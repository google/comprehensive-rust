msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust ü¶Ä\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust ü¶Ä"
msgstr "Bem-vindo ao Comprehensive Rust ü¶Ä"

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "Executando o Curso"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "Estrutura do Curso"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "Atalhos do Teclado"

#: src/SUMMARY.md:7
msgid "Using Cargo"
msgstr "Usando o Cargo"

#: src/SUMMARY.md:8
msgid "Rust Ecosystem"
msgstr "O Ecossistema do Rust"

#: src/SUMMARY.md:9
msgid "Code Samples"
msgstr "Amostras de C√≥digo"

#: src/SUMMARY.md:10
msgid "Running Cargo Locally"
msgstr "Executando o Cargo Localmente"

#: src/SUMMARY.md:13
msgid "Day 1: Morning"
msgstr "Dia 1: Manh√£"

#: src/SUMMARY.md:17 src/SUMMARY.md:73 src/SUMMARY.md:126 src/SUMMARY.md:182
msgid "Welcome"
msgstr "Bem-vindo"

#: src/SUMMARY.md:18
msgid "What is Rust?"
msgstr "O que √© Rust?"

#: src/SUMMARY.md:19
msgid "Hello World!"
msgstr "Ol√° Mundo!"

#: src/SUMMARY.md:20
msgid "Small Example"
msgstr "Um Pequeno Exemplo"

#: src/SUMMARY.md:21
msgid "Why Rust?"
msgstr "Por que Rust?"

#: src/SUMMARY.md:22
msgid "Compile Time Guarantees"
msgstr "Garantias em Tempo de Compila√ß√£o"

#: src/SUMMARY.md:23
msgid "Runtime Guarantees"
msgstr "Garantias em Tempo de Execu√ß√£o"

#: src/SUMMARY.md:24
msgid "Modern Features"
msgstr "Recursos Modernos"

#: src/SUMMARY.md:25
msgid "Basic Syntax"
msgstr "Sintaxe B√°sica"

#: src/SUMMARY.md:26
msgid "Scalar Types"
msgstr "Tipos Escalares"

#: src/SUMMARY.md:27
msgid "Compound Types"
msgstr "Tipos Compostos"

#: src/SUMMARY.md:28
msgid "References"
msgstr "Refer√™ncias"

#: src/SUMMARY.md:29
msgid "Dangling References"
msgstr "Refer√™ncias Pendentes"

#: src/SUMMARY.md:30
msgid "Slices"
msgstr "Slices"

#: src/SUMMARY.md:31
msgid "String vs str"
msgstr "String vs str"

#: src/SUMMARY.md:32
msgid "Functions"
msgstr "Fun√ß√µes"

#: src/SUMMARY.md:33 src/SUMMARY.md:80
msgid "Methods"
msgstr "M√©todos"

#: src/SUMMARY.md:34
msgid "Overloading"
msgstr "Sobrecarga"

#: src/SUMMARY.md:35 src/SUMMARY.md:64 src/SUMMARY.md:88 src/SUMMARY.md:117 src/SUMMARY.md:146 src/SUMMARY.md:174
#: src/SUMMARY.md:197 src/SUMMARY.md:224
msgid "Exercises"
msgstr "Exerc√≠cios"

#: src/SUMMARY.md:36
msgid "Implicit Conversions"
msgstr "Convers√µes Impl√≠citas"

#: src/SUMMARY.md:37
msgid "Arrays and for Loops"
msgstr "Vetores e La√ßos For"

#: src/SUMMARY.md:39
msgid "Day 1: Afternoon"
msgstr "Dia 1: Tarde"

#: src/SUMMARY.md:41
msgid "Variables"
msgstr "Vari√°veis"

#: src/SUMMARY.md:42
msgid "Type Inference"
msgstr "Infer√™ncia de Tipo"

#: src/SUMMARY.md:43
msgid "static & const"
msgstr "static & const"

#: src/SUMMARY.md:44
msgid "Scopes and Shadowing"
msgstr "Escopos e Sobreposi√ß√£o"

#: src/SUMMARY.md:45
msgid "Memory Management"
msgstr "Gerenciamento de Mem√≥ria"

#: src/SUMMARY.md:46
msgid "Stack vs Heap"
msgstr "Stack vs Heap"

#: src/SUMMARY.md:47
msgid "Stack Memory"
msgstr "Mem√≥ria de Pilha"

#: src/SUMMARY.md:48
msgid "Manual Memory Management"
msgstr "Gerenciamento Manual de Mem√≥ria"

#: src/SUMMARY.md:49
msgid "Scope-Based Memory Management"
msgstr "Gerenciamento de Mem√≥ria Baseado em Escopo"

#: src/SUMMARY.md:50
msgid "Garbage Collection"
msgstr "Garbage Collection (Coletor de lixo)"

#: src/SUMMARY.md:51
msgid "Rust Memory Management"
msgstr "Gerenciamento de Mem√≥ria do Rust"

#: src/SUMMARY.md:52
msgid "Comparison"
msgstr "Compara√ß√£o"

#: src/SUMMARY.md:53
msgid "Ownership"
msgstr "Ownership"

#: src/SUMMARY.md:54
msgid "Move Semantics"
msgstr "Sem√¢ntica do move (mover)"

#: src/SUMMARY.md:55
msgid "Moved Strings in Rust"
msgstr "Strings Movidas em Rust"

#: src/SUMMARY.md:56
msgid "Double Frees in Modern C++"
msgstr "Libera√ß√µes Duplas em C++ Moderno"

#: src/SUMMARY.md:57
msgid "Moves in Function Calls"
msgstr "Move em Chamadas de Fun√ß√£o"

#: src/SUMMARY.md:58
msgid "Copying and Cloning"
msgstr "Copiar e Clonar"

#: src/SUMMARY.md:59
msgid "Borrowing"
msgstr "Empr√©stimo"

#: src/SUMMARY.md:60
msgid "Shared and Unique Borrows"
msgstr "Empr√©stimos Compartilhados e √önicos"

#: src/SUMMARY.md:61
msgid "Lifetimes"
msgstr "Tempos de Vida (Lifetimes)"

#: src/SUMMARY.md:62
msgid "Lifetimes in Function Calls"
msgstr "Tempos de vida (Lifetimes) em Chamadas de Fun√ß√£o"

#: src/SUMMARY.md:63
msgid "Lifetimes in Data Structures"
msgstr "Tempos de Vida em Estruturas de Dados"

#: src/SUMMARY.md:65
msgid "Designing a Library"
msgstr "Projetando uma Biblioteca"

#: src/SUMMARY.md:66
msgid "Iterators and Ownership"
msgstr "Iteradores e Propriedade (Ownership)"

#: src/SUMMARY.md:69
msgid "Day 2: Morning"
msgstr "Dia 2: Manh√£"

#: src/SUMMARY.md:74
msgid "Structs"
msgstr "Structs"

#: src/SUMMARY.md:75
msgid "Tuple Structs"
msgstr "Structs como Tuplas"

#: src/SUMMARY.md:76
msgid "Field Shorthand Syntax"
msgstr "Sintaxe Abreviada de Campos"

#: src/SUMMARY.md:77
msgid "Enums"
msgstr "Enumera√ß√µes (Enums)"

#: src/SUMMARY.md:78
msgid "Variant Payloads"
msgstr "Variantes de Carga √ötil (payload)"

#: src/SUMMARY.md:79
msgid "Enum Sizes"
msgstr "Tamanhos de Enum"

#: src/SUMMARY.md:81
msgid "Method Receiver"
msgstr "Receptor de M√©todo"

#: src/SUMMARY.md:82 src/SUMMARY.md:157 src/SUMMARY.md:192
msgid "Example"
msgstr "Exemplo"

#: src/SUMMARY.md:83
msgid "Pattern Matching"
msgstr "Correspond√™ncia de Padr√µes"

#: src/SUMMARY.md:84
msgid "Destructuring Enums"
msgstr "Desestruturando Enums"

#: src/SUMMARY.md:85
msgid "Destructuring Structs"
msgstr "Desestruturando Structs"

#: src/SUMMARY.md:86
msgid "Destructuring Arrays"
msgstr "Desestruturando Vetores"

#: src/SUMMARY.md:87
msgid "Match Guards"
msgstr "Guardas de Correspond√™ncia (match)"

#: src/SUMMARY.md:89
msgid "Health Statistics"
msgstr "Estat√≠sticas de Sa√∫de"

#: src/SUMMARY.md:90
msgid "Points and Polygons"
msgstr "Pontos e Pol√≠gonos"

#: src/SUMMARY.md:92
msgid "Day 2: Afternoon"
msgstr "Dia 2: Tarde"

#: src/SUMMARY.md:94
msgid "Control Flow"
msgstr "Controle de Fluxo"

#: src/SUMMARY.md:95
msgid "Blocks"
msgstr "Blocos"

#: src/SUMMARY.md:96
msgid "if expressions"
msgstr "Express√µes Se (if)"

#: src/SUMMARY.md:97
msgid "if let expressions"
msgstr "Express√µes Se (if let)"

#: src/SUMMARY.md:98
msgid "while expressions"
msgstr "Express√µes Enquanto (while)"

#: src/SUMMARY.md:99
msgid "while let expressions"
msgstr "Express√µes Enquanto (while let)"

#: src/SUMMARY.md:100
msgid "for expressions"
msgstr "Express√µes Para (for)"

#: src/SUMMARY.md:101
msgid "loop expressions"
msgstr "Express√µes de La√ßo (loop)"

#: src/SUMMARY.md:102
msgid "match expressions"
msgstr "Express√µes de Correspond√™ncia (match)"

#: src/SUMMARY.md:103
msgid "break & continue"
msgstr "break e continue"

#: src/SUMMARY.md:104
msgid "Standard Library"
msgstr "Biblioteca Padr√£o"

#: src/SUMMARY.md:105
msgid "Option and Result"
msgstr "Option e Result"

#: src/SUMMARY.md:106
msgid "String"
msgstr "String"

#: src/SUMMARY.md:107
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:108
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:109
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:110
msgid "Recursive Data Types"
msgstr "Tipos de Dados Recursivos"

#: src/SUMMARY.md:111
msgid "Niche Optimization"
msgstr "Otimiza√ß√£o de Nicho"

#: src/SUMMARY.md:112
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:113
msgid "Modules"
msgstr "M√≥dulos"

#: src/SUMMARY.md:114
msgid "Visibility"
msgstr "Visibilidade"

#: src/SUMMARY.md:115
msgid "Paths"
msgstr "Caminhos"

#: src/SUMMARY.md:116
msgid "Filesystem Hierarchy"
msgstr "Hierarquia do Sistema de Arquivos"

#: src/SUMMARY.md:118
msgid "Luhn Algorithm"
msgstr "Algoritmo de Luhn"

#: src/SUMMARY.md:119
msgid "Strings and Iterators"
msgstr "Strings e Iteradores"

#: src/SUMMARY.md:122
msgid "Day 3: Morning"
msgstr "Dia 3: Manh√£"

#: src/SUMMARY.md:127
msgid "Traits"
msgstr "Traits"

#: src/SUMMARY.md:128
msgid "Deriving Traits"
msgstr "Traits Derivados"

#: src/SUMMARY.md:129
msgid "Default Methods"
msgstr "M√©todos Padr√£o"

#: src/SUMMARY.md:130
msgid "Important Traits"
msgstr "Traits Importantes"

#: src/SUMMARY.md:131
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:132
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:133
msgid "From and Into"
msgstr "From e Into"

#: src/SUMMARY.md:134
msgid "Read and Write"
msgstr "Read e Write"

#: src/SUMMARY.md:135
msgid "Add, Mul, ..."
msgstr "Add, Mul, ..."

#: src/SUMMARY.md:136
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:137
msgid "Default"
msgstr "Default"

#: src/SUMMARY.md:138
msgid "Generics"
msgstr "Generics"

#: src/SUMMARY.md:139
msgid "Generic Data Types"
msgstr "Tipos de Dados Gen√©ricos"

#: src/SUMMARY.md:140
msgid "Generic Methods"
msgstr "M√©todos Gen√©ricos"

#: src/SUMMARY.md:141
msgid "Trait Bounds"
msgstr "Limites de trait"

#: src/SUMMARY.md:142
msgid "impl Trait"
msgstr "Trait impl"

#: src/SUMMARY.md:143
msgid "Closures"
msgstr "Closures"

#: src/SUMMARY.md:144
msgid "Monomorphization"
msgstr "Monomorfiza√ß√£o"

#: src/SUMMARY.md:145
msgid "Trait Objects"
msgstr "Objetos Trait"

#: src/SUMMARY.md:147
msgid "A Simple GUI Library"
msgstr "Uma Biblioteca GUI Simples"

#: src/SUMMARY.md:149
msgid "Day 3: Afternoon"
msgstr "Dia 3: Tarde"

#: src/SUMMARY.md:151
msgid "Error Handling"
msgstr "Manipula√ß√£o de Erros"

#: src/SUMMARY.md:152
msgid "Panics"
msgstr "Panics (P√¢nico)"

#: src/SUMMARY.md:153
msgid "Catching Stack Unwinding"
msgstr "Capturando o Desenrolar da Pilha"

#: src/SUMMARY.md:154
msgid "Structured Error Handling"
msgstr "Tratamento Estruturado de Erros"

#: src/SUMMARY.md:155
msgid "Propagating Errors with ?"
msgstr "Propagando Erros com ?"

#: src/SUMMARY.md:156
msgid "Converting Error Types"
msgstr "Convertendo Tipos de Erro"

#: src/SUMMARY.md:158
msgid "Deriving Error Enums"
msgstr "Derivando Enums de Erro"

#: src/SUMMARY.md:159
msgid "Dynamic Error Types"
msgstr "Tipos de Erros Din√¢micos"

#: src/SUMMARY.md:160
msgid "Adding Context to Errors"
msgstr "Adicionando Contexto aos Erros"

#: src/SUMMARY.md:161
msgid "Testing"
msgstr "Testando"

#: src/SUMMARY.md:162
msgid "Unit Tests"
msgstr "Testes Unit√°rios"

#: src/SUMMARY.md:163
msgid "Test Modules"
msgstr "M√≥dulos de Teste"

#: src/SUMMARY.md:164
msgid "Documentation Tests"
msgstr "Testes de Documenta√ß√£o"

#: src/SUMMARY.md:165
msgid "Integration Tests"
msgstr "Testes de Integra√ß√£o"

#: src/SUMMARY.md:166
msgid "Unsafe Rust"
msgstr "Rust Inseguro (unsafe)"

#: src/SUMMARY.md:167
msgid "Dereferencing Raw Pointers"
msgstr "Desreferenciando Ponteiros Brutos"

#: src/SUMMARY.md:168
msgid "Mutable Static Variables"
msgstr "Vari√°veis Est√°ticas Mut√°veis"

#: src/SUMMARY.md:169
msgid "Unions"
msgstr "Uni√µes"

#: src/SUMMARY.md:170
msgid "Calling Unsafe Functions"
msgstr "Chamando Fun√ß√µes Inseguras"

#: src/SUMMARY.md:171
msgid "Writing Unsafe Functions"
msgstr "Escrevendo Fun√ß√µes Inseguras"

#: src/SUMMARY.md:172
msgid "Extern Functions"
msgstr "Fun√ß√µes Externas"

#: src/SUMMARY.md:173
msgid "Implementing Unsafe Traits"
msgstr "Implementando Traits Inseguros"

#: src/SUMMARY.md:175
msgid "Safe FFI Wrapper"
msgstr "Inv√≥lucro FFI seguro"

#: src/SUMMARY.md:178
msgid "Day 4: Morning"
msgstr "Dia 4: Manh√£"

#: src/SUMMARY.md:183
msgid "Concurrency"
msgstr "Concorr√™ncia"

#: src/SUMMARY.md:184
msgid "Threads"
msgstr "Threads"

#: src/SUMMARY.md:185
msgid "Scoped Threads"
msgstr "Threads com Escopo"

#: src/SUMMARY.md:186
msgid "Channels"
msgstr "Canais (channels)"

#: src/SUMMARY.md:187
msgid "Unbounded Channels"
msgstr "Canais Ilimitados"

#: src/SUMMARY.md:188
msgid "Bounded Channels"
msgstr "Canais Delimitados"

#: src/SUMMARY.md:189
msgid "Shared State"
msgstr "Estado Compartilhado"

#: src/SUMMARY.md:190
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:191
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:193
msgid "Send and Sync"
msgstr "Send e Sync"

#: src/SUMMARY.md:193
msgid "Send"
msgstr "Send"

#: src/SUMMARY.md:193
msgid "Sync"
msgstr "Sync"

#: src/SUMMARY.md:196
msgid "Examples"
msgstr "Exemplos"

#: src/SUMMARY.md:198
msgid "Dining Philosophers"
msgstr "Fil√≥sofos Jantando"

#: src/SUMMARY.md:199
msgid "Multi-threaded Link Checker"
msgstr "Verificador de Links Multi-Threads"

#: src/SUMMARY.md:201
msgid "Day 4: Afternoon"
msgstr "Dia 4: Tarde"

#: src/SUMMARY.md:205
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:206
msgid "Setup"
msgstr "Configurar"

#: src/SUMMARY.md:207
msgid "Build Rules"
msgstr "Regras de Constru√ß√£o"

#: src/SUMMARY.md:208
msgid "Binary"
msgstr "Bin√°rio"

#: src/SUMMARY.md:209
msgid "Library"
msgstr "Biblioteca"

#: src/SUMMARY.md:210
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:211
msgid "Interface"
msgstr "Interface"

#: src/SUMMARY.md:212
msgid "Implementation"
msgstr "Implementa√ß√£o"

#: src/SUMMARY.md:213
msgid "Server"
msgstr "Servidor"

#: src/SUMMARY.md:214
msgid "Deploy"
msgstr "Implantar"

#: src/SUMMARY.md:215
msgid "Client"
msgstr "Cliente"

#: src/SUMMARY.md:216
msgid "Changing API"
msgstr "Alterando API"

#: src/SUMMARY.md:217
msgid "Logging"
msgstr "Gerando Registros (Log)"

#: src/SUMMARY.md:218
msgid "Interoperability"
msgstr "Interoperabilidade"

#: src/SUMMARY.md:219
msgid "With C"
msgstr "Com C"

#: src/SUMMARY.md:220
msgid "Calling C with Bindgen"
msgstr "Chamando C com Bindgen"

#: src/SUMMARY.md:221
msgid "Calling Rust from C"
msgstr "Chamando Rust do C"

#: src/SUMMARY.md:222
msgid "With C++"
msgstr "Com C++"

#: src/SUMMARY.md:223
msgid "With Java"
msgstr "Com Java"

#: src/SUMMARY.md:226
msgid "Final Words"
msgstr "Palavras Finais"

#: src/SUMMARY.md:228
msgid "Thanks!"
msgstr "Obrigado!"

#: src/SUMMARY.md:229
msgid "Other Resources"
msgstr "Outros recursos"

#: src/SUMMARY.md:230
msgid "Credits"
msgstr "Cr√©ditos"

#: src/SUMMARY.md:234
msgid "Solutions"
msgstr "Solu√ß√µes"

#: src/SUMMARY.md:239
msgid "Day 1 Morning"
msgstr "Dia 1 Manh√£"

#: src/SUMMARY.md:240
msgid "Day 1 Afternoon"
msgstr "Dia 1 Tarde"

#: src/SUMMARY.md:241
msgid "Day 2 Morning"
msgstr "Dia 2 Manh√£"

#: src/SUMMARY.md:242
msgid "Day 2 Afternoon"
msgstr "Dia 2 Tarde"

#: src/SUMMARY.md:243
msgid "Day 3 Morning"
msgstr "Dia 3 Manh√£"

#: src/SUMMARY.md:244
msgid "Day 3 Afternoon"
msgstr "Dia 3 Tarde"

#: src/SUMMARY.md:245
msgid "Day 4 Morning"
msgstr "Dia 4 Manh√£"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust ü¶Ä"
msgstr "# Bem-vindo ao Comprehensive Rust ü¶Ä"

#: src/welcome.md:3
msgid ""
"This is a four day Rust course developed by the Android team. The course covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like generics\n"
"and error handling. It also includes Android-specific content on the last day."
msgstr ""
"Este √© um curso de Rust de quatro dias desenvolvido pela equipe do Android. O curso abrange\n"
"o espectro completo do Rust, desde a sintaxe b√°sica at√© t√≥picos avan√ßados como 'generics'\n"
"e tratamento de erros. Tamb√©m inclui conte√∫do espec√≠fico para Android no √∫ltimo dia."

#: src/welcome.md:7
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know anything\n"
"about Rust and hope to:"
msgstr ""
"O objetivo do curso √© ensinar Rust a voc√™. N√≥s assumimos que voc√™ n√£o sabe nada\n"
"sobre Rust e esperamos:"

#: src/welcome.md:10
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* Dar a voc√™ uma compreens√£o abrangente da linguagem e da sintaxe de Rust.\n"
"* Permitir que voc√™ modifique programas existentes e escreva novos programas em Rust.\n"
"* Demonstrar express√µes idiom√°ticas comuns de Rust."

#: src/welcome.md:14
msgid "On Day 4, we will cover Android-specific things such as:"
msgstr "No Dia 4, abordaremos assuntos espec√≠ficos do Android, como:"

#: src/welcome.md:16
msgid ""
"* Building Android components in Rust.\n"
"* AIDL servers and clients.\n"
"* Interoperability with C, C++, and Java."
msgstr ""
"* Construindo componentes Android em Rust.\n"
"* Servidores e clientes AIDL.\n"
"* Interoperabilidade com C, C++ e Java."

#: src/welcome.md:20
msgid ""
"It is important to note that this course does not cover Android **application** \n"
"development in Rust, and that the Android-specific parts are specifically about\n"
"writing code for Android itself, the operating system. "
msgstr ""
"√â importante observar que este curso n√£o cobre o desenvolvimento de **aplicativos** para Android\n"
"em Rust, e que as partes espec√≠ficas do Android s√£o relacionadas a\n"
"escrever c√≥digo para o sistema operacional Android."

#: src/welcome.md:24
msgid "## Non-Goals"
msgstr "## Fora do escopo"

#: src/welcome.md:26
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few days.\n"
"Some non-goals of this course are:"
msgstr ""
"Rust √© uma linguagem extensa e n√£o conseguiremos cobrir tudo em poucos dias.\n"
"Alguns assuntos que n√£o s√£o objetivos deste curso s√£o:"

#: src/welcome.md:29
msgid ""
"* Learn how to use async Rust --- we'll only mention async Rust when\n"
"  covering traditional concurrency primitives. Please see [Asynchronous\n"
"  Programming in Rust](https://rust-lang.github.io/async-book/) instead for\n"
"  details on this topic.\n"
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* Uso de async Rust --- s√≥ mencionaremos o async Rust quando\n"
"  cobrirmos primitivas de concorr√™ncia tradicionais. Consulte [Ass√≠ncrono\n"
"  Programa√ß√£o em Rust](https://rust-lang.github.io/async-book/) para mais\n"
"  detalhes sobre este tema.\n"
"* Desenvolvimento de macros, consulte [Cap√≠tulo 19.5 no Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) e [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) em vez disso."

#: src/welcome.md:37
msgid "## Assumptions"
msgstr "## Suposi√ß√µes"

#: src/welcome.md:39
msgid ""
"The course assumes that you already know how to program. Rust is a statically\n"
"typed language and we will sometimes make comparisons with C and C++ to better\n"
"explain or contrast the Rust approach."
msgstr ""
"O curso pressup√µe que voc√™ j√° saiba programar. Rust √© uma linguagem de tipagem est√°tica\n"
"e √†s vezes comparamos com C e C++ para melhor\n"
"explicar ou contrastar a abordagem Rust."

#: src/welcome.md:43
msgid ""
"If you know how to program in a dynamically typed language such as Python or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Se voc√™ sabe programar em uma linguagem de tipagem din√¢mica, como Python ou\n"
"JavaScript, ent√£o voc√™ tamb√©m ser√° capaz de acompanhar."

#: src/welcome.md:46 src/cargo/rust-ecosystem.md:19 src/cargo/code-samples.md:22 src/cargo/running-locally.md:68
#: src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19 src/hello-world.md:20 src/hello-world/small-example.md:21
#: src/why-rust.md:9 src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8 src/why-rust/modern.md:19
#: src/basic-syntax/compound-types.md:28 src/basic-syntax/slices.md:18 src/basic-syntax/string-slices.md:25
#: src/basic-syntax/functions.md:33 src/basic-syntax/functions-interlude.md:25 src/exercises/day-1/morning.md:9
#: src/exercises/day-1/for-loops.md:90 src/basic-syntax/variables.md:15 src/basic-syntax/type-inference.md:24
#: src/basic-syntax/static-and-const.md:46 src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20 src/ownership/moves-function-calls.md:18
#: src/ownership/copy-clone.md:33 src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27 src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/structs/tuple-structs.md:35 src/structs/field-shorthand.md:25
#: src/enums/variant-payloads.md:33 src/methods.md:28 src/pattern-matching/destructuring-enums.md:33
#: src/pattern-matching/destructuring-arrays.md:18 src/pattern-matching/match-guards.md:20 src/exercises/day-2/morning.md:9
#: src/exercises/day-2/points-polygons.md:115 src/control-flow/blocks.md:40 src/control-flow/if-expressions.md:29
#: src/control-flow/if-let-expressions.md:19 src/control-flow/while-let-expressions.md:25 src/std/option-result.md:16
#: src/std/string.md:28 src/std/vec.md:35 src/std/hashmap.md:36 src/std/box.md:32 src/std/rc.md:29 src/modules.md:26
#: src/modules/visibility.md:37 src/exercises/day-2/afternoon.md:5 src/traits.md:39 src/traits/iterator.md:30
#: src/traits/from-iterator.md:15 src/traits/operators.md:24 src/traits/drop.md:32 src/traits/default.md:38
#: src/generics/methods.md:23 src/generics/trait-bounds.md:33 src/generics/impl-trait.md:22 src/generics/closures.md:23
#: src/exercises/day-3/morning.md:5 src/error-handling/result.md:25 src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:48 src/error-handling/deriving-error-enums.md:37
#: src/error-handling/dynamic-errors.md:34 src/error-handling/error-contexts.md:33 src/unsafe.md:26
#: src/unsafe/raw-pointers.md:24 src/unsafe/mutable-static-variables.md:30 src/unsafe/unions.md:19
#: src/unsafe/writing-unsafe-functions.md:31 src/unsafe/extern-functions.md:19 src/unsafe/unsafe-traits.md:28
#: src/exercises/day-3/afternoon.md:5 src/concurrency/threads.md:28 src/concurrency/channels.md:25
#: src/concurrency/shared_state/arc.md:27 src/concurrency/shared_state/example.md:21 src/concurrency/send-sync.md:18
#: src/concurrency/send-sync/sync.md:12 src/exercises/day-4/morning.md:10 src/android/interoperability/with-c/rust.md:81
#: src/exercises/day-4/afternoon.md:10
msgid "<details>"
msgstr "<details>"

#: src/welcome.md:48
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"Este √© um exemplo de _nota do instrutor_. N√≥s os usaremos para adicionar\n"
"informa√ß√µes aos slides. Estes podem ser pontos chave em que o instrutor deve\n"
"cobrir respostas √† perguntas t√≠picas que surgem em sala de aula."

#: src/welcome.md:52 src/cargo/rust-ecosystem.md:67 src/cargo/code-samples.md:35 src/cargo/running-locally.md:74
#: src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29 src/hello-world.md:36 src/hello-world/small-example.md:44
#: src/why-rust.md:24 src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22 src/why-rust/modern.md:66
#: src/basic-syntax/compound-types.md:62 src/basic-syntax/references.md:28 src/basic-syntax/slices.md:36
#: src/basic-syntax/functions.md:54 src/exercises/day-1/morning.md:28 src/exercises/day-1/for-loops.md:95
#: src/basic-syntax/variables.md:20 src/basic-syntax/type-inference.md:48 src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49 src/memory-management/rust.md:18
#: src/ownership/move-semantics.md:26 src/ownership/moves-function-calls.md:26 src/ownership/borrowing.md:51
#: src/ownership/shared-unique-borrows.md:29 src/ownership/lifetimes-function-calls.md:60 src/exercises/day-1/afternoon.md:15
#: src/exercises/day-1/book-library.md:103 src/structs.md:41 src/enums/variant-payloads.md:41 src/enums/sizes.md:136
#: src/methods/example.md:53 src/pattern-matching/destructuring-enums.md:39 src/exercises/day-2/morning.md:15
#: src/exercises/day-2/points-polygons.md:125 src/control-flow/if-let-expressions.md:26 src/control-flow/for-expressions.md:29
#: src/control-flow/loop-expressions.md:27 src/std.md:31 src/std/option-result.md:25 src/std/string.md:34 src/std/vec.md:49
#: src/std/hashmap.md:40 src/std/rc.md:66 src/modules.md:32 src/modules/visibility.md:48 src/exercises/day-2/afternoon.md:11
#: src/traits.md:54 src/traits/from-iterator.md:26 src/traits/operators.md:38 src/traits/drop.md:42 src/traits/default.md:47
#: src/generics/methods.md:31 src/generics/closures.md:38 src/exercises/day-3/morning.md:11
#: src/error-handling/try-operator.md:55 src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45 src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32 src/unsafe/raw-pointers.md:42
#: src/unsafe/mutable-static-variables.md:35 src/unsafe/unions.md:28 src/unsafe/writing-unsafe-functions.md:38
#: src/unsafe/extern-functions.md:28 src/unsafe/unsafe-traits.md:37 src/exercises/day-3/afternoon.md:11
#: src/concurrency/threads.md:45 src/concurrency/channels.md:32 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/example.md:60 src/concurrency/send-sync/sync.md:18 src/exercises/day-4/morning.md:16
#: src/android/interoperability/with-c/rust.md:86 src/exercises/day-4/afternoon.md:15
msgid "</details>"
msgstr "</details>"

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# Executando o curso"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "> This page is for the course instructor."
msgstr "> Esta p√°gina √© para o instrutor do curso."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the course\n"
"internally at Google."
msgstr ""
"Aqui est√£o algumas informa√ß√µes b√°sicas sobre como estamos conduzindo o curso\n"
"internamente no Google."

#: src/running-the-course.md:8
msgid "To run the course, you need to:"
msgstr "Para executar o curso, voc√™ precisa:"

#: src/running-the-course.md:10
msgid ""
"1. Make yourself familiar with the course material. We've included speaker notes\n"
"   on some of the pages to help highlight the key points (please help us by\n"
"   contributing more speaker notes!). You should make sure to open the speaker\n"
"   notes in a popup (click the link with a little arrow next to \"Speaker\n"
"   Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"1. Familiarize-se com o material do curso. Inclu√≠mos notas do instrutor\n"
"   em algumas das p√°ginas para ajudar a destacar os pontos chave (por favor, ajude-nos\n"
"   contribuindo com mais notas do instrutor!). Voc√™ deve certificar-se de abrir as notas\n"
"   do instrutor em um pop-up (clique no link com uma pequena seta ao lado de \"Speaker\n"
"   Notes\"). Dessa forma, voc√™ tem uma tela limpa para apresentar √† turma."

#: src/running-the-course.md:16
msgid ""
"2. Decide on the dates. Since the course is large, we recommend that you\n"
"   schedule the four days over two weeks. Course participants have said that\n"
"   they find it helpful to have a gap in the course since it helps them process\n"
"   all the information we give them."
msgstr ""
"2. Decida as datas. Como o curso √© grande, recomendamos que voc√™\n"
"   agende os quatro dias em duas semanas. Os participantes do curso disseram que\n"
"   eles acham √∫til ter uma pausa no curso, pois os ajuda a processar\n"
"   todas as informa√ß√µes que lhes damos."

#: src/running-the-course.md:21
msgid ""
"3. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-20 people. That's small enough that people are comfortable\n"
"   asking questions --- it's also small enough that one instructor will have\n"
"   time to answer the questions."
msgstr ""
"3. Encontre uma sala suficientemente grande para seus participantes presenciais. Recomendamos\n"
"   turmas de 15 a 20 pessoas. Isso √© suficientemente pequeno para que as pessoas se sintam confort√°veis\n"
"   em fazer perguntas --- e para que um instrutor tenha\n"
"   tempo para responder √†s perguntas."

#: src/running-the-course.md:26
msgid ""
"4. On the day of your course, show up to the room a little early to set things\n"
"   up. We recommend presenting directly using `mdbook serve` running on your\n"
"   laptop (see the [installation instructions][5]). This ensures optimal performance with no lag as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them."
msgstr ""
"4. No dia do seu curso, chegue um pouco mais cedo na sala para acertar as coisas.\n"
"   Recomendamos apresentar diretamente usando `mdbook serve` rodando em seu\n"
"   laptop. Isso garante um desempenho ideal sem atrasos quando voc√™ muda de p√°gina.\n"
"   Usar seu laptop tamb√©m permitir√° que voc√™ corrija erros de digita√ß√£o enquanto voc√™ ou\n"
"   os participantes os identificam."

#: src/running-the-course.md:32
msgid ""
"5. Let people solve the exercises by themselves or in small groups. Make sure to\n"
"   ask people if they're stuck or if there is anything you can help with. When\n"
"   you see that several people have the same problem, call it out to the class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"5. Deixe as pessoas resolverem os exerc√≠cios sozinhas ou em pequenos grupos. Tenha certeza de\n"
"   perguntar √†s pessoas se elas est√£o com dificuldades ou se h√° algo em que voc√™ possa ajudar. Quando\n"
"   voc√™ v√™ que v√°rias pessoas t√™m o mesmo problema, chame a turma\n"
"   e ofere√ßa uma solu√ß√£o, por exemplo, mostrando √†s pessoas onde encontrar as informa√ß√µes relevantes\n"
"   na biblioteca padr√£o."

#: src/running-the-course.md:38
msgid ""
"6. If you don't skip the Android specific parts on Day 4, you will need an [AOSP\n"
"   checkout][1]. Make a checkout of the [course repository][2] on the same\n"
"   machine and move the `src/android/` directory into the root of your AOSP\n"
"   checkout. This will ensure that the Android build system sees the\n"
"   `Android.bp` files in `src/android/`."
msgstr ""
"6. Se voc√™ n√£o pular as partes espec√≠ficas do Android no Dia 4, precisar√° de um [checkout\n"
"   do AOSP][1]. Fa√ßa um checkout do [reposit√≥rio do curso][2] no mesmo\n"
"   computador e mova o diret√≥rio `src/android/` para a raiz do seu checkout doAOSP.\n"
"   Isso garantir√° que o sistema de compila√ß√£o do Android veja os\n"
"   arquivos `Android.bp` em `src/android/`."

#: src/running-the-course.md:44
msgid ""
"   Ensure that `adb sync` works with your emulator or real device and pre-build\n"
"   all Android examples using `src/android/build_all.sh`. Read the script to see\n"
"   the commands it runs and make sure they work when you run them by hand."
msgstr ""
"   Certifique-se de que `adb sync` funcione com seu emulador ou dispositivo real e pr√©-compile\n"
"   todos os exemplos do Android usando `src/android/build_all.sh`. Leia o roteiro para ver\n"
"   os comandos executados e verifique se eles funcionam quando voc√™ os executa manualmente."

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun for\n"
"you as it has been for us!"
msgstr ""
"Isso √© tudo, boa sorte no curso! Esperamos que seja t√£o divertido para\n"
"voc√™ como tem sido para n√≥s!"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback][3] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][4]!"
msgstr ""
"Por favor, [forne√ßa feedback][3] depois para que possamos continuar melhorando o\n"
"curso. Adorar√≠amos saber o que funcionou bem para voc√™ e o que pode ser melhorado.\n"
" Seus alunos tamb√©m s√£o muito bem-vindos para [nos enviar feedback][4]!"

#: src/running-the-course.md:55
msgid ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100\n"
"[5]: https://github.com/google/comprehensive-rust#building"
msgstr ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100"

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# Estrutura do curso"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "O curso √© r√°pido e muito abrangente:"

#: src/running-the-course/course-structure.md:7
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust.\n"
"* Day 4: Concurrency in Rust and interoperability with other languages"
msgstr ""
"* Dia 1: Rust b√°sico, ownership e verificador de empr√©stimo.\n"
"* Dia 2: Tipos de dados compostos, correspond√™ncia de padr√µes e a biblioteca padr√£o.\n"
"* Dia 3: Traits e generics, tratamento de erros, testes e Rust inseguro.\n"
"* Dia 4: Concorr√™ncia em Rust e interoperabilidade com outras linguagens"

#: src/running-the-course/course-structure.md:12
msgid ""
"> **Exercise for Day 4:** Do you interface with some C/C++ code in your project\n"
"> which we could attempt to move to Rust? The fewer dependencies the better.\n"
"> Parsing code would be ideal."
msgstr ""
"> **Exerc√≠cio para o dia 4:** Voc√™ faz interface com algum c√≥digo C/C++ em seu projeto\n"
"> que poder√≠amos tentar mover para Rust? Quanto menos depend√™ncias, melhor.\n"
"> Analisar o c√≥digo seria o ideal."

#: src/running-the-course/course-structure.md:16
msgid "## Format"
msgstr "## Formato"

#: src/running-the-course/course-structure.md:18
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr ""
"O curso pretende ser muito interativo e recomendamos deixar as\n"
"perguntas conduzirem a explora√ß√£o de Rust!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# Atalhos do teclado"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Existem v√°rios atalhos de teclado √∫teis no mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Seta para a esquerda</kbd>: Navega para a p√°gina anterior.\n"
"* <kbd>Seta para a direita</kbd>: Navega para a pr√≥xima p√°gina.\n"
"* <kbd>Ctrl + Enter</kbd>: Executa o exemplo de c√≥digo que tem o foco.\n"
"* <kbd>s</kbd>: ativa a barra de pesquisa."

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# Usando o Cargo"

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc.rust-lang.org/cargo/), the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want to\n"
"give a brief overview of what Cargo is and how it fits into the wider ecosystem\n"
"and how it fits into this training."
msgstr ""
"Quando voc√™ come√ßar a ler sobre Rust, logo conhecer√° o [Cargo](https://doc.rust-lang.org/cargo/), a ferramenta padr√£o\n"
"usada no ecossistema Rust para criar e executar aplicativos Rust. Aqui n√≥s queremos\n"
"dar uma breve vis√£o geral do que √© o Cargo e como ele se encaixa no ecossistema mais amplo\n"
"e como ele se encaixa neste treinamento."

#: src/cargo.md:8
msgid "## Installation"
msgstr "## Instala√ß√£o"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "### Rustup (Recomendado)"

#: src/cargo.md:12
msgid ""
"You can follow the instructions to install cargo and rust compiler, among other standard ecosystem tools with the [rustup]"
"[3] tool, which is maintained by the Rust Foundation."
msgstr ""
"Voc√™ pode seguir as instru√ß√µes para instalar o cargo e o compilador de Rust, entre outras ferramentas padr√£o do ecossistema "
"com a ferramenta [rustup][3], que √© mantida pela Rust Foundation."

#: src/cargo.md:14
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line utility that you can use to install/switch "
"toolchains, setup cross compilation, etc."
msgstr ""
"Juntamente com cargo e rustc, o Rustup se instalar√° como um utilit√°rio de linha de comando que voc√™ pode usar para instalar/"
"alternar ferramentas, configurar compila√ß√£o cruzada, etc."

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### Gerenciadores de pacotes"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
msgid "On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust formatter][6] with"
msgstr "No Debian/Ubuntu, voc√™ pode instalar o Cargo e o fonte Rust com"

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""
"```shell\n"
"$ sudo apt install cargo rust-src\n"
"```"

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"Isso permitir√° que o [rust-analyzer][1] localize as defini√ß√µes. Sugerimos usar o\n"
"[VS Code][2] para editar o c√≥digo (mas qualquer editor compat√≠vel com LSP funciona)."

#: src/cargo.md:29
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do their own analysis but have their own tradeoffs. If "
"you prefer them, you can install the [Rust Plugin][5]. Please take note that as of January 2023 debugging only works on the "
"CLion version of the JetBrains IDEA suite."
msgstr ""
"Algumas pessoas tamb√©m gostam de usar a fam√≠lia de IDEs [JetBrains][4], que fazem suas pr√≥prias an√°lises, mas t√™m suas "
"pr√≥prias vantagens e desvantagens. Se voc√™ preferir, pode instalar o [Plugin Rust][5]. Observe que, a partir de Janeiro de "
"2023, a depura√ß√£o funciona apenas na vers√£o CLion do pacote JetBrains IDEA."

#: src/cargo.md:31
msgid ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/\n"
"[6]: https://github.com/rust-lang/rustfmt"
msgstr ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/"

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# O ecossistema do Rust"

#: src/cargo/rust-ecosystem.md:3
msgid "The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "O ecossistema Rust consiste em v√°rias ferramentas, das quais as principais s√£o:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and other\n"
"  intermediate formats."
msgstr ""
"* `rustc`: o compilador Rust que transforma arquivos `.rs` em bin√°rios e outros\n"
"  formatos intermedi√°rios[^rustc]."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests."
msgstr ""
"* `cargo`: o gerenciador de depend√™ncias Rust e a ferramenta de compila√ß√£o. O Cargo sabe como\n"
"  baixar as depend√™ncias hospedadas em <https://crates.io> e as passar√° para\n"
"  o `rustc` ao compilar o seu projeto. O Cargo tamb√©m vem com um executor de testes\n"
"  embutido que √© usado para executar testes unit√°rios."

#: src/cargo/rust-ecosystem.md:13
msgid ""
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and `rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustup`: o instalador e atualizador do toolchain do Rust. Esta ferramenta √© utilizada para\n"
"  instalar e atualizar o `rustc` e o `cargo` quando novas vers√µes do Rust forem lan√ßadas.\n"
"  Al√©m disso, `rustup` tamb√©m pode baixar a documenta√ß√£o da biblioteca\n"
"  padr√£o. Voc√™ pode ter v√°rias vers√µes do Rust instaladas ao mesmo tempo e `rustup`\n"
"  permitir√° que voc√™ alterne entre elas conforme necess√°rio."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25 src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30 src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:50 src/concurrency/threads.md:30
msgid "Key points:"
msgstr "Pontos chave:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality."
msgstr ""
"* Rust tem um r√°pido cronograma de lan√ßamento com um novo lan√ßamento saindo\n"
"  a cada seis semanas. Novos lan√ßamentos mant√™m compatibilidade com vers√µes anteriores\n"
"  --- al√©m disso, eles permitem novas funcionalidades."

#: src/cargo/rust-ecosystem.md:27
msgid "* There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "* Existem tr√™s canais de lan√ßamento: \"stable\", \"beta\" e \"nightly\"."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks."
msgstr ""
"* Novos recursos est√£o sendo testados em \"nightly\", \"beta\" √© o que se torna\n"
"  \"est√°vel\" a cada seis semanas."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018."
msgstr ""
"* Rust tamb√©m tem [edi√ß√µes]: a edi√ß√£o atual √© Rust 2021. Edi√ß√µes\n"
"  anteriores foram Rust 2015 e Rust 2018."

#: src/cargo/rust-ecosystem.md:35
msgid ""
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language."
msgstr ""
"  * As edi√ß√µes podem fazer altera√ß√µes incompat√≠veis com vers√µes anteriores\n"
"    da linguagem."

#: src/cargo/rust-ecosystem.md:38
msgid ""
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file."
msgstr ""
"  * Para evitar rupturas, as edi√ß√µes s√£o opcionais: voc√™ seleciona a\n"
"    edi√ß√£o para o seu crate atrav√©s do arquivo `Cargo.toml`."

#: src/cargo/rust-ecosystem.md:41
msgid ""
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions."
msgstr ""
"  * Para evitar a divis√£o do ecossistema, os compiladores Rust podem misturar c√≥digo\n"
"    escrito para diferentes edi√ß√µes."

#: src/cargo/rust-ecosystem.md:44
msgid "  * Mention that it is quite rare to ever use the compiler directly not through `cargo` (most users never do)."
msgstr ""
"  * Mencione que √© muito raro usar o compilador diretamente, n√£o atrav√©s do `cargo` (a maioria dos usu√°rios nunca o faz)."

#: src/cargo/rust-ecosystem.md:46
msgid ""
"  * It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  It is capable of many "
"advanced features including but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as [cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"  * Pode valer a pena mencionar que o Cargo √© uma ferramenta extremamente poderosa e abrangente. Ele √© capaz de muitos "
"recursos avan√ßados, incluindo, entre outros:\n"
"      * Estrutura do projeto/pacote\n"
"      * [workspaces]\n"
"      * Gerenciamento de depend√™ncias de desenvolvimento e depend√™ncias de tempo de execu√ß√£o/cache\n"
"      * [scripts de compila√ß√£o]\n"
"      * [instala√ß√£o global]\n"
"      * Tamb√©m √© extens√≠vel com plugins de subcomando (como [cargo clippy]).\n"
"  * Leia mais no [livro oficial do Cargo]"

#: src/cargo/rust-ecosystem.md:55
msgid "[editions]: https://doc.rust-lang.org/edition-guide/"
msgstr "[edi√ß√µes]: https://doc.rust-lang.org/edition-guide/"

#: src/cargo/rust-ecosystem.md:57
msgid "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"
msgstr "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"

#: src/cargo/rust-ecosystem.md:59
msgid "[build scripting]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"
msgstr "[scripts de compila√ß√£o]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"

#: src/cargo/rust-ecosystem.md:61
msgid "[global installation]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"
msgstr "[instala√ß√£o global]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"

#: src/cargo/rust-ecosystem.md:63
msgid "[cargo clippy]: https://github.com/rust-lang/rust-clippy"
msgstr "[cargo clippy]: https://github.com/rust-lang/rust-clippy"

#: src/cargo/rust-ecosystem.md:65
msgid "[official Cargo Book]: https://doc.rust-lang.org/cargo/"
msgstr "[livro oficial do Cargo]: https://doc.rust-lang.org/cargo/"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# Exemplos de c√≥digo neste treinamento"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples\n"
"which can be executed through your browser. This makes the setup much easier and\n"
"ensures a consistent experience for everyone."
msgstr ""
"Para este treinamento, exploraremos principalmente a linguagem Rust por meio de exemplos\n"
"que podem ser executados atrav√©s do seu navegador. Isso torna a instala√ß√£o muito mais f√°cil e\n"
"garante uma experi√™ncia consistente para todos."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do the\n"
"exercises. On the last day, we will do a larger exercise which shows you how to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"A instala√ß√£o do Cargo ainda assim √© incentivada: ser√° mais f√°cil para voc√™ fazer os\n"
"exerc√≠cios. No √∫ltimo dia, faremos um exerc√≠cio maior que mostra como\n"
"trabalhar com depend√™ncias e para isso voc√™ precisar√° do Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "Os blocos de c√≥digo neste curso s√£o totalmente interativos:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    println!(\"Edite-me!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the\n"
"text box."
msgstr ""
"Voc√™ pode usar <kbd>Ctrl + Enter</kbd> para executar o c√≥digo quando o foco estiver na\n"
"caixa de texto."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr ""
"A maioria dos exemplos de c√≥digo s√£o edit√°veis, como mostrado acima. Alguns exemplos de c√≥digo\n"
"n√£o s√£o edit√°veis por v√°rios motivos:"

#: src/cargo/code-samples.md:27
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests."
msgstr ""
"* Os playgrounds incorporados n√£o podem executar testes unit√°rios. Copie e cole o\n"
"  c√≥digo e abra-o no Playground real para demonstrar os testes unit√°rios."

#: src/cargo/code-samples.md:30
msgid ""
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* Os playgrounds embutidos perdem seu estado no momento em que voc√™ navega\n"
"  fora da p√°gina! Esta √© a raz√£o pela qual os alunos devem\n"
"  resolver os exerc√≠cios usando uma instala√ß√£o Rust local ou via\n"
"  Playground."

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# Executando c√≥digo localmente com o Cargo"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"Se voc√™ quiser experimentar o c√≥digo em seu pr√≥prio sistema, precisar√°\n"
"primeiro instalar o Rust. Fa√ßa isso seguindo as [instru√ß√µes][1].\n"
"Isso deve fornecer o `rustc` e o `cargo` funcionando. Ao escrever\n"
"Este curso, a √∫ltima vers√£o est√°vel do Rust √©:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""
"```shell\n"
"% rustc --version\n"
"rust 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"

#: src/cargo/running-locally.md:15
msgid ""
"With this is in place, then follow these steps to build a Rust binary from one\n"
"of the examples in this training:"
msgstr ""
"Com isso finalizado, siga estas etapas para criar um bin√°rio Rust a partir de um\n"
"dos exemplos deste treinamento:"

#: src/cargo/running-locally.md:18
msgid "1. Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "1. Clique no bot√£o \"Copiar para a √°rea de transfer√™ncia\" no exemplo que deseja copiar."

#: src/cargo/running-locally.md:20
msgid "2. Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr "2. Use `cargo new exercise` para criar um novo diret√≥rio `exercise/` para o seu c√≥digo:"

#: src/cargo/running-locally.md:22
msgid ""
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:27
msgid "3. Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr "3. Navegue at√© `exercise/` e use `cargo run` para compilar e executar seu bin√°rio:"

#: src/cargo/running-locally.md:29
msgid ""
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:38
msgid ""
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"4. Substitua o c√≥digo de exemplo em `src/main.rs` pelo seu pr√≥prio c√≥digo. Por\n"
"   exemplo, usando o c√≥digo da p√°gina anterior, fa√ßa `src/main.rs` parecer"

#: src/cargo/running-locally.md:41
msgid ""
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:47
msgid "5. Use `cargo run` to build and run your updated binary:"
msgstr "5. Use `cargo run` para compilar e executar seu bin√°rio atualizado:"

#: src/cargo/running-locally.md:49
msgid ""
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:57
msgid ""
"6. Use `cargo check` to quickly check your project for errors, use `cargo build`\n"
"   to compile it without running it. You will find the output in `target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an optimized\n"
"   release build in `target/release/`."
msgstr ""
"6. Use `cargo check` para verificar rapidamente se h√° erros em seu projeto, use `cargo build`\n"
"   para compil√°-lo sem execut√°-lo. Voc√™ encontrar√° a sa√≠da em `target/debug/`\n"
"   para uma compila√ß√£o de depura√ß√£o. Use `cargo build --release` para produzir um bin√°rio\n"
"   otimizado em `target/release/`."

#: src/cargo/running-locally.md:62
msgid ""
"7. You can add dependencies for your project by editing `Cargo.toml`. When you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""
"7. Voc√™ pode adicionar depend√™ncias ao seu projeto editando `Cargo.toml`. Quando voc√™\n"
"   executar os comandos `cargo`, ele ir√° baixar e compilar automaticamente\n"
"   as depend√™ncias para voc√™."

#: src/cargo/running-locally.md:66
msgid "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"
msgstr "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"Tente encorajar os participantes do curso a instalar o Cargo e usar um\n"
"editor local. Isso facilitar√° a vida deles, pois eles ter√£o um\n"
"ambiente normal de desenvolvimento."

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# Bem-vindo ao Dia 1"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr ""
"Este √© o primeiro dia do Comprehensive Rust. N√≥s cobriremos muitos pontos\n"
"hoje:"

#: src/welcome-day-1.md:6
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods."
msgstr ""
"* Sintaxe b√°sica do Rust: vari√°veis, tipos escalares e compostos, enums, structs,\n"
"  refer√™ncias, fun√ß√µes e m√©todos."

#: src/welcome-day-1.md:9
msgid ""
"* Memory management: stack vs heap, manual memory management, scope-based memory\n"
"  management, and garbage collection."
msgstr ""
"* Gerenciamento de mem√≥ria: stack versus heap, gerenciamento manual de mem√≥ria, gerenciamento de mem√≥ria\n"
"   baseada em escopo e garbage collection (coleta de lixo)."

#: src/welcome-day-1.md:12
msgid "* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr "* Ownership: sem√¢ntica de movimento, c√≥pia e clonagem, empr√©stimo e tempos de vida."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Lembre aos alunos que:"

#: src/welcome-day-1.md:18
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, i.e.,\n"
"    keep the related to how Rust does things vs some other language. It can be\n"
"    hard to find the right balance, but err on the side of allowing discussions\n"
"    since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we talk about things ahead of the slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* Eles devem fazer perguntas na hora, n√£o as guarde para o fim.\n"
"* A aula √© para ser interativa e as discuss√µes s√£o muito encorajadas!\n"
"  * Como instrutor, voc√™ deve tentar manter as discuss√µes relevantes, ou seja,\n"
"    mantenha o que √© relacionado a como o Rust faz as coisas versus alguma outra linguagem. Pode ser\n"
"    dif√≠cil encontrar o equil√≠brio certo, mas erra ao permitir discuss√µes\n"
"    uma vez que envolvem as pessoas muito mais do que uma comunica√ß√£o unidirecional.\n"
"* As perguntas provavelmente parecer√£o que estamos falando sobre as coisas antes dos slides.\n"
"  * Isso est√° perfeitamente OK! A repeti√ß√£o √© uma parte importante do aprendizado. Lembre-se\n"
"    que os slides s√£o apenas um suporte e voc√™ est√° livre para ignor√°-los quando\n"
"    quiser."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to speak\n"
"about the famous borrow checker. The way Rust handles memory is a major feature\n"
"and we should show students this right away."
msgstr ""
"A ideia para o primeiro dia √© mostrar _apenas o suficiente_ de Rust para poder falar\n"
"sobre o famoso verificador de empr√©stimos. A maneira como o Rust lida com a mem√≥ria √© uma caracter√≠stica importante\n"
"e devemos mostrar isso aos alunos imediatamente."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Se voc√™ estiver ensinando isso em uma sala de aula, este √© um bom lugar para repassar\n"
"o cronograma. Sugerimos dividir o dia em duas partes (seguindo os slides):"

#: src/welcome-day-1.md:36
msgid ""
"* Morning: 9:00 to 12:00,\n"
"* Afternoon: 13:00 to 16:00."
msgstr ""
"* Manh√£: 9h √†s 12h,\n"
"* Tarde: 13h √†s 16h."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include breaks,\n"
"we recommend a break every hour!"
msgstr ""
"√â claro que voc√™ pode ajustar isso conforme necess√°rio. Certifique-se de incluir pausas,\n"
" Recomendamos uma pausa a cada hora!"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# O que √© Rust?"

#: src/welcome-day-1/what-is-rust.md:3
msgid "Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr "Rust √© uma nova linguagem de programa√ß√£o que teve sua vers√£o 1.0 lan√ßada em 2015:"

#: src/welcome-day-1/what-is-rust.md:5
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust √© uma linguagem compilada estaticamente e tem um papel semelhante ao C++\n"
"  * `rustc` usa o LLVM como back-end.\n"
"* Rust suporta muitas [plataformas e\n"
"  arquiteturas](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust √© usado em uma ampla gama de dispositivos:\n"
"  * firmware e carregadores de boot,\n"
"  * monitores inteligentes,\n"
"  * celulares,\n"
"  * desktops,\n"
"  * servidores."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust se encaixa na mesma √°rea que C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* Alta flexibilidade.\n"
"* Alto n√≠vel de controle.\n"
"* Pode ser reduzido para dispositivos com menos poder computacional, como telefones celulares.\n"
"* N√£o tem runtime ou garbage collection.\n"
"* Concentra-se na confiabilidade e seguran√ßa sem sacrificar o desempenho."

#: src/welcome-day-1/what-is-rust.md:31
msgid "[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html"
msgstr "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# Ol√° mundo!"

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr "Vamos pular para o programa em Rust mais simples poss√≠vel, o cl√°ssico \"Ol√° Mundo\":"

#: src/hello-world.md:6
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello üåç!\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    println!(\"Ol√° üåç!\");\n"
"}\n"
"```"

#: src/hello-world.md:12
msgid "What you see:"
msgstr "O que voc√™ v√™:"

#: src/hello-world.md:14
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* Fun√ß√µes s√£o introduzidas com `fn`.\n"
"* Os blocos s√£o delimitados por chaves como em C e C++.\n"
"* A fun√ß√£o `main` √© o ponto de entrada do programa.\n"
"* Rust tem macros, `println!` √© um exemplo disso.\n"
"* As strings Rust s√£o codificadas em UTF-8 e podem conter qualquer caractere Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will see\n"
"a ton of it over the next four days so we start small with something familiar."
msgstr ""
"Este slide tenta deixar os alunos familiarizados com o c√≥digo em Rust. Eles v√£o ver\n"
"uma tonelada nos pr√≥ximos quatro dias, ent√£o come√ßamos pequeno e com algo familiar."

#: src/hello-world.md:27
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary."
msgstr ""
"* Rust √© muito parecido com outras linguagens na tradi√ß√£o do C/C++/Java. √â\n"
"  imperativo (n√£o funcional) e n√£o tenta reinventar as coisas a menos que\n"
"  absolutamente necess√°rio."

#: src/hello-world.md:31
msgid "* Rust is modern with full support for things like Unicode."
msgstr "* Rust √© moderno com amplo suporte para coisas como Unicode."

#: src/hello-world.md:33
msgid ""
"* Rust uses macros for situations where you want to have a variable number of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""
"* Rust usa macros para situa√ß√µes em que voc√™ deseja ter um n√∫mero vari√°vel de\n"
"  argumentos (sem [overloading](sintaxe-b√°sica/fun√ß√µes-interlude.md) de fun√ß√µes)."

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# Um pequeno exemplo"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Aqui est√° um pequeno programa de exemplo em Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {              // Ponto de entrada do programa\n"
"    let mut x: i32 = 6;  // Atribui√ß√£o de uma vari√°vel mut√°vel\n"
"    print!(\"{x}\");     // Macro para escrever na tela, como printf\n"
"    while x != 1 {       // Sem par√™nteses ao redor de express√µes\n"
"        if x % 2 == 0 {  // Matem√°tica como em outras linguagens\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop will\n"
"always end, but this is not yet proved. Edit the code and play with different\n"
"inputs."
msgstr ""
"O c√≥digo implementa a conjectura de Collatz: acredita-se que o loop\n"
"sempre termina, mas isso ainda n√£o est√° provado. Edite o c√≥digo e tente diferentes\n"
"entradas."

#: src/hello-world/small-example.md:29
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer overflow."
msgstr ""
"* Explique que todas as vari√°veis s√£o estaticamente tipadas. Tente remover `i32` para acionar a\n"
"  infer√™ncia de tipo. Em vez disso, tente com `i8` e dispare um estouro de n√∫mero inteiro em tempo de execu√ß√£o."

#: src/hello-world/small-example.md:32
msgid "* Change `let mut x` to `let x`, discuss the compiler error."
msgstr "* Altere `let mut x` para `let x`, discuta o erro do compilador."

#: src/hello-world/small-example.md:34
msgid ""
"* Show how `print!` gives a compilation error if the arguments don't match the\n"
"  format string."
msgstr ""
"* Mostre como `print!` gera um erro de compila√ß√£o se os argumentos n√£o combinam com a\n"
"  sequ√™ncia de formato."

#: src/hello-world/small-example.md:37
msgid ""
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable."
msgstr ""
"* Mostre como voc√™ precisa usar `{}` como espa√ßo reservado se quiser imprimir uma\n"
"  express√£o que √© mais complexa do que apenas uma √∫nica vari√°vel."

#: src/hello-world/small-example.md:40
msgid ""
"* Show the students the standard library, show them how to search for `std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that the\n"
"  students become familiar with searching in the standard library."
msgstr ""
"* Mostre aos alunos a biblioteca padr√£o, mostre como pesquisar `std::fmt`, \n"
"  que possui as regras da mini-linguagem de formata√ß√£o. √â importante que\n"
"  os alunos se familiarizem com pesquisas na biblioteca padr√£o."

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# Por que Rust?"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Alguns pontos exclusivos do Rust:"

#: src/why-rust.md:5
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* Seguran√ßa de mem√≥ria em tempo de compila√ß√£o.\n"
"* Sem comportamento indefinido em tempo de execu√ß√£o.\n"
"* Recursos de linguagem de programa√ß√£o modernas."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr ""
"Certifique-se de perguntar √† classe com quais linguagens de programa√ß√£o eles t√™m experi√™ncia. Dependendo\n"
"da resposta voc√™ pode destacar diferentes caracter√≠sticas do Rust:"

#: src/why-rust.md:14
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you don't\n"
"  have the memory unsafety issues. In addition, you get a modern language with\n"
"  constructs like pattern matching and built-in dependency management."
msgstr ""
"* Experi√™ncia com C ou C++: Rust elimina toda uma classe de _erros de tempo de execu√ß√£o_\n"
"  atrav√©s do verificador de empr√©stimo. Voc√™ obt√©m desempenho como em C e C++, mas n√£o\n"
"  tem problemas de inseguran√ßa de mem√≥ria. Al√©m disso, voc√™ obt√©m uma linguagem moderna com\n"
"  constru√ß√µes como correspond√™ncia de padr√µes e gerenciamento de depend√™ncias integrado."

#: src/why-rust.md:19
msgid ""
"* Experience with Java, Go, Python, JavaScript...: You get the same memory safety\n"
"  as in those languages, plus a similar high-level language feeling. In addition\n"
"  you get fast and predictable performance like C and C++ (no garbage collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* Experi√™ncia com Java, Go, Python, JavaScript...: Voc√™ obt√©m a mesma seguran√ßa de mem√≥ria\n"
"  como nessas linguagens, al√©m de um sentimento semelhante ao de linguagem de alto n√≠vel. Al√©m disso\n"
"  voc√™ obt√©m desempenho r√°pido e previs√≠vel como C e C++ (sem coletor de lixo)\n"
"  bem como acesso a hardware de baixo n√≠vel (caso voc√™ precise)"

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# Garantias de tempo de compila√ß√£o"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Gerenciamento de mem√≥ria est√°tica em tempo de compila√ß√£o:"

#: src/why-rust/compile-time.md:5
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* Nenhuma vari√°vel n√£o inicializada.\n"
"* Sem vazamentos de mem√≥ria (_quase_, veja as notas).\n"
"* Sem _double-free_.\n"
"* Sem _user-afer-free_'.\n"
"* Sem ponteiros `NULL`.\n"
"* Sem mutexes bloqueados esquecidos.\n"
"* Sem concorr√™ncia de dados entre _threads_.\n"
"* Nenhuma invalida√ß√£o de iteradores."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr ""
"√â poss√≠vel produzir vazamentos de mem√≥ria no Rust seguro. Alguns exemplos\n"
"s√£o:"

#: src/why-rust/compile-time.md:19
msgid ""
"* You can for use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* Voc√™ pode usar [`Box::leak`] para vazar um ponteiro. Um uso disso poderia\n"
"  ser para obter vari√°veis est√°ticas inicializadas e dimensionadas em tempo de execu√ß√£o\n"
"* Voc√™ pode usar [`std::mem::forget`] para fazer o compilador \"esquecer\" sobre\n"
"  um valor (o que significa que o destrutor nunca √© executado).\n"
"* Voc√™ tamb√©m pode criar acidentalmente uma [refer√™ncia c√≠clica] com `Rc` ou\n"
"  `Arc`.\n"
"* Na verdade, alguns considerar√£o preencher infinitamente uma cole√ß√£o\n"
"  como vazamento de mem√≥ria e Rust n√£o protege disso."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr ""
"Para o prop√≥sito deste curso, \"Sem vazamentos de mem√≥ria\" deve ser entendido\n"
"como \"Praticamente sem vazamentos de mem√≥ria *acidentais*\"."

#: src/why-rust/compile-time.md:31
msgid ""
"[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[reference cycle]: https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"
msgstr ""
"[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[refer√™ncia c√≠clica]: https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# Garantias de tempo de execu√ß√£o"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Nenhum comportamento indefinido em tempo de execu√ß√£o:"

#: src/why-rust/runtime.md:5
msgid ""
"* Array access is bounds checked.\n"
"* Integer overflow is defined."
msgstr ""
"* O acesso √† vetores tem limites verificados.\n"
"* Estouro de n√∫meros inteiros √© definido."

#: src/why-rust/runtime.md:12
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`)."
msgstr ""
"* O estouro de n√∫meros inteiros √© definido por meio de um sinalizador de tempo de compila√ß√£o. As op√ß√µes s√£o\n"
"  ou um p√¢nico (uma falha controlada do programa) ou sem√¢ntica\n"
"  wrap-around. Por padr√£o, voc√™ obt√©m p√¢nico no modo de depura√ß√£o (`cargo build`)\n"
"  e wrap-around no modo de produ√ß√£o (`cargo build --release`)."

#: src/why-rust/runtime.md:17
msgid ""
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* A verifica√ß√£o de limites n√£o pode ser desativada com um sinalizador de compilador. Tamb√©m n√£o\n"
"  pode ser desativado diretamente com a palavra-chave `unsafe`. No entanto,\n"
"  `unsafe` permite que voc√™ chame fun√ß√µes como `slice::get_unchecked`\n"
"  que n√£o faz verifica√ß√£o de limites."

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# Recursos modernos"

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr "O Rust √© constru√≠do com toda a experi√™ncia adquirida nos √∫ltimos 40 anos."

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## Caracter√≠sticas da linguagem"

#: src/why-rust/modern.md:7
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* Enums e correspond√™ncia de padr√µes.\n"
"* Generics.\n"
"* FFI sem overhead.\n"
"* Abstra√ß√µes de custo zero."

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## Ferramentas"

#: src/why-rust/modern.md:14
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* Excelentes mensagens de erro do compilador.\n"
"* Gerenciador de depend√™ncias integrado.\n"
"* Suporte integrado para testes.\n"
"* Excelente suporte ao protocolo de servidor de linguagem (LSP)."

#: src/why-rust/modern.md:23
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to 'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct."
msgstr ""
"* Abstra√ß√µes de custo zero, semelhantes ao C++, significa que voc√™ n√£o precisa 'pagar'\n"
"  com mem√≥ria ou CPU por constru√ß√µes de programa√ß√£o de alto n√≠vel. Por exemplo,\n"
"  escrever um loop usando `for` deve resultar aproximadamente nas mesmas instru√ß√µes\n"
"  de baixo n√≠vel como ao usar a constru√ß√£o `.iter().fold()`."

#: src/why-rust/modern.md:28
msgid ""
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`."
msgstr ""
"* Pode valer a pena mencionar que enums em Rust tamb√©m s√£o 'tipos de dados alg√©bricos', tamb√©m\n"
"  conhecidos como 'tipos de soma', os quais permitem que o sistema de tipos expresse coisas como\n"
"  `Option<T>` e `Result<T, E>`."

#: src/why-rust/modern.md:32
msgid ""
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with _actionable_\n"
"  feedback, ready to copy-paste into your code."
msgstr ""
"* Lembre as pessoas de lerem os erros --- muitos desenvolvedores se acostumaram\n"
"  a ignorar as longas sa√≠da do compilador. O compilador Rust √© significativamente mais\n"
"  verboso do que outros compiladores. Muitas vezes, ele fornecer√° a voc√™ feedback\n"
"  _utiliz√°vel_, pronto para copiar e colar em seu c√≥digo."

#: src/why-rust/modern.md:37
msgid ""
"* The Rust standard library is small compared to languages like Java, Python,\n"
"  and Go. Rust does not come with several things you might consider standard and\n"
"  essential:"
msgstr ""
"* A biblioteca padr√£o do Rust √© pequena comparada a linguagens como Java, Python,\n"
"  e Go. Rust n√£o vem com v√°rias coisas que voc√™ pode considerar padr√£o e\n"
"  essencial:"

#: src/why-rust/modern.md:41
msgid ""
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json]."
msgstr ""
"  * um gerador de n√∫meros aleat√≥rios, mas veja [rand].\n"
"  * suporte para SSL ou TLS, mas consulte [rusttls].\n"
"  * suporte para JSON, mas consulte [serde_json]."

#: src/why-rust/modern.md:45
msgid ""
"  The reasoning behind this is that functionality in the standard library cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps there\n"
"  isn't a single \"best solution\" for some of these things."
msgstr ""
"  O racioc√≠nio por tr√°s disso √© que as funcionalidades na biblioteca padr√£o n√£o podem\n"
"  ser descartadas, portanto t√™m que ser muito est√°veis. Para os exemplos acima, a comunidade\n"
"  Rust ainda est√° trabalhando para encontrar a melhor solu√ß√£o --- e talvez n√£o\n"
"  haja uma √∫nica \"melhor solu√ß√£o\" para algumas dessas coisas."

#: src/why-rust/modern.md:50
msgid ""
"  Rust comes with a built-in package manager in the form of Cargo and this makes\n"
"  it trivial to download and compile third-party crates. A consequence of this\n"
"  is that the standard library can be smaller."
msgstr ""
"  O Rust vem com um gerenciador de pacotes embutido na forma de Cargo e isso torna\n"
"  trivial baixar e compilar crates de terceiros. Uma consequ√™ncia disso\n"
"  √© que a biblioteca padr√£o pode ser menor."

#: src/why-rust/modern.md:54
msgid ""
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"  Descobrir bons crates de terceiros pode ser um problema. Sites como\n"
"  <https://lib.rs/> ajudam com isso, permitindo que voc√™ compare m√©tricas para\n"
"  para encontrar um crate bom e confi√°vel.\n"
"  \n"
"* [rust-analyzer] √© uma implementa√ß√£o LSP bem suportada usada em grandes\n"
"  IDEs e editores de texto."

#: src/why-rust/modern.md:61
msgid ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"
msgstr ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# Sintaxe b√°sica"

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Grande parte da sintaxe do Rust ser√° familiar para voc√™ em C ou C++:"

#: src/basic-syntax.md:5
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* ...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* Blocos e escopos s√£o delimitados por chaves.\n"
"* Coment√°rios de linha s√£o iniciados com `//`, coment√°rios de bloco s√£o delimitados por `/* ...\n"
"  */`.\n"
"* Palavras-chave como `if` e `while` funcionam da mesma forma.\n"
"* A atribui√ß√£o de vari√°veis √© feita com `=`, a compara√ß√£o √© feita com `==`."

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# Tipos escalares"

#: src/basic-syntax/scalar-types.md:3
msgid ""
"|                        | Types                                      | Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | `3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                | `&str`                                     | `\"foo\"`, `r#\"\\\\\"#`            |\n"
"| Unicode scalar values  | `char`                                     | `'a'`, `'Œ±'`, `'‚àû'`           |\n"
"| Byte strings           | `&[u8]`                                    | `b\"abc\"`, `br#\" \" \"#`         |\n"
"| Booleans               | `bool`                                     | `true`, `false`               |"
msgstr ""
"|                           | Tipos                                      | Literais                      |\n"
"|---------------------------|--------------------------------------------|-------------------------------|\n"
"| Inteiro com sinal         | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123i64` |\n"
"| Inteiro sem sinal         | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10u16`           |\n"
"| Ponto flutuante           | `f32`, `f64`                               | `3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                   | `&str`                                     | `\"foo\"`, `r#\"\\\\\"#`            |\n"
"| Valores Unicode escalares | `char`                                     | `'a'`, `'Œ±'`, `'‚àû'`           |\n"
"| Byte strings              | `&[u8]`                                    | `b\"abc\"`, `br#\" \" \"#`         |\n"
"| Booleanos                 | `bool`                                     | `true`, `false`               |"

#: src/basic-syntax/scalar-types.md:13
msgid "The types have widths as follows:"
msgstr "Os tipos t√™m tamanhos como se segue:"

#: src/basic-syntax/scalar-types.md:15
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* `iN`, `uN` e `fN` s√£o _N_ bits,\n"
"* `isize` e `usize` s√£o o tamanho de um ponteiro,\n"
"* `char` tem 32 bits,\n"
"* `bool` tem 8 bits."

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# Tipos compostos"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"
msgstr ""
"|        | Tipos                         | Literais                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Vetores | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuplas  | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Atribui√ß√£o e acesso a vetores:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Atribui√ß√£o e acesso a tuplas:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1¬∫ √≠ndice: {}\", t.0);\n"
"    println!(\"2¬∫ √≠ndice: {}\", t.1);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Vetores:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that `[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types."
msgstr ""
"* Vetores possuem elementos do mesmo tipo, `T`, e comprimento, `N`, que √© uma constante de tempo de compila√ß√£o.\n"
"  Observe que o comprimento do vetor √© *parte de seu tipo*, o que significa que `[u8; 3]` e\n"
"  `[u8; 4]` s√£o considerados dois tipos diferentes."

#: src/basic-syntax/compound-types.md:38
msgid "* We can use literals to assign values to arrays."
msgstr "* Podemos usar literais para atribuir valores a vetores."

#: src/basic-syntax/compound-types.md:40
msgid ""
"* In the main function, the print statement asks for the debug implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after the\n"
"  format string."
msgstr ""
"* Na fun√ß√£o `main`, a instru√ß√£o print solicita a implementa√ß√£o de depura√ß√£o com um `?` no\n"
"  formatador: `{}` fornece a sa√≠da padr√£o, `{:?}` fornece a sa√≠da de depura√ß√£o. N√≥s\n"
"  tamb√©m poder√≠amos ter usado `{a}` e `{a:?}` sem especificar o valor ap√≥s a\n"
"  sequ√™ncia de formatadores."

#: src/basic-syntax/compound-types.md:45
msgid "* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be easier to read."
msgstr "* Adicionando `#`, por exemplo `{a:#?}`, chama um formatador de \"impress√£o bonita\", que pode ser mais f√°cil de ler."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Tuplas:"

#: src/basic-syntax/compound-types.md:49
msgid "* Like arrays, tuples have a fixed length."
msgstr "* Assim como os vetores, as tuplas t√™m um comprimento fixo."

#: src/basic-syntax/compound-types.md:51
msgid "* Tuples group together values of different types into a compound type."
msgstr "* As tuplas agrupam valores de tipos diferentes em um tipo composto."

#: src/basic-syntax/compound-types.md:53
msgid "* Fields of a tuple can be accessed by the period and the index of the value, e.g. `t.0`, `t.1`."
msgstr "* Os campos de uma tupla podem ser acessados pelo 'ponto' e pelo √≠ndice do valor, por exemplo `t.0`, `t.1`."

#: src/basic-syntax/compound-types.md:55
msgid ""
"* The empty tuple `()` is also known as the \"unit type\". It is both a type, and\n"
"  the only valid value of that type - that is to say both the type and its value\n"
"  are expressed as `()`. It is used to indicate, for example, that a function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* A tupla vazia `()` tamb√©m √© conhecida como \"tipo unit√°rio\". √â um tipo e\n"
"  o √∫nico valor v√°lido desse tipo - ou seja, o tipo e seu valor\n"
"  s√£o expressos como `()`. √â usado para indicar, por exemplo, que uma fun√ß√£o ou\n"
"  uma express√£o n√£o tem valor de retorno, como veremos em um pr√≥ximo slide.\n"
"    * Voc√™ pode pensar nisso como um 'vazio' que pode ser familiar para voc√™ de outras\n"
"      linguagens de programa√ß√£o."

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# Refer√™ncias"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Como C++, Rust tem refer√™ncias:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Algumas notas:"

#: src/basic-syntax/references.md:16
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values over their lifetime."
msgstr ""
"* Devemos desreferenciar `ref_x` ao atribuir um valor, semelhante √† ponteiros em C e C++.\n"
"* Rust desreferenciar√° automaticamente em alguns casos, em particular ao invocar\n"
"  m√©todos (tente `ref_x.count_ones()`).\n"
"* As refer√™ncias que s√£o declaradas como `mut` podem ser vinculadas a diferentes valores ao longo de seu tempo de vida."

#: src/basic-syntax/references.md:21
msgid ""
"<details>\n"
"Key points:"
msgstr ""
"<details>\n"
"Pontos chave:"

#: src/basic-syntax/references.md:24
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound to\n"
"  different values, while the second represents a reference to a mutable value."
msgstr ""
"* Certifique-se de observar a diferen√ßa entre `let mut ref_x: &i32` e `let ref_x:\n"
"  &mut i32`. O primeiro representa uma refer√™ncia mut√°vel que pode ser ligada a\n"
"  diferentes valores, enquanto o segundo representa uma refer√™ncia a um valor mut√°vel."

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# Refer√™ncias pendentes"

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust estaticamente proibir√° refer√™ncias pendentes:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* Diz-se que uma refer√™ncia \"pega emprestado\" o valor a que se refere.\n"
"* Rust est√° rastreando os tempos de vida de todas as refer√™ncias para garantir que elas durem\n"
"  o suficiente.\n"
"* Falaremos mais sobre empr√©stimos quando chegarmos √† ownership."

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# Slices"

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "Uma slice oferece uma vis√£o de uma cole√ß√£o maior:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"
msgstr ""

#: src/basic-syntax/slices.md:10
msgid ""
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:15
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* As slices pegam dados emprestados.\n"
"* Pergunta: O que acontece se voc√™ modificar `a[3]`?"

#: src/basic-syntax/slices.md:20
msgid "* We create a slice by borrowing `a` and specifying the starting and ending indexes in brackets."
msgstr "* Criamos uma slice pegando emprestado `a` e especificando os √≠ndices inicial e final entre colchetes."

#: src/basic-syntax/slices.md:22
msgid ""
"* If the slice starts at index 0, Rust's range syntax allows us to drop the starting index, meaning that `&a[0..a.len()]` "
"and `&a[..a.len()]` are identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are identical."
msgstr ""
"* Se a slice come√ßa no √≠ndice 0, a sintaxe de intervalo do Rust nos permite descartar o √≠ndice inicial, o que significa que "
"`&a[0..a.len()]` e `&a[..a.len()]` s√£o id√™nticos .\n"
"    \n"
"* O mesmo vale para o √∫ltimo √≠ndice, ent√£o `&a[2..a.len()]` e `&a[2..]` s√£o id√™nticos."

#: src/basic-syntax/slices.md:26
msgid "* To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "* Para criar facilmente uma slice do vetor completo, podemos usar `&a[..]`."

#: src/basic-syntax/slices.md:28
msgid ""
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` (`&[i32]`) no longer mentions the array length. This "
"allows us to perform computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to remain 'alive' (in scope) for at least as long as "
"our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, but the answer is that for memory safety "
"reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read the data from both `a` and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* `s` √© uma refer√™ncia a uma slice de `i32`. Observe que o tipo de `s` (`&[i32]`) n√£o menciona mais o tamanho do vetor. "
"Isso nos permite realizar c√°lculos em slices de tamanhos diferentes.\n"
" \n"
"* As slices sempre pegam emprestado de outro objeto. Neste exemplo, `a` deve permanecer 'vivo' (no escopo) por pelo menos "
"tanto tempo quanto nossa slice.\n"
"    \n"
"* A quest√£o sobre a modifica√ß√£o de `a[3]` pode gerar uma discuss√£o interessante, mas a resposta √© por motivos de seguran√ßa "
"de mem√≥ria\n"
"  voc√™ n√£o pode fazer isso por meio de `a` depois de criar uma slice, mas pode ler os dados de `a` e `s` com seguran√ßa.\n"
"  Mais detalhes ser√£o explicados na se√ß√£o do verificador de empr√©stimo."

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String` vs `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "Agora podemos entender os dois tipos de strings em Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"Mundo\";\n"
"    println!(\"s1: {s1}\");"

#: src/basic-syntax/string-slices.md:10
msgid ""
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""
"    let mut s2: String = String::from(\"Ol√° \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminologia do Rust:"

#: src/basic-syntax/string-slices.md:22
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` √© uma refer√™ncia imut√°vel para uma slice de string.\n"
"* `String` √© um buffer de string mut√°vel."

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 encoded string data \n"
"  stored in a block of memory. String literals (`\"Hello\"`), are stored in the program's binary."
msgstr ""
"* `&str` introduz uma slice de string, que √© uma refer√™ncia imut√°vel para dados de string codificados em UTF-8\n"
"  armazenados em um bloco de mem√≥ria. String literais (`\"Hello\"`), s√£o armazenados no bin√°rio do programa."

#: src/basic-syntax/string-slices.md:30
msgid ""
"* Rust's `String` type is a wrapper around a vector of bytes. As with a `Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string literal; `String::new()` \n"
"  creates a new empty string, to which string data can be added using the `push()` and `push_str()` methods."
msgstr ""
"* O tipo `String` do Rust √© um wrapper em torno de um vetor de bytes. Tal como acontece com um `Vec<T>`, ele √© um valor.\n"
"    \n"
"* Assim como muitos outros tipos, `String::from()` cria uma string a partir de uma string literal; `String::new()`\n"
"  cria uma nova string vazia, na qual os dados da string podem ser adicionados usando os m√©todos `push()` e `push_str()`."

#: src/basic-syntax/string-slices.md:35
msgid ""
"* The `format!()` macro is a convenient way to generate an owned string from dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of `std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).\n"
"    \n"
"</details>"
msgstr ""
"* A macro `format!()` √© uma maneira conveniente de gerar uma string a partir de valores din√¢micos. Ela\n"
"  aceita os mesmos formatadores que `println!()`.\n"
"    \n"
"* Voc√™ pode emprestar slices `&str` de `String` via `&` e, opcionalmente, selecionar um intervalo.\n"
"    \n"
"* Para programadores C++: pense em `&str` como `const char*` de C++, mas que sempre aponta\n"
"  para uma string v√°lida na mem√≥ria. Em Rust, `String` √© um equivalente aproximado de `std::string` de C++\n"
"  (principal diferen√ßa: ele s√≥ pode conter bytes codificados em UTF-8 e nunca usar√° uma otimiza√ß√£o de string pequena).\n"
"    \n"
"</details>"

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# Fun√ß√µes"

#: src/basic-syntax/functions.md:3
msgid "A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview question:"
msgstr "Uma vers√£o em Rust da famosa pergunta de entrevistas [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
"}"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    fizzbuzz_to(20); // Definido abaixo, nenhuma declara√ß√£o pr√©via √© necess√°ria\n"
"}"

#: src/basic-syntax/functions.md:10
msgid ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return value\n"
"}"
msgstr ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Caso especial, retorne antes\n"
"    }\n"
"    lhs % rhs == 0     // A √∫ltima express√£o em um bloco √© o valor de retorno\n"
"}"

#: src/basic-syntax/functions.md:17
msgid ""
"fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit type `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"
msgstr ""
"fn fizzbuzz(n: u32) -> () {  //  // Nenhum valor de retorno significa retornar o tipo unit√°rio `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"

#: src/basic-syntax/functions.md:26
msgid ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn fizzbuzz_to(n: u32) { // `-> ()` normalmente √© omitido\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward declarations nor headers are necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some programming languages), then a return type.\n"
"* The last expression in a function body (or any block) becomes the return value. Simply omit the `;` at the end of the "
"expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The compiler will infer this if the `-> ()` return "
"type is omitted.\n"
"* The range expression in the `for` loop in `fizzbuzz_to()` contains `=n`, which causes it to include the upper bound.\n"
"* The `match` expression in `fizzbuzz()` is doing a lot of work. It is expanded below to show what is happening."
msgstr ""
"* Nos referimos em `main` a uma fun√ß√£o escrita abaixo. Nem declara√ß√µes pr√©vias e nem cabe√ßalhos s√£o necess√°rios.\n"
"* Os par√¢metros de declara√ß√£o s√£o seguidos por um tipo (o inverso de algumas linguagens de programa√ß√£o) e, em seguida, um "
"tipo de retorno.\n"
"* A √∫ltima express√£o em um corpo de uma fun√ß√£o (ou qualquer bloco) torna-se o valor de retorno. Simplesmente omita o `;` no "
"final da express√£o.\n"
"* Algumas fun√ß√µes n√£o t√™m valor de retorno e retornam o 'tipo unit√°rio', `()`. O compilador inferir√° isso se o tipo de "
"retorno `-> ()` for omitido.\n"
"* A express√£o de intervalo no loop `for` em `fizzbuzz_to()` cont√©m `=n`, o que faz com que inclua o limite superior.\n"
"* A express√£o `match` em `fizzbuzz()` faz muita coisa. Ela ser√° expandida abaixo para mostrar o que est√° acontecendo."

#: src/basic-syntax/functions.md:42
msgid "  (Type annotations added for clarity, but they can be elided.)"
msgstr "  (As anota√ß√µes de tipo foram adicionadas para maior clareza, mas podem ser omitidas.)"

#: src/basic-syntax/functions.md:44
msgid ""
"  ```rust,ignore\n"
"  let by_3: bool = is_divisible_by(n, 3);\n"
"  let by_5: bool = is_divisible_by(n, 5);\n"
"  let by_35: (bool, bool) = (by_3, by_5);\n"
"  match by_35 {\n"
"    // ...\n"
"  ```"
msgstr ""

#: src/basic-syntax/functions.md:52
msgid "  "
msgstr ""

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# M√©todos"

#: src/basic-syntax/methods.md:3
msgid ""
"Rust has methods, they are simply functions that are associated with a particular type. The\n"
"first argument of a method is an instance of the type it is associated with:"
msgstr ""
"Rust tem m√©todos, eles s√£o simplesmente fun√ß√µes associadas a um tipo espec√≠fico. O\n"
"primeiro argumento de um m√©todo √© uma inst√¢ncia do tipo ao qual est√° associado:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}"
msgstr ""
"```rust,editable\n"
"struct Retangulo {\n"
"    largura: u32,\n"
"    altura: u32,\n"
"}"

#: src/basic-syntax/methods.md:12
msgid ""
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }"
msgstr ""
"impl Retangulo {\n"
"    fn area(&self) -> u32 {\n"
"        self.largura * self.altura\n"
"    }"

#: src/basic-syntax/methods.md:17
msgid ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}"
msgstr ""
"    fn aumenta_largura(&mut self, delta: u32) {\n"
"        self.largura += delta;\n"
"    }\n"
"}"

#: src/basic-syntax/methods.md:22
msgid ""
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut ret = Retangulo { largura: 10, altura: 5 };\n"
"    println!(\"√Årea inicial: {}\", ret.area());\n"
"    ret.aumenta_largura(5);\n"
"    println!(\"Nova √°rea: {}\", ret.area());\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:30
msgid "* We will look much more at methods in today's exercise and in tomorrow's class."
msgstr "* Veremos muito mais sobre m√©todos no exerc√≠cio de hoje e na aula de amanh√£."

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# Sobrecarga de fun√ß√µes"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "A sobrecarga n√£o √© suportada:"

#: src/basic-syntax/functions-interlude.md:5
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* Cada fun√ß√£o tem uma √∫nica implementa√ß√£o:\n"
"  * Sempre tem um n√∫mero fixo de par√¢metros.\n"
"  * Sempre usa um √∫nico conjunto de tipos de par√¢metros.\n"
"* Valores padr√£o n√£o s√£o suportados:\n"
"  * Todos as chamadas t√™m o mesmo n√∫mero de argumentos.\n"
"  * √Äs vezes macros s√£o usadas como alternativa."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "No entanto, os par√¢metros da fun√ß√£o podem ser gen√©ricos:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"
msgstr ""
"```rust,editable\n"
"fn escolha_um<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"

#: src/basic-syntax/functions-interlude.md:19
msgid ""
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    println!(\"Cara ou coroa: {}\", escolha_um(\"cara\", \"coroa\"));\n"
"    println!(\"B√¥nus: {}\", escolha_um(500, 1000));\n"
"}\n"
"```"

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind of limited\n"
"  polymorphism on argument types. We will see more details in a later section."
msgstr ""
"* Ao usar generics, o `Into<T>` da biblioteca padr√£o pode fornecer um tipo polim√≥rfico\n"
"  limitado nos tipos do argumento. Veremos mais detalhes em uma se√ß√£o posterior."

#: src/basic-syntax/functions-interlude.md:30
msgid "</defails>"
msgstr "</defails>"

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# Dia 1: Exerc√≠cios matinais"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "Nestes exerc√≠cios, exploraremos duas partes do Rust:"

#: src/exercises/day-1/morning.md:5
msgid "* Implicit conversions between types."
msgstr "* Convers√µes impl√≠citas entre tipos."

#: src/exercises/day-1/morning.md:7
msgid "* Arrays and `for` loops."
msgstr "* Vetores e la√ßos `for`."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr "Algumas coisas a considerar ao resolver os exerc√≠cios:"

#: src/exercises/day-1/morning.md:13
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for details\n"
"  on installing Rust."
msgstr ""
"* Se poss√≠vel, use uma instala√ß√£o local do Rust. Desta forma, voc√™ pode obter\n"
"  preenchimento autom√°tico em seu editor. Veja a p√°gina sobre [Utiliza√ß√£o do Cargo] para detalhes\n"
"  sobre instala√ß√£o do Rust."

#: src/exercises/day-1/morning.md:17
msgid "* Alternatively, use the Rust Playground."
msgstr "* Como alternativa, use o Rust Playground."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose\n"
"their state if you navigate away from the page."
msgstr ""
"Os trechos de c√≥digo n√£o s√£o edit√°veis de prop√≥sito: os trechos de c√≥digo embutidos perdem\n"
"seu estado se voc√™ sair da p√°gina."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11 src/exercises/day-2/morning.md:11
#: src/exercises/day-2/afternoon.md:7 src/exercises/day-3/morning.md:7 src/exercises/day-4/morning.md:12
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "Depois de ver os exerc√≠cios, voc√™ pode ver as [solu√ß√µes] fornecidas."

#: src/exercises/day-1/morning.md:24 src/exercises/day-2/morning.md:13 src/exercises/day-3/morning.md:9
#: src/exercises/day-4/morning.md:14
msgid "[solutions]: solutions-morning.md"
msgstr "[solu√ß√µes]:solutions-morning.md"

#: src/exercises/day-1/morning.md:26
msgid "[Using Cargo]: ../../cargo.md"
msgstr "[Utiliza√ß√£o do Cargo]: ../../cargo.md"

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# Convers√µes impl√≠citas"

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types ([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust n√£o aplicar√° automaticamente _convers√µes impl√≠citas_ entre os tipos ([ao contr√°rio\n"
"De C++][3]). Voc√™ pode ver isso em um programa como este:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:11
msgid ""
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:15
msgid ""
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single `from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted into\n"
"another type."
msgstr ""
"Todos os tipos inteiros do Rust implementam os traits [`From<T>`][1] e [`Into<T>`][2]\n"
"para nos deixar converter entre eles. Os traits `From<T>` tem um √∫nico `from()`\n"
"e da mesma forma, o trait `Into<T>` tem um √∫nico m√©todo `into()`.\n"
"A implementa√ß√£o dessas caracter√≠sticas √© como um tipo expressa que pode ser convertido em\n"
"outro tipo."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"A biblioteca padr√£o tem uma implementa√ß√£o de `From<i8> for i16`, o que significa\n"
"que podemos converter uma vari√°vel `x` do tipo `i8` para um `i16` chamando\n"
"`i16::from(x)`. Ou, mais simples, com `x.into()`, porque a implementa√ß√£o `From<i8> for i16`\n"
"cria automaticamente uma implementa√ß√£o de `Into<i16> for i8`."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so it is\n"
"sufficient to only implement `From` to get a respective `Into` implementation automatically."
msgstr ""
"O mesmo se aplica a suas pr√≥prias implementa√ß√µes de `From` para seus tipos, ent√£o √©\n"
"suficiente implementar apenas `From` para obter uma respectiva implementa√ß√£o `Into` automaticamente."

#: src/exercises/day-1/implicit-conversions.md:33
msgid "1. Execute the above program and look at the compiler error."
msgstr "1. Execute o programa acima e observe o erro do compilador."

#: src/exercises/day-1/implicit-conversions.md:35
msgid "2. Update the code above to use `into()` to do the conversion."
msgstr "2. Atualize o c√≥digo acima para usar `into()` para fazer a convers√£o."

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented for\n"
"   the pairs you check."
msgstr ""
"3. Mude os tipos de `x` e `y` para outros tipos (como `f32`, `bool`,\n"
"   `i128`) para ver quais tipos voc√™ pode converter para quais outros tipos. Experimente\n"
"   converter tipos pequenos em tipos grandes e vice-versa. Verifique a\n"
"   [documenta√ß√£o da biblioteca padr√£o][1] para ver se `From<T>` est√° implementado para\n"
"   os pares que voc√™ verifica."

#: src/exercises/day-1/implicit-conversions.md:43
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"
msgstr ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# Vetores e la√ßos `for`"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "Vimos que um vetor pode ser declarado assim:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""
"```rust\n"
"let vetor = [10, 20, 30];\n"
"```"

#: src/exercises/day-1/for-loops.md:9
msgid "You can print such an array by asking for its debug representation with `{:?}`:"
msgstr "Voc√™ pode imprimir tal vetor solicitando sua representa√ß√£o de depura√ß√£o com `{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let vetor = [10, 20, 30];\n"
"    println!(\"Vetor: {vetor:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr ""
"Rust permite iterar em coisas como vetores e intervalos usando um la√ßo `for`\n"
":"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let vetor = [10, 20, 30];\n"
"    print!(\"Interagindo com o vetor:\");\n"
"    for n in vetor {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"

#: src/exercises/day-1/for-loops.md:30
msgid ""
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"    print!(\"Interagindo sobre uma faixa:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", vetor[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix and\n"
"a function `transpose` which will transpose a matrix (turn rows into columns):"
msgstr ""
"Use o exerc√≠cio acima para escrever uma fun√ß√£o `pretty_print` que imprime uma matriz e\n"
"uma fun√ß√£o `transpose` que ir√° transpor uma matriz (transformar linhas em colunas):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"              ‚éõ‚é°1 2 3‚é§‚éû         ‚é°1 4 7‚é§\n"
"\"transpose\" ‚éú‚é¢4 5 6‚é•‚éü  \"==\" ‚é¢2 5 8‚é•\n"
"              ‚éù‚é£7 8 9‚é¶‚é†         ‚é£3 6 9‚é¶\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3 √ó 3 matrices."
msgstr "Limite ambas as fun√ß√µes a operar em matrizes 3 √ó 3."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/> e implemente as\n"
"fun√ß√µes:"

#: src/exercises/day-1/for-loops.md:52 src/exercises/day-1/book-library.md:20 src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""

#: src/exercises/day-1/for-loops.md:56
msgid ""
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"fn transposta(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-1/for-loops.md:60
msgid ""
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"fn impressao_formatada(matriz: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-1/for-loops.md:64
msgid ""
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""
"fn main() {\n"
"    let matriz = [\n"
"        [101, 102, 103], // <-- o coment√°rio faz com que o rustfmt adicione uma nova linha\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"

#: src/exercises/day-1/for-loops.md:71 src/exercises/day-1/solutions-morning.md:70
msgid ""
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);"
msgstr ""
"    println!(\"matriz:\");\n"
"    impressao_formatada(&matriz);"

#: src/exercises/day-1/for-loops.md:74
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""
"    let transposta = transposta(matriz);\n"
"    println!(\"Transposta:\");\n"
"    impressao_formatada(&transposta);\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## Pergunta B√¥nus"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 √ó 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"Voc√™ poderia usar slices `&[i32]` em vez de matrizes 3 √ó 3 est√°ticos para o seu\n"
"argumentos e tipos de retorno? Algo como `&[&[i32]]` para um slice-de-slices\n"
"bidimensional. Por que ou por que n√£o?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality\n"
"implementation."
msgstr ""
"Veja o crate [`ndarray`](https://docs.rs/ndarray/) para uma implementa√ß√£o de produ√ß√£o\n"
"."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"A solu√ß√£o e a resposta para a se√ß√£o de b√¥nus est√£o dispon√≠veis na\n"
"Se√ß√£o [Solu√ß√µes](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "# Vari√°veis"

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable by\n"
"default:"
msgstr ""
"Rust fornece seguran√ßa de tipo por meio de tipagem est√°tica. Vari√°veis s√£o imut√°veis por\n"
"padr√£o:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the types less and less as the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the function like syntax of `println!(\"x: {}\", x)`"
msgstr ""
"* Devido √† infer√™ncia de tipos, o `i32` √© opcional. Gradualmente mostraremos os tipos cada vez menos √† medida que o curso "
"progride.\n"
"* Observe que como `println!` √© uma macro, `x` n√£o √© movido, mesmo usando uma sintaxe parecida com a de uma fun√ß√£o `println!"
"(\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:1
msgid "# Type Inference"
msgstr "# Infer√™ncia do tipo"

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust ver√° como a vari√°vel √© _usada_ para determinar o tipo:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"
msgstr ""
"```rust,editable\n"
"fn recebe_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"

#: src/basic-syntax/type-inference.md:10
msgid ""
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"
msgstr ""
"fn recebe_u8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"

#: src/basic-syntax/type-inference.md:14
msgid ""
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;"
msgstr ""

#: src/basic-syntax/type-inference.md:18
msgid ""
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""
"    recebe_u32(x);\n"
"    recebe_u8(y);\n"
"    // recebe_u32(y);\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.\n"
"    \n"
"It is very important to emphasize that variables declared like this are not of some sort of dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type.\n"
"The compiler does the job for us and helps us to write a more concise code."
msgstr ""
"Este slide demonstra como o compilador Rust infere tipos com base em restri√ß√µes dadas por declara√ß√µes e usos de vari√°veis.\n"
"    \n"
"√â muito importante enfatizar que vari√°veis declaradas assim n√£o s√£o de um tipo din√¢mico \"qualquer tipo\" que possa\n"
"armazenar quaisquer dados. O c√≥digo de m√°quina gerado por tal declara√ß√£o √© id√™ntico √† declara√ß√£o expl√≠cita de um tipo.\n"
"O compilador faz o trabalho para n√≥s e nos ajuda a escrever um c√≥digo mais conciso."

#: src/basic-syntax/type-inference.md:32
msgid ""
"The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying "
"the contained type, using `_` as a placeholder:"
msgstr ""
"O c√≥digo a seguir informa ao compilador para copiar para um determinado cont√™iner gen√©rico sem que o c√≥digo especifique "
"explicitamente o tipo contido, usando `_` como placeholder:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");"
msgstr ""

#: src/basic-syntax/type-inference.md:41
msgid ""
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) relies on `FromIterator`, which "
"[`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) depende de `FromIterator`, que "
"[`HashSet`](https:/ /doc.rust-lang.org/std/iter/trait.FromIterator.html) implementa."

#: src/basic-syntax/static-and-const.md:1
msgid "# Static and Constant Variables"
msgstr "# Vari√°veis est√°ticas e constantes"

#: src/basic-syntax/static-and-const.md:3
msgid "Global state is managed with static and constant variables."
msgstr "O estado global √© gerenciado com vari√°veis est√°ticas e constantes."

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr "## `const`"

#: src/basic-syntax/static-and-const.md:7
msgid "You can declare compile-time constants:"
msgstr "Voc√™ pode declarar constantes de tempo de compila√ß√£o:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);"
msgstr ""

#: src/basic-syntax/static-and-const.md:13
msgid ""
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}"
msgstr ""

#: src/basic-syntax/static-and-const.md:21
msgid ""
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:27
msgid "According the the [Rust RFC Book][1] these are inlined upon use."
msgstr "De acordo com o [Rust RFC Book][1], eles s√£o expandidos no pr√≥prio local (inline) ap√≥s o uso."

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr "## `static`"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "Voc√™ tamb√©m pode declarar vari√°veis est√°ticas:"

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";"
msgstr ""
"```rust, editable\n"
"static BANNER: &str = \"Bem-vindo ao RustOS 3.14\";"

#: src/basic-syntax/static-and-const.md:36
msgid ""
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:41
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have an actual associated memory location.  This is "
"useful for unsafe and embedded code, and the variable lives through the entirety of the program execution."
msgstr ""
"Conforme observado no [Rust RFC Book][1], `static` e `const` n√£o s√£o expandidos em linha (inlined) quando utilizados e "
"possuem um local de mem√≥ria real associado. Isso √© √∫til para c√≥digo inseguro e embarcado, e a vari√°vel sobrevive durante "
"toda a execu√ß√£o do programa."

#: src/basic-syntax/static-and-const.md:44
msgid "We will look at mutating static data in the [chapter on Unsafe Rust](../unsafe.md)."
msgstr "Veremos a muta√ß√£o de dados est√°ticos no [cap√≠tulo sobre Unsafe Rust](../unsafe.md)."

#: src/basic-syntax/static-and-const.md:48
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable global variable in C++.\n"
"* It isn't super common that one would need a runtime evaluated constant, but it is helpful and safer than using a static."
msgstr ""
"* Mencione que `const` se comporta semanticamente similar ao `constexpr` de C++.\n"
"* `static`, por outro lado, √© muito mais parecido com um `const` ou vari√°vel global mut√°vel em C++.\n"
"* N√£o √© muito comum que algu√©m precise de uma constante avaliada em tempo de execu√ß√£o, mas √© √∫til e mais seguro do que usar "
"uma est√°tica."

#: src/basic-syntax/static-and-const.md:54
msgid "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"
msgstr "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# Escopos e sobreposi√ß√£o"

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from the\n"
"same scope:"
msgstr ""
"Voc√™ pode sobrepor (shadow) vari√°veis, tanto aquelas de escopos externos quanto vari√°veis do\n"
"mesmo escopo:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"Antes: {a}\");"

#: src/basic-syntax/scopes-shadowing.md:11
msgid ""
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");"
msgstr ""
"    {\n"
"        let a = \"Ol√°\";\n"
"        println!(\"Escopo interno: {a}\");"

#: src/basic-syntax/scopes-shadowing.md:15
msgid ""
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }"
msgstr ""
"        let a = true;\n"
"        println!(\"Sobreposi√ß√£o no escopo interno: {a}\");\n"
"    }"

#: src/basic-syntax/scopes-shadowing.md:19
msgid ""
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"Depois: {a}\");\n"
"}\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing both variable's memory locations exist at the "
"same time. Both are available under the same name, depending where you use it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory locations when shadowing an immutable variable "
"in a scope, even if the type does not change."
msgstr ""
"* Defini√ß√£o: A sobreposi√ß√£o √© diferente da muta√ß√£o, porque ap√≥s a sobreposi√ß√£o, os locais de mem√≥ria de ambas as vari√°veis "
"existem ao mesmo tempo. Ambos est√£o dispon√≠veis com o mesmo nome, dependendo de onde voc√™ os usa no c√≥digo.\n"
"* Uma vari√°vel sobreposta pode ter um tipo diferente.\n"
"* A sobreposi√ß√£o parece obscura a princ√≠pio, mas √© conveniente para manter os valores ap√≥s `.unwrap()`.\n"
"* O c√≥digo a seguir demonstra por que o compilador n√£o pode simplesmente reutilizar locais de mem√≥ria ao sobrepor uma "
"vari√°vel imut√°vel em um escopo, mesmo que o tipo n√£o seja alterado."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# Gerenciamento de mem√≥ria"

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradicionalmente, as linguagens se dividem em duas grandes categorias:"

#: src/memory-management.md:5
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ..."
msgstr ""
"* Controle total atrav√©s do gerenciamento manual de mem√≥ria: C, C++, Pascal, ...\n"
"* Seguran√ßa total atrav√©s do gerenciamento autom√°tico de mem√≥ria em tempo de execu√ß√£o: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust oferece uma nova mistura:"

#: src/memory-management.md:10
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> Controle total *e* seguran√ßa por imposi√ß√£o do correto gerenciamento de mem√≥ria em tempo de\n"
"> compila√ß√£o."

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "Ele faz isso com um conceito de ownership expl√≠cito."

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "Primeiro, vamos rever como o gerenciamento de mem√≥ria funciona."

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# Stack (pilha) vs Heap"

#: src/memory-management/stack-vs-heap.md:3
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality."
msgstr ""
"* Stack: √Årea cont√≠nua de mem√≥ria para vari√°veis locais.\n"
"  * Os valores t√™m tamanhos fixos conhecidos em tempo de compila√ß√£o.\n"
"  * Extremamente r√°pido: basta mover um ponteiro do stack.\n"
"  * F√°cil de gerenciar: segue chamadas de fun√ß√£o.\n"
"  * √ìtima localiza√ß√£o na mem√≥ria."

#: src/memory-management/stack-vs-heap.md:9
msgid ""
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* Heap: Armazenamento de valores fora das chamadas de fun√ß√£o.\n"
"  * Os valores t√™m tamanhos din√¢micos determinados em tempo de execu√ß√£o.\n"
"  * Ligeiramente mais lento que o stack: √© necess√°ria alguma contabilidade.\n"
"  * Sem garantia de localiza√ß√£o na mem√≥ria."

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# Mem√≥ria de pilha (stack Memory)"

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically sized\n"
"data on the heap:"
msgstr ""
"A cria√ß√£o de uma `String` coloca dados de tamanho fixo no stack e dados dimensionados dinamicamente\n"
"no heap:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                            Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                            Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/stack.md:28
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and length and can grow if mutable via reallocation on "
"the heap."
msgstr ""
"* Mencione que um `String` √© baseada em um `Vec`, ent√£o ele tem capacidade e comprimento e pode crescer se for mut√°vel por "
"meio de realoca√ß√£o no heap."

#: src/memory-management/stack.md:30
msgid ""
"* If students ask about it, you can mention that the underlying memory is heap allocated using the [System Allocator] and "
"custom allocators can be implemented using the [Allocator API]"
msgstr ""
"* Se os alunos perguntarem sobre isso, voc√™ pode mencionar que a mem√≥ria do heap √© alocada usando o [System Allocator] e "
"alocadores personalizados podem ser implementados usando a [Allocator API]"

#: src/memory-management/stack.md:32
msgid "* We can inspect the memory layout with `unsafe` code. However, you should point out that this is rightfully unsafe!"
msgstr "* Pode-se inspecionar o layout de mem√≥ria com c√≥digo `unsafe`. Entretanto, deve-se salientar que isto √© inseguro!"

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Ol√°\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"mundo\");\n"
"    // N√ÉO FA√áA ISSO EM CASA! Somente com prop√≥sito educacional.\n"
"    // String n√£o prov√©m nenhuma garantia sobre o seu layout, ent√£o isso pode levar\n"
"    // a um comportamento indefinido.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"        println!(\"Ponteiro = {ptr:#x}, tamanho = {len}, capacidade = {capacity}\");\n"
"    }\n"
"}\n"
"```"

#: src/memory-management/stack.md:51
msgid ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"
msgstr ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# Gerenciamento manual de mem√≥ria"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Voc√™ mesmo aloca e desaloca mem√≥ria no heap."

#: src/memory-management/manual.md:5
msgid "If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks."
msgstr ""
"Se n√£o for feito com cuidado, isso pode levar a travamentos, bugs, vulnerabilidades de seguran√ßa e vazamentos de mem√≥ria."

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## Exemplo em C"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "Voc√™ deve chamar `free` em cada ponteiro que alocar com `malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr ""
"A mem√≥ria vaza se a fun√ß√£o retornar mais cedo entre `malloc` e `free`: o\n"
"ponteiro √© perdido e n√£o podemos desalocar a mem√≥ria."

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# Gerenciamento de mem√≥ria baseado em escopo"

#: src/memory-management/scope-based.md:3
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr "Construtores e destrutores permitem que o tempo de vida de um objeto seja rastreado."

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception is\n"
"raised."
msgstr ""
"Ao envolver um ponteiro em um objeto, voc√™ pode liberar mem√≥ria quando o objeto √©\n"
"destru√≠do. O compilador garante que isso aconte√ßa, mesmo que uma exce√ß√£o seja\n"
"criada."

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and gives\n"
"you smart pointers."
msgstr ""
"Isso geralmente √© chamado de _aquisi√ß√£o de recursos √© inicializa√ß√£o_ (resource acquisition is initialization, RAII) e "
"fornece\n"
"ponteiros inteligentes."

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## Exemplo em C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Ol√° \" << person->name << std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* O objeto `std::unique_ptr` √© alocado no stack e aponta para\n"
"  mem√≥ria alocada no heap.\n"
"* No final de `say_hello`, o destrutor `std::unique_ptr` ser√° executado.\n"
"* O destrutor libera o objeto `Person` para o qual ele aponta."

#: src/memory-management/scope-based.md:25
msgid "Special move constructors are used when passing ownership to a function:"
msgstr "Construtores especiais de movimento (move) s√£o usados ao passar a \"ownership\" para uma fun√ß√£o:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "# Gerenciamento autom√°tico de mem√≥ria"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic memory\n"
"management:"
msgstr ""
"Uma alternativa ao gerenciamento de mem√≥ria manual e baseado em escopo √© o gerenciamento autom√°tico\n"
"de mem√≥ria:"

#: src/memory-management/garbage-collection.md:6
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the programmer."
msgstr ""
"* O programador nunca aloca ou desaloca mem√≥ria explicitamente.\n"
"* Um \"coletor de lixo\" (garbage collector) encontra mem√≥ria n√£o utilizada e a desaloca para o programador."

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Exemplo em Java"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "O objeto `person` n√£o √© desalocado depois que `sayHello` retorna:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Ol√° \" + person.getName());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# Gerenciamento de mem√≥ria do Rust"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "O gerenciamento de mem√≥ria no Rust √© uma mistura:"

#: src/memory-management/rust.md:5
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you choose, can be a single unique pointer, reference "
"counted, or atomically reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even have no cost at runtime like C."
msgstr ""
"* Seguro e correto como Java, mas sem coletor de lixo.\n"
"* Dependendo de qual abstra√ß√£o (ou combina√ß√£o de abstra√ß√µes) voc√™ escolher, pode ser um simples ponteiro √∫nico, refer√™ncia "
"contada ou refer√™ncia atomicamente contada.\n"
"* Baseado em escopo como C++, mas o compilador imp√µe ades√£o total.\n"
"* Um usu√°rio do Rust pode escolher a abstra√ß√£o certa para a situa√ß√£o, algumas at√© sem custo em tempo de execu√ß√£o como C."

#: src/memory-management/rust.md:10
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "Ele consegue isso modelando a propriedade (_ownership_) explicitamente."

#: src/memory-management/rust.md:14
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper types such as [Box], "
"[Vec], [Rc], or [Arc]. These encapsulate ownership and memory allocation via various means, and prevent the potential "
"errors in C."
msgstr ""
"* Neste ponto, se perguntado como, voc√™ pode mencionar que em Rust isso geralmente √© tratado por wrappers RAII como [Box], "
"[Vec], [Rc] ou [Arc]. Eles encapsulam a propriedade (ownership) e a aloca√ß√£o de mem√≥ria por v√°rios meios e evitam poss√≠veis erros em C."

#: src/memory-management/rust.md:16
msgid "* You may be asked about destructors here, the [Drop] trait is the Rust equivalent."
msgstr "* Voc√™ pode ser questionado sobre destrutores aqui, o trait [Drop] √© o equivalente em Rust."

#: src/memory-management/rust.md:20
msgid ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# Compara√ß√£o"

#: src/memory-management/comparison.md:3
msgid "Here is a rough comparison of the memory management techniques."
msgstr "Aqui est√° uma compara√ß√£o aproximada das t√©cnicas de gerenciamento de mem√≥ria."

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## Vantagens de diferentes t√©cnicas de gerenciamento de mem√≥ria"

#: src/memory-management/comparison.md:7
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Manual como C:\n"
"  * Nenhuma sobrecarga em tempo de execu√ß√£o.\n"
"* Autom√°tico como Java:\n"
"  * Totalmente automatizado.\n"
"  * Seguro e correto.\n"
"* Baseado em escopo como C++:\n"
"  * Parcialmente autom√°tico.\n"
"  * Nenhuma sobrecargo de tempo de execu√ß√£o.\n"
"* Baseado em escopo aplicado pelo compilador como Rust:\n"
"  * Aplicado pelo compilador.\n"
"  * Nenhuma sobrecarga em tempo de execu√ß√£o.\n"
"  * Seguro e correto."

#: src/memory-management/comparison.md:20
msgid "## Cons of Different Memory Management Techniques"
msgstr "## Desvantagens de diferentes t√©cnicas de gerenciamento de mem√≥ria"

#: src/memory-management/comparison.md:22
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Manual como C:\n"
"  * Uso ap√≥s a libera√ß√£o (use-after-free).\n"
"  * Libera√ß√µes duplas (double-free).\n"
"  * Vazamento de mem√≥ria.\n"
"* Autom√°tico como Java:\n"
"  * Pausa para coleta de lixo.\n"
"  * Atrasos na execu√ß√£o de destrutores.\n"
"* Baseado em escopo como C++:\n"
"  * Complexo, o programador deve optar em utiliz√°-las.\n"
"  * Potencial para uso ap√≥s a libera√ß√£o (user-after-free).\n"
"* Obrigado pelo compilador e baseado em escopo como Rust:\n"
"  * Alguma complexidade inicial.\n"
"  * Pode rejeitar programas v√°lidos."

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# Ownership"

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error to\n"
"use a variable outside its scope:"
msgstr ""
"Todas as associa√ß√µes de vari√°veis t√™m um _escopo_ onde s√£o v√°lidas e √© um erro\n"
"usar uma vari√°vel fora de seu escopo:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);"
msgstr ""
"```rust,editable,compile_fail\n"
"struct Ponto(i32, i32);"

#: src/ownership.md:9
msgid ""
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    {\n"
"        let p = Ponto(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"

#: src/ownership.md:18
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* No final do escopo, a vari√°vel √© _dropada_ e os dados s√£o liberados.\n"
"* Um destrutor pode ser executado aqui para liberar recursos.\n"
"* Dizemos que a vari√°vel _possui_ (√© dona) o valor."

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# Sem√¢ntica do `move` (mover)"

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer ownership between variables:"
msgstr "Uma atribui√ß√£o transferir√° a propriedade (ownership) entre vari√°veis:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Ol√°!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* A atribui√ß√£o de `s1` a `s2` transfere a ownership.\n"
"* Os dados foram _movidos_ de `s1` e `s1` n√£o est√£o mais acess√≠veis.\n"
"* Quando `s1` sai do escopo, nada acontece: ele n√£o tem ownership.\n"
"* Quando `s2` sai do escopo, os dados da string s√£o liberados.\n"
"* H√° sempre _exatamente_ uma associa√ß√£o de vari√°vel que possui um valor."

#: src/ownership/move-semantics.md:22
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by value unless you use `std::move` (and the move "
"constructor is defined!)."
msgstr ""
"* Mencione que isso √© o oposto dos padr√µes em C++, que copia por valor, a menos que voc√™ use `std::move` (e o construtor de "
"movimento esteja definido!)."

#: src/ownership/move-semantics.md:24
msgid "* In Rust, you clones are explicit (by using `clone`)."
msgstr "* No Rust, clones s√£o expl√≠citos (usando `clone`)."

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# Strings movidas em Rust"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* Os dados no heap de `s1` s√£o reutilizados para `s2`.\n"
"* Quando `s1` sai do escopo, nada acontece (foi movido dele)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Antes de mover para `s2`:"

#: src/ownership/moved-strings-rust.md:15
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Depois de mover para `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"  :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inacess√≠vel)\"   :     :                           :\n"
":   +------------+------+   :     :   +----+----+----+----+   :\n"
":   | ponteiro   |  o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | tamanho    |    4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacidade |    4 |   :  |  :                           :\n"
":   +------------+------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +------------+------+   :  |\n"
":   | ponteiro   |  o---+---+--'\n"
":   | tamanho    |    4 |   :\n"
":   | capacidade |    4 |   :\n"
":   +------------+------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# Libera√ß√µes duplas (double-free) em C++ moderno"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "O C++ moderno resolve isso de maneira diferente:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplica os dados em s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* Os dados de `s1` no heap s√£o duplicados e `s2` obt√©m sua pr√≥pria c√≥pia independente.\n"
"* Quando `s1` e `s2` saem do escopo, cada um libera sua pr√≥pria mem√≥ria."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Antes da atribui√ß√£o por c√≥pias:"

#: src/ownership/double-free-modern-cpp.md:16
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Ap√≥s atribui√ß√£o por c√≥pia:"

#: src/ownership/double-free-modern-cpp.md:32
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:1
msgid "# Moves in Function Calls"
msgstr "# Move (mover) em chamadas de Fun√ß√£o"

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr ""
"Quando voc√™ passa um valor para uma fun√ß√£o, o valor √© atribu√≠do ao par√¢metro\n"
"da fun√ß√£o. Isso transfere a ownership:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}"
msgstr ""
"```rust,editable\n"
"fn diz_ola(nome: String) {\n"
"    println!(\"Ol√° {nome}\")\n"
"}"

#: src/ownership/moves-function-calls.md:11
msgid ""
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let nome = String::from(\"Alice\");\n"
"    diz_ola(nome);\n"
"    // diz_ola(nome);\n"
"}\n"
"```"

#: src/ownership/moves-function-calls.md:20
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. Afterwards, `name` cannot be used anymore within "
"`main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the `say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) and if `say_hello` accepts a reference as a "
"parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call (`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making move semantics the default, and by forcing "
"programmers to make clones explicit."
msgstr ""
"* Com a primeira chamada para `say_hello`, `main` desiste da ownership de `name`. Depois disso, `name` n√£o pode mais ser "
"usado dentro de `main`.\n"
"* A mem√≥ria heap alocada para `name` ser√° liberada no final da fun√ß√£o `say_hello`.\n"
"* `main` pode manter a ownership se passar `name` como uma refer√™ncia (`&name`) e se `say_hello` aceitar uma refer√™ncia "
"como um par√¢metro.\n"
"* Alternativamente, `main` pode passar um clone de `name` na primeira chamada (`name.clone()`).\n"
"* Rust torna mais dif√≠cil do que o C++ a cria√ß√£o de c√≥pias inadvertidamente, tornando a sem√¢ntica de movimento o padr√£o e for√ßando "
"os programadores a tornar os clones expl√≠citos."

#: src/ownership/copy-clone.md:1
msgid "# Copying and Cloning"
msgstr "# Copiar e clonar"

#: src/ownership/copy-clone.md:3
msgid "While move semantics are the default, certain types are copied by default:"
msgstr "Embora a sem√¢ntica de movimento seja o padr√£o, certos tipos s√£o copiados por padr√£o:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "Esses tipos implementam o recurso `Copy`."

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr "Voc√™ pode ativar seus pr√≥prios tipos para usar a sem√¢ntica de c√≥pia:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);"
msgstr ""
"```rust, editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Ponto(i32, i32);"

#: src/ownership/copy-clone.md:22
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Ponto(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:30
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* Ap√≥s a atribui√ß√£o, tanto `p1` quanto `p2` possuem seus pr√≥prios dados.\n"
"* Tamb√©m podemos usar `p1.clone()` para copiar explicitamente os dados."

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "Copiar e clonar n√£o s√£o a mesma coisa:"

#: src/ownership/copy-clone.md:37
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by implementing the `Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* A c√≥pia refere-se a c√≥pias bit a bit de regi√µes de mem√≥ria e n√£o funciona em objetos arbitr√°rios.\n"
"* A c√≥pia n√£o permite l√≥gica personalizada (ao contr√°rio dos construtores de c√≥pia em C++).\n"
"* A clonagem √© uma opera√ß√£o mais geral e tamb√©m permite um comportamento personalizado implementando a trait `Clone`.\n"
"* A c√≥pia n√£o funciona em tipos que implementam a caracter√≠stica `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "No exemplo acima, tente o seguinte:"

#: src/ownership/copy-clone.md:44
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because `String` is not a `Copy` type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in the `println!` for  `p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* Adicione um campo `String` ao `struct Point`. N√£o ir√° compilar porque `String` n√£o √© um tipo `Copy`.\n"
"* Remova `Copy` do atributo `derive`. O erro do compilador agora est√° no `println!` para `p1`.\n"
"* Mostre que funciona se voc√™ clonar `p1` em vez disso."

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way to generate code in Rust\n"
"at compile time. In this case the default implementations of `Copy` and `Clone` traits are generated.\n"
"    \n"
"</details>"
msgstr ""
"Se os alunos perguntarem sobre `derive`, basta dizer que esta √© uma forma de gerar c√≥digo em Rust\n"
"em tempo de compila√ß√£o. Nesse caso, as implementa√ß√µes padr√£o dos traits `Copy` e `Clone` s√£o geradas.\n"
"    \n"
"</details>"

#: src/ownership/borrowing.md:1
msgid "# Borrowing"
msgstr "# Empr√©stimo (Borrowing)"

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr ""
"Em vez de transferir a ownership ao chamar uma fun√ß√£o, voc√™ pode permitir que uma\n"
"fun√ß√£o _empreste_ o valor:"

#: src/ownership/borrowing.md:6 src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);"
msgstr ""
"```rust, editable\n"
"#[derive(Debug)]\n"
"struct Ponto(i32, i32);"

#: src/ownership/borrowing.md:10
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"
msgstr ""
"fn somar(p1: &Ponto, p2: &Ponto) -> Ponto {\n"
"    Ponto(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"

#: src/ownership/borrowing.md:14
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Ponto(3, 4);\n"
"    let p2 = Ponto(10, 20);\n"
"    let p3 = somar(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"

#: src/ownership/borrowing.md:22
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* A fun√ß√£o `somar` _pega emprestado_ (_borrowing_) dois Pontos e retorna um novo Ponto.\n"
"* O chamador mant√©m a _ownership_ das entradas."

#: src/ownership/borrowing.md:27
msgid ""
"Notes on stack returns:\n"
"* Demonstrate that the return from `add` is cheap because the compiler can eliminate the copy operation. Change the above "
"code to print stack addresses and run it on the [Playground]. In the \"DEBUG\" optimization level, the addresses should "
"change, while the stay the same when changing to the \"RELEASE\" setting:"
msgstr ""
"Notas sobre retornos de pilha:\n"
"* Demonstre que o retorno de `somar` √© barato porque o compilador pode eliminar a opera√ß√£o de c√≥pia. Altere o c√≥digo acima "
"para imprimir endere√ßos de pilha e execute-o no [Playground]. No n√≠vel de otimiza√ß√£o \"DEBUG\", os endere√ßos devem mudar, "
"enquanto permanecem os mesmos ao mudar para a configura√ß√£o \"RELEASE\":"

#: src/ownership/borrowing.md:30
msgid ""
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"  ```rust, editable\n"
"  #[derive(Debug)]\n"
"  struct Ponto(i32, i32);"

#: src/ownership/borrowing.md:34
msgid ""
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"
msgstr ""
"  fn somar(p1: &Ponto, p2: &Ponto) -> Ponto {\n"
"      let p = Ponto(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"

#: src/ownership/borrowing.md:40
msgid ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, "
"this is not an issue at all. If RVO did not happen, Rust will always performs a simple and efficient `memcpy` copy."
msgstr ""
"  fn main() {\n"
"      let p1 = Ponto(3, 4);\n"
"      let p2 = Ponto(10, 20);\n"
"      let p3 = somar(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* O compilador Rust pode fazer otimiza√ß√£o de valor de retorno (RVO).\n"
"* Em C++, a elis√£o de c√≥pia deve ser definida na especifica√ß√£o da linguagem porque os construtores podem ter efeitos "
"colaterais. Em Rust, isso n√£o √© um problema. Se o RVO n√£o aconteceu, o Rust sempre executar√° uma c√≥pia `memcpy` simples e "
"eficiente."

#: src/ownership/borrowing.md:53
msgid "[Playground]: https://play.rust-lang.org/"
msgstr "[Playground]: https://play.rust-lang.org/"

#: src/ownership/shared-unique-borrows.md:1
msgid "# Shared and Unique Borrows"
msgstr "# Empr√©stimos compartilhados e exclusivos"

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "O Rust coloca restri√ß√µes nas formas como voc√™ pode emprestar valores:"

#: src/ownership/shared-unique-borrows.md:5
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* Voc√™ pode ter um ou mais valores `&T` a qualquer momento, _ou_\n"
"* Voc√™ pode ter exatamente um valor `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"

#: src/ownership/shared-unique-borrows.md:13
msgid ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"
msgstr ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"

#: src/ownership/shared-unique-borrows.md:18 src/std/rc.md:13
msgid ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"* The above code does not compile because `a` is borrowed as mutable (through `c`) and as immutable (through `b`) at the "
"same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` to make the code compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before the new mutable borrow of `a` through `c`. "
"This is a feature of the borrow checker called \"non-lexical lifetimes\"."
msgstr ""
"* O c√≥digo acima n√£o compila porque `a` √© emprestado como mut√°vel (atrav√©s de `c`) e como imut√°vel (atrav√©s de `b`) ao "
"mesmo tempo.\n"
"* Mova a instru√ß√£o `println!` para `b` antes do escopo que introduz `c` para fazer o c√≥digo compilar.\n"
"* Ap√≥s essa altera√ß√£o, o compilador percebe que `b` s√≥ √© usado antes do novo empr√©stimo mut√°vel de `a` a `c`. Este √© um "
"recurso do verificador de empr√©stimo chamado \"tempo de vida n√£o lexical\"."

#: src/ownership/lifetimes.md:1
msgid "# Lifetimes"
msgstr "# Tempos de vida"

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "Um valor emprestado tem um tempo de vida (_lifetime_):"

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that there is\n"
"    a valid solution."
msgstr ""
"* O tempo de vida pode ser omitido: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Tempos de vida tamb√©m podem ser expl√≠citos: `&'a Point`, `&'document str`.\n"
"* Leia `&'a Point` como \"um `Point` emprestado que √© v√°lido por pelo menos o\n"
"  tempo de vida `a`\".\n"
"* Os tempos de vida s√£o sempre inferidos pelo compilador: voc√™ n√£o pode atribuir um tempo de vida\n"
"  voc√™ mesmo.\n"
"  * As anota√ß√µes vital√≠cias criam restri√ß√µes; o compilador verifica se h√°\n"
"    uma solu√ß√£o v√°lida."

#: src/ownership/lifetimes-function-calls.md:1
msgid "# Lifetimes in Function Calls"
msgstr "# Tempos de vida em chamadas de fun√ß√£o"

#: src/ownership/lifetimes-function-calls.md:3
msgid "In addition to borrowing its arguments, a function can return a borrowed value:"
msgstr "Al√©m de emprestar seus argumentos, uma fun√ß√£o pode retornar um valor emprestado:"

#: src/ownership/lifetimes-function-calls.md:9
msgid ""
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"
msgstr ""
"fn mais_a_esquerda<'a>(p1: &'a Ponto, p2: &'a Ponto) -> &'a Ponto{\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"

#: src/ownership/lifetimes-function-calls.md:13
msgid ""
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1: Ponto = Ponto(10, 10);\n"
"    let p2: Ponto = Ponto(20, 20);\n"
"    let p3: &Ponto = mais_a_esquerda(&p1, &p2);\n"
"    println!(\"Ponto mais √† esquerda: {:?}\", p3);\n"
"}\n"
"```"

#: src/ownership/lifetimes-function-calls.md:21
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` √© um par√¢metro gen√©rico, √© inferido pelo compilador.\n"
"* Os tempos de vida come√ßam com `'` e `'a` √© um name padr√£o t√≠pico.\n"
"* Leia `&'a Ponto` como \"um `Ponto` emprestado que √© v√°lido por pelo menos o\n"
"  tempo de vida `a`\".\n"
"  * A parte _pelo menos_ √© importante quando os par√¢metros est√£o em escopos diferentes."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), resulting in the following code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"* Mova a declara√ß√£o de `p2` e `p3` para um novo escopo (`{ ... }`), resultando no seguinte c√≥digo:\n"
"  ```rust, ignore\n"
"  #[derive(Debug)]\n"
"  struct Ponto(i32, i32);"

#: src/ownership/lifetimes-function-calls.md:36
msgid ""
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"
msgstr ""
"  fn mais_a_esquerda<'a>(p1: &'a Ponto, p2: &'a Ponto) -> &'a Ponto {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"

#: src/ownership/lifetimes-function-calls.md:40
msgid ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"  fn main() {\n"
"      let p1: Ponto = Ponto(10, 10);\n"
"      let p3: &Ponto;\n"
"      {\n"
"          let p2: Ponto = Ponto(20, 20);\n"
"          p3 = mais_a_esquerda(&p1, &p2);\n"
"      }\n"
"      println!(\"Ponto mais √† esquerda: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Observe como isso n√£o compila, pois `p3` sobrevive a `p2`."

#: src/ownership/lifetimes-function-calls.md:52
msgid ""
"* Reset the workspace and change the function signature to `fn left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b "
"Point`. This will not compile because the relationship between the lifetimes `'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global variable).\n"
"  * Which one is it? The compiler needs to to know, so at the call site the returned reference is not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""
"* Redefina o espa√ßo de trabalho e altere a assinatura da fun√ß√£o para `fn mais_a_esquerda<'a, 'b>(p1: &'a Ponto, p2: &'a Ponto) -> "
"&'b Ponto`. Isso n√£o ser√° compilado porque a rela√ß√£o entre os tempos de vida `'a` e `'b` n√£o √© clara.\n"
"* Outra forma de explicar:\n"
"  * Duas refer√™ncias a dois valores s√£o emprestadas por uma fun√ß√£o e a fun√ß√£o retorna\n"
"    outra refer√™ncia.\n"
"  * Deve ter vindo de uma dessas duas entradas (ou de uma vari√°vel global).\n"
"  * Qual √©? O compilador precisa saber, portanto, no local da chamada, a refer√™ncia retornada n√£o √© usada\n"
"    por mais tempo do que uma vari√°vel de onde veio a refer√™ncia."

#: src/ownership/lifetimes-data-structures.md:1
msgid "# Lifetimes in Data Structures"
msgstr "# Tempos de vida em estruturas de dados"

#: src/ownership/lifetimes-data-structures.md:3
msgid "If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr "Se um tipo de dados armazena dados emprestados, ele deve ser anotado com um tempo de vida:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);"
msgstr ""
"```rust, editable\n"
"#[derive(Debug)]\n"
"struct Destaque<'doc>(&'doc str);"

#: src/ownership/lifetimes-data-structures.md:9
msgid ""
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}"
msgstr ""
"fn apagar(texto: String) {\n"
"    println!(\"Tchau {texto}!\");\n"
"}"

#: src/ownership/lifetimes-data-structures.md:13
msgid ""
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let texto = String::from(\"A esperta raposa marrom pula sobre o cachorro pregui√ßoso.\");\n"
"    let raposa = Destaque(&texto[2..23]);\n"
"    let cachorro = Destaque(&texto[37..57]);\n"
"    // apagar(texto);\n"
"    println!(\"{raposa:?}\");\n"
"    println!(\"{cachorro:?}\");\n"
"}\n"
"```"

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data underlying the contained `&str` lives at least "
"as long as any instance of `Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), the borrow checker throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This can be useful for creating lightweight views, "
"but it generally makes them somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one lifetime annotation. This can be necessary if there "
"is a need to describe lifetime relationships between the references themselves, in addition to the lifetime of the struct "
"itself. Those are very advanced use cases.\n"
"</details>"
msgstr ""
"* No exemplo acima, a anota√ß√£o em `Destaque` imp√µe que os dados subjacentes ao `&str` contido vivam pelo menos tanto "
"quanto qualquer inst√¢ncia de `Destaque` que usa esses dados.\n"
"* Se `texto` for consumido antes do final do tempo de vida de `raposa` (ou `cachorro`), o verificador de empr√©stimo lan√ßar√° um "
"erro.\n"
"* Tipos com dados emprestados for√ßam os usu√°rios a manter os dados originais. Isso pode ser √∫til para criar exibi√ß√µes "
"leves, mas geralmente as tornam um pouco mais dif√≠ceis de usar.\n"
"* Quando poss√≠vel, fa√ßa com que as _Structs_ de dados possuam seus dados diretamente.\n"
"* Algumas _Structs_ com v√°rias refer√™ncias internas podem ter mais de uma anota√ß√£o vital√≠cia. Isso pode ser necess√°rio se "
"houver necessidade de descrever relacionamentos de tempo de vida entre as pr√≥prias refer√™ncias, al√©m do tempo de vida da "
"pr√≥pria estrutura. Esses s√£o casos de uso muito avan√ßados.\n"
"</details>"

#: src/exercises/day-1/afternoon.md:1
msgid "# Day 1: Afternoon Exercises"
msgstr "# Dia 1: Exerc√≠cios da Tarde"

#: src/exercises/day-1/afternoon.md:3
msgid "We will look at two things:"
msgstr "Veremos duas coisas:"

#: src/exercises/day-1/afternoon.md:5
msgid "* A small book library,"
msgstr "* Uma pequena biblioteca de livros,"

#: src/exercises/day-1/afternoon.md:7
msgid "* Iterators and ownership (hard)."
msgstr "* Iteradores e ownership (dif√≠cil)."

#: src/exercises/day-1/afternoon.md:13 src/exercises/day-2/afternoon.md:9
msgid "[solutions]: solutions-afternoon.md"
msgstr "[solu√ß√µes]: solu√ß√µes-tarde.md"

#: src/exercises/day-1/book-library.md:1
msgid "# Designing a Library"
msgstr "# Projetando uma biblioteca"

#: src/exercises/day-1/book-library.md:3
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For now,\n"
"you just need to know part of its API:"
msgstr ""
"Aprenderemos muito mais sobre structs e o tipo `Vec<T>` amanh√£. Por hora,\n"
"voc√™ s√≥ precisa conhecer parte de sua API:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut vetor = vec![10, 20];\n"
"    vetor.push(30);\n"
"    println!(\"valor do meio: {}\", vetor[vetor.len() / 2]);\n"
"    for item in vetor.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:17
msgid ""
"Use this to create a library application. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Use isso para criar um aplicativo de biblioteca. Copie o c√≥digo abaixo para\n"
"<https://play.rust-lang.org/> e atualize os tipos para compilar:"

#: src/exercises/day-1/book-library.md:24
msgid ""
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""
"struct Biblioteca {\n"
"    livros: Vec<Livro>,\n"
"}"

#: src/exercises/day-1/book-library.md:28 src/exercises/day-1/solutions-afternoon.md:27
msgid ""
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}"
msgstr ""
"struct Livro {\n"
"    titulo: String,\n"
"    ano: u16,\n"
"}"

#: src/exercises/day-1/book-library.md:33 src/exercises/day-1/solutions-afternoon.md:32
msgid ""
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Livro {\n"
"    // Este √© um construtor, usado abaixo.\n"
"    fn new(titulo: &str, ano: u16) -> Livro {\n"
"        Livro {\n"
"            titulo: String::from(titulo),\n"
"            ano,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:43
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"
msgstr ""
"// Isso torna poss√≠vel imprimir valores de livro com {}.\n"
"impl std::fmt::Display for Livro {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.titulo, self.ano)\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:50
msgid ""
"impl Library {\n"
"    fn new() -> Library {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Biblioteca {\n"
"    fn new() -> Biblioteca {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-1/book-library.md:55
msgid ""
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn tamanho(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:59
msgid ""
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn tem_livros(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:63
msgid ""
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn adiciona_livro(self, livro: Livro) {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:67
msgid ""
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""
"    //fn imprime_acervo(self) {\n"
"    //    unimplemented!()\n"
"    //}"

#: src/exercises/day-1/book-library.md:71
msgid ""
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"
msgstr ""
"    //fn livro_mais_antigo(self) -> Option<&Livro> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"

#: src/exercises/day-1/book-library.md:76
msgid ""
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""
"// Isso mostra o comportamento desejado. Descomente o c√≥digo abaixo e\n"
"// implemente os m√©todos ausentes. Voc√™ precisar√° atualizar as\n"
"// assinaturas de m√©todo, incluindo o par√¢metro \"self\"! Voc√™ poder√°\n"
"// tamb√©m precisar atualizar as liga√ß√µes de vari√°veis dentro de main.\n"
"fn main() {\n"
"    let biblioteca = Biblioteca::new();"

#: src/exercises/day-1/book-library.md:83
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"```"
msgstr ""
"   // println!(\"Nossa biblioteca est√° vazia: {}\", biblioteca.tem_livros());\n"
"   // \n"
"   // biblioteca.adiciona_livro(Livro::new(\"Lord of the Rings\", 1954));\n"
"   // biblioteca.adiciona_livro(Livro::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"   // \n"
"   // biblioteca.imprime_acervo();\n"
"   // \n"
"   // match biblioteca.livro_mais_antigo() {\n"
"   //  Some(livro) => println!(\"Meu livro mais antigo √© {livro}\"),\n"
"   //  None => println!(\"Minha biblioteca est√° vazia!\"),\n"
"   // }\n"
"   // \n"
"   // println!(\"Nossa biblioteca tem {} livros\", biblioteca.tamanho());\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:99
msgid ""
"<details>\n"
"    \n"
"[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"<details>\n"
"    \n"
"[Solu√ß√µes](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:1
msgid "# Iterators and Ownership"
msgstr "# Iteradores e ownership"

#: src/exercises/day-1/iterators-and-ownership.md:3
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr ""
"O modelo de _ownership_ do Rust afeta muitas APIs. Um exemplo disso s√£o os _traits_\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) e\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)."

#: src/exercises/day-1/iterators-and-ownership.md:8
msgid "## `Iterator`"
msgstr "## `Iterator` (iterador)"

#: src/exercises/day-1/iterators-and-ownership.md:10
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` back:"
msgstr ""
"Os _traits_ s√£o como interfaces: eles descrevem o comportamento (m√©todos) para um tipo. o\n"
"O _trait_ `Iterator` simplesmente diz que voc√™ pode chamar `next` at√© obter `None` como retorno:"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:20
msgid "You use this trait like this:"
msgstr "Voc√™ usa esse trait assim:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"

#: src/exercises/day-1/iterators-and-ownership.md:27
msgid ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"Sem mais itens: {:?}\", iter.next());\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:34
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "Qual √© o tipo retornado pelo iterador? Teste sua resposta aqui:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"

#: src/exercises/day-1/iterators-and-ownership.md:41 src/exercises/day-1/iterators-and-ownership.md:78
msgid ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:46
msgid "Why is this type used?"
msgstr "Por que esse tipo?"

#: src/exercises/day-1/iterators-and-ownership.md:48
msgid "## `IntoIterator`"
msgstr "## `IntoIterator`"

#: src/exercises/day-1/iterators-and-ownership.md:50
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the iterator:"
msgstr ""
"O _trait_ `Iterator` informa como _iterar_ depois de criar um\n"
"iterador. A caracter√≠stica relacionada `IntoIterator` informa como criar o iterador:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"
msgstr ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"

#: src/exercises/day-1/iterators-and-ownership.md:58
msgid ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:62
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr ""
"A sintaxe aqui significa que toda implementa√ß√£o de `IntoIterator` deve\n"
"declarar dois tipos:"

#: src/exercises/day-1/iterators-and-ownership.md:65
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: o tipo sobre o qual iteramos, como `i8`,\n"
"* `IntoIter`: o tipo `Iterator` retornado pelo m√©todo `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Observe que `IntoIter` e `Item` est√£o vinculados: o iterador deve ter o mesmo\n"
"Tipo `Item`, o que significa que ele retorna `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Como antes, qual √© o tipo retornado pelo iterador?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"

#: src/exercises/day-1/iterators-and-ownership.md:83
msgid "## `for` Loops"
msgstr "## La√ßos `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"Agora que conhecemos `Iterator` e `IntoIterator`, podemos construir la√ßos `for`.\n"
"Eles chamam `into_iter()` em uma express√£o e itera sobre o resultado\n"
"iterador:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"

#: src/exercises/day-1/iterators-and-ownership.md:93
msgid ""
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }"
msgstr ""
"    for palavra in &v {\n"
"        println!(\"Palavra: {palavra}\");\n"
"    }"

#: src/exercises/day-1/iterators-and-ownership.md:97
msgid ""
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    for palavra in v {\n"
"        println!(\"Palavra: {palavra}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:103
msgid "What is the type of `word` in each loop?"
msgstr "Qual √© o tipo de `palavra` em cada la√ßo?"

#: src/exercises/day-1/iterators-and-ownership.md:105
msgid ""
"Experiment with the code above and then consult the documentation for [`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"to check your answers."
msgstr ""
"Experimente o c√≥digo acima e depois consulte a documenta√ß√£o para [`impl\n"
"IntoIterator para\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"e [`impl IntoIterator para\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"para verificar suas respostas."

#: src/welcome-day-2.md:1
msgid "# Welcome to Day 2"
msgstr "# Bem-vindo ao dia 2"

#: src/welcome-day-2.md:3
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Agora que vimos uma boa quantidade de Rust, continuaremos com:"

#: src/welcome-day-2.md:5
msgid "* Structs, enums, methods."
msgstr "* Estruturas (`structs`), enumera√ß√µes (`enums`) e m√©todos."

#: src/welcome-day-2.md:7
msgid "* Pattern matching: destructuring enums, structs, and arrays."
msgstr "* Correspond√™ncia de padr√µes: desestruturando enumera√ß√µes, estruturas e vetores."

#: src/welcome-day-2.md:9
msgid ""
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and\n"
"  `continue`."
msgstr ""
"* Constru√ß√µes de fluxo de controle: `if`, `if let`, `while`, `while let`, `break` e\n"
"  `continue`."

#: src/welcome-day-2.md:12
msgid ""
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`\n"
"  and `Arc`."
msgstr ""
"* A Biblioteca Padr√£o: `String`, `Option` e `Result`, `Vec`, `HashMap`, `Rc`\n"
"  e 'Arc'."

#: src/welcome-day-2.md:15
msgid "* Modules: visibility, paths, and filesystem hierarchy."
msgstr "* M√≥dulos: visibilidade, caminhos e hierarquia do sistema de arquivos."

#: src/structs.md:1
msgid "# Structs"
msgstr "# Estruturas (Structs)"

#: src/structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Como C e C++, Rust tem suporte para `structs` personalizadas:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""
"```rust, editable\n"
"struct Pessoa {\n"
"    nome: String,\n"
"    idade: u8,\n"
"}"

#: src/structs.md:11
msgid ""
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut pedro = Pessoa {\n"
"        nome: String::from(\"Pedro\"),\n"
"        idade: 27,\n"
"    };\n"
"    println!(\"{} tem {} anos.\", pedro.nome, pedro.idade);\n"
"    \n"
"    pedro.idade= 28;\n"
"    println!(\"{} tem {} anos.\", pedro.nome, pedro.idade);\n"
"    \n"
"    let jackie = Pessoa {\n"
"        nome: String::from(\"Jackie\"),\n"
"        ..pedro\n"
"    };\n"
"    println!(\"{} tem {} anos.\", jackie.nome, jackie.idade);\n"
"}\n"
"```"

#: src/structs.md:29
msgid ""
"<details>\n"
"Key Points: "
msgstr ""
"<details>\n"
"Pontos chave:"

#: src/structs.md:32
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following slides.\n"
"* This may be a good time to let people know there are different types of structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a trait on some type but don't have any data "
"that you want to store in the value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the old struct without having to explicitly type "
"it all out. It must always be the last element."

msgstr ""
"* Structs funcionam como em C ou C++.\n"
"  * Como em C++, e ao contr√°rio de C, nenhum typedef √© necess√°rio para definir um tipo.\n"
"  * Ao contr√°rio do C++, n√£o h√° heran√ßa entre structs.\n"
"* Os m√©todos s√£o definidos em um bloco `impl`, que veremos nos pr√≥ximos slides.\n"
"* Este pode ser um bom momento para que as pessoas saibam que existem diferentes tipos de structs.\n"
"  * _Structs_ de tamanho zero `por exemplo, struct Foo;` podem ser usadas ao implementar uma caracter√≠stica em algum tipo,\n"
"mas n√£o possuem nenhum dado que voc√™ deseja armazenar nelas.\n"
"  * O pr√≥ximo slide apresentar√° as estruturas tuplas (_Tuple Structs_) usadas quando o nome dos campos n√£o s√£o importantes.\n"
"* A sintaxe `..pedro` permite a c√≥pia da maioria do campos de uma _struct_ sem precisar explicitar seus tipos.\n"
" Ele precisa ser o √∫ltimo elemento."

#: src/structs/tuple-structs.md:1
msgid "# Tuple Structs"
msgstr "# Estruturas Tupla (Tuple Structs)"

#: src/structs/tuple-structs.md:3
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "Se os nomes dos campos n√£o forem importantes, voc√™ pode usar uma estrutura de tupla:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);"
msgstr ""
"```rust, editable\n"
"struct Ponto(i32, i32);"

#: src/structs/tuple-structs.md:8
msgid ""
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p = Ponto(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"

#: src/structs/tuple-structs.md:14
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr "Isso geralmente √© usado para wrappers de campo √∫nico (chamados newtypes):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"
msgstr ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"

#: src/structs/tuple-structs.md:20
msgid ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}"
msgstr ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Pergunte a um cientista de foguetes da NASA\")\n"
"}"

#: src/structs/tuple-structs.md:24
msgid ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"
msgstr ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"

#: src/structs/tuple-structs.md:28
msgid ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"
msgstr ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"

#: src/structs/tuple-structs.md:33 src/traits/default.md:36 src/generics/trait-objects.md:86
msgid "```"
msgstr "```"

#: src/structs/tuple-structs.md:37
msgid ""
"Newtypes are a great way to encode additional information about the value in a primitive type, for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer have to validate it again at every use: "
" `PhoneNumber(String)` or `OddNumber(u32)`.\n"
"    \n"
"</details>"
msgstr ""
"Newtypes s√£o uma √≥tima maneira de codificar informa√ß√µes adicionais sobre o valor em um tipo primitivo, por exemplo:\n"
"  * O n√∫mero √© medido em algumas unidades: `Newtons` no exemplo acima.\n"
"  * O valor passou por alguma valida√ß√£o quando foi criado, ent√£o voc√™ n√£o precisa mais valid√°-lo novamente a cada uso: "
" `PhoneNumber(String)` ou `OddNumber(u32)`.\n"
"    \n"
"</details>"

#: src/structs/field-shorthand.md:1
msgid "# Field Shorthand Syntax"
msgstr "# Sintaxe abreviada de campo"

#: src/structs/field-shorthand.md:3
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr ""
"Se voc√™ j√° tiver vari√°veis com os nomes corretos, poder√° criar o\n"
"struct usando uma abrevia√ß√£o:"

#: src/structs/field-shorthand.md:6 src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""
"```rust, editable\n"
"#[derive(Debug)]\n"
"struct Pessoa {\n"
"    nome: String,\n"
"    idade: u8,\n"
"}"

#: src/structs/field-shorthand.md:13
msgid ""
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}"
msgstr ""
"impl Pessoa {\n"
"    fn new(nome: String, idade: u8) -> Pessoa {\n"
"        Pessoa { nome, idade }\n"
"    }\n"
"}"

#: src/structs/field-shorthand.md:19
msgid ""
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let pedro = Pessoa::new(String::from(\"Pedro\"), 27);\n"
"    println!(\"{pedro:?}\");\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:27
msgid "The `new` function could be written using `Self` as a type, as it is interchangeable with the struct type name"
msgstr "A fun√ß√£o `new` pode ser escrita usando `Self` como um tipo, j√° que √© intercambi√°vel com o name do tipo _struct_"

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"</details>"
msgstr ""
"```rust, ignore\n"
"impl Pessoa {\n"
"    fn new(nome: String, idade: u8) -> Self {\n"
"        Self { nome, idade }\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"</details>"

#: src/enums.md:1
msgid "# Enums"
msgstr "# Enumera√ß√µes (Enums)"

#: src/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr ""
"A palavra-chave `enum` permite a cria√ß√£o de um tipo que possui algumas\n"
"varia√ß√µes diferentes:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}"
msgstr ""
"```rust, editable\n"
"fn gerador_numero_aleatorio() -> i32 {\n"
"    4 // Escolhido por jogada de dados justa. Garantido para ser aleat√≥rio.\n"
"}"

#: src/enums.md:11
msgid ""
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"enum CaraCoroa {\n"
"    Cara,\n"
"    Coroa,\n"
"}"

#: src/enums.md:17
msgid ""
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}"
msgstr ""
"fn jogar_moeda() -> CaraCoroa {\n"
"    let numero_aleatorio = gerador_numero_aleatorio();\n"
"    if numero_aleatorio % 2 == 0 {\n"
"        return CaraCoroa::Cara;\n"
"    } else {\n"
"        return CaraCoroa::Coroa;\n"
"    }\n"
"}"

#: src/enums.md:26
msgid ""
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    println!(\"Voc√™ tem: {:?}\", jogar_moeda());\n"
"}\n"
"```"

#: src/enums.md:31
msgid ""
"<details>\n"
"    \n"
"Key Points:"
msgstr ""
"<details>\n"
"    \n"
"Pontos chave:"

#: src/enums.md:35
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and `Tail`. You might note the namespace when using "
"variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant "
"payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate structs but then they wouldn't be the same "
"type as they would if they were all defined in an enum. \n"
"</details>"
msgstr ""
"* As enumera√ß√µes permitem que voc√™ colete um conjunto de valores em um tipo\n"
"* Esta p√°gina oferece um tipo de Enum `CoinFlip` com duas variantes `Heads` e `Tail`. Voc√™ pode observar o namespace ao "
"usar variantes.\n"
"* Este pode ser um bom momento para comparar Structs e Enums:\n"
"  * Em ambos, voc√™ pode ter uma vers√£o simples sem campos (unit struct) ou uma com diferentes tipos de campos (variant "
"payloads).\n"
"  * Em ambos, as fun√ß√µes associadas s√£o definidas dentro de um bloco `impl`.\n"
"  * Voc√™ pode at√© mesmo implementar as diferentes variantes de uma Enum com Structs separadas, mas elas n√£o seriam do mesmo "
"tipo que seriam se todas fossem definidas em uma Enum.\n"
"</details>"

#: src/enums/variant-payloads.md:1
msgid "# Variant Payloads"
msgstr "# Variantes de carga √∫til (payloads)"

#: src/enums/variant-payloads.md:3
msgid ""
"You can define richer enums where the variants carry data. You can then use the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"Voc√™ pode definir enums mais ricos onde as variantes carregam dados. Voc√™ pode ent√£o usar a\n"
"instru√ß√£o `match` para extrair os dados de cada variante:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}"
msgstr ""
"```rust, editable\n"
"enum WebEvent {\n"
"    PageLoad, // Variante sem payload\n"
"    KeyPress(char), // Variante da estrutura da tupla\n"
"    Click { x: i64, y: i64 }, // Variante de struct completa\n"
"}"

#: src/enums/variant-payloads.md:13
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}"
msgstr ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event{\n"
"        WebEvent::PageLoad => println!(\"p√°gina carregada\"),\n"
"        WebEvent::KeyPress(c) => println!(\"pressionou '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicou em x={x}, y={y}\"),\n"
"    }\n"
"}"

#: src/enums/variant-payloads.md:22
msgid ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"
msgstr ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"

#: src/enums/variant-payloads.md:27
msgid ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"

#: src/enums/variant-payloads.md:35
msgid ""
"* In the above example, accessing the `char` in `KeyPress`, or `x` and `y` in `Click` only works within a `match` or an `if "
"let` statement.\n"
"* `match` and `if let` inspect a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling `std::mem::discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs where comparing field values doesn't affect "
"equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level `struct Click { ... }`. "
"The inlined version cannot implement traits, for example."
msgstr ""
"* No exemplo acima, acessar o `char` em `KeyPress`, ou `x` e `y` em `Click` s√≥ funciona dentro de uma instru√ß√£o `match`\n"
" ou em uma express√£o `if let`.\n"
"* `match` inspeciona um campo discriminante oculto no `enum`.\n"
"* √â poss√≠vel recuperar o campo discriminante chamando `std::mem::discriminant()`.\n"
"* `WebEvent::Click { ... }` n√£o √© exatamente o mesmo que `WebEvent::Click(Click)` com um `struct Click { ... }` de n√≠vel "
"superior. A vers√£o embutida n√£o pode implementar traits, por exemplo."

#: src/enums/sizes.md:1
msgid "# Enum Sizes"
msgstr "# Tamanhos de Enum"

#: src/enums/sizes.md:3
msgid "Rust enums are packed tightly, taking constraints due to alignment into account:"
msgstr "Enums, em Rust, s√£o empacotados firmemente, levando em considera√ß√£o as restri√ß√µes devido ao alinhamento:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};"
msgstr ""

#: src/enums/sizes.md:8
msgid ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"
msgstr ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: tamano: {} byte(s), alinhamento: {} byte(s)\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"

#: src/enums/sizes.md:15
msgid ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"
msgstr ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"

#: src/enums/sizes.md:20
msgid ""
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}"
msgstr ""

#: src/enums/sizes.md:27
msgid ""
"fn main() {\n"
"    dbg_size!(Foo);\n"
"    dbg_size!(Bar);\n"
"    dbg_size!(bool);\n"
"    dbg_size!(Option<bool>);\n"
"    dbg_size!(&i32);\n"
"    dbg_size!(Option<&i32>);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:37
msgid "* See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr "* Consulte a [Refer√™ncia do Rust](https://doc.rust-lang.org/reference/type-layout.html)."

#: src/enums/sizes.md:39
msgid ""
"<details>\n"
"    \n"
"Key Points: \n"
" * Internally Rust is using a field (discriminant) to keep track of the enum variant.\n"
" * `Bar` enum demonstrates that there is a way to control the discriminant value and type. If `repr` is removed, the "
"discriminant type takes 2 bytes, becuase 10001 fits 2 bytes.\n"
" * As a niche optimization an enum discriminant is merged with the pointer so that `Option<&Foo>` is the same size as "
"`&Foo`.\n"
" * `Option<bool>` is another example of tight packing.\n"
" * For [some types](https://doc.rust-lang.org/std/option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`.\n"
" * Zero-sized types allow for efficient implementation of `HashSet` using `HashMap` with `()` as the value."
msgstr ""
"<details>\n"
"    \n"
"Pontos chave:\n"
" * Internamente Rust est√° usando um campo (discriminante) para acompanhar a variante da enum.\n"
" * A Enum `Bar` demonstra que existe uma maneira de controlar o valor e o tipo discriminante. Se `repr` for removido, o "
"tipo discriminante ocupa 2 bytes, porque 10001 cabe 2 bytes.\n"
" * Como uma otimiza√ß√£o de nicho, um discriminante de Enum √© mesclado com o ponteiro para que `Option<&Foo>` seja do mesmo "
"tamanho que `&Foo`.\n"
" * `Option<bool>` √© outro exemplo de empacotamento compacto.\n"
" * Para [alguns tipos](https://doc.rust-lang.org/std/option/#representation), Rust garante que o `size_of::<T>()` √© igual a "
"`size_of::<Option<T> >()`.\n"
" * Tipos de tamanho zero permitem a implementa√ß√£o eficiente de `HashSet` usando `HashMap` com `()` como valor."

#: src/enums/sizes.md:49
msgid ""
"Example code if you want to show how the bitwise representation *may* look like in practice.\n"
"It's important to note that the compiler provides no guarantees regarding this representation, therefore this is totally "
"unsafe."
msgstr "C√≥digo de exemplo se voc√™ quiser mostrar como a representa√ß√£o bit a bit *pode* parecer na pr√°tica.\n"
" √â importante observar que o compilador n√£o oferece garantias quanto a essa representa√ß√£o, portanto, isso √© totalmente "
"inseguro."

#: src/enums/sizes.md:52
msgid ""
"```rust,editable\n"
"use std::mem::transmute;"
msgstr ""

#: src/enums/sizes.md:55 src/enums/sizes.md:94
msgid ""
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:61
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        println!(\"Bitwise representation of bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);"
msgstr ""
"fn main() {\n"
"    // TOTALMENTE INSEGURO. Rust n√£o oferece nenhuma garantia sobre a\n"
"    // representa√ß√£o bit a bit de tipos.\n"
"    unsafe {\n"
"        println!(\"Representa√ß√£o bit a bit do tipo bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);"

#: src/enums/sizes.md:69
msgid ""
"        println!(\"Bitwise representation of Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);"
msgstr ""
"        println!(\"Representa√ß√£o bit a bit do tipo Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);"

#: src/enums/sizes.md:74
msgid ""
"        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);"
msgstr ""
"        println!(\"Representa√ß√£o bit a bit do tipo Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);"

#: src/enums/sizes.md:80
msgid ""
"        println!(\"Bitwise representation of Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"        println!(\"Representa√ß√£o bit a bit do tipo Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"

#: src/enums/sizes.md:87
msgid "More complex example if you want to discuss what happens when we chain more than 256 `Option`s together."
msgstr "Exemplo mais complexo se voc√™ quiser discutir o que acontece quando encadeamos mais de 256 `Option` juntas."

#: src/enums/sizes.md:89
msgid ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]"
msgstr ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]"

#: src/enums/sizes.md:92
msgid "use std::mem::transmute;"
msgstr "use std::mem::transmute;"

#: src/enums/sizes.md:100
msgid ""
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" signs.\n"
"// Increasing the recursion limit is required to evaluate this macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}"
msgstr ""
"// Macro para envolver um valor com Some() 2^n vezes onde n √© o n√∫mero de simbolos \"@\"\n"
"// √â necess√°rio aumentar o limite de recurs√£o para utilizar essa macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}"

#: src/enums/sizes.md:112
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"
msgstr ""
"fn main() {\n"
"    // TOTALMENTE INSEGURO. Rust n√£o oferece nenhuma garantia sobre a\n"
"    // representa√ß√£o bit a bit de tipos.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"

#: src/enums/sizes.md:120
msgid ""
"        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);"
msgstr ""
"        println!(\"Representa√ß√£o bit a bit de uma cadeia de 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);"

#: src/enums/sizes.md:124
msgid ""
"        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);"
msgstr ""
"        println!(\"Representa√ß√£o bit a bit de uma cadeia de 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);"

#: src/enums/sizes.md:128
msgid ""
"        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"        println!(\"Representa√ß√£o bit a bit de uma cadeia de 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"

#: src/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with an\n"
"`impl` block:"
msgstr ""
"Rust permite que voc√™ associe fun√ß√µes aos seus novos tipos. Voc√™ faz isso com um\n"
"bloco `impl`:"

#: src/methods.md:13
msgid ""
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Pessoa {\n"
"    fn diz_ola(&self) {\n"
"        println!(\"Ol√°, meu nome √© {}\", self.nome);\n"
"    }\n"
"}"

#: src/methods.md:19
msgid ""
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let pedro = Pessoa {\n"
"        nome: String::from(\"Pedro\"),\n"
"        idade: 27,\n"
"    };\n"
"    pedro.diz_ola();\n"
"}\n"
"```"

#: src/methods.md:30
msgid ""
"Key Points:\n"
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as "
"`self`.\n"
"  * Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. "
"By using methods we can keep all the implementation code in one predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in and can be used elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used to refer to individual fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from `self` by modifying the code and trying to run "
"say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   \n"
"</details>"
msgstr ""
"Pontos chave:\n"
"* Pode ser √∫til introduzir m√©todos comparando-os com fun√ß√µes.\n"
"  * M√©todos s√£o chamados em uma inst√¢ncia de um tipo (como struct ou enum), o primeiro par√¢metro representa a inst√¢ncia "
"como `self`.\n"
"  * Os desenvolvedores podem optar por usar m√©todos para aproveitar a sintaxe do receptor do m√©todo e ajudar a mant√™-los "
"mais organizados. Usando m√©todos, podemos manter todo o c√≥digo de implementa√ß√£o em um local previs√≠vel.\n"
"* Destaque o uso da palavra-chave `self`, um receptor de m√©todo.\n"
"  * Mostre que √© um termo abreviado para `self:&Self` e talvez mostre como o nome da struct tamb√©m poderia ser usado.\n"
"  * Explique que `Self` √© um apelido de tipo para o tipo em que o bloco `impl` est√° e pode ser usado em qualquer outro lugar no "
"bloco.\n"
"  * Observe como _self_ √© usado com outras _Structs_ e a nota√ß√£o de _ponto_ pode ser usada para se referir a campos "
"individuais.\n"
"  * Este pode ser um bom momento para demonstrar como `&self` difere de `self` modificando o c√≥digo e tentando executar "
"`diz_ola` duas vezes.\n"
"* Descreveremos a distin√ß√£o entre os receptores de m√©todo a seguir.\n"
"   \n"
"</details>"

#: src/methods/receiver.md:1
msgid "# Method Receiver"
msgstr "# Receptores de m√©todos"

#: src/methods/receiver.md:3
msgid ""
"The `&self` above indicates that the method borrows the object immutably. There\n"
"are other possible receivers for a method:"
msgstr ""
"O `&self` acima indica que o m√©todo toma emprestado o objeto imutavelmente. Abaixo h√°\n"
"outros receptores poss√≠veis para um m√©todo:"

#: src/methods/receiver.md:6
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. The\n"
"  method becomes the owner of the object. The object will be dropped (deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted.\n"
"* `mut self`: same as above, but while the method owns the object, it can\n"
"  mutate it too. Complete ownership does not automatically mean mutability.\n"
"* No receiver: this becomes a static method on the struct. Typically used to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: pega emprestado o objeto do chamador como uma refer√™ncia compartilhada\n"
" e mut√°vel. O objeto pode ser usado novamente depois.\n"
"* `&mut self`: pega emprestado o objeto do chamador como uma refer√™ncia √∫nica\n"
" e mut√°vel. O objeto pode ser usado novamente depois.\n"
"* `self`: toma posse do objeto e o afasta do chamador.\n"
"  O m√©todo se torna o propriet√°rio do objeto. O objeto ser√° descartado (desalocado)\n"
"  quando o m√©todo retorna, a menos que sua ownership seja explicitamente\n"
"  transmitida.\n"
"* `mut self`: o mesmo que acima, mas enquanto o m√©todo possui o objeto, ele pode\n"
"  alter√°-lo tamb√©m. A ownership completa n√£o significa automaticamente mutabilidade.\n"
"* Sem receptor: isso se torna um m√©todo static na estrutura. Normalmente usado para\n"
"  criar construtores que, por conven√ß√£o, s√£o chamados `new`."

#: src/methods/receiver.md:19
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"Al√©m das variantes de `self`, tamb√©m existem\n"
"[tipos especiais de wrapper](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"que podem ser tipos de receptores, como `Box<Self>`."

#: src/methods/receiver.md:23
msgid ""
"<details>\n"
"  \n"
"Consider emphasizing on \"shared and immutable\" and \"unique and mutable\". These constraints always come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It won't be possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) method on it.\n"
"  \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
"Considere enfatizar \"compartilhado e imut√°vel\" e \"√∫nico e mut√°vel\". Essas restri√ß√µes sempre v√™m\n"
"juntos no Rust devido √†s regras do verificador de empr√©stimo, e `self` n√£o √© uma exce√ß√£o. N√£o ser√° poss√≠vel\n"
"referenciar um struct de v√°rios locais e chamar um m√©todo mut√°vel (`&mut self`) nele.\n"
"  \n"
"</details>"

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "# Example"
msgstr "# Exemplo"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}"
msgstr ""
"```rust, editable\n"
"#[derive(Debug)]\n"
"struct Corrida {\n"
"    nome: String,\n"
"    voltas: Vec<i32>,\n"
"}"

#: src/methods/example.md:10
msgid ""
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }"
msgstr ""
"impl Corrida {\n"
"    fn new(nome: &str) -> Corrida {  // Um m√©todo est√°tico, sem a defini√ß√£o de um receptor.\n"
"        Corrida { nome: String::from(nome), voltas: Vec::new() }\n"
"    }"

#: src/methods/example.md:15
msgid ""
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access to self\n"
"        self.laps.push(lap);\n"
"    }"
msgstr ""
"    fn adiciona_volta(&mut self, volta: i32) { // Acesso emprestado de leitura e grava√ß√£o exclusivo para self\n"
"        self.voltas.push(volta);\n"
"    }"

#: src/methods/example.md:19
msgid ""
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }"
msgstr ""
"    fn imprime_voltas(&self) { // Acesso emprestado compartilhado e somente leitura para self\n"
"        println!(\"Gravadas {} voltas para {}:\", self.voltas.len(), self.nome);\n"
"        for (idx, volta) in self.voltas.iter().enumerate() {\n"
"            println!(\"Volta {idx}: {volta} seg.\");\n"
"        }\n"
"    }"

#: src/methods/example.md:26
msgid ""
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
"    }\n"
"}"
msgstr ""
"    fn finaliza(self) { // ownership exclusiva de self\n"
"        let total = self.voltas.iter().sum::<i32>();\n"
"        println!(\"A corrida {} terminou, tempo total da volta: {}\", self.nome, total);\n"
"    }\n"
"}"

#: src/methods/example.md:32
msgid ""
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut corrida = Corrida::new(\"Grande Pr√™mio de M√¥naco\");\n"
"    corrida.adiciona_volta(70);\n"
"    corrida.adiciona_volta(68);\n"
"    corrida.imprime_voltas();\n"
"    corrida.adiciona_volta(71);\n"
"    corrida.imprime_voltas();\n"
"    corrida.finaliza();\n"
"    // corrida.adiciona_volta(42);\n"
"}\n"
"```"

#: src/methods/example.md:44
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the variable values and if/how it can be used again in "
"`main`.\n"
"  * You can showcase the error that appears when trying to call `finish` twice.\n"
"* Note, that although the method receivers are different, the non-static functions are called the same way in the main "
"body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the `&`, `*`, "
"`muts` so that that object matches the method signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated over. We describe vectors in more detail in the "
"afternoon. "
msgstr ""
"<details>\n"
"    \n"
"Pontos chave:\n"
"* Todos os quatro m√©todos aqui usam um receptor de m√©todo diferente.\n"
"  * Voc√™ pode apontar como isso muda o que a fun√ß√£o pode fazer com os valores das vari√°veis e se/como ela pode ser usada "
"novamente em `main`.\n"
"  * Voc√™ pode mostrar o erro que aparece ao tentar chamar `finish` duas vezes.\n"
"* Observe que, embora os receptores do m√©todo sejam diferentes, as fun√ß√µes n√£o est√°ticas s√£o chamadas da mesma maneira no "
"corpo principal. Rust permite referenciar e desreferenciar automaticamente ao chamar m√©todos. Rust adiciona automaticamente "
"`&`, `*`, `muts` para que esse objeto corresponda √† assinatura do m√©todo.\n"
"* Voc√™ pode apontar que `print_laps` est√° usando um vetor iterado. Descreveremos os vetores com mais\n"
"detalhes √† tarde."

#: src/pattern-matching.md:1
msgid "# Pattern Matching"
msgstr "# Correspond√™ncia de padr√µes"

#: src/pattern-matching.md:3
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"A palavra-chave `match` permite que voc√™ corresponda um valor a um ou mais _padr√µes_ (_patterns_). As\n"
" compara√ß√µes s√£o feitas de cima para baixo e a primeira correspond√™ncia encontrada √© selecionada."

#: src/pattern-matching.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Os padr√µes podem ser valores simples, similarmente a `switch` em C e C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let input = 'x';"

#: src/pattern-matching.md:12
msgid ""
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    match input {\n"
"        'q' => println!(\"Sair\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Movendo-se\"),\n"
"        '0'..='9' => println!(\"Entrada num√©rica\"),\n"
"        _ => println!(\"Algo mais\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching.md:21
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "O padr√£o `_` √© um padr√£o curinga que corresponde a qualquer valor."

#: src/pattern-matching.md:23
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* You might point out how some specific characters are being used when in a pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing "
"the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.\n"
"   \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"Pontos chave:\n"
"* Voc√™ pode apontar como alguns caracteres espec√≠ficos podem ser usados em um padr√£o\n"
"  * `|` como um `ou`\n"
"  * `..` pode expandir o quanto for necess√°rio\n"
"  * `1..=5` representa um intervalo inclusivo\n"
"  * `_` √© um curinga\n"
"* Pode ser √∫til mostrar como funciona a vincula√ß√£o, por exemplo, substituindo um caractere curinga por uma vari√°vel ou "
"removendo as aspas ao redor de `q`.\n"
"* Voc√™ pode demonstrar correspond√™ncia em uma refer√™ncia.\n"
"* Este pode ser um bom momento para trazer √† tona o conceito de padr√µes irrefut√°veis, j√° que o termo pode aparecer em "
"mensagens de erro.\n"
"   \n"
"</details>"

#: src/pattern-matching/destructuring-enums.md:1
msgid "# Destructuring Enums"
msgstr "# Desestruturando enunera√ß√µes (Enums)"

#: src/pattern-matching/destructuring-enums.md:3
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is how\n"
"you inspect the structure of your types. Let us start with a simple `enum` type:"
msgstr ""
"Os padr√µes tamb√©m podem ser usados para vincular vari√°veis a partes de seus valores. √â assim\n"
"que voc√™ inspeciona a estrutura de seus tipos. Vamos come√ßar com um tipo `enum` simples:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"
msgstr ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"

#: src/pattern-matching/destructuring-enums.md:12
msgid ""
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}"
msgstr ""
"fn divide_por_dois(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n/2)\n"
"    } else {\n"
"        Result::Err(format!(\"N√£o √© poss√≠vel dividir {} em duas partes iguais\", n))\n"
"    }\n"
"}"

#: src/pattern-matching/destructuring-enums.md:20
msgid ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_por_dois(n) {\n"
"        Result::Ok(metade) => println!(\"{n} dividido em dois √© {metade}\"),\n"
"        Result::Err(msg) => println!(\"Desculpe, ocorreu um erro: {msg}\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-enums.md:29
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second arm,\n"
"`msg` is bound to the error message."
msgstr ""
"Aqui usamos a verifica√ß√£o de correspond√™ncia para _desestruturar_ o valor contido em `Result`. Na primeira\n"
"verifica√ß√£o de correspond√™ncia, `metade` est√° vinculado ao valor dentro da variante `Ok`. Na segunda,\n"
"`msg` est√° vinculado √† mensagem de erro."

#: src/pattern-matching/destructuring-enums.md:35
msgid ""
"Key points:\n"
"* The `if`/`else` expression is returning an enum that is later unpacked with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the "
"places where your code is now inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Pontos chave:\n"
"* A express√£o `if`/`else` est√° retornando um enum que √© posteriormente descompactado com um `match`.\n"
"* Voc√™ pode tentar adicionar uma terceira variante √† defini√ß√£o de Enum e exibir os erros ao executar o c√≥digo. Aponte os "
"lugares onde seu c√≥digo agora √© \"n√£o exaustivo\" e como o compilador tenta lhe dar dicas."

#: src/pattern-matching/destructuring-structs.md:1
msgid "# Destructuring Structs"
msgstr "# Desestruturando estruturas (Structs)"

#: src/pattern-matching/destructuring-structs.md:3
msgid "You can also destructure `structs`:"
msgstr "Voc√™ tamb√©m pode desestruturar `structs`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"
msgstr ""
"```rust, editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"

#: src/pattern-matching/destructuring-structs.md:11
msgid ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"<details>"
msgstr ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i } => println!(\"y = 2, i = {i:?}\"),\n"
"        Foo { y, .. } => println!(\"y = {y}, outros campos foram ignorados\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-structs.md:23
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"</details>"
msgstr ""
"* Altere os valores literais em `foo` para corresponderem com outros padr√µes.\n"
"* Adicione um novo campo em `Foo` e fa√ßa as altera√ß√µes no padr√£o"
" conforme necess√°rio.\n"
"</details>"

#: src/pattern-matching/destructuring-arrays.md:1
msgid "# Destructuring Arrays"
msgstr "# Desestruturando Vetores"

#: src/pattern-matching/destructuring-arrays.md:3
msgid "You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "Voc√™ pode desestruturar vetores, tuplas e slices combinando seus elementos:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triplo = [0, -2, 3];\n"
"    println!(\"Fale-me sobre {triplo:?}\");\n"
"    match triplo {\n"
"        [0, y, z] => println!(\"Primeiro √© 0, y = {y} e z = {z}\"),\n"
"        [1, ..] => println!(\"Primeiro √© 1 e o resto foi ignorado\"),\n"
"        _ => println!(\"Todos os elementos foram ignorados\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-arrays.md:20
msgid "* Destructuring of slices of unknown length also works with patterns of fixed length."
msgstr "* Desestruturar slices de tamanho desconhecido tamb√©m funciona com padr√µes de tamanho fixo."

#: src/pattern-matching/destructuring-arrays.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:28
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`\n"
"</details>"
msgstr ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Fale-me sobre {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"O primeiro √© 0, y = {y}, e z = {z}\"),\n"
"        &[1, ..]   => println!(\"O primeiro √© 1 e o restante √© ignorado\"),\n"
"        _          => println!(\"Todos os elementos foram ignorados\"),\n"
"    }\n"
"}\n"
"```\n"
"* Mostre as correspond√™ncias com o final do padr√£o usando `[.., b]` e `[a@..,b]`\n"
"</details>"

#: src/pattern-matching/match-guards.md:1
msgid "# Match Guards"
msgstr "# Guardas de correspond√™ncia (match guards)"

#: src/pattern-matching/match-guards.md:3
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"Ao verificar uma correspond√™ncia, voc√™ pode adicionar um _guarda_ para um padr√£o. √â uma express√£o booleana\n"
"que ser√° executada se o padr√£o corresponder:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Fale-me sobre {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y => println!(\"Estes s√£o g√™meos\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"O primeiro √© √≠mpar\"),\n"
"        _ => println!(\"Sem correla√ß√£o...\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/match-guards.md:22
msgid ""
"Key Points:\n"
"* Match guards as a separate syntax feature are important and necessary when we wish to concisely express more complex "
"ideas than patterns alone would allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. An `if` expression inside of the branch block "
"(after `=>`) happens after the match arm is selected. Failing the `if` condition inside of that block won't result in other "
"arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a pattern with an `|`.\n"
"</details>"
msgstr ""
"Pontos chave:\n"
"* Guardas de correspond√™ncia, como um recurso de sintaxe separado, s√£o importantes e necess√°rios.\n"
"Permitem expressar ideias mais complexas do que somente o padr√£o permitiria.\n"
"* Eles n√£o s√£o iguais √† express√£o `if` separada dentro do bloco de correspond√™ncia. Uma express√£o `if` dentro do bloco de "
"ramifica√ß√£o (depois de `=>`) acontece depois que a correspond√™ncia √© selecionada. A falha na condi√ß√£o `if` dentro "
"desse bloco n√£o resultar√° em outras verifica√ß√µes de correspond√™ncia\n"
"da express√£o `match` original serem consideradas.\n"
"* Voc√™ pode usar as vari√°veis definidas no padr√£o em sua express√£o `if`.\n"
"* A condi√ß√£o definida na guarda se aplica a todas as express√µes em um padr√£o com um `|`.\n"
"</details>"

#: src/exercises/day-2/morning.md:1
msgid "# Day 2: Morning Exercises"
msgstr "# Dia 2: Exerc√≠cios matinais"

#: src/exercises/day-2/morning.md:3
msgid "We will look at implementing methods in two contexts:"
msgstr "Veremos a implementa√ß√£o de m√©todos em dois contextos:"

#: src/exercises/day-2/morning.md:5
msgid "* Simple struct which tracks health statistics."
msgstr "* Estrutura simples que rastreia as estat√≠sticas de sa√∫de."

#: src/exercises/day-2/morning.md:7
msgid "* Multiple structs and enums for a drawing library."
msgstr "* V√°rias estruturas e enumera√ß√µes para uma biblioteca de desenho."

#: src/exercises/day-2/health-statistics.md:1
msgid "# Health Statistics"
msgstr "# Estat√≠sticas de sa√∫de"

#: src/exercises/day-2/health-statistics.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, you\n"
"need to keep track of users' health statistics."
msgstr ""
"Voc√™ est√° trabalhando na implementa√ß√£o de um sistema de monitoramento de sa√∫de. Como parte disso, voc√™\n"
"precisa acompanhar as estat√≠sticas de sa√∫de dos usu√°rios."

#: src/exercises/day-2/health-statistics.md:6
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a `User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"Voc√™ come√ßar√° com algumas fun√ß√µes fragmentadas em um bloco `impl` e tamb√©m com a defini√ß√£o da estrutura `User`.\n"
"Seu objetivo √© implementar os m√©todos esbo√ßados para a\n"
"`struct` `User` definidos no bloco `impl`."

#: src/exercises/day-2/health-statistics.md:10
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"methods:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/> e implemente os m√©todos:"

#: src/exercises/day-2/health-statistics.md:17
msgid ""
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}"
msgstr ""
"struct Usuario {\n"
"    nome: String,\n"
"    idade: u32,\n"
"    peso: f32,\n"
"}"

#: src/exercises/day-2/health-statistics.md:23
msgid ""
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Usuario {\n"
"    pub fn new(nome: String, idade: u32, peso: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:28
msgid ""
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn nome(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:32
msgid ""
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn idade(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:36
msgid ""
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn peso(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:40
msgid ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"    pub fn setar_idade(&mut self, nova_idade: u32) {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-2/health-statistics.md:44
msgid ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"    pub fn setar_peso(&mut self, novo_peso: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-2/health-statistics.md:49
msgid ""
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}"
msgstr ""
"fn main() {\n"
"    let bob = Usuario::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"Sou {} e minha idade √© {}\", bob.nome(), bob.idade());\n"
"}"

#: src/exercises/day-2/health-statistics.md:54
msgid ""
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}"
msgstr ""
"#[test]\n"
"fn test_peso() {\n"
"    let bob = Usuario::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.peso(), 155.2);\n"
"}"

#: src/exercises/day-2/health-statistics.md:60
msgid ""
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""
"#[test]\n"
"fn test_setar_idade() {\n"
"    let mut bob = Usuario::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.idade(), 32);\n"
"    bob.setar_idade(33);\n"
"    assert_eq!(bob.idade(), 33);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:1
msgid "# Polygon Struct"
msgstr "# Estrutura para pol√≠gono"

#: src/exercises/day-2/points-polygons.md:3
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make the\n"
"tests pass:"
msgstr ""
"Vamos criar uma estrutura `Poligono` que cont√©m alguns `Pontos`. Copie o c√≥digo abaixo\n"
"para <https://play.rust-lang.org/> e preencha os m√©todos que faltam para fazer os\n"
"testes passarem:"

#: src/exercises/day-2/points-polygons.md:7 src/exercises/day-2/luhn.md:23 src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""
"```rust\n"
"// TODO: remova isso quando terminar sua implementa√ß√£o.\n"
"#![allow(unused_variables, dead_code)]"

#: src/exercises/day-2/points-polygons.md:11
msgid ""
"pub struct Point {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Ponto {\n"
"    // adicione os campos\n"
"}"

#: src/exercises/day-2/points-polygons.md:15
msgid ""
"impl Point {\n"
"    // add methods\n"
"}"
msgstr ""
"impl Ponto {\n"
"    // adicione os m√©todos\n"
"}"

#: src/exercises/day-2/points-polygons.md:19
msgid ""
"pub struct Polygon {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Poligono {\n"
"    // adicione os campos\n"
"}"

#: src/exercises/day-2/points-polygons.md:23
msgid ""
"impl Polygon {\n"
"    // add methods\n"
"}"
msgstr ""
"impl Poligono {\n"
"    // adicione os m√©todos\n"
"}"

#: src/exercises/day-2/points-polygons.md:27
msgid ""
"pub struct Circle {\n"
"    // add fields\n"
"}"
msgstr ""
"pub struct Circulo {\n"
"    // adicione os campos\n"
"}"

#: src/exercises/day-2/points-polygons.md:31
msgid ""
"impl Circle {\n"
"    // add methods\n"
"}"
msgstr ""
"impl Circulo {\n"
"    // adicione os m√©todos\n"
"}"

#: src/exercises/day-2/points-polygons.md:35
msgid ""
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}"
msgstr ""
"pub enum Forma {\n"
"    Poligono(Poligono),\n"
"    Circulo(Circulo),\n"
"}"

#: src/exercises/day-2/points-polygons.md:40 src/testing/test-modules.md:15
msgid ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"

#: src/exercises/day-2/points-polygons.md:44 src/exercises/day-2/solutions-morning.md:165
msgid ""
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"
msgstr ""
"    fn arredonda_dois_digitos(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"

#: src/exercises/day-2/points-polygons.md:48 src/exercises/day-2/solutions-morning.md:169
msgid ""
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }"
msgstr ""
"    #[test]\n"
"    fn test_magnitude_ponto() {\n"
"        let p1 = Ponto::new(12, 13);\n"
"        assert_eq!(arredonda_dois_digitos(p1.magnitude()), 17.69);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:54 src/exercises/day-2/solutions-morning.md:175
msgid ""
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }"
msgstr ""
"    #[test]\n"
"    fn test_distancia_pontos() {\n"
"        let p1 = Ponto::new(10, 10);\n"
"        let p2 = Ponto::new(14, 13);\n"
"        assert_eq!(arredonda_dois_digitos(p1.dist(p2)), 5.00);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:61 src/exercises/day-2/solutions-morning.md:182
msgid ""
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }"
msgstr ""
"    #[test]\n"
"    fn test_somar_pontos() {\n"
"        let p1 = Ponto::new(16, 16);\n"
"        let p2 = p1 + Ponto::new(-4, 3);\n"
"        assert_eq!(p2, Ponto::new(12, 19));\n"
"    }"

#: src/exercises/day-2/points-polygons.md:68 src/exercises/day-2/solutions-morning.md:189
msgid ""
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""
"    #[test]\n"
"    fn test_poligono_ponto_mais_a_esquerda() {\n"
"        let p1 = Ponto::new(12, 13);\n"
"        let p2 = Ponto::new(16, 16);"

#: src/exercises/day-2/points-polygons.md:73 src/exercises/day-2/solutions-morning.md:194
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }"
msgstr ""
"        let mut poly = Poligono::new();\n"
"        poly.adiciona_ponto(p1);\n"
"        poly.adiciona_ponto(p2);\n"
"        assert_eq!(poly.ponto_mais_a_esquerda(), Some(p1));\n"
"    }"

#: src/exercises/day-2/points-polygons.md:79 src/exercises/day-2/solutions-morning.md:200
msgid ""
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""
"    #[test]\n"
"    fn test_poligono_iter() {\n"
"        let p1 = Ponto::new(12, 13);\n"
"        let p2 = Ponto::new(16, 16);"

#: src/exercises/day-2/points-polygons.md:84 src/exercises/day-2/solutions-morning.md:205
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);"
msgstr ""
"        let mut poly = Poligono::new();\n"
"        poly.adiciona_ponto(p1);\n"
"        poly.adiciona_ponto(p2);"

#: src/exercises/day-2/points-polygons.md:88 src/exercises/day-2/solutions-morning.md:209
msgid ""
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }"
msgstr ""
"        let pontos = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(pontos, vec![Ponto::new(12, 13), Ponto::new(16, 16)]);\n"
"    }"

#: src/exercises/day-2/points-polygons.md:92
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}"
msgstr ""
"    #[test]\n"
"    fn test_perimetros_da_forma() {\n"
"        let mut poly = Poligono::new();\n"
"        poly.adiciona_ponto(Ponto::new(12, 13));\n"
"        poly.adiciona_ponto(Ponto::new(17, 11));\n"
"        poly.adiciona_ponto(Ponto::new(16, 16));\n"
"        let formas = vec![\n"
"            Forma::from(poly),\n"
"            Forma::from(Circulo::new(Ponto::new(10, 20), 5)),\n"
"        ];\n"
"        let perimetros = formas\n"
"            .iter()\n"
"            .map(Forma::perimetro)\n"
"            .map(arredonda_dois_digitos)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimetros, vec![15.48, 31.42]);\n"
"    }\n"
"}"

#: src/exercises/day-2/points-polygons.md:111 src/exercises/day-2/luhn.md:68
msgid ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-2/points-polygons.md:117
msgid ""
"Since the method signatures are missing from the problem statements, the key part\n"
"of the exercise is to specify those correctly. Do not modify any of the tests."
msgstr ""
"Como as assinaturas dos m√©todos est√£o faltando nas declara√ß√µes do problema, a parte principal\n"
"do exerc√≠cio √© especific√°-las corretamente."

#: src/exercises/day-2/points-polygons.md:120
msgid ""
"Other interesting parts of the exercise:\n"
"    \n"
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes don't borrow their arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be addable via \"+\". Note that we do not discuss "
"generics until Day 3."
msgstr ""
"Outras partes interessantes do exerc√≠cio:\n"
"    \n"
"* Derive um _trait_ `Copy` para algumas estruturas, j√° que em testes os m√©todos √†s vezes n√£o emprestam seus argumentos.\n"
"* Descubra que o trait `Add` deve ser implementado para que dois objetos sejam adicionados via \"+\"."

#: src/control-flow.md:1
msgid "# Control Flow"
msgstr "# Controle de fluxo"

#: src/control-flow.md:3
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then becomes\n"
"the value of the `if` expression. Other control flow expressions work similarly\n"
"in Rust."
msgstr ""
"Como vimos, `if` √© uma express√£o em Rust. √â usado para condicionalmente\n"
"avaliar um dos dois blocos, mas os blocos podem ter um valor que ent√£o se torna\n"
"o valor da express√£o `if`. Outras express√µes de fluxo de controle funcionam de forma semelhante\n"
"em Rust."

#: src/control-flow/blocks.md:1
msgid "# Blocks"
msgstr "# Blocos"

#: src/control-flow/blocks.md:3
msgid ""
"A block in Rust has a value and a type: the value is the last expression of the\n"
"block:"
msgstr ""
"Um bloco em Rust tem um valor e um tipo: o valor √© a √∫ltima express√£o do\n"
"bloco:"

#: src/control-flow/blocks.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/control-flow/blocks.md:25
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"A mesma regra √© usada para fun√ß√µes: o valor do corpo da fun√ß√£o √© o\n"
"valor de retorno:"

#: src/control-flow/blocks.md:28
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}"
msgstr ""
"```rust,editable\n"
"fn dobro(x: i32) -> i32 {\n"
"    x + x\n"
"}"

#: src/control-flow/blocks.md:33
msgid ""
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    println!(\"dobro: {}\", dobro(7));\n"
"}\n"
"```"

#: src/control-flow/blocks.md:38
msgid "However if the last expression ends with `;`, then the resulting value and type is `()`."
msgstr "No entanto, se a √∫ltima express√£o terminar com `;` o valor e o tipo do retorno ser√° `()`."

#: src/control-flow/blocks.md:42
msgid ""
"Key Points:\n"
"* The point of this slide is to show that blocks have a type and value in Rust. \n"
"* You can show how the value of the block changes by changing the last line in the block. For instance, adding/removing a "
"semicolon or using a `return`.\n"
"   \n"
"</details>"
msgstr ""
"Pontos chave:\n"
"* O objetivo deste slide √© mostrar que os blocos t√™m um tipo e um valor em Rust.\n"
"* Voc√™ pode mostrar como o valor do bloco muda alterando a √∫ltima linha do bloco. Por exemplo, adicionar/remover um ponto e "
"v√≠rgula (`;`) ou usar um `return`.\n"
"   \n"
"</details>"

#: src/control-flow/if-expressions.md:1
msgid "# `if` expressions"
msgstr "# Express√µes Se (`if`)"

#: src/control-flow/if-expressions.md:3
msgid "You use `if` very similarly to how you would in other languages:"
msgstr "Voc√™ usa `if` de forma muito semelhante a como faria em outras linguagens:"

#: src/control-flow/if-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x/2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:16
msgid "In addition, you can use it as an expression. This does the same as above:"
msgstr "Al√©m disso, voc√™ pode us√°-lo como uma express√£o. Isso faz o mesmo que acima:"

#: src/control-flow/if-expressions.md:18
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:31
msgid ""
"Because `if` is an expression and must have a particular type, both of its branch blocks must have the same type. Consider "
"showing what happens if you add `;` after `x / 2` in the second example.\n"
"    \n"
"</details>"
msgstr ""
"Como `if` √© uma express√£o e deve ter um tipo espec√≠fico, ambos os blocos de ramifica√ß√£o devem ter o mesmo tipo. Considere "
"mostrar o que acontece se voc√™ adicionar um `;` depois de `x / 2` no segundo exemplo.\n"
"    \n"
"</details>"

#: src/control-flow/if-let-expressions.md:1
msgid "# `if let` expressions"
msgstr "# Express√µes Se (`if let`)"

#: src/control-flow/if-let-expressions.md:3
msgid "If you want to match a value against a pattern, you can use `if let`:"
msgstr "Se voc√™ deseja corresponder um valor a um padr√£o, pode usar `if let`:"

#: src/control-flow/if-let-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"nome do programa: {value}\");\n"
"    } else {\n"
"        println!(\"Falta o nome?\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-let-expressions.md:16 src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:22
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns in\n"
"Rust."
msgstr ""
"Consulte [correspond√™ncia de padr√µes](../pattern-matching.md) para obter mais detalhes sobre padr√µes em\n"
"Rust."

#: src/control-flow/if-let-expressions.md:21
msgid ""
"* `if let` can be more concise than `match`, e.g., when only one case is interesting. In contrast, `match` requires all "
"branches to be covered.\n"
"    * For the similar use case consider demonstrating a newly stabilized [`let else`](https://github.com/rust-lang/rust/"
"pull/93628) feature.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"* `if let` pode ser mais conciso que `match`, por exemplo, quando apenas um caso √© interessante. Em contraste, `match` "
"requer que todas as ramifica√ß√µes sejam cobertas.\n"
"    * Para o caso de uso semelhante, considere demonstrar um recurso [`let else`](https://github.com/rust-lang/rust/"
"pull/93628) recentemente estabilizado.\n"
"* Um uso comum √© lidar com valores `Some` ao trabalhar com `Option`.\n"
"* Ao contr√°rio de `match`, `if let` n√£o suporta cl√°usulas de guarda para correspond√™ncia de padr√µes."

#: src/control-flow/while-expressions.md:1
msgid "# `while` expressions"
msgstr "# Express√µes enquanto (`while`)"

#: src/control-flow/while-expressions.md:3
msgid "The `while` keyword works very similar to other languages:"
msgstr "A palavra-chave `while` funciona de maneira muito semelhante a outras linguagens:"

#: src/control-flow/while-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"X final: {x}\");\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:1
msgid "# `while let` expressions"
msgstr "# Express√µes enquanto (`while let`)"

#: src/control-flow/while-let-expressions.md:3
msgid ""
"Like with `if`, there is a `while let` variant which repeatedly tests a value\n"
"against a pattern:"
msgstr ""
"Como com `if`, h√° uma variante `while let` que testa repetidamente se um valor\n"
"corresponde a um padr√£o:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"

#: src/control-flow/while-let-expressions.md:11
msgid ""
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:17
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"Aqui o iterador retornado por `v.iter()` retornar√° uma `Option<i32>` em cada\n"
"chamada para `next()`. Ele retorna `Some(x)` at√© que seja conclu√≠do e, em seguida, retorna \n"
"`None`. O `while let` nos permite continuar iterando por todos os itens, enquando houver."

#: src/control-flow/while-let-expressions.md:27
msgid ""
"* Point out that the `while let` loop will keep going as long as the value matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if statement that breaks when there is no value to "
"unwrap for `iter.next()`. The `while let` provides syntactic sugar for the above scenario.\n"
"    \n"
"</details>"
msgstr ""
"* Saliente que o la√ßo `while let` continuar√° enquanto o valor corresponder ao padr√£o.\n"
"* Voc√™ pode reescrever o la√ßo `while let` como um la√ßo infinito com uma instru√ß√£o if que quebra quando n√£o h√° valor para "
"desempacotar para `iter.next()`. O `while let` fornece a√ß√∫car sint√°tico para o cen√°rio acima.\n"
"    \n"
"</details>"

#: src/control-flow/for-expressions.md:1
msgid "# `for` expressions"
msgstr "# Express√µes Para (`for`)"

#: src/control-flow/for-expressions.md:3
msgid ""
"The `for` expression is closely related to the `while let` expression. It will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"A express√£o `for` est√° intimamente relacionada com a express√£o `while let`. √â\n"
"chamado automaticamente `into_iter()` na express√£o e, em seguida, iterado sobre ela:"

#: src/control-flow/for-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];"

#: src/control-flow/for-expressions.md:10
msgid ""
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/for-expressions.md:20
msgid "You can use `break` and `continue` here as usual."
msgstr "Voc√™ pode usar `break` e `continue` aqui como de costume."

#: src/control-flow/for-expressions.md:22
msgid ""
"<details>\n"
"    \n"
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change vector `v` to be mutable and the for loop to "
"`for x in v.iter_mut()`."
msgstr ""
"<details>\n"
"    \n"
"* A itera√ß√£o de √≠ndice n√£o √© uma sintaxe especial no Rust apenas para esse caso.\n"
"* `(0..10)` √© um intervalo que implementa uma caracter√≠stica `Iterator`.\n"
"* `step_by` √© um m√©todo que retorna outro `Iterator` que pula todos os outros elementos.\n"
"    \n"
"</details>"

#: src/control-flow/loop-expressions.md:1
msgid "# `loop` expressions"
msgstr "# Express√µes de la√ßo (`loop`)"

#: src/control-flow/loop-expressions.md:3
msgid ""
"Finally, there is a `loop` keyword which creates an endless loop. Here you must\n"
"either `break` or `return` to stop the loop:"
msgstr ""
"Finalmente, h√° uma palavra-chave `loop` que cria um la√ßo infinito. Aqui voc√™ deve\n"
"usar `break` ou `return` para parar o la√ßo:"

#: src/control-flow/loop-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:23
msgid ""
"<details>\n"
"    \n"
"* Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr ""
"<details>\n"
"    \n"
"* Break o `loop` com um valor (ex. `break 8`) e mostre-o."

#: src/control-flow/match-expressions.md:1
msgid "# `match` expressions"
msgstr "# Express√µes de correspond√™ncia (`match`)"

#: src/control-flow/match-expressions.md:3
msgid ""
"The `match` keyword is used to match a value against one or more patterns. In\n"
"that sense, it works like a series of `if let` expressions:"
msgstr ""
"A palavra-chave `match` √© usada para corresponder um valor a um ou mais padr√µes. Nesse\n"
"sentido, funciona como uma s√©rie de express√µes `if let`:"

#: src/control-flow/match-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"gato\") => println!(\"Vai fazer coisas de gato\"),\n"
"        Some(\"ls\") => println!(\"Ser√£o alguns arquivos\"),\n"
"        Some(\"mv\") => println!(\"Vamos mover alguns arquivos\"),\n"
"        Some(\"rm\") => println!(\"Uh, perigoso!\"),\n"
"        None => println!(\"Hmm, nenhum nome de programa?\"),\n"
"        _ => println!(\"Nome de programa desconhecido!\"),\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:19
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Como `if let`, cada bra√ßo de correspond√™ncia deve ter o mesmo tipo. O tipo √© a √∫ltima\n"
"express√£o do bloco, se houver. No exemplo acima, o tipo √© `()`."

#: src/control-flow/match-expressions.md:25
msgid ""
"<details>\n"
"    \n"
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::Agrs().next` returns an `Option<&String>`, but we cannot match against `String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<T::Target>`. In our case, this turns `Option<&String>` into "
"`Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside `Option`.\n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"* Salve o resultado de uma express√£o de correspond√™ncia `match` em uma vari√°vel e imprima-a.\n"
"* Remova `.as_deref()` e explique o erro gerado.\n"
"    * `std::env::Agrs().next()` returns an `Option<&String>`, por√©m `match` n√£o funciona com o tipo `String`.\n"
"    * `as_deref()` transforma um tipo `Option<T>` em `Option<T::Target>`. Nesse caso, transforma um `Option<&String>` em "
"`Option<&str>`.\n"
"    * Agora podemos usar a correspond√™ncia de padr√µes em um `&str` dentro de um `Option`.\n"
"</details>"

#: src/control-flow/break-continue.md:1
msgid "# `break` and `continue`"
msgstr "# Interromper (`break`) e Continuar (`continue`)"

#: src/control-flow/break-continue.md:3
msgid ""
"If you want to exit a loop early, use `break`, if you want to immediately start\n"
"the next iteration use `continue`. Both `continue` and `break` can optionally\n"
"take a label argument which is used to break out of nested loops:"
msgstr ""
"Se voc√™ quiser sair de um la√ßos mais cedo, use `break`, se quiser iniciar imediatamente\n"
"a pr√≥xima itera√ß√£o use `continue`. Ambos `continue` e `break` podem opcionalmente\n"
"receber um r√≥tulo como argumento que √© usado para sair de la√ßos aninhados:"

#: src/control-flow/break-continue.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'laco_externo: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'laco_externo;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/break-continue.md:25
msgid "In this case we break the outer loop after 3 iterations of the inner loop."
msgstr "Neste caso, quebramos o la√ßo externo ap√≥s 3 itera√ß√µes do la√ßo interno."

#: src/std.md:1
msgid "# Standard Library"
msgstr "# Biblioteca padr√£o"

#: src/std.md:3
msgid ""
"Rust comes with a standard library which helps establish a set of common types\n"
"used by Rust library and programs. This way, two libraries can work together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust vem com uma biblioteca padr√£o que ajuda a estabelecer um conjunto de tipos comuns\n"
"usados pela biblioteca e programas Rust. Dessa forma, duas bibliotecas podem trabalhar juntas\n"
"sem problemas porque ambos usam o mesmo tipo `String`."

#: src/std.md:7
msgid "The common vocabulary types include:"
msgstr "As palavras reservadas de tipo comuns incluem:"

#: src/std.md:9
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional values\n"
"  and [error handling](error-handling.md)."
msgstr ""
"* Tipos [`Option` e `Result`](std/option-result.md): usados para valores opcionais\n"
"  e [manipula√ß√£o de erros](error-handling.md)."

#: src/std.md:12
msgid "* [`String`](std/string.md): the default string type used for owned data."
msgstr "* [`String`](std/string.md): o tipo de cadeia de caracteres padr√£o extens√≠vel usado para dados."

#: src/std.md:14
msgid "* [`Vec`](std/vec.md): a standard extensible vector."
msgstr "* [`Vec`](std/vec.md): um vetor extens√≠vel padr√£o."

#: src/std.md:16
msgid ""
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm."
msgstr ""
"* [`HashMap`](std/hashmap.md): um tipo de mapa hash com o algoritmo de hashing configur√°vel."

#: src/std.md:19
msgid "* [`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr "* [`Box`](std/box.md): um ponteiro pr√≥prio para dados alocados em heap."

#: src/std.md:21
msgid "* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated data."
msgstr "* [`Rc`](std/rc.md): um ponteiro de contagem de refer√™ncia compartilhado para dados alocados em heap."

#: src/std.md:23
msgid ""
"<details>\n"
"  \n"
"  * In fact, Rust contains several layers of the Standard Library: `core`, `alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on `libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as `Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"<details>\n"
"  \n"
"  * Na verdade, Rust cont√©m v√°rias camadas da Biblioteca Padr√£o: `core`, `alloc` e `std`.\n"
"  * `core` inclui os tipos e fun√ß√µes mais b√°sicos que n√£o dependem de `libc`, alocador ou\n"
"    at√© mesmo a presen√ßa de um sistema operacional.\n"
"  * `alloc` inclui tipos que requerem um alocador de heap global, como `Vec`, `Box` e `Arc`.\n"
"  * Os aplicativos Rust embarcados geralmente usam apenas `core` e, √†s vezes, `alloc`."

#: src/std/option-result.md:1
msgid "# `Option` and `Result`"
msgstr "# `Option` e `Result`"

#: src/std/option-result.md:3
msgid "The types represent optional data:"
msgstr "Os tipos representam dados opcionais:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let numeros = vec![10, 20, 30];\n"
"    let primeiro: Option<&i8> = numeros.first();\n"
"    println!(\"Primeiro: {primeiro:?}\");"

#: src/std/option-result.md:11
msgid ""
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""
"    let idx: Result<usize, usize> = numeros.binary_search(&10);\n"
"    println!(\"Indice: {idx:?}\");\n"
"}\n"
"```"

#: src/std/option-result.md:18
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should be inserted."
msgstr ""
"* `Option` e `Result` s√£o amplamente usados n√£o apenas na biblioteca padr√£o.\n"
"* `Option<&T>` tem sobrecarga de espa√ßo zero em compara√ß√£o com `&T`.\n"
"* `Result` √© o tipo padr√£o para implementar o tratamento de erros, como veremos no Dia 3.\n"
"* `binary_search` retorna `Result<usize, usize>`.\n"
"  * Se encontrado, `Result::Ok` cont√©m o √≠ndice onde o elemento foi encontrado.\n"
"  * Caso contr√°rio, `Result::Err` cont√©m o √≠ndice onde tal elemento deve ser inserido."

#: src/std/string.md:1
msgid "# String"
msgstr "# String"

#: src/std/string.md:3
msgid "[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr "[`String`][1] √© o buffer padr√£o de cadeia de caracteres UTF-8 expans√≠vel e alocado no heap:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Ol√°\");\n"
"    println!(\"s1: tamanho = {}, capacidade = {}\", s1.len(), s1.capacity());"

#: src/std/string.md:11
msgid ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());"
msgstr ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: tamanho = {}, capacidade = {}\", s2.len(), s2.capacity());"

#: src/std/string.md:16
msgid ""
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: tamanho = {}, n√∫mero de caracteres = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"

#: src/std/string.md:22
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can call all\n"
"`str` methods on a `String`."
msgstr ""
"`String` implementa [`Deref<Target = str>`][2], o que significa que voc√™ pode chamar todos\n"
"os m√©todos contidos em `str` em uma `String`."

#: src/std/string.md:25
msgid ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"
msgstr ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"

#: src/std/string.md:30
msgid ""
"* `len` returns the size of the `String` in bytes, not its length in characters.\n"
"* `chars` returns an iterator over the actual characters.\n"
"* `String` implements `Deref<Target = str>` which transparently gives it access to `str`'s methods."
msgstr ""
"* `len` retorna o tamanho da `String` em bytes, n√£o seu comprimento em caracteres.\n"
"* `chars` retorna um iterador sobre os caracteres reais.\n"
"* `String` implementa `Deref<Target = str>` que d√° acesso transparente aos m√©todos de `str`."

#: src/std/vec.md:1
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[`Vec`][1] √© o buffer padr√£o redimension√°vel alocado no heap:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: tamanho = {}, capacidade = {}\", v1.len(), v1.capacity());"

#: src/std/vec.md:11
msgid ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());"
msgstr ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: tamanho = {}, capacidade = {}\", v2.len(), v2.capacity());\n"
"}\n"
"```"

#: src/std/vec.md:16
msgid ""
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];"
msgstr ""
"    // Macro can√¥nica para inicializar um vetor com elementos.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];"

#: src/std/vec.md:19
msgid ""
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");"
msgstr ""
"    // Ret√©m somente os elementos pares.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");"

#: src/std/vec.md:23
msgid ""
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""
"    // Remove valores duplicados consecutivos.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"

#: src/std/vec.md:29
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call slice\n"
"methods on a `Vec`."
msgstr ""
"`Vec` implementa [`Deref<Target = [T]>`][2], o que significa que voc√™ pode chamar m√©todos de slice\n"
"em um `Vec`."

#: src/std/vec.md:32
msgid ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"
msgstr ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"

#: src/std/vec.md:37
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data it contains is stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at compile time. It can grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` explicitly. As always\n"
"  with Rust type inference, the `T` was established during the first `push` call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""
"<details>\n"
"    \n"
"* `Vec` √© um tipo de cole√ß√£o, como `String` e `HashMap`. Os dados que ele cont√©m s√£o armazenados\n"
"  no heap. Isso significa que a quantidade de dados n√£o precisa ser conhecida em tempo de compila√ß√£o. Pode crescer\n"
"  ou encolher em tempo de execu√ß√£o.\n"
"* Observe como `Vec<T>` tamb√©m √© um tipo gen√©rico, mas voc√™ n√£o precisa especificar `T` explicitamente. Como sempre,\n"
"  com a infer√™ncia de tipo Rust, o `T` foi estabelecido durante a primeira chamada `push`.\n"
"* `vec![...]` √© uma macro can√¥nica para usar em vez de `Vec::new()` e suporta adicionar elementos\n"
"  iniciais ao vetor.\n"
"* Para indexar o vetor, voc√™ usa `[` `]`, mas uma excess√£o do tipo _p√¢nico_ (`panic`) ser√° gerada se o √≠ndice estiver\n"
"fora dos limites. Alternativamente, usando\n"
"  `get` voc√™ obter√° uma `Option`. A fun√ß√£o `pop` remover√° o √∫ltimo elemento.\n"
"* Mostrar iterando sobre um vetor e alterando o valor:\n"
"  `for e in &mut v { *e += 50; }`"

#: src/std/hashmap.md:1
msgid "# `HashMap`"
msgstr "# `HashMap`"

#: src/std/hashmap.md:3
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Mapa de _hash_ padr√£o com prote√ß√£o contra ataques HashDoS:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;"
msgstr ""
"```rust,editable\n"
"use std::collections::HashMap;"

#: src/std/hashmap.md:8
msgid ""
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);"
msgstr ""
"fn main() {\n"
"    let mut meus_livros = HashMap::new();\n"
"    meus_livros.insert(\"Aventuras de Huckleberry Finn\".to_string(), 207);\n"
"    meus_livros.insert(\"Contos de Fadas dos Grimms\".to_string(), 751);\n"
"    meus_livros.insert(\"Orgulho e Preconceito\".to_string(), 303);"

#: src/std/hashmap.md:14
msgid ""
"    if !page_counts.contains_key(\"Les Mis√©rables\") {\n"
"        println!(\"We know about {} books, but not Les Mis√©rables.\",\n"
"                 page_counts.len());\n"
"    }"
msgstr ""
"    if !meus_livros.contains_key(\"Os Miser√°veis\") {\n"
"        println!(\"Tenho {} livros, mas n√£o Os Miser√°veis.\",\n"
"                 meus_livros.len());\n"
"    }"

#: src/std/hashmap.md:19
msgid ""
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }"
msgstr ""
"    for livro in [\"Orgulho e Preconceito\", \"Alice no Pa√≠s das Maravilhas\"] {\n"
"        match meus_livros.get(livro) {\n"
"            Some(paginas) => println!(\"{livro}: {paginas} p√°ginas\"),\n"
"            None => println!(\"{livro} √© desconhecido.\")\n"
"        }\n"
"    }"

#: src/std/hashmap.md:26
msgid ""
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string()).or_insert(0);\n"
"        *page_count += 1;\n"
"    }"
msgstr ""
"    // Use o m√©todo .entry() para inserir um valor, caso este n√£o seja encontrado.\n"
"    for livro in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let meu_livro: &mut i32 = meus_livros.entry(livro.to_string()).or_insert(0);\n"
"        *meu_livro += 1;\n"
"    }"

#: src/std/hashmap.md:32
msgid ""
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"{meus_livros:#?}\");\n"
"}\n"
"```"

#: src/std/hashmap.md:38
msgid "* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr "* Diferente de `vec!`, infelizmente n√£o h√° uma macro padr√£o `hashmap!`."

#: src/std/box.md:1
msgid "# `Box`"
msgstr "# `Box`"

#: src/std/box.md:3
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1] √© um ponteiro de propriedade para dados no heap:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let cinco = Box::new(5);\n"
"    println!(\"cinco: {}\", *cinco);\n"
"}\n"
"```"

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    cinco    :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"

#: src/std/box.md:26
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"`Box<T>` implementa `Deref<Target = T>`, o que significa que voc√™ pode [chamar m√©todos\n"
"de `T` diretamente em um `Box<T>`][2]."

#: src/std/box.md:29
msgid ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"
msgstr ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"

#: src/std/box.md:34
msgid ""
"* `Box` is like `std::unique_ptr` in C++. \n"
"* In the above example, you can even leave out the `*` in the `println!` statement thanks to `Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the Rust compiler wants to know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying large amounts of data on the stack, instead "
"store the data on the heap in a `Box` so only the pointer is moved.\n"
"</details>"
msgstr ""
"* `Box` √© parecido com `std::unique_ptr` em C++. \n"
"* No exemplo acima, voc√™ pode remover o `*` na instru√ß√£o `println!` gra√ßas ao `Deref`. \n"
"* Uma `Box` √© √∫til quando voc√™:\n"
"   * Tem um tipo cujo tamanho n√£o est√° dispon√≠vel em tempo de compila√ß√£o, mas o compilador Rust precisa saber o tamanho exato.\n"
"   * Precisa transferir a propriedade de um dado grande. Ao inv√©s de copiar grandes volumes de dados na pilha (`stack`),\n"
"os dados s√£o armazenados usando uma `Box` na _heap_ e apenas o ponteiro √© movido."
"</details>"

#: src/std/box-recursive.md:1
msgid "# Box with Recursive Data Structures"
msgstr "# `Box` com estruturas de dados recursivas"

#: src/std/box-recursive.md:3
msgid "Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "Tipos de dados recursivos ou tipos de dados com tamanhos din√¢micos precisam usar uma `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}"

#: src/std/box-recursive.md:12 src/std/box-niche.md:10
msgid ""
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    list                 :     :                                               :\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":   | Tag    | Cons  |    :     : .->| Tag    | Cons   | .->| Tag    | Nil  |   :\n"
":   | 0      | 1     |    :     : |  | 0      | 2      | |  | ////// | //// |   :\n"
":   | 1      | o-----+----+-----+-'  | 1      | o------+-'  | ////// | //// |   :\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    lista                :     :                                               :\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":   | Tag    | Cons  |    :     : .->| Tag    | Cons   | .->| Tag    | Nil  |   :\n"
":   | 0      | 1     |    :     : |  | 0      | 2      | |  | ////// | //// |   :\n"
":   | 1      | o-----+----+-----+-'  | 1      | o------+-'  | ////// | //// |   :\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/box-recursive.md:33
msgid ""
"<details>\n"
"    \n"
"* If the `Box` was not used here and we attempted to embed a `List` directly into the `List`,\n"
"the compiler would not compute a fixed size of the struct in memory, it would look infinite.\n"
"    \n"
"* `Box` solves this problem as it has the same size as a regular pointer and just points at the next\n"
"element of the `List` in the heap.    "

msgstr ""
"<details>\n"
"    \n"
"Se a `Box` n√£o for usada aqui e tentarmos incorporar uma `List` diretamente na `List`,\n"
"o compilador n√£o calcularia um tamanho fixo da estrutura na mem√≥ria, pareceria infinito.\n"
"    \n"
"`Box` resolve esse problema, pois tem o mesmo tamanho de um ponteiro normal e apenas aponta para o pr√≥ximo\n"
"elemento da `List` na _heap_.\n"
"    \n"
"</details>"

#: src/std/box-recursive.md:41
msgid ""
"* Remove the `Box` in the List definition and show the compiler error. `Recursive with indirection` is a hint you might "
"want to use a Box or reference of some kind, instead of storing a value directly.   \n"
"    \n"
"</details>"
msgstr ""
"* Remova a `Box` da defini√ß√£o da `List` e veja o erro apresentado pelo compilador. `Recursive with indirection` √© o aviso que voc√™ vai receber."
"</details>"

#: src/std/box-niche.md:1
msgid "# Niche Optimization"
msgstr "# Otimiza√ß√£o de Nicho"

#: src/std/box-niche.md:16
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"Uma `Box` n√£o pode estar vazia, ent√£o o ponteiro √© sempre v√°lido e n√£o `nulo`. Isto\n"
"permite que o compilador otimize o layout da mem√≥ria:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                                   :\n"
":    list                 :     :                                                   :\n"
":   +----------+-------+  :     :    +----------+--------+    +----------+------+   :\n"
":   | 0        | 1     |  :     : .->| 0        |  2     | .->| //////   | //// |   :\n"
":   | \"1/Tag\"| o-----+--+-----+-'  | \"1/Tag\"|  o-----+-'  | \"1/Tag\"| null |   :\n"
":   +----------+-------+  :     :    +----------+--------+    +----------+------+   :\n"
":                         :     :                                                   :\n"
":                         :     :                                                   :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                                   :\n"
":    lista                :     :                                                   :\n"
":   +----------+-------+  :     :    +----------+--------+    +----------+------+   :\n"
":   | 0        | 1     |  :     : .->| 0        |  2     | .->| //////   | //// |   :\n"
":   | \"1/Tag\"| o-----+--+-----+-'  | \"1/Tag\"|  o-----+-'  | \"1/Tag\"| null |   :\n"
":   +----------+-------+  :     :    +----------+--------+    +----------+------+   :\n"
":                         :     :                                                   :\n"
":                         :     :                                                   :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/rc.md:1
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to refer\n"
"to the same data from multiple places:"
msgstr ""
"[`Rc`][1] √© um ponteiro compartilhado com contagem de refer√™ncia. Use-o quando precisar consultar\n"
"os mesmos dados a partir de v√°rios locais:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;"
msgstr ""
"```rust,editable\n"
"use std::rc::Rc;"

#: src/std/rc.md:9
msgid ""
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"
msgstr ""
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"

#: src/std/rc.md:18
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create cycles\n"
"  that will get dropped."
msgstr ""
"Se voc√™ precisar alterar os dados dentro de um `Rc`, precisar√° agrupar os dados em\n"
"um tipo como [`Cell` ou `RefCell`][2]. Veja [`Arc`][3] se voc√™ estiver em um contexto multi-threads.\n"
"Voc√™ pode regredir um ponteiro compartilhado dentro de um ponteiro [`Weak`][4] para criar ciclos\n"
"que ser√£o descartados."

#: src/std/rc.md:24
msgid ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"

#: src/std/rc.md:31
msgid ""
"* Like C++'s `std::shared_ptr`.\n"
"* `clone` is cheap: creates a pointer to the same allocation and increases the reference count.\n"
"* `make_mut` actually clones the inner value if necessary (\"clone-on-write\") and returns a mutable reference.\n"
"* You can `downgrade()` a `Rc` into a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* Como `std::shared_ptr` do C++.\n"
"* `clone` √© barato: cria um ponteiro para a mesma aloca√ß√£o e aumenta a contagem de refer√™ncia.\n"
"* `make_mut` realmente clona o valor interno se necess√°rio (\"clone-on-write\") e retorna uma refer√™ncia mut√°vel.\n"
"* Voc√™ pode invocar `downgrade()` em um `Rc` para obter um objeto contador de refer√™ncias `Weak` para criar\n"
"ciclos que podem ser apropriadamente descartados (provavelmente combinados com `RefCell`)."

#: src/std/rc.md:38
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;"
msgstr ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;"

#: src/std/rc.md:42
msgid ""
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"struct No {\n"
"    valor: i64,\n"
"    pai: Option<Weak<RefCell<No>>>,\n"
"    filhos: Vec<Rc<RefCell<No>>>,\n"
"}"

#: src/std/rc.md:49
msgid ""
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);"
msgstr ""
"fn main() {\n"
"    let mut raiz = Rc::new(RefCell::new(No {\n"
"        valor: 42,\n"
"        pai: None,\n"
"        filhos: vec![],\n"
"    }));\n"
"    let filho = Rc::new(RefCell::new(No {\n"
"        valor: 43,\n"
"        filhos: vec![],\n"
"        pai: Some(Rc::downgrade(&raiz))\n"
"    }));\n"
"    raiz.borrow_mut().filhos.push(filho);"

#: src/std/rc.md:62
msgid ""
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""
"    println!(\"grafo: {raiz:#?}\");\n"
"}\n"
"```"

#: src/modules.md:1
msgid "# Modules"
msgstr "# M√≥dulos"

#: src/modules.md:3
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr "Vimos como os blocos `impl` nos permitem fun√ß√µes de usando espa√ßos de nomes (_namespace_) para um tipo."

#: src/modules.md:5
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "Da mesma forma, `mod` nos permite tipos e fun√ß√µes usando espa√ßo de nomes:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}"
msgstr ""
"```rust, editable\n"
"mod foo {\n"
"    pub fn qualquer_coisa() {\n"
"        println!(\"Qualquer coisa no m√≥dulo foo\");\n"
"    }\n"
"}"

#: src/modules.md:14
msgid ""
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}"
msgstr ""
"mod bar {\n"
"    pub fn qualquer_coisa() {\n"
"        println!(\"Qualquer coisa no modulo bar\");\n"
"    }\n"
"}"

#: src/modules.md:20
msgid ""
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    foo::qualquer_coisa();\n"
"    bar::qualquer_coisa();\n"
"}\n"
"```"

#: src/modules.md:28
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that describes how to build a bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable and a library crate compiles to a library.\n"
"* Modules define organization, scope, and is the focus of this section."
msgstr ""
"* Pacotes (packages) forneces funcionalidades e incluem o arquivo `Cargo.toml` que descreve como gerar o pacote com um ou mais _crates_.\n"
"* _Crates_ s√£o arvores de m√≥dulos onde um _crate_ bir√°rio cria um execut√°vel e um _crate_ de biblioteca compila uma biblioteca.\n"
"* M√≥dulos definem a organiza√ß√£o, o escopo e s√£o o foco desta sess√£o."

#: src/modules/visibility.md:1
msgid "# Visibility"
msgstr "# Visibilidade"

#: src/modules/visibility.md:3
msgid "Modules are a privacy boundary:"
msgstr "Os m√≥dulos s√£o um limitador de privacidade:"

#: src/modules/visibility.md:5
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all the\n"
"  descendants of `foo`."
msgstr ""
"* Os itens do m√≥dulo s√£o privados por padr√£o (ocultam detalhes de implementa√ß√£o).\n"
"* Os itens pai e irm√£o est√£o sempre vis√≠veis."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }"
msgstr ""
"```rust, editable\n"
"mod exterior {\n"
"    fn privado() {\n"
"        println!(\"externo::privado\");\n"
"    }"

#: src/modules/visibility.md:16
msgid ""
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }"
msgstr ""
"    pub fn public() {\n"
"        println!(\"externo::p√∫blico\");\n"
"    }"

#: src/modules/visibility.md:20
msgid ""
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }"
msgstr ""
"    mod interior {\n"
"        fn privado() {\n"
"            println!(\"externo::interno::privado\");\n"
"        }"

#: src/modules/visibility.md:25
msgid ""
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"        pub fn public() {\n"
"            println!(\"externo::interno::p√∫blico\");\n"
"            super::privado();\n"
"        }\n"
"    }\n"
"}"

#: src/modules/visibility.md:32
msgid ""
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    exterior::public();\n"
"}\n"
"```"

#: src/modules/visibility.md:39
msgid "* Use the `pub` keyword to make mods public."
msgstr "* Use a palavra reservada `pub` para tornar um m√≥dulo p√∫blico."

#: src/modules/visibility.md:41
msgid "Additionally, there are advanced `pub(...)` specifiers to restrict the scope of public visibility."
msgstr "Adicionamente, existem especificadores `pub(...)` avan√ßados para restringir o\n"
"escopo da visibilidade p√∫blica."

#: src/modules/visibility.md:43
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-"
"pubself)).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of its descendants)."
msgstr ""
"* Veja a [Refer√™ncia Rust](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-"
"pubself).\n"
"* `pub(crate)` √© a configura√ß√£o padr√£o de visibilidade.\n"
"* Menos comum, voc√™ pode dar visibilidade para um caminho espec√≠fico.\n"
"* Em todo caso, a visibilidade deve ser concedida ao m√≥dulo ancestral (e a todos os seus descendentes)."

#: src/modules/paths.md:1
msgid "# Paths"
msgstr "# Caminhos (paths)"

#: src/modules/paths.md:3
msgid "Paths are resolved as follows:"
msgstr "Os caminhos s√£o resolvidos da seguinte forma:"

#: src/modules/paths.md:5
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module."
msgstr ""
"1. Como caminho relativo:\n"
"   * `foo` ou `self::foo` refere-se a `foo` no m√≥dulo atual,\n"
"   * `super::foo` refere-se a `foo` no m√≥dulo pai."

#: src/modules/paths.md:9
msgid ""
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"2. Como um caminho absoluto:\n"
"   * `crate::foo` refere-se a `foo` na raiz do _crate_ atual,\n"
"   * `bar::foo` refere-se a `foo` no _crate_ `bar`."

#: src/modules/filesystem.md:1
msgid "# Filesystem Hierarchy"
msgstr "# Hierarquia do sistema de arquivos"

#: src/modules/filesystem.md:3
msgid "The module content can be omitted:"
msgstr "O conte√∫do do m√≥dulo pode ser omitido:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"

#: src/modules/filesystem.md:9
msgid "The `garden` module content is found at:"
msgstr "O conte√∫do do m√≥dulo `garden` √© encontrado em:"

#: src/modules/filesystem.md:11
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden.rs` (estilo Rust 2018 moderno)\n"
"* `src/garden/mod.rs` (antigo estilo Rust 2015)"

#: src/modules/filesystem.md:14
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "Da mesma forma, um m√≥dulo `garden::vegetables` pode ser encontrado em:"

#: src/modules/filesystem.md:16
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden/vegetables.rs` (estilo Rust 2018 moderno)\n"
"* `src/garden/vegetables/mod.rs` (antigo estilo Rust 2015)"

#: src/modules/filesystem.md:19
msgid "The `crate` root is in:"
msgstr "A raiz `crate` est√° em:"

#: src/modules/filesystem.md:21
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* `src/lib.rs` (para um _crate_ de biblioteca)\n"
"* `src/main.rs` (para um _crate_ bin√°rio)"

#: src/exercises/day-2/afternoon.md:1
msgid "# Day 2: Afternoon Exercises"
msgstr "# Dia 2: Exerc√≠cios da Tarde"

#: src/exercises/day-2/afternoon.md:3
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "Os exerc√≠cios desta tarde se concentrar√£o em strings e iteradores."

#: src/exercises/day-2/luhn.md:1
msgid "# Luhn Algorithm"
msgstr "# Algoritmo de Luhn"

#: src/exercises/day-2/luhn.md:3
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to\n"
"validate credit card numbers. The algorithm takes a string as input and does the\n"
"following to validate the credit card number:"
msgstr ""
"O [algoritmo Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) √© usado para\n"
"validar n√∫meros de cart√£o de cr√©dito. O algoritmo recebe uma string como entrada e faz o\n"
"seguinte para validar o n√∫mero do cart√£o de cr√©dito:"

#: src/exercises/day-2/luhn.md:7
msgid "* Ignore all spaces. Reject number with less than two digits."
msgstr "* Ignora todos os espa√ßos. Rejeita n√∫meros com menos de dois d√≠gitos."

#: src/exercises/day-2/luhn.md:9
msgid ""
"* Moving from right to left, double every second digit: for the number `1234`,\n"
"  we double `3` and `1`."
msgstr ""
"* Movendo-se da direita para a esquerda, dobra cada segundo d√≠gito: para o n√∫mero `1234`,\n"
"  dobra os n√∫meros `3` e `1`."

#: src/exercises/day-2/luhn.md:12
msgid ""
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` which\n"
"  becomes `5`."
msgstr ""
"* Depois de dobrar um d√≠gito, soma os d√≠gitos. Assim, duplicar `7` resulta em `14` que\n"
"  resulta em `5`."

#: src/exercises/day-2/luhn.md:15
msgid "* Sum all the undoubled and doubled digits."
msgstr "* Soma todos os d√≠gitos n√£o duplicados e duplicados."

#: src/exercises/day-2/luhn.md:17
msgid "* The credit card number is valid if the sum ends with `0`."
msgstr "* O n√∫mero do cart√£o de cr√©dito √© v√°lido se a soma terminar em `0`."

#: src/exercises/day-2/luhn.md:19
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"Copie o seguinte c√≥digo para <https://play.rust-lang.org/> e implemente a\n"
"fun√ß√£o:"

#: src/exercises/day-2/luhn.md:27
msgid ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"pub fn luhn(numero_cc: &str) -> bool {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-2/luhn.md:31
msgid ""
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""
"#[test]\n"
"fn test_numero_cc_nao_numerico() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"

#: src/exercises/day-2/luhn.md:36 src/exercises/day-2/solutions-afternoon.md:64
msgid ""
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}"
msgstr ""
"#[test]\n"
"fn test_numero_cc_vazio() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}"

#: src/exercises/day-2/luhn.md:44 src/exercises/day-2/solutions-afternoon.md:72
msgid ""
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}"
msgstr ""
"#[test]\n"
"fn test_numero_cc_um_numero() {\n"
"    assert!(!luhn(\"0\"));\n"
"}"

#: src/exercises/day-2/luhn.md:49 src/exercises/day-2/solutions-afternoon.md:77
msgid ""
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}"
msgstr ""
"#[test]\n"
"fn test_numero_cc_dois_numeros() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}"

#: src/exercises/day-2/luhn.md:54 src/exercises/day-2/solutions-afternoon.md:82
msgid ""
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}"
msgstr ""
"#[test]\n"
"fn test_numero_cc_valido() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}"

#: src/exercises/day-2/luhn.md:61
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"
msgstr ""
"#[test]\n"
"fn test_numero_cc_invalido() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"

#: src/exercises/day-2/strings-iterators.md:1
msgid "# Strings and Iterators"
msgstr "# Strings e iteradores"

#: src/exercises/day-2/strings-iterators.md:3
msgid ""
"In this exercise, you are implementing a routing component of a web server. The\n"
"server is configured with a number of _path prefixes_ which are matched against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"Neste exerc√≠cio, voc√™ est√° implementando um componente de roteamento de um servidor web. O\n"
"servidor est√° configurado com um n√∫mero de _prefixos de caminhos_ que s√£o comparados\n"
"com os _caminhos pedidos_. Os prefixos de caminho podem conter um caractere curinga que\n"
"corresponde a um segmento completo. Veja os testes unit√°rios abaixo."

#: src/exercises/day-2/strings-iterators.md:8
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copie o seguinte c√≥digo para <https://play.rust-lang.org/> e fa√ßa os testes\n"
"passarem. Tente evitar alocar um `Vec` para seus resultados intermedi√°rios:"

#: src/exercises/day-2/strings-iterators.md:16
msgid ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""
"pub fn correspondencia_prefixo(prefixo: &str, caminho_requisitado: &str) -> bool {\n"
"    unimplemented!()\n"
"}"

#: src/exercises/day-2/strings-iterators.md:20
msgid ""
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""
"#[test]\n"
"fn test_correspondencia_sem_curinga() {\n"
"    assert!(correspondencia_prefixo(\"/v1/autores\", \"/v1/autores\"));\n"
"    assert!(correspondencia_prefixo(\"/v1/autores\", \"/v1/autores/abc-123\"));\n"
"    assert!(correspondencia_prefixo(\"/v1/autores\", \"/v1/autores/abc/livros\"));"

#: src/exercises/day-2/strings-iterators.md:26 src/exercises/day-2/solutions-afternoon.md:146
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"}"
msgstr ""
"    assert!(!correspondencia_prefixo(\"/v1/autores\", \"/v1\"));\n"
"    assert!(!correspondencia_prefixo(\"/v1/autores\", \"/v1/autoresLivros\"));\n"
"    assert!(!correspondencia_prefixo(\"/v1/autores\", \"/v1/parent/autores\"));\n"
"}"

#: src/exercises/day-2/strings-iterators.md:31 src/exercises/day-2/solutions-afternoon.md:151
msgid ""
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));"
msgstr ""
"#[test]\n"
"fn test_correspondencia_com_curinga() {\n"
"    assert!(correspondencia_prefixo(\n"
"        \"/v1/autores/*/livros\",\n"
"        \"/v1/autores/foo/livros\"\n"
"    ));\n"
"    assert!(correspondencia_prefixo(\n"
"        \"/v1/autores/*/livros\",\n"
"        \"/v1/autores/bar/livros\"\n"
"    ));\n"
"    assert!(correspondencia_prefixo(\n"
"        \"/v1/autores/*/livros\",\n"
"        \"/v1/autores/foo/livros/livro1\"\n"
"    ));"

#: src/exercises/day-2/strings-iterators.md:46
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"    assert!(!correspondencia_prefixo(\"/v1/autores/*/livros\", \"/v1/autores\"));\n"
"    assert!(!correspondencia_prefixo(\n"
"        \"/v1/autores/*/livros\",\n"
"        \"/v1/autores/foo/livrosPorAutor\"\n"
"    ));\n"
"}\n"
"```"

#: src/welcome-day-3.md:1
msgid "# Welcome to Day 3"
msgstr "# Bem-vindo ao Dia 3"

#: src/welcome-day-3.md:3
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Hoje, abordaremos alguns t√≥picos mais avan√ßados em Rust:"

#: src/welcome-day-3.md:5
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits."
msgstr ""
"* Traits (Caracter√≠sticas): Traits derivadas, m√©todos padr√£o e Traits importantes da biblioteca padr√£o."

#: src/welcome-day-3.md:8
msgid ""
"* Generics: generic data types, generic methods, monomorphization, and trait\n"
"  objects."
msgstr ""
"* Generics (Gen√©ricos): tipos de dados gen√©ricos, m√©todos gen√©ricos, monomorfiza√ß√£o e trait\n"
"  objetos."

#: src/welcome-day-3.md:11
msgid "* Error handling: panics, `Result`, and the try operator `?`."
msgstr "* Tratamento de erros: p√¢nico (_panics_), `Result` e o operador _try_ `?`."

#: src/welcome-day-3.md:13
msgid "* Testing: unit tests, documentation tests, and integration tests."
msgstr "* Testes: testes unit√°rios, testes de documenta√ß√£o e testes de integra√ß√£o."

#: src/welcome-day-3.md:15
msgid ""
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""
"* Rust inseguro (unsafe): ponteiros brutos, vari√°veis est√°ticas, fun√ß√µes inseguras e fun√ß√µes externas."

#: src/traits.md:1
msgid "# Traits"
msgstr "# Traits (Caracter√≠sticas)"

#: src/traits.md:3
msgid "Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "Rust permite abstrair caracter√≠sticas dos tipos usando `trait`. Eles s√£o semelhantes √†s interfaces:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Greet {\n"
"    fn say_hello(&self);\n"
"}"
msgstr ""
"```rust,editable\n"
"trait Saudar {\n"
"    fn diz_ola(&self);\n"
"}"

#: src/traits.md:10
msgid ""
"struct Dog {\n"
"    name: String,\n"
"}"
msgstr ""
"struct Cachorro {\n"
"    nome: String,\n"
"}"

#: src/traits.md:14
msgid "struct Cat;  // No name, cats won't respond to it anyway."
msgstr "struct Gato; // Sem nome, os gatos n√£o v√£o responder de qualquer maneira."

#: src/traits.md:16
msgid ""
"impl Greet for Dog {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Wuf, my name is {}!\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Saudar for Cachorro {\n"
"    fn diz_ola(&self) {\n"
"        println!(\"Wuf, meu nome √© {}!\", self.nome);\n"
"    }\n"
"}"

#: src/traits.md:22
msgid ""
"impl Greet for Cat {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Miau!\");\n"
"    }\n"
"}"
msgstr ""
"impl Saudar for Gato {\n"
"    fn diz_ola(&self) {\n"
"        println!(\"Miau!\");\n"
"    }\n"
"}"

#: src/traits.md:28
msgid ""
"fn main() {\n"
"    let pets: Vec<Box<dyn Greet>> = vec![\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"        Box::new(Cat),\n"
"    ];\n"
"    for pet in pets {\n"
"        pet.say_hello();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let pets: Vec<Box<dyn Saudar>> = vec![\n"
"        Box::new(Cachorro{ nome: String::from(\"Fido\") }),\n"
"        Box::new(Gato),\n"
"    ];\n"
"    for pet in pets {\n"
"        pet.diz_ola();\n"
"    }\n"
"}\n"
"```"

#: src/traits.md:41
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that users are required to implement themselves. Methods "
"with default implementations can rely on required methods.\n"
"* Types that implement a given trait may be of different sizes. This makes it impossible to have things like `Vec<Greet>` "
"in the example above.\n"
"* `dyn Greet` is a way to tell the compiler about a dynamically sized type that implements `Greet`.\n"
"* In the example, `pets` holds Fat Pointers to objects that implement `Greet`. The Fat Pointer consists of two components, "
"a pointer to the actual object and a pointer to the virtual method table for the `Greet` implementation of that particular "
"object."
msgstr ""
"* _Traits_ podem especificar m√©todos pr√©-implementados (padr√£o) e m√©todos que os usu√°rios devem implementar por conta "
"pr√≥pria. Os m√©todos com implementa√ß√µes padr√£o podem contar com os m√©todos necess√°rios.\n"
"* Os tipos que implementam uma determinada caracter√≠stica podem ser de tamanhos diferentes. Isso torna imposs√≠vel ter "
"coisas como `Vec<Greet>` no exemplo acima.\n"
"* `dyn Greet` √© uma maneira de dizer ao compilador sobre um tipo de tamanho din√¢mico que implementa `Greet`.\n"
"* No exemplo, `pets` mant√©m _Fat Pointers_ para objetos que implementam `Greet`. O _Fat Pointer_ consiste em dois componentes, "
"um ponteiro para o objeto real e um ponteiro para a tabela de m√©todos virtuais para a implementa√ß√£o de `Greet` desse objeto em "
"particular."

#: src/traits.md:46
msgid ""
"Compare these outputs in the above example:\n"
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"
msgstr ""
"Compare essas sa√≠das no exemplo acima:\n"
"```rust, ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"

#: src/traits/deriving-traits.md:1
msgid "# Deriving Traits"
msgstr "# traits derivados"

#: src/traits/deriving-traits.md:3
msgid "You can let the compiler derive a number of traits:"
msgstr "Voc√™ pode deixar o compilador derivar uma s√©rie de traits:"

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Jogador {\n"
"    nome: String,\n"
"    forca: u8,\n"
"    pontos_vida: u8,\n"
"}"

#: src/traits/deriving-traits.md:13
msgid ""
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Jogador::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"√â {:?}\\nigual a {:?}?\\nA resposta √© {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"sim\" } else { \"n√£o\" });\n"
"}\n"
"```"

#: src/traits/default-methods.md:1
msgid "# Default Methods"
msgstr "# M√©todos Padr√£o"

#: src/traits/default-methods.md:3
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "Traits podem implementar o comportamento em termos de outros m√©todos de `trait`:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}"
msgstr ""
"```rust,editable\n"
"trait Iguais {\n"
"    fn igual(&self, outro: &Self) -> bool;\n"
"    fn diferente(&self, outro: &Self) -> bool {\n"
"        !self.igual(outro)\n"
"    }\n"
"}"

#: src/traits/default-methods.md:13
msgid ""
"#[derive(Debug)]\n"
"struct Centimeter(i16);"
msgstr ""
"#[derive(Debug)]\n"
"struct Centimetro(i16);"

#: src/traits/default-methods.md:16
msgid ""
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}"
msgstr ""
"impl Iguais for Centimetro {\n"
"    fn igual(&self, outro: &Centimetro) -> bool {\n"
"        self.0 == outro.0\n"
"    }\n"
"}"

#: src/traits/default-methods.md:22
msgid ""
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let a = Centimetro(10);\n"
"    let b = Centimetro(20);\n"
"    println!(\"{a:?} √© igual a {b:?}: {}\", a.igual(&b));\n"
"    println!(\"{a:?} √© diferente de {b:?}: {}\", a.diferente(&b));\n"
"}\n"
"```"

#: src/traits/important-traits.md:1
msgid "# Important Traits"
msgstr "# Traits importantes"

#: src/traits/important-traits.md:3
msgid "We will now look at some of the most common traits of the Rust standard library:"
msgstr "Veremos agora os _Traits_ mais comuns da biblioteca padr√£o do Rust:"

#: src/traits/important-traits.md:5
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* [`Iterator`][1] e [`IntoIterator`][2] usados em la√ßos `for`,\n"
"* [`From`][3] e [`Into`][4] usados na conver√ß√£o de valores,\n"
"* [`Read`][5] e [`Write`][6] usados em opera√ß√µes de IO,\n"
"* [`Add`][7], [`Mul`][8], ... usado na sobrecarga de operadores,\n"
"* [`Drop`][9] usado para definir destrutores e\n"
"* [`Default`][10] usado para construir uma inst√¢ncia padr√£o para um tipo."

#: src/traits/important-traits.md:12
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\n"
"[3]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[4]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[5]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[6]: https://doc.rust-lang.org/std/io/trait.Write.html\n"
"[7]: https://doc.rust-lang.org/std/ops/trait.Add.html\n"
"[8]: https://doc.rust-lang.org/std/ops/trait.Mul.html\n"
"[9]: https://doc.rust-lang.org/std/ops/trait.Drop.html\n"
"[10]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr ""

#: src/traits/iterator.md:1
msgid "# Iterators"
msgstr "# Iteradores"

#: src/traits/iterator.md:3
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "Voc√™ pode implementar o _trait_ `Iterator` em seus pr√≥prios tipos:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}"
msgstr ""

#: src/traits/iterator.md:11
msgid ""
"impl Iterator for Fibonacci {\n"
"    type Item = u32;"
msgstr ""

#: src/traits/iterator.md:14
msgid ""
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/iterator.md:22
msgid ""
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
msgid ""
"* `IntoIterator` is the trait that makes for loops work. It is implemented by collection types such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also implement it.\n"
"* The `Iterator` trait implements many common functional programming operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can find all the documentation\n"
"  about them. In Rust these functions should produce the code as efficient as equivalent imperative\n"
"  implementations.\n"
"    \n"
"</details>"
msgstr ""
"* `IntoIterator` √© o recurso que faz com que os la√ßos funcionem. √â implementado por tipos de cole√ß√£o, como\n"
"  `Vec<T>` e refer√™ncias a eles, como `&Vec<T>` e `&[T]`. Os intervalos tamb√©m o implementam.\n"
"* O _trait_ `Iterator` implementa muitas opera√ß√µes de programa√ß√£o funcional comuns sobre cole√ß√µes\n"
"  (por exemplo, `mapa`, `filtro`, `redu√ß√£o`, etc). Este √© o _trait_ onde voc√™ pode encontrar toda a documenta√ß√£o\n"
"  sobre eles. Em Rust, essas fun√ß√µes devem produzir o c√≥digo t√£o eficiente quanto a implementa√ß√£o imperativa equivalente.\n"
"    \n"
"</details>"

#: src/traits/iterator.md:41
msgid "[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#: src/traits/from-iterator.md:1
msgid "# FromIterator"
msgstr "# FromIterator"

#: src/traits/from-iterator.md:3
msgid "[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr "`FromIterator` permite construir uma cole√ß√£o a partir de um `Iterator`."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"`Iterator` implementa\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"

#: src/traits/from-iterator.md:23
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Tamb√©m existem implementa√ß√µes que permitem fazer coisas legais como converter um\n"
"`Iterator<Item = Result<V, E>>` em um `Result<Vec<V>, E>`."

#: src/traits/from-iterator.md:28
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"

#: src/traits/from-into.md:1
msgid "# `From` and `Into`"
msgstr "# `From` e `Into`"

#: src/traits/from-into.md:3
msgid "Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr "Os tipos implementam `From` e `Into` para facilitar as convers√µes de tipo:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"Ol√°\");\n"
"    let endereco_ipv4 = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let um = i16::from(true);\n"
"    let maior = i32::from(123i16);\n"
"    println!(\"{s}, {endereco_ipv4}, {um}, {maior}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:15
msgid "[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr "[`Into`][2] √© implementado automaticamente quando [`From`][1] √© implementado:"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"Ol√°\".into();\n"
"    let endereco_ipv4: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let um: i16 = true.into();\n"
"    let maior: i32 = 123i16.into();\n"
"    println!(\"{s}, {endereco_ipv4}, {um}, {maior}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:27
msgid ""
"<details>\n"
"  \n"
"* That's why it is common to only implement `From`, as your type will get `Into` implementation too.\n"
"* When declaring a function argument input type like \"anything that can be converted into a `String`\", the rule is "
"opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that _only_ implement `Into`.\n"
"    \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
"* √â por isso que √© comum implementar apenas `From`, j√° que seu tipo tamb√©m receber√° a implementa√ß√£o de `Into`.\n"
"* Ao declarar um tipo de entrada de argumento de fun√ß√£o como \"qualquer coisa que possa ser convertida em `String`\", a "
"regra √© oposta, voc√™ deve usar `Into`.\n"
"  Sua fun√ß√£o aceitar√° tipos que implementam `From` e aqueles que _apenas_ implementam `Into`.\n"
"    \n"
"</details>"

#: src/traits/from-into.md:35
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"

#: src/traits/read-write.md:1
msgid "# `Read` and `Write`"
msgstr "# `Read` e `Write`"

#: src/traits/read-write.md:3
msgid "Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "Usando `Read` e `BufRead`, voc√™ pode abstrair a leitura de conte√∫dos do tipo `u8`:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};"
msgstr ""

#: src/traits/read-write.md:8
msgid ""
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}"
msgstr ""
"fn contar_linhas<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}"

#: src/traits/read-write.md:13
msgid ""
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));"
msgstr ""
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"linhas na slice: {}\", contar_linhas(slice));"

#: src/traits/read-write.md:17
msgid ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"linhas no arquivo: {}\", contar_linhas(file));\n"
"    Ok(())\n"
"}\n"
"```"

#: src/traits/read-write.md:23
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "Da mesma forma, `Write` permite abstrair a escrita de dados do tipo `u8`:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};"
msgstr ""
"```rust, editable\n"
"use std::io::{Result, Write};"

#: src/traits/read-write.md:28
msgid ""
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}"
msgstr ""

#: src/traits/read-write.md:33
msgid ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Ol√°\")?;\n"
"    log(&mut buffer, \"Mundo\")?;\n"
"    println!(\"Logado: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"

#: src/traits/read-write.md:42
msgid ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"

#: src/traits/operators.md:1
msgid "# `Add`, `Mul`, ..."
msgstr "# `Add`, `Mul`, ..."

#: src/traits/operators.md:3
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr "A sobrecarga de operadores √© implementada por meio do `trait` contido em [`std::ops`][1]:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }"
msgstr ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Ponto { x: i32, y: i32 }"

#: src/traits/operators.md:9 src/exercises/day-2/solutions-morning.md:46
msgid ""
"impl std::ops::Add for Point {\n"
"    type Output = Self;"
msgstr ""
"impl std::ops::Add for Ponto {\n"
"    type Output = Self;"

#: src/traits/operators.md:12
msgid ""
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}"
msgstr ""
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}"

#: src/traits/operators.md:17
msgid ""
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Ponto { x: 10, y: 20 };\n"
"    let p2 = Ponto { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"

#: src/traits/operators.md:26 src/traits/drop.md:34
msgid "Discussion points:"
msgstr "Pontos de discuss√£o:"

#: src/traits/operators.md:28
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter?\n"
"    * Short answer: Type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor of a\n"
"        trait."
msgstr ""
"* Voc√™ pode implementar `Add` para `&Ponto`. Em quais situa√ß√µes isso √© √∫til?\n"
"    * Resposta: `Add:add` consome `self`. Se digitar `T` para o qual voc√™ est√°\n"
"        sobrecarregando o operador n√£o implementa `Copy`, voc√™ deve considerar sobrecarregar\n"
"        o operador para `&T` tamb√©m. Isso evita a clonagem desnecess√°ria no\n"
"        local da chamada.\n"
"* Por que `Output` √© um tipo associado? Poderia ser feito um par√¢metro de tipo?\n"
"    * Resposta curta: os par√¢metros de tipo s√£o controlados pelo chamador, mas\n"
"        tipos associados (como `Output`) s√£o controlados pelo implementador do\n"
"        `trait`."

#: src/traits/operators.md:40
msgid "[1]: https://doc.rust-lang.org/std/ops/index.html"
msgstr "[1]: https://doc.rust-lang.org/std/ops/index.html"

#: src/traits/drop.md:1
msgid "# The `Drop` Trait"
msgstr "# O Trait `Drop`"

#: src/traits/drop.md:3
msgid "Values which implement [`Drop`][1] can specify code to run when they go out of scope:"
msgstr "Valores que implementam [`Drop`][1] podem especificar o c√≥digo a ser executado quando saem do escopo:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}"
msgstr ""
"```rust,editable\n"
"struct Excluivel {\n"
"    nome: &'static str,\n"
"}"

#: src/traits/drop.md:10
msgid ""
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}"
msgstr ""
"impl Drop for Excluivel {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Executando 'Drop' {}\", self.nome);\n"
"    }\n"
"}"

#: src/traits/drop.md:16
msgid ""
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let a = Excluivel { nome: \"a\" };\n"
"    {\n"
"        let b = Excluivel { nome: \"b\" };\n"
"        {\n"
"            let c = Excluivel { nome: \"c\" };\n"
"            let d = Excluivel { nome: \"d\" };\n"
"            println!(\"Saindo do bloco B\");\n"
"        }\n"
"        println!(\"Saindo do bloco A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Saindo do main\");\n"
"}\n"
"```"

#: src/traits/drop.md:36
msgid ""
"* Why does not `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* Por que `Drop::drop` n√£o recebe `self`?\n"
"    * Resposta curta: Se recebesse, `std::mem::drop` seria chamado no final do\n"
"        bloco, resultando em outra chamada para `Drop::drop` ocasionando um estouro de pilha.\n"
"* Tente substituir `drop(a)` por `a.drop()`."

#: src/traits/drop.md:44
msgid "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#: src/traits/default.md:1
msgid "# The `Default` Trait"
msgstr "# O Trait `Default`"

#: src/traits/default.md:3
msgid "[`Default`][1] trait provides a default implementation of a trait."
msgstr "O `trait` [`Default`][1] fornece uma implementa√ß√£o padr√£o para um `trait`."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derivado {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implementado,\n"
"}"

#: src/traits/default.md:13
msgid ""
"#[derive(Debug)]\n"
"struct Implemented(String);"
msgstr ""
"#[derive(Debug)]\n"
"struct Implementado(String);"

#: src/traits/default.md:16
msgid ""
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}"
msgstr ""
"impl Default for Implementado {\n"
"    fn default() -> Self {\n"
"        Self(\"Fulano de tal\".into())\n"
"    }\n"
"}"

#: src/traits/default.md:22
msgid ""
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");"
msgstr ""
"fn main() {\n"
"    let estrutura_default: Derivado = Default::default();\n"
"    println!(\"{estrutura_default:#?}\");"

#: src/traits/default.md:26
msgid ""
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");"
msgstr ""
"    let estrutura_quase_default = Derivado {\n"
"        y: \"Y √© atribu√≠do!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{estrutura_quase_default:#?}\");"

#: src/traits/default.md:32
msgid ""
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}"
msgstr ""
"    let nada: Option<Derivado> = None;\n"
"    println!(\"{:#?}\", nada.unwrap_or_default());\n"
"}"

#: src/traits/default.md:40
msgid ""
"  * It can be implemented directly or it can be derived via `#[derive(Default)]`.\n"
"  * Derived implementation will produce an instance where all fields are set to their default values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values (e.g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and provides convenience methods that use it."
msgstr ""
"  * Ele pode ser implementado diretamente ou derivado usando `#[derive(Default)]`.\n"
"  * A implementa√ß√£o usando `derive` produz uma inst√¢ncia onde todos os campos s√£o preenchidos\n"
" com seus valores padr√£o.\n"
"    * Consequentemente, todos os tipos usados na estrutuda devem implementar `Default` tamb√©m.\n"
"  * Frequentemente, os tipos padr√£o do Rust implementam `Default` com valores razo√°veis (ex: `0`, `\"\"`, etc).\n"
"  * A c√≥pia parcial de estrututas funciona bem em conjunto com _default_.\n"
"  * A bilioteca padr√£o do Rust sabe que tipos podem implementar o `trait` `Default` e, convenientemente,\n"
" prov√™ m√©todos para isso."

#: src/traits/default.md:49
msgid "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#: src/generics.md:1
msgid "# Generics"
msgstr "# Generics (Gen√©ricos)"

#: src/generics.md:3
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as sorting)\n"
"over the types used in the algorithm."
msgstr ""
"Rust oferece suporte a tipos gen√©ricos, que permitem a um algoritmo (como classifica√ß√£o, por exemplo),\n"
"abstrair os tipos de dados usados no algoritmo."

#: src/generics/data-types.md:1
msgid "# Generic Data Types"
msgstr "# Tipos de dados gen√©ricos"

#: src/generics/data-types.md:3
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Voc√™ pode usar tipos gen√©ricos para abstrair o tipo concreto do campo:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Ponto<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"

#: src/generics/data-types.md:12
msgid ""
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let inteiro = Ponto { x: 5, y: 10 };\n"
"    let real = Ponto { x: 1.0, y: 4.0 };\n"
"    println!(\"{inteiro:?} e {real:?}\");\n"
"}\n"
"```"

#: src/generics/methods.md:1
msgid "# Generic Methods"
msgstr "# M√©todos Gen√©ricos"

#: src/generics/methods.md:3
msgid "You can declare a generic type on your `impl` block:"
msgstr "Voc√™ pode declarar um tipo gen√©rico em seu bloco `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);"
msgstr ""
"```rust, editable\n"
"#[derive(Debug)]\n"
"struct Ponto<T>(T, T);"

#: src/generics/methods.md:9
msgid ""
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }"
msgstr ""
"impl<T> Ponto<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0 // + 10\n"
"    }"

#: src/generics/methods.md:14
msgid ""
"    // fn set_x(&mut self, x: T)\n"
"}"
msgstr ""
"    // fn set_x(&mut self, x: T)\n"
"}"

#: src/generics/methods.md:17
msgid ""
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p = Ponto(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"

#: src/generics/methods.md:25
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that redundant?\n"
"    * This is because it is a generic implementation section for generic type. They are independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods in this block will only be available for "
"`Point<u32>`."
msgstr ""
"* *Pergunta:* Por que `T` √© especificado duas vezes em `impl<T> Ponto<T> {}`? Isso n√£o √© redundante?\n"
"    * Isso ocorre porque √© uma se√ß√£o de implementa√ß√£o gen√©rica para tipo gen√©rico. Eles s√£o gen√©ricos de forma "
"independente.\n"
"    * Significa que esses m√©todos s√£o definidos para qualquer `T`.\n"
"    * √â poss√≠vel escrever `Impl Ponto<u32> { .. }`.\n"
"      * `Ponto` ainda √© gen√©rico e voc√™ pode usar `Ponto<f64>`, mas os m√©todos neste bloco s√≥ estar√£o dispon√≠veis para "
"`Ponto<u32>`."

#: src/generics/trait-bounds.md:1
msgid "# Trait Bounds"
msgstr "# Limites de traits"

#: src/generics/trait-bounds.md:3
msgid ""
"When working with generics, you often want to require the types to implement\n"
"some trait, so that you can call this trait's methods."
msgstr ""
"Ao trabalhar com gen√©ricos, muitas vezes voc√™ exigir que os tipos implementem algum `trait`\n"
" para poder utilizar os m√©todos do `trait`."

#: src/generics/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Voc√™ consegue fazer isso com `T:Trait` ou `impl Trait`:"

#: src/generics/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"
msgstr ""
"```rust, editable\n"
"fn duplicar<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"

#: src/generics/trait-bounds.md:13
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}"
msgstr ""
"//   A√ßucar sint√°tico para:\n"
"//   fn somar_42_milhoes<T: Into<i32>>(x: T) -> i32 {\n"
"fn somar_42_milhoes(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}"

#: src/generics/trait-bounds.md:19
msgid "// struct NotClonable;"
msgstr "// struct NotClonable;"

#: src/generics/trait-bounds.md:21
msgid ""
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");"
msgstr ""
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let par = duplicar(foo);\n"
"    println!(\"{par:?}\");"

#: src/generics/trait-bounds.md:26
msgid ""
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""
"    let muito = somar_42_milhoes(42_i8);\n"
"    println!(\"{muito}\");\n"
"    let muito_mais = somar_42_milhoes(10_000_000);\n"
"    println!(\"{muito_mais}\");\n"
"}\n"
"```"

#: src/generics/trait-bounds.md:35
msgid ""
"Show a `where` clause, students will encounter it when reading code.\n"
"    \n"
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""
"Mostre uma cl√°usula `where`, os alunos a encontrar√£o ao ler o c√≥digo.\n"
"    \n"
"```rust, ignore\n"
"fn duplicar<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"

#: src/generics/trait-bounds.md:46
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of \":\" can be arbitrary, like `Option<T>`.\n"
"    \n"
"</details>"
msgstr ""
"* Organiza a assinatura da fun√ß√£o se voc√™ tiver muitos par√¢metros.\n"
"* Possui recursos adicionais tornando-o mais poderoso.\n"
"    * Se algu√©m perguntar, o recurso extra √© que o tipo √† esquerda de \":\" pode ser arbitr√°rio, como `Option<T>`.\n"
"    \n"
"</details>"

#: src/generics/impl-trait.md:1
msgid "# `impl Trait`"
msgstr "# Trait `impl`"

#: src/generics/impl-trait.md:3
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"Semelhante aos limites do _trait_, a sintaxe do _trait_ `impl` pode ser usada em argumentos de fun√ß√µes\n"
"e em valores de retorno:"

#: src/generics/impl-trait.md:6 src/generics/trait-objects.md:5 src/generics/trait-objects.md:28
msgid ""
"```rust,editable\n"
"use std::fmt::Display;"
msgstr ""
"```rust, editable\n"
"use std::fmt::Display;"

#: src/generics/impl-trait.md:9
msgid ""
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}"
msgstr ""
"fn get_x(nome: impl Display) -> impl Display {\n"
"    format!(\"Ol√° {nome}\")\n"
"}"

#: src/generics/impl-trait.md:13
msgid ""
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"

#: src/generics/impl-trait.md:19
msgid ""
"* `impl Trait` cannot be used with the `::<>` turbo fish syntax.\n"
"* `impl Trait` allows you to work with types which you cannot name."
msgstr ""
"* `impl Trait` n√£o pode ser usado com a sintaxe turbo fish `::<>`.\n"
"* `impl Trait` permite que voc√™ trabalhe com tipos que voc√™ n√£o pode nomear."

#: src/generics/impl-trait.md:24
msgid "The meaning of `impl Trait` is a bit different in the different positions."
msgstr "O significado do _trait_ `impl` √© um pouco difere de acordo com sua posi√ß√£o."

#: src/generics/impl-trait.md:26
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with a trait bound.\n"
"* For a return type, it means that the return type is some concrete type that implements the trait,\n"
"  without naming the type. This can be useful when you don't want to expose the concrete type in a\n"
"  public API."
msgstr ""
"* Como par√¢metro, o _trait_ `impl` √© como um par√¢metro gen√©rico an√¥nimo com um limitador de caracter√≠sticas (trait).\n"
"* Como tipo de retorno, significa que o tipo de retorno √© algum tipo concreto que implementa o _trait_,\n"
"  sem namear o tipo. Isso pode ser √∫til quando voc√™ n√£o deseja expor o tipo concreto em uma\n"
"  API p√∫blica."

#: src/generics/impl-trait.md:31
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` type are the same type.\n"
"It would not work for this particular function, as the type we expect as input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, we'd need two\n"
"independent generic parameters.\n"
"    \n"
"</details>"
msgstr ""
"Este exemplo √© √≥timo, porque usa `impl Display` duas vezes. Isso ajuda a explicar\n"
"que nada imp√µe que, nos dois usos, `impl Display` seja _do mesmo_ tipo. Se us√°ssemos um √∫nico\n"
"`T: Display`, imporia a restri√ß√£o de que o tipo `T` de entrada e o tipo `T` de retorno s√£o do mesmo tipo.\n"
"Isso n√£o funcionaria para esta fun√ß√£o espec√≠fica, pois o tipo que esperamos como entrada provavelmente n√£o √©\n"
"o que `format!` retorna. Se quis√©ssemos fazer o mesmo atrav√©s da sintaxe `: Display`, precisar√≠amos de dois\n"
"par√¢metros gen√©ricos independentes.\n"
"    \n"
"</details>"

#: src/generics/closures.md:1
msgid "# Closures"
msgstr "# Closures"

#: src/generics/closures.md:3
msgid ""
"Closures or lambda expressions have types which cannot be named. However, they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Closures ou express√µes _lambda_ t√™m tipos que n√£o podem ser nomeados. No entanto, eles\n"
"implementam os _traits_ especiais [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) e\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html):"

#: src/generics/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}"
msgstr ""
"```rust,editable\n"
"fn aplicar_com_registro(funcao: impl FnOnce(i32) -> i32, entrada: i32) -> i32 {\n"
"    println!(\"Chamando a fun√ß√£o com {entrada}\");\n"
"    funcao(entrada)\n"
"}"

#: src/generics/closures.md:14
msgid ""
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;"
msgstr ""
"fn main() {\n"
"    let soma_3 = |x| x + 3;\n"
"    let multiplica_5 = |x| x * 5;"

#: src/generics/closures.md:18
msgid ""
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""
"    println!(\"soma_3: {}\", aplicar_com_registro(soma_3, 10));\n"
"    println!(\"multiplica_5: {}\", aplicar_com_registro(multiplica_5, 20));\n"
"}\n"
"```"

#: src/generics/closures.md:25
msgid "If you have an `FnOnce`, you may only call it once. It might consume captured values."
msgstr "Se voc√™ tiver um `FnOnce`, poder√° cham√°-lo apenas uma vez. Pode consumir os valores capturados."

#: src/generics/closures.md:27
msgid "An `FnMut` might mutate captured values, so you can call it multiple times but not concurrently."
msgstr "Um `FnMut` pode alterar os valores capturados, ent√£o voc√™ pode cham√°-lo v√°rias vezes, mas n√£o simultaneamente."

#: src/generics/closures.md:29
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures nothing at all, so it can\n"
"be called multiple times concurrently."
msgstr ""
"Um `Fn` n√£o consome nem muda os valores capturados ou talvez n√£o capture nada, ent√£o, pode\n"
"ser chamado v√°rias vezes simultaneamente."

#: src/generics/closures.md:32
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever an `FnMut` or `FnOnce`\n"
"is called for."
msgstr ""
"`FnMut` √© um subtipo de `FnOnce`. `Fn` √© um subtipo de `FnMut` e `FnOnce`. Ou seja voc√™ pode usar um\n"
"`FnMut` sempre que um `FnOnce` √© chamado e voc√™ pode usar um `Fn` sempre que um `FnMut` ou um `FnOnce`\n"
"√© chamado."

#: src/generics/closures.md:36
msgid "`move` closures only implement `FnOnce`."
msgstr "_Closures_ `move` implementam apenas `FnOnce`."

#: src/generics/monomorphization.md:1
msgid "# Monomorphization"
msgstr "# Monomorfiza√ß√£o"

#: src/generics/monomorphization.md:3
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr "O c√≥digo _gen√©rico_ √© transformado em c√≥digo _n√£o gen√©rico_ de acordo com os tipos usados:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let inteiro = Some(5);\n"
"    let real = Some(5.0);\n"
"}\n"
"```"

#: src/generics/monomorphization.md:12
msgid "behaves as if you wrote"
msgstr "se comporta como se voc√™ tivesse escrito"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}"
msgstr ""
"```rust, editable\n"
"enum Option_i32 {\n"
"    Some (i32),\n"
"    None,\n"
"}"

#: src/generics/monomorphization.md:20
msgid ""
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}"
msgstr ""
"enum Option_f64 {\n"
"    Some (f64),\n"
"    None,\n"
"}"

#: src/generics/monomorphization.md:25
msgid ""
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let inteiro = Option_i32::Some(5);\n"
"    let real = Option_f64::Some(5.0);\n"
"}\n"
"```"

#: src/generics/monomorphization.md:31
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"Esta √© uma abstra√ß√£o de custo zero: voc√™ obt√©m exatamente o mesmo resultado como se tivesse\n"
"codificado manualmente as estruturas de dados sem utilizar a abstra√ß√£o."

#: src/generics/trait-objects.md:1
msgid "# Trait Objects"
msgstr "# Objetos `trait`"

#: src/generics/trait-objects.md:3
msgid "We've seen how a function can take arguments which implement a trait:"
msgstr "Vimos como uma fun√ß√£o pode receber argumentos que implementam um `trait` :"

#: src/generics/trait-objects.md:8
msgid ""
"fn print<T: Display>(x: T) {\n"
"    println!(\"Your value: {x}\");\n"
"}"
msgstr ""
"fn print<T: Display>(x: T) {\n"
"    println!(\"Seu valor: {}\", x);\n"
"}"

#: src/generics/trait-objects.md:12
msgid ""
"fn main() {\n"
"    print(123);\n"
"    print(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    print(123);\n"
"    print(\"Ol√°\");\n"
"}\n"
"```"

#: src/generics/trait-objects.md:18
msgid "However, how can we store a collection of mixed types which implement `Display`?"
msgstr "No entanto, como podemos armazenar uma cole√ß√£o de tipos mistos que implementam `Display`?"

#: src/generics/trait-objects.md:20
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Hello\"];\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Ol√°\"];\n"
"}\n"
"```"

#: src/generics/trait-objects.md:26
msgid "For this, we need _trait objects_:"
msgstr "Para isso, precisamos de objetos de _traits_:"

#: src/generics/trait-objects.md:31
msgid ""
"fn main() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), Box::new(\"Hello\")];\n"
"    for x in xs {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), Box::new(\"Ol√°\")];\n"
"    for x in xs {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"

#: src/generics/trait-objects.md:39
msgid "Memory layout after allocating `xs`:"
msgstr "Layout da mem√≥ria ap√≥s alocar `xs`:"

#: src/generics/trait-objects.md:41
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                               :\n"
":    xs                     :     :                                               :\n"
":   +-----------+-------+   :     :   +-----+-----+                               :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                               :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                               :\n"
":   | capacity  |     2 |   :     :     | |   | |   +----+----+----+----+----+    :\n"
":   +-----------+-------+   :     :     | |   | '-->| H  | e  | l  | l  | o  |    :\n"
":                           :     :     | |   |     +----+----+----+----+----+    :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                   :\n"
"                                  :     | |   |     +-------------------------+   :\n"
"                                  :     | |   '---->|\"<str as Display>::fmt\"|   :\n"
"                                  :     | |         +-------------------------+   :\n"
"                                  :     | |                                       :\n"
"                                  :     | |   +----+----+----+----+               :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |               :\n"
"                                  :     |     +----+----+----+----+               :\n"
"                                  :     |                                         :\n"
"                                  :     |     +-------------------------+         :\n"
"                                  :     '---->|\"<i32 as Display>::fmt\"|         :\n"
"                                  :           +-------------------------+         :\n"
"                                  :                                               :\n"
"                                  :                                               :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                               :\n"
":    xs                     :     :                                               :\n"
":   +------------+-------+  :     :   +-----+-----+                               :\n"
":   | ponteir    |   o---+--+-----+-->| o o | o o |                               :\n"
":   | tamanho    |     2 |  :     :   +-|-|-+-|-|-+                               :\n"
":   | capacidade |     2 |  :     :     | |   | |   +----+----+----+              :\n"
":   +------------+-------+  :     :     | |   | '-->| O  | l  | √°  |              :\n"
":                           :     :     | |   |     +----+----+----+              :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                   :\n"
"                                  :     | |   |     +-------------------------+   :\n"
"                                  :     | |   '---->|\"<str as Display>::fmt\"|   :\n"
"                                  :     | |         +-------------------------+   :\n"
"                                  :     | |                                       :\n"
"                                  :     | |   +----+----+----+----+               :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |               :\n"
"                                  :     |     +----+----+----+----+               :\n"
"                                  :     |                                         :\n"
"                                  :     |     +-------------------------+         :\n"
"                                  :     '---->|\"<i32 as Display>::fmt\"|         :\n"
"                                  :           +-------------------------+         :\n"
"                                  :                                               :\n"
"                                  :                                               :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/generics/trait-objects.md:69
msgid ""
"Similarly, you need a trait object if you want to return different types\n"
"implementing a trait:"
msgstr ""
"Da mesma forma, voc√™ precisa de um objeto de _traits_ se quiser retornar valores diferentes\n"
"implementando um `trait`:"

#: src/generics/trait-objects.md:72
msgid ""
"```rust,editable\n"
"fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}"
msgstr ""
"```rust,editable\n"
"fn numeros(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}"

#: src/generics/trait-objects.md:81
msgid ""
"fn main() {\n"
"    println!(\"{:?}\", numbers(-5).collect::<Vec<_>>());\n"
"    println!(\"{:?}\", numbers(5).collect::<Vec<_>>());\n"
"}"
msgstr ""
"fn main() {\n"
"    println!(\"{:?}\", numeros(-5).collect::<Vec<_>>());\n"
"    println!(\"{:?}\", numeros(5).collect::<Vec<_>>());\n"
"}"

#: src/exercises/day-3/morning.md:1
msgid "# Day 3: Morning Exercises"
msgstr "# Dia 3: Exerc√≠cios matinais"

#: src/exercises/day-3/morning.md:3
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Vamos projetar uma biblioteca cl√°ssica de _traits_ de GUI e objetos de `trait`."

#: src/exercises/day-3/simple-gui.md:1
msgid "# A Simple GUI Library"
msgstr "# Uma biblioteca GUI simples"

#: src/exercises/day-3/simple-gui.md:3
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"Vamos projetar uma biblioteca GUI cl√°ssica usando nosso novo conhecimento de _traits_ e\n"
"objetos de `trait`."

#: src/exercises/day-3/simple-gui.md:6
msgid "We will have a number of widgets in our library:"
msgstr "Teremos v√°rios _widgets_ em nossa biblioteca:"

#: src/exercises/day-3/simple-gui.md:8
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Window`: tem um `t√≠tulo` e cont√©m outros _widgets_.\n"
"* `Button`: tem um `r√≥tulo` e uma fun√ß√£o de _callback_ que √© invocada quando o\n"
"  bot√£o √© pressionado.\n"
"* `Label`: tem um `r√≥tulo`."

#: src/exercises/day-3/simple-gui.md:13
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Os _widgets_ ir√£o implementar o `trait` `Widget`, veja abaixo."

#: src/exercises/day-3/simple-gui.md:15
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/>, codifique os\n"
"m√©todos `draw_into` para que voc√™ implemente o `trait` `Widget`:"

#: src/exercises/day-3/simple-gui.md:18 src/exercises/day-3/safe-ffi-wrapper.md:25
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"
msgstr ""
"```rust,should_panic\n"
"// TODO: remova isso quando terminar sua implementa√ß√£o.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"

#: src/exercises/day-3/simple-gui.md:22
msgid ""
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""
"pub trait Widget {\n"
"    /// Largura natural de `self`.\n"
"    fn width(&self) -> usize;"

#: src/exercises/day-3/simple-gui.md:26 src/exercises/day-3/solutions-morning.md:27
msgid ""
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"
msgstr ""
"    /// Desenha o widget em um buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"

#: src/exercises/day-3/simple-gui.md:29 src/exercises/day-3/solutions-morning.md:30
msgid ""
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}"
msgstr ""
"    /// Desenha o widget na sa√≠da padr√£o.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{}\", &buffer);\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:37 src/exercises/day-3/solutions-morning.md:38
msgid ""
"pub struct Label {\n"
"    label: String,\n"
"}"
msgstr ""
"pub struct Label {\n"
"    label: String,\n"
"}"

#: src/exercises/day-3/simple-gui.md:41 src/exercises/day-3/solutions-morning.md:42
msgid ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:49 src/exercises/day-3/solutions-morning.md:50
msgid ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"
msgstr ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"

#: src/exercises/day-3/simple-gui.md:54 src/exercises/day-3/solutions-morning.md:55
msgid ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:63 src/exercises/day-3/solutions-morning.md:64
msgid ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"
msgstr ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"

#: src/exercises/day-3/simple-gui.md:68 src/exercises/day-3/solutions-morning.md:69
msgid ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"
msgstr ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"

#: src/exercises/day-3/simple-gui.md:76 src/exercises/day-3/solutions-morning.md:77
msgid ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"
msgstr ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:82
msgid ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:87 src/exercises/day-3/simple-gui.md:97 src/exercises/day-3/simple-gui.md:107
msgid ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/simple-gui.md:92
msgid ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:102
msgid ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"

#: src/exercises/day-3/simple-gui.md:112
msgid ""
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"Esta √© uma pequena demonstra√ß√£o de GUI de texto.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Clique em mim!\",\n"
"        Box::new(|| println!(\"Voc√™ clicou no bot√£o!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:123
msgid "The output of the above program can be something simple like this:"
msgstr "A sa√≠da do programa acima pode ser algo simples como:"

#: src/exercises/day-3/simple-gui.md:125
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========"
msgstr ""
"```texto\n"
"========\n"
"Demonstra√ß√£o da GUI do Rust 1.23\n"
"========"

#: src/exercises/day-3/simple-gui.md:130
msgid "This is a small text GUI demo."
msgstr "Esta √© uma pequena demonstra√ß√£o de GUI de texto."

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"| Click me! |\n"
"```"
msgstr ""
"| Clique-me! |\n"
"```"

#: src/exercises/day-3/simple-gui.md:135
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"Se voc√™ quiser desenhar texto alinhado, voc√™ pode usar os\n"
"operadores de formata√ß√£o [fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment).\n"
"Em particular, observe como voc√™ pode preencher com diferentes\n"
"caracteres (aqui um `'/'`) e como voc√™ pode controlar o alinhamento:"

#: src/exercises/day-3/simple-gui.md:140
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let largura = 10;\n"
"    println!(\"alinhado √† esquerda: |{:/<largura$}|\", \"foo\");\n"
"    println!(\"centralizado: |{:/^largura$}|\", \"foo\");\n"
"    println!(\"alinhado √† direita: |{:/>largura$}|\", \"foo\");\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:149
msgid "Using such alignment tricks, you can for example produce output like this:"
msgstr "Usando esses truques de alinhamento, voc√™ pode, por exemplo, produzir uma sa√≠da como esta:"

#: src/exercises/day-3/simple-gui.md:151
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""
"```texto\n"
"+--------------------------------------------------+\n"
"|            Rust GUI Demonstra√ß√£o 1.23            |\n"
"+==================================================+\n"
"| Esta √© uma pequena demonstra√ß√£o de GUI de texto. |\n"
"| +----------------+                               |\n"
"| |   Clique-me!   |                               |\n"
"| +----------------+                               |\n"
"+--------------------------------------------------+\n"
"```"

#: src/error-handling.md:1
msgid "# Error Handling"
msgstr "# Manipula√ß√£o de erros"

#: src/error-handling.md:3
msgid "Error handling in Rust is done using explicit control flow:"
msgstr "O tratamento de erros em Rust √© feito usando o fluxo de controle expl√≠cito:"

#: src/error-handling.md:5
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* As fun√ß√µes que podem ter erros mostram isso em seu tipo de retorno.\n"
"* N√£o h√° exce√ß√µes."

#: src/error-handling/panics.md:1
msgid "# Panics"
msgstr "# Panics (P√¢nico)"

#: src/error-handling/panics.md:3
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "O Rust disparar√° um _panic_ (p√¢nico) se um erro fatal ocorrer em tempo de execu√ß√£o:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"

#: src/error-handling/panics.md:12
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* _P√¢nicos_ s√£o para erros irrecuper√°veis e inesperados.\n"
"  * P√¢nicos s√£o sintomas de bugs no programa.\n"
"* Use APIs que n√£o disparam erros do tipo _p√¢nico_ (como `Vec::get`) se travar o programa n√£o for aceit√°vel."

#: src/error-handling/panic-unwind.md:1
msgid "# Catching the Stack Unwinding"
msgstr "# Capturando o desenrolar da pilha"

#: src/error-handling/panic-unwind.md:3
msgid "By default, a panic will cause the stack to unwind. The unwinding can be caught:"
msgstr "Por padr√£o, um p√¢nico far√° com que a pilha se desenrole. O desenrolamento pode ser capturado:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust\n"
"use std::panic;"
msgstr ""
"```rust\n"
"use std::panic;"

#: src/error-handling/panic-unwind.md:8
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hello!\");\n"
"});\n"
"assert!(result.is_ok());"
msgstr ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"Ol√°!\");\n"
"});\n"
"assert!(result.is_ok());"

#: src/error-handling/panic-unwind.md:13
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh no!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"
msgstr ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh n√£o!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"

#: src/error-handling/panic-unwind.md:19
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* Isso pode ser √∫til em servidores que devem continuar rodando mesmo se uma\n"
"  requisi√ß√£o tenha falhado.\n"
"* Isso n√£o funciona se `panic = 'abort'` estiver definido em seu `Cargo.toml`."

#: src/error-handling/result.md:1
msgid "# Structured Error Handling with `Result`"
msgstr "# Tratamento estruturado de erros com `Result`"

#: src/error-handling/result.md:3
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors are\n"
"expected as part of normal operation:"
msgstr ""
"J√° vimos o _Enum_ `Result`. Ele √© usado amplamente quando os erros s√£o\n"
"esperados como parte da opera√ß√£o normal:"

#: src/error-handling/result.md:6
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"
msgstr ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"

#: src/error-handling/result.md:10
msgid ""
"fn main() {\n"
"    let file = File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let arquivo = File::open(\"diario.txt\");\n"
"    match arquivo {\n"
"        Ok(mut arquivo) => {\n"
"            let mut conteudo = String::new();\n"
"            arquivo.read_to_string(&mut conteudo);\n"
"            println!(\"Querido di√°rio: {conteudo}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"N√£o foi poss√≠vel abrir o di√°rio: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/result.md:27
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where an error should never happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but it is worth mentioning. \n"
"    It contains a lot of convenience methods and functions that help functional-style programming. \n"
"    \n"
"</details>"
msgstr ""
"  * Como em `Option`, o valor bem-sucedido fica dentro de `Result`, for√ßando o desenvolvedor a\n"
"    extra√≠-lo explicitamente. Isso encoraja a verifica√ß√£o de erros. No caso em que um erro nunca deve acontecer,\n"
"    `unwrap()` ou `expect()` podem ser chamados, e isso sinaliza a inten√ß√£o do desenvolvedor.\n"
"  * A documenta√ß√£o de `Result` √© uma leitura recomendada. N√£o durante o curso, mas vale a pena mencion√°-la.\n"
"    Ele cont√©m muitos m√©todos e fun√ß√µes de conveni√™ncia que ajudam na programa√ß√£o ao estilo funcional.\n"
"    \n"
"</details>"

#: src/error-handling/try-operator.md:1
msgid "# Propagating Errors with `?`"
msgstr "# Propagando erros com `?`"

#: src/error-handling/try-operator.md:3
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you turn\n"
"the common"
msgstr ""
"O operador _try_ `?` √© usado para retornar erros ao chamador da fun√ß√£o.\n"
"Se ocorrer um erro, este √© retornado imediatamente ao chamador como retorno da fun√ß√£o."

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""
"```rust, ignore\n"
"match alguma_expressao {\n"
"    Ok(valor) => valor,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:13
msgid "into the much simpler"
msgstr "Pode ser simplificado por:"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""
"```rust, ignore\n"
"alguma_expressao?\n"
"```"

#: src/error-handling/try-operator.md:19
msgid "We can use this to simplify our error handing code:"
msgstr "Podemos usar isso para simplificar nosso c√≥digo de tratamento de erros:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"
msgstr ""
"```rust, editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"

#: src/error-handling/try-operator.md:25
msgid ""
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);"
msgstr ""
"fn ler_nome_usuario(caminho: &str) -> Result<String, io::Error> {\n"
"    let arquivo_nome_usuario_result = fs::File::open(caminho);"

#: src/error-handling/try-operator.md:28
msgid ""
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };"
msgstr ""
"    let mut arquivo_nome_usuario = match arquivo_nome_usuario_result {\n"
"        Ok(arquivo) => arquivo,\n"
"        Err(e) => return Err(e),\n"
"    };"

#: src/error-handling/try-operator.md:33
msgid "    let mut username = String::new();"
msgstr "    let mut nome_usuario = String::new();"

#: src/error-handling/try-operator.md:35
msgid ""
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"
msgstr ""
"    match arquivo_nome_usuario.read_to_string(&mut nome_usuario) {\n"
"        Ok(_) => Ok(nome_usuario),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"

#: src/error-handling/try-operator.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let nome_usuario = ler_nome_usuario(\"config.dat\");\n"
"    println!(\"Nome de usu√°rio ou erro: {nome_usuario:?}\");\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:52 src/error-handling/converting-error-types-example.md:52
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, empty file, file with username."
msgstr ""
"* A vari√°vel `nome_usuario` pode ser `Ok(string)` ou `Err(error)`.\n"
"* Use a chamada `fs::write` para testar os diferentes cen√°rios: nenhum arquivo, arquivo vazio e arquivo com name de usu√°rio."

#: src/error-handling/converting-error-types.md:1 src/error-handling/converting-error-types-example.md:1
msgid "# Converting Error Types"
msgstr "# Convertendo Tipos de Erro"

#: src/error-handling/converting-error-types.md:3
msgid "The effective expansion of `?` is a little more complicated than previously indicated:"
msgstr "A efetiva expans√£o do operador `?` √© um pouco mais complicada do que indicado anteriormente:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""
"```rust,ignore\n"
"expressao?\n"
"```"

#: src/error-handling/converting-error-types.md:9
msgid "works the same as"
msgstr "funciona da mesma forma que"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"match expressao {\n"
"    Ok(valor) => valor,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"

#: src/error-handling/converting-error-types.md:18
msgid ""
"The `From::from` call here means we attempt to convert the error type to the\n"
"type returned by the function:"
msgstr ""
"A chamada `From::from` aqui significa que tentamos converter o tipo de erro para o\n"
"tipo retornado pela fun√ß√£o:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};"
msgstr ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};"

#: src/error-handling/converting-error-types-example.md:9
msgid ""
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"enum LerNomeUsuarioError {\n"
"    IoError(io::Error),\n"
"    NomeUsuarioVazio(String),\n"
"}"

#: src/error-handling/converting-error-types-example.md:15
msgid "impl Error for ReadUsernameError {}"
msgstr "impl Error for LerNomeUsuarioError {}"

#: src/error-handling/converting-error-types-example.md:17
msgid ""
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {}\", e),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username in {}\", filename),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Display for LerNomeUsuarioError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"Erro de E/S: {}\", e),\n"
"            Self::NomeUsuarioVazio(arquivo) => write!(f, \"N√£o foi encontrado nome de usu√°rio em {}\", arquivo),\n"
"        }\n"
"    }\n"
"}"

#: src/error-handling/converting-error-types-example.md:26
msgid ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"
msgstr ""
"impl From<io::Error> for LerNomeUsuarioError {\n"
"    fn from(err: io::Error) -> LerNomeUsuarioError {\n"
"        LerNomeUsuarioError::IoError(err)\n"
"    }\n"
"}"

#: src/error-handling/converting-error-types-example.md:32
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn ler_nome_usuario(caminho: &str) -> Result<String, LerNomeUsuarioError> {\n"
"    let mut nome_usuario = String::with_capacity(100);\n"
"    File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
"    if nome_usuario.is_empty() {\n"
"        return Err(LerNomeUsuarioError::NomeUsuarioVazio(String::from(caminho)));\n"
"    }\n"
"    Ok(nome_usuario)\n"
"}"

#: src/error-handling/converting-error-types-example.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let nome_usuario = ler_nome_usuario(\"config.dat\");\n"
"    println!(\"Nome de usu√°rio ou erro: {nome_usuario:?}\");\n"
"}\n"
"```"

#: src/error-handling/converting-error-types-example.md:55
msgid ""
"It is good practice for all error types to implement `std::error::Error`, which requires `Debug` and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too where possible, to make\n"
"life easier for tests and consumers of your library. In this case we can't easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"√â uma boa pr√°tica para todos os tipos de erro implementar `std::error::Error`, que requer `Debug` e\n"
"`Display`. Geralmente √© √∫til para eles implementar `Clone` e `Eq` tamb√©m quando poss√≠vel, para tornar\n"
"mais f√°cil a vida ao testar e consumidor sua biblioteca. Neste caso, n√£o podemos faz√™-lo facilmente, porque\n"
"`io::Error` n√£o os implementa."

#: src/error-handling/deriving-error-enums.md:1
msgid "# Deriving Error Enums"
msgstr "# Derivando _Enums_ de erro"

#: src/error-handling/deriving-error-enums.md:3
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create an\n"
"error enum like we did on the previous page:"
msgstr ""
"O _crate_ [thiserror](https://docs.rs/thiserror/) √© uma maneira popular de criar um\n"
"tipo enumerado (enum) de erro, como fizemos na p√°gina anterior:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;"

#: src/error-handling/deriving-error-enums.md:11
msgid ""
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""
"#[derive(Debug, Error)]\n"
"enum LerNomeUsuarioError {\n"
"    #[error(\"N√£o foi poss√≠vel ler: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"N√£o foi encontrado o nome do usu√°rio em {0}\")]\n"
"    NomeUsuarioVazio(String),\n"
"}"

#: src/error-handling/deriving-error-enums.md:19
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn ler_nome_usuario(caminho: &str) -> Result<String, LerNomeUsuarioError> {\n"
"    let mut nome_usuario = String::with_capacity(100);\n"
"    fs::File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
"    if nome_usuario.is_empty() {\n"
"        return Err(LerNomeUsuarioError::NomeUsuarioVazio(String::from(caminho)));\n"
"    }\n"
"    Ok(nome_usuario)\n"
"}"

#: src/error-handling/deriving-error-enums.md:28 src/error-handling/dynamic-errors.md:25
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match ler_nome_usuario(\"config.dat\") {\n"
"        Ok(nome_usuario) => println!(\"Nome de usu√°rio: {nome_usuario}\"),\n"
"        Err(err) => println!(\"Erro: {err}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/deriving-error-enums.md:39
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the `#[from]` attribute is added).\n"
"It also works for structs."
msgstr ""
"A macro `thiserror` implementa automaticamente `std::error::Error`, e opcionalmente, `Display`\n"
"(se os atributos `#[error(...)]` forem fornecidos) e `From` (se o atributo `#[from]` for adicionado).\n"
"Tamb√©m funciona para estruturas."

#: src/error-handling/deriving-error-enums.md:43
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "N√£o afeta sua API p√∫blica, o que a torna boa para bibliotecas."

#: src/error-handling/dynamic-errors.md:1
msgid "# Dynamic Error Types"
msgstr "# Tipos de erros din√¢micos"

#: src/error-handling/dynamic-errors.md:3
msgid ""
"Sometimes we want to allow any type of error to be returned without writing our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"√Äs vezes, queremos permitir que qualquer tipo de erro seja retornado sem escrever nosso pr√≥prio `Enum`\n"
"abrangendo todas as diferentes possibilidades. `std::error::Error` torna isso f√°cil."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;"

#: src/error-handling/dynamic-errors.md:12
msgid ""
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);"
msgstr ""
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Nome de usu√°rio n√£o encontrado em {0}\")]\n"
"struct NomeUsuarioVazioError(String);"

#: src/error-handling/dynamic-errors.md:16
msgid ""
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn ler_nome_usuario(caminho: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut nome_usuario = String::with_capacity(100);\n"
"    File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
"    if nome_usuario.is_empty() {\n"
"        return Err(NomeUsuarioVazioError(String::from(caminho)).into());\n"
"    }\n"
"    Ok (nome_usuario)\n"
"}"

#: src/error-handling/dynamic-errors.md:36
msgid ""
"This saves on code, but gives up the ability to cleanly handle different error cases differently in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` in the public API of a\n"
"library, but it can be a good option in a program where you just want to display the error message\n"
"somewhere."
msgstr ""
"Isso economiza c√≥digo, mas abre m√£o da capacidade de lidar com diferentes casos de erro de maneira diferenciada no\n"
"programa. Como tal, geralmente n√£o √© uma boa ideia usar `Box<dyn Error>` na API p√∫blica de uma\n"
"biblioteca, mas pode ser uma boa op√ß√£o em um programa onde voc√™ deseja apenas exibir a mensagem de erro\n"
"em algum lugar."

#: src/error-handling/error-contexts.md:1
msgid "# Adding Context to Errors"
msgstr "# Adicionando contexto aos erros"

#: src/error-handling/error-contexts.md:3
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"O `crate` [anyhow](https://docs.rs/anyhow/) √© amplamente usado pode ajud√°-lo a adicionar\n"
"informa√ß√µes contextuais aos seus erros permitindo que voc√™ tenha menos\n"
"tipos de erros personalizados:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"

#: src/error-handling/error-contexts.md:12
msgid ""
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .context(format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""
"fn ler_nome_usuario(caminho: &str) -> Result<String> {\n"
"    let mut nome_usuario = String::with_capacity(100);\n"
"    fs::File::open(caminho)\n"
"        .context(format!(\"Falha ao abrir {caminho}\"))?\n"
"        .read_to_string(&mut nome_usuario)\n"
"        .context(\"Falha ao ler\")?;\n"
"    if nome_usuario.is_empty() {\n"
"        bail!(\"N√£o foi encontrado nenhum nome de usu√°rio em {caminho}\");\n"
"    }\n"
"    Ok (nome_usuario)\n"
"}"

#: src/error-handling/error-contexts.md:24
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match ler_nome_usuario(\"config.dat\") {\n"
"        Ok(nome_usuario) => println!(\"Nome de usu√°rio: {nome_usuario}\"),\n"
"        Err(err) => println!(\"Erro: {err:?}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/error-contexts.md:35
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such it's again generally not\n"
"  a good choice for the public API of a library, but is widely used in applications.\n"
"* Actual error type inside of it can be extracted for examination if necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* `anyhow::Result<V>` √© um apelido de tipo para `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` √© essencialmente um wrapper em torno de `Box<dyn Error>`. Como tal, geralmente n√£o √©\n"
"  uma boa escolha para a API p√∫blica de uma biblioteca, mas √© amplamente utilizado em aplica√ß√µes.\n"
"* O tipo de erro real dentro dele pode ser extra√≠do para exame, se necess√°rio.\n"
"* A funcionalidade fornecida por `anyhow::Result<T>` pode ser familiar para desenvolvedores Go, pois fornece\n"
"  padr√µes de uso e ergonomia semelhantes a `(T, error)` de Go."

#: src/testing.md:1
msgid "# Testing"
msgstr "# Teste"

#: src/testing.md:3
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust e Cargo v√™m com uma estrutura de testes unit√°rios simples:"

#: src/testing.md:5
msgid "* Unit tests are supported throughout your code."
msgstr "* Os testes unit√°rios s√£o suportados em todo o seu c√≥digo."

#: src/testing.md:7
msgid "* Integration tests are supported via the `tests/` directory."
msgstr "* Testes de integra√ß√£o s√£o suportados atrav√©s do diret√≥rio `tests/`."

#: src/testing/unit-tests.md:1
msgid "# Unit Tests"
msgstr "# Testes unit√°rios"

#: src/testing/unit-tests.md:3
msgid "Mark unit tests with `#[test]`:"
msgstr "Marque os testes unit√°rios com `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}"
msgstr ""
"```rust,editable\n"
"fn primeira_palavra(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}"

#: src/testing/unit-tests.md:13
msgid ""
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}"
msgstr ""
"#[test]\n"
"fn teste_vazio() {\n"
"    assert_eq!(primeira_palavra(\"\"), \"\");\n"
"}"

#: src/testing/unit-tests.md:18
msgid ""
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}"
msgstr ""
"#[test]\n"
"fn test_uma_palavra() {\n"
"    assert_eq!(primeira_palavra(\"Ol√°\"), \"Ol√°\");\n"
"}"

#: src/testing/unit-tests.md:23
msgid ""
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""
"#[test]\n"
"fn test_multiplas_palavras() {\n"
"    assert_eq!(primeira_palavra(\"Ol√° Mundo\"), \"Ol√°\");\n"
"}\n"
"```"

#: src/testing/unit-tests.md:29
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Use `cargo test` para encontrar e executar os testes unit√°rios."

#: src/testing/test-modules.md:1
msgid "# Test Modules"
msgstr "# M√≥dulos de teste"

#: src/testing/test-modules.md:3
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"Os testes unit√°rios geralmente s√£o colocados em um m√≥dulo aninhado (executar testes no\n"
"[Playground](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}"
msgstr ""
"```rust, editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}"

#: src/testing/test-modules.md:11
msgid ""
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}"
msgstr ""
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Ol√°\", \"Mundo\"));\n"
"}"

#: src/testing/test-modules.md:19
msgid ""
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"

#: src/testing/test-modules.md:26
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* Isso permite que voc√™ tenha testes unit√°rios auxiliares e privados.\n"
"* O atributo `#[cfg(test)]` s√≥ fica ativo quando voc√™ executa `cargo test`."

#: src/testing/doc-tests.md:1
msgid "# Documentation Tests"
msgstr "# Testes de Documenta√ß√£o"

#: src/testing/doc-tests.md:3
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust tem suporte embutido para testes de documenta√ß√£o:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// Encurta uma string para o comprimento especificado.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Ol√° Mundo\", 20), \"Ol√° Mundo\");\n"
"/// ```\n"
"pub fn short_string(s: &str, comprimento: usize) -> &str {\n"
"    &s[..std::cmp::min(comprimento, s.len())]\n"
"}\n"
"```"

#: src/testing/doc-tests.md:18
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* Blocos de c√≥digo em coment√°rios `///` s√£o vistos automaticamente como c√≥digo Rust.\n"
"* O c√≥digo ser√° compilado e executado como parte do `cargo test`.\n"
"* Teste o c√≥digo acima no [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:1
msgid "# Integration Tests"
msgstr "# Testes de Integra√ß√£o"

#: src/testing/integration-tests.md:3
msgid "If you want to test your library as a client, use an integration test."
msgstr "Se quiser testar sua biblioteca como cliente, use um teste de integra√ß√£o."

#: src/testing/integration-tests.md:5
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crie um arquivo `.rs` em `tests/`:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;"
msgstr ""
"```rust, ignore\n"
"use minha_biblioteca::init;"

#: src/testing/integration-tests.md:10
msgid ""
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"

#: src/testing/integration-tests.md:16
msgid "These tests only have access to the public API of your crate."
msgstr "Esses testes s√≥ t√™m acesso √† API p√∫blica do seu `crate`."

#: src/unsafe.md:1
msgid "# Unsafe Rust"
msgstr "# Rust inseguro (unsafe)"

#: src/unsafe.md:3
msgid "The Rust language has two parts:"
msgstr "A linguagem Rust tem duas partes:"

#: src/unsafe.md:5
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are violated."
msgstr ""
"* **Safe Rust:** mem√≥ria segura, nenhum comportamento indefinido √© poss√≠vel.\n"
"* **Insafe Rust:** pode desencadear um comportamento indefinido se as pr√©-condi√ß√µes forem violadas."

#: src/unsafe.md:8
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to know\n"
"what Unsafe Rust is."
msgstr ""
"Veremos principalmente Rust seguro neste curso, mas √© importante saber\n"
"o que √© Rust inseguro (_unsafe_)."

#: src/unsafe.md:11
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"C√≥digo inseguro √© geralmente pequeno e isolado, e sua corre√ß√£o deve ser cuidadosamente\n"
"documentada. Geralmente √© envolto em uma camada de abstra√ß√£o segura."

#: src/unsafe.md:14
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "O c√≥digo inseguro do Rust oferece acesso a cinco novos recursos:"

#: src/unsafe.md:16
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* Desreferenciar ponteiros brutos.\n"
"* Acessar ou modificar vari√°veis est√°ticas mut√°veis.\n"
"* Acessar os campos de uma `union`.\n"
"* Chamar fun√ß√µes inseguras (`unsafe`), incluindo fun√ß√µes `externas`.\n"
"* Implementar traits inseguros (`unsafe`)."

#: src/unsafe.md:22
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see\n"
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"A seguir, abordaremos brevemente os recursos inseguros. Para detalhes completos, consulte o\n"
"[Cap√≠tulo 19.1 no Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"e o [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety rules."
msgstr ""
"Rust inseguro n√£o significa que o c√≥digo est√° incorreto. Significa que os desenvolvedores\n"
"desligaram os recursos de seguran√ßa do compilador e tem que escrever o c√≥digo corretamente\n"
"eles mesmos. Significa tamb√©m que o compilador n√£o imp√µe mais as regras de seguran√ßa de mem√≥ria do Rust."

#: src/unsafe/raw-pointers.md:1
msgid "# Dereferencing Raw Pointers"
msgstr "# Desreferenciando ponteiros brutos"

#: src/unsafe/raw-pointers.md:3
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "Criar ponteiros √© seguro, mas desreferenci√°-los requer `unsafe`:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut num = 5;"

#: src/unsafe/raw-pointers.md:9
msgid ""
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = &num as *const i32;"
msgstr ""
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = &num as *const i32;"

#: src/unsafe/raw-pointers.md:12
msgid ""
"    // Safe because r1 and r2 were obtained from references and so are guaranteed to be non-null and\n"
"    // properly aligned, the objects underlying the references from which they were obtained are\n"
"    // live throughout the whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    // Seguro porque r1 e r2 foram obtidos de refer√™ncias e, portanto, s√£o garantidos como n√£o nulos e\n"
"    // devidamente alinhados, os objetos subjacentes √†s refer√™ncias das quais foram obtidos\n"
"    // vivem em todo o bloco inseguro e n√£o s√£o acessados nem por meio de\n"
"    // refer√™ncias ou simultaneamente por meio de quaisquer outros ponteiros.\n"
"    unsafe {\n"
"        println!(\"r1 √©: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 √©: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/raw-pointers.md:26
msgid ""
"It is good practice (and required by the Android Rust style guide) to write a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"√â uma boa pr√°tica (e exigida pelo guia de estilo do Android Rust) escrever um coment√°rio para cada\n"
"bloco `unsafe` explicando como o c√≥digo dentro dele satisfaz os requisitos de seguran√ßa para a\n"
"opera√ß√£o insegura que est√° fazendo."

#: src/unsafe/raw-pointers.md:30
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"No caso de desrefer√™ncia de ponteiros, isso significa que os ponteiros devem ser\n"
"[_v√°lidos_](https://doc.rust-lang.org/std/ptr/index.html#safety), ou seja:"

#: src/unsafe/raw-pointers.md:33
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * O ponteiro deve ser n√£o nulo.\n"
" * O ponteiro deve ser _desreferenci√°vel_ (dentro dos limites de um √∫nico objeto alocado).\n"
" * O objeto n√£o deve ter sido desalocado.\n"
" * N√£o deve haver acessos simult√¢neos ao mesmo local.\n"
" * Se o ponteiro foi obtido lan√ßando uma refer√™ncia, o objeto subjacente deve estar ativo e nenhuma\n"
"   refer√™ncia pode ser usada para acessar a mem√≥ria."

#: src/unsafe/raw-pointers.md:40
msgid "In most cases the pointer must also be properly aligned."
msgstr "Na maioria dos casos, o ponteiro tamb√©m deve estar alinhado corretamente."

#: src/unsafe/mutable-static-variables.md:1
msgid "# Mutable Static Variables"
msgstr "# Vari√°veis est√°ticas mut√°veis"

#: src/unsafe/mutable-static-variables.md:3
msgid "It is safe to read an immutable static variable:"
msgstr "√â seguro ler uma vari√°vel est√°tica imut√°vel:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";"
msgstr ""
"```rust, editable\n"
"static HELLO_WORLD: &str = \"Ol√°, mundo!\";"

#: src/unsafe/mutable-static-variables.md:8
msgid ""
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr ""
"No entanto, como podem ocorrer corridas de dados, n√£o √© seguro ler e gravar dados em\n"
"vari√°veis est√°ticas mut√°veis:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;"
msgstr ""
"```rust, editable\n"
"static mut CONTADOR: u32 = 0;"

#: src/unsafe/mutable-static-variables.md:19
msgid ""
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}"
msgstr ""
"fn add_to_counter(inc: u32) {\n"
"    unsafe { CONTADOR += inc; } // Potencial corrida de dados!\n"
"}"

#: src/unsafe/mutable-static-variables.md:23
msgid ""
"fn main() {\n"
"    add_to_counter(42);"
msgstr ""
"fn main() {\n"
"    add_to_counter(42);"

#: src/unsafe/mutable-static-variables.md:26
msgid ""
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""
"    unsafe { println!(\"CONTADOR: {}\", CONTADOR); } // Potencial corrida de dados!\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:32
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases where it might make sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working with some C APIs."
msgstr ""
"Usar uma vari√°vel est√°tica mut√°vel geralmente √© uma m√° ideia, mas h√° alguns casos em que pode fazer sentido,\n"
"em c√≥digo `no_std` de baixo n√≠vel, como implementar um alocador de heap ou trabalhar com algumas APIs C."

#: src/unsafe/unions.md:1
msgid "# Unions"
msgstr "# Unions (Uni√µes)"

#: src/unsafe/unions.md:3
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "As uni√µes `union` s√£o como enums, mas voc√™ mesmo precisa rastrear o campo ativo:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MinhaUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}"

#: src/unsafe/unions.md:12
msgid ""
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let u = MinhaUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Comportamento indefinido!\n"
"}\n"
"```"

#: src/unsafe/unions.md:21
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally needed\n"
"for interacting with C library APIs."
msgstr ""
"As uni√µes raramente s√£o necess√°rias no Rust, pois geralmente voc√™ pode usar um `enum`. Elas s√£o ocasionalmente necess√°rios\n"
"para interagir com as APIs da biblioteca C."

#: src/unsafe/unions.md:24
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"Se voc√™ deseja apenas reinterpretar os bytes como um tipo diferente, provavelmente usaria\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) ou um\n"
"wrapper seguro como o `crate` [`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:1
msgid "# Calling Unsafe Functions"
msgstr "# Chamando fun√ß√µes inseguras"

#: src/unsafe/calling-unsafe-functions.md:3
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"Uma fun√ß√£o ou m√©todo pode ser marcado como 'unsafe' se tiver pr√©-condi√ß√µes extras que voc√™\n"
"deve respeitar para evitar comportamentos indefinidos:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";"

#: src/unsafe/calling-unsafe-functions.md:10
msgid ""
"    // Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"{}\", emojis.get_unchecked(0..4));\n"
"        println!(\"{}\", emojis.get_unchecked(4..7));\n"
"        println!(\"{}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    // Seguro porque os √≠ndices est√£o na ordem correta, dentro dos limites da\n"
"    // slice da string e fica nos limites da sequ√™ncia UTF-8.\n"
"    unsafe {\n"
"        println!(\"{}\", emojis.get_unchecked(0..4));\n"
"        println!(\"{}\", emojis.get_unchecked(4..7));\n"
"        println!(\"{}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:1
msgid "# Writing Unsafe Functions"
msgstr "# Escrevendo fun√ß√µes inseguras"

#: src/unsafe/writing-unsafe-functions.md:3
msgid ""
"You can mark your own functions as `unsafe` if they require particular conditions to avoid undefined\n"
"behaviour."
msgstr ""
"Voc√™ pode marcar suas pr√≥prias fun√ß√µes como _inseguras_ se elas exigirem condi√ß√µes espec√≠ficas para evitar\n"
"comportamentos indefinidos."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}"
msgstr ""
"```rust,editable\n"
"/// Trocando os valores dos par√¢metros pode refer√™ncia usando ponteiros\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// Os ponteiros precisam ser v√°lidos e corretamente alinhados.\n"
"unsafe fn troca(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}"

#: src/unsafe/writing-unsafe-functions.md:18
msgid ""
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;"
msgstr ""
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;"

#: src/unsafe/writing-unsafe-functions.md:22
msgid ""
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }"
msgstr ""
"    // Seguro porque...\n"
"    unsafe {\n"
"        troca(&mut a, &mut b);\n"
"    }"

#: src/unsafe/writing-unsafe-functions.md:27
msgid ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:33
msgid "We wouldn't actually use pointers for this because it can be done safely with references."
msgstr "Na verdade, n√£o usar√≠amos ponteiros para isso porque isso pode ser feito com seguran√ßa usando refer√™ncias."

#: src/unsafe/writing-unsafe-functions.md:35
msgid ""
"Note that unsafe code is allowed within an unsafe function without an `unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see what happens."
msgstr ""
"Observe que o c√≥digo _inseguro_ √© permitido dentro de uma fun√ß√£o _insegura_ sem o uso de um bloco `unsafe`. Podemos\n"
"proibir isso com `#[deny(unsafe_op_in_unsafe_fn)]`. Tente adicion√°-lo e veja o que acontece."

#: src/unsafe/extern-functions.md:1
msgid "# Calling External Code"
msgstr "# Chamando c√≥digo externo"

#: src/unsafe/extern-functions.md:3
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling\n"
"them is thus unsafe:"
msgstr ""
"Fun√ß√µes de outras linguagens podem violar as garantias do Rust. Chamar\n"
"elas √©, portanto, inseguro:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}"
msgstr ""

#: src/unsafe/extern-functions.md:11
msgid ""
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    unsafe {\n"
"        // Comportamento indefinido se o abs se comportar mal.\n"
"        println!(\"Valor absoluto de -3 de acordo com C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/extern-functions.md:21
msgid ""
"This is usually only a problem for extern functions which do things with pointers which might\n"
"violate Rust's memory model, but in general any C function might have undefined behaviour under any\n"
"arbitrary circumstances."
msgstr ""
"Isso geralmente √© apenas um problema para fun√ß√µes externas que fazem coisas com ponteiros que podem\n"
"violar o modelo de mem√≥ria do Rust, mas em geral qualquer fun√ß√£o C pode ter comportamento indefinido sob quaisquer\n"
"circunst√¢ncias arbitr√°rias."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"O `\"C\"` neste exemplo √© o ABI;\n"
"[outros ABIs tamb√©m est√£o dispon√≠veis](https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe/unsafe-traits.md:1
msgid "# Implementing Unsafe Traits"
msgstr "# Implementando traits inseguros"

#: src/unsafe/unsafe-traits.md:3
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"Assim como nas fun√ß√µes, voc√™ pode marcar um `trait` como `unsafe` se a implementa√ß√£o deve garantir\n"
"condi√ß√µes particulares para evitar comportamento indefinido."

#: src/unsafe/unsafe-traits.md:6
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Por exemplo, o `crate` `zerocopy` tem uma caracter√≠stica insegura que parece\n"
"[algo assim](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;"
msgstr ""
"```rust, editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;"

#: src/unsafe/unsafe-traits.md:13
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"/// ...\n"
"/// # Safety\n"
"/// O tipo deve ter uma representa√ß√£o definida e nenhum preenchimento.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}"

#: src/unsafe/unsafe-traits.md:24
msgid ""
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""
"// Seguro porque u32 tem uma representa√ß√£o definida e nenhum preenchimento.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"

#: src/unsafe/unsafe-traits.md:30
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Deve haver uma se√ß√£o `# Safety` no Rustdoc para o `trait` explicando os requisitos para\n"
"o `trait` ser implementado com seguran√ßa."

#: src/unsafe/unsafe-traits.md:33
msgid "The actual safety section for `AsBytes` is rather longer and more complicated."
msgstr "A se√ß√£o de seguran√ßa atual para `AsBytes` √© bem mais longa e complicada."

#: src/unsafe/unsafe-traits.md:35
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Os _traits_ incorporadas `Send` e `Sync` n√£o s√£o seguros."

#: src/exercises/day-3/afternoon.md:1
msgid "# Day 3: Afternoon Exercises"
msgstr "# Dia 3: Exerc√≠cios da Tarde"

#: src/exercises/day-3/afternoon.md:3
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "Vamos construir um wrapper seguro para ler o conte√∫do do diret√≥rio!"

#: src/exercises/day-3/afternoon.md:7
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "Depois de ver o exerc√≠cio, voc√™ pode ver a [solu√ß√£o] fornecida."

#: src/exercises/day-3/afternoon.md:9
msgid "[solution]: solutions-afternoon.md"
msgstr "[solu√ß√£o]: solutions-afternoon.md"

#: src/exercises/day-3/safe-ffi-wrapper.md:1
msgid "# Safe FFI Wrapper"
msgstr "# _Wrapper_ FFI seguro"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust tem √≥timo suporte para chamar fun√ß√µes por meio de uma interface para fun√ß√µes externas (_function foreign\n"
"interface_ FFI). Usaremos isso para construir um inv√≥lucro seguro para as fun√ß√µes da `libc`\n"
"de C que voc√™ usaria para ler os nomes dos arquivos de um diret√≥rio."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
msgid "You will want to consult the manual pages:"
msgstr "Voc√™ vai querer consultar as p√°ginas do manual:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
msgid ""
"You will also want to browse the [`std::ffi`] module, particular for [`CStr`]\n"
"and [`CString`] types which are used to hold NUL-terminated strings coming from\n"
"C. The [Nomicon] also has a very useful chapter about FFI."
msgstr ""
"Voc√™ tamb√©m deve procurar o m√≥dulo [`std::ffi`], especialmente para [`CStr`]\n"
"e tipos [`CString`] que s√£o usados para armazenar strings terminadas com NULL vindas do\n"
"C. O [Nomicon] tamb√©m tem um cap√≠tulo muito √∫til sobre FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:17
msgid ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"
msgstr ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"functions and methods:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/> e implemente as\n"
"fun√ß√µes e m√©todos que faltam:"

#: src/exercises/day-3/safe-ffi-wrapper.md:29
msgid ""
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#: src/exercises/day-3/safe-ffi-wrapper.md:32 src/exercises/day-3/solutions-afternoon.md:26
msgid ""
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }"
msgstr ""
"    // Tipo opaco. Consulte https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }"

#: src/exercises/day-3/safe-ffi-wrapper.md:39 src/exercises/day-3/solutions-afternoon.md:33
msgid ""
"    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }"
msgstr ""
"    // Layout para readdir(3) e defini√ß√µes em /usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }"

#: src/exercises/day-3/safe-ffi-wrapper.md:49 src/exercises/day-3/solutions-afternoon.md:43
msgid ""
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"
msgstr ""
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:56 src/exercises/day-3/solutions-afternoon.md:50
msgid ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"
msgstr ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"

#: src/exercises/day-3/safe-ffi-wrapper.md:59
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"
msgstr ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:65
msgid ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Chama opendir e retorna um valor Ok se funcionou,\n"
"        // caso contr√°rio, retorna Err com uma mensagem.\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:73
msgid ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Continue chamando readdir at√© obter um ponteiro NULL de volta.\n"
"        unimplemented!()\n"
"    }\n"
"}"

#: src/exercises/day-3/safe-ffi-wrapper.md:81
msgid ""
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:88
msgid ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"arquivos: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"

#: src/welcome-day-4.md:1
msgid "# Welcome to Day 4"
msgstr "# Bem-vindo ao Dia 4"

#: src/welcome-day-4.md:3
msgid "Today we will look at two main topics:"
msgstr "Hoje veremos dois t√≥picos principais:"

#: src/welcome-day-4.md:5
msgid "* Concurrency: threads, channels, shared state, `Send` and `Sync`."
msgstr "* Concorr√™ncia: _threads_, _channels_, estado compartilhado, `Send` e `Sync`."

#: src/welcome-day-4.md:7
msgid ""
"* Android: building binaries and libraries, using AIDL, logging, and\n"
"  interoperability with C, C++, and Java."
msgstr ""
"* Android: construindo bin√°rios e bibliotecas, usando AIDL, log e\n"
"  interoperabilidade com C, C++ e Java."

#: src/welcome-day-4.md:10
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try to\n"
"> find a little corner of your code base where we can move some lines of code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> Tentaremos chamar Rust de um de seus pr√≥prios projetos hoje. Ent√£o tente\n"
"> encontrar um pequeno canto da sua base de c√≥digo onde podemos mover algumas linhas de c√≥digo para\n"
"> Rust. Quanto menos depend√™ncias e tipos \"ex√≥ticos\", melhor. Algo que\n"
"> analise alguns bytes brutos seria o ideal."

#: src/concurrency.md:1
msgid "# Fearless Concurrency"
msgstr "# Concorr√™ncia sem medo"

#: src/concurrency.md:3
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust tem suporte total para concorr√™ncia usando _threads_ do SO com _mutexes_ e\n"
"_channels_ (canais)."

#: src/concurrency.md:6
msgid ""
"The Rust type system plays an important role in making many concurrency bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"O sistema de tipos do Rust desempenha um papel importante na convers√£o de muitos erros de concorr√™ncia\n"
"em erros de tempo de compila√ß√£o. Isso geralmente √© chamado de _concorr√™ncia sem medo_, pois voc√™\n"
"pode confiar no compilador para garantir a exatid√£o no tempo de execu√ß√£o."

#: src/concurrency/threads.md:1
msgid "# Threads"
msgstr "# Threads"

#: src/concurrency/threads.md:3
msgid "Rust threads work similarly to threads in other languages:"
msgstr "_Threads_ em Rust funcionam de maneira semelhante √†s _threads_ em outras linguagens:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;"

#: src/concurrency/threads.md:9
msgid ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"
msgstr ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Contador na thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"

#: src/concurrency/threads.md:17
msgid ""
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    for i in 1..5 {\n"
"        println!(\"Thread principal: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/threads.md:24
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* _Threads_ s√£o todas \"_daemon threads_\", o _thread_ principal n√£o espera por elas.\n"
"* \"_Panics_\" em _threads_ s√£o independentes uns dos outros.\n"
"  * \"_Panics_\" podem carregar um _payload_ (carga √∫til), que pode ser descompactado com `downcast_ref`."

#: src/concurrency/threads.md:32
msgid ""
"* Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is\n"
"  not waiting."
msgstr ""
"* Observe que o _thread_ √© interrompido antes de atingir 10 ‚Äî o _thread_ principal n√£o\n"
"  o espera."

#: src/concurrency/threads.md:35
msgid ""
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for\n"
"  the thread to finish."
msgstr ""
"* Use `let handle = thread::spawn(...)` e posteriormente `handle.join()` para aguardar\n"
"  a `thread` terminar."

#: src/concurrency/threads.md:38
msgid "* Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "* Acione um p√¢nico (`panic`) na _thread_ e observe como isso n√£o afeta a _thread_ `main`."

#: src/concurrency/threads.md:40
msgid ""
"* Use the `Result` return value from `handle.join()` to get access to the panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""
"* Use o valor de retorno `Result` de `handle.join()` para obter acesso ao\n"
"  _payload_ do `panic` gerado. Este √© um bom momento para falar sobre [`Any`]."

#: src/concurrency/threads.md:43
msgid "[`Any`]: https://doc.rust-lang.org/std/any/index.html"
msgstr "[`Qualquer`]: https://doc.rust-lang.org/std/any/index.html"

#: src/concurrency/scoped-threads.md:1
msgid "# Scoped Threads"
msgstr "# Threads com Escopo"

#: src/concurrency/scoped-threads.md:3
msgid "Normal threads cannot borrow from their environment:"
msgstr "_Threads_ normais n√£o podem emprestar de seu ambiente:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::thread;"

#: src/concurrency/scoped-threads.md:8 src/concurrency/scoped-threads.md:22
msgid ""
"fn main() {\n"
"    let s = String::from(\"Hello\");"
msgstr ""
"fn main() {\n"
"    let s = String::from(\"Ol√°\");"

#: src/concurrency/scoped-threads.md:11
msgid ""
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""
"    thread::spawn(|| {\n"
"        println!(\"Comprimento: {}\", s.len());\n"
"    });\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:17
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "No entanto, voc√™ pode usar uma [_thread_ com escopo][1] para isso:"

#: src/concurrency/scoped-threads.md:19
msgid ""
"```rust,editable\n"
"use std::thread;"
msgstr ""
"```rust,editable\n"
"use std::thread;"

#: src/concurrency/scoped-threads.md:25
msgid ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Comprimento: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:33
msgid "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"
msgstr "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"

#: src/concurrency/scoped-threads.md:35
msgid ""
"<details>\n"
"    \n"
"* The reason for that is that when the `thread::scope` function completes, all the threads are guaranteed to be joined, so "
"they can return borrowed data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by any number of threads.\n"
"    \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"* A raz√£o para isso √© que, quando a fun√ß√£o `thread::scope` for conclu√≠da, todas as _threads_ ser√£o unidas, para que possam "
"retornar dados emprestados.\n"
"* Aplicam-se as regras normais de empr√©stimo do Rust: o empr√©stimo pode ser mut√°vel, para uma `thread` ou imut√°vel para\n"
"qualquer n√∫mero de _threads_.\n"
"    \n"
"</details>"

#: src/concurrency/channels.md:1
msgid "# Channels"
msgstr "# Channels (Canais)"

#: src/concurrency/channels.md:3
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"Os _channels_ (canais) em Rust t√™m duas partes: um `Sender<T>` e um `Receiver<T>`. As duas partes\n"
"est√£o conectadas atrav√©s do _channel_, mas voc√™ s√≥ v√™ os _end-points_."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;"
msgstr ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;"

#: src/concurrency/channels.md:10 src/concurrency/channels/unbounded.md:10
msgid ""
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();"
msgstr ""
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();"

#: src/concurrency/channels.md:13
msgid ""
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();"
msgstr ""

#: src/concurrency/channels.md:16
msgid ""
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());"
msgstr ""
"    println!(\"Recebido: {:?}\", rx.recv());\n"
"    println!(\"Recebido: {:?}\", rx.recv());"

#: src/concurrency/channels.md:19
msgid ""
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Recebido: {:?}\", rx.recv());\n"
"}\n"
"```"

#: src/concurrency/channels.md:27
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` implement `Clone` (so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the counterpart `Sender` or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` significa Multi-Produtor, √önico-Consumidor. `Sender` e `SyncSender` implementam `Clone` (ent√£o\n"
"  voc√™ pode criar v√°rios produtores), mas `Receiver` (consumidores) n√£o.\n"
"* `send()` e `recv()` retornam `Result`. Se retornarem `Err`, significa que a contraparte `Sender` ou\n"
"  `Receiver` √© descartada e o canal √© fechado."

#: src/concurrency/channels/unbounded.md:1
msgid "# Unbounded Channels"
msgstr "# Canais ilimitados"

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Voc√™ obt√©m um canal ilimitado e ass√≠ncrono com `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5 src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;"

#: src/concurrency/channels/unbounded.md:13 src/concurrency/channels/bounded.md:13
msgid ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"
msgstr ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Mensagem {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: enviando a mensagem: {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: feito\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"

#: src/concurrency/channels/unbounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {}\", msg);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: obteve {msg}\");\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/channels/bounded.md:1
msgid "# Bounded Channels"
msgstr "# Canais Delimitados"

#: src/concurrency/channels/bounded.md:3
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr "Canais limitados e s√≠ncronos fazem `send` bloquear o _thread_ atual:"

#: src/concurrency/channels/bounded.md:10
msgid ""
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);"
msgstr ""
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);"

#: src/concurrency/channels/bounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: obteve {msg}\");\n"
"    }\n"
"}\n"
"```"

#: src/concurrency/shared_state.md:1
msgid "# Shared State"
msgstr "# Estado Compartilhado"

#: src/concurrency/shared_state.md:3
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is\n"
"primarily done via two types:"
msgstr ""
"Rust usa o sistema de tipos para impor a sincroniza√ß√£o de dados compartilhados. Isso √©\n"
"feito principalmente atrav√©s de dois tipos:"

#: src/concurrency/shared_state.md:6
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], refer√™ncia at√¥mica contada `T`: manipula o compartilhamento entre _threads_ e\n"
"  toma o cuidado de desalocar `T` quando a √∫ltima refer√™ncia √© descartada,\n"
"* [`Mutex<T>`][2]: garante acesso mutuamente exclusivo ao valor `T`."

#: src/concurrency/shared_state.md:10
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"

#: src/concurrency/shared_state/arc.md:1
msgid "# `Arc`"
msgstr "# `Arc`"

#: src/concurrency/shared_state/arc.md:3
msgid "[`Arc<T>`][1] allows shared read-only access via its `clone` method:"
msgstr "[`Arc<T>`][1] permite acesso somente leitura compartilhado por meio de seu m√©todo `clone`:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;"
msgstr ""
"```rust, editable\n"
"use std::thread;\n"
"use std::sync::Arc;"

#: src/concurrency/shared_state/arc.md:9
msgid ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"
msgstr ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"

#: src/concurrency/shared_state/arc.md:20
msgid ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/arc.md:25
msgid "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/arc.md:29
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but after that the use of the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc` significa \"Atomic Reference Counted\", uma vers√£o _thread-safe_ de `Rc` que usa opera√ß√µes at√¥micas.\n"
"* `Arc<T>` implementa `Clone` quer `T` o fa√ßa ou n√£o. Ele implementa `Send` e `Sync` se `T`\n"
"  implementa os dois.\n"
"* `Arc::clone()` tem o custo das opera√ß√µes at√¥micas que s√£o executadas, mas depois disso o uso do\n"
"  `T` √© gratuito.\n"
"* Cuidado com os ciclos de refer√™ncia, `Arc` n√£o usa um coletor de lixo para detect√°-los.\n"
"    * `std::sync::Weak` pode ajudar."

#: src/concurrency/shared_state/mutex.md:1
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"[`Mutex<T>`][1] garante exclus√£o m√∫tua _e_ permite acesso mut√°vel a `T`\n"
"por tr√°s de uma interface somente leitura:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;"
msgstr ""
"```rust, editable\n"
"use std::sync::Mutex;"

#: src/concurrency/shared_state/mutex.md:9
msgid ""
"fn main() {\n"
"    let v: Mutex<Vec<i32>> = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());"
msgstr ""
"fn main() {\n"
"    let v: Mutex<Vec<i32>> = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());"

#: src/concurrency/shared_state/mutex.md:13
msgid ""
"    {\n"
"        let v: &Mutex<Vec<i32>> = &v;\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }"
msgstr ""
"    {\n"
"        let v: &Mutex<Vec<i32>> = &v;\n"
"        let mut guarda= v.lock().unwrap();\n"
"        guarda.push(40);\n"
"    }"

#: src/concurrency/shared_state/mutex.md:19
msgid ""
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"

#: src/concurrency/shared_state/mutex.md:23
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr ""
"Observe como temos uma implementa√ß√£o [`impl<T: Send> Sync for Mutex<T>`][2]\n"
"encoberta."

#: src/concurrency/shared_state/mutex.md:26
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/mutex.md:30
msgid ""
"<details>\n"
"    \n"
"* `Mutex` in Rust looks like a collection with just one element - the protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The `MutexGuard` ensures that the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes \"poisoned\" to signal that\n"
"      the data it protected might be in an inconsistent state. Calling `lock()` on a poisoned mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error to recover the data\n"
"      regardless."
msgstr ""
"<details>\n"
"    \n"
"* `Mutex` em Rust parece uma cole√ß√£o com apenas um elemento - os dados protegidos.\n"
"    * N√£o √© poss√≠vel esquecer de adquirir o mutex antes de acessar os dados protegidos.\n"
"* Voc√™ pode obter um `&mut T` de um `&Mutex<T>` obtendo um bloqueio (_lock_). O `MutexGuard` garante que o\n"
"  `&mut T` n√£o sobrevive al√©m do bloqueio (_lock_).\n"
"* `Mutex<T>` implementa `Send` e `Sync` se `T` implementa `Send`.\n"
"* O bloqueio para leitura e grava√ß√£o - `RwLock`.\n"
"* Por que `lock()` retorna um `Result`?\n"
"    * Se o thread que manteve o `Mutex` entrou em p√¢nico, o `Mutex` torna-se \"envenenado\" para sinalizar que\n"
"      os dados protegidos podem estar em um estado inconsistente. Ao chamar `lock()` em um mutex envenenado\n"
"      o retorno √© uma falha com um [`PoisonError`]. Voc√™ pode chamar `into_inner()` no erro para recuperar os dados\n"
"      independentemente."

#: src/concurrency/shared_state/mutex.md:44
msgid ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html  \n"
"    \n"
"</details>"
msgstr ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html\n"
"    \n"
"</details>"

#: src/concurrency/shared_state/example.md:3
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Vamos ver `Arc` e `Mutex` em a√ß√£o:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};"

#: src/concurrency/shared_state/example.md:9
msgid ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"
msgstr ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"

#: src/concurrency/shared_state/example.md:16
msgid ""
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"

#: src/concurrency/shared_state/example.md:23
msgid ""
"Possible solution:\n"
"    \n"
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"
msgstr ""
"Solu√ß√£o poss√≠vel:\n"
"    \n"
"```rust, editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"

#: src/concurrency/shared_state/example.md:29
msgid ""
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"
msgstr ""
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"

#: src/concurrency/shared_state/example.md:32
msgid ""
"    let v2 = v.clone();\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"
msgstr ""
"    let v2 = v.clone();\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"

#: src/concurrency/shared_state/example.md:38
msgid ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"
msgstr ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"

#: src/concurrency/shared_state/example.md:43
msgid "    handle.join().unwrap();"
msgstr "    handle.join().unwrap();"

#: src/concurrency/shared_state/example.md:45
msgid ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Notable parts:"
msgstr ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Partes importantes:"

#: src/concurrency/shared_state/example.md:54
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another thread. Note `move` was added to the lambda "
"signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as possible.\n"
"* We still need to acquire the `Mutex` to print our `Vec`."
msgstr ""
"* `v` √© agrupado em ambos `Arc` e `Mutex`, porque seus interesses s√£o ortogonais.\n"
"  * Envolver um `Mutex` em um `Arc` √© um padr√£o comum para compartilhar o estado mut√°vel entre threads.\n"
"* `v: Arc<_>` precisa ser clonado como `v2` antes que possa ser movido para outro thread. Note que `move` foi adicionado √† "
"assinatura lambda.\n"
"* Os blocos s√£o introduzidos para restringir o escopo do `LockGuard` tanto quanto poss√≠vel.\n"
"* Ainda precisamos adquirir o `Mutex` para imprimir nosso `Vec`."

#: src/concurrency/send-sync.md:1
msgid "# `Send` and `Sync`"
msgstr "# `Send` e `Sync`"

#: src/concurrency/send-sync.md:3
msgid "How does Rust know to forbid shared access across thread? The answer is in two traits:"
msgstr "Como o Rust sabe proibir o acesso compartilhado entre threads? A resposta est√° em duas caracter√≠sticas:"

#: src/concurrency/send-sync.md:5
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a thread\n"
"  boundary."
msgstr ""
"* [`Send`][1]: um tipo `T` √© `Send` se for seguro mover um `T` entre _threads_\n"
"* [`Sync`][2]: um tipo `T` √© `Sync` se for seguro mover um `&T` entre _threads_"

#: src/concurrency/send-sync.md:10
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically derive them for your types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement them manually when you\n"
"know it is valid."
msgstr ""
"`Send` e `Sync` s√£o [`unsafe traits`][3]. O compilador os derivar√° automaticamente para seus tipos\n"
"desde que contenham apenas os tipos `Send` e `Sync`. Voc√™ tamb√©m pode implement√°-los manualmente quando\n"
"souber que s√£o v√°lidos."

#: src/concurrency/send-sync.md:14
msgid ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"
msgstr ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"

#: src/concurrency/send-sync.md:20
msgid ""
"* One can think of these traits as markers that the type has certain thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  \n"
"</details>"
msgstr ""
"* Pode-se pensar nesses _traits_ como marcadores de que o tipo possui certas propriedades de seguran√ßa de "
"_threads_.\n"
"* Eles podem ser usados nas restri√ß√µes gen√©ricas como _traits_ normais.\n"
"  \n"
"</details>"

#: src/concurrency/send-sync/send.md:1
msgid "# `Send`"
msgstr "# `Send`"

#: src/concurrency/send-sync/send.md:3
msgid "> A type `T` is [`Send`][1] if it is safe to move a `T` value to another thread."
msgstr "> Um tipo `T` √© [`Send`][1] se for seguro mover um valor `T` para outro _thread_."

#: src/concurrency/send-sync/send.md:5
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will run\n"
"in that thread. So the question is when you can allocate a value in one thread\n"
"and deallocate it in another."
msgstr ""
"O efeito de mover a propriedade (ownership) para outro _thread_ √© que os _destructors_ ser√£o executados\n"
"nessa _thread_. Ent√£o a quest√£o √©: quando voc√™ pode alocar um valor em um _thread_\n"
"e desaloc√°-lo em outro?"

#: src/concurrency/send-sync/send.md:9
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#: src/concurrency/send-sync/sync.md:1
msgid "# `Sync`"
msgstr "# `Sync`"

#: src/concurrency/send-sync/sync.md:3
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from multiple\n"
"> threads at the same time."
msgstr ""
"> Um tipo `T` √© [`Sync`][1] se for seguro acessar um valor `T` de v√°rias\n"
"> threads ao mesmo tempo."

#: src/concurrency/send-sync/sync.md:6
msgid "More precisely, the definition is:"
msgstr "Mais precisamente, a defini√ß√£o √©:"

#: src/concurrency/send-sync/sync.md:8
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> `T` √© `Sync` se e somente se `&T` √© `Send`"

#: src/concurrency/send-sync/sync.md:10
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"

#: src/concurrency/send-sync/sync.md:14
msgid ""
"This statement is essentially a shorthand way of saying that if a type is thread-safe for shared use, it is also thread-"
"safe to pass references of it across threads."
msgstr ""
"Essa instru√ß√£o √© essencialmente uma maneira abreviada de dizer que, se um tipo √© _thread-safe_ para uso compartilhado, tamb√©m "
"√© _thread-safe_ passar refer√™ncias a ele entre _threads_."

#: src/concurrency/send-sync/sync.md:16
msgid ""
"This is because if a type is Sync it means that it can be shared across multiple threads without the risk of data races or "
"other synchronization issues, so it is safe to move it to another thread. A reference to the type is also safe to move to "
"another thread, because the data it references can be accessed from any thread safely."
msgstr ""
"Isso ocorre porque, se um tipo for `Sync`, significa que ele pode ser compartilhado entre v√°rios _threads_ sem o risco de "
"corridas de dados ou outros problemas de sincroniza√ß√£o, portanto, √© seguro mov√™-lo para outro _thread_. Uma refer√™ncia "
"ao tipo tamb√©m √© segura para mover para outro _thread_, porque os dados a que ela faz refer√™ncia podem ser acessados de "
"qualquer _thread_ com seguran√ßa."

#: src/concurrency/send-sync/examples.md:1
msgid "# Examples"
msgstr "# Exemplos"

#: src/concurrency/send-sync/examples.md:3
msgid "## `Send + Sync`"
msgstr "## `Send + Sync`"

#: src/concurrency/send-sync/examples.md:5
msgid "Most types you come across are `Send + Sync`:"
msgstr "A maioria dos tipos que voc√™ encontra s√£o `Send + Sync`:"

#: src/concurrency/send-sync/examples.md:7
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitamente _thread-safe_ via contagem de refer√™ncia at√¥mica.\n"
"* `Mutex<T>`: Explicitamente _thread-safe_ via bloqueio interno.\n"
"* `AtomicBool`, `AtomicU8`, ...: Usa instru√ß√µes at√¥micas especiais."

#: src/concurrency/send-sync/examples.md:14
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"Os tipos gen√©ricos s√£o tipicamente `Send + Sync` quando os par√¢metros de tipo s√£o\n"
"`Send + Sync`."

#: src/concurrency/send-sync/examples.md:17
msgid "## `Send + !Sync`"
msgstr "## `Send + !Sync`"

#: src/concurrency/send-sync/examples.md:19
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"Esses tipos podem ser movidos para outras _threads_, mas n√£o s√£o seguros para _threads_.\n"
"Normalmente por causa da mutabilidade interior:"

#: src/concurrency/send-sync/examples.md:22
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
msgid "## `!Send + Sync`"
msgstr "## `!Send + Sync`"

#: src/concurrency/send-sync/examples.md:29
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr "Esses tipos s√£o _thread-safe_, mas n√£o podem ser movidos para outro _thread_:"

#: src/concurrency/send-sync/examples.md:31
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on the\n"
"  thread which created them."
msgstr ""
"* `MutexGuard<T>`: Usa primitivas a n√≠vel de sistema operacional que devem ser desalocadas no\n"
" _thread_ que as criou."

#: src/concurrency/send-sync/examples.md:34
msgid "## `!Send + !Sync`"
msgstr "## `!Send + !Sync`"

#: src/concurrency/send-sync/examples.md:36
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr "Esses tipos n√£o s√£o _thread-safe_ e n√£o podem ser movidos para outros _threads_:"

#: src/concurrency/send-sync/examples.md:38
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: cada `Rc<T>` tem uma refer√™ncia a um `RcBox<T>`, que cont√©m uma\n"
"  contagem de refer√™ncia n√£o at√¥mica.\n"
"* `*const T`, `*mut T`: Rust assume que ponteiros brutos podem ter\n"
"  considera√ß√µes de especiais de concorr√™ncia."

#: src/exercises/day-4/morning.md:1 src/exercises/day-4/afternoon.md:1
msgid "# Exercises"
msgstr "# Exerc√≠cios"

#: src/exercises/day-4/morning.md:3
msgid "Let us practice our new concurrency skills with"
msgstr "Vamos praticar nossas novas habilidades de concorr√™ncia com:"

#: src/exercises/day-4/morning.md:5
msgid "* Dining philosophers: a classic problem in concurrency."
msgstr "* _Dining philosophers_: um problema cl√°ssico em concorr√™ncia."

#: src/exercises/day-4/morning.md:7
msgid ""
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"* Verificador de link _multi-threads_: um projeto maior  no qual voc√™ usar√° o Cargo para\n"
"  baixar as depend√™ncias e tamb√©m verificar os links em paralelo."

#: src/exercises/day-4/dining-philosophers.md:1
msgid "# Dining Philosophers"
msgstr "# Fil√≥sofos jantando"

#: src/exercises/day-4/dining-philosophers.md:3
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "O problema dos fil√≥sofos jantando √© um problema cl√°ssico em concorr√™ncia:"

#: src/exercises/day-4/dining-philosophers.md:5
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has their\n"
"> own place at the table. There is a fork between each plate. The dish served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will only\n"
"> be available when their two nearest neighbors are thinking, not eating. After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> Cinco fil√≥sofos jantam juntos na mesma mesa. Cada fol√≥sofo tem seu\n"
"> pr√≥prio lugar √† mesa. H√° um garfo entre cada prato. O prato servido √©\n"
"> uma esp√©cie de espaguete que se come com dois garfos. Cada fil√≥sofo pode\n"
"> somente pensar ou comer, alternadamente. Al√©m disso, um fil√≥sofo s√≥ pode comer seu\n"
"> espaguete quando ele t√™m garfo esquerdo e direito. Assim, dois garfos s√≥\n"
"> estar√£o dispon√≠veis quando seus dois vizinhos mais pr√≥ximos estiverem pensando, n√£o comendo. Depois de\n"
"> um fil√≥sofo individual termina de comer, ele abaixa os dois garfos."

#: src/exercises/day-4/dining-philosophers.md:13
msgid ""
"You will need a local [Cargo installation][../../cargo/running-locally.md] for\n"
"this exercise. Copy the code below to `src/main.rs` file, fill out the blanks,\n"
"and test that `cargo run` does not deadlock:"
msgstr ""
"Voc√™ precisar√° de uma [instala√ß√£o do Cargo][../../cargo/running-locally.md] local para\n"
"esse exerc√≠cio. Copie o c√≥digo abaixo para o arquivo `src/main.rs`, preencha os espa√ßos em branco,\n"
"e teste se `cargo run` n√£o trava:"

#: src/exercises/day-4/dining-philosophers.md:17
msgid ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"

#: src/exercises/day-4/dining-philosophers.md:23 src/exercises/day-4/solutions-morning.md:28
msgid "struct Fork;"
msgstr "struct Garfo;"

#: src/exercises/day-4/dining-philosophers.md:25
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}"
msgstr ""
"struct Filosofo {\n"
"    nome: String,\n"
"    // garfo_esquerda: ...\n"
"    // garfo_direita: ...\n"
"    // pensamentos: ...\n"
"}"

#: src/exercises/day-4/dining-philosophers.md:32
msgid ""
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }"
msgstr ""
"impl Filosofo {\n"
"    fn pensa(&self) {\n"
"        self.pensamento\n"
"            .send(format!(\"Eureka! {} tem uma nova ideia!\", &self.nome))\n"
"            .unwrap();\n"
"    }"

#: src/exercises/day-4/dining-philosophers.md:39
msgid ""
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""
"    fn come(&self) {\n"
"        // Pegar garfos...\n"
"        println!(\"{} est√° comendo...\", &self.nome);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"

#: src/exercises/day-4/dining-philosophers.md:46 src/exercises/day-4/solutions-morning.md:60
msgid ""
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];"
msgstr ""
"static FILOSOFOS: &[&str] =\n"
"&[\"S√≥crates\", \"Plat√£o\", \"Arist√≥teles\", \"Tales\", \"Pit√°goras\"];"

#: src/exercises/day-4/dining-philosophers.md:49
msgid ""
"fn main() {\n"
"    // Create forks"
msgstr ""
"fn main() {\n"
"    // Criar garfos"

#: src/exercises/day-4/dining-philosophers.md:52
msgid "    // Create philosophers"
msgstr "    // Criar filosofos"

#: src/exercises/day-4/dining-philosophers.md:54
msgid "    // Make them think and eat"
msgstr "    // Fa√ßa-os pensar e comer"

#: src/exercises/day-4/dining-philosophers.md:56
msgid ""
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""
"    // Mostrar seus pensamentos\n"
"}\n"
"```"

#: src/exercises/day-4/link-checker.md:1
msgid "# Multi-threaded Link Checker"
msgstr "# Verificador de links _multi-threads_"

#: src/exercises/day-4/link-checker.md:3
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until all\n"
"pages have been validated."
msgstr ""
"Vamos usar nosso novo conhecimento para criar um verificador de links _multi-threads_. \n"
"Comece em uma p√°gina da web e verifique se os links na p√°gina s√£o v√°lidos. \n"
"Verifique recursivamente outras p√°ginas no mesmo dom√≠nio e continue fazendo isso at√© que todas\n"
"as p√°ginas tenham sido validadas."

#: src/exercises/day-4/link-checker.md:8
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Para isso, voc√™ precisar√° de um cliente HTTP como [`reqwest`][1]. Crie um novo\n"
"Project com o Cargo e adicione `reqwest` como uma depend√™ncia:"

#: src/exercises/day-4/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"

#: src/exercises/day-4/link-checker.md:17
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> Se `cargo add` falhar com `error: no such subcommand`, edite o\n"
"> arquivo `Cargo.toml` √† m√£o. Adicione as depend√™ncias listadas abaixo."

#: src/exercises/day-4/link-checker.md:20
msgid "You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr "Voc√™ tamb√©m precisar√° de uma maneira de encontrar links. Podemos usar [`scraper`][2] para isso:"

#: src/exercises/day-4/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""
"```shell\n"
"$ cargo add scraper\n"
"```"

#: src/exercises/day-4/link-checker.md:26
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] for\n"
"that:"
msgstr ""
"Por fim, precisaremos de alguma forma de lidar com os erros. Usamos [`thiserror`][3] para\n"
"isso:"

#: src/exercises/day-4/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""
"```shell\n"
"$ cargo add thiserror\n"
"```"

#: src/exercises/day-4/link-checker.md:33
msgid "The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "As chamadas `cargo add` ir√£o atualizar o arquivo `Cargo.toml` para ficar assim:"

#: src/exercises/day-4/link-checker.md:35
msgid ""
"```toml\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[depend√™ncias]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/day-4/link-checker.md:42
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"Agora voc√™ pode baixar a p√°gina inicial. Tente com um pequeno site como\n"
"`https://www.google.org/`."

#: src/exercises/day-4/link-checker.md:45
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Seu arquivo `src/main.rs` deve se parecer com isto:"

#: src/exercises/day-4/link-checker.md:47
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;"
msgstr ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;"

#: src/exercises/day-4/link-checker.md:53
msgid ""
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"
msgstr ""
"#[derive(Error, Debug)]\n"
"enum Error{\n"
"    #[error(\"erro de solicita√ß√£o: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"

#: src/exercises/day-4/link-checker.md:59
msgid ""
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"
msgstr ""
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"

#: src/exercises/day-4/link-checker.md:65
msgid ""
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: {err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"
msgstr ""
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"Em {base_url}: n√£o foi poss√≠vel analisar {href:?}: {err} (ignorado)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"

#: src/exercises/day-4/link-checker.md:77
msgid ""
"    Ok(valid_urls)\n"
"}"
msgstr ""
"    Ok(valid_urls)\n"
"}"

#: src/exercises/day-4/link-checker.md:80
msgid ""
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"N√£o foi poss√≠vel extrair os links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-4/link-checker.md:90
msgid "Run the code in `src/main.rs` with"
msgstr "Execute o c√≥digo em `src/main.rs` com"

#: src/exercises/day-4/link-checker.md:92
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/exercises/day-4/link-checker.md:96
msgid "## Tasks"
msgstr "## Tarefas"

#: src/exercises/day-4/link-checker.md:98
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that you\n"
"  don't end up being blocked by the site."
msgstr ""
"* Use _threads_ para verificar os links em paralelo: envie as URLs a serem verificadas para um\n"
"  _channel_ e deixe alguns _threads_ verificarem as URLs em paralelo.\n"
"* Estenda isso para extrair recursivamente links de todas as p√°ginas no\n"
"  dom√≠nio `www.google.org`. Coloque um limite m√°ximo de 100 p√°ginas ou menos para que voc√™\n"
"  n√£o acabe sendo bloqueado pelo site."

#: src/exercises/day-4/link-checker.md:104
msgid ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"
msgstr ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"

#: src/android.md:1
msgid "# Android"
msgstr "# Android"

#: src/android.md:3
msgid ""
"Rust is supported for native platform development on Android. This means that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust tem suporte para desenvolvimento de plataforma nativa no Android. Isso significa que\n"
"voc√™ pode escrever novos servi√ßos de sistema operacional em Rust, bem como estender\n"
"servi√ßos existentes."

#: src/android/setup.md:1
msgid "# Setup"
msgstr "# Configurar"

#: src/android/setup.md:3
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you have\n"
"access to one or create a new one with:"
msgstr ""
"Estaremos usando um dispositivo virtual Android para testar nosso c√≥digo. Assegure-se de ter\n"
"acesso a um ou crie um novo com:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ launch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"

#: src/android/setup.md:12
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"Consulte o [Codelab para Desenvolvedor Android]\n"
"[https://source.android.com/docs/setup/start] para obter detalhes."

#: src/android/build-rules.md:1
msgid "# Build Rules"
msgstr "# Regras de constru√ß√£o"

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr "O sistema de compila√ß√£o do Android (Soong) oferece suporte ao Rust por meio de v√°rios m√≥dulos:"

#: src/android/build-rules.md:5
msgid ""
"| Module Type       | Description                                                                                        |\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust binary.                                                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and `dylib` variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and provides both static and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are analogous to compiler plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard Rust test harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging `libfuzzer`.                                                |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that provides an interface for a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library containing Rust bindings to C libraries.              |"
msgstr ""
"| Tipo de m√≥dulo | Descri√ß√£o |\n"
"|-------------------|----------------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produz um bin√°rio Rust.                                                                                  |\n"
"| `rust_library`    | Produz uma biblioteca Rust e fornece as variantes `rlib` e `dylib`.                                      |\n"
"| `rust_ffi`        | Produz uma biblioteca Rust C utiliz√°vel por m√≥dulos `cc` e fornece variantes est√°ticas e compartilhadas. |\n"
"| `rust_proc_macro` | Produz uma biblioteca Rust `proc-macro`. Estes s√£o an√°logos aos plugins do compilador.                   |\n"
"| `rust_test`       | Produz um bin√°rio de teste Rust que usa o equipamento de teste Rust padr√£o.                              |\n"
"| `rust_fuzz`       | Produz um bin√°rio Rust fuzz aproveitando `libfuzzer`.                                                    |\n"
"| `rust_protobuf`   | Gera o c√≥digo-fonte e produz uma biblioteca Rust que fornece uma interface para um _protobuf_ espec√≠fico.|\n"
"| `rust_bindgen`    | Gera fonte e produz uma biblioteca Rust contendo liga√ß√µes Rust para bibliotecas C.                       |"

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Veremos `rust_binary` e `rust_library` a seguir."

#: src/android/build-rules/binary.md:1
msgid "# Rust Binaries"
msgstr "# Bin√°rios Rust"

#: src/android/build-rules/binary.md:3
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, create\n"
"the following files:"
msgstr ""
"Vamos come√ßar com um aplicativo simples. Na raiz de um checkout AOSP, crie\n"
"os seguintes arquivos:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary{\n"
"    name: \"ol√°_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo."
msgstr ""
"```rust\n"
"//! Demonstra√ß√£o de Rust."

#: src/android/build-rules/binary.md:21
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""
"/// Imprime uma sauda√ß√£o na sa√≠da padr√£o.\n"
"fn main() {\n"
"    println!(\"Ol√° do Rust!\");\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "Agora voc√™ pode compilar, enviar e executar o bin√°rio:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Sauda√ß√µes da Rust!\n"
"```"

#: src/android/build-rules/library.md:1
msgid "# Rust Libraries"
msgstr "# Bibliotecas de Rust"

#: src/android/build-rules/library.md:3
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "Voc√™ usa `rust_library` para criar uma nova biblioteca Rust para Android."

#: src/android/build-rules/library.md:5
msgid "Here we declare a dependency on two libraries:"
msgstr "Aqui declaramos uma depend√™ncia em duas bibliotecas:"

#: src/android/build-rules/library.md:7
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* `libgreeting`, que definimos abaixo,\n"
"* `libtextwrap`, que √© um `crate` j√° vendida em\n"
"  [`external/rust/crates/`][crates]."

#: src/android/build-rules/library.md:11
msgid "[crates]: https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"
msgstr "[crates]: https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"

#: src/android/build-rules/library.md:27
msgid ""
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo."
msgstr ""
"```rust, ignore\n"
"//! Demonstra√ß√£o de rust."

#: src/android/build-rules/library.md:39
msgid ""
"use greetings::greeting;\n"
"use textwrap::fill;"
msgstr ""
"use greetings::greeting;\n"
"use textwrap::fill;"

#: src/android/build-rules/library.md:42
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""
"/// Imprime uma sauda√ß√£o na sa√≠da padr√£o.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library."
msgstr ""
"```rust, ignore\n"
"//! Biblioteca de Sauda√ß√£o."

#: src/android/build-rules/library.md:53
msgid ""
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""
"/// Sauda√ß√£o `nome`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Ol√° {name}, prazer em conhec√™-lo!\")\n"
"}\n"
"```"

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "Voc√™ constr√≥i, envia e executa o bin√°rio como antes:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Ol√° Bob, prazer em conhec√™-lo!\n"
"```"

#: src/android/aidl.md:1
msgid "# AIDL"
msgstr "# AIDL"

#: src/android/aidl.md:3
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in Rust:"
msgstr ""
"A [Linguagem de Defini√ß√£o de Interface Android\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) √© compat√≠vel com Rust:"

#: src/android/aidl.md:6
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* O c√≥digo Rust pode chamar servidores AIDL existentes,\n"
"* Voc√™ pode criar novos servidores AIDL em Rust."

#: src/android/aidl/interface.md:1
msgid "# AIDL Interfaces"
msgstr "# Interfaces AIDL"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Voc√™ declara a API do seu servi√ßo usando uma interface AIDL:"

#: src/android/aidl/interface.md:5
msgid "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"

#: src/android/aidl/interface.md:7 src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;"
msgstr ""
"```java\n"
"package com.example.birthdayservice;"

#: src/android/aidl/interface.md:10
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""
"/** Interface de servi√ßo de anivers√°rio. */\n"
"interface IBirthdayService {\n"
"    /** Gera uma mensagem de feliz anivers√°rio. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"

#: src/android/aidl/interface.md:17
msgid "*birthday_service/aidl/Android.bp*:"
msgstr "*birthday_service/aidl/Android.bp*:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust n√£o est√° ativado por padr√£o\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"

#: src/android/aidl/interface.md:32
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the vendor\n"
"partition."
msgstr ""
"Adicione `vendor_available: true` se seu arquivo AIDL for usado por um bin√°rio na parti√ß√£o _vendor_."

#: src/android/aidl/implementation.md:1
msgid "# Service Implementation"
msgstr "# Implementa√ß√£o de servi√ßo"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "Agora podemos implementar o servi√ßo AIDL:"

#: src/android/aidl/implementation.md:5
msgid "*birthday_service/src/lib.rs*:"
msgstr "*birthday_service/src/lib.rs*:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""
"```rust, ignore\n"
"//! Implementa√ß√£o da interface AIDL `IBirthdayService`.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"

#: src/android/aidl/implementation.md:12
msgid ""
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;"
msgstr ""
"/// A implementa√ß√£o `IBirthdayService`.\n"
"pub struct BirthdayService;"

#: src/android/aidl/implementation.md:15
msgid "impl binder::Interface for BirthdayService {}"
msgstr "impl binder::Interface for BirthdayService {}"

#: src/android/aidl/implementation.md:17
msgid ""
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Feliz Anivers√°rio {name}, parab√©ns pelos {years} anos!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28 src/android/aidl/client.md:37
msgid "*birthday_service/Android.bp*:"
msgstr "*birthday_service/Android.bp*:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"

#: src/android/aidl/server.md:1
msgid "# AIDL Server"
msgstr "# Servidor AIDL"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "Finalmente, podemos criar um servidor que exp√µe o servi√ßo:"

#: src/android/aidl/server.md:5
msgid "*birthday_service/src/server.rs*:"
msgstr "*birthday_service/src/server.rs*:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""
"```rust, ignore\n"
"//! Servi√ßo de anivers√°rio.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;"

#: src/android/aidl/server.md:13 src/android/aidl/client.md:12
msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
msgstr "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"

#: src/android/aidl/server.md:15
msgid ""
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""
"/// Point de entrada para servi√ßo de anivers√°rio.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_server,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Falha ao registrar o servi√ßo\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefere_rlib: true,\n"
"}\n"
"```"

#: src/android/aidl/deploy.md:1
msgid "# Deploy"
msgstr "# Implantar"

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "Agora podemos construir, enviar e iniciar o servi√ßo:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md:11
msgid "In another terminal, check that the service runs:"
msgstr "Em outro terminal, verifique se o servi√ßo √© executado:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Servi√ßo de anivers√°rio: encontrado\n"
"```"

#: src/android/aidl/deploy.md:18
msgid "You can also call the service with `service call`:"
msgstr "Voc√™ tamb√©m pode chamar o servi√ßo com `service call`:"

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .a.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000 's.!..... ')\n"
"```"

#: src/android/aidl/client.md:1
msgid "# AIDL Client"
msgstr "# Cliente AIDL"

#: src/android/aidl/client.md:3
msgid "Finally, we can create a Rust client for our new service."
msgstr "Por fim, podemos criar um cliente Rust para nosso novo servi√ßo."

#: src/android/aidl/client.md:5
msgid "*birthday_service/src/client.rs*:"
msgstr "*birthday_server/src/client.rs*:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""
"```rust, ignore\n"
"//! Servi√ßo de anivers√°rio.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"

#: src/android/aidl/client.md:14
msgid ""
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"
msgstr ""
"/// Conecte-se ao Servi√ßo de Anivers√°rio.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"

#: src/android/aidl/client.md:19
msgid ""
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"
msgstr ""
"/// Chamada ao servi√ßo de anivers√°rio.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"

#: src/android/aidl/client.md:29
msgid ""
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Falha ao conectar ao BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefere_rlib: true,\n"
"}\n"
"```"

#: src/android/aidl/client.md:52
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Observe que o cliente n√£o depende de `libbirthdayservice`."

#: src/android/aidl/client.md:54
msgid "Build, push, and run the client on your device:"
msgstr "Crie, envie e execute o cliente em seu dispositivo:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Parab√©ns Charlie, parab√©ns pelos 60 anos!\n"
"```"

#: src/android/aidl/changing.md:1
msgid "# Changing API"
msgstr "# Alterando API"

#: src/android/aidl/changing.md:3
msgid ""
"Let us extend the API with more functionality: we want to let clients specify a\n"
"list of lines for the birthday card:"
msgstr ""
"Vamos estender a API com mais funcionalidades: queremos permitir que os clientes especifiquem uma\n"
"lista de linhas para o cart√£o de anivers√°rio:"

#: src/android/aidl/changing.md:9
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""
"/** Interface de servi√ßo de anivers√°rio. */\n"
"interface IBirthdayService {\n"
"    /** Gera uma mensagem de feliz anivers√°rio. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"

#: src/android/logging.md:1
msgid "# Logging"
msgstr "# Gerando registros (Log)"

#: src/android/logging.md:3
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) or\n"
"`stdout` (on-host):"
msgstr ""
"Voc√™ deve usar o `crate` `log` para logar automaticamente no `logcat` (no dispositivo) ou\n"
"`stdout` (no hospedeiro):"

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefere_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"

#: src/android/logging.md:22
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo."
msgstr ""
"```rust, ignore\n"
"//! Demonstra√ß√£o de registro de rust."

#: src/android/logging.md:27
msgid "use log::{debug, error, info};"
msgstr "use log::{debug, error, info};"

#: src/android/logging.md:29
msgid ""
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""
"/// Registra uma sauda√ß√£o.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Iniciando programa.\");\n"
"    info!(\"As coisas est√£o indo bem.\");\n"
"    error!(\"Algo deu errado!\");\n"
"}\n"
"```"

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98 src/android/interoperability/with-c/rust.md:73
msgid "Build, push, and run the binary on your device:"
msgstr "Crie, envie e execute o bin√°rio em seu dispositivo:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md:50
msgid "The logs show up in `adb logcat`:"
msgstr "Os logs aparecem em `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!\n"
"```"
msgstr ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454 2420 2420 D rust: hello_rust_logs: Iniciando o programa.\n"
"09-08 08:38:32.454 2420 2420 I rust: hello_rust_logs: As coisas est√£o indo bem.\n"
"09-08 08:38:32.454 2420 2420 E rust: hello_rust_logs: Algo deu errado!\n"
"```"

#: src/android/interoperability.md:1
msgid "# Interoperability"
msgstr "# Interoperabilidade"

#: src/android/interoperability.md:3
msgid ""
"Rust has excellent support for interoperability with other languages. This means\n"
"that you can:"
msgstr ""
"Rust tem excelente suporte para interoperabilidade com outras linguagens. Isso significa\n"
"que voc√™ pode:"

#: src/android/interoperability.md:6
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* Chamar fun√ß√µes _Rust_ em outras linguagens.\n"
"* Chamar fun√ß√µes escritas em outras linguagens no _Rust_."

#: src/android/interoperability.md:9
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"Quando voc√™ chama fun√ß√µes em outra linguagem, dizemos que voc√™ est√° usando uma\n"
"_interface de fun√ß√£o externa_, tamb√©m conhecida como FFI."

#: src/android/interoperability/with-c.md:1
msgid "# Interoperability with C"
msgstr "# Interoperabilidade com C"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"_Rust_ tem suporte completo para vincular arquivos de objeto com uma conven√ß√£o de chamada C.\n"
"Da mesma forma, voc√™ pode exportar fun√ß√µes Rust e cham√°-las em C."

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "Voc√™ pode fazer isso manualmente se quiser:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"
msgstr ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"

#: src/android/interoperability/with-c.md:13
msgid ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr ""
"J√° vimos isso no exerc√≠cio [Safe FFI Wrapper\n"
"](../../exercises/day-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr ""
"> Isso pressup√µe conhecimento total da plataforma de destino. N√£o recomendado para\n"
"> produ√ß√£o."

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "Veremos op√ß√µes melhores a seguir."

#: src/android/interoperability/with-c/bindgen.md:1
msgid "# Using Bindgen"
msgstr "# Usando Bingen"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"A ferramenta [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)\n"
"pode gerar liga√ß√µes automaticamente a partir de um arquivo de cabe√ßalho C."

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "Primeiro crie uma pequena biblioteca C:"

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"
msgstr ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"

#: src/android/interoperability/with-c/bindgen.md:16
msgid ""
"void print_card(const card* card);\n"
"```"
msgstr ""
"void print_card(const card* card);\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\""
msgstr ""
"```c\n"
"#include <stdio.h>\n"
  "#include \"libbirthday.h\""

#: src/android/interoperability/with-c/bindgen.md:25
msgid ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Feliz Anivers√°rio %s!\\n\", card->name);\n"
"  printf(\"| Parab√©ns pelos %i anos!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr "Adicione isto ao seu arquivo `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35 src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69 src/android/interoperability/with-c/bindgen.md:108
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperability/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr ""
"Crie um arquivo de cabe√ßalho wrapper para a biblioteca (n√£o estritamente necess√°rio neste\n"
"exemplo):"

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "Agora voc√™ pode gerar automaticamente as vincula√ß√µes:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Finalmente, podemos usar as liga√ß√µes em nosso programa Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary{\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo."
msgstr ""
"```rust,compile_fail\n"
"//! Demonstra√ß√£o do Bingen."

#: src/android/interoperability/with-c/bindgen.md:84
msgid "use birthday_bindgen::{card, print_card};"
msgstr "use birthday_bindgen::{card, print_card};"

#: src/android/interoperability/with-c/bindgen.md:86
msgid ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:106
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr "Por fim, podemos executar testes gerados automaticamente para garantir que as vincula√ß√µes funcionem:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Arquivo gerado, pule o linting\n"
"    lints: \"none\",\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"

#: src/android/interoperability/with-c/rust.md:1
msgid "# Calling Rust"
msgstr "# Chamando Rust"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Exportar fun√ß√µes e tipos do Rust para C √© f√°cil:"

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]"
msgstr ""
"```rust, editable\n"
"//! Demonstra√ß√£o de uso do FFI com Rust.\n"
"#![deny(improper_ctypes_definitions)]"

#: src/android/interoperability/with-c/rust.md:11
msgid "use std::os::raw::c_int;"
msgstr "use std::os::raw::c_int;"

#: src/android/interoperability/with-c/rust.md:13
msgid ""
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"/// Analisar os n√∫meros.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) √© o menor!\");\n"
"    } else {\n"
"        println!(\"y ({y}) √© provavelmente maior que x ({x})\");\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H"
msgstr ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H"

#: src/android/interoperability/with-c/rust.md:30
msgid ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"
msgstr ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"

#: src/android/interoperability/with-c/rust.md:34
msgid ""
"#endif\n"
"```"
msgstr ""
"#endif\n"
"```"

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "Agora podemos chamar isso de um bin√°rio C:"

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analisar/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\""
msgstr ""
"```c\n"
"#include \"analyze.h\""

#: src/android/interoperability/with-c/rust.md:55
msgid ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md:83
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol will just be the name of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` desativa a altera√ß√£o de name usual do Rust, ent√£o o s√≠mbolo exportado ser√° apenas o nome da\n"
"fun√ß√£o. Voc√™ tamb√©m pode usar `#[export_name = \"some_name\"]` para especificar qualquer nome que desejar."

#: src/android/interoperability/cpp.md:1
msgid "# With C++"
msgstr "# Com C++"

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between Rust\n"
"and C++."
msgstr ""
"O [crate CXX][1] possibilita a interoperabilidade segura entre Rust\n"
"e C++."

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "A abordagem geral √© assim:"

#: src/android/interoperability/cpp.md:8
msgid "<img src=\"cpp/overview.svg\">"
msgstr "<img src=\"cpp/overview.svg\">"

#: src/android/interoperability/cpp.md:10
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr "Veja o [tutorial CXX][2] para um exemplo completo de como us√°-lo."

#: src/android/interoperability/cpp.md:12
msgid ""
"[1]: https://cxx.rs/\n"
"[2]: https://cxx.rs/tutorial.html"
msgstr ""
"[1]: https://cxx.rs/\n"
"[2]: https://cxx.rs/tutorial.html"

#: src/android/interoperability/java.md:1
msgid "# Interoperability with Java"
msgstr "# Interoperabilidade com Java"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java pode carregar objetos compartilhados via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface).\n"
"O [crate `jni`](https://docs.rs/jni/) permite que voc√™ crie uma biblioteca compat√≠vel."

#: src/android/interoperability/java.md:7
msgid "First, we create a Rust function to export to Java:"
msgstr "Primeiro, criamos uma fun√ß√£o Rust para exportar para Java:"

#: src/android/interoperability/java.md:9
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo."
msgstr ""
"```rust,compile_fail\n"
"//! Demonstra√ß√£o FFI Rust <-> Java."

#: src/android/interoperability/java.md:14
msgid ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"
msgstr ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"

#: src/android/interoperability/java.md:18
msgid ""
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""
"/// Implementa√ß√£o do m√©todo HelloWorld::hello.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Ol√°, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"

#: src/android/interoperability/java.md:32 src/android/interoperability/java.md:62
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:43
msgid "Finally, we can call this function from Java:"
msgstr "Finalmente, podemos chamar esta fun√ß√£o do Java:"

#: src/android/interoperability/java.md:45
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);"
msgstr ""
"```java\n"
"classe HelloWorld{\n"
"    private static native String hello(String name);"

#: src/android/interoperability/java.md:51
msgid ""
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }"
msgstr ""
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }"

#: src/android/interoperability/java.md:55
msgid ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    necess√°rio: [\"libhello_jni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:73
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Por fim, voc√™ pode criar, sincronizar e executar o bin√°rio:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync # requer adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"

#: src/exercises/day-4/afternoon.md:3
msgid ""
"For the last exercise, we will look at one of the projects you work with. Let us\n"
"group up and do this together. Some suggestions:"
msgstr ""
"No √∫ltimo exerc√≠cio, veremos um dos projetos com os quais voc√™ trabalha. Chamem-nos\n"
"agrupem-se e fa√ßam isso juntos. Algumas sugest√µes:"

#: src/exercises/day-4/afternoon.md:6
msgid "* Call your AIDL service with a client written in Rust."
msgstr "* Chame seu servi√ßo AIDL com um cliente escrito em Rust."

#: src/exercises/day-4/afternoon.md:8
msgid "* Move a function from your project to Rust and call it."
msgstr "* Mova uma fun√ß√£o do seu projeto para o Rust e chame-a."

#: src/exercises/day-4/afternoon.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nenhuma solu√ß√£o √© fornecida aqui, pois isso √© aberto: depende de voc√™ ter\n"
"uma classe tendo um peda√ßo de c√≥digo que voc√™ pode transformar em Rust em tempo real."

#: src/thanks.md:1
msgid "# Thanks!"
msgstr "# Obrigado!"

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust ü¶Ä!_ We hope you enjoyed it and that it\n"
"was useful."
msgstr ""
"_Obrigado por fazer o Comprehensive Rust ü¶Ä!_ Esperamos que tenha gostado e que\n"
"tenha sido √∫til."

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would love\n"
"to hear from you."
msgstr ""
"N√≥s nos divertimos muito montando o curso. O curso n√£o √© perfeito,\n"
"portanto, se voc√™ identificou algum erro ou tem ideias para melhorias, entre em\n"
"[entre em contato conosco em\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). N√≥s adorar√≠amos\n"
"ouvir voc√™."

#: src/other-resources.md:1
msgid "# Other Rust Resources"
msgstr "# Outros recursos de Rust"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr ""
"A comunidade Rust tem abund√¢ncia de recursos gratuitos e de alta qualidade\n"
"on-line."

#: src/other-resources.md:6
msgid "## Official Documentation"
msgstr "## Documenta√ß√£o Oficial"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "O projeto Rust hospeda muitos recursos. Estes cobrem Rust em geral:"

#: src/other-resources.md:10
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the Rust\n"
"  syntax via a series of examples which showcase different constructs. Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [A Linguagem de Programa√ß√£o Rust](https://doc.rust-lang.org/book/): o\n"
"  livro gratuito can√¥nico sobre Rust. Abrange o idioma em detalhes e inclui alguns\n"
"  projetos para as pessoas constru√≠rem.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): abrange a sintaxe de Rust\n"
"  por meio de uma s√©rie de exemplos que mostram diferentes constru√ß√µes. As vezes\n"
"  inclui pequenos exerc√≠cios onde voc√™ √© solicitado a expandir o c√≥digo dos\n"
"  exemplos.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): documenta√ß√£o completa da\n"
"  biblioteca padr√£o para Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): um livro incompleto\n"
"  que descreve a gram√°tica Rust e o modelo de mem√≥ria."

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Mais guias especializados hospedados no site oficial do Rust:"

#: src/other-resources.md:24
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [O Rustonomicon](https://doc.rust-lang.org/nomicon/): cobre Rust inseguro,\n"
"  incluindo trabalhar com ponteiros brutos e fazer interface com outras linguagens\n"
"  (FFI).\n"
"* [Programa√ß√£o ass√≠ncrona em Rust](https://rust-lang.github.io/async-book/):\n"
"  abrange o novo modelo de programa√ß√£o ass√≠ncrona que foi introduzido ap√≥s o\n"
"  Rust Book ser escrito.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): uma\n"
"  introdu√ß√£o ao uso do Rust em dispositivos embarcados sem um sistema operacional."

#: src/other-resources.md:33
msgid "## Unofficial Learning Material"
msgstr "## Material de aprendizagem n√£o oficial"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Uma pequena sele√ß√£o de outros guias e tutoriais para Rust:"

#: src/other-resources.md:37
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): a\n"
"  series of small presentations covering both basic and advanced part of the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and the\n"
"  second is a set of 11 modules which covers Rust syntax and basic constructs."
msgstr ""
"* [Aprenda Rust da maneira perigosa](http://cliffle.com/p/dangerust/): cobre Rust\n"
"  da perspectiva de programadores C de baixo n√≠vel.\n"
"* [Rust para Programadores Embedded C](https://docs.opentitan.org/doc/ug/rust_for_c/):\n"
"  cobre Rust da perspectiva dos desenvolvedores que escrevem firmware em C.\n"
"* [Rust para profissionais](https://overexact.com/rust-for-professionals/):\n"
"  cobre a sintaxe do Rust usando compara√ß√µes lado a lado com outras linguagens\n"
"  como C, C++, Java, JavaScript e Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): mais de 100 exerc√≠cios para ajudar\n"
"  voc√™ aprende Rust.\n"
"* [Ensino Ferroso\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): uma\n"
"  s√©rie de pequenas apresenta√ß√µes abrangendo tanto a parte b√°sica quanto a avan√ßada da\n"
"  Linguagem Rust. Outros t√≥picos como WebAssembly e async/await tamb√©m s√£o\n"
"  abordados.\n"
"* [S√©rie Iniciante a\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) e\n"
"  [D√™ seus primeiros passos com\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): dois\n"
"  guias Rust voltados para novos desenvolvedores. O primeiro √© um conjunto de 35 v√≠deos e o\n"
"  o segundo √© um conjunto de 11 m√≥dulos que cobrem a sintaxe Rust e as constru√ß√µes b√°sicas."

#: src/other-resources.md:59
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) for\n"
"even more Rust books."
msgstr ""
"Consulte o [Little Book of Rust Books](https://lborb.github.io/book/) para\n"
"ainda mais livros Rust."

#: src/credits.md:1
msgid "# Credits"
msgstr "# Cr√©ditos"

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of useful\n"
"resources."
msgstr ""
"O material aqui se baseia em muitas fontes excelentes de documenta√ß√£o do Rust.\n"
"Consulte a p√°gina em [outros recursos](outros-recursos.md) para obter uma lista completa de recursos √∫teis\n."

#: src/credits.md:7
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache 2.0\n"
"license, please see [`LICENSE`](../LICENSE) for details."
msgstr ""
"O material do Comprehensive Rust √© licenciado sob os termos da licen√ßa Apache 2.0\n"
", consulte [`LICENSE`](../LICENSE) para obter detalhes."

#: src/credits.md:10
msgid "## Rust by Example"
msgstr "## Rust by Example"

#: src/credits.md:12
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"Alguns exemplos e exerc√≠cios foram copiados e adaptados de [Rust by\n"
"Exemplo](https://doc.rust-lang.org/rust-by-example/). por favor veja o\n"
"diret√≥rio `third_party/rust-by-example/` para detalhes, incluindo os termos de\n"
"licen√ßa."

#: src/credits.md:17
msgid "## Rust on Exercism"
msgstr "## Rust on Exercism"

#: src/credits.md:19
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the license\n"
"terms."
msgstr ""
"Alguns exerc√≠cios foram copiados e adaptados de [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). por favor veja o\n"
"diret√≥rio `third_party/rust-on-exercism/` para obter detalhes, incluindo os termos\n"
"licen√ßa."

#: src/credits.md:24
msgid "## CXX"
msgstr "## CXX"

#: src/credits.md:26
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` directory\n"
"for details, including the license terms."
msgstr ""
"A se√ß√£o [Interoperability with C++](android/interoperability/cpp.md) usa uma\n"
"imagem de [CXX](https://cxx.rs/). Consulte o diret√≥rio `third_party/cxx/`\n"
"para obter detalhes, incluindo os termos da licen√ßa."

#: src/exercises/solutions.md:1
msgid "# Solutions"
msgstr "# Solu√ß√µes"

#: src/exercises/solutions.md:3
msgid "You will find solutions to the exercises on the following pages."
msgstr "Voc√™ encontrar√° solu√ß√µes para os exerc√≠cios nas p√°ginas seguintes."

#: src/exercises/solutions.md:5
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"Sinta-se √† vontade para fazer perguntas sobre as solu√ß√µes [no\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Nos informe\n"
"se voc√™ tiver uma solu√ß√£o diferente ou melhor do que a apresentada aqui."

#: src/exercises/solutions.md:10
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **Nota:** Ignore os coment√°rios `// ANCHOR: label` e `// ANCHOR_END: label`\n"
"> que voc√™ v√™ nas solu√ß√µes. Eles est√£o l√° para tornar poss√≠vel\n"
"> reutilizar partes das solu√ß√µes como exerc√≠cios."

#: src/exercises/day-1/solutions-morning.md:1
msgid "# Day 1 Morning Exercises"
msgstr "# Dia 1 Exerc√≠cios matinais"

#: src/exercises/day-1/solutions-morning.md:3
msgid "## Arrays and `for` Loops"
msgstr "## Vetores e la√ßos `for`"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "([voltar ao exerc√≠cio](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7 src/exercises/day-1/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-morning.md:7 src/exercises/day-2/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-afternoon.md:102 src/exercises/day-3/solutions-morning.md:7
#: src/exercises/day-3/solutions-afternoon.md:7 src/exercises/day-4/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."
msgstr ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."

#: src/exercises/day-1/solutions-morning.md:22
msgid ""
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"// ANCHOR: transpose\n"
"fn transposta(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut resultado = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            resultado[j][i] = matriz[i][j];\n"
"        }\n"
"    }\n"
"    return resultado;\n"
"}"

#: src/exercises/day-1/solutions-morning.md:34
msgid ""
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}"
msgstr ""
"// ANCHOR: pretty_print\n"
"fn impressao_formatada(matriz: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for linha in matriz {\n"
"        println!(\"{linha:?}\");\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-morning.md:42
msgid ""
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests"
msgstr ""
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transposta() {\n"
"    let matriz = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let matriz_transposta = transposta(matriz);\n"
"    assert_eq!(\n"
"        matriz_transposta,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests"

#: src/exercises/day-1/solutions-morning.md:62
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let matriz = [\n"
"        [101, 102, 103], // <-- o coment√°rio faz com que o rustfmt adicione uma nova linha\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"

#: src/exercises/day-1/solutions-morning.md:73
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```\n"
"### Bonus question"
msgstr ""
"    let matriz_transposta = transposta(matriz);\n"
"    println!(\"Transposta:\");\n"
"    impressao_formatada(&matriz_transposta);\n"
"}\n"
"```\n"
"### Pergunta b√¥nus"

#: src/exercises/day-1/solutions-morning.md:80
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-of-slices (`&[&[i32]]`) as the input type to "
"transpose and thus make our function handle any size of matrix. However, this quickly breaks down: the return type cannot "
"be `&[&[i32]]` since it needs to own the data you return."
msgstr ""
"Isso necessita a utiliza√ß√£o de conceitos mais avan√ßados. Pode parecer que poder√≠amos usar uma slice de slices (`&[&[i32]]`) como o tipo de "
"entrada para `transposta` e, assim, fazer nossa fun√ß√£o lidar com qualquer tamanho de matriz. No entanto, isso falha "
"rapidamente: o tipo de retorno n√£o pode ser `&[&[i32]]`, pois ele precisa possuir os dados que voc√™ retorna."

#: src/exercises/day-1/solutions-morning.md:82
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work out-of-the-box either: it's hard to convert "
"from `Vec<Vec<i32>>` to `&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"Voc√™ pode tentar usar algo como `Vec<Vec<i32>>`, mas isso tamb√©m n√£o funciona muito bem: √© dif√≠cil converter de "
"`Vec<Vec<i32>>` para `&[&[i32]] ` ent√£o agora voc√™ tamb√©m n√£o pode usar `impressao_formatada` facilmente."

#: src/exercises/day-1/solutions-morning.md:84
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::AsRef`][1] trait to abstract over anything "
"that can be referenced as a slice."
msgstr ""
"Assim que chegarmos aos _traits_ and _generics_, podemos usar o _trait_ [`std::convert::AsRef`][1] para abstrair qualquer coisa\n"
"que pode ser referenciada como um _slice_."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;"
msgstr ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;"

#: src/exercises/day-1/solutions-morning.md:90
msgid ""
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}"
msgstr ""
"fn impressao_formatada<T, Linha, Matriz>(matriz: Matriz)\n"
"where\n"
"    T: Debug,\n"
"    // Linha referencia uma slice de itens\n"
"    Linha: AsRef<[T]>,\n"
"    // Matriz referencia uma slice de linhas\n"
"    Matriz: AsRef<[Linha]>\n"
"{\n"
"    for linha in matriz.as_ref() {\n"
"        println!(\"{:?}\", linha.as_ref());\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-morning.md:103
msgid ""
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    // &[&[i32]]\n"
"    impressao_formatada(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    impressao_formatada([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    impressao_formatada(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"

#: src/exercises/day-1/solutions-morning.md:113
msgid ""
"In addition, the type itself would not enforce that the child slices are of the same length, so such variable could contain "
"an invalid matrix."
msgstr ""
"Al√©m disso, o pr√≥prio tipo n√£o imporia que as slices filhas tenham o mesmo comprimento, portanto, tal vari√°vel poderia "
"conter uma matriz inv√°lida."

#: src/exercises/day-1/solutions-morning.md:115
msgid "[1]: https://doc.rust-lang.org/std/convert/trait.AsRef.html"
msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#: src/exercises/day-1/solutions-afternoon.md:1
msgid "# Day 1 Afternoon Exercises"
msgstr "# Dia 1 Exerc√≠cios da Tarde"

#: src/exercises/day-1/solutions-afternoon.md:3
msgid "## Designing a Library"
msgstr "## Projetando uma biblioteca"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](book-library.md))"
msgstr "([voltar ao exerc√≠cio](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:22
msgid ""
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""
"// ANCHOR: configura√ß√£o\n"
"struct Biblioteca {\n"
"    livros: Vec<Livro>,\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:42
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}\n"
"// ANCHOR_END: setup"
msgstr ""
"// Isso torna poss√≠vel imprimir valores de livros com {}.\n"
"impl std::fmt::Display for Livro {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.titulo, self.ano)\n"
"    }\n"
"}\n"
"// ANCHOR_END: Configura√ß√£o"

#: src/exercises/day-1/solutions-afternoon.md:50
msgid ""
"// ANCHOR: Library_new\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }"
msgstr ""
"impl Biblioteca {\n"
"    // ANCHOR: Library_new\n"
"    fn new() -> Biblioteca {\n"
"        // ANCHOR_END: Library_new\n"
"        Biblioteca { livros: Vec::new() }\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:57
msgid ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }"
msgstr ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    // unimplemented!()\n"
"    ///}\n"
"    // ANCHOR_END: Library_len\n"
"    fn tamanho(&self) -> usize {\n"
"        self.livros.len()\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:66
msgid ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"
msgstr ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    // unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn esta_vazia(&self) -> bool {\n"
"        self.livros.is_empty()\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:75
msgid ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }"
msgstr ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    // unimplemented!()\n"
"    ///}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn adiciona_livro(&mut self, livro: Livro) {\n"
"        self.livros.push(livro)\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:84
msgid ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}\", book);\n"
"        }\n"
"    }"
msgstr ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    // unimplemented!()\n"
"    ///}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn imprime_livros(&self) {\n"
"        for livro in &self.livros {\n"
"            println!(\"{}\", livro);\n"
"        }\n"
"    }"

#: src/exercises/day-1/solutions-afternoon.md:95
msgid ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        self.books.iter().min_by_key(|book| book.year)\n"
"    }\n"
"}"
msgstr ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    // n√£o implementado!()\n"
"    ///}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn livro_mais_antigo(&self) -> Option<&Livro> {\n"
"        self.livros.iter().min_by_key(|livro| livro.ano)\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:105
msgid ""
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""
"// ANCHOR: main\n"
"// Isso mostra o comportamento desejado. Descomente o c√≥digo abaixo e\n"
"// implementa os m√©todos ausentes. Voc√™ precisar√° atualizar o\n"
"// assinaturas de m√©todo, incluindo o par√¢metro \"self\"! Voc√™ pode\n"
"// tamb√©m precisa atualizar as liga√ß√µes de vari√°veis dentro de main.\n"
"fn main() {\n"
"    let mut biblioteca = Biblioteca::new();"

#: src/exercises/day-1/solutions-afternoon.md:113
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"// ANCHOR_END: main"
msgstr ""
"    //println!(\"Nossa biblioteca est√° vazia: {}\", biblioteca.esta_vazia());\n"
"    //\n"
"    //biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
"    //biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", 1865));\n"
"    //\n"
"    //biblioteca.imprime_livros();\n"
"    //\n"
"    //match biblioteca.livro_mais_antigo() {\n"
"    // Some(livro) => println!(\"Meu livro mais antigo √© {livro}\"),\n"
"    // None => println!(\"Minha biblioteca est√° vazia!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Nossa biblioteca tem {} livros\", biblioteca.tamanho());\n"
"}\n"
"// ANCHOR_END: main"

#: src/exercises/day-1/solutions-afternoon.md:129
msgid ""
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());"
msgstr ""
"#[test]\n"
"fn test_tamanho_biblioteca() {\n"
"    let mut biblioteca = Biblioteca::new();\n"
"    assert_eq!(biblioteca.tamanho(), 0);\n"
"    assert!(biblioteca.esta_vazia());"

#: src/exercises/day-1/solutions-afternoon.md:135
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""
"    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
"    biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", 1865));\n"
"    assert_eq!(biblioteca.tamanho(), 2);\n"
"    assert!(!biblioteca.esta_vazia());\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:141
msgid ""
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());"
msgstr ""
"#[test]\n"
"fn test_biblioteca_esta_vazia() {\n"
"    let mut biblioteca = Biblioteca::new();\n"
"    assert!(biblioteca.esta_vazia());"

#: src/exercises/day-1/solutions-afternoon.md:146
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""
"    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
"    assert!(!biblioteca.esta_vazia());\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:150
msgid ""
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}"
msgstr ""
"#[test]\n"
"fn test_biblioteca_imprime_livros() {\n"
"    let mut biblioteca = Biblioteca::new();\n"
"    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
"    biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", 1865));\n"
"    // Poder√≠amos tentar capturar stdout, mas vamos apenas chamar o\n"
"    // m√©todo para come√ßar.\n"
"    biblioteca.imprime_livros();\n"
"}"

#: src/exercises/day-1/solutions-afternoon.md:160
msgid ""
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());"
msgstr ""
"#[test]\n"
"fn test_biblioteca_livro_mais_antigo() {\n"
"    let mut biblioteca = Biblioteca::new();\n"
"    assert!(biblioteca.livro_mais_antigo().is_none());"

#: src/exercises/day-1/solutions-afternoon.md:165
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );"
msgstr ""
"    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
"    assert_eq!(\n"
"        biblioteca.livro_mais_antigo().map(|b| b.titulo.as_str()),\n"
"        Some(\"O Senhor dos An√©is\")\n"
"    );"

#: src/exercises/day-1/solutions-afternoon.md:171
msgid ""
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""
"    biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", 1865));\n"
"    assert_eq!(\n"
"        biblioteca.livro_mais_antigo().map(|b| b.titulo.as_str()),\n"
"        Some(\"As Aventuras de Alice no Pa√≠s das Maravilhas\")\n"
"    );\n"
"}\n"
"```"

#: src/exercises/day-2/solutions-morning.md:1
msgid "# Day 2 Morning Exercises"
msgstr "# Dia 2 Exerc√≠cios matinais"

#: src/exercises/day-2/solutions-morning.md:3
msgid "## Points and Polygons"
msgstr "## Pontos e Pol√≠gonos"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](points-polygons.md))"
msgstr "([voltar ao exerc√≠cio](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:22
msgid ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"
msgstr ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Ponto {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:30
msgid ""
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }"
msgstr ""
"// ANCHOR: Point-impl\n"
"impl Ponto {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Ponto {\n"
"        Ponto { x, y }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:37
msgid ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"
msgstr ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:41
msgid ""
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}"
msgstr ""
"    pub fn dist(self, outro: Ponto) -> f64 {\n"
"        (self - outro).magnitude()\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:49
msgid ""
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"    fn add(self, outro: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + outro.x,\n"
"            y: self.y + outro.y,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:57
msgid ""
"impl std::ops::Sub for Point {\n"
"    type Output = Self;"
msgstr ""
"impl std::ops::Sub for Ponto {\n"
"    type Output = Self;"

#: src/exercises/day-2/solutions-morning.md:60
msgid ""
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"    fn sub(self, outro: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - outro.x,\n"
"            y: self.y - outro.y,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:68
msgid ""
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}"
msgstr ""
"// ANCHOR: Polygon\n"
"pub struct Poligono {\n"
"    // ANCHOR_END: Polygon\n"
"    pontos: Vec<Ponto>,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:74
msgid ""
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }"
msgstr ""
"// ANCHOR: Polygon-impl\n"
"impl Poligono {\n"
"    pub fn new() -> Poligono {\n"
"        Poligono { pontos: Vec::new() }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:81
msgid ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }"
msgstr ""
"    pub fn adiciona_ponto(&mut self, ponto: Ponto) {\n"
"        self.pontos.push(ponto);\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:85
msgid ""
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"
msgstr ""
"    pub fn ponto_mais_a_esquerda(&self) -> Option<Ponto> {\n"
"        self.pontos.iter().min_by_key(|p| p.x).copied()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:89
msgid ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }"
msgstr ""
"    pub fn iter(&self) -> impl Iterator<Item = &Ponto> {\n"
"        self.pontos.iter()\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:93
msgid ""
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }"
msgstr ""
"    pub fn comprimento(&self) -> f64 {\n"
"        if self.pontos.is_empty() {\n"
"            return 0.0;\n"
"        }"

#: src/exercises/day-2/solutions-morning.md:98
msgid ""
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}"
msgstr ""
"        let mut resultado = 0.0;\n"
"        let mut ultimo_ponto = self.pontos[0];\n"
"        for ponto in &self.pontos[1..] {\n"
"            resultado += ultimo_ponto.dist(*ponto);\n"
"            ultimo_ponto = *ponto;\n"
"        }\n"
"        resultado += ultimo_ponto.dist(self.pontos[0]);\n"
"        resultado\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:109
msgid ""
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}"
msgstr ""
"// ANCHOR: Circle\n"
"pub struct Circulo {\n"
"    // ANCHOR_END: Circle\n"
"    centro: Ponto,\n"
"    raio: i32,\n"
"}"

#: src/exercises/day-2/solutions-morning.md:116
msgid ""
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }"
msgstr ""
"// ANCHOR: Circle-impl\n"
"impl Circulo {\n"
"    pub fn new(centro: Ponto, raio: i32) -> Circulo {\n"
"        Circulo { centro, raio }\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:123
msgid ""
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"
msgstr ""
"    pub fn circunferencia(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.raio)\n"
"    }"

#: src/exercises/day-2/solutions-morning.md:127
msgid ""
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}"
msgstr ""
"    pub fn dist(&self, outro: &Self) -> f64 {\n"
"        self.centro.dist(outro.centro)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:132
msgid ""
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape"
msgstr ""
"// ANCHOR: Shape\n"
"pub enum Forma {\n"
"    Poligono(Poligono),\n"
"    Circulo(Circulo),\n"
"}\n"
"// ANCHOR_END: Shape"

#: src/exercises/day-2/solutions-morning.md:139
msgid ""
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}"
msgstr ""
"impl From<Poligono> for Forma {\n"
"    fn from(poli: Poligono) -> Self {\n"
"        Forma::Poligono(poli)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:145
msgid ""
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}"
msgstr ""
"impl From<Circulo> for Forma {\n"
"    fn from(circulo: Circulo) -> Self {\n"
"        Forma::Circulo(circulo)\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:151
msgid ""
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Forma {\n"
"    pub fn perimetro(&self) -> f64 {\n"
"        match self {\n"
"            Forma::Poligono(poli) => poli.comprimento(),\n"
"            Forma::Circulo(circulo) => circulo.circunferencia(),\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-2/solutions-morning.md:160
msgid ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"

#: src/exercises/day-2/solutions-morning.md:213
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""
"    #[test]\n"
"    fn test_forma_perimetros() {\n"
"        let mut poli = Poligono::new();\n"
"        poli.adiciona_ponto(Ponto::new(12, 13));\n"
"        poli.adiciona_ponto(Ponto::new(17, 11));\n"
"        poli.adiciona_ponto(Ponto::new(16, 16));\n"
"        let formas = vec![\n"
"            Forma::from(poli),\n"
"            Forma::from(Circulo::new(Ponto::new(10, 20), 5)),\n"
"        ];\n"
"        let perimetros = formas\n"
"            .iter()\n"
"            .map(Forma::perimetro)\n"
"            .map(arredonda_dois_digitos)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimetros, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"

#: src/exercises/day-2/solutions-morning.md:233 src/exercises/day-2/solutions-afternoon.md:174
msgid ""
"fn main() {}\n"
"```"
msgstr ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:1
msgid "# Day 2 Afternoon Exercises"
msgstr "# Dia 2 Exerc√≠cios da Tarde"

#: src/exercises/day-2/solutions-afternoon.md:3
msgid "## Luhn Algorithm"
msgstr "## Algoritmo de Luhn"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr "([voltar ao exerc√≠cio](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:22
msgid ""
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"
msgstr ""
"// ANCHOR: luhn\n"
"pub fn luhn(numero_cc: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digitos_vistos = 0;\n"
"    let mut soma = 0;\n"
"    for (i, ch) in numero_cc.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                soma += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digitos_vistos += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"

#: src/exercises/day-2/solutions-afternoon.md:42
msgid ""
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }"
msgstr ""
"    if digitos_vistos < 2 {\n"
"        return false;\n"
"    }"

#: src/exercises/day-2/solutions-afternoon.md:46
msgid ""
"    sum % 10 == 0\n"
"}"
msgstr ""
"    soma % 10 == 0\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:49
msgid ""
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {} a valid credit card number? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}"
msgstr ""
"fn main() {\n"
"    let numero_cc = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"{} √© um n√∫mero de cart√£o de cr√©dito v√°lido? {}\",\n"
"        numero_cc,\n"
"        if luhn(numero_cc) { \"Sim\" } else { \"N√£o\" }\n"
"    );\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:58
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_numero_cc_nao_numerico() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:89
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""
"#[test]\n"
"fn test_numero_cc_invalido() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"

#: src/exercises/day-2/solutions-afternoon.md:98
msgid "## Strings and Iterators"
msgstr "## Strings e iteradores"

#: src/exercises/day-2/solutions-afternoon.md:100
msgid "([back to exercise](strings-iterators.md))"
msgstr "([voltar ao exerc√≠cio](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:117
msgid ""
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"
msgstr ""
"// ANCHOR: prefix_matches\n"
"pub fn correspondencia_prefixo(prefixo: &str, caminho_requisitado: &str) -> bool {\n"
"// ANCHOR_END: prefix_matches\n"
"    let prefixos = prefixo.split('/');\n"
"    let caminhos_requisitados = caminho_requisitado\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"

#: src/exercises/day-2/solutions-afternoon.md:126
msgid ""
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"
msgstr ""
"    for (prefixo, caminho_requisitado) in prefixos.zip(caminhos_requisitados) {\n"
"        match caminho_requisitado {\n"
"            Some(caminho_requisitado) => {\n"
"                if (prefixo != \"*\") && (prefixo != caminho_requisitado) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"

#: src/exercises/day-2/solutions-afternoon.md:139
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(correspondencia_prefixo(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(correspondencia_prefixo(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(correspondencia_prefixo(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"

#: src/exercises/day-2/solutions-afternoon.md:166
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""
"    assert!(!correspondencia_prefixo(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!correspondencia_prefixo(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests"

#: src/exercises/day-3/solutions-morning.md:1
msgid "# Day 3 Morning Exercise"
msgstr "# Dia 3 Exerc√≠cio matinal"

#: src/exercises/day-3/solutions-morning.md:3
msgid "## A Simple GUI Library"
msgstr "## Uma biblioteca GUI simples"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr "([voltar ao exerc√≠cio](simples-gui.md))"

#: src/exercises/day-3/solutions-morning.md:22
msgid ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"

#: src/exercises/day-3/solutions-morning.md:82
msgid "// ANCHOR_END: setup"
msgstr "// ANCHOR_END: setup"

#: src/exercises/day-3/solutions-morning.md:84
msgid ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"
msgstr ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:94
msgid ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"
msgstr ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"

#: src/exercises/day-3/solutions-morning.md:102
msgid "        let window_width = self.width();"
msgstr "        let window_width = self.width();"

#: src/exercises/day-3/solutions-morning.md:104
msgid ""
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""
"        // TODO: depois de aprender sobre tratamento de erros, voc√™ pode alterar\n"
"        // draw_into para retornar Result<(), std::fmt::Error>. Ent√£o use\n"
"        // o operador ? aqui em vez de .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:117
msgid ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }"
msgstr ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:124
msgid ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"
msgstr ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"

#: src/exercises/day-3/solutions-morning.md:131
msgid ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:139
msgid ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"
msgstr ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"

#: src/exercises/day-3/solutions-morning.md:150
msgid ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"
msgstr ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-morning.md:157
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"Esta √© uma pequena demonstra√ß√£o de GUI de texto.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Clique em mim!\",\n"
"        Box::new(|| println!(\"Voc√™ clicou no bot√£o!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"

#: src/exercises/day-3/solutions-afternoon.md:1
msgid "# Day 3 Afternoon Exercises"
msgstr "# Dia 3 Exerc√≠cios da Tarde"

#: src/exercises/day-3/solutions-afternoon.md:3
msgid "## Safe FFI Wrapper"
msgstr "## Wrapper FFI Seguro"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([voltar ao exerc√≠cio](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:22
msgid ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#: src/exercises/day-3/solutions-afternoon.md:53
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"
msgstr ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"

#: src/exercises/day-3/solutions-afternoon.md:60
msgid ""
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: {err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Caminho inv√°lido: {err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"N√£o foi poss√≠vel abrir {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-afternoon.md:77
msgid ""
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}"
msgstr ""
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-afternoon.md:97
msgid ""
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"N√£o foi poss√≠vel fechar {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-3/solutions-afternoon.md:111
msgid ""
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"Arquivos: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"```"

#: src/exercises/day-4/solutions-morning.md:1
msgid "# Day 4 Morning Exercise"
msgstr "# Dia 4 Exerc√≠cio matinal"

#: src/exercises/day-4/solutions-morning.md:3
msgid "## Dining Philosophers"
msgstr "## Fil√≥sofos jantando"

#: src/exercises/day-4/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([voltar ao exerc√≠cio](dining-philosophers.md))"

#: src/exercises/day-4/solutions-morning.md:22
msgid ""
"// ANCHOR: Philosopher\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""
"// ANCHOR: Philosopher\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"

#: src/exercises/day-4/solutions-morning.md:30
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}"
msgstr ""
"struct Filosofo {\n"
"    nome: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    garfo_esquerda: Arc<Mutex<Garfo>>,\n"
"    garfo_direita: Arc<Mutex<Garfo>>,\n"
"    pensamentos: mpsc::SyncSender<String>,\n"
"}"

#: src/exercises/day-4/solutions-morning.md:38
msgid ""
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think"
msgstr ""
"// ANCHOR: Philosopher-think\n"
"impl Filosofo {\n"
"    fn pensar(&self) {\n"
"        self.pensamentos\n"
"            .send(format!(\"Eureka! {} teve uma nova ideia!\", &self.nome))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think"

#: src/exercises/day-4/solutions-morning.md:47
msgid ""
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();"
msgstr ""
"    // ANCHOR: Philosopher-eat\n"
"    fn comer(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} est√° tentando comer\", &self.nome);\n"
"        let _esquerda = self.garfo_esquerda.lock().unwrap();\n"
"        let _direita = self.garfo_direita.lock().unwrap();"

#: src/exercises/day-4/solutions-morning.md:54
msgid ""
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} est√° comendo...\", &self.nome);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"

#: src/exercises/day-4/solutions-morning.md:63
msgid ""
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);"
msgstr ""
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);"

#: src/exercises/day-4/solutions-morning.md:67
msgid ""
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();"
msgstr ""
"    let garfos = (0..FILOSOFOS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Garfo)))\n"
"        .collect::<Vec<_>>();"

#: src/exercises/day-4/solutions-morning.md:71
msgid ""
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();"
msgstr ""
"    for i in 0..garfos.len() {\n"
"        let tx = tx.clone();\n"
"        let mut garfo_esquerda = garfos[i].clone();\n"
"        let mut garfo_direita = garfos[(i + 1) % garfos.len()].clone();"

#: src/exercises/day-4/solutions-morning.md:76
msgid ""
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }"
msgstr ""
"        // Para evitar um impasse, temos que quebrar a simetria\n"
"        // algum lugar. Isso ir√° trocar os garfos sem desinicializar\n"
"        // qualquer um deles.\n"
"        if i == garfos.len() - 1 {\n"
"            std::mem::swap(&mut garfo_esquerda, &mut garfo_direita);\n"
"        }"

#: src/exercises/day-4/solutions-morning.md:83
msgid ""
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };"
msgstr ""
"        let filosofo = Filosofo {\n"
"            nome: FILOSOFOS[i].to_string(),\n"
"            pensamentos: tx,\n"
"            garfo_esquerda,\n"
"            garfo_direita,\n"
"        };"

#: src/exercises/day-4/solutions-morning.md:90
msgid ""
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }"
msgstr ""
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                filosofo.comer();\n"
"                filosofo.pensar();\n"
"            }\n"
"        });\n"
"    }"

#: src/exercises/day-4/solutions-morning.md:98
msgid ""
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    drop(tx);\n"
"    for pensamento in rx {\n"
"        println!(\"{pensamento}\");\n"
"    }\n"
"}\n"
"```"

#~ msgid ""
#~ "* `Box` is like `std::unique_ptr` in C++.\n"
#~ "* In the above example, you can even leave out the `*` in the `println!` statement thanks to `Deref`."
#~ msgstr ""
#~ "* `Box` √© como `std::unique_ptr` em C++.\n"
#~ "* No exemplo acima, voc√™ pode at√© deixar de fora o `*` na declara√ß√£o `println!` gra√ßas a `Deref`."

