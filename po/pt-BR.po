msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust ü¶Ä\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-07-07 14:39-0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust ü¶Ä"
msgstr "Bem-vindo ao Comprehensive Rust ü¶Ä"

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "Conduzindo o Curso"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "Estrutura do Curso"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "Atalhos de Teclado"

#: src/SUMMARY.md:7
msgid "Translations"
msgstr "Tradu√ß√µes"

#: src/SUMMARY.md:8
msgid "Using Cargo"
msgstr "Usando o Cargo"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "O Ecossistema do Rust"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "Amostras de C√≥digo"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "Executando o Cargo Localmente"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "Dia 1: Manh√£"

#: src/SUMMARY.md:18 src/SUMMARY.md:75 src/SUMMARY.md:128 src/SUMMARY.md:185 src/SUMMARY.md:211
#: src/SUMMARY.md:261
msgid "Welcome"
msgstr "Bem-vindo"

#: src/SUMMARY.md:19
msgid "What is Rust?"
msgstr "O que √© Rust?"

#: src/SUMMARY.md:20
msgid "Hello World!"
msgstr "Ol√° Mundo!"

#: src/SUMMARY.md:21
msgid "Small Example"
msgstr "Um Pequeno Exemplo"

#: src/SUMMARY.md:22
msgid "Why Rust?"
msgstr "Por que Rust?"

#: src/SUMMARY.md:23
msgid "Compile Time Guarantees"
msgstr "Garantias em Tempo de Compila√ß√£o"

#: src/SUMMARY.md:24
msgid "Runtime Guarantees"
msgstr "Garantias em Tempo de Execu√ß√£o"

#: src/SUMMARY.md:25
msgid "Modern Features"
msgstr "Recursos Modernos"

#: src/SUMMARY.md:26
msgid "Basic Syntax"
msgstr "Sintaxe B√°sica"

#: src/SUMMARY.md:27
msgid "Scalar Types"
msgstr "Tipos Escalares"

#: src/SUMMARY.md:28
msgid "Compound Types"
msgstr "Tipos Compostos"

#: src/SUMMARY.md:29
msgid "References"
msgstr "Refer√™ncias"

#: src/SUMMARY.md:30
msgid "Dangling References"
msgstr "Refer√™ncias Soltas"

#: src/SUMMARY.md:31
msgid "Slices"
msgstr "Slices"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "String vs str"

#: src/SUMMARY.md:33
msgid "Functions"
msgstr "Fun√ß√µes"

#: src/SUMMARY.md:34
msgid "Rustdoc"
msgstr ""

#: src/SUMMARY.md:35 src/SUMMARY.md:82
msgid "Methods"
msgstr "M√©todos"

#: src/SUMMARY.md:36
msgid "Overloading"
msgstr "Sobrecarga"

#: src/SUMMARY.md:37 src/SUMMARY.md:66 src/SUMMARY.md:90 src/SUMMARY.md:119
#: src/SUMMARY.md:148 src/SUMMARY.md:177 src/SUMMARY.md:204 src/SUMMARY.md:225
#: src/SUMMARY.md:251 src/SUMMARY.md:273 src/SUMMARY.md:294
msgid "Exercises"
msgstr "Exerc√≠cios"

#: src/SUMMARY.md:38
msgid "Implicit Conversions"
msgstr "Convers√µes Impl√≠citas"

#: src/SUMMARY.md:39
msgid "Arrays and for Loops"
msgstr "Vetores e La√ßos For"

#: src/SUMMARY.md:41
msgid "Day 1: Afternoon"
msgstr "Dia 1: Tarde"

#: src/SUMMARY.md:43
msgid "Variables"
msgstr "Vari√°veis"

#: src/SUMMARY.md:44
msgid "Type Inference"
msgstr "Infer√™ncia de Tipo"

#: src/SUMMARY.md:45
msgid "static & const"
msgstr "Vari√°veis Est√°ticas e Constantes"

#: src/SUMMARY.md:46
msgid "Scopes and Shadowing"
msgstr "Escopos e Sobreposi√ß√£o"

#: src/SUMMARY.md:47
msgid "Memory Management"
msgstr "Gerenciamento de Mem√≥ria"

#: src/SUMMARY.md:48
msgid "Stack vs Heap"
msgstr "Stack vs Heap"

#: src/SUMMARY.md:49
msgid "Stack Memory"
msgstr "Mem√≥ria de Pilha"

#: src/SUMMARY.md:50
msgid "Manual Memory Management"
msgstr "Gerenciamento Manual de Mem√≥ria"

#: src/SUMMARY.md:51
msgid "Scope-Based Memory Management"
msgstr "Gerenciamento de Mem√≥ria Baseado em Escopo"

#: src/SUMMARY.md:52
msgid "Garbage Collection"
msgstr "Garbage Collection (Coletor de lixo)"

#: src/SUMMARY.md:53
msgid "Rust Memory Management"
msgstr "Gerenciamento de Mem√≥ria do Rust"

#: src/SUMMARY.md:54
msgid "Comparison"
msgstr "Compara√ß√£o"

#: src/SUMMARY.md:55
msgid "Ownership"
msgstr "Ownership"

#: src/SUMMARY.md:56
msgid "Move Semantics"
msgstr "Sem√¢ntica do move (mover)"

#: src/SUMMARY.md:57
msgid "Moved Strings in Rust"
msgstr "Strings Movidas em Rust"

#: src/SUMMARY.md:58
msgid "Double Frees in Modern C++"
msgstr "Libera√ß√µes Duplas em C++ Moderno"

#: src/SUMMARY.md:59
msgid "Moves in Function Calls"
msgstr "Move em Chamadas de Fun√ß√£o"

#: src/SUMMARY.md:60
msgid "Copying and Cloning"
msgstr "Copia e Clonagem"

#: src/SUMMARY.md:61
msgid "Borrowing"
msgstr "Empr√©stimo"

#: src/SUMMARY.md:62
msgid "Shared and Unique Borrows"
msgstr "Empr√©stimos Compartilhados e √önicos"

#: src/SUMMARY.md:63
msgid "Lifetimes"
msgstr "Tempos de Vida (Lifetimes)"

#: src/SUMMARY.md:64
msgid "Lifetimes in Function Calls"
msgstr "Tempos de vida (Lifetimes) em Chamadas de Fun√ß√£o"

#: src/SUMMARY.md:65
msgid "Lifetimes in Data Structures"
msgstr "Tempos de Vida em Estruturas de Dados"

#: src/SUMMARY.md:67
msgid "Storing Books"
msgstr "Armazenando Livros"

#: src/SUMMARY.md:68
msgid "Iterators and Ownership"
msgstr "Iteradores e Ownership (Posse)"

#: src/SUMMARY.md:71
msgid "Day 2: Morning"
msgstr "Dia 2: Manh√£"

#: src/SUMMARY.md:76
msgid "Structs"
msgstr "Structs"

#: src/SUMMARY.md:77
msgid "Tuple Structs"
msgstr "Structs como Tuplas"

#: src/SUMMARY.md:78
msgid "Field Shorthand Syntax"
msgstr "Sintaxe Abreviada de Campos"

#: src/SUMMARY.md:79
msgid "Enums"
msgstr "Enums"

#: src/SUMMARY.md:80
msgid "Variant Payloads"
msgstr "Conte√∫dos Variantes"

#: src/SUMMARY.md:81
msgid "Enum Sizes"
msgstr "Tamanhos de Enum"

#: src/SUMMARY.md:83
msgid "Method Receiver"
msgstr "Receptor de M√©todo"

#: src/SUMMARY.md:84 src/SUMMARY.md:159 src/SUMMARY.md:274
msgid "Example"
msgstr "Exemplo"

#: src/SUMMARY.md:85
msgid "Pattern Matching"
msgstr "Correspond√™ncia de Padr√µes"

#: src/SUMMARY.md:86
msgid "Destructuring Enums"
msgstr "Desestruturando Enums"

#: src/SUMMARY.md:87
msgid "Destructuring Structs"
msgstr "Desestruturando Structs"

#: src/SUMMARY.md:88
msgid "Destructuring Arrays"
msgstr "Desestruturando Matrizes"

#: src/SUMMARY.md:89
msgid "Match Guards"
msgstr "Guardas de Correspond√™ncia (match)"

#: src/SUMMARY.md:91
msgid "Health Statistics"
msgstr "Estat√≠sticas de Sa√∫de"

#: src/SUMMARY.md:92
msgid "Points and Polygons"
msgstr "Pontos e Pol√≠gonos"

#: src/SUMMARY.md:94
msgid "Day 2: Afternoon"
msgstr "Dia 2: Tarde"

#: src/SUMMARY.md:96 src/SUMMARY.md:288
msgid "Control Flow"
msgstr "Controle de Fluxo"

#: src/SUMMARY.md:97
msgid "Blocks"
msgstr "Blocos"

#: src/SUMMARY.md:98
msgid "if expressions"
msgstr "Express√µes if"

#: src/SUMMARY.md:99
msgid "if let expressions"
msgstr "Express√µes if let"

#: src/SUMMARY.md:100
msgid "while expressions"
msgstr "Loops while"

#: src/SUMMARY.md:101
msgid "while let expressions"
msgstr "Loops while let"

#: src/SUMMARY.md:102
msgid "for expressions"
msgstr "Loops for"

#: src/SUMMARY.md:103
msgid "loop expressions"
msgstr "Express√µes loop"

#: src/SUMMARY.md:104
msgid "match expressions"
msgstr "Express√µes match (Correspond√™ncia)"

#: src/SUMMARY.md:105
msgid "break & continue"
msgstr "break e continue"

#: src/SUMMARY.md:106
msgid "Standard Library"
msgstr "Biblioteca Padr√£o"

#: src/SUMMARY.md:107
msgid "Option and Result"
msgstr "Option e Result"

#: src/SUMMARY.md:108
msgid "String"
msgstr "String"

#: src/SUMMARY.md:109
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:110
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:111
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:112
msgid "Recursive Data Types"
msgstr "Box com Estruturas de Dados Recursivas"

#: src/SUMMARY.md:113
msgid "Niche Optimization"
msgstr "Otimiza√ß√£o de Nicho"

#: src/SUMMARY.md:114
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:115
msgid "Modules"
msgstr "M√≥dulos"

#: src/SUMMARY.md:116
msgid "Visibility"
msgstr "Visibilidade"

#: src/SUMMARY.md:117
msgid "Paths"
msgstr "Caminhos"

#: src/SUMMARY.md:118
msgid "Filesystem Hierarchy"
msgstr "Hierarquia do Sistema de Arquivos"

#: src/SUMMARY.md:120
msgid "Luhn Algorithm"
msgstr "Algoritmo de Luhn"

#: src/SUMMARY.md:121
msgid "Strings and Iterators"
msgstr "Strings e Iteradores"

#: src/SUMMARY.md:124
msgid "Day 3: Morning"
msgstr "Dia 3: Manh√£"

#: src/SUMMARY.md:129
msgid "Generics"
msgstr "Generics"

#: src/SUMMARY.md:130
msgid "Generic Data Types"
msgstr "Tipos de Dados Gen√©ricos"

#: src/SUMMARY.md:131
msgid "Generic Methods"
msgstr "M√©todos Gen√©ricos"

#: src/SUMMARY.md:132
msgid "Monomorphization"
msgstr "Monomorfiza√ß√£o"

#: src/SUMMARY.md:133
msgid "Traits"
msgstr "Traits"

#: src/SUMMARY.md:134
msgid "Trait Objects"
msgstr "Objetos Trait"

#: src/SUMMARY.md:135
msgid "Deriving Traits"
msgstr "Traits Derivados"

#: src/SUMMARY.md:136
msgid "Default Methods"
msgstr "M√©todos Padr√£o"

#: src/SUMMARY.md:137
msgid "Trait Bounds"
msgstr "Limites de trait"

#: src/SUMMARY.md:138
msgid "impl Trait"
msgstr "Trait impl"

#: src/SUMMARY.md:139
msgid "Important Traits"
msgstr "Traits Importantes"

#: src/SUMMARY.md:140
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:141
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:142
msgid "From and Into"
msgstr "From e Into"

#: src/SUMMARY.md:143
msgid "Read and Write"
msgstr "Read e Write"

#: src/SUMMARY.md:144
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:145
msgid "Default"
msgstr "Default"

#: src/SUMMARY.md:146
msgid "Operators: Add, Mul, ..."
msgstr "Operadores: Add, Mul, ..."

#: src/SUMMARY.md:147
msgid "Closures: Fn, FnMut, FnOnce"
msgstr ""

#: src/SUMMARY.md:149
msgid "A Simple GUI Library"
msgstr "Uma Biblioteca GUI Simples"

#: src/SUMMARY.md:151
msgid "Day 3: Afternoon"
msgstr "Dia 3: Tarde"

#: src/SUMMARY.md:153
msgid "Error Handling"
msgstr "Tratamento de Erros"

#: src/SUMMARY.md:154
msgid "Panics"
msgstr "Panics (P√¢nico)"

#: src/SUMMARY.md:155
msgid "Catching Stack Unwinding"
msgstr "Capturando o Desenrolar da Pilha"

#: src/SUMMARY.md:156
msgid "Structured Error Handling"
msgstr "Tratamento Estruturado de Erros"

#: src/SUMMARY.md:157
msgid "Propagating Errors with ?"
msgstr "Propagando Erros com ?"

#: src/SUMMARY.md:158
msgid "Converting Error Types"
msgstr "Convertendo Tipos de Erro"

#: src/SUMMARY.md:160
msgid "Deriving Error Enums"
msgstr "Derivando Enums de Erro"

#: src/SUMMARY.md:161
msgid "Dynamic Error Types"
msgstr "Tipos de Erros Din√¢micos"

#: src/SUMMARY.md:162
msgid "Adding Context to Errors"
msgstr "Adicionando Contexto aos Erros"

#: src/SUMMARY.md:163
msgid "Testing"
msgstr "Testando"

#: src/SUMMARY.md:164
msgid "Unit Tests"
msgstr "Testes Unit√°rios"

#: src/SUMMARY.md:165
msgid "Test Modules"
msgstr "M√≥dulos de Teste"

#: src/SUMMARY.md:166
msgid "Documentation Tests"
msgstr "Testes de Documenta√ß√£o"

#: src/SUMMARY.md:167
msgid "Integration Tests"
msgstr "Testes de Integra√ß√£o"

#: src/SUMMARY.md:168
msgid "Useful crates"
msgstr "Crates √öteis para Testes"

#: src/SUMMARY.md:169
msgid "Unsafe Rust"
msgstr "Rust Inseguro (unsafe)"

#: src/SUMMARY.md:170
msgid "Dereferencing Raw Pointers"
msgstr "Desreferenciando Ponteiros Brutos"

#: src/SUMMARY.md:171
msgid "Mutable Static Variables"
msgstr "Vari√°veis Est√°ticas Mut√°veis"

#: src/SUMMARY.md:172
msgid "Unions"
msgstr "Uni√µes"

#: src/SUMMARY.md:173
msgid "Calling Unsafe Functions"
msgstr "Chamando Fun√ß√µes Inseguras"

#: src/SUMMARY.md:174
msgid "Writing Unsafe Functions"
msgstr "Escrevendo Fun√ß√µes Inseguras"

#: src/SUMMARY.md:175
msgid "Extern Functions"
msgstr "Fun√ß√µes Externas"

#: src/SUMMARY.md:176
msgid "Implementing Unsafe Traits"
msgstr "Implementando Traits Inseguros"

#: src/SUMMARY.md:178
msgid "Safe FFI Wrapper"
msgstr "Wrapper FFI seguro"

#: src/SUMMARY.md:181 src/SUMMARY.md:251
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:186
msgid "Setup"
msgstr "Configurar"

#: src/SUMMARY.md:187
msgid "Build Rules"
msgstr "Regras de Constru√ß√£o"

#: src/SUMMARY.md:188
msgid "Binary"
msgstr "Bin√°rio"

#: src/SUMMARY.md:189
msgid "Library"
msgstr "Biblioteca"

#: src/SUMMARY.md:190
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:191
msgid "Interface"
msgstr "Interface"

#: src/SUMMARY.md:192
msgid "Implementation"
msgstr "Implementa√ß√£o"

#: src/SUMMARY.md:193
msgid "Server"
msgstr "Servidor"

#: src/SUMMARY.md:194
msgid "Deploy"
msgstr "Implantar"

#: src/SUMMARY.md:195
msgid "Client"
msgstr "Cliente"

#: src/SUMMARY.md:196
msgid "Changing API"
msgstr "Alterando API"

#: src/SUMMARY.md:197 src/SUMMARY.md:241
msgid "Logging"
msgstr "Gerando Registros (Log)"

#: src/SUMMARY.md:198
msgid "Interoperability"
msgstr "Interoperabilidade"

#: src/SUMMARY.md:199
msgid "With C"
msgstr "Com C"

#: src/SUMMARY.md:200
msgid "Calling C with Bindgen"
msgstr "Chamando C com Bindgen"

#: src/SUMMARY.md:201
msgid "Calling Rust from C"
msgstr "Chamando Rust do C"

#: src/SUMMARY.md:202
msgid "With C++"
msgstr "Com C++"

#: src/SUMMARY.md:203
msgid "With Java"
msgstr "Com Java"

#: src/SUMMARY.md:207
msgid "Bare Metal: Morning"
msgstr "Bare Metal: Manh√£"

#: src/SUMMARY.md:212
msgid "no_std"
msgstr ""

#: src/SUMMARY.md:213
msgid "A Minimal Example"
msgstr "Um pequeno exemplo"

#: src/SUMMARY.md:214
msgid "alloc"
msgstr ""

#: src/SUMMARY.md:215
msgid "Microcontrollers"
msgstr ""

#: src/SUMMARY.md:216
msgid "Raw MMIO"
msgstr ""

#: src/SUMMARY.md:217
msgid "PACs"
msgstr ""

#: src/SUMMARY.md:218
msgid "HAL Crates"
msgstr ""

#: src/SUMMARY.md:219
msgid "Board Support Crates"
msgstr ""

#: src/SUMMARY.md:220
msgid "The Type State Pattern"
msgstr ""

#: src/SUMMARY.md:221
msgid "embedded-hal"
msgstr ""

#: src/SUMMARY.md:222
msgid "probe-rs, cargo-embed"
msgstr ""

#: src/SUMMARY.md:223
msgid "Debugging"
msgstr "Debugging"

#: src/SUMMARY.md:224 src/SUMMARY.md:242
msgid "Other Projects"
msgstr "Outros Projetos"

#: src/SUMMARY.md:226
msgid "Compass"
msgstr "B√∫ssola"

#: src/SUMMARY.md:228
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: Tarde"

#: src/SUMMARY.md:230
msgid "Application Processors"
msgstr ""

#: src/SUMMARY.md:231
msgid "Getting Ready to Rust"
msgstr ""

#: src/SUMMARY.md:232
msgid "Inline Assembly"
msgstr ""

#: src/SUMMARY.md:233
msgid "MMIO"
msgstr ""

#: src/SUMMARY.md:234
msgid "Let's Write a UART Driver"
msgstr ""

#: src/SUMMARY.md:234
msgid "More Traits"
msgstr "Mais Traits (Caracter√≠sticas)"

#: src/SUMMARY.md:236
msgid "A Better UART Driver"
msgstr ""

#: src/SUMMARY.md:237
msgid "Bitflags"
msgstr ""

#: src/SUMMARY.md:238
msgid "Multiple Registers"
msgstr ""

#: src/SUMMARY.md:239
msgid "Driver"
msgstr ""

#: src/SUMMARY.md:239 src/SUMMARY.md:241
msgid "Using It"
msgstr "Usando o Cargo"

#: src/SUMMARY.md:243
#, fuzzy
msgid "Exceptions"
msgstr "Fun√ß√µes"

#: src/SUMMARY.md:245
msgid "Useful Crates"
msgstr ""

#: src/SUMMARY.md:246
msgid "zerocopy"
msgstr ""

#: src/SUMMARY.md:247
msgid "aarch64-paging"
msgstr ""

#: src/SUMMARY.md:248
msgid "buddy_system_allocator"
msgstr ""

#: src/SUMMARY.md:249
msgid "tinyvec"
msgstr ""

#: src/SUMMARY.md:250
msgid "spin"
msgstr ""

#: src/SUMMARY.md:252
msgid "vmbase"
msgstr ""

#: src/SUMMARY.md:254
msgid "RTC Driver"
msgstr ""

#: src/SUMMARY.md:255
msgid "Concurrency: Morning"
msgstr "Concorr√™ncia: Manh√£"

#: src/SUMMARY.md:262
msgid "Threads"
msgstr "Threads"

#: src/SUMMARY.md:263
msgid "Scoped Threads"
msgstr "Threads com Escopo"

#: src/SUMMARY.md:264
msgid "Channels"
msgstr "Canais (channels)"

#: src/SUMMARY.md:265
msgid "Unbounded Channels"
msgstr "Canais Ilimitados"

#: src/SUMMARY.md:266
msgid "Bounded Channels"
msgstr "Canais Delimitados"

#: src/SUMMARY.md:267
msgid "Send and Sync"
msgstr "Send e Sync"

#: src/SUMMARY.md:267
msgid "Send"
msgstr "Send"

#: src/SUMMARY.md:267
msgid "Sync"
msgstr "Sync"

#: src/SUMMARY.md:270
msgid "Examples"
msgstr "Exemplos"

#: src/SUMMARY.md:271
msgid "Shared State"
msgstr "Estado Compartilhado"

#: src/SUMMARY.md:272
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:273
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:274 src/SUMMARY.md:295
msgid "Dining Philosophers"
msgstr "Fil√≥sofos Jantando"

#: src/SUMMARY.md:277
msgid "Multi-threaded Link Checker"
msgstr "Verificador de Links Multi-Threads"

#: src/SUMMARY.md:277
msgid "Concurrency: Afternoon"
msgstr "Concorr√™ncia: Tarde"

#: src/SUMMARY.md:281
msgid "Async Basics"
msgstr ""

#: src/SUMMARY.md:282
msgid "async/await"
msgstr ""

#: src/SUMMARY.md:283
msgid "Futures"
msgstr ""

#: src/SUMMARY.md:282
msgid "Runtimes"
msgstr "Tempos de Execu√ß√£o"

#: src/SUMMARY.md:285
msgid "Tokio"
msgstr ""

#: src/SUMMARY.md:284
msgid "Tasks"
msgstr "Tarefas"

#: src/SUMMARY.md:285
msgid "Async Channels"
msgstr "Canais Ass√≠ncronos"

#: src/SUMMARY.md:289
msgid "Join"
msgstr ""

#: src/SUMMARY.md:290
msgid "Select"
msgstr ""

#: src/SUMMARY.md:291
msgid "Pitfalls"
msgstr ""

#: src/SUMMARY.md:292
msgid "Blocking the Executor"
msgstr ""

#: src/SUMMARY.md:293
msgid "Pin"
msgstr ""

#: src/SUMMARY.md:292
msgid "Async Traits"
msgstr "Traits (Caracter√≠sticas)"

#: src/SUMMARY.md:293
msgid "Cancellation"
msgstr "Cancelar"

#: src/SUMMARY.md:296
msgid "Broadcast Chat Application"
msgstr ""

#: src/SUMMARY.md:299
msgid "Final Words"
msgstr "Palavras Finais"

#: src/SUMMARY.md:303
msgid "Thanks!"
msgstr "Obrigado!"

#: src/SUMMARY.md:304
msgid "Other Resources"
msgstr "Outros recursos"

#: src/SUMMARY.md:305
msgid "Credits"
msgstr "Cr√©ditos"

#: src/SUMMARY.md:308
msgid "Solutions"
msgstr "Solu√ß√µes"

#: src/SUMMARY.md:313
msgid "Day 1 Morning"
msgstr "Dia 1 Manh√£"

#: src/SUMMARY.md:314
msgid "Day 1 Afternoon"
msgstr "Dia 1 Tarde"

#: src/SUMMARY.md:315
msgid "Day 2 Morning"
msgstr "Dia 2 Manh√£"

#: src/SUMMARY.md:316
msgid "Day 2 Afternoon"
msgstr "Dia 2 Tarde"

#: src/SUMMARY.md:317
msgid "Day 3 Morning"
msgstr "Dia 3 Manh√£"

#: src/SUMMARY.md:318
msgid "Day 3 Afternoon"
msgstr "Dia 3 Tarde"

#: src/SUMMARY.md:319
msgid "Bare Metal Rust Morning"
msgstr ""

#: src/SUMMARY.md:320
msgid "Bare Metal Rust Afternoon"
msgstr "Bare Metal Rust Tarde"

#: src/SUMMARY.md:321
msgid "Concurrency Morning"
msgstr "Concorr√™ncia Manh√£"

#: src/SUMMARY.md:322
msgid "Concurrency Afternoon"
msgstr "Concorr√™ncia Tarde"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust ü¶Ä"
msgstr "# Bem-vindo ao Comprehensive Rust ü¶Ä"

#: src/welcome.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/"
"build.yml?style=flat-square)](https://github.com/google/comprehensive-rust/actions/workflows/build."
"yml?query=branch%3Amain)"
msgstr ""

#: src/welcome.md:3
msgid "Build workflow"
msgstr ""

#: src/welcome.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/"
"build.yml?style=flat-square)](https://github.com/google/comprehensive-rust/actions/workflows/build."
"yml?query=branch%3Amain)\n"
"[![GitHub contributors](https://img.shields.io/github/contributors/google/comprehensive-rust?"
"style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)"
msgstr ""

#: src/welcome.md:4
msgid "GitHub contributors"
msgstr ""

#: src/welcome.md:4
msgid ""
"[![GitHub contributors](https://img.shields.io/github/contributors/google/comprehensive-rust?"
"style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)\n"
"[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Contribui√ß√µes no GitHub](https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)\n"
"[![Estrelas no GitHub](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)](https://github.com/google/comprehensive-rust/stargazers)"

#: src/welcome.md:5
msgid "GitHub stars"
msgstr ""

#: src/welcome.md:5
msgid ""
"[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"
msgstr ""

#: src/welcome.md:7
msgid ""
"This is a three day Rust course developed by the Android team. The course covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like generics\n"
"and error handling. It also includes Android-specific content on the last day."
msgstr ""
"Este √© um curso de Rust de tr√™s dias desenvolvido pela equipe do Android. O curso abrange\n"
"o espectro completo da linguagem, desde a sintaxe b√°sica at√© t√≥picos avan√ßados como 'generics'\n"
"e tratamento de erros. Tamb√©m inclui conte√∫do espec√≠fico para Android no √∫ltimo dia."

#: src/welcome.md:11
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know anything\n"
"about Rust and hope to:"
msgstr ""
"O objetivo do curso √© ensinar Rust a voc√™. N√≥s assumimos que voc√™ n√£o saiba nada\n"
"sobre Rust e esperamos:"

#: src/welcome.md:14
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* Dar a voc√™ uma compreens√£o abrangente da linguagem e da sintaxe de Rust.\n"
"* Permitir que voc√™ modifique programas existentes e escreva novos programas em Rust.\n"
"* Demonstrar express√µes idiom√°ticas comuns de Rust."

#: src/welcome.md:18
msgid ""
"The first three days show you the fundamentals of Rust. Following this, you're\n"
"invited to dive into one or more specialized topics:"
msgstr ""
"Os tr√™s primeiros dias lhe mostram os fundamentos de Rust. Em seguida, voc√™ est√°\n"
"convidado(a) a mergulhar a fundo em um ou mais t√≥picos especializados:"

#: src/welcome.md:21
msgid ""
"* [Android](android.md): a half-day course on using Rust for Android platform\n"
"  development (AOSP). This includes interoperability with C, C++, and Java.\n"
"* [Bare-metal](bare-metal.md): a full day class on using Rust for bare-metal\n"
"  (embedded) development. Both microcontrollers and application processors are\n"
"  covered.\n"
"* [Concurrency](concurrency.md): a full day class on concurrency in Rust. We\n"
"  cover both classical concurrency (preemptively scheduling using threads and\n"
"  mutexes) and async/await concurrency (cooperative multitasking using\n"
"  futures)."
msgstr ""
"* [Android](android.md): um curso de meio dia sobre a utiliza√ß√£o de Rust no desenvolvimento para a plataforma\n"
"Android (AOSP). Isto inclui interoperabilidade com C, C++ e Java.\n"
"* [Bare-metal](bare-metal.md): uma aula de um dia sobre a utiliza√ß√£o de Rust para o desenvolvimento\n"
"\"bare metal\" (sistema embarcado). Tanto micro-controladores quanto processadores de aplica√ß√£o s√£o\n"
"  cobertos.\n"
"* [Concorr√™ncia](concurrency.md): uma aula de um dia inteiro sobre concorr√™ncia em Rust. N√≥s\n"
"  cobrimos tanto concorr√™ncia cl√°ssica (escalonamento preemptivo utilizando threads e\n"
"  mutexes) quanto concorr√™ncia async/await (multitarefa cooperativa utilizando\n"
"  _futures_)."

#: src/welcome.md:32
msgid "## Non-Goals"
msgstr "## Fora do escopo"

#: src/welcome.md:34
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few days.\n"
"Some non-goals of this course are:"
msgstr ""
"Rust √© uma linguagem extensa e n√£o conseguiremos cobrir tudo em poucos dias.\n"
"Alguns assuntos que n√£o s√£o objetivos deste curso s√£o:"

#: src/welcome.md:37
msgid ""
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* Aprender a criar macros, por favor confira [Cap√≠tulo 19.5 em Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) e [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) para esse fim."

#: src/welcome.md:41
msgid "## Assumptions"
msgstr "## Premissas"

#: src/welcome.md:43
msgid ""
"The course assumes that you already know how to program. Rust is a statically\n"
"typed language and we will sometimes make comparisons with C and C++ to better\n"
"explain or contrast the Rust approach."
msgstr ""
"O curso pressup√µe que voc√™ j√° saiba programar. Rust √© uma linguagem de tipagem est√°tica\n"
"e ocasionalmente faremos compara√ß√µes com C e C++ para melhor\n"
"explicar ou contrastar a abordagem do Rust."

#: src/welcome.md:47
msgid ""
"If you know how to program in a dynamically typed language such as Python or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Se voc√™ sabe programar em uma linguagem de tipagem din√¢mica, como Python ou\n"
"JavaScript, ent√£o voc√™ tamb√©m ser√° capaz de acompanhar."

#: src/welcome.md:50 src/cargo/rust-ecosystem.md:19 src/cargo/code-samples.md:22
#: src/cargo/running-locally.md:68 src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8 src/why-rust/modern.md:19
#: src/basic-syntax/scalar-types.md:19 src/basic-syntax/compound-types.md:28
#: src/basic-syntax/references.md:21 src/basic-syntax/slices.md:18
#: src/basic-syntax/string-slices.md:25 src/basic-syntax/functions.md:33
#: src/basic-syntax/rustdoc.md:22 src/basic-syntax/methods.md:32
#: src/basic-syntax/functions-interlude.md:25 src/exercises/day-1/morning.md:9
#: src/exercises/day-1/for-loops.md:90 src/basic-syntax/variables.md:15
#: src/basic-syntax/type-inference.md:24 src/basic-syntax/static-and-const.md:46
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27
#: src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/exercises/day-1/book-library.md:100
#: src/structs.md:29 src/structs/tuple-structs.md:35
#: src/structs/field-shorthand.md:25 src/enums.md:32
#: src/enums/variant-payloads.md:33 src/enums/sizes.md:27 src/methods.md:28
#: src/methods/receiver.md:22 src/methods/example.md:44 src/pattern-matching.md:23
#: src/pattern-matching/destructuring-enums.md:33 src/pattern-matching/destructuring-structs.md:21
#: src/pattern-matching/destructuring-arrays.md:19 src/pattern-matching/match-guards.md:20
#: src/exercises/day-2/morning.md:9 src/exercises/day-2/points-polygons.md:115
#: src/control-flow/blocks.md:40 src/control-flow/if-expressions.md:33
#: src/control-flow/if-let-expressions.md:21 src/control-flow/while-let-expressions.md:24
#: src/control-flow/for-expressions.md:23 src/control-flow/loop-expressions.md:25
#: src/control-flow/match-expressions.md:26 src/std.md:23 src/std/option-result.md:16
#: src/std/string.md:28 src/std/vec.md:35 src/std/hashmap.md:36 src/std/box.md:32
#: src/std/box-recursive.md:31 src/std/rc.md:29 src/modules.md:26 src/modules/visibility.md:37
#: src/modules/filesystem.md:42 src/exercises/day-2/afternoon.md:5 src/generics/data-types.md:19
#: src/generics/methods.md:23 src/traits/trait-objects.md:70 src/traits/default-methods.md:30
#: src/traits/trait-bounds.md:33 src/traits/impl-trait.md:21 src/traits/iterator.md:30
#: src/traits/from-iterator.md:15 src/traits/from-into.md:27 src/traits/drop.md:32
#: src/traits/default.md:38 src/traits/operators.md:24 src/traits/closures.md:23
#: src/exercises/day-3/morning.md:5 src/error-handling/result.md:25
#: src/error-handling/try-operator.md:46 src/error-handling/converting-error-types-example.md:48
#: src/error-handling/deriving-error-enums.md:37 src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26 src/unsafe/raw-pointers.md:25
#: src/unsafe/mutable-static-variables.md:30 src/unsafe/unions.md:19
#: src/unsafe/writing-unsafe-functions.md:31 src/unsafe/extern-functions.md:19
#: src/unsafe/unsafe-traits.md:28 src/exercises/day-3/afternoon.md:5
#: src/android/interoperability/with-c/rust.md:81 src/exercises/android/morning.md:10
#: src/bare-metal/minimal.md:15 src/bare-metal/alloc.md:37 src/bare-metal/microcontrollers.md:23
#: src/bare-metal/microcontrollers/mmio.md:62 src/bare-metal/microcontrollers/pacs.md:47
#: src/bare-metal/microcontrollers/hals.md:37 src/bare-metal/microcontrollers/board-support.md:26
#: src/bare-metal/microcontrollers/type-state.md:30
#: src/bare-metal/microcontrollers/embedded-hal.md:17 src/bare-metal/microcontrollers/probe-rs.md:14
#: src/bare-metal/microcontrollers/debugging.md:25
#: src/bare-metal/microcontrollers/other-projects.md:16 src/exercises/bare-metal/morning.md:5
#: src/bare-metal/aps.md:7 src/bare-metal/aps/entry-point.md:75
#: src/bare-metal/aps/inline-assembly.md:41 src/bare-metal/aps/mmio.md:7
#: src/bare-metal/aps/uart.md:53 src/bare-metal/aps/uart/traits.md:22
#: src/bare-metal/aps/better-uart.md:24 src/bare-metal/aps/better-uart/bitflags.md:35
#: src/bare-metal/aps/better-uart/registers.md:39 src/bare-metal/aps/better-uart/driver.md:62
#: src/bare-metal/aps/better-uart/using.md:49 src/bare-metal/aps/logging.md:48
#: src/bare-metal/aps/logging/using.md:44 src/bare-metal/aps/exceptions.md:62
#: src/bare-metal/aps/other-projects.md:15 src/bare-metal/useful-crates/zerocopy.md:43
#: src/bare-metal/useful-crates/aarch64-paging.md:26
#: src/bare-metal/useful-crates/buddy_system_allocator.md:24
#: src/bare-metal/useful-crates/tinyvec.md:21
#: src/bare-metal/useful-crates/spin.md:21 src/bare-metal/android/vmbase.md:19
#: src/exercises/bare-metal/afternoon.md:5 src/concurrency/threads.md:28
#: src/concurrency/scoped-threads.md:35 src/concurrency/channels.md:25
#: src/concurrency/send-sync.md:18 src/concurrency/send-sync/send.md:11
#: src/concurrency/send-sync/sync.md:12 src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/mutex.md:29
#: src/concurrency/shared_state/example.md:21
#: src/exercises/concurrency/morning.md:10 src/async/async-await.md:23
#: src/async/futures.md:30 src/async/runtimes.md:18
#: src/async/runtimes/tokio.md:31 src/async/tasks.md:50
#: src/async/channels.md:33 src/async/control-flow/join.md:34
#: src/async/control-flow/select.md:60
#: src/async/pitfalls/blocking-executor.md:27 src/async/pitfalls/pin.md:66
#: src/async/pitfalls/cancellation.md:70
#: src/exercises/concurrency/afternoon.md:11
#: src/exercises/concurrency/dining-philosophers-async.md:75
msgid "<details>"
msgstr "<details>"

#: src/welcome.md:52
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"Este √© um exemplo de uma _nota do instrutor_. N√≥s as usaremos para adicionar\n"
"informa√ß√µes complementares aos slides. Elas podem ser tanto pontos-chave que o instrutor deve\n"
"cobrir quanto respostas a perguntas t√≠picas que surgem em sala de aula."

#: src/welcome.md:56 src/cargo/rust-ecosystem.md:67 src/cargo/code-samples.md:35
#: src/cargo/running-locally.md:74 src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:40 src/hello-world/small-example.md:46 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22 src/why-rust/modern.md:66
#: src/basic-syntax/scalar-types.md:43 src/basic-syntax/compound-types.md:62
#: src/basic-syntax/references.md:29 src/basic-syntax/slices.md:36
#: src/basic-syntax/string-slices.md:44 src/basic-syntax/functions.md:41
#: src/basic-syntax/rustdoc.md:33 src/basic-syntax/methods.md:45
#: src/basic-syntax/functions-interlude.md:30 src/exercises/day-1/morning.md:28
#: src/exercises/day-1/for-loops.md:95 src/basic-syntax/variables.md:20
#: src/basic-syntax/type-inference.md:48 src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/copy-clone.md:51
#: src/ownership/borrowing.md:51 src/ownership/shared-unique-borrows.md:29
#: src/ownership/lifetimes-function-calls.md:60
#: src/ownership/lifetimes-data-structures.md:30
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:104
#: src/structs.md:42 src/structs/tuple-structs.md:43
#: src/structs/field-shorthand.md:72 src/enums.md:42
#: src/enums/variant-payloads.md:45 src/enums/sizes.md:155 src/methods.md:41
#: src/methods/receiver.md:28 src/methods/example.md:53
#: src/pattern-matching.md:35 src/pattern-matching/destructuring-enums.md:39
#: src/pattern-matching/destructuring-structs.md:29
#: src/pattern-matching/destructuring-arrays.md:46
#: src/pattern-matching/match-guards.md:28 src/exercises/day-2/morning.md:15
#: src/exercises/day-2/points-polygons.md:125 src/control-flow/blocks.md:46
#: src/control-flow/if-expressions.md:37
#: src/control-flow/if-let-expressions.md:41
#: src/control-flow/while-let-expressions.md:29
#: src/control-flow/for-expressions.md:30
#: src/control-flow/loop-expressions.md:32
#: src/control-flow/match-expressions.md:33 src/std.md:31
#: src/std/option-result.md:25 src/std/string.md:42 src/std/vec.md:49
#: src/std/hashmap.md:66 src/std/box.md:39 src/std/box-recursive.md:41
#: src/std/rc.md:69 src/modules.md:32 src/modules/visibility.md:48
#: src/modules/filesystem.md:71 src/exercises/day-2/afternoon.md:11
#: src/generics/data-types.md:25 src/generics/methods.md:31
#: src/traits/trait-objects.md:83 src/traits/default-methods.md:60
#: src/traits/trait-bounds.md:50 src/traits/impl-trait.md:44
#: src/traits/iterator.md:42 src/traits/from-iterator.md:26
#: src/traits/from-into.md:33 src/traits/drop.md:42 src/traits/default.md:47
#: src/traits/operators.md:40 src/traits/closures.md:38
#: src/exercises/day-3/morning.md:11 src/error-handling/result.md:33
#: src/error-handling/try-operator.md:53 src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45 src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32 src/unsafe/raw-pointers.md:43
#: src/unsafe/mutable-static-variables.md:35 src/unsafe/unions.md:28
#: src/unsafe/writing-unsafe-functions.md:38 src/unsafe/extern-functions.md:28
#: src/unsafe/unsafe-traits.md:37 src/exercises/day-3/afternoon.md:11
#: src/android/interoperability/with-c/rust.md:86 src/exercises/android/morning.md:15
#: src/bare-metal/no_std.md:65 src/bare-metal/minimal.md:26 src/bare-metal/alloc.md:49
#: src/bare-metal/microcontrollers.md:29 src/bare-metal/microcontrollers/mmio.md:72
#: src/bare-metal/microcontrollers/pacs.md:65 src/bare-metal/microcontrollers/hals.md:49
#: src/bare-metal/microcontrollers/board-support.md:40
#: src/bare-metal/microcontrollers/type-state.md:43
#: src/bare-metal/microcontrollers/embedded-hal.md:23 src/bare-metal/microcontrollers/probe-rs.md:29
#: src/bare-metal/microcontrollers/debugging.md:38
#: src/bare-metal/microcontrollers/other-projects.md:26 src/exercises/bare-metal/morning.md:11
#: src/bare-metal/aps.md:15 src/bare-metal/aps/entry-point.md:101
#: src/bare-metal/aps/inline-assembly.md:58 src/bare-metal/aps/mmio.md:17
#: src/bare-metal/aps/uart/traits.md:27 src/bare-metal/aps/better-uart.md:28
#: src/bare-metal/aps/better-uart/bitflags.md:40 src/bare-metal/aps/better-uart/registers.md:46
#: src/bare-metal/aps/better-uart/driver.md:67 src/bare-metal/aps/better-uart/using.md:55
#: src/bare-metal/aps/logging.md:52 src/bare-metal/aps/logging/using.md:49
#: src/bare-metal/aps/exceptions.md:75 src/bare-metal/aps/other-projects.md:29
#: src/bare-metal/useful-crates/zerocopy.md:53 src/bare-metal/useful-crates/aarch64-paging.md:33
#: src/bare-metal/useful-crates/buddy_system_allocator.md:30
#: src/bare-metal/useful-crates/tinyvec.md:26
#: src/bare-metal/useful-crates/spin.md:30 src/bare-metal/android/vmbase.md:25
#: src/exercises/bare-metal/afternoon.md:11 src/concurrency/threads.md:45
#: src/concurrency/scoped-threads.md:40 src/concurrency/channels.md:32
#: src/concurrency/send-sync.md:23 src/concurrency/send-sync/send.md:16
#: src/concurrency/send-sync/sync.md:18 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/mutex.md:45
#: src/concurrency/shared_state/example.md:56
#: src/exercises/concurrency/morning.md:16 src/async/async-await.md:48
#: src/async/futures.md:45 src/async/runtimes.md:29
#: src/async/runtimes/tokio.md:49 src/async/tasks.md:63
#: src/async/channels.md:49 src/async/control-flow/join.md:50
#: src/async/control-flow/select.md:79
#: src/async/pitfalls/blocking-executor.md:50 src/async/pitfalls/pin.md:112
#: src/async/pitfalls/async-traits.md:63 src/async/pitfalls/cancellation.md:114
#: src/exercises/concurrency/afternoon.md:17
#: src/exercises/concurrency/dining-philosophers-async.md:79
msgid "</details>"
msgstr "</details>"

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# Oferecendo o curso"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "> This page is for the course instructor."
msgstr "> Esta p√°gina √© para o instrutor do curso."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the course\n"
"internally at Google."
msgstr ""
"Aqui est√£o algumas informa√ß√µes b√°sicas sobre como estamos conduzindo o curso\n"
"internamente no Google."

#: src/running-the-course.md:8
msgid "Before you run the course, you will want to:"
msgstr "Antes de oferecer o curso, voc√™ precisa:"

#: src/running-the-course.md:10
msgid ""
"1. Make yourself familiar with the course material. We've included speaker notes\n"
"   to help highlight the key points (please help us by contributing more speaker\n"
"   notes!). When presenting, you should make sure to open the speaker notes in a\n"
"   popup (click the link with a little arrow next to \"Speaker Notes\"). This way\n"
"   you have a clean screen to present to the class.\n"
"\n"
"1. Decide on the dates. Since the course takes at least three full days, we recommend that you\n"
"   schedule the days over two weeks. Course participants have said that\n"
"   they find it helpful to have a gap in the course since it helps them process\n"
"   all the information we give them.\n"
"\n"
"1. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-25 people. That's small enough that people are comfortable\n"
"   asking questions --- it's also small enough that one instructor will have\n"
"   time to answer the questions. Make sure the room has _desks_ for yourself and for the\n"
"   students: you will all need to be able to sit and work with your laptops.\n"
"   In particular, you will be doing a lot of live-coding as an instructor, so a lectern won't\n"
"   be very helpful for you.\n"
"\n"
"1. On the day of your course, show up to the room a little early to set things\n"
"   up. We recommend presenting directly using `mdbook serve` running on your\n"
"   laptop (see the [installation instructions][3]). This ensures optimal performance with no lag "
"as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them.\n"
"\n"
"1. Let people solve the exercises by themselves or in small groups.\n"
"   We typically spend 30-45 minutes on exercises in the morning and in the afternoon (including "
"time to review the solutions).\n"
"   Make sure to\n"
"   ask people if they're stuck or if there is anything you can help with. When\n"
"   you see that several people have the same problem, call it out to the class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"1. Familiarize-se com o material do curso. Inclu√≠mos notas do instrutor\n"
"    para ajudar a destacar os pontos principais (ajude-nos contribuindo com mais\n"
"    notas!). Ao apresentar, certifique-se de abrir as notas do instrutor em um\n"
"    pop-up (clique no link com uma pequena seta ao lado de \"Speaker Notes\" ou \"Notas do Instrutor\"). Desta forma\n"
"    voc√™ tem uma tela limpa para apresentar √† turma.\n"
"\n"
"1. Decida as datas. Como o curso leva pelo menos tr√™s dias completos, recomendamos que voc√™\n"
"    agende os dias ao longo de duas semanas. Os participantes do curso disseram que\n"
"    eles acham √∫til ter uma lacuna no curso, pois os ajuda a processar\n"
"    todas as informa√ß√µes que lhes damos.\n"
"\n"
"1. Encontre uma sala grande o suficiente para seus participantes presenciais. Recomendamos\n"
"    turmas de 15 a 25 pessoas. Isso √© pequeno o suficiente para que as pessoas se sintam confort√°veis\n"
"    fazendo perguntas --- tamb√©m √© pequeno o suficiente para que um instrutor tenha\n"
"    tempo para responder √†s perguntas. Certifique-se de que a sala tenha _mesas_ para voc√™ e para os\n"
"    alunos: todos voc√™s precisam ser capazes de sentar e trabalhar com seus laptops.\n"
"    Em particular, voc√™ far√° muita codifica√ß√£o ao vivo como instrutor, portanto, um p√≥dio n√£o\n"
"    ser√° muito √∫til para voc√™.\n"
"\n"
"1. No dia do seu curso, chegue um pouco mais cedo na sala para acertar as coisas.\n"
"    Recomendamos apresentar diretamente usando `mdbook serve` rodando em seu\n"
"    laptop (consulte as [instru√ß√µes de instala√ß√£o][3]). Isso garante um desempenho ideal sem atrasos conforme voc√™ muda de p√°gina.\n"
"    Usar seu laptop tamb√©m permitir√° que voc√™ corrija erros de digita√ß√£o enquanto voc√™ ou os participantes\n"
"    do curso os identificam.\n"
"\n"
"1. Deixe as pessoas resolverem os exerc√≠cios sozinhas ou em pequenos grupos.\n"
"    Normalmente gastamos de 30 a 45 minutos em exerc√≠cios pela manh√£ e √† tarde (incluindo o tempo para revisar as solu√ß√µes).\n"
"    Tenha certeza de\n"
"    perguntar √†s pessoas se elas est√£o em dificuldades ou se h√° algo em que voc√™ possa ajudar. Quando\n"
"    voc√™ vir que v√°rias pessoas t√™m o mesmo problema, chame a turma\n"
"    e ofere√ßa uma solu√ß√£o, por exemplo, mostrando √†s pessoas onde encontrar as informa√ß√µes relevantes\n"
"    na biblioteca padr√£o (\"standard library\")."

#: src/running-the-course.md:43
msgid ""
"That is all, good luck running the course! We hope it will be as much fun for\n"
"you as it has been for us!"
msgstr ""
"Isso √© tudo, boa sorte no curso! Esperamos que seja t√£o divertido para\n"
"voc√™ como tem sido para n√≥s!"

#: src/running-the-course.md:46
msgid ""
"Please [provide feedback][1] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][2]!"
msgstr ""
"Por favor, [d√™ seu feedback][1] depois para que possamos continuar melhorando o\n"
"curso. Adorar√≠amos saber o que funcionou bem para voc√™ e o que pode ser melhorado.\n"
"Seus alunos tamb√©m s√£o muito bem-vindos para [nos enviar feedback][2]!"

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# Estrutura do curso"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "O curso √© r√°pido e muito abrangente:"

#: src/running-the-course/course-structure.md:7
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust."
msgstr ""
"* Dia 1: Rust b√°sico, _ownership_ (\"posse\") e o _borrow checker_ (\"verificador de empr√©stimo\").\n"
"* Dia 2: Tipos de dados compostos, correspond√™ncia de padr√µes e a biblioteca padr√£o.\n"
"* Dia 3: _Traits_ (\"caracter√≠sticas\") e gen√©ricos, tratamento de erros, testes e _unsafe_ (\"inseguro\") Rust."

#: src/running-the-course/course-structure.md:11
msgid "## Deep Dives"
msgstr "## An√°lises Detalhadas"

#: src/running-the-course/course-structure.md:13
msgid ""
"In addition to the 3-day class on Rust Fundamentals, we cover some more\n"
"specialized topics:"
msgstr ""
"Al√©m do curso de 3 dias sobre fundamentos de Rust, n√≥s abordamos alguns t√≥picos\n"
"mais especializados:"

#: src/running-the-course/course-structure.md:16
msgid "### Android"
msgstr "### Android"

#: src/running-the-course/course-structure.md:18
msgid ""
"The [Android Deep Dive](../android.md) is a half-day course on using Rust for\n"
"Android platform development. This includes interoperability with C, C++, and\n"
"Java."
msgstr ""
"O [Android Deep Dive](../android.md) √© um curso de meio dia sobre o uso de Rust para\n"
"o desenvolvimento na plataforma Android. Isso inclui interoperabilidade com C, C++ e\n"
"Java."

#: src/running-the-course/course-structure.md:22
msgid ""
"You will need an [AOSP checkout][1]. Make a checkout of the [course\n"
"repository][2] on the same machine and move the `src/android/` directory into\n"
"the root of your AOSP checkout. This will ensure that the Android build system\n"
"sees the `Android.bp` files in `src/android/`."
msgstr ""
"Voc√™ precisar√° de um [_checkout_ do AOSP][1]. Fa√ßa um checkout do [reposit√≥rio\n"
"do curso][2] no mesmo computador e mova o diret√≥rio `src/android/` para\n"
"a raiz do seu checkout do AOSP. Isso garantir√° que o sistema de compila√ß√£o do Android\n"
"veja os arquivos `Android.bp` em `src/android/`."

#: src/running-the-course/course-structure.md:27
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build all\n"
"Android examples using `src/android/build_all.sh`. Read the script to see the\n"
"commands it runs and make sure they work when you run them by hand."
msgstr ""
"Certifique-se de que `adb sync` funcione com seu emulador ou dispositivo f√≠sico e pr√©-compile\n"
"todos os exemplos do Android usando `src/android/build_all.sh`. Leia o roteiro para ver\n"
"os comandos executados e verifique se eles funcionam quando voc√™ os executa manualmente."

#: src/running-the-course/course-structure.md:34
msgid "### Bare-Metal"
msgstr "### Bare-Metal"

#: src/running-the-course/course-structure.md:36
msgid ""
"The [Bare-Metal Deep Dive](../bare-metal.md): a full day class on using Rust for\n"
"bare-metal (embedded) development. Both microcontrollers and application\n"
"processors are covered."
msgstr ""
"O [Bare-Metal Deep Dive](../bare-metal.md) √© uma aula de um dia sobre o uso de Rust para\n"
"o desenvolvimento _bare-metal_ (sistema embarcado). Tanto micro-controladores quanto processadores\n"
"de aplica√ß√µes s√£o cobertos."

#: src/running-the-course/course-structure.md:40
msgid ""
"For the microcontroller part, you will need to buy the [BBC\n"
"micro:bit](https://microbit.org/) v2 development board ahead of time. Everybody\n"
"will need to install a number of packages as described on the [welcome\n"
"page](../bare-metal.md)."
msgstr ""
"Para a parte do micro-controlador, voc√™ precisar√° comprar a placa\n"
"de desenvolvimento [BBC micro:bit](https://microbit.org/) v2 com\n"
"anteced√™ncia. Todos precisar√£o instalar v√°rios pacotes, conforme\n"
"descrito na [p√°gina inicial](../bare-metal.md)."

#: src/running-the-course/course-structure.md:45
msgid "### Concurrency"
msgstr "### Concorr√™ncia"

#: src/running-the-course/course-structure.md:47
msgid ""
"The [Concurrency Deep Dive](../concurrency.md) is a full day class on classical\n"
"as well as `async`/`await` concurrency."
msgstr ""
"O [Concurrency Deep Dive](../concurrency.md) √© uma aula de um dia sobre\n"
"concorr√™ncia cl√°ssica e `async`/`await`."

#: src/running-the-course/course-structure.md:50
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready to\n"
"go. You can then copy/paste the examples into `src/main.rs` to experiment with\n"
"them:"
msgstr ""
"Voc√™ precisar√° de um novo _crate_ configurado e as depend√™ncias baixadas e prontas\n"
"para uso. Voc√™ pode ent√£o copiar/colar os exemplos para `src/main.rs` para\n"
"experiment√°-los:"

#: src/running-the-course/course-structure.md:54
msgid ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio --features full\n"
"cargo run\n"
"```"
msgstr ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio ‚Äîfeatures full\n"
"cargo run\n"
"```"

#: src/running-the-course/course-structure.md:61
msgid "## Format"
msgstr "## Formato"

#: src/running-the-course/course-structure.md:63
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr ""
"O curso foi projetado para ser bastante interativo e recomendamos\n"
"deixar as perguntas conduzirem a explora√ß√£o de Rust!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# Atalhos de Teclado"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Existem v√°rios atalhos de teclado √∫teis no _mdBook_:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Seta para a esquerda</kbd>: Vai para a p√°gina anterior.\n"
"* <kbd>Seta para a direita</kbd>: Vai para a pr√≥xima p√°gina.\n"
"* <kbd>Ctrl + Enter</kbd>: Executa o exemplo de c√≥digo que tem o foco.\n"
"* <kbd>S</kbd>: Ativa a barra de pesquisa."

#: src/running-the-course/translations.md:1
msgid "# Translations"
msgstr "# Tradu√ß√µes"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful\n"
"volunteers:"
msgstr ""
"O curso foi traduzido para outros idiomas por um grupo de volunt√°rios\n"
"maravilhosos:"

#: src/running-the-course/translations.md:6
msgid ""
"* [Brazilian Portuguese][pt-BR] by [@rastringer] and [@hugojacob].\n"
"* [Korean][ko] by [@keispace], [@jiyongp] and [@jooyunghan]."
msgstr ""
"* [Portugu√™s do Brasil][pt-BR] por [@rastringer] e [@hugojacob].\n"
"* [Coreano][ko] por [@keispace], [@jiyongp] e [@jooyunghan]."

#: src/running-the-course/translations.md:9
msgid "Use the language picker in the top-right corner to switch between languages."
msgstr "Use o seletor de idioma no canto superior direito para alternar entre os idiomas."

#: src/running-the-course/translations.md:11
msgid "## Incomplete Translations"
msgstr "## Tradu√ß√µes Incompletas"

#: src/running-the-course/translations.md:13
msgid ""
"There is a large number of in-progress translations. We link to the most\n"
"recently updated translations:"
msgstr ""
"H√° um grande n√∫mero de tradu√ß√µes em andamento. N√≥s referenciamos as\n"
"tradu√ß√µes mais recentemente atualizadas:"

#: src/running-the-course/translations.md:16
msgid ""
"* [Bengali][bn] by [@raselmandol].\n"
"* [French][fr] by [@KookaS] and [@vcaen].\n"
"* [German][de] by [@Throvn] and [@ronaldfw].\n"
"* [Japanese][ja] by [@CoinEZ-JPN] and [@momotaro1105]."
msgstr ""
"* [Bengali][bn] por [@raselmandol].\n"
"* [Franc√™s][fr] por [@KookaS] e [@vcaen].\n"
"* [Alem√£o][de] por [@Throvn] e [@ronaldfw].\n"
"* [Japon√™s][ja] por [@CoinEZ-JPN] e [@momotaro1105]."

#: src/running-the-course/translations.md:21
msgid ""
"If you want to help with this effort, please see [our instructions] for how to\n"
"get going. Translations are coordinated on the [issue tracker]."
msgstr ""
"Se voc√™ quiser ajudar com esse esfor√ßo, consulte [nossas instru√ß√µes][our instructions] sobre\n"
"como proceder. As tradu√ß√µes s√£o coordenadas no _[issue tracker]_."

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# Usando o Cargo"

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc.rust-lang.org/cargo/), "
"the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want to\n"
"give a brief overview of what Cargo is and how it fits into the wider ecosystem\n"
"and how it fits into this training."
msgstr ""
"Quando voc√™ come√ßar a ler sobre Rust, logo conhecer√° o [Cargo](https://doc.rust-lang.org/cargo/), "
"a ferramenta padr√£o\n"
"usada no ecossistema Rust para criar e executar aplicativos Rust. Aqui n√≥s queremos\n"
"dar uma breve vis√£o geral do que √© o Cargo e como ele se encaixa no ecossistema mais amplo\n"
"e como ele se encaixa neste treinamento."

#: src/cargo.md:8
msgid "## Installation"
msgstr "## Instala√ß√£o"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "### Rustup (Recomendado)"

#: src/cargo.md:12
msgid ""
"You can follow the instructions to install cargo and rust compiler, among other standard ecosystem "
"tools with the [rustup][3] tool, which is maintained by the Rust Foundation."
msgstr ""
"Voc√™ pode seguir as instru√ß√µes para instalar o cargo e o compilador de Rust, entre outras "
"ferramentas padr√£o do ecossistema com a ferramenta [rustup][3], que √© mantida pela Rust Foundation."

#: src/cargo.md:14
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line utility that you can use "
"to install/switch toolchains, setup cross compilation, etc."
msgstr ""
"Juntamente com cargo e rustc, o Rustup se instalar√° como um utilit√°rio de linha de comando que "
"voc√™ pode usar para instalar/alternar ferramentas, configurar compila√ß√£o cruzada, etc."

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### Gerenciadores de pacotes"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
msgid "On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust formatter][6] with"
msgstr "No Debian/Ubuntu, voc√™ pode instalar o Cargo, o c√≥digo-fonte Rust e o [formatador Rust][6] com"

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"Isso permitir√° que o [rust-analyzer][1] localize as defini√ß√µes. Sugerimos usar o\n"
"[VS Code][2] para editar o c√≥digo (mas qualquer editor compat√≠vel com LSP funciona)."

#: src/cargo.md:29
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do their own analysis but "
"have their own tradeoffs. If you prefer them, you can install the [Rust Plugin][5]. Please take "
"note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"Algumas pessoas tamb√©m gostam de usar a fam√≠lia de IDEs [JetBrains][4], que fazem suas pr√≥prias "
"an√°lises, mas t√™m suas pr√≥prias vantagens e desvantagens. Se voc√™ preferir, pode instalar o "
"[Plugin Rust][5]. Observe que, a partir de Janeiro de 2023, a depura√ß√£o funciona apenas na vers√£o "
"CLion do pacote JetBrains IDEA."

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# O ecossistema do Rust"

#: src/cargo/rust-ecosystem.md:3
msgid "The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "O ecossistema Rust consiste em v√°rias ferramentas, das quais as principais s√£o:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and other\n"
"  intermediate formats.\n"
"\n"
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests.\n"
"\n"
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and `rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustc`: o compilador Rust que converte arquivos `.rs` em bin√°rios e outros\n"
" formatos intermedi√°rios.\n"
"\n"
"* `cargo`: o gerenciador de depend√™ncias e ferramenta de compila√ß√£o do Rust. O Cargo sabe como\n"
" baixar depend√™ncias hospedadas em <https://crates.io> e ele as passar√° para o \n"
" `rustc` quando compilar o seu projeto. O Cargo tamb√©m vem com um gerenciador de\n"
" testes embutido que √© utilizado para a execu√ß√£o de testes unit√°rios.\n"
"\n"
"* `rustup`: o instalador e atualizador do conjunto de ferramentas do Rust. Esta ferramenta √© utilizada para\n"
" instalar e atualizar o `rustc` e o `cargo` quando novas vers√µes do Rust forem lan√ßadas.\n"
" Al√©m disso, `rustup` tamb√©m pode baixar a documenta√ß√£o da biblioteca\n"
" padr√£o. Voc√™ pode ter m√∫ltiplas vers√µes do Rust instaladas ao mesmo tempo e `rustup`\n"
" permitir√° que voc√™ alterne entre elas conforme necess√°rio."

#: src/cargo/rust-ecosystem.md:21
#: src/hello-world.md:25
#: src/hello-world/small-example.md:27
#: src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21
#: src/basic-syntax/compound-types.md:30
#: src/basic-syntax/references.md:23
#: src/pattern-matching/destructuring-enums.md:35
#: src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30
#: src/async/async-await.md:25
msgid "Key points:"
msgstr "Pontos chave:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality.\n"
"\n"
"* There are three release channels: \"stable\", \"beta\", and \"nightly\".\n"
"\n"
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks.\n"
"\n"
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018.\n"
"\n"
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language.\n"
"\n"
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file.\n"
"\n"
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions.\n"
"\n"
"  * Mention that it is quite rare to ever use the compiler directly not through `cargo` (most "
"users never do).\n"
"\n"
"  * It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  "
"It is capable of many advanced features including but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as [cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"* O Rust tem um cronograma de lan√ßamento r√°pido com um novo lan√ßamento saindo\n"
" a cada seis semanas. Novos lan√ßamentos mant√™m compatibilidade com vers√µes\n"
" anteriores ‚Äî al√©m disso, eles habilitam novas funcionalidades.\n"
"\n"
"* Existem tr√™s canais de lan√ßamento: _\"stable\"_, _\"beta\"_ e _\"nightly\"_.\n"
"\n"
"* Novos recursos est√£o sendo testados em \"nightly\", \"beta\" √© o que se torna\n"
" \"stable\" a cada seis semanas.\n"
"\n"
"* O Rust tamb√©m tem [edi√ß√µes][editions]: a edi√ß√£o atual √© o Rust 2021. As edi√ß√µes\n"
" anteriores foram o Rust 2015 e o Rust 2018.\n"
"\n"
"* As edi√ß√µes podem fazer altera√ß√µes incompat√≠veis com vers√µes anteriores\n"
" da linguagem.\n"
"\n"
" * Para evitar quebra de c√≥digo, as edi√ß√µes s√£o opcionais: voc√™ seleciona a\n"
" edi√ß√£o para o seu _crate_ atrav√©s do arquivo `Cargo.toml`.\n"
"\n"
" * Para evitar a divis√£o do ecossistema, os compiladores Rust podem misturar c√≥digo\n"
" escrito para diferentes edi√ß√µes.\n"
"\n"
" * Mencione que √© muito raro usar o compilador diretamente, n√£o atrav√©s do `cargo` (a maioria dos usu√°rios nunca o faz).\n"
"\n"
" * Pode valer a pena mencionar que o pr√≥prio Cargo √© uma ferramenta extremamente poderosa e abrangente. Ele √© capaz de muitos recursos avan√ßados, incluindo, entre outros:\n"
"    * Estrutura do projeto/pacote\n"
"    * [Espa√ßos de trabalho][workspaces]\n"
"    * Depend√™ncias de desenvolvimento e gerenciamento/cache de depend√™ncia de tempo de execu√ß√£o\n"
"    * [Criar scripts][build scripting]\n"
"    * [Instala√ß√£o global][global installation]\n"
"    * Tamb√©m √© extens√≠vel com plugins de sub-comando (tais como [cargo clippy]).\n"
" * Leia mais no [livro oficial do Cargo][official Cargo Book]"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# Exemplos de C√≥digo neste Treinamento"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples\n"
"which can be executed through your browser. This makes the setup much easier and\n"
"ensures a consistent experience for everyone."
msgstr ""
"Para este treinamento, exploraremos principalmente a linguagem Rust por meio de exemplos\n"
"que podem ser executados atrav√©s do seu navegador. Isso torna a instala√ß√£o muito mais f√°cil e\n"
"garante uma experi√™ncia consistente para todos."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do the\n"
"exercises. On the last day, we will do a larger exercise which shows you how to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"A instala√ß√£o do Cargo ainda assim √© incentivada: ser√° mais f√°cil para voc√™ fazer os\n"
"exerc√≠cios. No √∫ltimo dia, faremos um exerc√≠cio maior que mostra como\n"
"trabalhar com depend√™ncias e para isso voc√™ precisar√° do Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "Os blocos de c√≥digo neste curso s√£o totalmente interativos:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    println!(\"Edite-me!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the\n"
"text box."
msgstr ""
"Voc√™ pode usar <kbd>Ctrl + Enter</kbd> para executar o c√≥digo quando o foco estiver na\n"
"caixa de texto."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr ""
"A maioria dos exemplos de c√≥digo s√£o edit√°veis, como mostrado acima. Alguns exemplos de c√≥digo\n"
"n√£o s√£o edit√°veis por v√°rios motivos:"

#: src/cargo/code-samples.md:27
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests.\n"
"\n"
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* Os _playgrounds_ embutidos n√£o conseguem executar testes unit√°rios. Copie o\n"
" c√≥digo e cole no _Playground_ real para demonstrar os testes unit√°rios.\n"
"\n"
"* Os _playgrounds_ embutidos perdem seu estado no momento em que voc√™ navega\n"
" para outra p√°gina! Esta √© a raz√£o pela qual os alunos devem\n"
" resolver os exerc√≠cios usando uma instala√ß√£o do Rust local ou via\n"
" Playground real."

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# Executando C√≥digo Localmente com o Cargo"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"Se voc√™ quiser experimentar o c√≥digo em seu pr√≥prio sistema, precisar√°\n"
"primeiro instalar o Rust. Fa√ßa isso seguindo as [instru√ß√µes no Livro do Rust][1].\n"
"Isso deve fornecer o `rustc` e o `cargo` funcionando. Quando este curso\n"
"foi escrito, as √∫ltimas vers√µes est√°veis do Rust s√£o:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.69.0 (84c898d65 2023-04-16)\n"
"% cargo --version\n"
"cargo 1.69.0 (6e9a83356 2023-04-12)\n"
"```"
msgstr ""
"```shell\n"
"% rustc ‚Äîversion\n"
"rustc 1.69.0 (84c898d65 2023-04-16)\n"
"% cargo ‚Äîversion\n"
"cargo 1.69.0 (6e9a83356 2023-04-12)\n"
"```"

#: src/cargo/running-locally.md:15
msgid ""
"With this in place, follow these steps to build a Rust binary from one\n"
"of the examples in this training:"
msgstr ""
"Com isso finalizado, siga estas etapas para criar um bin√°rio Rust a partir de um\n"
"dos exemplos deste treinamento:"

#: src/cargo/running-locally.md:18
msgid ""
"1. Click the \"Copy to clipboard\" button on the example you want to copy.\n"
"\n"
"2. Use `cargo new exercise` to create a new `exercise/` directory for your code:\n"
"\n"
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```\n"
"\n"
"3. Navigate into `exercise/` and use `cargo run` to build and run your binary:\n"
"\n"
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```\n"
"\n"
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look like\n"
"\n"
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```\n"
"\n"
"5. Use `cargo run` to build and run your updated binary:\n"
"\n"
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```\n"
"\n"
"6. Use `cargo check` to quickly check your project for errors, use `cargo build`\n"
"   to compile it without running it. You will find the output in `target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an optimized\n"
"   release build in `target/release/`.\n"
"\n"
"7. You can add dependencies for your project by editing `Cargo.toml`. When you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""
"1. Clique no bot√£o _\"Copy to clipboard\"_ (\"Copiar para a √°rea de transfer√™ncia\") no exemplo que deseja copiar.\n"
"\n"
"2. Use `cargo new exercise` para criar um novo diret√≥rio `exercise/` para o seu c√≥digo:\n"
"\n"
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```\n"
"\n"
"3. Navegue at√© `exercise/` e use `cargo run` para compilar e executar seu bin√°rio:\n"
"\n"
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```\n"
"\n"
"4. Substitua o c√≥digo gerado em `src/main.rs` pelo seu pr√≥prio c√≥digo. Por\n"
" exemplo, usando o exemplo da p√°gina anterior, fa√ßa `src/main.rs` parecer como\n"
"\n"
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```\n"
"\n"
"5. Use `cargo run` para compilar e executar seu bin√°rio atualizado:\n"
"\n"
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```\n"
"\n"
"6. Use `cargo check` para verificar rapidamente se h√° erros em seu projeto, use `cargo build`\n"
" para compil√°-lo sem execut√°-lo. Voc√™ encontrar√° a sa√≠da em `target/debug/`\n"
" para uma compila√ß√£o de depura√ß√£o normal. Use `cargo build --release` para produzir um bin√°rio\n"
" otimizado em `target/release/`.\n"
"\n"
"7. Voc√™ pode adicionar depend√™ncias para seu projeto editando `Cargo.toml`. Quando voc√™\n"
" execute os comandos `cargo`, ele ir√° baixar e compilar automaticamente\n"
" depend√™ncias para voc√™."

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"Tente encorajar os participantes do curso a instalar o Cargo e usar um\n"
"editor local. Isso facilitar√° a vida deles, pois eles ter√£o um\n"
"ambiente normal de desenvolvimento."

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# Bem-vindo ao Dia 1"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr ""
"Este √© o primeiro dia do Comprehensive Rust. N√≥s cobriremos muitos pontos\n"
"hoje:"

#: src/welcome-day-1.md:6
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods.\n"
"\n"
"* Memory management: stack vs heap, manual memory management, scope-based memory\n"
"  management, and garbage collection.\n"
"\n"
"* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"Sintaxe Rust b√°sica: vari√°veis, tipos escalares e compostos, enums, structs,\n"
"refer√™ncias, fun√ß√µes e m√©todos.\n"
"\n"
"Gerenciamento de mem√≥ria: pilha versus heap, gerenciamento de mem√≥ria manual, gerenciamento de mem√≥ria baseado em\n"
"escopo e _garbage collection_ (coleta de lixo).\n"
"\n"
"_Ownership_ (posse): sem√¢ntica de _move_, c√≥pia e clonagem, _borrow_ (empr√©stimo) e _lifetime_ (tempo de vida)."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Lembre aos alunos que:"

#: src/welcome-day-1.md:18
#, fuzzy
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, i.e.,\n"
"    keep the discussions related to how Rust does things vs some other language. \n"
"    It can be hard to find the right balance, but err on the side of allowing \n"
"    discussions since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we talk about things ahead of the slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* Eles devem fazer perguntas na hora, n√£o as guarde para o fim.\n"
"* A aula √© para ser interativa e as discuss√µes s√£o muito encorajadas!\n"
"  * Como instrutor, voc√™ deve tentar manter as discuss√µes relevantes, ou seja,\n"
"    mantenha as discuss√µes relacionadas a como o Rust faz as coisas versus alguma outra linguagem.\n"
"    Pode ser dif√≠cil encontrar o equil√≠brio certo, mas procure permitir mais discuss√µes,\n"
"    uma vez que elas engajam as pessoas muito mais do que uma comunica√ß√£o unidirecional.\n"
"* As perguntas provavelmente far√£o com que falemos sobre coisas antes dos slides.\n"
"  * Isso est√° perfeitamente OK! A repeti√ß√£o √© uma parte importante do aprendizado. Lembre-se\n"
"    que os slides s√£o apenas um suporte e voc√™ est√° livre para ignor√°-los quando\n"
"    quiser."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to speak\n"
"about the famous borrow checker. The way Rust handles memory is a major feature\n"
"and we should show students this right away."
msgstr ""
"A ideia para o primeiro dia √© mostrar _apenas o suficiente_ de Rust para poder falar\n"
"sobre o famoso _borrow checker_ (verificador de empr√©stimos). A maneira como o Rust lida\n"
"com a mem√≥ria √© uma caracter√≠stica importante e devemos mostrar isso aos alunos imediatamente."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Se voc√™ estiver ensinando isso em uma sala de aula, este √© um bom lugar para repassar\n"
"o cronograma. Sugerimos dividir o dia em duas partes (seguindo os slides):"

#: src/welcome-day-1.md:36
msgid ""
"* Morning: 9:00 to 12:00,\n"
"* Afternoon: 13:00 to 16:00."
msgstr ""
"* Manh√£: 9h √†s 12h,\n"
"* Tarde: 13h √†s 16h."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include breaks,\n"
"we recommend a break every hour!"
msgstr ""
"√â claro que voc√™ pode ajustar isso conforme necess√°rio. Certifique-se de incluir pausas,\n"
"recomendamos uma a cada hora!"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# O que √© Rust?"

#: src/welcome-day-1/what-is-rust.md:3
msgid "Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr "Rust √© uma nova linguagem de programa√ß√£o que teve sua [vers√£o 1.0 lan√ßada em 2015][1]:"

#: src/welcome-day-1/what-is-rust.md:5
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust √© uma linguagem compilada estaticamente e tem um papel semelhante ao C++\n"
"  * `rustc` usa o LLVM como back-end.\n"
"* Rust suporta muitas [plataformas e\n"
"  arquiteturas](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust √© usado em uma ampla gama de dispositivos:\n"
"  * firmware e carregadores de boot,\n"
"  * monitores inteligentes,\n"
"  * celulares,\n"
"  * desktops,\n"
"  * servidores."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust se encaixa na mesma √°rea que C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* Alta flexibilidade.\n"
"* Alto n√≠vel de controle.\n"
"* Pode ser reduzido para dispositivos com menor poder computacional, como telefones celulares.\n"
"* N√£o tem _runtime_ ou _garbage collection_.\n"
"* Concentra-se em confiabilidade e seguran√ßa sem sacrificar o desempenho."

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# Ol√° Mundo!"

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr "Vamos pular para o programa em Rust mais simples poss√≠vel, o cl√°ssico \"Ol√° Mundo\":"

#: src/hello-world.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hello üåç!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Ol√°, üåç!\");\n"
"}\n"
"```"

#: src/hello-world.md:12
msgid "What you see:"
msgstr "O que voc√™ v√™:"

#: src/hello-world.md:14
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* Fun√ß√µes s√£o introduzidas com `fn`.\n"
"* Os blocos s√£o delimitados por chaves como em C e C++.\n"
"* A fun√ß√£o `main` √© o ponto de entrada do programa.\n"
"* Rust tem macros \"higi√™nicas\", `println!` √© um exemplo disso.\n"
"* As strings Rust s√£o codificadas em UTF-8 e podem conter qualquer caractere Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will see\n"
"a ton of it over the next four days so we start small with something familiar."
msgstr ""
"Este slide tenta deixar os alunos familiarizados com o c√≥digo em Rust. Eles v√£o ver\n"
"uma tonelada nos pr√≥ximos quatro dias, ent√£o come√ßamos pequeno e com algo familiar."

#: src/hello-world.md:27
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary.\n"
"\n"
"* Rust is modern with full support for things like Unicode.\n"
"\n"
"* Rust uses macros for situations where you want to have a variable number of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md)).\n"
"\n"
"* Macros being 'hygienic' means they don't accidentally capture identifiers from\n"
"  the scope they are used in. Rust macros are actually only\n"
"  [partially hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)."
msgstr ""
"* Rust √© muito parecido com outras linguagens na tradi√ß√£o C/C++/Java. √â\n"
"imperativo (n√£o funcional) e n√£o tenta reinventar as coisas, a menos que\n"
"seja absolutamente necess√°rio.\n"
"\n"
"* Rust √© moderno com suporte total para coisas como Unicode.\n"
"\n"
"* Rust usa macros para situa√ß√µes em que voc√™ deseja ter um n√∫mero vari√°vel\n"
"de argumentos (sem [sobrecarga de fun√ß√£o](basic-syntax/functions-interlude.md)).\n"
"\n"
"* As macros sendo ‚Äòhigi√™nicas‚Äô significa que elas n√£o capturam acidentalmente\n"
"identificadores do escopo em que s√£o usadas. As macros em Rust s√£o, na verdade,\n"
"apenas [parcialmente higi√™nicas](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)."

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# Um pequeno exemplo"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Aqui est√° um pequeno programa de exemplo em Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {              // Ponto de entrada do programa\n"
"    let mut x: i32 = 6;  // Atribui√ß√£o de uma vari√°vel mut√°vel\n"
"    print!(\"{x}\");       // Macro para escrever na tela, como printf\n"
"    while x != 1 {       // Sem par√™nteses ao redor de express√µes\n"
"        if x % 2 == 0 {  // Matem√°tica como em outras linguagens\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop will\n"
"always end, but this is not yet proved. Edit the code and play with different\n"
"inputs."
msgstr ""
"O c√≥digo implementa a conjectura de Collatz: acredita-se que o loop\n"
"sempre termina, mas isso ainda n√£o est√° provado. Edite o c√≥digo e tente diferentes\n"
"entradas."

#: src/hello-world/small-example.md:29
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer overflow.\n"
"\n"
"* Change `let mut x` to `let x`, discuss the compiler error.\n"
"\n"
"* Show how `print!` gives a compilation error if the arguments don't match the\n"
"  format string.\n"
"\n"
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable.\n"
"\n"
"* Show the students the standard library, show them how to search for `std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that the\n"
"  students become familiar with searching in the standard library.\n"
"    \n"
"    * In a shell `rustup doc std::fmt` will open a browser on the local std::fmt documentation"
msgstr ""
"* Explique que todas as vari√°veis ‚Äã‚Äãs√£o tipadas estaticamente. Tente remover `i32`\n"
"para acionar a infer√™ncia de tipo. Em vez disso, tente com `i8` e cause um estouro\n"
"de n√∫mero inteiro (_integer overflow_) em tempo de execu√ß√£o.\n"
"\n"
"* Altere `let mut x` para `let x`, discuta o erro do compilador.\n"
"\n"
"* Mostre como `print!` cause um erro de compila√ß√£o se os\n"
"argumentos n√£o corresponderem √† string de formato.\n"
"\n"
"* Mostre como voc√™ precisa usar `{}` como um espa√ßo reservado se quiser\n"
"imprimir uma express√£o que seja mais complexa do que apenas uma √∫nica vari√°vel.\n"
"\n"
"* Mostre aos alunos a biblioteca padr√£o (_standard library_), mostre como pesquisar\n"
"`std::fmt`, o qual possui as regras da mini-linguagem de formata√ß√£o. √â importante que\n"
"os alunos se familiarizem com pesquisas na biblioteca padr√£o.\n"
"\n"
"    * Em um shell `rustup doc std::fmt` abrir√° um navegador na documenta√ß√£o std::fmt local."

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# Por que Rust?"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Alguns pontos exclusivos do Rust:"

#: src/why-rust.md:5
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* Seguran√ßa de mem√≥ria em tempo de compila√ß√£o.\n"
"* Sem comportamento indefinido em tempo de execu√ß√£o.\n"
"* Recursos de linguagem de programa√ß√£o modernas."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr ""
"Certifique-se de perguntar √† classe com quais linguagens de programa√ß√£o eles t√™m experi√™ncia. "
"Dependendo\n"
"da resposta voc√™ pode destacar diferentes caracter√≠sticas do Rust:"

#: src/why-rust.md:14
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you don't\n"
"  have the memory unsafety issues. In addition, you get a modern language with\n"
"  constructs like pattern matching and built-in dependency management.\n"
"\n"
"* Experience with Java, Go, Python, JavaScript...: You get the same memory safety\n"
"  as in those languages, plus a similar high-level language feeling. In addition\n"
"  you get fast and predictable performance like C and C++ (no garbage collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* Experi√™ncia com C ou C++: Rust elimina toda uma classe de _erros em tempo de execu√ß√£o_\n"
" atrav√©s do verificador de empr√©stimos (_borrow checker_). Voc√™ obt√©m desempenho como em C e C++, mas sem\n"
" os problemas de inseguran√ßa de mem√≥ria. Al√©m disso, voc√™ tem uma linguagem com\n"
" funcionalidades modernas como correspond√™ncia de padr√µes e gerenciamento de depend√™ncia integrado.\n"
"\n"
"* Experi√™ncia com Java, Go, Python, JavaScript...: Voc√™ tem a mesma seguran√ßa de mem√≥ria\n"
" como nessas linguagens, al√©m de uma semelhan√ßa com linguagens de alto n√≠vel. Al√©m disso\n"
" voc√™ obt√©m desempenho r√°pido e previs√≠vel como C e C++ (sem coletor de lixo ou \"_garbage collector_\")\n"
" bem como acesso a hardware de baixo n√≠vel (caso voc√™ precise)"

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# Garantias em Tempo de Compila√ß√£o"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Gerenciamento de mem√≥ria est√°tica em tempo de compila√ß√£o:"

#: src/why-rust/compile-time.md:5
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* Sem vari√°veis n√£o inicializadas.\n"
"* Sem vazamentos de mem√≥ria (_quase_, veja as notas).\n"
"* Sem _double-frees_.\n"
"* Sem _use-after-free_.\n"
"* Sem ponteiros `NULL`.\n"
"* Sem _mutexes_ bloqueados esquecidos.\n"
"* Sem concorr√™ncia de dados entre _threads_.\n"
"* Sem invalida√ß√£o de iteradores."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr ""
"√â poss√≠vel produzir vazamentos de mem√≥ria no Rust (seguro). Alguns exemplos\n"
"s√£o:"

#: src/why-rust/compile-time.md:19
#, fuzzy
msgid ""
"* You can use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* Voc√™ pode usar [`Box::leak`] para vazar um ponteiro. Um uso para isso poderia\n"
"  ser para obter vari√°veis est√°ticas inicializadas e dimensionadas em tempo de execu√ß√£o\n"
"* Voc√™ pode usar [`std::mem::forget`] para fazer o compilador \"esquecer\" sobre\n"
"  um valor (o que significa que o destrutor nunca √© executado).\n"
"* Voc√™ tamb√©m pode criar acidentalmente uma [refer√™ncia c√≠clica][reference cycle] com `Rc` ou\n"
"  `Arc`.\n"
"* Na verdade, alguns considerar√£o que preencher infinitamente uma cole√ß√£o (estruturas de dados)\n"
"  seja um vazamento de mem√≥ria e o Rust n√£o protege disso."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr ""
"Para o prop√≥sito deste curso, \"Sem vazamentos de mem√≥ria\" deve ser entendido\n"
"como \"Praticamente sem vazamentos de mem√≥ria *acidentais*\"."

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# Garantias em Tempo de Execu√ß√£o"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Nenhum comportamento indefinido em tempo de execu√ß√£o:"

#: src/why-rust/runtime.md:5
msgid ""
"* Array access is bounds checked.\n"
"* Integer overflow is defined."
msgstr ""
"* O acesso a matrizes tem limites verificados.\n"
"* Estouro de n√∫meros inteiros √© definido."

#: src/why-rust/runtime.md:12
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`).\n"
"\n"
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* O estouro de n√∫meros inteiros √© definido por meio de uma _flag_ em tempo de compila√ß√£o. As op√ß√µes s√£o\n"
" um p√¢nico (uma falha controlada do programa) ou sem√¢ntica\n"
" wrap-around. Por padr√£o, voc√™ obt√©m p√¢nicos em modo de depura√ß√£o (`cargo build`)\n"
" e wrap-around em modo de produ√ß√£o (`cargo build --release`).\n"
"\n"
"* A verifica√ß√£o de limites (\"_bounds checking_\") n√£o pode ser desativada com uma _flag_ do compilador.\n"
"Ela tamb√©m n√£o pode ser desativada diretamente com a palavra-chave `unsafe`. No entanto,\n"
" `unsafe` permite que voc√™ chame fun√ß√µes como `slice::get_unchecked`\n"
" que n√£o faz verifica√ß√£o de limites."

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# Recursos Modernos"

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr "O Rust √© constru√≠do com toda a experi√™ncia adquirida nos √∫ltimos 40 anos."

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## Caracter√≠sticas da Linguagem"

#: src/why-rust/modern.md:7
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* Enums e correspond√™ncia de padr√µes.\n"
"* _Generics_.\n"
"* FFI sem _overhead_.\n"
"* Abstra√ß√µes de custo zero."

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## Ferramentas"

#: src/why-rust/modern.md:14
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* Excelentes mensagens de erro do compilador.\n"
"* Gerenciador de depend√™ncias integrado.\n"
"* Suporte integrado para testes.\n"
"* Excelente suporte ao protocolo de servidor de linguagem (LSP)."

#: src/why-rust/modern.md:23
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to 'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct.\n"
"\n"
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`.\n"
"\n"
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with _actionable_\n"
"  feedback, ready to copy-paste into your code.\n"
"\n"
"* The Rust standard library is small compared to languages like Java, Python,\n"
"  and Go. Rust does not come with several things you might consider standard and\n"
"  essential:\n"
"\n"
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json].\n"
"\n"
"  The reasoning behind this is that functionality in the standard library cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps there\n"
"  isn't a single \"best solution\" for some of these things.\n"
"\n"
"  Rust comes with a built-in package manager in the form of Cargo and this makes\n"
"  it trivial to download and compile third-party crates. A consequence of this\n"
"  is that the standard library can be smaller.\n"
"\n"
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"* Abstra√ß√µes de custo zero, semelhantes ao C++, significa que voc√™ n√£o precisa ‚Äòpagar‚Äô\n"
" por constru√ß√µes de programa√ß√£o de alto n√≠vel com mem√≥ria ou CPU. Por exemplo,\n"
" escrever um loop usando `for` deve resultar aproximadamente no mesmo n√≠vel\n"
" de instru√ß√µes de baixo n√≠vel quanto usar a constru√ß√£o `.iter().fold()`.\n"
"\n"
"* Pode valer a pena mencionar que Rust enums s√£o ‚ÄòTipos de Dados Alg√©bricos‚Äô\n"
"(‚Äò_Algebraic Data Types_‚Äô), tamb√©m conhecidos como ‚Äòtipos de soma‚Äô, que permitem que o\n"
"sistema de tipos expresse coisas como `Option<T>` e `Result<T, E>`.\n"
"\n"
"* Lembre as pessoas de lerem os erros --- muitos desenvolvedores se acostumaram\n"
" ignore as longas mensagens do compilador. O compilador Rust √© significativamente mais\n"
" \"verbal\" do que outros compiladores. Muitas vezes, ele lhe fornecer√° sugest√µes _pr√°ticas_,\n"
"prontas para copiar e colar em seu c√≥digo.\n"
"\n"
"* A biblioteca padr√£o do Rust (_Rust standard library_) √© pequena comparada a linguagens\n"
"como Java, Python e Go. Rust n√£o vem com v√°rias coisas que voc√™ pode considerar padr√£o e essencial:\n"
"\n"
"   * um gerador de n√∫meros aleat√≥rios, mas veja [rand].\n"
"   * suporte para SSL ou TLS, mas consulte [rusttls].\n"
"   * suporte para JSON, mas consulte [serde_json].\n"
"\n"
"   O racioc√≠nio por tr√°s disso √© que funcionalidade na biblioteca padr√£o n√£o pode\n"
"   ser descartada, portanto ela tem que ser muito est√°vel. Para os exemplos acima,\n"
"   a comunidade do Rust ainda est√° trabalhando para encontrar a melhor solu√ß√£o --- e\n"
"   talvez n√£o exista uma √∫nica \"melhor solu√ß√£o\" para algumas dessas coisas.\n"
"\n"
"   Rust vem com um gerenciador de pacotes embutido na forma de Cargo e isso torna\n"
"   trivial baixar e compilar _crates_ de terceiros. Uma consequ√™ncia disso\n"
"   √© que a biblioteca padr√£o pode ser menor.\n"
"\n"
"   Descobrir bons _crates_ de terceiros pode ser um problema. Sites como\n"
"   <https://lib.rs/> ajudam com isso, permitindo que voc√™ compare m√©tricas de\n"
"   _crates_ para encontrar um bom e confi√°vel.\n"
"  \n"
"* [rust-analyzer] √© uma implementa√ß√£o LSP bem suportada usada pelas principais\n"
" IDEs e editores de texto."

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# Sintaxe B√°sica"

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Grande parte da sintaxe do Rust ser√° familiar para voc√™ que vem de C, C++ ou Java:"

#: src/basic-syntax.md:5
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* ...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* Blocos e escopos s√£o delimitados por chaves.\n"
"* Coment√°rios de linha s√£o iniciados com `//`, coment√°rios de bloco s√£o delimitados por `/* ...\n"
"  */`.\n"
"* Palavras-chave como `if` e `while` funcionam da mesma forma.\n"
"* A atribui√ß√£o de vari√°veis √© feita com `=`, a compara√ß√£o √© feita com `==`."

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# Tipos Escalares"

#: src/basic-syntax/scalar-types.md:3
msgid ""
"|                        | Types                                      | "
"Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, "
"`123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, "
"`10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | `3.14`, `-10.0e20`, "
"`2f32`    |\n"
"| Strings                | `&str`                                     | `\"foo\"`, "
"`\"two\\nlines\"`       |\n"
"| Unicode scalar values  | `char`                                     | `'a'`, `'Œ±'`, "
"`'‚àû'`           |\n"
"| Booleans               | `bool`                                     | `true`, "
"`false`               |"
msgstr ""
"|                           | Tipos                                      | Literais                      |\n"
"|---------------------------|--------------------------------------------|------------------------------ |\n"
"| Inteiros com sinal        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123i64` |\n"
"| Inteiros sem sinal        | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10u16`           |\n"
"| N√∫meros de ponto flutuante| `f32`, `f64`                               | `3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                   | `&str`                                     | `\"foo\"`, `\"two\\nlines\"`       |\n"
"| Valores escalares Unicode | `char`                                     | `‚Äôa‚Äô`, `‚ÄôŒ±‚Äô`, `‚Äô‚àû‚Äô`           |\n"
"| Booleanos                 | `bool`                                     | `true`, `false`               |"

#: src/basic-syntax/scalar-types.md:12
msgid "The types have widths as follows:"
msgstr "Os tipos t√™m os seguintes tamanhos:"

#: src/basic-syntax/scalar-types.md:14
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* `iN`, `uN` e `fN` t√™m _N_ bits,\n"
"* `isize` e `usize` s√£o do tamanho de um ponteiro,\n"
"* `char` tem 32 bits,\n"
"* `bool` tem 8 bits."

#: src/basic-syntax/scalar-types.md:21
msgid "There are a few syntaxes which are not shown above:"
msgstr "H√° algumas sintaxes que n√£o s√£o mostradas acima:"

#: src/basic-syntax/scalar-types.md:23
msgid ""
"- Raw strings allow you to create a `&str` value with escapes disabled: `r\"\\n\"\n"
"  == \"\\\\\\\\n\"`. You can embed double-quotes by using an equal amount of `#` on\n"
"  either side of the quotes:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"      println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"  }\n"
"  ```\n"
"\n"
"- Byte strings allow you to create a `&[u8]` value directly:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(\"{:?}\", b\"abc\");\n"
"      println!(\"{:?}\", &[97, 98, 99]);\n"
"  }\n"
"  ```"
msgstr ""
"- Strings brutas permitem que voc√™ crie um valor `&str` com caracteres de escape desabilitados: `r\"\\n\"\n"
"  == \"\\\\\\\\n\"`. Voc√™ pode embutir aspas duplas utilizando uma quantidade igual de `#` em\n"
"  Ambos os lados das aspas:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"      println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"  }\n"
"  ```\n"
"\n"
"- Strings de byte permitem que voc√™ crie um valor `&[u8]` diretamente:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(\"{:?}\", b\"abc\");\n"
"      println!(\"{:?}\", &[97, 98, 99]);\n"
"  }\n"
"  ```"

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# Tipos Compostos"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"
msgstr ""
"|        | Tipos                         | Literais                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Matrizes | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuplas | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Atribui√ß√£o e acesso a matrizes:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Atribui√ß√£o e acesso a tuplas:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1¬∫ √≠ndice: {}\", t.0);\n"
"    println!(\"2¬∫ √≠ndice: {}\", t.1);\n"
"}\n"
"```"

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Vetores:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that `[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types.\n"
"\n"
"* We can use literals to assign values to arrays.\n"
"\n"
"* In the main function, the print statement asks for the debug implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after the\n"
"  format string.\n"
"\n"
"* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be easier to read."
msgstr ""
"* Matrizes t√™m elementos do mesmo tipo, `T`, and tamanho, `N`, o qual √© uma constante em tempo de compila√ß√£o.\n"
" Note que o tamanho de uma matriz √© *parte do seu tipo*, o que significa que `[u8; 3]` e\n"
" `[u8; 4]` s√£o considerados dois tipos diferentes.\n"
"\n"
"* N√≥s podemos usar literais para atribuir valores para matrizes.\n"
"\n"
"* Na fun√ß√£o `main`, o comando `print` pede a implementa√ß√£o de depura√ß√£o (_debug_) com o par√¢metro\n"
" de formato formato `?`: `{}` produz a sa√≠da padr√£o, `{:?}` produz a sa√≠da de depura√ß√£o. N√≥s\n"
" tamb√©m poder√≠amos ter usado `{a}` e `{a:?}` sem especificar o valor depois da string\n"
" de formato.\n"
"\n"
"* Adicionando `#`, p.ex. `{a:#?}`, invoca um formato \"_pretty printing_\" (\"impress√£o bonita\"), que pode ser mais leg√≠vel."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Tuplas:"

#: src/basic-syntax/compound-types.md:49
msgid ""
"* Like arrays, tuples have a fixed length.\n"
"\n"
"* Tuples group together values of different types into a compound type.\n"
"\n"
"* Fields of a tuple can be accessed by the period and the index of the value, e.g. `t.0`, `t.1`.\n"
"\n"
"* The empty tuple `()` is also known as the \"unit type\". It is both a type, and\n"
"  the only valid value of that type - that is to say both the type and its value\n"
"  are expressed as `()`. It is used to indicate, for example, that a function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* Assim como matrizes, tuplas t√™m tamanho fixo.\n"
"\n"
"* Tuplas agrupam valores de diferentes tipos em um tipo composto.\n"
"\n"
"* Campos de uma tupla podem ser acessados com um ponto e o √≠ndice do valor, e.g. `t.0`, `t.1`.\n"
"\n"
"* A tupla vazia `()` tamb√©m √© conhecida como \"tipo unidade\" (_unit type_). √â tanto\n"
"um tipo quanto o √∫nico valor v√°lido desse tipo - ou seja, o tipo e seu valor\n"
"s√£o expressos como `()`. √â usado para indicar, por exemplo, que uma fun√ß√£o ou\n"
"express√£o n√£o tem valor de retorno, como veremos em um slide futuro.\n"
"    * Voc√™ pode pensar nisso como um `void`, que talvez lhe seja familiar\n"
"    de outras linguagens de programa√ß√£o."

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# Refer√™ncias"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Como C++, o Rust tem refer√™ncias:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Algumas notas:"

#: src/basic-syntax/references.md:16
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values over their lifetime."
msgstr ""
"* Devemos desreferenciar `ref_x` ao atribu√≠-lo um valor, semelhante √† ponteiros em C e C++.\n"
"* Em alguns casos, o Rust desreferenciar√° automaticamente, em particular ao invocar\n"
" m√©todos (tente `ref_x.count_ones()`).\n"
"* As refer√™ncias que s√£o declaradas como `mut` podem ser vinculadas a diferentes valores ao longo de seu tempo de vida."

#: src/basic-syntax/references.md:25
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound to\n"
"  different values, while the second represents a reference to a mutable value."
msgstr ""
"* Certifique-se de observar a diferen√ßa entre `let mut ref_x: &i32` e `let ref_x:\n"
"  &mut i32`. O primeiro representa uma refer√™ncia mut√°vel que pode ser ligada a\n"
"  diferentes valores, enquanto o segundo representa uma refer√™ncia a um valor mut√°vel."

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# Refer√™ncias Soltas"

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust estaticamente proibir√° refer√™ncias pendentes:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* Diz-se que uma refer√™ncia \"pega emprestado\" o valor a que se refere.\n"
"* Rust est√° rastreando os tempos de vida de todas as refer√™ncias para garantir que elas durem\n"
"  o suficiente.\n"
"* Falaremos mais sobre empr√©stimos quando chegarmos √† _ownership_."

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# Slices"

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "Uma _slice_ (fatia) oferece uma vis√£o de uma cole√ß√£o maior:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"\n"
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"\n"
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/slices.md:15
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* As slices pegam dados emprestados do tipo original.\n"
"* Pergunta: O que acontece se voc√™ modificar `a[3]`?"

#: src/basic-syntax/slices.md:20
msgid ""
"* We create a slice by borrowing `a` and specifying the starting and ending indexes in brackets.\n"
"\n"
"* If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the starting index, "
"meaning that `&a[0..a.len()]` and `&a[..a.len()]` are identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are identical.\n"
"\n"
"* To easily create a slice of the full array, we can therefore use `&a[..]`.\n"
"\n"
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` (`&[i32]`) no longer "
"mentions the array length. This allows us to perform computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to remain 'alive' (in scope) "
"for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, but the answer is that "
"for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read the data from both `a` "
"and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* N√≥s criamos uma _slice_ emprestando `a` e especificando os √≠ndices de in√≠cio e fim entre colchetes.\n"
"\n"
"* Se a _slice_ come√ßa no √≠ndice 0, a sintaxe de _range_ (faixa) nos permite omitir o √≠ndice inicial, o que significa que `&a[0..a.len()]` e `&a[..a.len()]` s√£o id√™nticos.\n"
"\n"
"* O mesmo vale para o √∫ltimo √≠ndice, logo `&a[2..a.len()]` e `&a[2..]` s√£o id√™nticos.\n"
"\n"
"* Para criar facilmente uma _slice_ de uma matriz completa, podemos utilizar`&a[..]`.\n"
"\n"
"* `s` √© uma refer√™ncia a uma _slice_ de `i32`. Observe que o tipo de `s` (`&[i32]`) n√£o menciona mais o tamanho da matriz. Isso nos permite realizar c√°lculos em _slices_ de tamanhos diferentes.\n"
" \n"
"* As _slices_ sempre pegam emprestado de outro objeto. Neste exemplo, `a` deve permanecer ‚Äòvivo‚Äô (em escopo) por pelo menos tanto tempo quanto nossa _slice_.\n"
" \n"
"* A quest√£o sobre a modifica√ß√£o de `a[3]` pode gerar uma discuss√£o interessante, mas a resposta √© que por motivos de seguran√ßa de mem√≥ria\n"
" voc√™ n√£o pode fazer isso por meio de `a` depois de criar uma _slice_, mas voc√™ pode ler os dados de `a` e `s` com seguran√ßa.\n"
" Mais detalhes ser√£o explicados na se√ß√£o do verificador de empr√©stimos."

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String` vs `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "Agora podemos entender os dois tipos de strings em Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminologia do Rust:"

#: src/basic-syntax/string-slices.md:22
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` √© uma refer√™ncia imut√°vel para uma _slice_ de string.\n"
"* `String` √© um _buffer_ de string mut√°vel."

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 encoded string data \n"
"  stored in a block of memory. String literals (`\"Hello\"`), are stored in the program‚Äôs binary.\n"
"\n"
"* Rust‚Äôs `String` type is a wrapper around a vector of bytes. As with a `Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string literal; `String::"
"new()` \n"
"  creates a new empty string, to which string data can be added using the `push()` and "
"`push_str()` methods.\n"
"\n"
"* The `format!()` macro is a convenient way to generate an owned string from dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of `std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string "
"optimization).\n"
"    "
msgstr ""
"* `&str` introduz uma _slice_ de string, a qual √© uma refer√™ncia imut√°vel para os dados da string em formato UTF-8\n"
" armazenados em um bloco de mem√≥ria. Literais de string (`\"Hello\"`) s√£o armazenadas no c√≥digo bin√°rio do programa.\n"
"\n"
"* O tipo `String` do Rust √© um inv√≥lucro ao redor de uma matriz de bytes. Assim como um `Vec<T>`, ele √© _owned_.\n"
"\n"
"* Da mesma forma que outros tipos, `String::from()` cria uma string a partir de um literal; `String::new()` \n"
"  cria uma nova string vazia, na qual dados de string podem ser adicionados com os m√©todos `push()` e `push_str()`.\n"
"\n"
"* A macro `format!()` √© uma maneira conveniente de gerar uma string _owned_ a partir de valores din√¢micos. Ela\n"
"  aceita os mesmos formatadores que `println!()`.\n"
"    \n"
"* Voc√™ pode emprestar _slices_ `&str` de `String` atrav√©s do operador `&` e, opcionalmente, selecionar um _range_ (\"intervalo\").\n"
"    \n"
"* Para programadores C++: pense em `&str` como `const char*` de C++, mas que sempre aponta\n"
"  para uma string v√°lida na mem√≥ria. Em Rust, `String` √© um equivalente aproximado de `std::string` de C++\n"
"  (principal diferen√ßa: ele s√≥ pode conter bytes codificados em UTF-8 e nunca usar√° uma otimiza√ß√£o "
"de string pequena).\n"
"    \n"
"</details>"

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# Fun√ß√µes"

#: src/basic-syntax/functions.md:3
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview "
"question:"
msgstr ""
"Uma vers√£o em Rust da famosa pergunta de entrevistas [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    print_fizzbuzz_to(20);\n"
"}\n"
"\n"
"fn is_divisible(n: u32, divisor: u32) -> bool {\n"
"    if divisor == 0 {\n"
"        return false;\n"
"    }\n"
"    n % divisor == 0\n"
"}\n"
"\n"
"fn fizzbuzz(n: u32) -> String {\n"
"    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
"    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
"    if fizz.is_empty() && buzz.is_empty() {\n"
"        return format!(\"{n}\");\n"
"    }\n"
"    format!(\"{fizz}{buzz}\")\n"
"}\n"
"\n"
"fn print_fizzbuzz_to(n: u32) {\n"
"    for i in 1..=n {\n"
"        println!(\"{}\", fizzbuzz(i));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward declarations nor headers are "
"necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some programming languages), then "
"a return type.\n"
"* The last expression in a function body (or any block) becomes the return value. Simply omit the "
"`;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The compiler will infer "
"this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `print_fizzbuzz_to()` contains `=n`, which causes it "
"to include the upper bound."
msgstr ""
"* Nos referimos em `main` a uma fun√ß√£o escrita abaixo. Nem declara√ß√µes pr√©vias e nem cabe√ßalhos s√£o necess√°rios.\n"
"* Os par√¢metros de declara√ß√£o s√£o seguidos por um tipo (o inverso de algumas linguagens de programa√ß√£o) e, em seguida, um tipo de retorno.\n"
"* A √∫ltima express√£o em um corpo de uma fun√ß√£o (ou qualquer bloco) torna-se o valor de retorno. Simplesmente omita o `;` no final da express√£o.\n"
"* Algumas fun√ß√µes n√£o t√™m valor de retorno e retornam o 'tipo unit√°rio', `()`. O compilador ir√° inferir isso se o tipo de retorno `-> ()` for omitido.\n"
"* A express√£o de intervalo no loop `for` em `fizzbuzz_to()` cont√©m `=n`, o que faz com que inclua o limite superior."

#: src/basic-syntax/rustdoc.md:1
msgid "# Rustdoc"
msgstr "# Rustdoc"

#: src/basic-syntax/rustdoc.md:3
msgid "All language items in Rust can be documented using special `///` syntax."
msgstr "Todos os itens da linguagem podem ser documentados com a sintaxe especial `///`."

#: src/basic-syntax/rustdoc.md:5
msgid ""
"```rust,editable\n"
"/// Determine whether the first argument is divisible by the second argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return value\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"/// Determine se o primeiro argumento √© divis√≠vel pelo segundo argumento.\n"
"///\n"
"/// Se o segundo argumento for zero, o resultado √© falso.\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Caso excepcional, retorne antes\n"
"    }\n"
"    lhs % rhs == 0     // A √∫ltima express√£o do bloco √© o valor de retorno\n"
"}\n"
"```"

#: src/basic-syntax/rustdoc.md:17
msgid ""
"The contents are treated as Markdown. All published Rust library crates are\n"
"automatically documented at [`docs.rs`](https://docs.rs) using the\n"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is\n"
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"O conte√∫dio √© tratado como _Markdown_. Todos os _crates_ publicados na biblioteca Rust s√£o\n"
"documentados automaticamente em [`docs.rs`](https://docs.rs) utilizando a\n"
"ferramenta [rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html). √â idiom√°tico\n"
"documentar todos os itens p√∫blicos em uma API usando este padr√£o."

#: src/basic-syntax/rustdoc.md:24
msgid ""
"* Show students the generated docs for the `rand` crate at\n"
"  [`docs.rs/rand`](https://docs.rs/rand).\n"
"\n"
"* This course does not include rustdoc on slides, just to save space, but in\n"
"  real code they should be present.\n"
"\n"
"* Inner doc comments are discussed later (in the page on modules) and need not\n"
"  be addressed here."
msgstr ""
"* Mostre aos alunos os documentos gerados para o crate `rand` em\n"
"  [`docs.rs/rand`](https://docs.rs/rand).\n"
"\n"
"* Este curso n√£o inclui o rustdoc nos slides, apenas para economizar espa√ßo, mas em\n"
"  c√≥digo real eles devem estar presentes.\n"
"\n"
"* Os coment√°rios internos do documento s√£o discutidos posteriormente (na p√°gina sobre m√≥dulos) e n√£o precisam ser\n"
"  ser abordados aqui."

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# M√©todos"

#: src/basic-syntax/methods.md:3
msgid ""
"Methods are functions associated with a type. The `self` argument of a method is\n"
"an instance of the type it is associated with:"
msgstr ""
"M√©todos s√£o fun√ß√µes associadas a um tipo espec√≠fico. O primeiro argumento (`self`)\n"
"de um m√©todo √© uma inst√¢ncia do tipo ao qual est√° associado:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"struct Retangulo {\n"
"    largura: u32,\n"
"    altura: u32,\n"
"}\n"
"\n"
"impl Retangulo {\n"
"    fn area(&self) -> u32 {\n"
"        self.largura * self.altura\n"
"    }\n"
"\n"
"    fn aum_largura(&mut self, delta: u32) {\n"
"        self.largura += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut ret = Retangulo { largura: 10, altura: 5 };\n"
"    println!(\"area antiga: {}\", ret.area());\n"
"    ret.aum_largura(5);\n"
"    println!(\"nova area: {}\", ret.area());\n"
"}\n"
"```"

#: src/basic-syntax/methods.md:30
msgid "* We will look much more at methods in today's exercise and in tomorrow's class."
msgstr "* Veremos muito mais sobre m√©todos no exerc√≠cio de hoje e na aula de amanh√£."

#: src/basic-syntax/methods.md:34
msgid ""
"- Add a `Rectangle::new` constructor and call this from `main`:\n"
"\n"
"    ```rust,editable,compile_fail\n"
"    fn new(width: u32, height: u32) -> Rectangle {\n"
"        Rectangle { width, height }\n"
"    }\n"
"    ```\n"
"\n"
"- Add a `Rectangle::new_square(width: u32)` constructor to illustrate that\n"
"  constructors can take arbitrary parameters."
msgstr ""
"- Adicione um construtor `Retangulo::new` e o chame a partir de `main`:\n"
"\n"
"    ```rust,editable,compile_fail\n"
"    fn new(largura: u32, altura: u32) -> Retangulo {\n"
"        Retangulo { largura, altura }\n"
"    }\n"
"    ```\n"
"\n"
"- Adicione um construtor `Rectangle::novo_quadrado(largura: u32)` para ilustrar que\n"
"  construtores podem ter par√¢metros arbitr√°rios."

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# Sobrecarga de Fun√ß√µes"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "Sobrecarga n√£o √© suportada:"

#: src/basic-syntax/functions-interlude.md:5
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* Cada fun√ß√£o tem uma √∫nica implementa√ß√£o:\n"
"  * Sempre tem um n√∫mero fixo de par√¢metros.\n"
"  * Sempre usa um √∫nico conjunto de tipos de par√¢metros.\n"
"* Valores padr√£o n√£o s√£o suportados:\n"
"  * Todos as chamadas t√™m o mesmo n√∫mero de argumentos.\n"
"  * √Äs vezes macros s√£o utilizadas como alternativa."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "No entanto, os par√¢metros da fun√ß√£o podem ser tipos gen√©ricos:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn escolha_um<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"lance da moeda: {}\", escolha_um(\"cara\", \"coroa\"));\n"
"    println!(\"pr√™mio em dinheiro: {}\", escolha_um(500, 1000));\n"
"}\n"
"```"

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind of limited\n"
"  polymorphism on argument types. We will see more details in a later section."
msgstr ""
"* Ao usar tipos gen√©ricos, o `Into<T>` da biblioteca padr√£o pode fornecer um tipo de polimorfismo\n"
"  limitado nos tipos de argumento. Veremos mais detalhes em uma se√ß√£o posterior."

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# Dia 1: Exerc√≠cios Matinais"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "Nestes exerc√≠cios, vamos explorar duas partes do Rust:"

#: src/exercises/day-1/morning.md:5
msgid ""
"* Implicit conversions between types.\n"
"\n"
"* Arrays and `for` loops."
msgstr ""
"* Convers√µes impl√≠citas entre tipos.\n"
"\n"
"* Matrizes (_Arrays_) e la√ßos (loops) `for`."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr "Algumas coisas a considerar ao resolver os exerc√≠cios:"

#: src/exercises/day-1/morning.md:13
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for details\n"
"  on installing Rust.\n"
"\n"
"* Alternatively, use the Rust Playground."
msgstr ""
"* Se poss√≠vel, use uma instala√ß√£o local do Rust. Desta forma, voc√™ pode obter\n"
"  preenchimento autom√°tico em seu editor. Veja a p√°gina sobre [Utiliza√ß√£o do Cargo][Using Cargo] para detalhes\n"
"  sobre instala√ß√£o do Rust.\n"
"\n"
"* Alternativamente, utilize o Rust Playground."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose\n"
"their state if you navigate away from the page."
msgstr ""
"Os trechos de c√≥digo n√£o s√£o edit√°veis de prop√≥sito: os trechos de c√≥digo embutidos perdem\n"
"seu estado se voc√™ sair da p√°gina."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/bare-metal/morning.md:7
#: src/exercises/bare-metal/afternoon.md:7 src/exercises/concurrency/morning.md:12
#: src/exercises/concurrency/afternoon.md:13
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "Depois de ver os exerc√≠cios, voc√™ pode ver as [solu√ß√µes][solutions] fornecidas."

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# Convers√µes Impl√≠citas"

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types ([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust n√£o aplicar√° automaticamente _convers√µes impl√≠citas_ entre os tipos ([ao contr√°rio\n"
"de C++][3]). Voc√™ pode ver isso em um programa como este:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"\n"
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;\n"
"\n"
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn multiplicar(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"\n"
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;\n"
"\n"
"    println!(\"{x} * {y} = {}\", multiplicar(x, y));\n"
"}\n"
"```"

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single `from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted into\n"
"another type."
msgstr ""
"Todos os tipos inteiros do Rust implementam os _traits_ [`From<T>`][1] e [`Into<T>`][2]\n"
"para nos deixar converter entre eles. O trait `From<T>` tem um √∫nico m√©todo `from()`\n"
"e da mesma forma, o trait `Into<T>` tem um √∫nico m√©todo `into()`.\n"
"A implementa√ß√£o desses traits √© como um tipo expressa que pode ser convertido em\n"
"outro tipo."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"A biblioteca padr√£o tem uma implementa√ß√£o de `From<i8> for i16`, o que significa\n"
"que podemos converter uma vari√°vel `x` do tipo `i8` para um `i16` chamando\n"
"`i16::from(x)`. Ou, mais simples, com `x.into()`, porque a implementa√ß√£o `From<i8> for i16`\n"
"cria automaticamente uma implementa√ß√£o de `Into<i16> for i8`."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so it is\n"
"sufficient to only implement `From` to get a respective `Into` implementation automatically."
msgstr ""
"O mesmo se aplica √†s suas pr√≥prias implementa√ß√µes de `From` para seus pr√≥prios tipos, logo √©\n"
"suficiente implementar apenas `From` para obter uma respectiva implementa√ß√£o `Into` automaticamente."

#: src/exercises/day-1/implicit-conversions.md:33
msgid ""
"1. Execute the above program and look at the compiler error.\n"
"\n"
"2. Update the code above to use `into()` to do the conversion.\n"
"\n"
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented for\n"
"   the pairs you check."
msgstr ""
"1. Execute o programa acima e observe o erro de compila√ß√£o.\n"
"\n"
"2. Atualize o c√≥digo acima para utilizar `into()` para fazer a convers√£o.\n"
"\n"
"3. Mude os tipos de `x` e `y` para outros tipos (como `f32`, `bool`,\n"
"   `i128`) para ver quais tipos voc√™ pode converter para quais outros tipos. Experimente\n"
"   converter tipos pequenos em tipos grandes e vice-versa. Verifique a\n"
"   [documenta√ß√£o da biblioteca padr√£o][1] para ver se `From<T>` est√° implementado para\n"
"   os pares que voc√™ verificar."

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# Matrizes (Arrays) e La√ßos (Loops) `for`"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "Vimos que uma matriz pode ser declarada assim:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""
"```rust\n"
"let matriz = [10, 20, 30];\n"
"```"

#: src/exercises/day-1/for-loops.md:9
msgid "You can print such an array by asking for its debug representation with `{:?}`:"
msgstr "Voc√™ pode imprimir tal matriz solicitando sua representa√ß√£o de depura√ß√£o com `{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let matriz = [10, 20, 30];\n"
"    println!(\"matriz: {matriz:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr ""
"Rust permite iterar em coisas como matrizes e _ranges_ (faixas ou intervalos) usando\n"
"a palavra-chave `for`:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let matriz = [10, 20, 30];\n"
"    print!(\"Iterando sobre a matriz:\");\n"
"    for n in matriz {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterando sobre um range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", matriz[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix and\n"
"a function `transpose` which will transpose a matrix (turn rows into columns):"
msgstr ""
"Use o exerc√≠cio acima para escrever uma fun√ß√£o `pretty_print` que imprime uma matriz e\n"
"uma fun√ß√£o `transpose` que ir√° transpor uma matriz (transformar linhas em colunas):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           ‚éõ‚é°1 2 3‚é§‚éû      ‚é°1 4 7‚é§\n"
"\"transpose\"‚éú‚é¢4 5 6‚é•‚éü  \"==\"‚é¢2 5 8‚é•\n"
"           ‚éù‚é£7 8 9‚é¶‚é†      ‚é£3 6 9‚é¶\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3 √ó 3 matrices."
msgstr "Limite ambas as fun√ß√µes a operar em matrizes 3 √ó 3."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/> e implemente as\n"
"fun√ß√µes:"

#: src/exercises/day-1/for-loops.md:52
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: remova isto quando voc√™ terminar sua implementa√ß√£o .\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matriz: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matriz = [\n"
"        [101, 102, 103], // <-- o coment√°rio faz com que o rustfmt adicione uma nova linha\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matriz:\");\n"
"    pretty_print(&matriz);\n"
"\n"
"    let transposed = transpose(matriz);\n"
"    println!(\"transposta:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## Pergunta B√¥nus"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 √ó 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"Voc√™ poderia usar slices `&[i32]` em vez de matrizes 3 √ó 3 fixas no c√≥digo para o seu\n"
"argumento e tipos de retorno? Algo como `&[&[i32]]` para um slice-de-slices\n"
"bidimensional. Por que sim ou por que n√£o?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality\n"
"implementation."
msgstr ""
"Veja o crate [`ndarray`](https://docs.rs/ndarray/) para uma implementa√ß√£o de \n"
"produ√ß√£o."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"A solu√ß√£o e a resposta para a se√ß√£o de b√¥nus est√£o dispon√≠veis na\n"
"Se√ß√£o [Solu√ß√µes](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "# Vari√°veis"

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable by\n"
"default:"
msgstr ""
"Rust fornece seguran√ßa de tipo por meio de tipagem est√°tica. Vari√°veis s√£o imut√°veis por\n"
"padr√£o:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the types less and less as "
"the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the function like syntax of "
"`println!(\"x: {}\", x)`"
msgstr ""
"* Devido √† infer√™ncia de tipos, o `i32` √© opcional. Gradualmente mostraremos os tipos cada vez "
"menos √† medida que o curso progride.\n"
"* Observe que como `println!` √© uma macro, `x` n√£o √© movido, mesmo usando uma sintaxe parecida com "
"a de uma fun√ß√£o `println!(\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:1
msgid "# Type Inference"
msgstr "# Infer√™ncia do Tipo"

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust ver√° como a vari√°vel √© _usada_ para determinar o tipo:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"\n"
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;\n"
"\n"
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn recebe_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"\n"
"fn recebe_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;\n"
"\n"
"    recebe_u32(x);\n"
"    recebe_i8(y);\n"
"    // recebe_u32(y);\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on constraints given by variable "
"declarations and usages."
msgstr ""
"Este slide demonstra como o compilador Rust infere tipos com base em restri√ß√µes dadas por "
"declara√ß√µes e usos de vari√°veis."

#: src/basic-syntax/type-inference.md:28
msgid ""
"It is very important to emphasize that variables declared like this are not of some sort of "
"dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical to the explicit "
"declaration of a type.\n"
"The compiler does the job for us and helps us write more concise code."
msgstr ""
"√â muito importante enfatizar que vari√°veis declaradas assim n√£o s√£o de um tipo din√¢mico \"qualquer "
"tipo\" que possa\n"
"armazenar quaisquer dados. O c√≥digo de m√°quina gerado por tal declara√ß√£o √© id√™ntico √† declara√ß√£o "
"expl√≠cita de um tipo.\n"
"O compilador faz o trabalho para n√≥s e nos ajuda a escrever um c√≥digo mais conciso."

#: src/basic-syntax/type-inference.md:32
msgid ""
"The following code tells the compiler to copy into a certain generic container without the code "
"ever explicitly specifying the contained type, using `_` as a placeholder:"
msgstr ""
"O c√≥digo a seguir informa ao compilador para copiar para um determinado cont√™iner gen√©rico sem que "
"o c√≥digo especifique explicitamente o tipo contido, usando `_` como _placeholder_:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"\n"
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"\n"
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/type-inference.md:46
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) relies "
"on `FromIterator`, which [`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) depende "
"de `FromIterator`, que [`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implementa."

#: src/basic-syntax/static-and-const.md:1
msgid "# Static and Constant Variables"
msgstr "# Vari√°veis Est√°ticas e Constantes"

#: src/basic-syntax/static-and-const.md:3
msgid "Global state is managed with static and constant variables."
msgstr "O estado global √© gerenciado com vari√°veis est√°ticas e constantes."

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr "## `const`"

#: src/basic-syntax/static-and-const.md:7
msgid "You can declare compile-time constants:"
msgstr "Voc√™ pode declarar constantes em tempo de compila√ß√£o:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"\n"
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}\n"
"\n"
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"const TAMANHO_RESUMO: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"\n"
"fn computar_resumo(texto: &str) -> [u8; TAMANHO_RESUMO] {\n"
"    let mut resumo = [ZERO.unwrap_or(0); TAMANHO_RESUMO];\n"
"    for (idx, &b) in texto.as_bytes().iter().enumerate() {\n"
"        resumo[idx % TAMANHO_RESUMO] = resumo[idx % TAMANHO_RESUMO].wrapping_add(b);\n"
"    }\n"
"    resumo\n"
"}\n"
"\n"
"fn main() {\n"
"    let resumo = computar_resumo(\"Ol√°\");\n"
"    println!(\"Resumo: {resumo:?}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:27
msgid "According to the [Rust RFC Book][1] these are inlined upon use."
msgstr "De acordo com o [Rust RFC Book][1], eles s√£o expandidos no pr√≥prio local (_inline_) quando utilizados."

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr "## `static`"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "Voc√™ tamb√©m pode declarar vari√°veis est√°ticas:"

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"static BANNER: &str = \"Bem-vindo ao RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"

#: src/basic-syntax/static-and-const.md:41
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have an actual associated "
"memory location.  This is useful for unsafe and embedded code, and the variable lives through the "
"entirety of the program execution."
msgstr ""
"Conforme observado no [Rust RFC Book][1], `static` e `const` n√£o s√£o expandidos em linha (_inlined_) "
"quando utilizados e possuem um local de mem√≥ria real associado. Isso √© √∫til para c√≥digo inseguro (_unsafe_) e "
"embarcado, e a vari√°vel sobrevive durante toda a execu√ß√£o do programa."

#: src/basic-syntax/static-and-const.md:44
msgid "We will look at mutating static data in the [chapter on Unsafe Rust](../unsafe.md)."
msgstr "Veremos a muta√ß√£o de dados est√°ticos no [cap√≠tulo sobre Rust Inseguro (_Unsafe_)](../unsafe.md)."

#: src/basic-syntax/static-and-const.md:48
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable global variable in C+"
"+.\n"
"* It isn't super common that one would need a runtime evaluated constant, but it is helpful and "
"safer than using a static."
msgstr ""
"* Mencione que `const` se comporta semanticamente similar ao `constexpr` de C++.\n"
"* `static`, por outro lado, √© muito mais parecido com um `const` ou vari√°vel global mut√°vel em C++.\n"
"* N√£o √© muito comum que algu√©m precise de uma constante avaliada em tempo de execu√ß√£o, mas √© √∫til "
"e mais seguro do que usar uma est√°tica."

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# Escopos e _Shadowing_ (Sobreposi√ß√£o)"

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from the\n"
"same scope:"
msgstr ""
"Voc√™ pode sobrepor (_shadow_) vari√°veis, tanto aquelas de escopos externos quanto de vari√°veis do\n"
"mesmo escopo:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"\n"
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }\n"
"\n"
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"antes: {a}\");\n"
"\n"
"    {\n"
"        let a = \"ol√°\";\n"
"        println!(\"escopo interno: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"sobreposto no escopo interno: {a}\");\n"
"    }\n"
"\n"
"    println!(\"depois: {a}\");\n"
"}\n"
"```"

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing both variable's memory "
"locations exist at the same time. Both are available under the same name, depending where you use "
"it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory locations when "
"shadowing an immutable variable in a scope, even if the type does not change."
msgstr ""
"* Defini√ß√£o: _Shadowing_ √© diferente da muta√ß√£o, porque ap√≥s a sobreposi√ß√£o (_shadowing_), os locais de "
"mem√≥ria de ambas as vari√°veis existem ao mesmo tempo. Ambas est√£o dispon√≠veis com o mesmo nome, "
"dependendo de onde voc√™ as usa no c√≥digo.\n"
"* Uma vari√°vel sobreposta pode ter um tipo diferente.\n"
"* A sobreposi√ß√£o parece obscura a princ√≠pio, mas √© conveniente para manter os valores ap√≥s `.unwrap()`.\n"
"* O c√≥digo a seguir demonstra por que o compilador n√£o pode simplesmente reutilizar locais de "
"mem√≥ria ao sobrepor uma vari√°vel imut√°vel em um escopo, mesmo que o tipo n√£o seja alterado."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# Gerenciamento de Mem√≥ria"

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradicionalmente, as linguagens se dividem em duas grandes categorias:"

#: src/memory-management.md:5
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ..."
msgstr ""
"* Controle total atrav√©s do gerenciamento manual de mem√≥ria: C, C++, Pascal, ...\n"
"* Seguran√ßa total atrav√©s do gerenciamento autom√°tico de mem√≥ria em tempo de execu√ß√£o: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust oferece uma nova combina√ß√£o:"

#: src/memory-management.md:10
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> Controle total **_e_** seguran√ßa por imposi√ß√£o do correto gerenciamento de mem√≥ria em tempo de\n"
"> compila√ß√£o."

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "Ele faz isso com um conceito de _ownership_ (posse) expl√≠cito."

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "Primeiro, vamos rever como funciona o gerenciamento de mem√≥ria."

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# A Pilha (_Stack_) vs O _Heap_"

#: src/memory-management/stack-vs-heap.md:3
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality.\n"
"\n"
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* Pilha: √Årea cont√≠nua de mem√≥ria para vari√°veis locais.\n"
"  * Os valores t√™m tamanhos fixos conhecidos em tempo de compila√ß√£o.\n"
"  * Extremamente r√°pida: basta mover um ponteiro de pilha.\n"
"  * F√°cil de gerenciar: segue chamadas de fun√ß√£o.\n"
"  * √ìtima localidade de mem√≥ria."
"\n"
"* Heap: Armazenamento de valores fora das chamadas de fun√ß√£o.\n"
"  * Valores possuem tamanhos din√¢micos determinados em tempo de execu√ß√£o.\n"
"  * Ligeiramente mais devagar que a pilha: √© necess√°rio um pouco de gerenciamento.\n"
"  * Sem garantias de localidade de mem√≥ria."

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# Mem√≥ria de Pilha (_Stack Memory_)"

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically sized\n"
"data on the heap:"
msgstr ""
"A cria√ß√£o de uma `String` coloca dados de tamanho fixo na pilha e dados dimensionados dinamicamente\n"
"no heap:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                               Heap\n"
".- - - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                             :     :                               :\n"
":                             :     :                               :\n"
":   +------------+-------+    :     :   +----+----+----+----+----+  :\n"
":   | ptr        |   o---+----+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | tamanho    |     5 |    :     :   +----+----+----+----+----+  :\n"
":   | capacidade |     5 |    :     :                               :\n"
":   +------------+-------+    :     :                               :\n"
":                             :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/stack.md:28
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and length and can grow if "
"mutable via reallocation on the heap.\n"
"\n"
"* If students ask about it, you can mention that the underlying memory is heap allocated using the "
"[System Allocator] and custom allocators can be implemented using the [Allocator API]\n"
"\n"
"* We can inspect the memory layout with `unsafe` code. However, you should point out that this is "
"rightfully unsafe!\n"
"\n"
"    ```rust,editable\n"
"    fn main() {\n"
"        let mut s1 = String::from(\"Hello\");\n"
"        s1.push(' ');\n"
"        s1.push_str(\"world\");\n"
"        // DON'T DO THIS AT HOME! For educational purposes only.\n"
"        // String provides no guarantees about its layout, so this could lead to\n"
"        // undefined behavior.\n"
"        unsafe {\n"
"            let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"            println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"        }\n"
"    }\n"
"    ```"
msgstr ""
"* Mencione que uma `String` √© suportada por um `Vec`, portanto ela tem um tamanho e capacidade e pode crescer se "
"for mut√°vel por meio de realoca√ß√£o no heap.\n"
"\n"
"* Se os alunos perguntarem sobre isso, voc√™ pode mencionar que a mem√≥ria subjacente √© alocada no heap usando o "
"_[System Allocator]_ e os alocadores personalizados podem ser implementados usando a _[API Allocator][Allocator API]_.\n"
"\n"
"* Podemos inspecionar o layout da mem√≥ria com c√≥digo inseguro (`unsafe`). No entanto, voc√™ deve apontar que isso √© "
"legitimamente inseguro!\n"
"\n"
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Ol√°\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"mundo\");\n"
"    // N√ÉO FA√áA ISSO EM CASA! Somente com prop√≥sito educacional.\n"
"    // String n√£o fornece nenhuma garantia sobre o seu layout, ent√£o isso pode levar\n"
"    // a um comportamento indefinido.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"        println!(\"Ponteiro = {ptr:#x}, tamanho = {len}, capacidade = {capacity}\");\n"
"    }\n"
"}\n"
"```"

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# Gerenciamento Manual de Mem√≥ria"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Voc√™ mesmo aloca e desaloca mem√≥ria no heap."

#: src/memory-management/manual.md:5
msgid ""
"If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks."
msgstr ""
"Se n√£o for feito com cuidado, isso pode levar a travamentos, bugs, vulnerabilidades de seguran√ßa e vazamentos de mem√≥ria."

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## Exemplo em C"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "Voc√™ deve chamar `free` em cada ponteiro que alocar com `malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_matriz = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... v√°rias linhas de c√≥digo\n"
"    //\n"
"    free(int_matriz);\n"
"}\n"
"```"

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr ""
"Mem√≥ria √© vazada se a fun√ß√£o retornar mais cedo entre `malloc` e `free`: o\n"
"ponteiro √© perdido e n√£o podemos desalocar a mem√≥ria."

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# Gerenciamento de Mem√≥ria Baseado em Escopo"

#: src/memory-management/scope-based.md:3
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr "Construtores e destrutores permitem que o tempo de vida de um objeto seja rastreado."

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception is\n"
"raised."
msgstr ""
"Ao envolver um ponteiro em um objeto, voc√™ pode liberar mem√≥ria quando o objeto √©\n"
"destru√≠do. O compilador garante que isso aconte√ßa, mesmo que uma exce√ß√£o seja\n"
"lan√ßada."

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and gives\n"
"you smart pointers."
msgstr ""
"Isso geralmente √© chamado de _aquisi√ß√£o de recursos √© inicializa√ß√£o_ (_Resource Acquisition Is Initialization_, RAII) e fornece\n"
"ponteiros inteligentes (_smart pointers_)."

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## Exemplo em C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""
"```c++\n"
"void diga_ola(std::unique_ptr<Pessoa> pessoa) {\n"
"  std::cout << \"Ol√° \" << pessoa->nome << std::endl;\n"
"}\n"
"```"

#: src/memory-management/scope-based.md:20
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* O objeto `std::unique_ptr` √© alocado na pilha e aponta para\n"
"  mem√≥ria alocada no heap.\n"
"* No final de `diga_ola`, o destrutor `std::unique_ptr` ser√° executado.\n"
"* O destrutor libera o objeto `Pessoa` para o qual ele aponta."

#: src/memory-management/scope-based.md:25
msgid "Special move constructors are used when passing ownership to a function:"
msgstr "Construtores especiais de movimento (_move_) s√£o usados ao passar o _\"ownership\"_ para uma fun√ß√£o:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""
"```c++\n"
"std::unique_ptr<Pessoa> pessoa = encontrar_pessoa(\"Carla\");\n"
"diga_ola(std::move(pessoa));\n"
"```"

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "# Gerenciamento Autom√°tico de Mem√≥ria"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic memory\n"
"management:"
msgstr ""
"Uma alternativa ao gerenciamento de mem√≥ria manual e baseado em escopo √© o gerenciamento autom√°tico\n"
"de mem√≥ria:"

#: src/memory-management/garbage-collection.md:6
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the programmer."
msgstr ""
"* O programador nunca aloca ou desaloca mem√≥ria explicitamente.\n"
"* Um \"coletor de lixo\" (_garbage collector_) encontra mem√≥ria n√£o utilizada e a desaloca para o programador."

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Exemplo em Java"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "O objeto `pessoa` n√£o √© desalocado depois que `digaOla` retorna:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""
"```java\n"
"void digaOla(Pessoa pessoa) {\n"
"  System.out.println(\"Ol√° \" + pessoa.obterNome());\n"
"}\n"
"```"

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# Gerenciamento de Mem√≥ria no Rust"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "O gerenciamento de mem√≥ria no Rust √© uma combina√ß√£o:"

#: src/memory-management/rust.md:5
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you choose, can be a single "
"unique pointer, reference counted, or atomically reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even have no cost at "
"runtime like C."
msgstr ""
"* Seguro e correto como Java, mas sem um coletor de lixo.\n"
"* Dependendo de qual abstra√ß√£o (ou combina√ß√£o de abstra√ß√µes) voc√™ escolher, pode ser um simples "
"ponteiro √∫nico, refer√™ncia contada ou refer√™ncia atomicamente contada.\n"
"* Baseado em escopo como C++, mas o compilador imp√µe ades√£o total.\n"
"* Um usu√°rio do Rust pode escolher a abstra√ß√£o certa para a situa√ß√£o, algumas at√© sem custo em "
"tempo de execu√ß√£o como C."

#: src/memory-management/rust.md:10
msgid "Rust achieves this by modeling _ownership_ explicitly."
msgstr "O Rust consegue isso modelando a propriedade (_ownership_) explicitamente."

#: src/memory-management/rust.md:14
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper "
"types such as [Box], [Vec], [Rc], or [Arc]. These encapsulate ownership and memory allocation via "
"various means, and prevent the potential errors in C.\n"
"\n"
"* You may be asked about destructors here, the [Drop] trait is the Rust equivalent."
msgstr ""
"* Neste ponto, se perguntado como, voc√™ pode mencionar que em Rust isso geralmente √© tratado por "
"_wrappers_ (inv√≥lucros) RAII tais como [Box], [Vec], [Rc] ou [Arc]. Eles encapsulam a propriedade (ownership) e a "
"aloca√ß√£o de mem√≥ria por v√°rios meios e previnem os erros poss√≠veis em C."
"\n"
"* Aqui voc√™ pode ser perguntado sobre destrutores, o _trait_ [Drop] √© o equivalente em Rust."

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# Compara√ß√£o"

#: src/memory-management/comparison.md:3
msgid "Here is a rough comparison of the memory management techniques."
msgstr "Aqui est√° uma compara√ß√£o aproximada das t√©cnicas de gerenciamento de mem√≥ria."

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## Vantagens de Diferentes T√©cnicas de Gerenciamento de Mem√≥ria"

#: src/memory-management/comparison.md:7
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Manual como C:\n"
"  * Nenhuma sobrecarga em tempo de execu√ß√£o.\n"
"* Autom√°tico como Java:\n"
"  * Totalmente automatizado.\n"
"  * Seguro e correto.\n"
"* Baseado em escopo como C++:\n"
"  * Parcialmente autom√°tico.\n"
"  * Nenhuma sobrecarga em tempo de execu√ß√£o.\n"
"* Baseado em escopo imposto pelo compilador como Rust:\n"
"  * Imposto pelo compilador.\n"
"  * Nenhuma sobrecarga em tempo de execu√ß√£o.\n"
"  * Seguro e correto."

#: src/memory-management/comparison.md:20
msgid "## Cons of Different Memory Management Techniques"
msgstr "## Desvantagens de Diferentes T√©cnicas de Gerenciamento de Mem√≥ria"

#: src/memory-management/comparison.md:22
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Manual como C:\n"
"  * Uso ap√≥s a libera√ß√£o (_use-after-free_).\n"
"  * Libera√ß√µes duplas (_double-frees_).\n"
"  * Vazamentos de mem√≥ria.\n"
"* Autom√°tico como Java:\n"
"  * Pausas para coleta de lixo.\n"
"  * Atrasos na execu√ß√£o de destrutores.\n"
"* Baseado em escopo como C++:\n"
"  * Complexo, o programador deve optar em utiliz√°-las.\n"
"  * Potencial para uso ap√≥s a libera√ß√£o (_use-after-free_).\n"
"* Imposto pelo compilador e baseado em escopo como Rust:\n"
"  * Alguma complexidade inicial.\n"
"  * Pode rejeitar programas v√°lidos."

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# Ownership (_\"Posse\"_)"

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error to\n"
"use a variable outside its scope:"
msgstr ""
"Todas as associa√ß√µes de vari√°veis t√™m um _escopo_ onde s√£o v√°lidas e √© um erro\n"
"usar uma vari√°vel fora de seu escopo:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    {\n"
"        let p = Ponto(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"

#: src/ownership.md:18
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* No final do escopo, a vari√°vel √© eliminada (_\"dropada\"_) e os dados s√£o liberados.\n"
"* Um destrutor pode ser executado aqui para liberar recursos.\n"
"* Dizemos que a vari√°vel _possui_ (_owns_) o valor."

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# Sem√¢ntica do `Move` (Mover)"

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer ownership between variables:"
msgstr "Uma atribui√ß√£o transferir√° a _ownership_ entre vari√°veis:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Ol√°!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/ownership/move-semantics.md:14
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* A atribui√ß√£o de `s1` a `s2` transfere a _ownership_.\n"
"* Os dados foram _movidos_ de `s1` e `s1` n√£o est√° mais acess√≠vel.\n"
"* Quando `s1` sai do escopo, nada acontece: ele n√£o tem _ownership_.\n"
"* Quando `s2` sai do escopo, os dados da string s√£o liberados.\n"
"* H√° sempre _exatamente_ uma associa√ß√£o de vari√°vel que possui (owns) um valor."

#: src/ownership/move-semantics.md:22
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by value unless you use "
"`std::move` (and the move constructor is defined!).\n"
"\n"
"* In Rust, clones are explicit (by using `clone`)."
msgstr ""
"* Mencione que isso √© o oposto dos _defaults_ (padr√µes) em C++, que copia por valor, a menos que voc√™ use "
"`std::move` (e o construtor `move` esteja definido!)."
"\n"
"* No Rust, clones s√£o expl√≠citos (utilizando-se `clone`)."

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# Strings Movidas em Rust"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* Os dados no heap de `s1` s√£o reutilizados para `s2`.\n"
"* Quando `s1` sai do escopo, nada acontece (foi movido dele)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Antes de mover para `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +------------+------+   :     :   +----+----+----+----+   :\n"
":   | ponteiro   |  o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | tamanho    |    4 |   :     :   +----+----+----+----+   :\n"
":   | capacidade |    4 |   :     :                           :\n"
":   +------------+------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Depois de mover para `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inacess√≠vel)\"     :     :                           :\n"
":   +------------+------+   :     :   +----+----+----+----+   :\n"
":   | ponteiro   |  o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | tamanho    |    4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacidade |    4 |   :  |  :                           :\n"
":   +------------+------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +------------+------+   :  |\n"
":   | ponteiro   |  o---+---+--'\n"
":   | tamanho    |    4 |   :\n"
":   | capacidade |    4 |   :\n"
":   +------------+------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# Libera√ß√µes Duplas (_Double Frees_) em C++ Moderno"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "O C++ moderno resolve isso de maneira diferente:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplica os dados em s1.\n"
"```"

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* Os dados de `s1` no heap s√£o duplicados e `s2` obt√©m sua pr√≥pria c√≥pia independente.\n"
"* Quando `s1` e `s2` saem de escopo, cada um libera sua pr√≥pria mem√≥ria."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Antes da atribui√ß√£o por c√≥pia:"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | tam       |     3 |   :     :   +----+----+----+    :\n"
":   | capac     |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Ap√≥s atribui√ß√£o por c√≥pia:"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | tam       |     3 |   :     :   +----+----+----+    :\n"
":   | capac     |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | tam       |     3 |   :     :   +----+----+----+    :\n"
":   | capac     |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/ownership/moves-function-calls.md:1
msgid "# Moves in Function Calls"
msgstr "# _Moves_ (Movimentos) em Chamadas de Fun√ß√£o"

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr ""
"Quando voc√™ passa um valor para uma fun√ß√£o, o valor √© atribu√≠do ao par√¢metro\n"
"da fun√ß√£o. Isso transfere a _ownership_:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn diga_ola(nome: String) {\n"
"    println!(\"Ol√° {nome}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let nome = String::from(\"Alice\");\n"
"    diga_ola(nome);\n"
"    // diga_ola(nome);\n"
"}\n"
"```"

#: src/ownership/moves-function-calls.md:20
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. Afterwards, `name` "
"cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the `say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) and if `say_hello` "
"accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call (`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making move semantics the "
"default, and by forcing programmers to make clones explicit."
msgstr ""
"* Com a primeira chamada para `diga_ola`, `main` desiste da ownership de `nome`. Depois disso, "
"`nome` n√£o pode mais ser usado dentro de `main`.\n"
"* A mem√≥ria do heap alocada para `nome` ser√° liberada no final da fun√ß√£o `diga_ola`.\n"
"* `main` pode manter a ownership se passar `nome` como uma refer√™ncia (`&nome`) e se `diga_ola` "
"aceitar uma refer√™ncia como um par√¢metro.\n"
"* Alternativamente, `main` pode passar um clone de `nome` na primeira chamada (`nome.clone()`).\n"
"* Rust torna mais dif√≠cil a cria√ß√£o de c√≥pias inadvertidamente do que o C++, tornando padr√£o a sem√¢ntica "
"de movimento e for√ßando os programadores a tornar os clones expl√≠citos."

#: src/ownership/copy-clone.md:1
msgid "# Copying and Cloning"
msgstr "# Copia e Clonagem"

#: src/ownership/copy-clone.md:3
msgid "While move semantics are the default, certain types are copied by default:"
msgstr "Embora a sem√¢ntica de movimento seja o padr√£o, certos tipos s√£o copiados por padr√£o:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "Esses tipos implementam o _trait_ `Copy`."

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr "Voc√™ pode habilitar seus pr√≥prios tipos para usar a sem√¢ntica de c√≥pia:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Ponto(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p1 = Ponto(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"

#: src/ownership/copy-clone.md:30
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* Ap√≥s a atribui√ß√£o, tanto `p1` quanto `p2` possuem seus pr√≥prios dados.\n"
"* Tamb√©m podemos usar `p1.clone()` para copiar os dados explicitamente."

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "Copia e clonagem n√£o s√£o a mesma coisa:"

#: src/ownership/copy-clone.md:37
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by implementing the "
"`Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* C√≥pia refere-se a c√≥pias bit a bit de regi√µes de mem√≥ria e n√£o funciona em objetos arbitr√°rios.\n"
"* C√≥pia n√£o permite l√≥gica personalizada (ao contr√°rio dos construtores de c√≥pia em C++).\n"
"* Clonagem √© uma opera√ß√£o mais geral e tamb√©m permite um comportamento personalizado atrav√©s da "
"implementa√ß√£o do trait `Clone`.\n"
"* C√≥pia n√£o funciona em tipos que implementam o trait `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "No exemplo acima, tente o seguinte:"

#: src/ownership/copy-clone.md:44
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because `String` is not a `Copy` "
"type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in the `println!` for  "
"`p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* Adicione um campo `String` ao `struct Ponto`. Ele n√£o ir√° compilar porque `String` n√£o √© um tipo "
"`Copy`.\n"
"* Remova `Copy` do atributo `derive`. O erro do compilador agora est√° no `println!` para `p1`.\n"
"* Mostre que ele funciona se ao inv√©s disso voc√™ clonar `p1`."

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way to generate code in "
"Rust\n"
"at compile time. In this case the default implementations of `Copy` and `Clone` traits are "
"generated."
msgstr ""
"Se os alunos perguntarem sobre `derive`, basta dizer que isto √© uma forma de gerar c√≥digo em Rust\n"
"em tempo de compila√ß√£o. Nesse caso, as implementa√ß√µes padr√£o dos traits `Copy` e `Clone` s√£o "
"geradas."

#: src/ownership/borrowing.md:1
msgid "# Borrowing"
msgstr "# _Borrowing_ (Empr√©stimo)"

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr ""
"Em vez de transferir a ownership ao chamar uma fun√ß√£o, voc√™ pode permitir que uma\n"
"fun√ß√£o _empreste_ o valor:"

#: src/ownership/borrowing.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Ponto(i32, i32);\n"
"\n"
"fn somar(p1: &Ponto, p2: &Ponto) -> Ponto {\n"
"    Ponto(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Ponto(3, 4);\n"
"    let p2 = Ponto(10, 20);\n"
"    let p3 = somar(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"

#: src/ownership/borrowing.md:22
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* A fun√ß√£o `somar` _pega emprestado_ (_borrows_) dois pontos e retorna um novo ponto.\n"
"* O chamador mant√©m a _ownership_ das entradas."

#: src/ownership/borrowing.md:27
msgid "Notes on stack returns:"
msgstr "Notas sobre os retornos da pilha:"

#: src/ownership/borrowing.md:28
msgid ""
"* Demonstrate that the return from `add` is cheap because the compiler can eliminate the copy "
"operation. Change the above code to print stack addresses and run it on the [Playground]. In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay the same when changing "
"to the \"RELEASE\" setting:\n"
"\n"
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);\n"
"\n"
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification because constructors can "
"have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always "
"perform a simple and efficient `memcpy` copy."
msgstr ""
"* Demonstre que o retorno de `somar` √© barato porque o compilador pode eliminar a opera√ß√£o de c√≥pia. "
"Modifique o c√≥digo acima para imprimir endere√ßos da pilha e execute-o no [Playground]. No "
"n√≠vel de otimiza√ß√£o \"DEBUG\", os endere√ßos devem mudar, enquanto eles permanecem os mesmos quando a configura√ß√£o "
"√© alterada para \"RELEASE\":\n"
"\n"
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Ponto(i32, i32);\n"
"\n"
"fn somar(p1: &Ponto, p2: &Ponto) -> Ponto {\n"
"    Ponto(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"  fn main() {\n"
"      let p1 = Ponto(3, 4);\n"
"      let p2 = Ponto(10, 20);\n"
"      let p3 = somar(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* O compilador Rust pode fazer otimiza√ß√£o de valor de retorno (_Return Value Operation_ - RVO).\n"
"* Em C++, a elis√£o (omiss√£o) de c√≥pia deve ser definida na especifica√ß√£o da linguagem porque os construtores "
"podem ter efeitos colaterais. Em Rust, isso n√£o √© um problema. Se o RVO n√£o aconteceu, o Rust "
"sempre executar√° uma c√≥pia `memcpy` simples e eficiente."

#: src/ownership/shared-unique-borrows.md:1
msgid "# Shared and Unique Borrows"
msgstr "# Empr√©stimos (_Borrows_) Compartilhados e Exclusivos"

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "O Rust coloca restri√ß√µes nas formas como voc√™ pode emprestar valores:"

#: src/ownership/shared-unique-borrows.md:5
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* Voc√™ pode ter um ou mais valores `&T` a qualquer momento, _ou_\n"
"* Voc√™ pode ter exatamente um valor `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"\n"
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"\n"
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"* The above code does not compile because `a` is borrowed as mutable (through `c`) and as "
"immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` to make the code "
"compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before the new mutable "
"borrow of `a` through `c`. This is a feature of the borrow checker called \"non-lexical "
"lifetimes\"."
msgstr ""
"* O c√≥digo acima n√£o compila porque `a` √© emprestado como mut√°vel (atrav√©s de `c`) e como imut√°vel "
"(atrav√©s de `b`) ao mesmo tempo.\n"
"* Mova a instru√ß√£o `println!` para `b` antes do escopo que introduz `c` para fazer o c√≥digo "
"compilar.\n"
"* Ap√≥s essa altera√ß√£o, o compilador percebe que `b` s√≥ √© usado antes do novo empr√©stimo mut√°vel de "
"`a` atrav√©s de `c`. Este √© um recurso do verificador de empr√©stimo (_borrow checker_) chamado \"tempos de vida n√£o lexicais\"."

#: src/ownership/lifetimes.md:1
msgid "# Lifetimes"
msgstr "# Tempos de Vida (_Lifetimes_)"

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "Um valor emprestado tem um _tempo de vida_ (_lifetime_):"

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a "
"lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that "
"there is\n"
"    a valid solution.\n"
"* Lifetimes for function arguments and return values must be fully "
"specified,\n"
"  but Rust allows lifetimes to be elided in most cases with [a few simple\n"
"  rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html)."
msgstr ""
"* O tempo de vida pode ser impl√≠cito: `somar(p1: &Ponto, p2: &Ponto) -> Ponto`.\n"
"* Tempos de vida tamb√©m podem ser expl√≠citos: `&'a Ponto`, `&'documento str`.\n"
"* Leia `&'a Ponto` como \"um `Ponto` emprestado que √© v√°lido por pelo menos o\n"
"  tempo de vida `a`\".\n"
"* Tempos de vida s√£o sempre inferidos pelo compilador: voc√™ n√£o pode atribuir um tempo de vida\n"
"  voc√™ mesmo.\n"
"  * Anota√ß√µes de tempo de vida criam restri√ß√µes; o compilador verifica se h√°\n"
"    uma solu√ß√£o v√°lida.\n"
"* Tempos de vida para argumentos de fun√ß√£o e valores de retorno precisam ser completamente especificados,\n"
"  mas o Rust permite que eles sejam omitidos na maioria das vezes com [algumas regras\n"
"  simples](https://doc.rust-lang.org/nomicon/lifetime-elision.html)."

#: src/ownership/lifetimes-function-calls.md:1
msgid "# Lifetimes in Function Calls"
msgstr "# Tempos de Vida (_Lifetimes_) em Chamadas de Fun√ß√£o"

#: src/ownership/lifetimes-function-calls.md:3
msgid "In addition to borrowing its arguments, a function can return a borrowed value:"
msgstr "Al√©m de emprestar seus argumentos, uma fun√ß√£o pode retornar um valor emprestado:"

#: src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Ponto(i32, i32);\n"
"\n"
"fn mais_a_esquerda<'a>(p1: &'a Ponto, p2: &'a Ponto) -> &'a Ponto {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Ponto = Ponto(10, 10);\n"
"    let p2: Ponto = Ponto(20, 20);\n"
"    let p3: &Ponto = mais_a_esquerda(&p1, &p2);\n"
"    println!(\"Ponto mais √† esquerda: {:?}\", p3);\n"
"}\n"
"```"

#: src/ownership/lifetimes-function-calls.md:21
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` √© um par√¢metro gen√©rico, ele √© inferido pelo compilador.\n"
"* Os tempos de vida come√ßam com `'` e `'a` √© um name padr√£o t√≠pico.\n"
"* Leia `&'a Ponto` como \"um `Ponto` emprestado que √© v√°lido por pelo menos o\n"
"  tempo de vida `a`\".\n"
"  * A parte _pelo menos_ √© importante quando os par√¢metros est√£o em escopos diferentes."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), resulting in the following code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);\n"
"\n"
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`.\n"
"\n"
"* Reset the workspace and change the function signature to `fn left_most<'a, 'b>(p1: &'a Point, "
"p2: &'a Point) -> &'b Point`. This will not compile because the relationship between the lifetimes "
"`'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global variable).\n"
"  * Which one is it? The compiler needs to know, so at the call site the returned reference is not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""
"* Mova a declara√ß√£o de `p2` e `p3` para um novo escopo (`{ ... }`), resultando no seguinte c√≥digo:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Ponto(i32, i32);\n"
"\n"
"  fn mais_a_esquerda<'a>(p1: &'a Ponto, p2: &'a Ponto) -> &'a Ponto {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1: Ponto = Ponto(10, 10);\n"
"      let p3: &Ponto;\n"
"      {\n"
"          let p2: Ponto = Ponto(20, 20);\n"
"          p3 = mais_a_esquerda(&p1, &p2);\n"
"      }\n"
"      println!(\"ponto mais √† esquerda: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note como isto n√£o compila uma vez que `p3` vive mais que `p2`.\n"
"\n"
"* Reinicie o espa√ßo de trabalho e altere a assinatura da fun√ß√£o para `fn mais_a_esquerda<'a, "
"  'b>(p1: &'a Ponto, p2: &'a Ponto) -> &'b Ponto`. Isso n√£o ser√° compilado porque a rela√ß√£o entre os "
"  tempos de vida `'a` e `'b` n√£o √© clara.\n"
"* Outra forma de explicar:\n"
"  * Duas refer√™ncias a dois valores s√£o emprestadas por uma fun√ß√£o e a fun√ß√£o retorna\n"
"    outra refer√™ncia.\n"
"  * Ela deve ter vindo de uma dessas duas entradas (ou de uma vari√°vel global).\n"
"  * De qual? O compilador precisa saber, de forma que no local da chamada a refer√™ncia retornada n√£o seja usada\n"
"    por mais tempo do que uma vari√°vel de onde veio a refer√™ncia."

#: src/ownership/lifetimes-data-structures.md:1
msgid "# Lifetimes in Data Structures"
msgstr "# Tempos de Vida (_Lifetimes_) em Estruturas de Dados"

#: src/ownership/lifetimes-data-structures.md:3
msgid "If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr "Se um tipo de dados armazena dados emprestados, ele deve ser anotado com um tempo de vida:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Destaque<'doc>(&'doc str);\n"
"\n"
"fn apagar(texto: String) {\n"
"    println!(\"At√© logo {texto}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let texto = String::from(\"A raposa marrom √°gil pula sobre o cachorro pregui√ßoso.\");\n"
"    let raposa = Destaque(&texto[2..21]);\n"
"    let cachorro = Destaque(&texto[35..53]);\n"
"    // apagar(texto);\n"
"    println!(\"{raposa:?}\");\n"
"    println!(\"{cachorro:?}\");\n"
"}\n"
"```"

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data underlying the "
"contained `&str` lives at least as long as any instance of `Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), the borrow checker "
"throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This can be useful for "
"creating lightweight views, but it generally makes them somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one lifetime annotation. This "
"can be necessary if there is a need to describe lifetime relationships between the references "
"themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases."
msgstr ""
"* No exemplo acima, a anota√ß√£o em `Destaque` imp√µe que os dados subjacentes ao `&str` contido "
"vivam pelo menos tanto quanto qualquer inst√¢ncia de `Destaque` que use esses dados.\n"
"* Se `texto` for consumido antes do final do tempo de vida de `raposa` (ou `cachorro`), o "
"verificador de empr√©stimo lan√ßar√° um erro.\n"
"* Tipos com dados emprestados for√ßam os usu√°rios a manter os dados originais. Isso pode ser √∫til "
"para criar exibi√ß√µes leves, mas geralmente as tornam um pouco mais dif√≠ceis de usar.\n"
"* Quando poss√≠vel, fa√ßa com que as estruturas de dados possuam (_own_) seus dados diretamente.\n"
"* Algumas _structs_ com m√∫ltiplas refer√™ncias internas podem ter mais de uma anota√ß√£o de tempo de vida. Isso "
"pode ser necess√°rio se houver a necessidade de descrever-se relacionamentos de tempo de vida entre as "
"pr√≥prias refer√™ncias, al√©m do tempo de vida da pr√≥pria _struct_. Esses s√£o casos de uso bastante "
"avan√ßados."

#: src/exercises/day-1/afternoon.md:1
msgid "# Day 1: Afternoon Exercises"
msgstr "# Dia 1: Exerc√≠cios da Tarde"

#: src/exercises/day-1/afternoon.md:3
msgid "We will look at two things:"
msgstr "N√≥s iremos ver duas coisas:"

#: src/exercises/day-1/afternoon.md:5
msgid ""
"* A small book library,\n"
"\n"
"* Iterators and ownership (hard)."
msgstr ""
"* Uma pequena biblioteca liter√°ria,\n"
"\n"
"* Iteradores e _ownership_ (dif√≠cil)."

#: src/exercises/day-1/book-library.md:1
msgid "# Storing Books"
msgstr "# Armazenando Livros"

#: src/exercises/day-1/book-library.md:3
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now,\n"
"you just need to know part of its API:"
msgstr ""
"N√≥s iremos aprender muito mais sobre _structs_ e o tipo `Vec<T>` amanh√£. Por hora,\n"
"voc√™ s√≥ precisa conhecer parte de sua API:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"middle value: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut vetor = vec![10, 20];\n"
"    vetor.push(30);\n"
"    let ponto_central = vetor.len() / 2;\n"
"    println!(\"valor do meio: {}\", vetor[ponto_central]);\n"
"    for item in vetor.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:18
msgid ""
"Use this to model a library's book collection. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Use isto para modelar uma cole√ß√£o de livros de uma biblioteca. Copie o c√≥digo abaixo para\n"
"<https://play.rust-lang.org/> e atualize os tipos para compilar:"

#: src/exercises/day-1/book-library.md:21
msgid ""
"```rust,should_panic\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        todo!(\"Initialize and return a `Library` value\")\n"
"    }\n"
"\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"}\n"
"\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"struct Biblioteca {\n"
"    livros: Vec<Livro>,\n"
"}\n"
"\n"
"struct Livro {\n"
"    titulo: String,\n"
"    ano: u16,\n"
"}\n"
"\n"
"impl Livro {\n"
"    // Este √© um construtor, utilizado abaixo.\n"
"    fn new(titulo: &str, ano: u16) -> Livro {\n"
"        Livro {\n"
"            titulo: String::from(titulo),\n"
"            ano,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implemente os m√©todos abaixo. Atualize o par√¢metro `self` para\n"
"// indicar o n√≠vel requerido de ownership sobre o objeto:\n"
"//\n"
"// - `&self` para acesso compartilhado de apenas leitura,\n"
"// - `&mut self` para acesso mut√°vel exclusivo,\n"
"// - `self` para acesso exclusivo por valor.\n"
"impl Biblioteca {\n"
"    fn new() -> Biblioteca {\n"
"        todo!(\"Inicialize e retorne um valor `Biblioteca`\")\n"
"    }\n"
"\n"
"    //fn tamanho(self) -> usize {\n"
"    //    todo!(\"Retorne o tamanho de `self.livros`\")\n"
"    //}\n"
"\n"
"    //fn esta_vazia(self) -> bool {\n"
"    //    todo!(\"Retorne `true` se `self.livros` for vazio\")\n"
"    //}\n"
"\n"
"    //fn adicionar_livro(self, book: Livro) {\n"
"    //    todo!(\"Adicione um novo livro em `self.livros`\")\n"
"    //}\n"
"\n"
"    //fn imprimir_livros(self) {\n"
"    //    todo!(\"Itere sobre `self.livros` e sobre o t√≠tulo e ano de cada livro\")\n"
"    //}\n"
"\n"
"    //fn livro_mais_antigo(self) -> Option<&Livro> {\n"
"    //    todo!(\"Retorne uma refer√™ncia para o livro mais antigo (se houver)\")\n"
"    //}\n"
"}\n"
"\n"
"// Isto demonstra o comportamento esperado. Descomente o c√≥digo abaixo e\n"
"// implemente os m√©todos que faltam. Voc√™ precisar√° atualizar as\n"
"// assinaturas dos m√©todos, incluindo o par√¢metro \"self\"! Voc√™ talvez\n"
"// precise atualizar as atribui√ß√µes de vari√°vel dentro de `main()`.\n"
"fn main() {\n"
"    let biblioteca = Biblioteca::new();\n"
"\n"
"    //println!(\"A biblioteca est√° vazia: biblioteca.esta_vazia() -> {}\", "
"biblioteca.esta_vazia());\n"
"    //\n"
"    //biblioteca.adicionar_livro(Livro::new(\"Lord of the Rings\", 1954));\n"
"    //biblioteca.adicionar_livro(Livro::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The biblioteca n√£o est√° mais vazia: biblioteca.esta_vazia() -> {}\", "
"biblioteca.esta_vazia());\n"
"    //\n"
"    //\n"
"    //biblioteca.imprimir_livros();\n"
"    //\n"
"    //match biblioteca.livro_mais_antigo() {\n"
"    //    Some(livro) => println!(\"O livro mais antigo √© {}\", livro.titulo),\n"
"    //    None => println!(\"A biblioteca est√° vazia!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The biblioteca tem {} livros\", biblioteca.tamanho());\n"
"    //biblioteca.imprimir_livros();\n"
"}\n"
"```"

#: src/exercises/day-1/book-library.md:102
msgid "[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"[Solu√ß√µes](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:1
msgid "# Iterators and Ownership"
msgstr "# Iteradores e _Ownership_ (Posse)"

#: src/exercises/day-1/iterators-and-ownership.md:3
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr ""
"O modelo de _ownership_ do Rust afeta muitas APIs. Um exemplo disso s√£o os _traits_\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) e\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)."

#: src/exercises/day-1/iterators-and-ownership.md:8
msgid "## `Iterator`"
msgstr "## `Iterator` (Iterador)"

#: src/exercises/day-1/iterators-and-ownership.md:10
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` back:"
msgstr ""
"Os _traits_ s√£o como interfaces: eles descrevem o comportamento (m√©todos) para um tipo.\n"
"O _trait_ `Iterator` simplesmente diz que voc√™ pode chamar `next` at√© obter `None` como retorno:"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:20
msgid "You use this trait like this:"
msgstr "Voc√™ usa esse _trait_ da seguinte forma:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"Sem mais itens: {:?}\", iter.next());\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:34
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "Qual √© o tipo retornado pelo iterador? Teste sua resposta aqui:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:46
msgid "Why is this type used?"
msgstr "Por que esse tipo?"

#: src/exercises/day-1/iterators-and-ownership.md:48
msgid "## `IntoIterator`"
msgstr "## `IntoIterator`"

#: src/exercises/day-1/iterators-and-ownership.md:50
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the iterator:"
msgstr ""
"O _trait_ `Iterator` informa como _iterar_ depois de criar um\n"
"iterador. O _trait_ relacionado `IntoIterator` lhe informa como criar o iterador:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"\n"
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"\n"
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:62
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr ""
"A sintaxe aqui significa que toda implementa√ß√£o de `IntoIterator` deve\n"
"declarar dois tipos:"

#: src/exercises/day-1/iterators-and-ownership.md:65
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: o tipo sobre o qual iteramos, como `i8`,\n"
"* `IntoIter`: o tipo `Iterator` retornado pelo m√©todo `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Observe que `IntoIter` e `Item` est√£o vinculados: o iterador deve ter o mesmo\n"
"tipo `Item`, o que significa que ele retorna `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Como antes, qual √© o tipo retornado pelo iterador?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:83
msgid "## `for` Loops"
msgstr "## _Loops_ `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"Agora que conhecemos `Iterator` e `IntoIterator`, podemos construir loops `for`.\n"
"Eles chamam `into_iter()` em uma express√£o e itera sobre o iterador\n"
"resultante:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"\n"
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"\n"
"    for palavra in &v {\n"
"        println!(\"palavra: {palavra}\");\n"
"    }\n"
"\n"
"    for palavra in v {\n"
"        println!(\"palavra: {palavra}\");\n"
"    }\n"
"}\n"
"```"

#: src/exercises/day-1/iterators-and-ownership.md:103
msgid "What is the type of `word` in each loop?"
msgstr "Qual √© o tipo de `palavra` em cada la√ßo?"

#: src/exercises/day-1/iterators-and-ownership.md:105
msgid ""
"Experiment with the code above and then consult the documentation for "
"[`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT,+A%3E)\n"
"to check your answers."
msgstr ""
"Experimente com o c√≥digo acima e depois consulte a documenta√ß√£o para [`impl\n"
"IntoIterator para\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"%26%27a%20Vec%3CT%2C%20A%3E)\n"
"e [`impl IntoIterator para\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"Vec%3CT%2C%20A%3E)\n"
"para verificar suas respostas."

#: src/welcome-day-2.md:1
msgid "# Welcome to Day 2"
msgstr "# Bem-vindos ao Dia 2"

#: src/welcome-day-2.md:3
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Agora que vimos uma boa quantidade de Rust, continuaremos com:"

#: src/welcome-day-2.md:5
msgid ""
"* Structs, enums, methods.\n"
"\n"
"* Pattern matching: destructuring enums, structs, and arrays.\n"
"\n"
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and\n"
"  `continue`.\n"
"\n"
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`\n"
"  and `Arc`.\n"
"\n"
"* Modules: visibility, paths, and filesystem hierarchy."
msgstr ""
"* Estruturas (structs), enumera√ß√µes (enums), m√©todos (methods).\n"
"\n"
"* Correspond√™ncia de padr√µes: desestruturando enums, structs, e arrays.\n"
"\n"
"* Construtos de fluxo de controle: `if`, `if let`, `while`, `while let`, `break`, e\n"
"  `continue`.\n"
"\n"
"* A Biblioteca Padr√£o: `String`, `Option` e `Result`, `Vec`, `HashMap`, `Rc`\n"
"  e `Arc`.\n"
"\n"
"* M√≥dulos: visibilidade, caminhos (paths), e hierarquia do sistema de arquivos."

#: src/structs.md:1
msgid "# Structs"
msgstr "# Estruturas (Structs)"

#: src/structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Como C e C++, Rust tem suporte para `structs` personalizadas:"

#: src/structs.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut pedro = Pessoa {\n"
"        nome: String::from(\"Pedro\"),\n"
"        idade: 27,\n"
"    };\n"
"    println!(\"{} tem {} anos.\", pedro.nome, pedro.idade);\n"
"    \n"
"    pedro.idade= 28;\n"
"    println!(\"{} tem {} anos.\", pedro.nome, pedro.idade);\n"
"    \n"
"    let jackie = Pessoa {\n"
"        nome: String::from(\"Jackie\"),\n"
"        ..pedro\n"
"    };\n"
"    println!(\"{} tem {} anos.\", jackie.nome, jackie.idade);\n"
"}\n"
"```"

#: src/structs.md:31
#: src/enums.md:34
#: src/enums/sizes.md:29
#: src/methods.md:30
#: src/methods/example.md:46
#: src/pattern-matching.md:25
#: src/pattern-matching/match-guards.md:22
#: src/control-flow/blocks.md:43
msgid "Key Points:"
msgstr "Pontos Chave:"

#: src/structs.md:33
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following slides.\n"
"* This may be a good time to let people know there are different types of structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a trait on some type "
"but don‚Äôt have any data that you want to store in the value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the old struct without "
"having to explicitly type it all out. It must always be the last element."
msgstr ""
"* Structs funcionam como em C ou C++.\n"
"  * Como em C++, e ao contr√°rio de C, nenhum _`typedef`_ √© necess√°rio para definir um tipo.\n"
"  * Ao contr√°rio do C++, n√£o h√° heran√ßa entre _structs_.\n"
"* Os m√©todos s√£o definidos em um bloco _`impl`_, que veremos nos pr√≥ximos slides.\n"
"* Este pode ser um bom momento para que as pessoas saibam que existem diferentes tipos de _structs_.\n"
"  * _Structs_ de tamanho zero `por exemplo, struct Foo;` podem ser usadas ao implementar uma caracter√≠stica em algum tipo, mas n√£o possuem nenhum dado que\n"
"voc√™ deseja armazenar nelas.\n"
"  * O pr√≥ximo slide apresentar√° as estruturas tuplas (_Estruturas Tupla_) usadas quando o nome dos campos n√£o s√£o importantes.\n"
"* A sintaxe `..pedro` permite copiar a maioria dos campos de uma _struct_ sem precisar explicitar seus tipos. Sempre deve ser o √∫ltimo elemento."

#: src/structs/tuple-structs.md:1
msgid "# Tuple Structs"
msgstr "# Estruturas Tupla (Tuple Structs)"

#: src/structs/tuple-structs.md:3
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "Se os nomes dos campos n√£o forem importantes, voc√™ pode usar uma estrutura de tupla:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"struct Ponto(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Ponto(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"

#: src/structs/tuple-structs.md:14
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr "Isso √© comumente utilizado para _wrappers_ (inv√≥lucros) com campo √∫nico (chamados _newtypes_):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"struct LibrasDeForca(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn calcular_forca_nas_turbinas() -> LibrasDeForca {\n"
"    todo!(‚ÄúPergunte para um cientista de foguetes da NASA‚Äù)\n"
"}\n"
"\n"
"fn definir_forca_nas_turbinas(force: Newtons) {\n"
"    // ‚Ä¶\n"
"}\n"
"\n"
"fn main() {\n"
"    let forca = calcular_forca_nas_turbinas();\n"
"    definir_forca_nas_turbinas(forca);\n"
"}\n"
"\n"
"```"

#: src/structs/tuple-structs.md:37
msgid ""
"* Newtypes are a great way to encode additional information about the value in a primitive type, "
"for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer have to validate it "
"again at every use: 'PhoneNumber(String)` or `OddNumber(u32)`.\n"
"* Demonstrate how to add a `f64` value to a `Newtons` type by accessing the single field in the "
"newtype.\n"
"  *  Rust generally doesn‚Äôt like inexplicit things, like automatic unwrapping or for instance "
"using booleans as integers.\n"
"  *  Operator overloading is discussed on Day 3 (generics).\n"
"* The example is a subtle reference to the [Mars Climate Orbiter](https://en.wikipedia.org/wiki/"
"Mars_Climate_Orbiter) failure."
msgstr ""
"_Newtypes_ s√£o uma √≥tima maneira de codificar informa√ß√µes adicionais sobre o valor em um tipo primitivo, por exemplo:\n"
"  * O n√∫mero √© medido em alguma unidade: `Newtons` no exemplo acima.\n"
"  * O valor passou por alguma valida√ß√£o quando foi criado, ent√£o n√£o √© preciso valid√°-lo novamente a cada uso: `NumeroTelefone(String)` ou `NumeroImpar(u32)`.\n"
"* Demonstre como somar um valor `f64` em um valor do tipo `Newtons` acessando o campo √∫nico do _newtype_.\n"
"  *  Geralmente, Rust n√£o gosta de coisas impl√≠citas, como _unwrapping_ autom√°tico ou, por exemplo, usar booleanos como inteiros.\n"
"  *  Sobrecarga de operadores √© discutido no Dia 3 (_generics_).\n"
"* O examplo √© uma refer√™ncia sutil a falha do [Orbitador Clim√°tico de Marte](https://pt.wikipedia.org/wiki/Mars_Climate_Orbiter)."

#: src/structs/field-shorthand.md:1
msgid "# Field Shorthand Syntax"
msgstr "# Sintaxe Abreviada de Campo"

#: src/structs/field-shorthand.md:3
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr ""
"Se voc√™ j√° tiver vari√°veis com os nomes corretos, poder√° criar a\n"
"estrutura (_struct_) usando uma abrevia√ß√£o:"

#: src/structs/field-shorthand.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Pessoa {\n"
"    nome: String,\n"
"    idade: u8,\n"
"}\n"
"\n"
"impl Pessoa {\n"
"    fn new(nome: String, idade: u8) -> Pessoa {\n"
"        Pessoa { nome, idade }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pedro = Pessoa::new(String::from(\"Pedro\"), 27);\n"
"    println!(\"{pedro:?}\");\n"
"}\n"
"```"

#: src/structs/field-shorthand.md:27
msgid ""
"*  The `new` function could be written using `Self` as a type, as it is interchangeable with the "
"struct type name\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Person {\n"
"         name: String,\n"
"         age: u8,\n"
"     }\n"
"     impl Person {\n"
"         fn new(name: String, age: u8) -> Self {\n"
"             Self { name, age }\n"
"         }\n"
"     }\n"
"     ```    \n"
"* Implement the `Default` trait for the struct. Define some fields and use the default values for "
"the other fields.\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Person {\n"
"         name: String,\n"
"         age: u8,\n"
"     }\n"
"     impl Default for Person {\n"
"         fn default() -> Person {\n"
"             Person {\n"
"                 name: \"Bot\".to_string(),\n"
"                 age: 0,\n"
"             }\n"
"         }\n"
"     }\n"
"     fn create_default() {\n"
"         let tmp = Person {\n"
"             ..Default::default()\n"
"         };\n"
"         let tmp = Person {\n"
"             name: \"Sam\".to_string(),\n"
"             ..Default::default()\n"
"         };\n"
"     }\n"
"     ```\n"
"\n"
"* Methods are defined in the `impl` block.\n"
"* Use struct update syntax to define a new structure using `peter`. Note that the variable `peter` "
"will no longer be accessible afterwards.\n"
"* Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""
"*  A fun√ß√£o `new` poderia ser escrita utilizando `Self` como tipo, j√° que ele √© intercambi√°vel com o nome da _struct_\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Pessoa {\n"
"         nome: String,\n"
"         idade: u8,\n"
"     }\n"
"     impl Pessoa {\n"
"         fn new(nome: String, idade: u8) -> Self {\n"
"             Self { nome, idade }\n"
"         }\n"
"     }\n"
"     ```    \n"
"* Implemente a _trait_ `Default` (Padr√£o) para a _struct_. Defina alguns campos e utilize valores padr√£o para os demais.\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Pessoa {\n"
"         nome: String,\n"
"         idade: u8,\n"
"     }\n"
"     impl Default for Pessoa {\n"
"         fn default() -> Pessoa {\n"
"             Pessoa {\n"
"                 nome: \"Rob√¥\".to_string(),\n"
"                 idade: 0,\n"
"             }\n"
"         }\n"
"     }\n"
"     fn create_default() {\n"
"         let tmp = Pessoa {\n"
"             ..Default::default()\n"
"         };\n"
"         let tmp = Pessoa {\n"
"             nome: \"Sam\".to_string(),\n"
"             ..Default::default()\n"
"         };\n"
"     }\n"
"     ```\n"
"\n"
"* M√©todos s√£o definidos no bloco `impl`.\n"
"* Use struct update syntax to define a new structure using `peter`. Note that the variable `peter` will no longer be accessible afterwards.\n"
"* Utilize `{:#?}` para imprimir _structs_ para utilizar a representa√ß√£o `Debug` (de Depura√ß√£o)."

#: src/enums.md:1
msgid "# Enums"
msgstr "# Enums"

#: src/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr ""
"A palavra-chave `enum` permite a cria√ß√£o de um tipo que possui algumas\n"
"varia√ß√µes diferentes:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementation based on https://xkcd.com/221/\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn gerar_numero_aleatorio() -> i32 {\n"
"    // Implementa√ß√£o baseada em https://xkcd.com/221/\n"
"    4  // Escolhido por uma rolagem de dados justa. Garantido ser aleat√≥rio.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum MoedaJogada {\n"
"    Cara,\n"
"    Coroa,\n"
"}\n"
"\n"
"fn jogar_moeda() -> MoedaJogada {\n"
"    let numero_aleatorio = gerar_numero_aleatorio();\n"
"    if numero_aleatorio % 2 == 0 {\n"
"        return MoedaJogada::Cara;\n"
"    } else {\n"
"        return MoedaJogada::Coroa;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"Voc√™ tirou: {:?}\", jogar_moeda());\n"
"}\n"
"```"

#: src/enums.md:36
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and `Tail`. You might note "
"the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or one with different "
"types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate structs but then they "
"wouldn‚Äôt be the same type as they would if they were all defined in an enum. "
msgstr ""
"* Enumera√ß√µes permitem coletar um conjunto de valores em um tipo\n"
"* Esta p√°gina oferece um tipo de _enum_ `MoedaJogada` com duas variantes `Cara` e `Coroa`. Voc√™ pode observar o _namespace_ ao usar variantes.\n"
"* Este pode ser um bom momento para comparar _Structs_ e _Enums_:\n"
"  * Em ambos, voc√™ pode ter uma vers√£o simples sem campos (_unit struct_, ou estrutura unit√°ria) ou uma com diferentes tipos de campo.\n"
"  * Em ambos, as fun√ß√µes associadas s√£o definidas dentro de um bloco `impl`.\n"
"  * Voc√™ pode at√© mesmo implementar as diferentes variantes de uma _Enum_ com _Structs_ separadas, mas elas n√£o seriam do mesmo tipo, como seriam se todas "
"fossem definidas em uma _Enum_. "

#: src/enums/variant-payloads.md:1
msgid "# Variant Payloads"
msgstr "# Conte√∫dos Variantes"

#: src/enums/variant-payloads.md:3
msgid ""
"You can define richer enums where the variants carry data. You can then use the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"Voc√™ pode definir enums mais ricos onde as variantes carregam dados. Voc√™ pode ent√£o usar a\n"
"instru√ß√£o `match` (corresponder) para extrair os dados de cada variante:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"enum EventoWeb {\n"
"    CarregarPagina,               // Variante sem conte√∫do\n"
"    TeclaPressionada(char), // Variante tupla\n"
"    Clique { x: i64, y: i64 },   // Variante completa\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspecionar(evento: EventoWeb) {\n"
"    match evento {\n"
"        EventoWeb::CarregarPagina       => println!(\"p√°gina carregada\"),\n"
"        EventoWeb::TeclaPressionada(c)    => println!(\"pressionou '{c}'\"),\n"
"        EventoWeb::Clique { x, y } => println!(\"clicou em x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let carregar = EventoWeb::CarregarPagina;\n"
"    let pressionar = EventoWeb::TeclaPressionada('x');\n"
"    let clicar = EventoWeb::Clique { x: 20, y: 80 };\n"
"\n"
"    inspecionar(carregar);\n"
"    inspecionar(pressionar);\n"
"    inspecionar(clicar);\n"
"}\n"
"```"

#: src/enums/variant-payloads.md:35
msgid ""
"* The values in the enum variants can only be accessed after being pattern matched. The pattern "
"binds references to the fields in the \"match arm\" after the `=>`.\n"
"  * The expression is matched against the patterns from top to bottom. There is no fall-through "
"like in C or C++.\n"
"  * The match expression has a value. The value is the last expression in the match arm which was "
"executed.\n"
"  * Starting from the top we look for what pattern matches the value then run the code following "
"the arrow. Once we find a match, we stop. \n"
"* Demonstrate what happens when the search is inexhaustive. Note the advantage the Rust compiler "
"provides by confirming when all cases are handled. \n"
"* `match` inspects a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling `std::mem::discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs where comparing field "
"values doesn't affect equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level "
"`struct Click { ... }`. The inlined version cannot implement traits, for example.  \n"
"  "
msgstr ""
"* Os valores nas variantes de uma _enum_ s√≥ podem ser acessados ap√≥s uma correspond√™ncia de padr√£o. O padr√£o vincula refer√™ncias aos campos no \"bra√ßo\" do "
"_match_ ap√≥s `=>`.\n"
"  * A express√£o √© comparada com os padr√µes de cima a baixo. N√£o existe _fall-through_ como em C ou C++.\n"
"  * A express√£o _match_ possui um valor. O valor √© o da √∫ltima express√£o executada em um \"bra√ßo\" do _match_.\n"
"  * Come√ßando do topo, n√≥s procuramos qual padr√£o corresponde ao valor, e ent√£o executamos o c√≥digo ap√≥s a flecha. Quando uma correspond√™ncia √© encontrada, n√≥s "
"paramos. \n"
"* Demonstre o que acontece quando a busca n√£o abrange todas as possibilidades. Mencione a vantagem que o compilador do Rust oferece confirmando quando todos os "
"casos foram tratados. \n"
"* `match` inspeciona um campo discriminant escondido na `enum`.\n"
"* √â poss√≠vel recuperar o discriminante chamando `std::mem::discriminant()`\n"
"  * Isso √© √∫til, por exemplo, ao implementar `PartialEq` para _structs_ nas quais comparar valores de campos n√£o afeta a igualdade.\n"
"* `EventoWeb::Clique { ... }` n√£o √© exatamente o mesmo que `EventoWeb::Clique(Clique)` com uma `struct Clique { ... }` _top-level_. A vers√£o no pr√≥prio local "
"(_inline_) n√£o permite implementar _traits_, por exemplo.  \n"
"  "

#: src/enums/sizes.md:1
msgid "# Enum Sizes"
msgstr "# Tamanhos de Enum"

#: src/enums/sizes.md:3
msgid "Rust enums are packed tightly, taking constraints due to alignment into account:"
msgstr "Enums, em Rust, s√£o empacotados firmemente, levando em considera√ß√£o as restri√ß√µes devido ao alinhamento:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size!(Foo);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: tamanho {} bytes, alinhamento: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size!(Foo);\n"
"}\n"
"```"

#: src/enums/sizes.md:25
msgid "* See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr "* Consulte a [Refer√™ncia do Rust](https://doc.rust-lang.org/reference/type-layout.html)."

#: src/enums/sizes.md:31
msgid ""
" * Internally Rust is using a field (discriminant) to keep track of the enum variant.\n"
"\n"
" * You can control the discriminant if needed (e.g., for compatibility with C):\n"
" \n"
"     ```rust,editable\n"
"     #[repr(u32)]\n"
"     enum Bar {\n"
"         A,  // 0\n"
"         B = 10000,\n"
"         C,  // 10001\n"
"     }\n"
"     \n"
"     fn main() {\n"
"         println!(\"A: {}\", Bar::A as u32);\n"
"         println!(\"B: {}\", Bar::B as u32);\n"
"         println!(\"C: {}\", Bar::C as u32);\n"
"     }\n"
"     ```\n"
"\n"
"    Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2\n"
"    bytes.\n"
"\n"
"\n"
" * Try out other types such as\n"
" \n"
"     * `dbg_size!(bool)`: size 1 bytes, align: 1 bytes,\n"
"     * `dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche optimization, see below),\n"
"     * `dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),\n"
"     * `dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer optimization, see "
"below).\n"
"\n"
" * Niche optimization: Rust will merge unused bit patterns for the enum\n"
"   discriminant.\n"
"\n"
" * Null pointer optimization: For [some\n"
"   types](https://doc.rust-lang.org/std/option/#representation), Rust guarantees\n"
"   that `size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
"\n"
"     Example code if you want to show how the bitwise representation *may* look like in practice.\n"
"     It's important to note that the compiler provides no guarantees regarding this "
"representation, therefore this is totally unsafe.\n"
"\n"
"     ```rust,editable\n"
"     use std::mem::transmute;\n"
"\n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"         // representation of types.\n"
"         unsafe {\n"
"             println!(\"Bitwise representation of bool\");\n"
"             dbg_bits!(false, u8);\n"
"             dbg_bits!(true, u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<bool>\");\n"
"             dbg_bits!(None::<bool>, u8);\n"
"             dbg_bits!(Some(false), u8);\n"
"             dbg_bits!(Some(true), u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"             dbg_bits!(Some(Some(false)), u8);\n"
"             dbg_bits!(Some(Some(true)), u8);\n"
"             dbg_bits!(Some(None::<bool>), u8);\n"
"             dbg_bits!(None::<Option<bool>>, u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<&i32>\");\n"
"             dbg_bits!(None::<&i32>, usize);\n"
"             dbg_bits!(Some(&0i32), usize);\n"
"         }\n"
"     }\n"
"     ```\n"
"\n"
"     More complex example if you want to discuss what happens when we chain more than 256 "
"`Option`s together.\n"
"\n"
"     ```rust,editable\n"
"     #![recursion_limit = \"1000\"]\n"
"\n"
"     use std::mem::transmute;\n"
"     \n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     // Macro to wrap a value in 2^n Some() where n is the number of \"@\" signs.\n"
"     // Increasing the recursion limit is required to evaluate this macro.\n"
"     macro_rules! many_options {\n"
"         ($value:expr) => { Some($value) };\n"
"         ($value:expr, @) => {\n"
"             Some(Some($value))\n"
"         };\n"
"         ($value:expr, @ $($more:tt)+) => {\n"
"             many_options!(many_options!($value, $($more)+), $($more)+)\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"         // representation of types.\n"
"         unsafe {\n"
"             assert_eq!(many_options!(false), Some(false));\n"
"             assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"             assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));\n"
"\n"
"             println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"             dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"             dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"\n"
"             println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"             dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"\n"
"             println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"             dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"         }\n"
"     }\n"
"     ```"
msgstr ""
" * Internamente Rust utiliza um campo (discriminante) para saber qual a variante da _enum_.\n"
"\n"
" * √â poss√≠vel controlar a discriminante se necess√°rio (e.g., para compatibilidade com C):\n"
" \n"
"     ```rust,editable\n"
"     #[repr(u32)]\n"
"     enum Bar {\n"
"         A,  // 0\n"
"         B = 10000,\n"
"         C,  // 10001\n"
"     }\n"
"     \n"
"     fn main() {\n"
"         println!(\"A: {}\", Bar::A as u32);\n"
"         println!(\"B: {}\", Bar::B as u32);\n"
"         println!(\"C: {}\", Bar::C as u32);\n"
"     }\n"
"     ```\n"
"\n"
"    Sem `repr`, o tipo da discriminante usa 2 bytes, porque 10001 cabe em 2\n"
"    bytes.\n"
"\n"
"\n"
" * Tente outros tipos como\n"
" \n"
"     * `dbg_size!(bool)`: tamanho 1 bytes, alinhamento: 1 bytes,\n"
"     * `dbg_size!(Option<bool>)`: tamanho 1 bytes, alinhamento: 1 bytes (otimiza√ß√£o de nicho, seja abaixo),\n"
"     * `dbg_size!(&i32)`: tamanho 8 bytes, alinhamento: 8 bytes (em uma m√°quina de 64-bits),\n"
"     * `dbg_size!(Option<&i32>)`: tamanho 8 bytes, alinhamento: 8 bytes (otimiza√ß√£o de ponteiro nulo, veja abaixo).\n"
"\n"
" * Otimiza√ß√£o de nicho: Rust vai mesclar padr√µes de bits n√£o utilizados na discriminante\n"
"   da _enum_.\n"
"\n"
" * Otimiza√ß√£o de ponteiro nulo: para [alguns\n"
"   tipos](https://doc.rust-lang.org/std/option/#representation), o Rust garante\n"
"   que `size_of::<T>()` se iguala `size_of::<Option<T>>()`.\n"
"\n"
"     C√≥digo de exemplo caso queira mostrar como a representa√ß√£o em bits *pode* ser na pr√°tica.\n"
"     √â importante apontar que o compilador n√£o oferece nenhuma garantia a respeito dessa representa√ß√£o, portanto isso √© completamente inseguro.\n"
"\n"
"     ```rust,editable\n"
"     use std::mem::transmute;\n"
"\n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALMENTE INSEGURO. Rust n√£o oferece nenhuma garantia sobre a\n"
"         // representa√ß√£o dos tipos em bits.\n"
"         unsafe {\n"
"             println!(\"Representa√ß√£o em bits de booleano\");\n"
"             dbg_bits!(false, u8);\n"
"             dbg_bits!(true, u8);\n"
"\n"
"             println!(\"Representa√ß√£o em bits de Option<bool>\");\n"
"             dbg_bits!(None::<bool>, u8);\n"
"             dbg_bits!(Some(false), u8);\n"
"             dbg_bits!(Some(true), u8);\n"
"\n"
"             println!(\"Representa√ß√£o em bits de Option<Option<bool>>\");\n"
"             dbg_bits!(Some(Some(false)), u8);\n"
"             dbg_bits!(Some(Some(true)), u8);\n"
"             dbg_bits!(Some(None::<bool>), u8);\n"
"             dbg_bits!(None::<Option<bool>>, u8);\n"
"\n"
"             println!(\"Representa√ß√£o em bits de Option<&i32>\");\n"
"             dbg_bits!(None::<&i32>, usize);\n"
"             dbg_bits!(Some(&0i32), usize);\n"
"         }\n"
"     }\n"
"     ```\n"
"\n"
"     Exemplo mais complexo caso queira demonstrar o que acontece ao encadear mais de 256 `Option`s de uma vez.\n"
"\n"
"     ```rust,editable\n"
"     #![recursion_limit = \"1000\"]\n"
"\n"
"     use std::mem::transmute;\n"
"     \n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     // Macro que envolve um valor em 2^n Some() no qual n √© o n√∫mero de \"@\".\n"
"     // √â preciso aumentar o limite de recurs√£o para aplicar essa macro.\n"
"     macro_rules! muitos_options {\n"
"         ($value:expr) => { Some($value) };\n"
"         ($value:expr, @) => {\n"
"             Some(Some($value))\n"
"         };\n"
"         ($value:expr, @ $($more:tt)+) => {\n"
"             muitos_options!(muitos_options!($value, $($more)+), $($more)+)\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALMENTE INSEGURO. Rust n√£o oferece nenhuma garantia sobre a\n"
"         // representa√ß√£o dos tipos em bits.\n"
"         unsafe {\n"
"             assert_eq!(muitos_options!(false), Some(false));\n"
"             assert_eq!(muitos_options!(false, @), Some(Some(false)));\n"
"             assert_eq!(muitos_options!(false, @@), Some(Some(Some(Some(false)))));\n"
"\n"
"             println!(\"Representa√ß√£o em bits de uma sequ√™ncia de 128 Option's.\");\n"
"             dbg_bits!(muitos_options!(false, @@@@@@@), u8);\n"
"             dbg_bits!(muitos_options!(true, @@@@@@@), u8);\n"
"\n"
"             println!(\"Representa√ß√£o em bits de uma sequ√™ncia de 256 Option's.\");\n"
"             dbg_bits!(muitos_options!(false, @@@@@@@@), u16);\n"
"             dbg_bits!(muitos_options!(true, @@@@@@@@), u16);\n"
"\n"
"             println!(\"Representa√ß√£o em bits de uma sequ√™ncia de 257 Option's.\");\n"
"             dbg_bits!(muitos_options!(Some(false), @@@@@@@@), u16);\n"
"             dbg_bits!(muitos_options!(Some(true), @@@@@@@@), u16);\n"
"             dbg_bits!(muitos_options!(None::<bool>, @@@@@@@@), u16);\n"
"         }\n"
"     }\n"
"     ```"

#: src/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with an\n"
"`impl` block:"
msgstr ""
"Rust permite que voc√™ associe fun√ß√µes aos seus novos tipos. Voc√™ faz isso com um\n"
"bloco `impl`:"

#: src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Pessoa {\n"
"    nome: String,\n"
"    idade: u8,\n"
"}\n"
"\n"
"impl Pessoa {\n"
"    fn dizer_ola(&self) {\n"
"        println!(\"Ol√°, meu nome √© {}\", self.nome);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pedro = Pessoa {\n"
"        nome: String::from(\"Pedro\"),\n"
"        idade: 27,\n"
"    };\n"
"    pedro.dizer_ola();\n"
"}\n"
"```"

#: src/methods.md:31
msgid ""
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), the first parameter "
"represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method receiver syntax and to help "
"keep them more organized. By using methods we can keep all the implementation code in one "
"predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name "
"could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in and can be used "
"elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used to refer to individual "
"fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from `self` by modifying the "
"code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   "
msgstr ""
"* Pode ser √∫til introduzir m√©todos comparando-os com fun√ß√µes.\n"
"  * M√©todos s√£o chamados em uma inst√¢ncia de um tipo (como _struct_ ou _enum_), o primeiro par√¢metro representa a inst√¢ncia como `self`.\n"
"  * Os desenvolvedores podem optar por usar m√©todos para aproveitar a sintaxe do receptor do m√©todo e ajudar a mant√™-los mais organizados. Usando m√©todos, "
"podemos manter todo o c√≥digo de implementa√ß√£o em um local previs√≠vel.\n"
"* Destaque o uso da palavra-chave `self`, um receptor de m√©todo.\n"
"  * Mostre que √© um termo abreviado para `self:&Self` e talvez mostre como o nome da struct tamb√©m poderia ser usado.\n"
"  * Explique que `Self` √© um apelido de tipo para o tipo em que o bloco `impl` est√° e pode ser usado em qualquer outro lugar no bloco.\n"
"  * Observe como `self` √© usado como outras _Structs_ e a nota√ß√£o de ponto pode ser usada para se referir a campos individuais.\n"
"  * Este pode ser um bom momento para demonstrar como `&self` difere de `self` modificando o c√≥digo e tentando executar `dizer_ola` duas vezes.\n"
"* Descreveremos a distin√ß√£o entre os receptores de m√©todo a seguir.\n"
"   "

#: src/methods/receiver.md:1
msgid "# Method Receiver"
msgstr "# Receptores de m√©todos"

#: src/methods/receiver.md:3
msgid ""
"The `&self` above indicates that the method borrows the object immutably. There\n"
"are other possible receivers for a method:"
msgstr ""
"O `&self` acima indica que o m√©todo toma emprestado o objeto imutavelmente. Existem\n"
"outros receptores poss√≠veis para um m√©todo:"

#: src/methods/receiver.md:6
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. The\n"
"  method becomes the owner of the object. The object will be dropped (deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted. Complete ownership does not automatically mean mutability.\n"
"* `mut self`: same as above, but the method can mutate the object. \n"
"* No receiver: this becomes a static method on the struct. Typically used to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: pega emprestado o objeto do chamador como uma refer√™ncia compartilhada\n"
" e imut√°vel. O objeto pode ser usado novamente depois.\n"
"* `&mut self`: pega emprestado o objeto do chamador como uma refer√™ncia √∫nica\n"
" e mut√°vel. O objeto pode ser usado novamente depois.\n"
"* `self`: toma posse do objeto e o move do chamador.\n"
"  O m√©todo se torna o propriet√°rio do objeto. O objeto ser√° descartado (desalocado)\n"
"  quando o m√©todo retorna, a menos que sua _ownership_ (posse) seja explicitamente\n"
"  transmitida. Posse completa n√£o significa automaticamente mutabilidade.\n"
"* `mut self`: o mesmo que acima, mas enquanto o m√©todo possui o objeto, ele pode\n"
"  alter√°-lo tamb√©m.\n"
"* Sem receptor: isso se torna um m√©todo est√°tico (_static_) na estrutura. Normalmente usado para\n"
"  criar construtores que, por conven√ß√£o, s√£o chamados `new`."

#: src/methods/receiver.md:18
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"Al√©m das variantes de `self`, tamb√©m existem\n"
"[tipos especiais de _wrapper_](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"que podem ser tipos de receptores, como `Box<Self>`."

#: src/methods/receiver.md:24
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". These constraints always "
"come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It isn't possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) method on it."
msgstr ""
"Considere enfatizar \"compartilhado e imut√°vel\" e \"√∫nico e mut√°vel\". Essas restri√ß√µes sempre v√™m\n"
"juntos no Rust devido √†s regras do _Borrow Checker_ (verificador de empr√©stimo), e `self` n√£o √© uma exce√ß√£o. N√£o ser√° poss√≠vel\n"
"referenciar uma _struct_ de v√°rios locais e chamar um m√©todo mut√°vel (`&mut self`) nela."

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "# Example"
msgstr "# Exemplo"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access to self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Corrida {\n"
"    nome: String,\n"
"    voltas: Vec<i32>,\n"
"}\n"
"\n"
"impl Corrida {\n"
"    fn new(nome: &str) -> Corrida {  // Sem receptor, m√©todo est√°tico\n"
"        Corrida { nome: String::from(nome), voltas: Vec::new() }\n"
"    }\n"
"\n"
"    fn adicionar_volta(&mut self, volta: i32) {  // Empr√©stimo √∫nico com acesso de leitura e escrita em self\n"
"        self.voltas.push(volta);\n"
"    }\n"
"\n"
"    fn imprimir_voltas(&self) {  // Empr√©stimo compartilhado com acesso apenas de leitura em self\n"
"        println!(\"Registrou {} voltas para {}:\", self.voltas.len(), self.nome);\n"
"        for (idx, volta) in self.voltas.iter().enumerate() {\n"
"            println!(\"Volta {idx}: {volta} seg\");\n"
"        }\n"
"    }\n"
"\n"
"    fn encerrar(self) {  // Propriedade exclusiva de self\n"
"        let total = self.voltas.iter().sum::<i32>();\n"
"        println!(\"Corrida {} foi encerrada, tempo de voltas total: {}\", self.nome, total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut corrida = Corrida::new(\"Monaco Grand Prix\");\n"
"    corrida.adicionar_volta(70);\n"
"    corrida.adicionar_volta(68);\n"
"    corrida.imprimir_voltas();\n"
"    corrida.adicionar_volta(71);\n"
"    corrida.imprimir_voltas();\n"
"    corrida.encerrar();\n"
"    // corrida.adicionar_volta(42);\n"
"}\n"
"```"

#: src/methods/example.md:47
msgid ""
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the variable values and if/how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` twice.\n"
"* Note that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing "
"and dereferencing when calling methods. Rust automatically adds in the `&`, `*`, `muts` so that that object matches the method signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated over. We describe vectors in more detail in the afternoon. "
msgstr ""
"* Todos os quatro m√©todos aqui usam um receptor de m√©todo diferente.\n"
"  * Voc√™ pode apontar como isso muda o que a fun√ß√£o pode fazer com os valores das vari√°veis e se/como ela pode ser usada novamente na `main`.\n"
"  * Voc√™ pode mostrar o erro que aparece ao tentar chamar `encerrar` duas vezes.\n"
"* Observe que, embora os receptores do m√©todo sejam diferentes, as fun√ß√µes n√£o est√°ticas s√£o chamadas da mesma maneira no corpo principal. Rust permite "
"referenciar e desreferenciar automaticamente ao chamar m√©todos. Rust adiciona automaticamente `&`, `*`, `muts` para que esse objeto corresponda √† assinatura do "
"m√©todo.\n"
"* Voc√™ pode apontar que `imprimir_voltas` est√° usando um vetor e iterando sobre ele. Descreveremos os vetores com mais detalhes √† tarde. "

#: src/pattern-matching.md:1
msgid "# Pattern Matching"
msgstr "# Correspond√™ncia de padr√µes"

#: src/pattern-matching.md:3
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"A palavra-chave `match` permite que voc√™ corresponda um valor a um ou mais _padr√µes_ (_patterns_). As\n"
"compara√ß√µes s√£o feitas de cima para baixo e a primeira correspond√™ncia encontrada √© selecionada."

#: src/pattern-matching.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "Os padr√µes podem ser valores simples, similarmente a `switch` em C e C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let entrada = 'x';\n"
"\n"
"    match entrada {\n"
"        'q'                   => println!(\"Encerrando\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Movendo por ai\"),\n"
"        '0'..='9'             => println!(\"Entrada de n√∫mero\"),\n"
"        _                     => println!(\"Alguma outra coisa\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching.md:21
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "O padr√£o `_` √© um padr√£o curinga que corresponde a qualquer valor."

#: src/pattern-matching.md:26
msgid ""
"* You might point out how some specific characters are being used when in a pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.\n"
"   "
msgstr ""
"* Voc√™ pode apontar como alguns caracteres espec√≠ficos podem ser usados em um padr√£o\n"
"  * `|` como um `ou`\n"
"  * `..` pode expandir o quanto for necess√°rio\n"
"  * `1..=5` representa um intervalo inclusivo\n"
"  * `_` √© um curinga\n"
"* Pode ser √∫til mostrar como funciona a vincula√ß√£o, por exemplo, substituindo um caractere curinga por uma vari√°vel ou removendo as aspas ao redor de `q`.\n"
"* Voc√™ pode demonstrar correspond√™ncia em uma refer√™ncia.\n"
"* Este pode ser um bom momento para trazer √† tona o conceito de padr√µes irrefut√°veis, j√° que o termo pode aparecer em mensagens de erro.\n"
"   "

#: src/pattern-matching/destructuring-enums.md:1
msgid "# Destructuring Enums"
msgstr "# Desestruturando Enums"

#: src/pattern-matching/destructuring-enums.md:3
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is how\n"
"you inspect the structure of your types. Let us start with a simple `enum` type:"
msgstr ""
"Os padr√µes tamb√©m podem ser usados para vincular vari√°veis a partes de seus valores. √â assim\n"
"que voc√™ inspeciona a estrutura de seus tipos. Vamos come√ßar com um tipo `enum` simples:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"enum Resultado {\n"
"    Ok(i32),\n"
"    Erro(String),\n"
"}\n"
"\n"
"fn divide_em_dois(n: i32) -> Resultado {\n"
"    if n % 2 == 0 {\n"
"        Resultado::Ok(n / 2)\n"
"    } else {\n"
"        Resultado::Erro(format!(\"n√£o √© poss√≠vel dividir {n} em duas partes iguais\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_em_dois(n) {\n"
"        Resultado::Ok(metade) => println!(\"{n} divido em dois √© {metade}\"),\n"
"        Resultado::Erro(msg) => println!(\"desculpe, aconteceu um erro: {msg}\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-enums.md:29
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second arm,\n"
"`msg` is bound to the error message."
msgstr ""
"Aqui usamos a verifica√ß√£o de correspond√™ncia para _desestruturar_ o valor contido em `Result`. Na primeira\n"
"verifica√ß√£o de correspond√™ncia, `metade` est√° vinculado ao valor dentro da variante `Ok`. Na segunda,\n"
"`msg` est√° vinculado √† mensagem de erro."

#: src/pattern-matching/destructuring-enums.md:36
msgid ""
"* The `if`/`else` expression is returning an enum that is later unpacked with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"* A express√£o `if`/`else` est√° retornando um `enum` que √© posteriormente descompactado com um `match`.\n"
"* Voc√™ pode tentar adicionar uma terceira variante √† defini√ß√£o de Enum e exibir os erros ao executar o c√≥digo. Aponte os lugares onde seu c√≥digo agora √© \"n√£o "
"exaustivo\" e como o compilador tenta lhe dar dicas."

#: src/pattern-matching/destructuring-structs.md:1
msgid "# Destructuring Structs"
msgstr "# Desestruturando Structs"

#: src/pattern-matching/destructuring-structs.md:3
msgid "You can also destructure `structs`:"
msgstr "Voc√™ tamb√©m pode desestruturar `structs`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, outros campos foram ignorados\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-structs.md:23
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"* The distinction between a capture and a constant expression can be hard to\n"
"  spot. Try changing the `2` in the second arm to a variable, and see that it subtly\n"
"  doesn't work. Change it to a `const` and see it working again."
msgstr ""
"* Modifique os valores em `foo` para corresponder com os outros padr√µes.\n"
"* Adicione um novo campo a `Foo` e fa√ßa mudan√ßas nos padr√µes conforme necess√°rio.\n"
"* A diferen√ßa entre uma captura (_capture_) e uma express√£o constante pode ser dif√≠cil de\n"
"  perceber. Tente modificar o `2` no segundo bra√ßo para uma vari√°vel, e veja que, de forma s√∫til,\n"
"  n√£o funciona. Mude para `const` e veja funcionando novamente."

#: src/pattern-matching/destructuring-arrays.md:1
msgid "# Destructuring Arrays"
msgstr "# Desestruturando Vetores"

#: src/pattern-matching/destructuring-arrays.md:3
msgid "You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "Voc√™ pode desestruturar vetores, tuplas e _slices_ combinando seus elementos:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triplo = [0, -2, 3];\n"
"    println!(\"Fale-me sobre {triplo:?}\");\n"
"    match triplo {\n"
"        [0, y, z] => println!(\"Primeiro √© 0, y = {y} e z = {z}\"),\n"
"        [1, ..] => println!(\"Primeiro √© 1 e o resto foi ignorado\"),\n"
"        _ => println!(\"Todos os elementos foram ignorados\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-arrays.md:21
msgid ""
"* Destructuring of slices of unknown length also works with patterns of fixed length.\n"
"\n"
"\n"
"     ```rust,editable\n"
"     fn main() {\n"
"         inspect(&[0, -2, 3]);\n"
"         inspect(&[0, -2, 3, 4]);\n"
"     }\n"
"\n"
"     #[rustfmt::skip]\n"
"     fn inspect(slice: &[i32]) {\n"
"         println!(\"Tell me about {slice:?}\");\n"
"         match slice {\n"
"             &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"             &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"             _          => println!(\"All elements were ignored\"),\n"
"         }\n"
"     }\n"
"     ```\n"
"  \n"
"* Create a new pattern using `_` to represent an element. \n"
"* Add more values to the array.\n"
"* Point out that how `..` will expand to account for different number of elements.\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""
"* Desestruturar _slices_ de tamanho desconhecido √© poss√≠vel utilizando padr√µes de tamanho fixo.\n"
"\n"
"\n"
"     ```rust,editable\n"
"     fn main() {\n"
"         inspecionar(&[0, -2, 3]);\n"
"         inspecionar(&[0, -2, 3, 4]);\n"
"     }\n"
"\n"
"     #[rustfmt::skip]\n"
"     fn inspecionar(slice: &[i32]) {\n"
"         println!(\"Fale-me sobre {slice:?}\");\n"
"         match slice {\n"
"             &[0, y, z] => println!(\"Primeiro √© 0, y = {y}, and z = {z}\"),\n"
"             &[1, ..]   => println!(\"Primeiro √© 1 e o resto foi ignorado\"),\n"
"             _          => println!(\"Todos os elementos foram ignorados\"),\n"
"         }\n"
"     }\n"
"     ```\n"
"  \n"
"* Crie um novo padr√£o usando `_` para representar um elemento. \n"
"* Adicione mais valores ao vetor.\n"
"* Aponte que `..` vai expandir para levar em conta um n√∫mero diferente de elementos.\n"
"* Mostre correspond√™ncia com a cauda usando os padr√µes `[.., b]` and `[a@..,b]`"

#: src/pattern-matching/match-guards.md:1
msgid "# Match Guards"
msgstr "# Guardas de Correspond√™ncia (Match Guards)"

#: src/pattern-matching/match-guards.md:3
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"Ao verificar uma correspond√™ncia, voc√™ pode adicionar uma guarda (_guard_) para um padr√£o. √â uma express√£o Booleana\n"
"arbitr√°ria que ser√° executada se o padr√£o corresponder:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let par = (2, -2);\n"
"    println!(\"Fale-me sobre {par:?}\");\n"
"    match par {\n"
"        (x, y) if x == y => println!(\"Estes s√£o g√™meos\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"O primeiro √© √≠mpar\"),\n"
"        _ => println!(\"Sem correla√ß√£o...\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/match-guards.md:23
msgid ""
"* Match guards as a separate syntax feature are important and necessary when we wish to concisely "
"express more complex ideas than patterns alone would allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. An `if` expression "
"inside of the branch block (after `=>`) happens after the match arm is selected. Failing the `if` "
"condition inside of that block won't result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a pattern with an `|`."
msgstr ""
"* Guardas de correspond√™ncia, como um recurso de sintaxe separado, s√£o importantes e necess√°rias quando se quer expressar ideias mais complexas do que somente o "
"padr√£o permitiria.\n"
"* Eles n√£o s√£o iguais √† express√£o `if` separada dentro do bloco de correspond√™ncia. Uma express√£o `if` dentro do bloco de ramifica√ß√£o (depois de `=>`) acontece "
"depois que a correspond√™ncia √© selecionada. A falha na condi√ß√£o `if` dentro desse bloco n√£o resultar√° em outras verifica√ß√µes de correspond√™ncia da express√£o "
"`match` original serem consideradas.\n"
"* Voc√™ pode usar as vari√°veis definidas no padr√£o em sua express√£o `if`.\n"
"* A condi√ß√£o definida na guarda se aplica a todas as express√µes em um padr√£o com um `|`."

#: src/exercises/day-2/morning.md:1
msgid "# Day 2: Morning Exercises"
msgstr "# Dia 2: Exerc√≠cios Matinais"

#: src/exercises/day-2/morning.md:3
msgid "We will look at implementing methods in two contexts:"
msgstr "Veremos a implementa√ß√£o de m√©todos em dois contextos:"

#: src/exercises/day-2/morning.md:5
msgid ""
"* Simple struct which tracks health statistics.\n"
"\n"
"* Multiple structs and enums for a drawing library."
msgstr ""
"* Uma _struct_ simples que guarda estat√≠sticas de sa√∫de.\n"
"\n"
"* V√°rias _structs_ e _enums_ para uma biblioteca de desenho."

#: src/exercises/day-2/health-statistics.md:1
msgid "# Health Statistics"
msgstr "# Estat√≠sticas de sa√∫de"

#: src/exercises/day-2/health-statistics.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, you\n"
"need to keep track of users' health statistics."
msgstr ""
"Voc√™ est√° trabalhando na implementa√ß√£o de um sistema de monitoramento de sa√∫de. Como parte disso, voc√™\n"
"precisa acompanhar as estat√≠sticas de sa√∫de dos usu√°rios."

#: src/exercises/day-2/health-statistics.md:6
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a `User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"Voc√™ come√ßar√° com algumas fun√ß√µes fragmentadas em um bloco `impl` e tamb√©m com a defini√ß√£o da estrutura `Usuario`.\n"
"Seu objetivo √© implementar os m√©todos esbo√ßados para a `struct` `Usuario`\n"
"definidos no bloco `impl`."

#: src/exercises/day-2/health-statistics.md:10
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"methods:"
msgstr ""
"Copie o c√≥digo abaixo em <https://play.rust-lang.org/> e implemente os m√©todos\n"
"que est√£o faltando:"

#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: remova a linha abaixo quando terminar sua implementa√ß√£o.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Usuario {\n"
"    nome: String,\n"
"    idade: u32,\n"
"    peso: f32,\n"
"}\n"
"\n"
"impl Usuario {\n"
"    pub fn new(nome: String, idade: u32, peso: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn nome(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn idade(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn peso(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn definir_idade(&mut self, nova_idade: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn definir_peso(&mut self, novo_peso: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let beto = Usuario::new(String::from(\"Beto\"), 32, 155.2);\n"
"    println!(\"Eu sou {} e minha idade √© {}\", beto.nome(), beto.idade());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_peso() {\n"
"    let beto = Usuario::new(String::from(\"Beto\"), 32, 155.2);\n"
"    assert_eq!(beto.peso(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut beto = Usuario::new(String::from(\"Beto\"), 32, 155.2);\n"
"    assert_eq!(beto.idade(), 32);\n"
"    beto.definir_idade(33);\n"
"    assert_eq!(beto.idade(), 33);\n"
"}\n"
"```"

#: src/exercises/day-2/points-polygons.md:1
msgid "# Polygon Struct"
msgstr "# Estrutura para pol√≠gono"

#: src/exercises/day-2/points-polygons.md:3
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make the\n"
"tests pass:"
msgstr ""
"Vamos criar uma estrutura `Poligono` que cont√©m alguns `Pontos`. Copie o c√≥digo abaixo\n"
"em <https://play.rust-lang.org/> e preencha os m√©todos que faltam para fazer os\n"
"testes passarem:"

#: src/exercises/day-2/points-polygons.md:7
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Point {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Point {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Circle {\n"
"    // add methods\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"// TODO: remova a linha abaixo quando terminar sua implementa√ß√£o.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Ponto {\n"
"    // adicione atributos\n"
"}\n"
"\n"
"impl Ponto {\n"
"    // adicione m√©todos\n"
"}\n"
"\n"
"pub struct Poligono {\n"
"    // adicione atributos\n"
"}\n"
"\n"
"impl Poligono {\n"
"    // adicione m√©todos\n"
"}\n"
"\n"
"pub struct Circulo {\n"
"    // adicione atributos\n"
"}\n"
"\n"
"impl Circulo {\n"
"    // adicione m√©todos\n"
"}\n"
"\n"
"pub enum Forma {\n"
"    Poligono(Poligono),\n"
"    Circulo(Circulo),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn arredonda_dois_digitos(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn testa_magnitude_ponto() {\n"
"        let p1 = Ponto::new(12, 13);\n"
"        assert_eq!(arredonda_dois_digitos(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn testa_distancia_ponto() {\n"
"        let p1 = Ponto::new(10, 10);\n"
"        let p2 = Ponto::new(14, 13);\n"
"        assert_eq!(arredonda_dois_digitos(p1.distancia(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn testa_somar_ponto() {\n"
"        let p1 = Ponto::new(16, 16);\n"
"        let p2 = p1 + Ponto::new(-4, 3);\n"
"        assert_eq!(p2, Ponto::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn testa_ponto_mais_a_esquerda_poligono() {\n"
"        let p1 = Ponto::new(12, 13);\n"
"        let p2 = Ponto::new(16, 16);\n"
"\n"
"        let mut poli = Poligono::new();\n"
"        poli.adiciona_ponto(p1);\n"
"        poli.adiciona_ponto(p2);\n"
"        assert_eq!(poli.ponto_mais_a_esquerda(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn testa_iterador_poligono() {\n"
"        let p1 = Ponto::new(12, 13);\n"
"        let p2 = Ponto::new(16, 16);\n"
"\n"
"        let mut poli = Poligono::new();\n"
"        poli.adiciona_ponto(p1);\n"
"        poli.adiciona_ponto(p2);\n"
"\n"
"        let pontos = poli.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(pontos, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn testa_perimetros_forma() {\n"
"        let mut poli = Poligono::new();\n"
"        poli.adiciona_ponto(Ponto::new(12, 13));\n"
"        poli.adiciona_ponto(Ponto::new(17, 11));\n"
"        poli.adiciona_ponto(Ponto::new(16, 16));\n"
"        let formas = vec![\n"
"            Forma::from(poli),\n"
"            Forma::from(Circulo::new(Ponto::new(10, 20), 5)),\n"
"        ];\n"
"        let perimetros = formas\n"
"            .iter()\n"
"            .map(Forma::perimetro)\n"
"            .map(arredonda_dois_digitos)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimetros, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-2/points-polygons.md:117
msgid ""
"Since the method signatures are missing from the problem statements, the key part\n"
"of the exercise is to specify those correctly. You don't have to modify the tests."
msgstr ""
"Como as assinaturas dos m√©todos est√£o faltando nas declara√ß√µes do problema, a parte principal\n"
"do exerc√≠cio √© especific√°-las corretamente. N√£o √© preciso modificar os testes."

#: src/exercises/day-2/points-polygons.md:120
msgid "Other interesting parts of the exercise:"
msgstr "Outras partes interessante do exerc√≠cio:"

#: src/exercises/day-2/points-polygons.md:122
msgid ""
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes don't borrow their arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be addable via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"Outras partes interessantes do exerc√≠cio:\n"
"    \n"
"* Derive um _trait_ `Copy` para algumas estruturas, j√° que em testes os m√©todos √†s vezes n√£o "
"emprestam seus argumentos.\n"
"* Descubra que o trait `Add` deve ser implementado para que dois objetos sejam adicionados via \"+"
"\"."

#: src/control-flow.md:1
msgid "# Control Flow"
msgstr "# Controle de Fluxo"

#: src/control-flow.md:3
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then becomes\n"
"the value of the `if` expression. Other control flow expressions work similarly\n"
"in Rust."
msgstr ""
"Como vimos, `if` √© uma express√£o em Rust. √â usado para avaliar\n"
"condicionalmente um de dois blocos, mas os blocos podem ter um valor que ent√£o se torna\n"
"o valor da express√£o `if`. Outras express√µes de controle de fluxo funcionam de forma semelhante\n"
"em Rust."

#: src/control-flow/blocks.md:1
msgid "# Blocks"
msgstr "# Blocos"

#: src/control-flow/blocks.md:3
msgid ""
"A block in Rust contains a sequence of expressions.\n"
"Each block has a value and a type,\n"
"which are those of the last expression of the block:"
msgstr ""
"Um bloco em Rust cont√™m uma sequ√™ncia de express√µes.\n"
"Cada bloco tem um valor e um tipo,\n"
"os quais s√£o os da √∫ltima express√£o do bloco:"

#: src/control-flow/blocks.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/control-flow/blocks.md:26
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"Se a √∫ltima express√£o terminar com `;`, o valor resultante e o tipo ser√° "
"`()`."

#: src/control-flow/blocks.md:28
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"A mesma regra √© usada para fun√ß√µes: o valor do corpo da fun√ß√£o √© o\n"
"valor de retorno:"

#: src/control-flow/blocks.md:31
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn dobrar(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"dobrado: {}\", dobrar(7));\n"
"}\n"
"```"

#: src/control-flow/blocks.md:44
msgid ""
"* The point of this slide is to show that blocks have a type and value in "
"Rust. \n"
"* You can show how the value of the block changes by changing the last line "
"in the block. For instance, adding/removing a semicolon or using a "
"`return`.\n"
"   "
msgstr ""
"* O objetivo deste slide √© mostrar que os blocos t√™m um tipo e um valor em Rust.\n"
"* Voc√™ pode mostrar como o valor do bloco muda alterando a √∫ltima linha do bloco. Por exemplo, "
"adicionar/remover um ponto e v√≠rgula (`;`) ou usar um `return`.\n"
"   "

#: src/control-flow/if-expressions.md:1
msgid "# `if` expressions"
msgstr "# Express√µes `if`"

#: src/control-flow/if-expressions.md:3
msgid ""
"You use [`if`\n"
"expressions](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions)\n"
"exactly like `if` statements in other languages:"
msgstr ""
"Voc√™ usa [express√µes `if`\n"
"](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions)\n"
"exatamente como declara√ß√µes `if` em outras linguagens:"

#: src/control-flow/if-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x/2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:18
msgid ""
"In addition, you can use `if` as an expression. The last expression of each\n"
"block becomes the value of the `if` expression:"
msgstr ""
"Al√©m disso, voc√™ pode us√°-lo como uma express√£o. A √∫ltima express√£o de cada\n"
"bloco se torna o valor da express√£o `if`"

#: src/control-flow/if-expressions.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:35
msgid ""
"Because `if` is an expression and must have a particular type, both of its branch blocks must have "
"the same type. Consider showing what happens if you add `;` after `x / 2` in the second example."
msgstr ""
"Como `if` √© uma express√£o e deve ter um tipo espec√≠fico, ambos os blocos de ramifica√ß√£o devem ter "
"o mesmo tipo. Considere mostrar o que acontece se voc√™ adicionar um `;` depois de `x / 2` no segundo exemplo."

#: src/control-flow/if-let-expressions.md:1
msgid "# `if let` expressions"
msgstr "# Express√µes `if let`"

#: src/control-flow/if-let-expressions.md:3
msgid ""
"The [`if let`\n"
"expression](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions)\n"
"lets you execute different code depending on whether a value matches a pattern:"
msgstr ""
"A [express√£o `if let`\n"
"](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions)\n"
"lhe permite que voc√™ execute um c√≥digo diferente, dependendo se um valor corresponde a um padr√£o:"

#: src/control-flow/if-let-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(valor) = arg {\n"
"        println!(\"Nome do programa: {valor}\");\n"
"    } else {\n"
"        println!(\"Falta o nome?\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-let-expressions.md:18
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:23
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in\n"
"Rust."
msgstr ""
"Consulte [correspond√™ncia de padr√µes (_pattern matching_)](../pattern-matching.md) para obter mais detalhes sobre padr√µes em\n"
"Rust."

#: src/control-flow/if-let-expressions.md:23
msgid ""
"* Unlike `match`, `if let` does not have to cover all branches. This can "
"make it more concise than `match`.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern "
"matching.\n"
"* Since 1.65, a similar "
"[let-else](https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html) "
"construct allows to do a destructuring assignment, or if it fails, execute a "
"block which is required to abort normal control flow (with "
"`panic`/`return`/`break`/`continue`):\n"
"\n"
"   ```rust,editable\n"
"   fn main() {\n"
"       println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
"   }\n"
"    \n"
"   fn second_word_to_upper(s: &str) -> Option<String> {\n"
"       let mut it = s.split(' ');\n"
"       let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
"           return None;\n"
"       };\n"
"       Some(item.to_uppercase())\n"
"   }"
msgstr ""
"* Ao contr√°rio de `match`, `if let` n√£o precisa cobrir todas as ramifica√ß√µes. Isso pode torn√°-lo mais conciso do que "
"`match`.\n"
"* Um uso comum √© lidar com valores `Some` ao trabalhar com `Option`.\n"
"* Ao contr√°rio de `match`, `if let` n√£o suporta cl√°usulas de guarda para correspond√™ncia de padr√µes.\n"
"* Desde 1.65, uma constru√ß√£o [let-else](https://doc.rust-lang.org/rust-by-example/flow_control/let_else) semelhante "
"permite fazer uma atribui√ß√£o de desestrutura√ß√£o, ou se falhar, ter um bloco de ramifica√ß√£o "
"sem retorno (`panic`/`return`/`break`/`continue`):\n"
"\n"
"   ```rust,editable\n"
"   fn main() {\n"
"       println!(\"{:?}\", segunda_palavra_para_maiusculas(\"foo bar\"));\n"
"   }\n"
"    \n"
"   fn segunda_palavra_para_maiusculas(s: &str) -> Option<String> {\n"
"       let mut it = s.split(' ');\n"
"       let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
"           return None;\n"
"       };\n"
"       Some(item.to_uppercase())\n"
"   }"

#: src/control-flow/while-expressions.md:1
msgid "# `while` loops"
msgstr "# _Loops_ (La√ßos) `while`"

#: src/control-flow/while-expressions.md:3
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-"
"loops)\n"
"works very similar to other languages:"
msgstr ""
"A [palavra-chave `while`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-"
"loops)\n"
"funciona de maneira muito similar a outras linguagens:"

#: src/control-flow/while-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"X final: {x}\");\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:1
msgid "# `while let` loops"
msgstr "# _Loops_ (La√ßos) `while let`"

#: src/control-flow/while-let-expressions.md:3
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-pattern-loops)\n"
"variant which repeatedly tests a value against a pattern:"
msgstr ""
"Similar a `if let`, h√° uma variante [`while let`](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-pattern-loops)\n"
"que testa repetidamente se um valor corresponde a um padr√£o:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:17
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"Aqui o iterador retornado por `v.iter()` retornar√° uma `Option<i32>` em cada\n"
"chamada para `next()`. Ele retorna `Some(x)` at√© que seja conclu√≠do e, em seguida, retorna \n"
"`None`. O `while let` nos permite continuar iterando por todos os itens."

#: src/control-flow/while-let-expressions.md:26
msgid ""
"* Point out that the `while let` loop will keep going as long as the value matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if statement that breaks when "
"there is no value to unwrap for `iter.next()`. The `while let` provides syntactic sugar for the "
"above scenario.\n"
"    "
msgstr ""
"* Ressalte que o loop `while let` continuar√° executando enquanto o valor corresponder ao padr√£o.\n"
"* Voc√™ pode reescrever o loop `while let` como um loop infinito com uma instru√ß√£o `if` que √© interrompido "
"quando n√£o houver mais nenhum valor para desempacotar (_unwrap_) para `iter.next()`. O `while let` fornece um atalho "
"para o cen√°rio acima.\n"
"    "

#: src/control-flow/for-expressions.md:1
msgid "# `for` loops"
msgstr "# Loops (La√ßos) `for`"

#: src/control-flow/for-expressions.md:3
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is closely\n"
"related to the [`while let` loop](while-let-expressions.md). It will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"O loop `for` est√° intimamente relacionado com o [loop `while let`](while-let-expressions.md). Ele\n"
"chamar√° automaticamente `into_iter()` na express√£o e, em seguida, iterar√° sobre ela:"

#: src/control-flow/for-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"\n"
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"\n"
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/for-expressions.md:21
msgid "You can use `break` and `continue` here as usual."
msgstr "Aqui voc√™ pode usar `break` e `continue` como de costume."

#: src/control-flow/for-expressions.md:25
msgid ""
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change vector `v` to be "
"mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"* A itera√ß√£o de √≠ndice n√£o √© uma sintaxe especial no Rust apenas para esse caso.\n"
"* `(0..10)` √© um _range_ (intervalo) que implementa um trait `Iterator`.\n"
"* `step_by` √© um m√©todo que retorna outro `Iterator` que pula outros elementos alternadamente.\n"
"* Modifique os elementos no vetor e explique os erros de compila√ß√£o. Altere o vetor `v` para ser "
"mut√°vel e o loop `for` para `for x in v.iter_mut()`."

#: src/control-flow/loop-expressions.md:1
msgid "# `loop` expressions"
msgstr "# Express√µes `loop`"

#: src/control-flow/loop-expressions.md:3
msgid ""
"Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#infinite-loops)\n"
"which creates an endless loop."
msgstr ""
"Finalmente, h√° uma [palavra-chave `loop`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops)\n"
"que cria um loop infinito."

#: src/control-flow/loop-expressions.md:6
msgid "Here you must either `break` or `return` to stop the loop:"
msgstr ""
"Aqui voc√™ deve usar `break` ou `return` para parar o loop:"

#: src/control-flow/loop-expressions.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"X final: {x}\");\n"
"}\n"
"```"

#: src/control-flow/loop-expressions.md:27
msgid ""
"* Break the `loop` with a value (e.g. `break 8`) and print it out.\n"
"* Note that `loop` is the only looping construct which returns a non-trivial\n"
"  value. This is because it's guaranteed to be entered at least once (unlike\n"
"  `while` and `for` loops)."
msgstr ""
"* Interrompa o `loop` com um valor (por exemplo, `break 8`) e imprima-o.\n"
"* Observe que `loop` √© a √∫nica constru√ß√£o de loop que retorna um valor n√£o trivial\n"
" . Isso ocorre porque √© garantido que ele ser√° executado pelo menos uma vez (diferente de\n"
" loops `while` e `for`)."

#: src/control-flow/match-expressions.md:1
msgid "# `match` expressions"
msgstr "# Express√µes `match` (Correspond√™ncia)"

#: src/control-flow/match-expressions.md:3
msgid ""
"The [`match` keyword](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n"
"is used to match a value against one or more patterns. In that sense, it works\n"
"like a series of `if let` expressions:"
msgstr ""
"A [palavra-chave `match`](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n"
"√© usada para corresponder um valor a um ou mais padr√µes. Nesse\n"
"sentido, funciona como uma s√©rie de express√µes `if let`:"

#: src/control-flow/match-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"gato\") => println!(\"Vai fazer coisas de gato\"),\n"
"        Some(\"ls\")   => println!(\"Vou ls alguns arquivos\"),\n"
"        Some(\"mv\")   => println!(\"Vamos mover alguns arquivos\"),\n"
"        Some(\"rm\")   => println!(\"Uh, perigoso!\"),\n"
"        None          => println!(\"Hmm, nenhum nome de programa?\"),\n"
"        _             => println!(\"Nome de programa desconhecido!\"),\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:20
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Assim como `if let`, cada bra√ßo de correspond√™ncia deve ter o mesmo tipo. O tipo √© a √∫ltima\n"
"express√£o do bloco, se houver. No exemplo acima, o tipo √© `()`."

#: src/control-flow/match-expressions.md:28
msgid ""
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::args().next()` returns an `Option<String>`, but we cannot match against "
"`String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, this turns "
"`Option<String>` into `Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside `Option`."
msgstr ""
"* Salve o resultado de uma express√£o de correspond√™ncia `match` em uma vari√°vel e imprima-a.\n"
"* Remova `.as_deref()` e explique o erro gerado.\n"
"    * `std::env::Args().next()` retorna um `Option<&String>`, por√©m `match` n√£o funciona com o "
"tipo `String`.\n"
"    * `as_deref()` transforma um `Option<T>` em `Option<&T::Target>`. Em nosso caso, isso transforma "
"um `Option<String>` em `Option<&str>`.\n"
"    * Agora podemos usar a correspond√™ncia de padr√µes em um `&str` dentro de `Option`."

#: src/control-flow/break-continue.md:1
msgid "# `break` and `continue`"
msgstr "# `break` e `continue`"

#: src/control-flow/break-continue.md:3
msgid ""
"- If you want to exit a loop early, use [`break`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#break-expressions),\n"
"- If you want to immediately start\n"
"the next iteration use [`continue`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#continue-expressions)."
msgstr ""
"- Se voc√™ quiser sair de um loop cedo, use [`break`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#break-expressions).\n"
"- Se voc√™ quiser iniciar imediatamente\n"
"a pr√≥xima itera√ß√£o use [`continue`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#continue-expressions)."

#: src/control-flow/break-continue.md:7
msgid ""
"Both `continue` and `break` can optionally take a label argument which is used\n"
"to break out of nested loops:"
msgstr ""
"Ambos `continue` e `break` podem opcionalmente receber um _label_ (r√≥tulo) como argumento\n"
"que √© usado para sair de loops aninhados:"

#: src/control-flow/break-continue.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'laco_externo: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'laco_externo;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/break-continue.md:28
msgid "In this case we break the outer loop after 3 iterations of the inner loop."
msgstr "Neste caso, paramos o loop externo ap√≥s 3 itera√ß√µes do loop interno."

#: src/std.md:1
msgid "# Standard Library"
msgstr "# Biblioteca Padr√£o"

#: src/std.md:3
msgid ""
"Rust comes with a standard library which helps establish a set of common types\n"
"used by Rust library and programs. This way, two libraries can work together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust vem com uma biblioteca padr√£o (_standard library_) que ajuda a estabelecer um conjunto de tipos comuns\n"
"usados por bibliotecas e programas Rust. Dessa forma, duas bibliotecas podem trabalhar juntas\n"
"sem problemas porque ambas usam o mesmo tipo `String`."

#: src/std.md:7
msgid "The common vocabulary types include:"
msgstr "Os tipos de vocabul√°rio comuns incluem:"

#: src/std.md:9
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional values\n"
"  and [error handling](error-handling.md).\n"
"\n"
"* [`String`](std/string.md): the default string type used for owned data.\n"
"\n"
"* [`Vec`](std/vec.md): a standard extensible vector.\n"
"\n"
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm.\n"
"\n"
"* [`Box`](std/box.md): an owned pointer for heap-allocated data.\n"
"\n"
"* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated data."
msgstr ""
"* [`Option` e `Result`](std/option-result.md): tipos usados para valores opcionais\n"
" e [tratamento de erro](error-handling.md).\n"
"\n"
"* [`String`](std/string.md): o tipo de string padr√£o usado para dados _owned_.\n"
"\n"
"* [`Vec`](std/vec.md): um vetor extens√≠vel padr√£o.\n"
"\n"
"* [`HashMap`](std/hashmap.md): um tipo de mapa de hash com um algoritmo de hash\n"
"  configur√°vel.\n"
"\n"
"* [`Box`](std/box.md): um ponteiro _owned_ para dados alocados em heap.\n"
"\n"
"* [`Rc`](std/rc.md): um ponteiro de contagem de refer√™ncia compartilhado para dados alocados em heap."

#: src/std.md:25
msgid ""
"  * In fact, Rust contains several layers of the Standard Library: `core`, `alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on `libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as `Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"  * Na verdade, o Rust cont√©m v√°rias camadas de Biblioteca Padr√£o: `core`, `alloc` e `std`.\n"
"  * `core` inclui os tipos e fun√ß√µes mais b√°sicos que n√£o dependem de `libc`, alocador ou\n"
"    at√© mesmo a presen√ßa de um sistema operacional.\n"
"  * `alloc` inclui tipos que requerem um alocador de heap global, como `Vec`, `Box` e `Arc`.\n"
"  * Os aplicativos Rust embarcados geralmente usam apenas `core` e, √†s vezes, `alloc`."

#: src/std/option-result.md:1
msgid "# `Option` and `Result`"
msgstr "# `Option` e `Result`"

#: src/std/option-result.md:3
msgid "The types represent optional data:"
msgstr "Os tipos representam dados opcionais:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let numeros = vec![10, 20, 30];\n"
"    let primeiro: Option<&i8> = numeros.first();\n"
"    println!(\"primeiro: {primeiro:?}\");\n"
"\n"
"    let ind: Result<usize, usize> = numeros.binary_search(&10);\n"
"    println!(\"ind: {ind:?}\");\n"
"}\n"
"```"

#: src/std/option-result.md:18
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should be inserted."
msgstr ""
"* `Option` e `Result` s√£o amplamente usados n√£o apenas na biblioteca padr√£o.\n"
"* `Option<&T>` n√£o tem nenhum custo adicional de espa√ßo em compara√ß√£o com `&T`.\n"
"* `Result` √© o tipo padr√£o para implementar tratamento de erros, como veremos no Dia 3.\n"
"* `binary_search` retorna `Result<usize, usize>`.\n"
"  * Se encontrado, `Result::Ok` cont√©m o √≠ndice onde o elemento foi encontrado.\n"
"  * Caso contr√°rio, `Result::Err` cont√©m o √≠ndice onde tal elemento deve ser inserido."

#: src/std/string.md:1
msgid "# String"
msgstr "# String"

#: src/std/string.md:3
msgid "[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr "[`String`][1] √© o buffer padr√£o de cadeia de caracteres UTF-8 expans√≠vel e alocado no heap:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Ol√°\");\n"
"    println!(\"s1: tam = {}, capacidade = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: tam = {}, capacidade = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"üáßüá∑\");\n"
"    println!(\"s3: tam = {}, n√∫mero de caracteres = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"

#: src/std/string.md:22
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can call all\n"
"`str` methods on a `String`."
msgstr ""
"`String` implementa [`Deref<Target = str>`][2], o que significa que voc√™ pode chamar todos\n"
"os m√©todos de `str` em uma `String`."

#: src/std/string.md:30
msgid ""
"* `String::new` returns a new empty string, use `String::with_capacity` when you know how much "
"data you want to push to the string.\n"
"* `String::len` returns the size of the `String` in bytes (which can be different from its length "
"in characters).\n"
"* `String::chars` returns an iterator over the actual characters. Note that a `char` can be "
"different from what a human will consider a \"character\" due to [grapheme clusters](https://docs."
"rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html).\n"
"*  When people refer to strings they could either be talking about `&str` or `String`.  \n"
"* When a type implements `Deref<Target = T>`, the compiler will let you transparently call methods "
"from `T`.\n"
"    * `String` implements `Deref<Target = str>` which transparently gives it access to `str`'s "
"methods.\n"
"    * Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;.\n"
"* `String` is implemented as a wrapper around a vector of bytes, many of the operations you see "
"supported on vectors are also supported on `String`, but with some extra guarantees.\n"
"* Compare the different ways to index a `String`:\n"
"    * To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, out-of-bounds.\n"
"    * To a substring by using `s3[0..4]`, where that slice is on character boundaries or not."
msgstr ""
"* `String::new` retorna uma nova string vazia, use `String::with_capacity` quando voc√™ sabe a quantidade de dados que voc√™ deseja colocar na string.\n"
"* `String::len` retorna o tamanho da `String` em bytes (que pode ser diferente de seu comprimento em caracteres).\n"
"* `String::chars` retorna um iterador com os caracteres de fato. Observe que um `char` pode ser diferente do que um humano considerar√° um \"caracter\" devido a "
"[agrupamentos de grafemas (_grapheme clusters_)](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html).\n"
"* Quando as pessoas se referem a strings, elas podem estar falando sobre `&str` ou `String`.\n"
"* Quando um tipo implementa `Deref<Target = T>`, o compilador permitir√° que voc√™ transparentemente chame m√©todos "
"de `T`.\n"
"    * `String` implementa `Deref<Target = str>` que, de forma transparente, d√° acesso aos m√©todos de `str`.\n"
"    * Escreva e compare `let s3 = s1.deref();` e `let s3 = &*s1;`.\n"
"* `String` √© implementado como um wrapper em torno de um vetor de bytes, muitas das opera√ß√µes que voc√™ v√™ "
"suportados em vetores tamb√©m s√£o suportadas em `String`, mas com algumas garantias extras.\n"
"* Compare as diferentes formas de indexar uma `String`:\n"
"    * Para um caracter usando `s3.chars().nth(i).unwrap()` onde `i` est√° dentro dos limites, fora dos limites.\n"
"    * Para uma substring usando `s3[0..4]`, onde essa _slice_ est√° nos limites dos caracteres ou n√£o."

#: src/std/vec.md:1
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[`Vec`][1] √© o buffer padr√£o redimension√°vel alocado no heap:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: tamanho = {}, capacidade = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: tamanho = {}, capacidade = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Macro can√¥nica para inicializar um vetor com elementos.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Mant√©m apenas os elementos pares.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove duplicatas consecutivas.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"

#: src/std/vec.md:29
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call slice\n"
"methods on a `Vec`."
msgstr ""
"`Vec` implementa [`Deref<Target = [T]>`][2], o que significa que voc√™ pode chamar m√©todos de _slice_\n"
"em um `Vec`."

#: src/std/vec.md:37
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data it contains is "
"stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at compile time. It can "
"grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` explicitly. As "
"always\n"
"  with Rust type inference, the `T` was established during the first `push` call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""
"* `Vec` √© um tipo de cole√ß√£o, como `String` e `HashMap`. Os dados que ele cont√©m s√£o armazenados\n"
"  no heap. Isso significa que a quantidade de dados n√£o precisa ser conhecida em tempo de compila√ß√£o. Ela pode crescer\n"
"  ou encolher em tempo de execu√ß√£o.\n"
"* Observe como `Vec<T>` tamb√©m √© um tipo gen√©rico, mas voc√™ n√£o precisa especificar `T` explicitamente. Como sempre,\n"
"  com a infer√™ncia de tipos do Rust, `T` foi estabelecido durante a primeira chamada de `push`.\n"
"* `vec![...]` √© uma macro can√¥nica para usar em vez de `Vec::new()` e suporta a adi√ß√£o de elementos\n"
"  iniciais ao vetor.\n"
"* Para indexar o vetor, voc√™ usa `[` `]`, mas uma exce√ß√£o do tipo _p√¢nico_ (`panic`) ser√° gerada se o √≠ndice estiver\n"
"fora dos limites. Alternativamente, usando\n"
"  `get` voc√™ obter√° um `Option`. A fun√ß√£o `pop` remover√° o √∫ltimo elemento.\n"
"* Mostre uma itera√ß√£o sobre um vetor e alterando o valor:\n"
"  `for e in &mut v { *e += 50; }`"

#: src/std/hashmap.md:1
msgid "# `HashMap`"
msgstr "# `HashMap`"

#: src/std/hashmap.md:3
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "_Hash map_ (Mapa de _hash_) padr√£o com prote√ß√£o contra ataques _HashDoS_:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les Mis√©rables\") {\n"
"        println!(\"We know about {} books, but not Les Mis√©rables.\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string()).or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut contadores_paginas = HashMap::new();\n"
"    contadores_paginas.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
"    contadores_paginas.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    contadores_paginas.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !contadores_paginas.contains_key(\"Les Mis√©rables\") {\n"
"        println!(\"N√≥s sabemos sobre livros {}, mas n√£o Les Mis√©rables.\",\n"
"                 contadores_paginas.len());\n"
"    }\n"
"\n"
"    for livro in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        match contadores_paginas.get(livro) {\n"
"            Some(paginas) => println!(\"{livro}: {paginas} p√°ginas\"),\n"
"            None => println!(\"{livro} √© desconhecido.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use o m√©todo .entry() para inserir um valor caso nada seja encontrado.\n"
"    for livro in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let contador_paginas: &mut i32 = contadores_paginas.entry(livro.to_string()).or_insert(0);\n"
"        *contador_paginas += 1;\n"
"    }\n"
"\n"
"    println!(\"{contadores_paginas:#?}\");\n"
"}\n"
"```"

#: src/std/hashmap.md:38
msgid ""
"* `HashMap` is not defined in the prelude and needs to be brought into scope.\n"
"* Try the following lines of code. The first line will see if a book is in the hashmap and if not "
"return an alternative value. The second line will insert the alternative value in the hashmap if "
"the book is not found.\n"
"\n"
"     ```rust,ignore\n"
"       let pc1 = page_counts\n"
"           .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"           .unwrap_or(&336);\n"
"       let pc2 = page_counts\n"
"           .entry(\"The Hunger Games\".to_string())\n"
"           .or_insert(374);\n"
"       ```\n"
"* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.\n"
"  * Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1], which allows us to "
"easily initialize a hash map from a literal array:\n"
"\n"
"     ```rust,ignore\n"
"       let page_counts = HashMap::from([\n"
"         (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"         (\"The Hunger Games\".to_string(), 374),\n"
"       ]);\n"
"       ```\n"
"\n"
" * Alternatively HashMap can be built from any `Iterator` which yields key-value tuples.\n"
"* We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make examples easier. "
"Using references in collections can, of course, be done,\n"
"  but it can lead into complications with the borrow checker.\n"
"  * Try removing `to_string()` from the example above and see if it still compiles. Where do you "
"think we might run into issues?"
msgstr ""
"* `HashMap` n√£o est√° definido no prel√∫dio e precisa ser inclu√≠do no escopo.\n"
"* Tente as seguintes linhas de c√≥digo. A primeira linha ver√° se um livro est√° no hash map e, caso n√£o esteja, "
"retorna um valor alternativo. A segunda linha ir√° inserir o valor alternativo no hash map se "
"o livro n√£o for encontrado.\n"
"\n"
"\n"
"     ```rust,ignore\n"
"       let pc1 = contadores_paginas\n"
"           .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"           .unwrap_or(&336);\n"
"       let pc2 = contadores_paginas\n"
"           .entry(\"The Hunger Games\".to_string())\n"
"           .or_insert(374);\n"
"       ```\n"
"* Ao contr√°rio de `vec!`, infelizmente n√£o existe uma macro `hashmap!` padr√£o.\n"
"   * Entretanto, desde o Rust 1.56, o HashMap implementa [`From<[(K, V); N]>`][1], o que nos permite "
"inicializar facilmente um hash map a partir de uma matriz literal:\n"
"\n"
"     ```rust,ignore\n"
"       let contadores_paginas = HashMap::from([\n"
"         (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"         (\"The Hunger Games\".to_string(), 374),\n"
"       ]);\n"
"       ```\n"
"\n"
"   * Alternativamente, o HashMap pode ser constru√≠do a partir de qualquer `Iterator` que produz tuplas de chave-valor.\n"
"* Estamos mostrando `HashMap<String, i32>`, e evite usar `&str` como chave para facilitar os exemplos. "
"√â claro que o uso de refer√™ncias em cole√ß√µes pode ser feito,\n"
" mas isto pode levar a complica√ß√µes com o verificador de empr√©stimos.\n"
"   * Tente remover `to_string()` do exemplo acima e veja se ele ainda compila. Onde voc√™ "
"acha que podemos ter problemas?"

#: src/std/box.md:1
msgid "# `Box`"
msgstr "# `Box`"

#: src/std/box.md:3
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1] √© um ponteiro _owned_ para dados no heap:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let cinco = Box::new(5);\n"
"    println!(\"cinco: {}\", *cinco);\n"
"}\n"
"```"

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                       Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    cinco    :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"

#: src/std/box.md:26
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"`Box<T>` implementa `Deref<Target = T>`, o que significa que voc√™ pode [chamar m√©todos\n"
"de `T` diretamente em um `Box<T>`][2]."

#: src/std/box.md:34
msgid ""
"* `Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be not null. \n"
"* In the above example, you can even leave out the `*` in the `println!` statement thanks to "
"`Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the Rust compiler wants to "
"know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying large amounts of data "
"on the stack, instead store the data on the heap in a `Box` so only the pointer is moved."
msgstr ""
"* `Box` √© parecido com `std::unique_ptr` em C++, exceto que ele √© garantidamente n√£o nulo.\n"
"* No exemplo acima, voc√™ pode at√© remover o `*` na instru√ß√£o `println!` gra√ßas ao `Deref`. \n"
"* Uma `Box` √© √∫til quando voc√™:\n"
"   * Tem um tipo cujo tamanho n√£o est√° dispon√≠vel em tempo de compila√ß√£o, mas o compilador Rust "
"precisa saber o tamanho exato.\n"
"   * Precisa transferir o _ownership_ de um grande volume de dados. Ao inv√©s de copiar grandes volumes de dados na pilha,\n"
"eles s√£o armazenados usando uma `Box` no _heap_ e apenas o ponteiro √© movido."

#: src/std/box-recursive.md:1
msgid "# Box with Recursive Data Structures"
msgstr "# `Box` com Estruturas de Dados Recursivas"

#: src/std/box-recursive.md:3
msgid "Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "Tipos de dados recursivos ou tipos de dados com tamanhos din√¢micos precisam usar uma `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let lista: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{lista:?}\");\n"
"}\n"
"```"

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // |   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    lista                :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // |   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/box-recursive.md:33
msgid ""
"* If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`,\n"
"the compiler would not compute a fixed size of the struct in memory (`List` "
"would be of infinite size).\n"
"\n"
"* `Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next\n"
"element of the `List` in the heap.\n"
"\n"
"* Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly.   \n"
"    "
msgstr ""
"Se a `Box` n√£o for usada e tentarmos incorporar uma `List` diretamente na `List`,\n"
"o compilador n√£o conseguiria calcular um tamanho fixo da _struct_ na mem√≥ria (`List` teria tamanho infinito)   .\n"
"\n"
"* `Box` resolve esse problema, pois tem o mesmo tamanho de um ponteiro normal e apenas aponta para o "
"pr√≥ximo\n"
"elemento da `List` no _heap_.\n"
"\n"
"* Remova o `Box` na defini√ß√£o de `List` e mostre o erro de compila√ß√£o. \"Recursive with "
"indirection\" (recursivo com indire√ß√£o) √© uma dica para que voc√™ talvez queira usar uma `Box` ou refer√™ncia de alguma forma, ao inv√©s de armazenar "
"um valor diretamente.   \n"
"    "

#: src/std/box-niche.md:1
msgid "# Niche Optimization"
msgstr "# Otimiza√ß√£o de Nicho"

#: src/std/box-niche.md:16
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"Uma `Box` n√£o pode estar vazia, portanto o ponteiro √© sempre v√°lido e n√£o nulo (`null`). Isto\n"
"permite que o compilador otimize o layout da mem√≥ria:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                             :\n"
":    list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null |             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Pilha                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                             :\n"
":    lista                :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null |             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/rc.md:1
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to refer\n"
"to the same data from multiple places:"
msgstr ""
"[`Rc`][1] √© um ponteiro compartilhado com contagem de refer√™ncia. Use-o quando precisar consultar\n"
"os mesmos dados a partir de v√°rios locais:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"

#: src/std/rc.md:18
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create cycles\n"
"  that will get dropped."
msgstr ""
"* Se voc√™ precisar alterar os dados dentro de um `Rc`, precisar√° agrupar os dados em\n"
"  um tipo como [`Cell` ou `RefCell`][2].\n"
"* Veja [`Arc`][3] se voc√™ estiver em um contexto multi-thread.\n"
"* Voc√™ pode *downgrade* um ponteiro compartilhado para um ponteiro [`Weak`][4] para criar ciclos\n"
"  que ser√£o descartados."

#: src/std/rc.md:31
msgid ""
"* `Rc`'s count ensures that its contained value is valid for as long as "
"there are references.\n"
"* `Rc` in Rust is like `std::shared_ptr` in C++.\n"
"* `Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code.\n"
"* `make_mut` actually clones the inner value if necessary "
"(\"clone-on-write\") and returns a mutable reference.\n"
"* Use `Rc::strong_count` to check the reference count.\n"
"* Compare the different datatypes mentioned. `Box` enables (im)mutable "
"borrows that are enforced at compile time. `RefCell` enables (im)mutable "
"borrows that are enforced at run time and will panic if it fails at "
"runtime.\n"
"* `Rc::downgrade` gives you a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* O contador do `Rc` garante que os seus valores contidos sejam v√°lidos enquanto houver refer√™ncias.\n"
"* `Rc` em Rust √© como `std::shared_ptr` em C++.\n"
"* `Rc::clone` √© barato: ele cria um ponteiro para a mesma aloca√ß√£o e aumenta a contagem de refer√™ncia. "
"Ele n√£o faz um \"clone profundo\" (_deep clone_) e geralmente pode ser ignorado ao procurar problemas de desempenho "
"no c√≥digo.\n"
"* `make_mut` realmente clona o valor interno se necess√°rio (\"_clone-on-write_\") e retorna uma "
"refer√™ncia mut√°vel.\n"
"* Use `Rc::strong_count` para verificar a contagem de refer√™ncia.\n"
"* Compare os diferentes tipos de dados mencionados. `Box` permite empr√©stimos mut√°veis e imut√°veis que s√£o impostos "
"em tempo de compila√ß√£o. `RefCell` permite empr√©stimos mut√°veis e imut√°veis impostos em tempo de execu√ß√£o e ir√° lan√ßar um "
"`panic` caso falhe.\n"
"* `Rc::downgrade` lhe fornece um objeto *contador de refer√™ncias \"fraco\" (weak)* para criar\n"
"ciclos que podem ser apropriadamente descartados (provavelmente combinados com `RefCell`)."

#: src/std/rc.md:41
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;\n"
"\n"
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;\n"
"\n"
"#[derive(Debug)]\n"
"struct Node {\n"
"    valor: i64,\n"
"    pai: Option<Weak<RefCell<Node>>>,\n"
"    filhos: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut raiz = Rc::new(RefCell::new(Node {\n"
"        valor: 42,\n"
"        pai: None,\n"
"        filhos: vec![],\n"
"    }));\n"
"    let filho = Rc::new(RefCell::new(Node {\n"
"        valor: 43,\n"
"        filhos: vec![],\n"
"        pai: Some(Rc::downgrade(&raiz))\n"
"    }));\n"
"    raiz.borrow_mut().filhos.push(filho);\n"
"\n"
"    println!(\"Grafo: {raiz:#?}\");\n"
"}\n"
"```"

#: src/modules.md:1
msgid "# Modules"
msgstr "# M√≥dulos"

#: src/modules.md:3
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Vimos como os blocos `impl` nos permitem usar _namespaces_ (espa√ßos de nomes) de fun√ß√µes para um tipo."

#: src/modules.md:5
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "Da mesma forma, `mod` nos permite usar _namespaces_ de tipos e fun√ß√µes:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn faz_algo() {\n"
"        println!(\"No m√≥dulo foo\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn faz_algo() {\n"
"        println!(\"No m√≥dulo bar\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::faz_algo();\n"
"    bar::faz_algo();\n"
"}\n"
"```"

#: src/modules.md:28
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that describes how to build a "
"bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable and a library crate "
"compiles to a library.\n"
"* Modules define organization, scope, and are the focus of this section."
msgstr ""
"* Pacotes (_packages_) fornecem funcionalidades e incluem um arquivo `Cargo.toml` que descreve como "
"gerar um pacote com um ou mais _crates_.\n"
"* _Crates_ s√£o arvores de m√≥dulos, onde um _crate_ bin√°rio cria um execut√°vel e um _crate_ de "
"biblioteca √© compilado em uma biblioteca.\n"
"* M√≥dulos definem organiza√ß√£o, escopo e s√£o o foco desta se√ß√£o."

#: src/modules/visibility.md:1
msgid "# Visibility"
msgstr "# Visibilidade"

#: src/modules/visibility.md:3
msgid "Modules are a privacy boundary:"
msgstr "M√≥dulos s√£o limitadores de privacidade:"

#: src/modules/visibility.md:5
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all the\n"
"  descendants of `foo`."
msgstr ""
"* Itens do m√≥dulo s√£o privados por padr√£o (ocultam detalhes de implementa√ß√£o).\n"
"* Itens paternos e fraternos s√£o sempre vis√≠veis.\n"
"* Em outras palavras, se um item √© vis√≠vel no m√≥dulo `foo`, ele √© vis√≠vel em todos os\n"
"  descendentes de `foo`."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"mod externo {\n"
"    fn privado() {\n"
"        println!(\"externo::privado\");\n"
"    }\n"
"\n"
"    pub fn publico() {\n"
"        println!(\"externo::publico\");\n"
"    }\n"
"\n"
"    mod interno {\n"
"        fn privado() {\n"
"            println!(\"externo::interno::privado\");\n"
"        }\n"
"\n"
"        pub fn publico() {\n"
"            println!(\"externo::interno::publico\");\n"
"            super::privado();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    externo::publico();\n"
"}\n"
"```"

#: src/modules/visibility.md:39
msgid "* Use the `pub` keyword to make modules public."
msgstr "* Use a palavra reservada `pub` para tornar m√≥dulos p√∫blicos."

#: src/modules/visibility.md:41
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope of public visibility."
msgstr ""
"* Adicionamente, existem especificadores `pub(...)` avan√ßados para restringir o\n"
"escopo de visibilidade p√∫blica."

#: src/modules/visibility.md:43
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-"
"path-pubcrate-pubsuper-and-pubself).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of its descendants)."
msgstr ""
"* Veja a [Refer√™ncia Rust](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-"
"path-pubcrate-pubsuper-and-pubself).\n"
"* A configura√ß√£o de visibilidade `pub(crate)` √© um padr√£o comum.\n"
"* Menos comum, voc√™ pode dar visibilidade para um caminho espec√≠fico.\n"
"* Em todo caso, a visibilidade deve ser concedida a um m√≥dulo ancestral (e a todos os seus descendentes)."

#: src/modules/paths.md:1
msgid "# Paths"
msgstr "# Caminhos (_Paths_)"

#: src/modules/paths.md:3
msgid "Paths are resolved as follows:"
msgstr "Caminhos s√£o resolvidos da seguinte forma:"

#: src/modules/paths.md:5
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module.\n"
"\n"
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"1. Como um caminho relativo:\n"
"   * `foo` ou `self::foo` referem-se √† `foo` no m√≥dulo atual,\n"
"   * `super::foo` refere-se √† `foo` no m√≥dulo pai.\n"
"\n"
"2. Como um caminho absoluto:\n"
"   * `crate::foo` refere-se √† `foo` na raiz do _crate_ atual,\n"
"   * `bar::foo` refere-se a `foo` no _crate_ `bar`."

#: src/modules/paths.md:13
msgid ""
"A module can bring symbols from another module into scope with `use`.\n"
"You will typically see something like this at the top of each module:"
msgstr ""
"Um m√≥dulo pode trazer s√≠mbolos de outro m√≥dulo para o escopo com `use`.\n"
"Normalmente, voc√™ ver√° algo assim na parte superior de cada m√≥dulo:"

#: src/modules/paths.md:16
msgid ""
"```rust,editable\n"
"use std::collections::HashSet;\n"
"use std::mem::transmute;\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::collections::HashSet;\n"
"use std::mem::transmute;\n"
"```"

#: src/modules/filesystem.md:1
msgid "# Filesystem Hierarchy"
msgstr "# Hierarquia do Sistema de Arquivos"

#: src/modules/filesystem.md:3
msgid "The module content can be omitted:"
msgstr "O conte√∫do do m√≥dulo pode ser omitido:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"mod jardim;\n"
"```"

#: src/modules/filesystem.md:9
msgid "The `garden` module content is found at:"
msgstr "O conte√∫do do m√≥dulo `jardim` √© encontrado em:"

#: src/modules/filesystem.md:11
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/jardim.rs` (estilo Rust 2018 moderno)\n"
"* `src/jardim/mod.rs` (antigo estilo Rust 2015)"

#: src/modules/filesystem.md:14
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "Da mesma forma, um m√≥dulo `jardim::vegetais` pode ser encontrado em:"

#: src/modules/filesystem.md:16
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/jardim/vegetais.rs` (estilo Rust 2018 moderno)\n"
"* `src/jardim/vegetais/mod.rs` (antigo estilo Rust 2015)"

#: src/modules/filesystem.md:19
msgid "The `crate` root is in:"
msgstr "A raiz `crate` est√° em:"

#: src/modules/filesystem.md:21
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* `src/lib.rs` (para um _crate_ de biblioteca)\n"
"* `src/main.rs` (para um _crate_ bin√°rio)"

#: src/modules/filesystem.md:24
msgid ""
"Modules defined in files can be documented, too, using \"inner doc comments\".\n"
"These document the item that contains them -- in this case, a module."
msgstr ""
"M√≥dulos definidos em arquivos tamb√©m podem ser documentados usando \"coment√°rios internos de documento\" (_inner doc comments_).\n"
"Estes documentam o item que os cont√©m - neste caso, um m√≥dulo."

#: src/modules/filesystem.md:27
msgid ""
"```rust,editable,compile_fail\n"
"//! This module implements the garden, including a highly performant germination\n"
"//! implementation.\n"
"\n"
"// Re-export types from this module.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sow the given seed packets.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
"\n"
"/// Harvest the produce in the garden that is ready.\n"
"pub fn harvest(garden: &mut Garden) { todo!() }\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"//! Este m√≥dulo implementa o jardim, incluindo uma implementa√ß√£o de germina√ß√£o\n"
"//!  de alto desempenho.\n"
"\n"
"// Re-exporta tipos deste m√≥dulo.\n"
"pub use sementes::SementePacote;\n"
"pub use jardim::Jardim;\n"
"\n"
"/// Semeia os pacotes de semente fornecidos.\n"
"pub fn semear(sementes: Vec<SementePacote>) { todo!() }\n"
"\n"
"/// Colhe os vegetais no jardim que est√° pronto.\n"
"pub fn colher(jardim: &mut Jardim) { todo!() }\n"
"```"

#: src/modules/filesystem.md:44
msgid ""
"* The change from `module/mod.rs` to `module.rs` doesn't preclude the use of submodules in Rust "
"2018.\n"
"  (It was mandatory in Rust 2015.)\n"
"\n"
"  The following is valid:\n"
"\n"
"  ```ignore\n"
"  src/\n"
"  ‚îú‚îÄ‚îÄ main.rs\n"
"  ‚îú‚îÄ‚îÄ top_module.rs\n"
"  ‚îî‚îÄ‚îÄ top_module/\n"
"      ‚îî‚îÄ‚îÄ sub_module.rs\n"
"  ```\n"
"\n"
"* The main reason for the change is to prevent many files named `mod.rs`, which can be hard\n"
"  to distinguish in IDEs.\n"
"\n"
"* Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but this can be changed\n"
"  with a compiler directive:\n"
"\n"
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```\n"
"\n"
"  This is useful, for example, if you would like to place tests for a module in a file named\n"
"  `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"* A mudan√ßa de `modulo/mod.rs` para `modulo.rs` n√£o impede o uso de subm√≥dulos no Rust "
"2018.\n"
" (Isto era obrigat√≥rio no Rust 2015)\n"
"\n"
" O seguinte √© v√°lido:\n"
"\n"
"  ```ignore\n"
"  src/\n"
"  ‚îú‚îÄ‚îÄ main.rs\n"
"  ‚îú‚îÄ‚îÄ top_module.rs\n"
"  ‚îî‚îÄ‚îÄ top_module/\n"
"      ‚îî‚îÄ‚îÄ sub_module.rs\n"
"  ```\n"
"\n"
"* A principal raz√£o para a altera√ß√£o √© evitar muitos arquivos denominados `mod.rs`, que podem ser dif√≠ceis\n"
" de distinguir em IDEs.\n"
"\n"
"* Rust procurar√° m√≥dulos em `modulonome/mod.rs` e `modulonome.rs`, mas isso pode ser alterado\n"
" com uma diretiva de compilador:\n"
"\n"
"  ```rust,ignore\n"
"  #[caminho = \"algum/caminho.rs\"]\n"
"  mod algum_modulo { }\n"
"  ```\n"
"\n"
"Isto √© √∫til, por exemplo, se voc√™ quiser colocar testes para um m√≥dulo em um arquivo chamado\n"
" `algum_modulo_teste.rs`, semelhante √† conven√ß√£o em Go."

#: src/exercises/day-2/afternoon.md:1
msgid "# Day 2: Afternoon Exercises"
msgstr "# Dia 2: Exerc√≠cios da Tarde"

#: src/exercises/day-2/afternoon.md:3
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "Os exerc√≠cios desta tarde se concentrar√£o em strings e iteradores."

#: src/exercises/day-2/luhn.md:1
msgid "# Luhn Algorithm"
msgstr "# Algoritmo de Luhn"

#: src/exercises/day-2/luhn.md:3
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to\n"
"validate credit card numbers. The algorithm takes a string as input and does the\n"
"following to validate the credit card number:"
msgstr ""
"O [algoritmo de Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) √© usado para\n"
"validar n√∫meros de cart√£o de cr√©dito. O algoritmo recebe uma string como entrada e faz o\n"
"seguinte para validar o n√∫mero do cart√£o de cr√©dito:"

#: src/exercises/day-2/luhn.md:7
msgid ""
"* Ignore all spaces. Reject number with less than two digits.\n"
"\n"
"* Moving from right to left, double every second digit: for the number `1234`,\n"
"  we double `3` and `1`.\n"
"\n"
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` which\n"
"  becomes `5`.\n"
"\n"
"* Sum all the undoubled and doubled digits.\n"
"\n"
"* The credit card number is valid if the sum ends with `0`."
msgstr ""
"* Ignore todos os espa√ßos. Rejeite n√∫mero com menos de dois d√≠gitos.\n"
"\n"
"* Movendo-se da direita para a esquerda, dobre cada segundo d√≠gito: para o n√∫mero `1234`,\n"
" dobramos `3` e `1`.\n"
"\n"
"* Depois de dobrar um d√≠gito, some os d√≠gitos. Portanto, dobrando `7` torna-se `14`, que\n"
" torna-se `5`.\n"
"\n"
"* Some todos os d√≠gitos, dobrados ou n√£o.\n"
"\n"
"* O n√∫mero do cart√£o de cr√©dito √© v√°lido se a soma terminar em `0`."

#: src/exercises/day-2/luhn.md:19
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"Copie o seguinte c√≥digo para <https://play.rust-lang.org/> e implemente a\n"
"fun√ß√£o:"

#: src/exercises/day-2/luhn.md:23
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"// TODO: remova isto quando voc√™ estiver terminado com sua implementa√ß√£o.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_numero: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_cc_numero_nao_digito() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_cc_numero_vazio() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_cc_numero_digito_simples() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_cc_numero_dois_digitos() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_cc_numero_valido() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_cc_numero_invalido() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"

#: src/exercises/day-2/strings-iterators.md:1
msgid "# Strings and Iterators"
msgstr "# Strings e Iteradores"

#: src/exercises/day-2/strings-iterators.md:3
msgid ""
"In this exercise, you are implementing a routing component of a web server. The\n"
"server is configured with a number of _path prefixes_ which are matched against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"Neste exerc√≠cio, voc√™ ir√° implementar um componente de roteamento de um servidor web. O\n"
"servidor est√° configurado com um n√∫mero de _prefixos de caminhos_ que s√£o comparados\n"
"com os _caminhos requisitados_. Os prefixos de caminho podem conter um caractere curinga que\n"
"corresponde a um segmento completo. Veja os testes unit√°rios abaixo."

#: src/exercises/day-2/strings-iterators.md:8
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copie o seguinte c√≥digo para <https://play.rust-lang.org/> e fa√ßa os testes\n"
"passarem. Tente evitar alocar um `Vec` para seus resultados intermedi√°rios:"

#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// TODO: remova isto quando voc√™ estiver terminado com sua implementa√ß√£o.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn corresponde_prefixo(prefixo: &str, caminho_requisitado: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_corresponde_sem_curinga() {\n"
"    assert!(corresponde_prefixo(\"/v1/editores\", \"/v1/editores\"));\n"
"    assert!(corresponde_prefixo(\"/v1/editores\", \"/v1/editores/abc-123\"));\n"
"    assert!(corresponde_prefixo(\"/v1/editores\", \"/v1/editores/abc/livros\"));\n"
"\n"
"    assert!(!corresponde_prefixo(\"/v1/editores\", \"/v1\"));\n"
"    assert!(!corresponde_prefixo(\"/v1/editores\", \"/v1/editoresLivros\"));\n"
"    assert!(!corresponde_prefixo(\"/v1/editores\", \"/v1/pai/editores\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_corresponde_com_curinga() {\n"
"    assert!(corresponde_prefixo(\n"
"        \"/v1/editores/*/livros\",\n"
"        \"/v1/editores/foo/livros\"\n"
"    ));\n"
"    assert!(corresponde_prefixo(\n"
"        \"/v1/editores/*/livros\",\n"
"        \"/v1/editores/bar/livros\"\n"
"    ));\n"
"    assert!(corresponde_prefixo(\n"
"        \"/v1/editores/*/livros\",\n"
"        \"/v1/editores/foo/livros/livro1\"\n"
"    ));\n"
"\n"
"    assert!(!corresponde_prefixo(\"/v1/editores/*/livros\", \"/v1/editores\"));\n"
"    assert!(!corresponde_prefixo(\n"
"        \"/v1/editores/*/livros\",\n"
"        \"/v1/editores/foo/livrosPorAutor\"\n"
"    ));\n"
"}\n"
"```"

#: src/welcome-day-3.md:1
msgid "# Welcome to Day 3"
msgstr "# Bem-vindo ao Dia 3"

#: src/welcome-day-3.md:3
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Hoje, abordaremos alguns t√≥picos mais avan√ßados em Rust:"

#: src/welcome-day-3.md:5
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits.\n"
"\n"
"* Generics: generic data types, generic methods, monomorphization, and trait\n"
"  objects.\n"
"\n"
"* Error handling: panics, `Result`, and the try operator `?`.\n"
"\n"
"* Testing: unit tests, documentation tests, and integration tests.\n"
"\n"
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""

#: src/generics.md:1
msgid "# Generics"
msgstr "# Generics (Gen√©ricos)"

#: src/generics.md:3
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as sorting)\n"
"over the types used in the algorithm."
msgstr ""
"Rust oferece suporte a tipos gen√©ricos, que permitem a um algoritmo (como classifica√ß√£o, por "
"exemplo),\n"
"abstrair os tipos de dados usados no algoritmo."

#: src/generics/data-types.md:1
msgid "# Generic Data Types"
msgstr "# Tipos de dados gen√©ricos"

#: src/generics/data-types.md:3
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Voc√™ pode usar tipos gen√©ricos para abstrair o tipo concreto do campo:"

#: src/generics/data-types.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let inteiro = Ponto { x: 5, y: 10 };\n"
"    let real = Ponto { x: 1.0, y: 4.0 };\n"
"    println!(\"{inteiro:?} e {real:?}\");\n"
"}\n"
"```"

#: src/generics/data-types.md:21
msgid ""
"* Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`.\n"
"\n"
"* Fix the code to allow points that have elements of different types."
msgstr ""

#: src/generics/methods.md:1
msgid "# Generic Methods"
msgstr "# M√©todos Gen√©ricos"

#: src/generics/methods.md:3
msgid "You can declare a generic type on your `impl` block:"
msgstr "Voc√™ pode declarar um tipo gen√©rico em seu bloco `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that redundant?\n"
"    * This is because it is a generic implementation section for generic type. They are "
"independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods in this block will only "
"be available for `Point<u32>`."
msgstr ""
"* *Pergunta:* Por que `T` √© especificado duas vezes em `impl<T> Ponto<T> {}`? Isso n√£o √© "
"redundante?\n"
"    * Isso ocorre porque √© uma se√ß√£o de implementa√ß√£o gen√©rica para tipo gen√©rico. Eles s√£o "
"gen√©ricos de forma independente.\n"
"    * Significa que esses m√©todos s√£o definidos para qualquer `T`.\n"
"    * √â poss√≠vel escrever `Impl Ponto<u32> { .. }`.\n"
"      * `Ponto` ainda √© gen√©rico e voc√™ pode usar `Ponto<f64>`, mas os m√©todos neste bloco s√≥ "
"estar√£o dispon√≠veis para `Ponto<u32>`."

#: src/generics/monomorphization.md:1
msgid "# Monomorphization"
msgstr "# Monomorfiza√ß√£o"

#: src/generics/monomorphization.md:3
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr "O c√≥digo _gen√©rico_ √© transformado em c√≥digo _n√£o gen√©rico_ de acordo com os tipos usados:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let inteiro = Some(5);\n"
"    let real = Some(5.0);\n"
"}\n"
"```"

#: src/generics/monomorphization.md:12
msgid "behaves as if you wrote"
msgstr "se comporta como se voc√™ tivesse escrito"

#: src/generics/monomorphization.md:14
#, fuzzy
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"\n"
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let inteiro = Option_i32::Some(5);\n"
"    let real = Option_f64::Some(5.0);\n"
"}\n"
"```"

#: src/generics/monomorphization.md:31
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"Esta √© uma abstra√ß√£o de custo zero: voc√™ obt√©m exatamente o mesmo resultado como se tivesse\n"
"codificado manualmente as estruturas de dados sem utilizar a abstra√ß√£o."

#: src/traits.md:1
msgid "# Traits"
msgstr "# Traits (Caracter√≠sticas)"

#: src/traits.md:3
msgid "Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust permite abstrair caracter√≠sticas dos tipos usando `trait`. Eles s√£o semelhantes √†s interfaces:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it anyway.\n"
"    }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &P) {\n"
"    println!(\"Who's a cutie? {} is!\", pet.name());\n"
"}\n"
"\n"
"fn main() {\n"
"    let fido = Dog { name: \"Fido\".into() };\n"
"    greet(&fido);\n"
"\n"
"    let captain_floof = Cat;\n"
"    greet(&captain_floof);\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:1
msgid "# Trait Objects"
msgstr "# Objetos `trait`"

#: src/traits/trait-objects.md:3
msgid "Trait objects allow for values of different types, for instance in a collection:"
msgstr ""

#: src/traits/trait-objects.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it anyway.\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec<Box<dyn Pet>> = vec![\n"
"        Box::new(Cat),\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Hello {}!\", pet.name());\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:40
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Layout da mem√≥ria ap√≥s alocar `xs`:"

#: src/traits/trait-objects.md:42
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  |           :\n"
":                           :     :     | |   |     +---------------+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                 :\n"
"                                  :     | |   |     +----------------------+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" |    :\n"
"                                  :     | |         +----------------------+    : \n"
"                                  :     | |                                     : \n"
"                                  :     | |   +-+                               :   \n"
"                                  :     | '-->|\\|                               :     \n"
"                                  :     |     +-+                               :    \n"
"                                  :     |                                       : \n"
"                                  :     |     +----------------------+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" |          : \n"
"                                  :           +----------------------+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                               :\n"
":    xs                     :     :                                               :\n"
":   +------------+-------+  :     :   +-----+-----+                               :\n"
":   | ponteir    |   o---+--+-----+-->| o o | o o |                               :\n"
":   | tamanho    |     2 |  :     :   +-|-|-+-|-|-+                               :\n"
":   | capacidade |     2 |  :     :     | |   | |   +----+----+----+              :\n"
":   +------------+-------+  :     :     | |   | '-->| O  | l  | √°  |              :\n"
":                           :     :     | |   |     +----+----+----+              :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                   :\n"
"                                  :     | |   |     +-------------------------+   :\n"
"                                  :     | |   '---->|\"<str as Display>::fmt\"|   :\n"
"                                  :     | |         +-------------------------+   :\n"
"                                  :     | |                                       :\n"
"                                  :     | |   +----+----+----+----+               :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |               :\n"
"                                  :     |     +----+----+----+----+               :\n"
"                                  :     |                                         :\n"
"                                  :     |     +-------------------------+         :\n"
"                                  :     '---->|\"<i32 as Display>::fmt\"|         :\n"
"                                  :           +-------------------------+         :\n"
"                                  :                                               :\n"
"                                  :                                               :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/traits/trait-objects.md:72
#, fuzzy
msgid ""
"* Types that implement a given trait may be of different sizes. This makes it impossible to have "
"things like `Vec<Pet>` in the example above.\n"
"* `dyn Pet` is a way to tell the compiler about a dynamically sized type that implements `Pet`.\n"
"* In the example, `pets` holds *fat pointers* to objects that implement `Pet`. The fat pointer "
"consists of two components, a pointer to the actual object and a pointer to the virtual method "
"table for the `Pet` implementation of that particular object.\n"
"* Compare these outputs in the above example:\n"
"     ```rust,ignore\n"
"         println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"         println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"         println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"         println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
"     ```"
msgstr ""
"* _Traits_ podem especificar m√©todos pr√©-implementados (padr√£o) e m√©todos que os usu√°rios devem "
"implementar por conta pr√≥pria. Os m√©todos com implementa√ß√µes padr√£o podem contar com os m√©todos "
"necess√°rios.\n"
"* Os tipos que implementam uma determinada caracter√≠stica podem ser de tamanhos diferentes. Isso "
"torna imposs√≠vel ter coisas como `Vec<Greet>` no exemplo acima.\n"
"* `dyn Greet` √© uma maneira de dizer ao compilador sobre um tipo de tamanho din√¢mico que "
"implementa `Greet`.\n"
"* No exemplo, `pets` mant√©m _Fat Pointers_ para objetos que implementam `Greet`. O _Fat Pointer_ "
"consiste em dois componentes, um ponteiro para o objeto real e um ponteiro para a tabela de "
"m√©todos virtuais para a implementa√ß√£o de `Greet` desse objeto em particular."

#: src/traits/deriving-traits.md:1
msgid "# Deriving Traits"
msgstr "# traits derivados"

#: src/traits/deriving-traits.md:3
msgid "You can let the compiler derive a number of traits:"
msgstr "Voc√™ pode deixar o compilador derivar uma s√©rie de traits:"

#: src/traits/deriving-traits.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let p1 = Jogador::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"√â {:?}\\nigual a {:?}?\\nA resposta √© {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"sim\" } else { \"n√£o\" });\n"
"}\n"
"```"

#: src/traits/default-methods.md:1
msgid "# Default Methods"
msgstr "# M√©todos Padr√£o"

#: src/traits/default-methods.md:3
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "Traits podem implementar o comportamento em termos de outros m√©todos de `trait`:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimeter(i16);\n"
"\n"
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:32
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that users are required to\n"
"  implement themselves. Methods with default implementations can rely on required methods.\n"
"\n"
"* Move method `not_equal` to a new trait `NotEqual`.\n"
"\n"
"* Make `Equals` a super trait for `NotEqual`.\n"
"    ```rust,editable,compile_fail\n"
"    trait NotEqual: Equals {\n"
"        fn not_equal(&self, other: &Self) -> bool {\n"
"            !self.equal(other)\n"
"        }\n"
"    }\n"
"    ```\n"
"\n"
"* Provide a blanket implementation of `NotEqual` for `Equal`.\n"
"    ```rust,editable,compile_fail\n"
"    trait NotEqual {\n"
"        fn not_equal(&self, other: &Self) -> bool;\n"
"    }\n"
"\n"
"    impl<T> NotEqual for T where T: Equals {\n"
"        fn not_equal(&self, other: &Self) -> bool {\n"
"            !self.equal(other)\n"
"        }\n"
"    }\n"
"    ```\n"
"  * With the blanket implementation, you no longer need `Equals` as a super trait for `NotEqual`.\n"
"    "
msgstr ""

#: src/traits/trait-bounds.md:1
msgid "# Trait Bounds"
msgstr "# Limites de traits"

#: src/traits/trait-bounds.md:3
msgid ""
"When working with generics, you often want to require the types to implement\n"
"some trait, so that you can call this trait's methods."
msgstr ""
"Ao trabalhar com gen√©ricos, muitas vezes voc√™ exigir que os tipos implementem algum `trait`\n"
" para poder utilizar os m√©todos do `trait`."

#: src/traits/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Voc√™ consegue fazer isso com `T:Trait` ou `impl Trait`:"

#: src/traits/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:35
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""

#: src/traits/trait-bounds.md:37
#, fuzzy
msgid ""
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn duplicar<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"

#: src/traits/trait-bounds.md:46
#, fuzzy
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of \":\" can be arbitrary, "
"like `Option<T>`.\n"
"    "
msgstr ""
"* Organiza a assinatura da fun√ß√£o se voc√™ tiver muitos par√¢metros.\n"
"* Possui recursos adicionais tornando-o mais poderoso.\n"
"    * Se algu√©m perguntar, o recurso extra √© que o tipo √† esquerda de \":\" pode ser arbitr√°rio, "
"como `Option<T>`.\n"
"    \n"
"</details>"

#: src/traits/impl-trait.md:1
msgid "# `impl Trait`"
msgstr "# Trait `impl`"

#: src/traits/impl-trait.md:3
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"Semelhante aos limites do _trait_, a sintaxe do _trait_ `impl` pode ser usada em argumentos de "
"fun√ß√µes\n"
"e em valores de retorno:"

#: src/traits/impl-trait.md:6
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/impl-trait.md:19
#, fuzzy
msgid "* `impl Trait` allows you to work with types which you cannot name."
msgstr ""
"* `impl Trait` n√£o pode ser usado com a sintaxe turbo fish `::<>`.\n"
"* `impl Trait` permite que voc√™ trabalhe com tipos que voc√™ n√£o pode nomear."

#: src/traits/impl-trait.md:23
msgid "The meaning of `impl Trait` is a bit different in the different positions."
msgstr "O significado do _trait_ `impl` √© um pouco difere de acordo com sua posi√ß√£o."

#: src/traits/impl-trait.md:25
#, fuzzy
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with a trait bound.\n"
"\n"
"* For a return type, it means that the return type is some concrete type that implements the "
"trait,\n"
"  without naming the type. This can be useful when you don't want to expose the concrete type in "
"a\n"
"  public API.\n"
"\n"
"  Inference is hard in return position. A function returning `impl Foo` picks\n"
"  the concrete type it returns, without writing it out in the source. A function\n"
"  returning a generic type like `collect<B>() -> B` can return any type\n"
"  satisfying `B`, and the caller may need to choose one, such as with `let x:\n"
"  Vec<_> = foo.collect()` or with the turbofish, `foo.collect::<Vec<_>>()`."
msgstr ""
"* Como par√¢metro, o _trait_ `impl` √© como um par√¢metro gen√©rico an√¥nimo com um limitador de "
"caracter√≠sticas (trait).\n"
"* Como tipo de retorno, significa que o tipo de retorno √© algum tipo concreto que implementa o "
"_trait_,\n"
"  sem namear o tipo. Isso pode ser √∫til quando voc√™ n√£o deseja expor o tipo concreto em uma\n"
"  API p√∫blica."

#: src/traits/impl-trait.md:37
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` type are the same "
"type.\n"
"It would not work for this particular function, as the type we expect as input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, we'd need two\n"
"independent generic parameters."
msgstr ""
"Este exemplo √© √≥timo, porque usa `impl Display` duas vezes. Isso ajuda a explicar\n"
"que nada imp√µe que, nos dois usos, `impl Display` seja _do mesmo_ tipo. Se us√°ssemos um √∫nico\n"
"`T: Display`, imporia a restri√ß√£o de que o tipo `T` de entrada e o tipo `T` de retorno s√£o do "
"mesmo tipo.\n"
"Isso n√£o funcionaria para esta fun√ß√£o espec√≠fica, pois o tipo que esperamos como entrada "
"provavelmente n√£o √©\n"
"o que `format!` retorna. Se quis√©ssemos fazer o mesmo atrav√©s da sintaxe `: Display`, "
"precisar√≠amos de dois\n"
"par√¢metros gen√©ricos independentes.\n"
"    \n"
"</details>"

#: src/traits/important-traits.md:1
msgid "# Important Traits"
msgstr "# Traits importantes"

#: src/traits/important-traits.md:3
msgid "We will now look at some of the most common traits of the Rust standard library:"
msgstr "Veremos agora os _Traits_ mais comuns da biblioteca padr√£o do Rust:"

#: src/traits/important-traits.md:5
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* [`Iterator`][1] e [`IntoIterator`][2] usados em la√ßos `for`,\n"
"* [`From`][3] e [`Into`][4] usados na conver√ß√£o de valores,\n"
"* [`Read`][5] e [`Write`][6] usados em opera√ß√µes de IO,\n"
"* [`Add`][7], [`Mul`][8], ... usado na sobrecarga de operadores,\n"
"* [`Drop`][9] usado para definir destrutores e\n"
"* [`Default`][10] usado para construir uma inst√¢ncia padr√£o para um tipo."

#: src/traits/iterator.md:1
msgid "# Iterators"
msgstr "# Iteradores"

#: src/traits/iterator.md:3
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "Voc√™ pode implementar o _trait_ `Iterator` em seus pr√≥prios tipos:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator for Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
msgid ""
"* The `Iterator` trait implements many common functional programming operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can find all the "
"documentation\n"
"  about them. In Rust these functions should produce the code as efficient as equivalent "
"imperative\n"
"  implementations.\n"
"    \n"
"* `IntoIterator` is the trait that makes for loops work. It is implemented by collection types "
"such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also implement it. This is "
"why\n"
"  you can iterate over a vector with `for i in some_vec { .. }` but\n"
"  `some_vec.next()` doesn't exist."
msgstr ""

#: src/traits/from-iterator.md:1
msgid "# FromIterator"
msgstr "# FromIterator"

#: src/traits/from-iterator.md:3
msgid "[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr "`FromIterator` permite construir uma cole√ß√£o a partir de um `Iterator`."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"`Iterator` implementa\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"

#: src/traits/from-iterator.md:23
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Tamb√©m existem implementa√ß√µes que permitem fazer coisas legais como converter um\n"
"`Iterator<Item = Result<V, E>>` em um `Result<Vec<V>, E>`."

#: src/traits/from-into.md:1
msgid "# `From` and `Into`"
msgstr "# `From` e `Into`"

#: src/traits/from-into.md:3
msgid "Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr "Os tipos implementam `From` e `Into` para facilitar as convers√µes de tipo:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"Ol√°\");\n"
"    let endereco_ipv4 = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let um = i16::from(true);\n"
"    let maior = i32::from(123i16);\n"
"    println!(\"{s}, {endereco_ipv4}, {um}, {maior}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:15
msgid "[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr "[`Into`][2] √© implementado automaticamente quando [`From`][1] √© implementado:"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"Ol√°\".into();\n"
"    let endereco_ipv4: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let um: i16 = true.into();\n"
"    let maior: i32 = 123i16.into();\n"
"    println!(\"{s}, {endereco_ipv4}, {um}, {maior}\");\n"
"}\n"
"```"

#: src/traits/from-into.md:29
#, fuzzy
msgid ""
"* That's why it is common to only implement `From`, as your type will get `Into` implementation "
"too.\n"
"* When declaring a function argument input type like \"anything that can be converted into a "
"`String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that _only_ implement `Into`.\n"
"    "
msgstr ""
"<details>\n"
"  \n"
"* √â por isso que √© comum implementar apenas `From`, j√° que seu tipo tamb√©m receber√° a "
"implementa√ß√£o de `Into`.\n"
"* Ao declarar um tipo de entrada de argumento de fun√ß√£o como \"qualquer coisa que possa ser "
"convertida em `String`\", a regra √© oposta, voc√™ deve usar `Into`.\n"
"  Sua fun√ß√£o aceitar√° tipos que implementam `From` e aqueles que _apenas_ implementam `Into`.\n"
"    \n"
"</details>"

#: src/traits/read-write.md:1
msgid "# `Read` and `Write`"
msgstr "# `Read` e `Write`"

#: src/traits/read-write.md:3
msgid "Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "Usando `Read` e `BufRead`, voc√™ pode abstrair a leitura de conte√∫dos do tipo `u8`:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "Da mesma forma, `Write` permite abstrair a escrita de dados do tipo `u8`:"

#: src/traits/read-write.md:25
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Ol√°\")?;\n"
"    log(&mut buffer, \"Mundo\")?;\n"
"    println!(\"Logado: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"

#: src/traits/drop.md:1
msgid "# The `Drop` Trait"
msgstr "# O Trait `Drop`"

#: src/traits/drop.md:3
msgid "Values which implement [`Drop`][1] can specify code to run when they go out of scope:"
msgstr ""
"Valores que implementam [`Drop`][1] podem especificar o c√≥digo a ser executado quando saem do "
"escopo:"

#: src/traits/drop.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let a = Excluivel { nome: \"a\" };\n"
"    {\n"
"        let b = Excluivel { nome: \"b\" };\n"
"        {\n"
"            let c = Excluivel { nome: \"c\" };\n"
"            let d = Excluivel { nome: \"d\" };\n"
"            println!(\"Saindo do bloco B\");\n"
"        }\n"
"        println!(\"Saindo do bloco A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Saindo do main\");\n"
"}\n"
"```"

#: src/traits/drop.md:34 src/traits/operators.md:26
msgid "Discussion points:"
msgstr "Pontos de discuss√£o:"

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"* Why doesn't `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* Por que `Drop::drop` n√£o recebe `self`?\n"
"    * Resposta curta: Se recebesse, `std::mem::drop` seria chamado no final do\n"
"        bloco, resultando em outra chamada para `Drop::drop` ocasionando um estouro de pilha.\n"
"* Tente substituir `drop(a)` por `a.drop()`."

#: src/traits/default.md:1
msgid "# The `Default` Trait"
msgstr "# O Trait `Default`"

#: src/traits/default.md:3
#, fuzzy
msgid "[`Default`][1] trait produces a default value for a type."
msgstr "O `trait` [`Default`][1] fornece uma implementa√ß√£o padr√£o para um `trait`."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/traits/default.md:40
msgid ""
"  * It can be implemented directly or it can be derived via `#[derive(Default)]`.\n"
"  * Derived implementation will produce an instance where all fields are set to their default "
"values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values (e.g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and provides convenience "
"methods that use it."
msgstr ""
"  * Ele pode ser implementado diretamente ou derivado usando `#[derive(Default)]`.\n"
"  * A implementa√ß√£o usando `derive` produz uma inst√¢ncia onde todos os campos s√£o preenchidos\n"
" com seus valores padr√£o.\n"
"    * Consequentemente, todos os tipos usados na estrutuda devem implementar `Default` tamb√©m.\n"
"  * Frequentemente, os tipos padr√£o do Rust implementam `Default` com valores razo√°veis (ex: `0`, "
"`\"\"`, etc).\n"
"  * A c√≥pia parcial de estrututas funciona bem em conjunto com _default_.\n"
"  * A bilioteca padr√£o do Rust sabe que tipos podem implementar o `trait` `Default` e, "
"convenientemente,\n"
" prov√™ m√©todos para isso."

#: src/traits/operators.md:1
msgid "# `Add`, `Mul`, ..."
msgstr "# `Add`, `Mul`, ..."

#: src/traits/operators.md:3
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr "A sobrecarga de operadores √© implementada por meio do `trait` contido em [`std::ops`][1]:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter of the method?\n"
"    * Short answer: Function type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor of a\n"
"        trait.\n"
"* You could implement `Add` for two different types, e.g.\n"
"  `impl Add<(i32, i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"* Voc√™ pode implementar `Add` para `&Ponto`. Em quais situa√ß√µes isso √© √∫til?\n"
"    * Resposta: `Add:add` consome `self`. Se digitar `T` para o qual voc√™ est√°\n"
"        sobrecarregando o operador n√£o implementa `Copy`, voc√™ deve considerar sobrecarregar\n"
"        o operador para `&T` tamb√©m. Isso evita a clonagem desnecess√°ria no\n"
"        local da chamada.\n"
"* Por que `Output` √© um tipo associado? Poderia ser feito um par√¢metro de tipo?\n"
"    * Resposta curta: os par√¢metros de tipo s√£o controlados pelo chamador, mas\n"
"        tipos associados (como `Output`) s√£o controlados pelo implementador do\n"
"        `trait`."

#: src/traits/closures.md:1
msgid "# Closures"
msgstr "# Closures"

#: src/traits/closures.md:3
msgid ""
"Closures or lambda expressions have types which cannot be named. However, they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Closures ou express√µes _lambda_ t√™m tipos que n√£o podem ser nomeados. No entanto, eles\n"
"implementam os _traits_ especiais [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) e\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html):"

#: src/traits/closures.md:8
#, fuzzy
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;\n"
"\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn aplicar_com_registro(funcao: impl FnOnce(i32) -> i32, entrada: i32) -> i32 {\n"
"    println!(\"Chamando a fun√ß√£o com {entrada}\");\n"
"    funcao(entrada)\n"
"}"

#: src/traits/closures.md:25
msgid "If you have an `FnOnce`, you may only call it once. It might consume captured values."
msgstr ""
"Se voc√™ tiver um `FnOnce`, poder√° cham√°-lo apenas uma vez. Pode consumir os valores capturados."

#: src/traits/closures.md:27
msgid ""
"An `FnMut` might mutate captured values, so you can call it multiple times but not concurrently."
msgstr ""
"Um `FnMut` pode alterar os valores capturados, ent√£o voc√™ pode cham√°-lo v√°rias vezes, mas n√£o "
"simultaneamente."

#: src/traits/closures.md:29
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures nothing at all, so it "
"can\n"
"be called multiple times concurrently."
msgstr ""
"Um `Fn` n√£o consome nem muda os valores capturados ou talvez n√£o capture nada, ent√£o, pode\n"
"ser chamado v√°rias vezes simultaneamente."

#: src/traits/closures.md:32
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever an `FnMut` or "
"`FnOnce`\n"
"is called for."
msgstr ""
"`FnMut` √© um subtipo de `FnOnce`. `Fn` √© um subtipo de `FnMut` e `FnOnce`. Ou seja voc√™ pode usar "
"um\n"
"`FnMut` sempre que um `FnOnce` √© chamado e voc√™ pode usar um `Fn` sempre que um `FnMut` ou um "
"`FnOnce`\n"
"√© chamado."

#: src/traits/closures.md:36
msgid "`move` closures only implement `FnOnce`."
msgstr "_Closures_ `move` implementam apenas `FnOnce`."

#: src/exercises/day-3/morning.md:1
msgid "# Day 3: Morning Exercises"
msgstr "# Dia 3: Exerc√≠cios matinais"

#: src/exercises/day-3/morning.md:3
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Vamos projetar uma biblioteca cl√°ssica de _traits_ de GUI e objetos de `trait`."

#: src/exercises/day-3/simple-gui.md:1
msgid "# A Simple GUI Library"
msgstr "# Uma biblioteca GUI simples"

#: src/exercises/day-3/simple-gui.md:3
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"Vamos projetar uma biblioteca GUI cl√°ssica usando nosso novo conhecimento de _traits_ e\n"
"objetos de `trait`."

#: src/exercises/day-3/simple-gui.md:6
msgid "We will have a number of widgets in our library:"
msgstr "Teremos v√°rios _widgets_ em nossa biblioteca:"

#: src/exercises/day-3/simple-gui.md:8
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Window`: tem um `t√≠tulo` e cont√©m outros _widgets_.\n"
"* `Button`: tem um `r√≥tulo` e uma fun√ß√£o de _callback_ que √© invocada quando o\n"
"  bot√£o √© pressionado.\n"
"* `Label`: tem um `r√≥tulo`."

#: src/exercises/day-3/simple-gui.md:13
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "Os _widgets_ ir√£o implementar o `trait` `Widget`, veja abaixo."

#: src/exercises/day-3/simple-gui.md:15
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/>, codifique os\n"
"m√©todos `draw_into` para que voc√™ implemente o `trait` `Widget`:"

#: src/exercises/day-3/simple-gui.md:18
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
msgid "The output of the above program can be something simple like this:"
msgstr "A sa√≠da do programa acima pode ser algo simples como:"

#: src/exercises/day-3/simple-gui.md:132
#, fuzzy
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========\n"
"\n"
"This is a small text GUI demo.\n"
"\n"
"| Click me! |\n"
"```"
msgstr ""
"```texto\n"
"========\n"
"Demonstra√ß√£o da GUI do Rust 1.23\n"
"========"

#: src/exercises/day-3/simple-gui.md:142
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"Se voc√™ quiser desenhar texto alinhado, voc√™ pode usar os\n"
"operadores de formata√ß√£o [fill/alignment](https://doc.rust-lang.org/std/fmt/index."
"html#fillalignment).\n"
"Em particular, observe como voc√™ pode preencher com diferentes\n"
"caracteres (aqui um `'/'`) e como voc√™ pode controlar o alinhamento:"

#: src/exercises/day-3/simple-gui.md:147
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""
"```rust, editable\n"
"fn main() {\n"
"    let largura = 10;\n"
"    println!(\"alinhado √† esquerda: |{:/<largura$}|\", \"foo\");\n"
"    println!(\"centralizado: |{:/^largura$}|\", \"foo\");\n"
"    println!(\"alinhado √† direita: |{:/>largura$}|\", \"foo\");\n"
"}\n"
"```"

#: src/exercises/day-3/simple-gui.md:156
msgid "Using such alignment tricks, you can for example produce output like this:"
msgstr "Usando esses truques de alinhamento, voc√™ pode, por exemplo, produzir uma sa√≠da como esta:"

#: src/exercises/day-3/simple-gui.md:158
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""
"```texto\n"
"+--------------------------------------------------+\n"
"|            Rust GUI Demonstra√ß√£o 1.23            |\n"
"+==================================================+\n"
"| Esta √© uma pequena demonstra√ß√£o de GUI de texto. |\n"
"| +----------------+                               |\n"
"| |   Clique-me!   |                               |\n"
"| +----------------+                               |\n"
"+--------------------------------------------------+\n"
"```"

#: src/error-handling.md:1
msgid "# Error Handling"
msgstr "# Tratamento de Erros"

#: src/error-handling.md:3
msgid "Error handling in Rust is done using explicit control flow:"
msgstr "O tratamento de erros em Rust √© feito usando fluxo de controle expl√≠cito:"

#: src/error-handling.md:5
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* Fun√ß√µes que podem ter erros mostram isso em seu tipo de retorno.\n"
"* N√£o h√° exce√ß√µes (_exceptions_)."

#: src/error-handling/panics.md:1
msgid "# Panics"
msgstr "# _Panics_ (P√¢nicos)"

#: src/error-handling/panics.md:3
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "O Rust ir√° disparar um _panic_ (p√¢nico) se um erro fatal ocorrer em tempo de execu√ß√£o:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"

#: src/error-handling/panics.md:12
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* _P√¢nicos_ s√£o para erros irrecuper√°veis e inesperados.\n"
"  * P√¢nicos s√£o sintomas de bugs no programa.\n"
"* Use APIs que n√£o disparam erros do tipo _p√¢nico_ (como `Vec::get`) se n√£o for "
"aceit√°vel o travamento do programa."

#: src/error-handling/panic-unwind.md:1
msgid "# Catching the Stack Unwinding"
msgstr "# Capturando a _Resolu√ß√£o_ da Pilha (_Stack Unwinding_)"

#: src/error-handling/panic-unwind.md:3
msgid "By default, a panic will cause the stack to unwind. The unwinding can be caught:"
msgstr "Por padr√£o, um p√¢nico causar√° a _resolu√ß√£o_ da pilha. A resolu√ß√£o pode ser capturada:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {\n"
"        println!(\"hello!\");\n"
"    });\n"
"    assert!(result.is_ok());\n"
"    \n"
"    let result = panic::catch_unwind(|| {\n"
"        panic!(\"oh no!\");\n"
"    });\n"
"    assert!(result.is_err());\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {\n"
"        println!(\"ol√°!\");\n"
"    });\n"
"    assert!(result.is_ok());\n"
"    \n"
"    let result = panic::catch_unwind(|| {\n"
"        panic!(\"ah n√£o!\");\n"
"    });\n"
"    assert!(result.is_err());\n"
"}\n"
"```"

#: src/error-handling/panic-unwind.md:21
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* Isso pode ser √∫til em servidores que devem continuar rodando mesmo se uma\n"
"  requisi√ß√£o tenha falhado.\n"
"* Isso n√£o funciona se `panic = 'abort'` estiver definido em seu `Cargo.toml`."

#: src/error-handling/result.md:1
msgid "# Structured Error Handling with `Result`"
msgstr "# Tratamento Estruturado de Erros com `Result`"

#: src/error-handling/result.md:3
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors are\n"
"expected as part of normal operation:"
msgstr ""
"J√° vimos o _enum_ `Result`. Ele √© usado amplamente quando os erros s√£o\n"
"esperados como parte da opera√ß√£o normal:"

#: src/error-handling/result.md:6
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = fs::File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let arquivo = fs::File::open(\"diario.txt\");\n"
"    match arquivo {\n"
"        Ok(mut arquivo) => {\n"
"            let mut conteudo = String::new();\n"
"            arquivo.read_to_string(&mut conteudo);\n"
"            println!(\"Querido di√°rio: {conteudo}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"N√£o foi poss√≠vel abrir o di√°rio: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/result.md:27
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where an error should never "
"happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but it is worth "
"mentioning. \n"
"    It contains a lot of convenience methods and functions that help functional-style "
"programming. \n"
"    "
msgstr ""
"  * Como em `Option`, o valor bem-sucedido fica dentro de `Result`, for√ßando o desenvolvedor a\n"
"    extra√≠-lo explicitamente. Isso encoraja a verifica√ß√£o de erros. No caso em que um erro nunca "
"deve acontecer,\n"
"    `unwrap()` ou `expect()` podem ser chamados, e isso tamb√©m sinaliza a inten√ß√£o do desenvolvedor.\n"
"  * A documenta√ß√£o de `Result` √© uma leitura recomendada. N√£o durante o curso, mas vale a pena "
"mencion√°-la.\n"
"    Ele cont√©m muitos m√©todos e fun√ß√µes de conveni√™ncia que ajudam na programa√ß√£o ao estilo "
"funcional.\n"
"    "

#: src/error-handling/try-operator.md:1
msgid "# Propagating Errors with `?`"
msgstr "# Propagando Erros com `?`"

#: src/error-handling/try-operator.md:3
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you turn\n"
"the common"
msgstr ""
"O operador _try_ `?` √© usado para retornar erros ao chamador da fun√ß√£o.\n"
"Se ocorrer um erro, este √© retornado imediatamente ao chamador como retorno da fun√ß√£o."

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""
"```rust, ignore\n"
"match alguma_expressao {\n"
"    Ok(valor) => valor,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:13
msgid "into the much simpler"
msgstr "O c√≥digo acima pode ser simplificado para:"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""
"```rust, ignore\n"
"alguma_expressao?\n"
"```"

#: src/error-handling/try-operator.md:19
msgid "We can use this to simplify our error handling code:"
msgstr "Podemos usar isso para simplificar nosso c√≥digo de tratamento de erros:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn ler_usuario(caminho: &str) -> Result<String, io::Error> {\n"
"    let resultado_arq_usuario = fs::File::open(caminho);\n"
"    let mut arquivo_usuario = match resultado_arq_usuario {\n"
"        Ok(arquivo) => arquivo,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut nome_usuario = String::new();\n"
"    match arquivo_usuario.read_to_string(&mut nome_usuario) {\n"
"        Ok(_) => Ok(nome_usuario),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let nome_usuario = ler_usuario(\"config.dat\");\n"
"    println!(\"nome_usuario ou erro: {nome_usuario:?}\");\n"
"}\n"
"```"

#: src/error-handling/try-operator.md:50 src/error-handling/converting-error-types-example.md:52
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, empty file, file with "
"username."
msgstr ""
"* A vari√°vel `nome_usuario` pode ser `Ok(string)` ou `Err(error)`.\n"
"* Use a chamada `fs::write` para testar os diferentes cen√°rios: nenhum arquivo, arquivo vazio e "
"arquivo com nome de usu√°rio."

#: src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
msgid "# Converting Error Types"
msgstr "# Convertendo Tipos de Erro"

#: src/error-handling/converting-error-types.md:3
msgid "The effective expansion of `?` is a little more complicated than previously indicated:"
msgstr "A expans√£o efetiva do operador `?` √© um pouco mais complicada do que indicado anteriormente:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""
"```rust,ignore\n"
"expressao?\n"
"```"

#: src/error-handling/converting-error-types.md:9
msgid "works the same as"
msgstr "funciona da mesma forma que"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"match expressao {\n"
"    Ok(valor) => valor,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"

#: src/error-handling/converting-error-types.md:18
msgid ""
"The `From::from` call here means we attempt to convert the error type to the\n"
"type returned by the function:"
msgstr ""
"A chamada `From::from` aqui significa que tentamos converter o tipo de erro para o\n"
"tipo retornado pela fun√ß√£o:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error for ReadUsernameError {}\n"
"\n"
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username in {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum LerNomeUsuarioErro {\n"
"    ErroEs(io::Error),\n"
"    NomeUsuarioVazio(String),\n"
"}\n"
"\n"
"impl Error for LerNomeUsuarioErro {}\n"
"\n"
"impl Display for LerNomeUsuarioErro {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::ErroEs(e) => write!(f, \"Erro E/S: {e}\"),\n"
"            Self::NomeUsuarioVazio(nome_arquivo) => write!(f, \"Nome de usu√°rio n√£o encontrado em {nome_arquivo}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for LerNomeUsuarioErro {\n"
"    fn from(err: io::Error) -> LerNomeUsuarioErro {\n"
"        LerNomeUsuarioErro::ErroEs(err)\n"
"    }\n"
"}\n"
"\n"
"fn ler_nome_usuario(caminho: &str) -> Result<String, LerNomeUsuarioErro> {\n"
"    let mut nome_usuario = String::with_capacity(100);\n"
"    File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
"    if nome_usuario.is_empty() {\n"
"        return Err(LerNomeUsuarioErro::NomeUsuarioVazio(String::from(caminho)));\n"
"    }\n"
"    Ok(nome_usuario)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let nome_usuario = ler_nome_usuario(\"config.dat\");\n"
"    println!(\"nome_usuario ou erro: {nome_usuario:?}\");\n"
"}\n"
"```"

#: src/error-handling/converting-error-types-example.md:55
msgid ""
"It is good practice for all error types to implement `std::error::Error`, which requires `Debug` "
"and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too where possible, to "
"make\n"
"life easier for tests and consumers of your library. In this case we can't easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"√â uma boa pr√°tica para todos os tipos de erro implementar `std::error::Error`, que requer `Debug` "
"e\n"
"`Display`. Geralmente √© √∫til para eles implementar `Clone` e `Eq` tamb√©m quando poss√≠vel, para "
"tornar\n"
"mais f√°cil a vida para testes e consumidores da sua biblioteca. Neste caso, n√£o podemos faz√™-lo "
"facilmente, porque\n"
"`io::Error` n√£o os implementa."

#: src/error-handling/deriving-error-enums.md:1
msgid "# Deriving Error Enums"
msgstr "# Derivando _Enums_ de Erro"

#: src/error-handling/deriving-error-enums.md:3
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create an\n"
"error enum like we did on the previous page:"
msgstr ""
"O _crate_ [thiserror](https://docs.rs/thiserror/) √© uma maneira popular de criar um\n"
"tipo enumerado (_enum_) de erro, como fizemos na p√°gina anterior:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum LerNomeUsuarioErro {\n"
"    #[error(\"N√£o √© possivel ler: {0}\")]\n"
"    ErroES(#[from] io::Error),\n"
"    #[error(\"Nome de usu√°rio n√£o encontrado em {0}\")]\n"
"    NomeUsuarioVazio(String),\n"
"}\n"
"\n"
"fn ler_nome_usuario(caminho: &str) -> Result<String, LerNomeUsuarioErro> {\n"
"    let mut nome_usuario = String::new();\n"
"    fs::File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
"    if nome_usuario.is_empty() {\n"
"        return Err(LerNomeUsuarioErro::NomeUsuarioVazio(String::from(caminho)));\n"
"    }\n"
"    Ok(nome_usuario)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match ler_nome_usuario(\"config.dat\") {\n"
"        Ok(nome_usuario) => println!(\"Nome do usu√°rio: {nome_usuario}\"),\n"
"        Err(err)     => println!(\"Erro: {err}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/deriving-error-enums.md:39
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the `#[from]` attribute is "
"added).\n"
"It also works for structs."
msgstr ""
"A _derive macro_ `thiserror` implementa automaticamente `std::error::Error`, e opcionalmente, `Display`\n"
"(se os atributos `#[error(...)]` forem fornecidos) e `From` (se o atributo `#[from]` for "
"adicionado).\n"
"Tamb√©m funciona para _structs_."

#: src/error-handling/deriving-error-enums.md:43
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "N√£o afeta sua API p√∫blica, o que a torna boa para bibliotecas."

#: src/error-handling/dynamic-errors.md:1
msgid "# Dynamic Error Types"
msgstr "# Tipos de Erros Din√¢micos"

#: src/error-handling/dynamic-errors.md:3
msgid ""
"Sometimes we want to allow any type of error to be returned without writing our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"√Äs vezes, queremos permitir que qualquer tipo de erro seja retornado sem escrever nosso pr√≥prio "
"`Enum`\n"
"abrangendo todas as diferentes possibilidades. `std::error::Error` torna isso f√°cil."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Nome de usu√°rio n√£o encontrado em {0}\")]\n"
"struct NomeUsuarioVazioErro(String);\n"
"\n"
"fn ler_nome_usuario(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut nome_usuario = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut nome_usuario)?;\n"
"    if nome_usuario.is_empty() {\n"
"        return Err(NomeUsuarioVazioErro(String::from(path)).into());\n"
"    }\n"
"    Ok(nome_usuario)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match ler_nome_usuario(\"config.dat\") {\n"
"        Ok(nome_usuario) => println!(\"nome_usuario: {nome_usuario}\"),\n"
"        Err(err)     => println!(\"Erro: {err}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/dynamic-errors.md:36
msgid ""
"This saves on code, but gives up the ability to cleanly handle different error cases differently "
"in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` in the public API of "
"a\n"
"library, but it can be a good option in a program where you just want to display the error "
"message\n"
"somewhere."
msgstr ""
"Isso economiza c√≥digo, mas abre m√£o da capacidade de lidar com diferentes casos de erro de maneira "
"diferenciada no\n"
"programa. Como tal, geralmente n√£o √© uma boa ideia usar `Box<dyn Error>` na API p√∫blica de uma\n"
"biblioteca, mas pode ser uma boa op√ß√£o em um programa onde voc√™ deseja apenas exibir a mensagem de "
"erro\n"
"em algum lugar."

#: src/error-handling/error-contexts.md:1
msgid "# Adding Context to Errors"
msgstr "# Adicionando Contexto a Erros"

#: src/error-handling/error-contexts.md:3
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"O `crate` [anyhow](https://docs.rs/anyhow/) √© amplamente usado e pode lhe ajudar a adicionar\n"
"informa√ß√µes contextuais aos seus erros, permitindo que voc√™ tenha menos\n"
"tipos de erros personalizados:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn ler_nome_usuario(caminho: &str) -> Result<String> {\n"
"    let mut nome_usuario = String::with_capacity(100);\n"
"    fs::File::open(caminho)\n"
"        .with_context(|| format!(\"Falha ao abrir {caminho}\"))?\n"
"        .read_to_string(&mut nome_usuario)\n"
"        .context(\"Falha ao ler\")?;\n"
"    if nome_usuario.is_empty() {\n"
"        bail!(\"Nome de usu√°rio n√£o encontrado em {caminho}\");\n"
"    }\n"
"    Ok(nome_usuario)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match ler_nome_usuario(\"config.dat\") {\n"
"        Ok(nome_usuario) => println!(\"nome_usuario: {nome_usuario}\"),\n"
"        Err(err)     => println!(\"Erro: {err:?}\"),\n"
"    }\n"
"}\n"
"```"

#: src/error-handling/error-contexts.md:35
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such it's again generally "
"not\n"
"  a good choice for the public API of a library, but is widely used in applications.\n"
"* Actual error type inside of it can be extracted for examination if necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* `anyhow::Result<V>` √© um apelido de tipo para `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` √© essencialmente um wrapper em torno de `Box<dyn Error>`. Como tal, geralmente "
"n√£o √©\n"
"  uma boa escolha para a API p√∫blica de uma biblioteca, mas √© amplamente utilizado em aplica√ß√µes.\n"
"* O tipo de erro real dentro dele pode ser extra√≠do para exame, se necess√°rio.\n"
"* A funcionalidade fornecida por `anyhow::Result<T>` pode ser familiar para desenvolvedores Go, "
"pois fornece\n"
"  padr√µes de uso e ergonomia semelhantes a `(T, error)` de Go."

#: src/testing.md:1
msgid "# Testing"
msgstr "# Teste"

#: src/testing.md:3
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust e Cargo v√™m com uma estrutura de testes unit√°rios simples:"

#: src/testing.md:5
msgid ""
"* Unit tests are supported throughout your code.\n"
"\n"
"* Integration tests are supported via the `tests/` directory."
msgstr ""
"* Testes unit√°rios s√£o suportados em todo o seu c√≥digo.\n"
"\n"
"* Testes de integra√ß√£o s√£o suportados atrav√©s do diret√≥rio `tests/`."

#: src/testing/unit-tests.md:1
msgid "# Unit Tests"
msgstr "# Testes Unit√°rios"

#: src/testing/unit-tests.md:3
msgid "Mark unit tests with `#[test]`:"
msgstr "Marque os testes unit√°rios com `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable,ignore\n"
"fn primeira_palavra(texto: &str) -> &str {\n"
"    match texto.find(' ') {\n"
"        Some(idx) => &texto[..idx],\n"
"        None => &texto,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_vazio() {\n"
"    assert_eq!(primeira_palavra(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_palavra_unica() {\n"
"    assert_eq!(primeira_palavra(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn teste_palavras_multiplas() {\n"
"    assert_eq!(primeira_palavra(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"

#: src/testing/unit-tests.md:29
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Use `cargo test` para encontrar e executar os testes unit√°rios."

#: src/testing/test-modules.md:1
msgid "# Test Modules"
msgstr "# M√≥dulos de Teste"

#: src/testing/test-modules.md:3
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"Testes unit√°rios geralmente s√£o colocados em um m√≥dulo aninhado (execute testes no\n"
"[Playground](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn auxiliar(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", auxiliar(\"Ol√°\", \"Mundo\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn teste_auxiliar() {\n"
"        assert_eq!(auxiliar(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"

#: src/testing/test-modules.md:26
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* Isso permite que voc√™ tenha testes unit√°rios auxiliares privados.\n"
"* O atributo `#[cfg(test)]` somente fica ativo quando voc√™ executa `cargo test`."

#: src/testing/doc-tests.md:1
msgid "# Documentation Tests"
msgstr "# Testes de Documenta√ß√£o"

#: src/testing/doc-tests.md:3
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust tem suporte embutido para testes de documenta√ß√£o:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// Encurta uma string para o comprimento especificado.\n"
"///\n"
"/// ```\n"
"/// use playground::encurtar_string;\n"
"/// assert_eq!(encurtar_string(\"Ol√° Mundo\", 4), \"Ol√°\");\n"
"/// assert_eq!(encurtar_string(\"Ol√° Mundo\", 20), \"Ol√° Mundo\");\n"
"/// ```\n"
"pub fn encurtar_string(s: &str, comprimento: usize) -> &str {\n"
"    &s[..std::cmp::min(comprimento, s.len())]\n"
"}\n"
"```"

#: src/testing/doc-tests.md:18
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* Blocos de c√≥digo em coment√°rios `///` s√£o vistos automaticamente como c√≥digo Rust.\n"
"* O c√≥digo ser√° compilado e executado como parte do `cargo test`.\n"
"* Teste o c√≥digo acima no [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:1
msgid "# Integration Tests"
msgstr "# Testes de Integra√ß√£o"

#: src/testing/integration-tests.md:3
msgid "If you want to test your library as a client, use an integration test."
msgstr "Se quiser testar sua biblioteca como um cliente, use um teste de integra√ß√£o."

#: src/testing/integration-tests.md:5
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crie um arquivo `.rs` em `tests/`:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use minha_biblioteca::iniciar;\n"
"\n"
"#[test]\n"
"fn teste_iniciar() {\n"
"    assert!(iniciar().is_ok());\n"
"}\n"
"```"

#: src/testing/integration-tests.md:16
msgid "These tests only have access to the public API of your crate."
msgstr "Esses testes t√™m acesso somente √† API p√∫blica do seu `crate`."

#: src/testing/useful-crates.md:1
msgid "## Useful crates for writing tests"
msgstr "## _Crates_ √öteis para Escrever Testes"

#: src/testing/useful-crates.md:3
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust possui apenas suporte b√°sico para escrever testes."

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr "Estes s√£o alguns _crates_ adicionais que recomendamos para a escrita de testes:"

#: src/testing/useful-crates.md:7
msgid ""
"* [googletest](https://docs.rs/googletest): Comprehensive test assertion library in the tradition "
"of GoogleTest for C++.\n"
"* [proptest](https://docs.rs/proptest): Property-based testing for Rust.\n"
"* [rstest](https://docs.rs/rstest): Support for fixtures and parameterised tests."
msgstr ""
"* [googletest](https://docs.rs/googletest): Biblioteca abrangente para testes de assertividade na tradi√ß√£o "
"de GoogleTest para C++.\n"
"* [proptest](https://docs.rs/proptest): Testes baseados em propriedades para Rust.\n"
"* [rstest](https://docs.rs/rstest): Suporte para testes parametrizados e acess√≥rios."

#: src/unsafe.md:1
msgid "# Unsafe Rust"
msgstr "# Rust Inseguro (_Unsafe_)"

#: src/unsafe.md:3
msgid "The Rust language has two parts:"
msgstr "A linguagem Rust tem duas partes:"

#: src/unsafe.md:5
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are violated."
msgstr ""
"* **Rust Seguro (_Safe_):** mem√≥ria segura, nenhum comportamento indefinido √© poss√≠vel.\n"
"* **Rust Inseguro (_Unsafe_):** pode desencadear comportamento indefinido se pr√©-condi√ß√µes forem violadas."

#: src/unsafe.md:8
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to know\n"
"what Unsafe Rust is."
msgstr ""
"Veremos principalmente Rust seguro neste curso, mas √© importante saber\n"
"o que √© Rust inseguro (_unsafe_)."

#: src/unsafe.md:11
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"C√≥digo inseguro √© geralmente pequeno e isolado, e seu funcionamento correto deve ser cuidadosamente\n"
"documentado. Geralmente √© envolto em uma camada de abstra√ß√£o segura."

#: src/unsafe.md:14
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "O c√≥digo inseguro do Rust oferece acesso a cinco novos recursos:"

#: src/unsafe.md:16
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* Desreferenciar ponteiros brutos.\n"
"* Acessar ou modificar vari√°veis est√°ticas mut√°veis.\n"
"* Acessar os campos de uma `union`.\n"
"* Chamar fun√ß√µes inseguras (`unsafe`), incluindo fun√ß√µes `extern` (externas).\n"
"* Implementar _traits_ inseguros (`unsafe` traits)."

#: src/unsafe.md:22
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see\n"
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"A seguir, abordaremos brevemente os recursos inseguros. Para detalhes completos, consulte o\n"
"[Cap√≠tulo 19.1 no Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"e o [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety rules."
msgstr ""
"Rust inseguro n√£o significa que o c√≥digo esteja incorreto. Significa que os desenvolvedores\n"
"desligaram os recursos de seguran√ßa do compilador e precisam escrever o c√≥digo corretamente\n"
"por eles mesmos. Significa tamb√©m que o compilador n√£o imp√µe mais as regras de seguran√ßa de mem√≥ria do "
"Rust."

#: src/unsafe/raw-pointers.md:1
msgid "# Dereferencing Raw Pointers"
msgstr "# Desreferenciando Ponteiros Brutos (_Raw_)"

#: src/unsafe/raw-pointers.md:3
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "Criar ponteiros √© seguro, mas desreferenci√°-los requer `unsafe`:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Seguro porque r1 e r2 foram obtidos atrav√©s de refer√™ncias e logo √©\n"
"    // garantido que eles n√£o sejam nulos e sejam propriamente alinhados, os objetos\n"
"    // cujas refer√™ncias foram obtidas s√£o v√°lidos por\n"
"    // todo o bloco inseguro, e eles n√£o sejam acessados tanto atrav√©s das\n"
"    // refer√™ncias ou concorrentemente atrav√©s de outros ponteiros.\n"
"    unsafe {\n"
"        println!(\"r1 √©: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 √©: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/raw-pointers.md:27
msgid ""
"It is good practice (and required by the Android Rust style guide) to write a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"√â uma boa pr√°tica (e exigida pelo guia de estilo do Android Rust) escrever um coment√°rio para "
"cada\n"
"bloco `unsafe` explicando como o c√≥digo dentro dele satisfaz os requisitos de seguran√ßa para a\n"
"opera√ß√£o insegura que est√° fazendo."

#: src/unsafe/raw-pointers.md:31
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"No caso de desrefer√™ncia de ponteiros, isso significa que os ponteiros devem ser\n"
"[_v√°lidos_](https://doc.rust-lang.org/std/ptr/index.html#safety), ou seja:"

#: src/unsafe/raw-pointers.md:34
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * O ponteiro deve ser n√£o nulo.\n"
" * O ponteiro deve ser _desreferenci√°vel_ (dentro dos limites de um √∫nico objeto alocado).\n"
" * O objeto n√£o deve ter sido desalocado.\n"
" * N√£o deve haver acessos simult√¢neos √† mesma localiza√ß√£o.\n"
" * Se o ponteiro foi obtido lan√ßando uma refer√™ncia, o objeto subjacente deve estar v√°lido e "
"nenhuma\n"
"   refer√™ncia pode ser usada para acessar a mem√≥ria."

#: src/unsafe/raw-pointers.md:41
msgid "In most cases the pointer must also be properly aligned."
msgstr "Na maioria dos casos, o ponteiro tamb√©m deve estar alinhado corretamente."

#: src/unsafe/mutable-static-variables.md:1
msgid "# Mutable Static Variables"
msgstr "# Vari√°veis Est√°ticas Mut√°veis"

#: src/unsafe/mutable-static-variables.md:3
msgid "It is safe to read an immutable static variable:"
msgstr "√â seguro ler uma vari√°vel est√°tica imut√°vel:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"static OLA_MUNDO: &str = \"Ol√°, mundo!\";\n"
"\n"
"fn main() {\n"
"    println!(\"OLA_MUNDO: {OLA_MUNDO}\");\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr ""
"No entanto, como podem ocorrer corridas de dados, n√£o √© seguro ler e gravar dados em\n"
"vari√°veis est√°ticas mut√°veis:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"static mut CONTADOR: u32 = 0;\n"
"\n"
"fn adicionar_ao_contador(inc: u32) {\n"
"    unsafe { CONTADOR += inc; }  // Corrida de dados potencial!\n"
"}\n"
"\n"
"fn main() {\n"
"    adicionar_ao_contador(42);\n"
"\n"
"    unsafe { println!(\"CONTADOR: {CONTADOR}\"); }  // Corrida de dados potencial!\n"
"}\n"
"```"

#: src/unsafe/mutable-static-variables.md:32
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases where it might make "
"sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working with some C APIs."
msgstr ""
"Usar uma vari√°vel est√°tica mut√°vel geralmente √© uma m√° ideia, mas h√° alguns casos em que isso pode "
"fazer sentido,\n"
"tais como em c√≥digo `no_std` de baixo n√≠vel, como implementar um alocador de heap ou trabalhar com algumas "
"APIs C."

#: src/unsafe/unions.md:1
msgid "# Unions"
msgstr "# _Unions_ (Uni√µes)"

#: src/unsafe/unions.md:3
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "_Unions_ s√£o como _enums_, mas voc√™ mesmo precisa rastrear o campo ativo:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MinhaUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MinhaUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Comportamento indefinido!\n"
"}\n"
"```"

#: src/unsafe/unions.md:21
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally "
"needed\n"
"for interacting with C library APIs."
msgstr ""
"_Unions_ raramente s√£o necess√°rias no Rust, pois geralmente voc√™ pode usar um _enum_. Elas s√£o "
"ocasionalmente necess√°rias\n"
"para interagir com as APIs da biblioteca C."

#: src/unsafe/unions.md:24
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"Se voc√™ deseja apenas reinterpretar os bytes como um tipo diferente, voc√™ provavelmente deveria usar\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) ou um\n"
"wrapper seguro como o _crate_ [`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:1
msgid "# Calling Unsafe Functions"
msgstr "# Chamando Fun√ß√µes Inseguras"

#: src/unsafe/calling-unsafe-functions.md:3
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"Uma fun√ß√£o ou m√©todo pode ser marcado como `unsafe` se houver pr√©-condi√ß√µes extras que voc√™\n"
"deve respeitar para evitar comportamento indefinido:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";\n"
"\n"
"    // Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..7) }));\n"
"\n"
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";\n"
"\n"
"    // Seguro porque os √≠ndices est√£o na ordem correta, dentro dos limites da\n"
"    // slice da string, e contido dentro da sequ√™ncia UTF-8.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"contador de caracteres: {}\", contador_caracteres(unsafe { emojis.get_unchecked(0..7) }));\n"
"\n"
"    // N√£o manter o requerimento de codifica√ß√£o UTF-8 viola seguran√ßa de mem√≥ria!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"contador caracter: {}\", contador_caracteres(unsafe { emojis.get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn contador_caracteres(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:1
msgid "# Writing Unsafe Functions"
msgstr "# Escrevendo Fun√ß√µes Inseguras"

#: src/unsafe/writing-unsafe-functions.md:3
msgid ""
"You can mark your own functions as `unsafe` if they require particular conditions to avoid "
"undefined\n"
"behaviour."
msgstr ""
"Voc√™ pode marcar suas pr√≥prias fun√ß√µes como _inseguras_ (`unsafe`) se elas exigirem condi√ß√µes espec√≠ficas "
"para evitar\n"
"comportamentos indefinidos."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"/// Troca os valores apontadoes pelos ponteiros fornecidos.\n"
"///\n"
"/// # Seguran√ßa\n"
"///\n"
"/// Os ponteiros precisam ser v√°lidos e corretamente alinhados.\n"
"unsafe fn trocar(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Seguro porque ...\n"
"    unsafe {\n"
"        trocar(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"

#: src/unsafe/writing-unsafe-functions.md:33
msgid "We wouldn't actually use pointers for this because it can be done safely with references."
msgstr ""
"Na verdade, n√£o usar√≠amos ponteiros para essa opera√ß√£o porque isso pode ser feito com seguran√ßa usando "
"refer√™ncias."

#: src/unsafe/writing-unsafe-functions.md:35
msgid ""
"Note that unsafe code is allowed within an unsafe function without an `unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see what happens."
msgstr ""
"Observe que o c√≥digo _inseguro_ √© permitido dentro de uma fun√ß√£o _insegura_ sem o uso de um bloco "
"`unsafe`. Podemos\n"
"proibir isso com `#[deny(unsafe_op_in_unsafe_fn)]`. Tente adicion√°-lo e veja o que acontece."

#: src/unsafe/extern-functions.md:1
msgid "# Calling External Code"
msgstr "# Chamando C√≥digo Externo"

#: src/unsafe/extern-functions.md:3
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling\n"
"them is thus unsafe:"
msgstr ""
"Fun√ß√µes de outras linguagens podem violar as garantias do Rust. Logo, cham√°-las\n"
"√© inseguro:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(entrada: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Comportamento indefinido se abs se comportar mal.\n"
"        println!(\"Valor absoluto de -3 de acordo com C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/extern-functions.md:21
msgid ""
"This is usually only a problem for extern functions which do things with pointers which might\n"
"violate Rust's memory model, but in general any C function might have undefined behaviour under "
"any\n"
"arbitrary circumstances."
msgstr ""
"Normalmente isso √© apenas um problema para fun√ß√µes externas que fazem coisas com ponteiros que "
"podem\n"
"violar o modelo de mem√≥ria do Rust, mas em geral qualquer fun√ß√£o C pode ter comportamento "
"indefinido sob quaisquer\n"
"circunst√¢ncias arbitr√°rias."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"O `\"C\"` neste exemplo √© o ABI;\n"
"[outros ABIs tamb√©m est√£o dispon√≠veis](https://doc.rust-lang.org/reference/items/external-blocks."
"html)."

#: src/unsafe/unsafe-traits.md:1
msgid "# Implementing Unsafe Traits"
msgstr "# Implementando _Traits_ Inseguros"

#: src/unsafe/unsafe-traits.md:3
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"Assim como nas fun√ß√µes, voc√™ pode marcar um `trait` como `unsafe` se a implementa√ß√£o precisa "
"garantir\n"
"condi√ß√µes particulares para evitar comportamento indefinido."

#: src/unsafe/unsafe-traits.md:6
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Por exemplo, o _crate_ `zerocopy` tem um _trait_ inseguro que parece\n"
"[algo assim](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Seguran√ßa\n"
"/// O tipo precisa ter uma representa√ß√£o definida e nenhum preenchimento.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Seguro porque u32 possui uma representa√ß√£o definida e sem preenchimento.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"

#: src/unsafe/unsafe-traits.md:30
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Deve haver uma se√ß√£o `# Safety` no Rustdoc para o `trait` explicando os requisitos para\n"
"ser implementado com seguran√ßa."

#: src/unsafe/unsafe-traits.md:33
msgid "The actual safety section for `AsBytes` is rather longer and more complicated."
msgstr "Na verdade, a se√ß√£o de seguran√ßa para `AsBytes` √© bem mais longa e complicada."

#: src/unsafe/unsafe-traits.md:35
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "Os _traits_ integrados `Send` e `Sync` s√£o inseguros."

#: src/exercises/day-3/afternoon.md:1
msgid "# Day 3: Afternoon Exercises"
msgstr "# Dia 3: Exerc√≠cios da Tarde"

#: src/exercises/day-3/afternoon.md:3
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "Vamos construir um wrapper seguro para ler o conte√∫do do diret√≥rio!"

#: src/exercises/day-3/afternoon.md:5
msgid ""
"For this exercise, we suggest using a local dev environment instead\n"
"of the Playground. This will allow you to run your binary on your own "
"machine."
msgstr ""
"Para este exerc√≠cio, n√≥s sugerimos a utiliza√ßao de um ambiente de desenvolvimento local\n"
"ao inv√©s do _Playground_. Isto lhe permitir√° executar o bin√°rio na sua pr√≥pria m√°quina."

#: src/exercises/day-3/afternoon.md:8
msgid "To get started, follow the [running locally] instructions."
msgstr "Para come√ßar, siga as instru√ßoes para [rodar localmente][running locally]."

#: src/exercises/day-3/afternoon.md:14
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "Depois de ver o exerc√≠cio, voc√™ pode ver a [solu√ß√£o][solution] fornecida."

#: src/exercises/day-3/safe-ffi-wrapper.md:1
msgid "# Safe FFI Wrapper"
msgstr "# _Wrapper_ FFI Seguro"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust tem √≥timo suporte para chamar fun√ß√µes por meio de uma interface para fun√ß√µes externas "
"(_Function Foreign\n"
"Interface_ - FFI). Usaremos isso para construir um _wrapper_ (inv√≥lucro) seguro para as fun√ß√µes da `libc`\n"
"de C que voc√™ usaria para ler os nomes dos arquivos de um diret√≥rio."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
msgid "You will want to consult the manual pages:"
msgstr "Voc√™ vai querer consultar as p√°ginas do manual:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
msgid ""
"You will also want to browse the [`std::ffi`] module. There you find a number of\n"
"string types which you need for the exercise:"
msgstr ""
"Voc√™ tamb√©m vai querer navegar pelo m√≥dulo [`std::ffi`]. L√° voc√™ encontrar√° um n√∫mero de\n"
"tipos de string que voc√™ precisar√° para o exerc√≠cio:"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid ""
"| Types                      | Encoding       | Use                            |\n"
"|----------------------------|----------------|--------------------------------|\n"
"| [`str`] and [`String`]     | UTF-8          | Text processing in Rust        |\n"
"| [`CStr`] and [`CString`]   | NUL-terminated | Communicating with C functions |\n"
"| [`OsStr`] and [`OsString`] | OS-specific    | Communicating with the OS      |"
msgstr ""
"| Tipos                      | Codifica√ß√£o      | Uso                            |\n"
"|----------------------------|------------------|--------------------------------|\n"
"| [`str`] e [`String`]       | UTF-8            | Processamento de texto em Rust |\n"
"| [`CStr`] e [`CString`]     | terminado em NUL | Comunica√ß√£o com fun√ß√µes em C   |\n"
"| [`OsStr`] e [`OsString`]   | espec√≠fico ao SO | Comunica√ß√£o com o SO           |"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
msgid "You will convert between all these types:"
msgstr "Voc√™ ir√° converter entre todos estes tipos:"

#: src/exercises/day-3/safe-ffi-wrapper.md:24
msgid ""
"- `&str` to `CString`: you need to allocate space for a trailing `\\0` character,\n"
"- `CString` to `*const i8`: you need a pointer to call C functions,\n"
"- `*const i8` to `&CStr`: you need something which can find the trailing `\\0` character,\n"
"- `&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some unknow data\",\n"
"- `&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use\n"
"  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html)\n"
"  to create it,\n"
"- `&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to return it and call\n"
"  `readdir` again."
msgstr ""
"- `&str` para `CString`: voc√™ precisa alocar espa√ßo para o caracter terminador `\\0`,\n"
"- `CString` para `*const i8`: voc√™ precisa de um ponteiro para chamar fun√ß√µes em C,\n"
"- `*const i8` para `&CStr`: voc√™ voc√™ precisa de algo que pode encontrar o caracter terminador `\\0`,\n"
"- `&CStr` para `&[u8]`: um _slice_ de bytes √© a interface universal para \"algum dado desconhecido\",\n"
"- `&[u8]` para `&OsStr`: `&OsStr` √© um passo em dire√ß√£o a `OsString`, use\n"
"  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html)\n"
"  para cri√°-lo,\n"
"- `&OsStr` para `OsString`: voc√™ precisa clonar os dados em `&OsStr` para poder retorn√°-lo e chamar\n"
"  `readdir` novamente."

#: src/exercises/day-3/safe-ffi-wrapper.md:34
msgid "The [Nomicon] also has a very useful chapter about FFI."
msgstr "O [Nomicon] tamb√©m tem um cap√≠tulo bastante √∫til sobre FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:45
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"functions and methods:"
msgstr ""
"Copie o c√≥digo abaixo para <https://play.rust-lang.org/> e implemente as\n"
"fun√ß√µes e m√©todos que faltam:"

#: src/exercises/day-3/safe-ffi-wrapper.md:48
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,should_panic\n"
"// TODO: remova isto com estiver terminado com sua implementa√ß√£o.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Tipo opaco. Veja https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout de acordo com a p√°gina man do Linux para readdir(3), onde ino_t e\n"
"    // off_t s√£o resolvidos de acordo com as defini√ß√µes em\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout de acordo com a p√°gina man do macOS man page para dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // Veja https://github.com/rust-lang/libc/issues/414 e a se√ß√£o sobre\n"
"        // _DARWIN_FEATURE_64_BIT_INODE na p√°gina man do macOS para stat(2).\n"
"        //\n"
"        // \"Plataformas que existiram antes destas atualiza√ß√µes estarem dispon√≠veis\" refere-se\n"
"        // ao macOS (ao contr√°rio do iOS / wearOS / etc.) em Intel e PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Chama opendir e retorna um valor Ok se funcionar,\n"
"        // ou retorna Err com uma mensagem.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Continua chamando readdir at√© n√≥s obtermos um ponteiro NULL de volta.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Chama closedir se necess√°rio.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"

#: src/android.md:1
#, fuzzy
msgid "# Welcome to Rust in Android"
msgstr "# Bem-vindo ao Dia 1"

#: src/android.md:3
msgid ""
"Rust is supported for native platform development on Android. This means that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust tem suporte para desenvolvimento de plataforma nativa no Android. Isso significa que\n"
"voc√™ pode escrever novos servi√ßos de sistema operacional em Rust, bem como estender\n"
"servi√ßos existentes."

#: src/android.md:7
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try to\n"
"> find a little corner of your code base where we can move some lines of code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> Tentaremos chamar Rust de um de seus pr√≥prios projetos hoje. Ent√£o tente\n"
"> encontrar um pequeno canto da sua base de c√≥digo onde podemos mover algumas linhas de c√≥digo "
"para\n"
"> Rust. Quanto menos depend√™ncias e tipos \"ex√≥ticos\", melhor. Algo que\n"
"> analise alguns bytes brutos seria o ideal."

#: src/android/setup.md:1
msgid "# Setup"
msgstr "# Configurar"

#: src/android/setup.md:3
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you have\n"
"access to one or create a new one with:"
msgstr ""
"Estaremos usando um dispositivo virtual Android para testar nosso c√≥digo. Assegure-se de ter\n"
"acesso a um ou crie um novo com:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ launch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"

#: src/android/setup.md:12
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"Consulte o [Codelab para Desenvolvedor Android]\n"
"[https://source.android.com/docs/setup/start] para obter detalhes."

#: src/android/build-rules.md:1
msgid "# Build Rules"
msgstr "# Regras de constru√ß√£o"

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"O sistema de compila√ß√£o do Android (Soong) oferece suporte ao Rust por meio de v√°rios m√≥dulos:"

#: src/android/build-rules.md:5
msgid ""
"| Module Type       | "
"Description                                                                                        "
"|\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust "
"binary.                                                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and `dylib` "
"variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard Rust test "
"harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging "
"`libfuzzer`.                                                |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that provides an interface for "
"a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library containing Rust bindings to C "
"libraries.              |"
msgstr ""
"| Tipo de m√≥dulo | Descri√ß√£o |\n"
"|-------------------|----------------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produz um bin√°rio "
"Rust.                                                                                  |\n"
"| `rust_library`    | Produz uma biblioteca Rust e fornece as variantes `rlib` e "
"`dylib`.                                      |\n"
"| `rust_ffi`        | Produz uma biblioteca Rust C utiliz√°vel por m√≥dulos `cc` e fornece variantes "
"est√°ticas e compartilhadas. |\n"
"| `rust_proc_macro` | Produz uma biblioteca Rust `proc-macro`. Estes s√£o an√°logos aos plugins do "
"compilador.                   |\n"
"| `rust_test`       | Produz um bin√°rio de teste Rust que usa o equipamento de teste Rust "
"padr√£o.                              |\n"
"| `rust_fuzz`       | Produz um bin√°rio Rust fuzz aproveitando "
"`libfuzzer`.                                                    |\n"
"| `rust_protobuf`   | Gera o c√≥digo-fonte e produz uma biblioteca Rust que fornece uma interface "
"para um _protobuf_ espec√≠fico.|\n"
"| `rust_bindgen`    | Gera fonte e produz uma biblioteca Rust contendo liga√ß√µes Rust para "
"bibliotecas C.                       |"

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Veremos `rust_binary` e `rust_library` a seguir."

#: src/android/build-rules/binary.md:1
msgid "# Rust Binaries"
msgstr "# Bin√°rios Rust"

#: src/android/build-rules/binary.md:3
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, create\n"
"the following files:"
msgstr ""
"Vamos come√ßar com um aplicativo simples. Na raiz de um checkout AOSP, crie\n"
"os seguintes arquivos:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary{\n"
"    name: \"ol√°_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
#, fuzzy
msgid ""
"```rust\n"
"//! Rust demo.\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""
"/// Imprime uma sauda√ß√£o na sa√≠da padr√£o.\n"
"fn main() {\n"
"    println!(\"Ol√° do Rust!\");\n"
"}\n"
"```"

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "Agora voc√™ pode compilar, enviar e executar o bin√°rio:"

#: src/android/build-rules/binary.md:29
#, fuzzy
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Sauda√ß√µes da Rust!\n"
"```"

#: src/android/build-rules/library.md:1
msgid "# Rust Libraries"
msgstr "# Bibliotecas de Rust"

#: src/android/build-rules/library.md:3
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "Voc√™ usa `rust_library` para criar uma nova biblioteca Rust para Android."

#: src/android/build-rules/library.md:5
msgid "Here we declare a dependency on two libraries:"
msgstr "Aqui declaramos uma depend√™ncia em duas bibliotecas:"

#: src/android/build-rules/library.md:7
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* `libgreeting`, que definimos abaixo,\n"
"* `libtextwrap`, que √© um `crate` j√° vendida em\n"
"  [`external/rust/crates/`][crates]."

#: src/android/build-rules/library.md:15
#, fuzzy
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"

#: src/android/build-rules/library.md:36
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""
"/// Imprime uma sauda√ß√£o na sa√≠da padr√£o.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""
"/// Sauda√ß√£o `nome`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Ol√° {name}, prazer em conhec√™-lo!\")\n"
"}\n"
"```"

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "Voc√™ constr√≥i, envia e executa o bin√°rio como antes:"

#: src/android/build-rules/library.md:61
#, fuzzy
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Ol√° Bob, prazer em conhec√™-lo!\n"
"```"

#: src/android/aidl.md:1
msgid "# AIDL"
msgstr "# AIDL"

#: src/android/aidl.md:3
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in Rust:"
msgstr ""
"A [Linguagem de Defini√ß√£o de Interface Android\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) √© compat√≠vel com Rust:"

#: src/android/aidl.md:6
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* O c√≥digo Rust pode chamar servidores AIDL existentes,\n"
"* Voc√™ pode criar novos servidores AIDL em Rust."

#: src/android/aidl/interface.md:1
msgid "# AIDL Interfaces"
msgstr "# Interfaces AIDL"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Voc√™ declara a API do seu servi√ßo usando uma interface AIDL:"

#: src/android/aidl/interface.md:5
msgid "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"

#: src/android/aidl/interface.md:7
#, fuzzy
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""
"/** Interface de servi√ßo de anivers√°rio. */\n"
"interface IBirthdayService {\n"
"    /** Gera uma mensagem de feliz anivers√°rio. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"

#: src/android/aidl/interface.md:17
msgid "*birthday_service/aidl/Android.bp*:"
msgstr "*birthday_service/aidl/Android.bp*:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust n√£o est√° ativado por padr√£o\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"

#: src/android/aidl/interface.md:32
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the vendor\n"
"partition."
msgstr ""
"Adicione `vendor_available: true` se seu arquivo AIDL for usado por um bin√°rio na parti√ß√£o "
"_vendor_."

#: src/android/aidl/implementation.md:1
msgid "# Service Implementation"
msgstr "# Implementa√ß√£o de servi√ßo"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "Agora podemos implementar o servi√ßo AIDL:"

#: src/android/aidl/implementation.md:5
msgid "*birthday_service/src/lib.rs*:"
msgstr "*birthday_service/src/lib.rs*:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;\n"
"\n"
"impl binder::Interface for BirthdayService {}\n"
"\n"
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28 src/android/aidl/client.md:37
msgid "*birthday_service/Android.bp*:"
msgstr "*birthday_service/Android.bp*:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"

#: src/android/aidl/server.md:1
msgid "# AIDL Server"
msgstr "# Servidor AIDL"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "Finalmente, podemos criar um servidor que exp√µe o servi√ßo:"

#: src/android/aidl/server.md:5
msgid "*birthday_service/src/server.rs*:"
msgstr "*birthday_service/src/server.rs*:"

#: src/android/aidl/server.md:7
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""
"/// Point de entrada para servi√ßo de anivers√°rio.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_server,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Falha ao registrar o servi√ßo\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefere_rlib: true,\n"
"}\n"
"```"

#: src/android/aidl/deploy.md:1
msgid "# Deploy"
msgstr "# Implantar"

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "Agora podemos construir, enviar e iniciar o servi√ßo:"

#: src/android/aidl/deploy.md:5
#, fuzzy
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md:11
msgid "In another terminal, check that the service runs:"
msgstr "Em outro terminal, verifique se o servi√ßo √© executado:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Servi√ßo de anivers√°rio: encontrado\n"
"```"

#: src/android/aidl/deploy.md:18
msgid "You can also call the service with `service call`:"
msgstr "Voc√™ tamb√©m pode chamar o servi√ßo com `service call`:"

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .a.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000 's.!..... ')\n"
"```"

#: src/android/aidl/client.md:1
msgid "# AIDL Client"
msgstr "# Cliente AIDL"

#: src/android/aidl/client.md:3
msgid "Finally, we can create a Rust client for our new service."
msgstr "Por fim, podemos criar um cliente Rust para nosso novo servi√ßo."

#: src/android/aidl/client.md:5
msgid "*birthday_service/src/client.rs*:"
msgstr "*birthday_server/src/client.rs*:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefere_rlib: true,\n"
"}\n"
"```"

#: src/android/aidl/client.md:52
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Observe que o cliente n√£o depende de `libbirthdayservice`."

#: src/android/aidl/client.md:54
msgid "Build, push, and run the client on your device:"
msgstr "Crie, envie e execute o cliente em seu dispositivo:"

#: src/android/aidl/client.md:56
#, fuzzy
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Parab√©ns Charlie, parab√©ns pelos 60 anos!\n"
"```"

#: src/android/aidl/changing.md:1
msgid "# Changing API"
msgstr "# Alterando API"

#: src/android/aidl/changing.md:3
msgid ""
"Let us extend the API with more functionality: we want to let clients specify a\n"
"list of lines for the birthday card:"
msgstr ""
"Vamos estender a API com mais funcionalidades: queremos permitir que os clientes especifiquem uma\n"
"lista de linhas para o cart√£o de anivers√°rio:"

#: src/android/aidl/changing.md:6
#, fuzzy
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""
"/** Interface de servi√ßo de anivers√°rio. */\n"
"interface IBirthdayService {\n"
"    /** Gera uma mensagem de feliz anivers√°rio. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"

#: src/android/logging.md:1 src/bare-metal/aps/logging.md:1
msgid "# Logging"
msgstr "# Gerando registros (Log)"

#: src/android/logging.md:3
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) or\n"
"`stdout` (on-host):"
msgstr ""
"Voc√™ deve usar o `crate` `log` para logar automaticamente no `logcat` (no dispositivo) ou\n"
"`stdout` (no hospedeiro):"

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefere_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"

#: src/android/logging.md:22
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
#, fuzzy
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"\n"
"use log::{debug, error, info};\n"
"\n"
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""
"/// Registra uma sauda√ß√£o.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Iniciando programa.\");\n"
"    info!(\"As coisas est√£o indo bem.\");\n"
"    error!(\"Algo deu errado!\");\n"
"}\n"
"```"

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
msgid "Build, push, and run the binary on your device:"
msgstr "Crie, envie e execute o bin√°rio em seu dispositivo:"

#: src/android/logging.md:44
#, fuzzy
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md:50
msgid "The logs show up in `adb logcat`:"
msgstr "Os logs aparecem em `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!\n"
"```"
msgstr ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454 2420 2420 D rust: hello_rust_logs: Iniciando o programa.\n"
"09-08 08:38:32.454 2420 2420 I rust: hello_rust_logs: As coisas est√£o indo bem.\n"
"09-08 08:38:32.454 2420 2420 E rust: hello_rust_logs: Algo deu errado!\n"
"```"

#: src/android/interoperability.md:1
msgid "# Interoperability"
msgstr "# Interoperabilidade"

#: src/android/interoperability.md:3
msgid ""
"Rust has excellent support for interoperability with other languages. This means\n"
"that you can:"
msgstr ""
"Rust tem excelente suporte para interoperabilidade com outras linguagens. Isso significa\n"
"que voc√™ pode:"

#: src/android/interoperability.md:6
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* Chamar fun√ß√µes _Rust_ em outras linguagens.\n"
"* Chamar fun√ß√µes escritas em outras linguagens no _Rust_."

#: src/android/interoperability.md:9
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"Quando voc√™ chama fun√ß√µes em outra linguagem, dizemos que voc√™ est√° usando uma\n"
"_interface de fun√ß√£o externa_, tamb√©m conhecida como FFI."

#: src/android/interoperability/with-c.md:1
msgid "# Interoperability with C"
msgstr "# Interoperabilidade com C"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"_Rust_ tem suporte completo para vincular arquivos de objeto com uma conven√ß√£o de chamada C.\n"
"Da mesma forma, voc√™ pode exportar fun√ß√µes Rust e cham√°-las em C."

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "Voc√™ pode fazer isso manualmente se quiser:"

#: src/android/interoperability/with-c.md:8
#, fuzzy
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr ""
"J√° vimos isso no exerc√≠cio [Safe FFI Wrapper\n"
"](../../exercises/day-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr ""
"> Isso pressup√µe conhecimento total da plataforma de destino. N√£o recomendado para\n"
"> produ√ß√£o."

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "Veremos op√ß√µes melhores a seguir."

#: src/android/interoperability/with-c/bindgen.md:1
msgid "# Using Bindgen"
msgstr "# Usando Bingen"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"A ferramenta [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)\n"
"pode gerar liga√ß√µes automaticamente a partir de um arquivo de cabe√ßalho C."

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "Primeiro crie uma pequena biblioteca C:"

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
#, fuzzy
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;\n"
"\n"
"void print_card(const card* card);\n"
"```"
msgstr ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
#, fuzzy
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Feliz Anivers√°rio %s!\\n\", card->name);\n"
"  printf(\"| Parab√©ns pelos %i anos!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr "Adicione isto ao seu arquivo `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperability/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr ""
"Crie um arquivo de cabe√ßalho wrapper para a biblioteca (n√£o estritamente necess√°rio neste\n"
"exemplo):"

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "Agora voc√™ pode gerar automaticamente as vincula√ß√µes:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Finalmente, podemos usar as liga√ß√µes em nosso programa Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_binary{\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:100
#, fuzzy
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:106
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Por fim, podemos executar testes gerados automaticamente para garantir que as vincula√ß√µes "
"funcionem:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Arquivo gerado, pule o linting\n"
"    lints: \"none\",\n"
"}\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"

#: src/android/interoperability/with-c/rust.md:1
msgid "# Calling Rust"
msgstr "# Chamando Rust"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Exportar fun√ß√µes e tipos do Rust para C √© f√°cil:"

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"/// Analisar os n√∫meros.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) √© o menor!\");\n"
"    } else {\n"
"        println!(\"y ({y}) √© provavelmente maior que x ({x})\");\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
#, fuzzy
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "Agora podemos chamar isso de um bin√°rio C:"

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analisar/main.c_"

#: src/android/interoperability/with-c/rust.md:52
#, fuzzy
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"

#: src/android/interoperability/with-c/rust.md:75
#, fuzzy
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\"\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md:83
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol will just be the name "
"of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` desativa a altera√ß√£o de name usual do Rust, ent√£o o s√≠mbolo exportado ser√° apenas o "
"nome da\n"
"fun√ß√£o. Voc√™ tamb√©m pode usar `#[export_name = \"some_name\"]` para especificar qualquer nome que "
"desejar."

#: src/android/interoperability/cpp.md:1
msgid "# With C++"
msgstr "# Com C++"

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between Rust\n"
"and C++."
msgstr ""
"O [crate CXX][1] possibilita a interoperabilidade segura entre Rust\n"
"e C++."

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "A abordagem geral √© assim:"

#: src/android/interoperability/cpp.md:8
msgid "<img src=\"cpp/overview.svg\">"
msgstr "<img src=\"cpp/overview.svg\">"

#: src/android/interoperability/cpp.md:10
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr "Veja o [tutorial CXX][2] para um exemplo completo de como us√°-lo."

#: src/android/interoperability/java.md:1
msgid "# Interoperability with Java"
msgstr "# Interoperabilidade com Java"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java pode carregar objetos compartilhados via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface).\n"
"O [crate `jni`](https://docs.rs/jni/) permite que voc√™ crie uma biblioteca compat√≠vel."

#: src/android/interoperability/java.md:7
msgid "First, we create a Rust function to export to Java:"
msgstr "Primeiro, criamos uma fun√ß√£o Rust para exportar para Java:"

#: src/android/interoperability/java.md:9
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""
"/// Implementa√ß√£o do m√©todo HelloWorld::hello.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Ol√°, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"

#: src/android/interoperability/java.md:32 src/android/interoperability/java.md:62
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:43
msgid "Finally, we can call this function from Java:"
msgstr "Finalmente, podemos chamar esta fun√ß√£o do Java:"

#: src/android/interoperability/java.md:45
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
#, fuzzy
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    necess√°rio: [\"libhello_jni\"],\n"
"}\n"
"```"

#: src/android/interoperability/java.md:73
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Por fim, voc√™ pode criar, sincronizar e executar o bin√°rio:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync # requer adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"

#: src/exercises/android/morning.md:1 src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1 src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
msgid "# Exercises"
msgstr "# Exerc√≠cios"

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with and\n"
"try to integrate some Rust into it. Some suggestions:"
msgstr ""
"No √∫ltimo exerc√≠cio, veremos um dos projetos com os quais voc√™ trabalha. Chamem-nos\n"
"agrupem-se e fa√ßam isso juntos. Algumas sugest√µes:"

#: src/exercises/android/morning.md:6
#, fuzzy
msgid ""
"* Call your AIDL service with a client written in Rust.\n"
"\n"
"* Move a function from your project to Rust and call it."
msgstr "* Mova uma fun√ß√£o do seu projeto para o Rust e chame-a."

#: src/exercises/android/morning.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nenhuma solu√ß√£o √© fornecida aqui, pois isso √© aberto: depende de voc√™ ter\n"
"uma classe tendo um peda√ßo de c√≥digo que voc√™ pode transformar em Rust em tempo real."

#: src/bare-metal.md:1
#, fuzzy
msgid "# Welcome to Bare Metal Rust"
msgstr "# Bem-vindo ao Comprehensive Rust ü¶Ä"

#: src/bare-metal.md:3
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people who are familiar with "
"the\n"
"basics of Rust (perhaps from completing the Comprehensive Rust course), and ideally also have "
"some\n"
"experience with bare-metal programming in some other language such as C."
msgstr ""

#: src/bare-metal.md:7
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS underneath us. This "
"will\n"
"be divided into several parts:"
msgstr ""

#: src/bare-metal.md:10
msgid ""
"- What is `no_std` Rust?\n"
"- Writing firmware for microcontrollers.\n"
"- Writing bootloader / kernel code for application processors.\n"
"- Some useful crates for bare-metal Rust development."
msgstr ""

#: src/bare-metal.md:15
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit](https://microbit.org/) "
"v2\n"
"as an example. It's a [development board](https://tech.microbit.org/hardware/) based on the "
"Nordic\n"
"nRF51822 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, "
"and\n"
"an on-board SWD debugger."
msgstr ""

#: src/bare-metal.md:20
msgid "To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""

#: src/bare-metal.md:22
msgid ""
"```bash\n"
"sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-config qemu-system-"
"arm\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal.md:30
msgid "And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""

#: src/bare-metal.md:32
msgid ""
"```bash\n"
"echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", GROUP=\"plugdev\"' |\\\n"
"  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
"sudo udevadm control --reload-rules\n"
"```"
msgstr ""

#: src/bare-metal.md:38
msgid "On MacOS:"
msgstr ""

#: src/bare-metal.md:40
msgid ""
"```bash\n"
"xcode-select --install\n"
"brew install gdb picocom qemu\n"
"brew install --cask gcc-aarch64-embedded\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal/no_std.md:1
msgid "# `no_std`"
msgstr ""

#: src/bare-metal/no_std.md:3
msgid ""
"<table>\n"
"<tr>\n"
"<th>"
msgstr ""

#: src/bare-metal/no_std.md:7
msgid "`core`"
msgstr ""

#: src/bare-metal/no_std.md:9 src/bare-metal/no_std.md:14
msgid ""
"</th>\n"
"<th>"
msgstr ""

#: src/bare-metal/no_std.md:12
msgid "`alloc`"
msgstr ""

#: src/bare-metal/no_std.md:17
msgid "`std`"
msgstr ""

#: src/bare-metal/no_std.md:19
msgid ""
"</th>\n"
"</tr>\n"
"<tr valign=\"top\">\n"
"<td>"
msgstr ""

#: src/bare-metal/no_std.md:24
msgid ""
"* Slices, `&str`, `CStr`\n"
"* `NonZeroU8`...\n"
"* `Option`, `Result`\n"
"* `Display`, `Debug`, `write!`...\n"
"* `Iterator`\n"
"* `panic!`, `assert_eq!`...\n"
"* `NonNull` and all the usual pointer-related functions\n"
"* `Future` and `async`/`await`\n"
"* `fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`...\n"
"* `Duration`"
msgstr ""

#: src/bare-metal/no_std.md:35 src/bare-metal/no_std.md:42
msgid ""
"</td>\n"
"<td>"
msgstr ""

#: src/bare-metal/no_std.md:38
msgid ""
"* `Box`, `Cow`, `Arc`, `Rc`\n"
"* `Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`\n"
"* `String`, `CString`, `format!`"
msgstr ""

#: src/bare-metal/no_std.md:45
msgid ""
"* `Error`\n"
"* `HashMap`\n"
"* `Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`\n"
"* `File` and the rest of `fs`\n"
"* `println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`\n"
"* `Path`, `OsString`\n"
"* `net`\n"
"* `Command`, `Child`, `ExitCode`\n"
"* `spawn`, `sleep` and the rest of `thread`\n"
"* `SystemTime`, `Instant`"
msgstr ""

#: src/bare-metal/no_std.md:56
msgid ""
"</td>\n"
"</tr>\n"
"</table>\n"
"\n"
"<details>"
msgstr ""

#: src/bare-metal/no_std.md:62
msgid ""
"* `HashMap` depends on RNG.\n"
"* `std` re-exports the contents of both `core` and `alloc`."
msgstr ""

#: src/bare-metal/minimal.md:1
msgid "# A minimal `no_std` program"
msgstr ""

#: src/bare-metal/minimal.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::panic::PanicInfo;\n"
"\n"
"#[panic_handler]\n"
"fn panic(_panic: &PanicInfo) -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/minimal.md:17
msgid ""
"* This will compile to an empty binary.\n"
"* `std` provides a panic handler; without it we must provide our own.\n"
"* It can also be provided by another crate, such as `panic-halt`.\n"
"* Depending on the target, you may need to compile with `panic = \"abort\"` to avoid an error "
"about\n"
"  `eh_personality`.\n"
"* Note that there is no `main` or any other entry point; it's up to you to define your own entry\n"
"  point. This will typically involve a linker script and some assembly code to set things up "
"ready\n"
"  for Rust code to run."
msgstr ""

#: src/bare-metal/alloc.md:1
msgid "# `alloc`"
msgstr ""

#: src/bare-metal/alloc.md:3
msgid ""
"To use `alloc` you must implement a\n"
"[global (heap) allocator](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""

#: src/bare-metal/alloc.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Now we can do things that require heap allocation.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/alloc.md:39
msgid ""
"* `buddy_system_allocator` is a third-party crate implementing a basic buddy system allocator. "
"Other\n"
"  crates are available, or you can write your own or hook into your existing allocator.\n"
"* The const parameter of `LockedHeap` is the max order of the allocator; i.e. in this case it can\n"
"  allocate regions of up to 2**32 bytes.\n"
"* If any crate in your dependency tree depends on `alloc` then you must have exactly one global\n"
"  allocator defined in your binary. Usually this is done in the top-level binary crate.\n"
"* `extern crate panic_halt as _` is necessary to ensure that the `panic_halt` crate is linked in "
"so\n"
"  we get its panic handler.\n"
"* This example will build but not run, as it doesn't have an entry point."
msgstr ""

#: src/bare-metal/microcontrollers.md:1
msgid "# Microcontrollers"
msgstr ""

#: src/bare-metal/microcontrollers.md:3
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for Cortex M "
"microcontrollers."
msgstr ""

#: src/bare-metal/microcontrollers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use cortex_m_rt::entry;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers.md:21
msgid "Next we'll look at how to access peripherals, with increasing levels of abstraction."
msgstr ""

#: src/bare-metal/microcontrollers.md:25
msgid ""
"* The `cortex_m_rt::entry` macro requires that the function have type `fn() -> !`, because "
"returning\n"
"  to the reset handler doesn't make sense.\n"
"* Run the example with `cargo embed --bin minimal`"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:1
msgid "# Raw MMIO"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:3
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try turning on an LED on our\n"
"micro:bit:"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// GPIO port 0 peripheral address\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// GPIO peripheral offsets\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// PIN_CNF fields\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
"const PULL_DISABLED: u32 = 0x0 << 2;\n"
"const DRIVE_S0S1: u32 = 0x0 << 8;\n"
"const SENSE_DISABLED: u32 = 0x0 << 16;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 << 28);\n"
"        gpio0_outset.write_volatile(1 << 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:64
msgid ""
"* GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 to the first row."
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:66 src/bare-metal/microcontrollers/pacs.md:59
#: src/bare-metal/microcontrollers/hals.md:43 src/bare-metal/microcontrollers/board-support.md:34
msgid "Run the example with:"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:68
#, fuzzy
msgid ""
"```sh\n"
"cargo embed --bin mmio\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/bare-metal/microcontrollers/pacs.md:1
msgid "# Peripheral Access Crates"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:3
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust wrappers for\n"
"memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index."
"html)\n"
"files."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:49
msgid ""
"* SVD (System View Description) files are XML files typically provided by silicon vendors which\n"
"  describe the memory map of the device.\n"
"  * They are organised by peripheral, register, field and value, with names, descriptions, "
"addresses\n"
"    and so on.\n"
"  * SVD files are often buggy and incomplete, so there are various projects which patch the\n"
"    mistakes, add missing details, and publish the generated crates.\n"
"* `cortex-m-rt` provides the vector table, among other things.\n"
"* If you `cargo install cargo-binutils` then you can run\n"
"  `cargo objdump --bin pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:61
#, fuzzy
msgid ""
"```sh\n"
"cargo embed --bin pac\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/bare-metal/microcontrollers/hals.md:1
msgid "# HAL crates"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:3
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates) "
"for\n"
"many microcontrollers provide wrappers around various peripherals. These generally implement "
"traits\n"
"from [`embedded-hal`](https://crates.io/crates/embedded-hal)."
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Create HAL wrapper for GPIO port 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:39
msgid ""
" * `set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait.\n"
" * HAL crates exist for many Cortex-M and RISC-V devices, including various STM32, GD32, nRF, "
"NXP,\n"
"   MSP430, AVR and PIC microcontrollers."
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:45
#, fuzzy
msgid ""
"```sh\n"
"cargo embed --bin hal\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/bare-metal/microcontrollers/board-support.md:1
msgid "# Board support crates"
msgstr "# Atalhos de teclado"

#: src/bare-metal/microcontrollers/board-support.md:3
msgid ""
"Board support crates provide a further level of wrapping for a specific board for convenience."
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::Board;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let mut board = Board::take().unwrap();\n"
"\n"
"    board.display_pins.col1.set_low().unwrap();\n"
"    board.display_pins.row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:28
msgid ""
" * In this case the board support crate is just providing more useful names, and a bit of\n"
"   initialisation.\n"
" * The crate may also include drivers for some on-board devices outside of the microcontroller\n"
"   itself.\n"
"   * `microbit-v2` includes a simple driver for the LED matrix."
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:36
msgid ""
"```sh\n"
"cargo embed --bin board_support\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:1
msgid "# The type state pattern"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Error, moved.\n"
"\n"
"    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);\n"
"    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03.into_push_pull_output(Level::Low);\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:32
msgid ""
" * Pins don't implement `Copy` or `Clone`, so only one instance of each can exist. Once a pin is\n"
"   moved out of the port struct nobody else can take it.\n"
" * Changing the configuration of a pin consumes the old pin instance, so you can‚Äôt keep use the "
"old\n"
"   instance afterwards.\n"
" * The type of a value indicates the state that it is in: e.g. in this case, the configuration "
"state\n"
"   of a GPIO pin. This encodes the state machine into the type system, and ensures that you don't\n"
"   try to use a pin in a certain way without properly configuring it first. Illegal state\n"
"   transitions are caught at compile time.\n"
" * You can call `is_high` on an input pin and `set_high` on an output pin, but not vice-versa.\n"
" * Many HAL crates follow this pattern."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:1
msgid "# `embedded-hal`"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:3
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a number of traits\n"
"covering common microcontroller peripherals."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:6
msgid ""
" * GPIO\n"
" * ADC\n"
" * I2C, SPI, UART, CAN\n"
" * RNG\n"
" * Timers\n"
" * Watchdogs"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:13
msgid ""
"Other crates then implement\n"
"[drivers](https://github.com/rust-embedded/awesome-embedded-rust#driver-crates) in terms of these\n"
"traits, e.g. an accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:19
msgid ""
" * There are implementations for many microcontrollers, as well as other platforms such as Linux "
"on\n"
"Raspberry Pi.\n"
" * There is work in progress on an `async` version of `embedded-hal`, but it isn't stable yet."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:1
msgid "# `probe-rs`, `cargo-embed`"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:3
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, like OpenOCD but better\n"
"integrated."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:6
msgid ""
"* <abbr title=\"Serial Wire Debug\">SWD</abbr> and JTAG via CMSIS-DAP, ST-Link and J-Link probes\n"
"* GDB stub and Microsoft <abbr title=\"Debug Adapter Protocol\">DAP</abbr> server\n"
"* Cargo integration"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:10
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log\n"
"<abbr title=\"Real Time Transfers\">RTT</abbr> output and connect GDB. It's configured by an\n"
"`Embed.toml` file in your project directory."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:16
msgid ""
"* [CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is an Arm standard\n"
"  protocol over USB for an in-circuit debugger to access the CoreSight Debug Access Port of "
"various\n"
"  Arm Cortex processors. It's what the on-board debugger on the BBC micro:bit uses.\n"
"* ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is a range from\n"
"  SEGGER.\n"
"* The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial Wire Debug.\n"
"* probe-rs is a library which you can integrate into your own tools if you want to.\n"
"* The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/) "
"lets\n"
"  VSCode and other IDEs debug code running on any supported microcontroller.\n"
"* cargo-embed is a binary built using the probe-rs library.\n"
"* RTT (Real Time Transfers) is a mechanism to transfer data between the debug host and the target\n"
"  through a number of ringbuffers."
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:1
#, fuzzy
msgid "# Debugging"
msgstr "# Gerando registros (Log)"

#: src/bare-metal/microcontrollers/debugging.md:3
msgid "Embed.toml:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:5
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:13
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:15
msgid ""
"```sh\n"
"cargo embed --bin board_support debug\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:19
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "Em outro terminal, verifique se o servi√ßo √© executado:"

#: src/bare-metal/microcontrollers/debugging.md:21
msgid ""
"```sh\n"
"gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=\"target "
"remote :1337\"\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:27
msgid "In GDB, try running:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:29
msgid ""
"```gdb\n"
"b src/bin/board_support.rs:29\n"
"b src/bin/board_support.rs:30\n"
"b src/bin/board_support.rs:32\n"
"c\n"
"c\n"
"c\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:1 src/bare-metal/aps/other-projects.md:1
msgid "# Other projects"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:3
msgid ""
" * [RTIC](https://rtic.rs/)\n"
"   * \"Real-Time Interrupt-driven Concurrency\"\n"
"   * Shared resource management, message passing, task scheduling, timer queue\n"
" * [Embassy](https://embassy.dev/)\n"
"   * `async` executors with priorities, timers, networking, USB\n"
" * [TockOS](https://www.tockos.org/documentation/getting-started)\n"
"   * Security-focused RTOS with preemptive scheduling and Memory Protection Unit support\n"
" * [Hubris](https://hubris.oxide.computer/)\n"
"   * Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, "
"IPC\n"
" * [Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)\n"
" * Some platforms have `std` implementations, e.g.\n"
"   [esp-idf](https://esp-rs.github.io/book/overview/using-the-standard-library.html)."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:18
msgid ""
" * RTIC can be considered either an RTOS or a concurrency framework.\n"
"   * It doesn't include any HALs.\n"
"   * It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for scheduling rather than a\n"
"     proper kernel.\n"
"   * Cortex-M only.\n"
" * Google uses TockOS on the Haven microcontroller for Titan security keys.\n"
" * FreeRTOS is mostly written in C, but there are Rust bindings for writing applications."
msgstr ""

#: src/exercises/bare-metal/morning.md:3
msgid "We will read the direction from an I2C compass, and log the readings to a serial port."
msgstr ""

#: src/exercises/bare-metal/compass.md:1
#, fuzzy
msgid "# Compass"
msgstr "# Compara√ß√£o"

#: src/exercises/bare-metal/compass.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a serial port. If you "
"have\n"
"time, try displaying it on the LEDs somehow too, or use the buttons somehow."
msgstr ""

#: src/exercises/bare-metal/compass.md:6
msgid "Hints:"
msgstr ""

#: src/exercises/bare-metal/compass.md:8
msgid ""
"- Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) and\n"
"  [`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) crates, as well as the\n"
"  [micro:bit hardware](https://tech.microbit.org/hardware/).\n"
"- The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.\n"
"- TWI is another name for I2C, so the I2C master peripheral is called TWIM.\n"
"- The LSM303AGR driver needs something implementing the `embedded_hal::blocking::i2c::WriteRead`\n"
"  trait. The\n"
"  [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"struct\n"
"  implements this.\n"
"- You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/struct.Board.html)\n"
"  struct with fields for the various pins and peripherals.\n"
"- You can also look at the\n"
"  [nRF52833 datasheet](https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf) if you want, "
"but\n"
"  it shouldn't be necessary for this exercise."
msgstr ""

#: src/exercises/bare-metal/compass.md:23
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and look in the "
"`compass`\n"
"directory for the following files."
msgstr ""

#: src/exercises/bare-metal/compass.md:26 src/exercises/bare-metal/rtc.md:19
#, fuzzy
msgid "`src/main.rs`:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/compass.md:28 src/exercises/bare-metal/rtc.md:21
#: src/exercises/concurrency/dining-philosophers.md:17 src/exercises/concurrency/link-checker.md:55
#: src/exercises/concurrency/dining-philosophers-async.md:11
msgid "<!-- File src/main.rs -->"
msgstr ""

#: src/exercises/bare-metal/compass.md:30
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:64 src/exercises/bare-metal/rtc.md:385
msgid "`Cargo.toml` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:66 src/exercises/bare-metal/rtc.md:387
#: src/exercises/concurrency/dining-philosophers.md:63 src/exercises/concurrency/link-checker.md:35
#: src/exercises/concurrency/dining-philosophers-async.md:60 src/exercises/concurrency/chat-app.md:17
msgid "<!-- File Cargo.toml -->"
msgstr ""

#: src/exercises/bare-metal/compass.md:68
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"compass\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"cortex-m-rt = \"0.7.3\"\n"
"embedded-hal = \"0.2.6\"\n"
"lsm303agr = \"0.2.2\"\n"
"microbit-v2 = \"0.13.0\"\n"
"panic-halt = \"0.2.0\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:85
msgid "`Embed.toml` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:87
msgid "<!-- File Embed.toml -->"
msgstr ""

#: src/exercises/bare-metal/compass.md:89
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"\n"
"[debug.reset]\n"
"halt_afterwards = true\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:100 src/exercises/bare-metal/rtc.md:985
msgid "`.cargo/config.toml` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:102 src/exercises/bare-metal/rtc.md:987
msgid "<!-- File .cargo/config.toml -->"
msgstr ""

#: src/exercises/bare-metal/compass.md:104
msgid ""
"```toml\n"
"[build]\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\"-C\", \"link-arg=-Tlink.x\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:112
msgid "See the serial output on Linux with:"
msgstr ""

#: src/exercises/bare-metal/compass.md:114
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/ttyACM0\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
msgid "Or on Mac OS something like (the device name may be slightly different):"
msgstr ""

#: src/exercises/bare-metal/compass.md:120
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:124
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr ""

#: src/bare-metal/aps.md:1
msgid "# Application processors"
msgstr ""

#: src/bare-metal/aps.md:3
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. Now let's try "
"writing\n"
"something for Cortex-A. For simplicity we'll just work with QEMU's aarch64\n"
"['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) board."
msgstr ""

#: src/bare-metal/aps.md:9
msgid ""
"* Broadly speaking, microcontrollers don't have an MMU or multiple levels of privilege (exception\n"
"  levels on Arm CPUs, rings on x86), while application processors do.\n"
"* QEMU supports emulating various different machines or board models for each architecture. The\n"
"  'virt' board doesn't correspond to any particular real hardware, but is designed purely for\n"
"  virtual machines."
msgstr ""

#: src/bare-metal/aps/entry-point.md:1
msgid "# Getting Ready to Rust"
msgstr ""

#: src/bare-metal/aps/entry-point.md:3
msgid "Before we can start running Rust code, we need to do some initialisation."
msgstr ""

#: src/bare-metal/aps/entry-point.md:5
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md:77
msgid ""
"* This is the same as it would be for C: initialising the processor state, zeroing the BSS, and\n"
"  setting up the stack pointer.\n"
"  * The BSS (block starting symbol, for historical reasons) is the part of the object file which\n"
"    containing statically allocated variables which are initialised to zero. They are omitted "
"from\n"
"    the image, to avoid wasting space on zeroes. The compiler assumes that the loader will take "
"care\n"
"    of zeroing them.\n"
"* The BSS may already be zeroed, depending on how memory is initialised and the image is loaded, "
"but\n"
"  we zero it to be sure.\n"
"* We need to enable the MMU and cache before reading or writing any memory. If we don't:\n"
"  * Unaligned accesses will fault. We build the Rust code for the `aarch64-unknown-none` target\n"
"    which sets `+strict-align` to prevent the compiler generating unaligned accesses, so it "
"should\n"
"    be fine in this case, but this is not necessarily the case in general.\n"
"  * If it were running in a VM, this can lead to cache coherency issues. The problem is that the "
"VM\n"
"    is accessing memory directly with the cache disabled, while the host has cachable aliases to "
"the\n"
"    same memory. Even if the host doesn't explicitly access the memory, speculative accesses can\n"
"    lead to cache fills, and then changes from one or the other will get lost when the cache is\n"
"    cleaned or the VM enables the cache. (Cache is keyed by physical address, not VA or IPA.)\n"
"* For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which identity maps the first "
"1\n"
"  GiB of address space for devices, the next 1 GiB for DRAM, and another 1 GiB higher up for more\n"
"  devices. This matches the memory layout that QEMU uses.\n"
"* We also set up the exception vector (`vbar_el1`), which we'll see more about later.\n"
"* All examples this afternoon assume we will be running at exception level 1 (EL1). If you need "
"to\n"
"  run at a different exception level you'll need to modify `entry.S` accordingly."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:1
msgid "# Inline assembly"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:3
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with Rust code. For example,\n"
"to make an <abbr title=\"hypervisor call\">HVC</abbr> to tell the firmware to power off the system:"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
"    unsafe {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            options(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:39
msgid ""
"(If you actually want to do this, use the [`smccc`][1] crate which has wrappers for all these "
"functions.)"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:43
msgid ""
"* PSCI is the Arm Power State Coordination Interface, a standard set of functions to manage "
"system\n"
"  and CPU power states, among other things. It is implemented by EL3 firmware and hypervisors on\n"
"  many systems.\n"
"* The `0 => _` syntax means initialise the register to 0 before running the inline assembly code,\n"
"  and ignore its contents afterwards. We need to use `inout` rather than `in` because the call "
"could\n"
"  potentially clobber the contents of the registers.\n"
"* This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because it is called from "
"our\n"
"  entry point in `entry.S`.\n"
"* `_x0`‚Äì`_x3` are the values of registers `x0`‚Äì`x3`, which are conventionally used by the "
"bootloader\n"
"  to pass things like a pointer to the device tree. According to the standard aarch64 calling\n"
"  convention (which is what `extern \"C\"` specifies to use), registers `x0`‚Äì`x7` are used for "
"the\n"
"  first 8 arguments passed to a function, so `entry.S` doesn't need to do anything special except\n"
"  make sure it doesn't change these registers.\n"
"* Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/mmio.md:1
msgid "# Volatile memory access for MMIO"
msgstr ""

#: src/bare-metal/aps/mmio.md:3
msgid ""
" * Use `pointer::read_volatile` and `pointer::write_volatile`.\n"
" * Never hold a reference.\n"
" * `addr_of!` lets you get fields of structs without creating an intermediate reference."
msgstr ""

#: src/bare-metal/aps/mmio.md:9
msgid ""
" * Volatile access: read or write operations may have side-effects, so prevent the compiler or\n"
"   hardware from reordering, duplicating or eliding them.\n"
"   * Usually if you write and then read, e.g. via a mutable reference, the compiler may assume "
"that\n"
"     the value read is the same as the value just written, and not bother actually reading "
"memory.\n"
" * Some existing crates for volatile access to hardware do hold references, but this is unsound.\n"
"   Whenever a reference exist, the compiler may choose to dereference it.\n"
" * Use the `addr_of!` macro to get struct field pointers from a pointer to the struct."
msgstr ""

#: src/bare-metal/aps/uart.md:1
msgid "# Let's write a UART driver"
msgstr ""

#: src/bare-metal/aps/uart.md:3
msgid "The QEMU 'virt' machine has a [PL011][1] UART, so let's write a driver for that."
msgstr ""

#: src/bare-metal/aps/uart.md:5
msgid ""
"```rust,editable\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Minimal driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of a\n"
"    /// PL011 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart.md:55
msgid ""
"* Note that `Uart::new` is unsafe while the other methods are safe. This is because as long as "
"the\n"
"  caller of `Uart::new` guarantees that its safety requirements are met (i.e. that there is only\n"
"  ever one instance of the driver for a given UART, and nothing else aliasing its address space),\n"
"  then it is always safe to call `write_byte` later because we can assume the necessary\n"
"  preconditions.\n"
"* We could have done it the other way around (making `new` safe but `write_byte` unsafe), but "
"that\n"
"  would be much less convenient to use as every place that calls `write_byte` would need to "
"reason\n"
"  about the safety\n"
"* This is a common pattern for writing safe wrappers of unsafe code: moving the burden of proof "
"for\n"
"  soundness from a large number of places to a smaller number of places."
msgstr ""

#: src/bare-metal/aps/uart.md:66
#, fuzzy
msgid "</detais>"
msgstr "</details>"

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "# More traits"
msgstr "# Traits (Caracter√≠sticas)"

#: src/bare-metal/aps/uart/traits.md:3
msgid "We derived the `Debug` trait. It would be useful to implement a few more traits too."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:24
msgid ""
"* Implementing `Write` lets us use the `write!` and `writeln!` macros with our `Uart` type.\n"
"* Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/better-uart.md:1
msgid "# A better UART driver"
msgstr ""

#: src/bare-metal/aps/better-uart.md:3
msgid ""
"The PL011 actually has [a bunch more registers][1], and adding offsets to construct pointers to "
"access\n"
"them is error-prone and hard to read. Plus, some of them are bit fields which would be nice to\n"
"access in a structured way."
msgstr ""

#: src/bare-metal/aps/better-uart.md:7
msgid ""
"| Offset | Register name | Width |\n"
"| ------ | ------------- | ----- |\n"
"| 0x00   | DR            | 12    |\n"
"| 0x04   | RSR           | 4     |\n"
"| 0x18   | FR            | 9     |\n"
"| 0x20   | ILPR          | 8     |\n"
"| 0x24   | IBRD          | 16    |\n"
"| 0x28   | FBRD          | 6     |\n"
"| 0x2c   | LCR_H         | 8     |\n"
"| 0x30   | CR            | 16    |\n"
"| 0x34   | IFLS          | 6     |\n"
"| 0x38   | IMSC          | 11    |\n"
"| 0x3c   | RIS           | 11    |\n"
"| 0x40   | MIS           | 11    |\n"
"| 0x44   | ICR           | 11    |\n"
"| 0x48   | DMACR         | 3     |"
msgstr ""

#: src/bare-metal/aps/better-uart.md:26
msgid "- There are also some ID registers which have been omitted for brevity."
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:1
msgid "# Bitflags"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:3
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for working with bitflags."
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:37
msgid ""
"* The `bitflags!` macro creates a newtype something like `Flags(u16)`, along with a bunch of "
"method\n"
"  implementations to get and set flags."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:1
msgid "# Multiple registers"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:3
msgid "We can use a struct to represent the memory layout of the UART's registers."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:41
msgid ""
"* [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-representation) tells\n"
"  the compiler to lay the struct fields out in order, following the same rules as C. This is\n"
"  necessary for our struct to have a predictable layout, as default Rust representation allows "
"the\n"
"  compiler to (among other things) reorder fields however it sees fit."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:1
msgid "# Driver"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:3
msgid "Now let's use the new `Registers` struct in our driver."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:5
msgid ""
"```rust,editable,compile_fail\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of a\n"
"    /// PL011 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:64
msgid ""
"* Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual fields without "
"creating\n"
"  an intermediate reference, which would be unsound."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:1 src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "# Using it"
msgstr "# Usando Bingen"

#: src/bare-metal/aps/better-uart/using.md:3
msgid ""
"Let's write a small program using our driver to write to the serial console, and echo incoming\n"
"bytes."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(b) = uart.read_byte() {\n"
"            uart.write_byte(b);\n"
"            match b {\n"
"                b'\\r' => {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' => break,\n"
"                _ => {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
msgid ""
"* As in the [inline assembly](../inline-assembly.md) example, this `main` function is called from "
"our\n"
"  entry point code in `entry.S`. See the speaker notes there for details.\n"
"* Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/logging.md:3
msgid ""
"It would be nice to be able to use the logging macros from the [`log`][1] crate. We can do this "
"by\n"
"implementing the `Log` trait."
msgstr ""

#: src/bare-metal/aps/logging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging.md:50
msgid "* The unwrap in `log` is safe because we initialise `LOGGER` before calling `set_logger`."
msgstr ""

#: src/bare-metal/aps/logging/using.md:3
msgid "We need to initialise the logger before we use it."
msgstr ""

#: src/bare-metal/aps/logging/using.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
msgid ""
"* Note that our panic handler can now log details of panics.\n"
"* Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/exceptions.md:1
#, fuzzy
msgid "# Exceptions"
msgstr "# Fun√ß√µes"

#: src/bare-metal/aps/exceptions.md:3
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of exceptions "
"(synchronous,\n"
"IRQ, FIQ, SError) from 4 states (current EL with SP0, current EL with SPx, lower EL using "
"AArch64,\n"
"lower EL using AArch32). We implement this in assembly to save volatile registers to the stack\n"
"before calling into Rust code:"
msgstr ""

#: src/bare-metal/aps/exceptions.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/exceptions.md:64
msgid ""
"* EL is exception level; all our examples this afternoon run in EL1.\n"
"* For simplicity we aren't distinguishing between SP0 and SPx for the current EL exceptions, or\n"
"  between AArch32 and AArch64 for the lower EL exceptions.\n"
"* For this example we just log the exception and power down, as we don't expect any of them to\n"
"  actually happen.\n"
"* We can think of exception handlers and our main execution context more or less like different\n"
"  threads. [`Send` and `Sync`][1] will control what we can share between them, just like with "
"threads.\n"
"  For example, if we want to share some value between exception handlers and the rest of the\n"
"  program, and it's `Send` but not `Sync`, then we'll need to wrap it in something like a `Mutex`\n"
"  and put it in a static."
msgstr ""

#: src/bare-metal/aps/other-projects.md:3
msgid ""
" * [oreboot](https://github.com/oreboot/oreboot)\n"
"   * \"coreboot without the C\"\n"
"   * Supports x86, aarch64 and RISC-V.\n"
"   * Relies on LinuxBoot rather than having many drivers itself.\n"
" * [Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials)\n"
"   * Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling,\n"
"     page tables\n"
"   * Some dodginess around cache maintenance and initialisation in Rust, not necessarily a good\n"
"     example to copy for production code.\n"
" * [`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)\n"
"   * Static analysis to determine maximum stack usage."
msgstr ""

#: src/bare-metal/aps/other-projects.md:17
msgid ""
"* The RaspberryPi OS tutorial runs Rust code before the MMU and caches are enabled. This will "
"read\n"
"  and write memory (e.g. the stack). However:\n"
"  * Without the MMU and cache, unaligned accesses will fault. It builds with `aarch64-unknown-"
"none`\n"
"    which sets `+strict-align` to prevent the compiler generating unaligned accesses so it should "
"be\n"
"    alright, but this is not necessarily the case in general.\n"
"  * If it were running in a VM, this can lead to cache coherency issues. The problem is that the "
"VM\n"
"    is accessing memory directly with the cache disabled, while the host has cachable aliases to "
"the\n"
"    same memory. Even if the host doesn't explicitly access the memory, speculative accesses can\n"
"    lead to cache fills, and then changes from one or the other will get lost. Again this is "
"alright\n"
"    in this particular case (running directly on the hardware with no hypervisor), but isn't a "
"good\n"
"    pattern in general."
msgstr ""

#: src/bare-metal/useful-crates.md:1
msgid "# Useful crates"
msgstr "_Crates_ √öteis"

#: src/bare-metal/useful-crates.md:3
msgid "We'll go over a few crates which solve some common problems in bare-metal programming."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:1
msgid "# `zerocopy`"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:3
msgid ""
"The [`zerocopy`][1] crate (from Fuchsia) provides traits and macros for safely converting between\n"
"byte sequences and other types."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use zerocopy::AsBytes;\n"
"\n"
"#[repr(u32)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"enum RequestType {\n"
"    #[default]\n"
"    In = 0,\n"
"    Out = 1,\n"
"    Flush = 4,\n"
"}\n"
"\n"
"#[repr(C)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"struct VirtioBlockRequest {\n"
"    request_type: RequestType,\n"
"    reserved: u32,\n"
"    sector: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let request = VirtioBlockRequest {\n"
"        request_type: RequestType::Flush,\n"
"        sector: 42,\n"
"        ..Default::default()\n"
"    };\n"
"\n"
"    assert_eq!(\n"
"        request.as_bytes(),\n"
"        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:40
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), but can be useful "
"for\n"
"working with structures shared with hardware e.g. by DMA, or sent over some external interface."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:45
msgid ""
"* `FromBytes` can be implemented for types for which any byte pattern is valid, and so can safely "
"be\n"
"  converted from an untrusted sequence of bytes.\n"
"* Attempting to derive `FromBytes` for these types would fail, because `RequestType` doesn't use "
"all\n"
"  possible u32 values as discriminants, so not all byte patterns are valid.\n"
"* `zerocopy::byteorder` has types for byte-order aware numeric primitives.\n"
"* Run the example with `cargo run` under `src/bare-metal/useful-crates/zerocopy-example/`. (It "
"won't\n"
"  run in the Playground because of the crate dependency.)"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:1
msgid "# `aarch64-paging`"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:3
msgid ""
"The [`aarch64-paging`][1] crate lets you create page tables according to the AArch64 Virtual "
"Memory\n"
"System Architecture."
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paging::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Create a new page table with identity mapping.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map a 2 MiB region of memory as read-only.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Set `TTBR0_EL1` to activate the page table.\n"
"idmap.activate();\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
msgid ""
"* For now it only supports EL1, but support for other exception levels should be straightforward "
"to\n"
"  add.\n"
"* This is used in Android for the [Protected VM Firmware][2].\n"
"* There's no easy way to run this example, as it needs to run on real hardware or under QEMU."
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:1
msgid "# `buddy_system_allocator`"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
msgid ""
"[`buddy_system_allocator`][1] is a third-party crate implementing a basic buddy system allocator.\n"
"It can be used both for [`LockedHeap`][2] implementing [`GlobalAlloc`][3] so you can use the\n"
"standard `alloc` crate (as we saw [before][4]), or for allocating other address space. For "
"example,\n"
"we might want to allocate MMIO space for PCI BARs:"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use buddy_system_allocator::FrameAllocator;\n"
"use core::alloc::Layout;\n"
"\n"
"fn main() {\n"
"    let mut allocator = FrameAllocator::<32>::new();\n"
"    allocator.add_frame(0x200_0000, 0x400_0000);\n"
"\n"
"    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
"    let bar = allocator\n"
"        .alloc_aligned(layout)\n"
"        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
"    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:26
msgid ""
"* PCI BARs always have alignment equal to their size.\n"
"* Run the example with `cargo run` under `src/bare-metal/useful-crates/allocator-example/`. (It "
"won't\n"
"  run in the Playground because of the crate dependency.)"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:1
msgid "# `tinyvec`"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:3
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without heap allocation.\n"
"[`tinyvec`][1] provides this: a vector backed by an array or slice, which could be statically\n"
"allocated or on the stack, which keeps track of how many elements are used and panics if you try "
"to\n"
"use more than are allocated."
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use tinyvec::{array_vec, ArrayVec};\n"
"\n"
"fn main() {\n"
"    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.push(7);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.remove(1);\n"
"    println!(\"{numbers:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:23
msgid ""
"* `tinyvec` requires that the element type implement `Default` for initialisation.\n"
"* The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "# `spin`"
msgstr "## `static`"

#: src/bare-metal/useful-crates/spin.md:3
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` are not available in\n"
"`core` or `alloc`. How can we manage synchronisation or interior mutability, such as for sharing\n"
"state between different CPUs?"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:7
msgid "The [`spin`][1] crate provides spinlock-based equivalents of many of these primitives."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:9
msgid ""
"```rust,editable,compile_fail\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
"\n"
"fn main() {\n"
"    println!(\"count: {}\", counter.lock());\n"
"    *counter.lock() += 2;\n"
"    println!(\"count: {}\", counter.lock());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:23
msgid ""
"* Be careful to avoid deadlock if you take locks in interrupt handlers.\n"
"* `spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, `Barrier` and "
"`Once`\n"
"  from `std::sync`;  and `Lazy` for lazy initialisation.\n"
"* The [`once_cell`][2] crate also has some useful types for late initialisation with a slightly\n"
"  different approach to `spin::once::Once`.\n"
"* The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""

#: src/bare-metal/android.md:1
msgid "# Android"
msgstr "# Android"

#: src/bare-metal/android.md:3
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a `rust_ffi_static` Soong rule to "
"build\n"
"your Rust code, then a `cc_binary` with a linker script to produce the binary itself, and then a\n"
"`raw_binary` to convert the ELF to a raw binary ready to be run."
msgstr ""

#: src/bare-metal/android.md:7
msgid ""
"```soong\n"
"rust_ffi_static {\n"
"    name: \"libvmbase_example\",\n"
"    defaults: [\"vmbase_ffi_defaults\"],\n"
"    crate_name: \"vmbase_example\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libvmbase\",\n"
"    ],\n"
"}\n"
"\n"
"cc_binary {\n"
"    name: \"vmbase_example\",\n"
"    defaults: [\"vmbase_elf_defaults\"],\n"
"    srcs: [\n"
"        \"idmap.S\",\n"
"    ],\n"
"    static_libs: [\n"
"        \"libvmbase_example\",\n"
"    ],\n"
"    linker_scripts: [\n"
"        \"image.ld\",\n"
"        \":vmbase_sections\",\n"
"    ],\n"
"}\n"
"\n"
"raw_binary {\n"
"    name: \"vmbase_example_bin\",\n"
"    stem: \"vmbase_example.bin\",\n"
"    src: \":vmbase_example\",\n"
"    enabled: false,\n"
"    target: {\n"
"        android_arm64: {\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:1
msgid "# vmbase"
msgstr ""

#: src/bare-metal/android/vmbase.md:3
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase][1] library provides a linker script and "
"useful\n"
"defaults for the build rules, along with an entry point, UART console logging and more."
msgstr ""

#: src/bare-metal/android/vmbase.md:6
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use vmbase::{main, println};\n"
"\n"
"main!(main);\n"
"\n"
"pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
"    println!(\"Hello world\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:21
msgid ""
"* The `main!` macro marks your main function, to be called from the `vmbase` entry point.\n"
"* The `vmbase` entry point handles console initialisation, and issues a PSCI_SYSTEM_OFF to "
"shutdown\n"
"  the VM if your main function returns."
msgstr ""

#: src/exercises/bare-metal/afternoon.md:3
msgid "We will write a driver for the PL031 real-time clock device."
msgstr ""

#: src/exercises/bare-metal/rtc.md:1
msgid "# RTC driver"
msgstr ""

#: src/exercises/bare-metal/rtc.md:3
msgid ""
"The QEMU aarch64 virt machine has a [PL031][1] real-time clock at 0x9010000. For this exercise, "
"you\n"
"should write a driver for it."
msgstr ""

#: src/exercises/bare-metal/rtc.md:6
msgid ""
"1. Use it to print the current time to the serial console. You can use the [`chrono`][2] crate "
"for\n"
"   date/time formatting.\n"
"2. Use the match register and raw interrupt status to busy-wait until a given time, e.g. 3 "
"seconds\n"
"   in the future. (Call [`core::hint::spin_loop`][3] inside the loop.)\n"
"3. _Extension if you have time:_ Enable and handle the interrupt generated by the RTC match. You "
"can\n"
"   use the driver provided in the [`arm-gic`][4] crate to configure the Arm Generic Interrupt "
"Controller.\n"
"   - Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`.\n"
"   - Once the interrupt is enabled, you can put the core to sleep via `arm_gic::wfi()`, which will "
"cause the core to sleep until it receives an interrupt.\n"
"   "
msgstr ""

#: src/exercises/bare-metal/rtc.md:16
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and look in the `rtc`\n"
"directory for the following files."
msgstr ""

#: src/exercises/bare-metal/rtc.md:23
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Create instance of RTC driver and print current time.\n"
"\n"
"    // TODO: Wait for 3 seconds.\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:75
msgid "`src/exceptions.rs` (you should only need to change this for the 3rd part of the exercise):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:77
msgid "<!-- File src/exceptions.rs -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:79
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
msgid "`src/logger.rs` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:151
msgid "<!-- File src/logger.rs -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:153
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: main\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:210
msgid "`src/pl011.rs` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:212
msgid "<!-- File src/pl011.rs -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:214
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Flags\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART Receive Status Register / Error Clear Register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 << 0;\n"
"        /// Parity error.\n"
"        const PE = 1 << 1;\n"
"        /// Break error.\n"
"        const BE = 1 << 2;\n"
"        /// Overrun error.\n"
"        const OE = 1 << 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Registers\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registers\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of a\n"
"    /// PL011 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:389
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"rtc\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"arm-gic = \"0.1.0\"\n"
"bitflags = \"2.0.0\"\n"
"chrono = { version = \"0.4.24\", default-features = false }\n"
"log = \"0.4.17\"\n"
"smccc = \"0.1.1\"\n"
"spin = \"0.9.8\"\n"
"\n"
"[build-dependencies]\n"
"cc = \"1.0.73\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:410
msgid "`build.rs` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:412
msgid "<!-- File build.rs -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:414
#, fuzzy
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."

#: src/exercises/bare-metal/rtc.md:446
msgid "`entry.S` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:448
msgid "<!-- File entry.S -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:450
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << 28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | ."
"L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations required to prepare "
"the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-"
"x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:595
msgid "`exceptions.S` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:597
msgid "<!-- File exceptions.S -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:599
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,\n"
" * which can be used as the first and second arguments of a subsequent call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving 18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:780
msgid "`idmap.S` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:782
msgid "<!-- File idmap.S -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:784
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:829
msgid "`image.ld` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:831
msgid "<!-- File image.ld -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:833
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:940
msgid "`Makefile` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:942
msgid "<!-- File Makefile -->"
msgstr ""

#: src/exercises/bare-metal/rtc.md:944
#, fuzzy
msgid ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"# you may not use this file except in compliance with the License.\n"
"# You may obtain a copy of the License at\n"
"#\n"
"#      http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Unless required by applicable law or agreed to in writing, software\n"
"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"# See the License for the specific language governing permissions and\n"
"# limitations under the License.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel "
"$< -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"
msgstr ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."

#: src/exercises/bare-metal/rtc.md:989
msgid ""
"```toml\n"
"[build]\n"
"target = \"aarch64-unknown-none\"\n"
"rustflags = [\"-C\", \"link-arg=-Timage.ld\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:995
msgid "Run the code in QEMU with `make qemu`."
msgstr ""

#: src/concurrency.md:1
#, fuzzy
msgid "# Welcome to Concurrency in Rust"
msgstr "# Bem-vindo ao Comprehensive Rust ü¶Ä"

#: src/concurrency.md:3
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust tem suporte total para concorr√™ncia usando _threads_ do SO com _mutexes_ e\n"
"_channels_ (canais)."

#: src/concurrency.md:6
msgid ""
"The Rust type system plays an important role in making many concurrency bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"O sistema de tipos do Rust desempenha um papel importante na convers√£o de muitos erros de "
"concorr√™ncia\n"
"em erros de tempo de compila√ß√£o. Isso geralmente √© chamado de _concorr√™ncia sem medo_, pois voc√™\n"
"pode confiar no compilador para garantir a exatid√£o no tempo de execu√ß√£o."

#: src/concurrency/threads.md:1
msgid "# Threads"
msgstr "# Threads"

#: src/concurrency/threads.md:3
msgid "Rust threads work similarly to threads in other languages:"
msgstr "_Threads_ em Rust funcionam de maneira semelhante √†s _threads_ em outras linguagens:"

#: src/concurrency/threads.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Contador na thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"

#: src/concurrency/threads.md:24
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* _Threads_ s√£o todas \"_daemon threads_\", o _thread_ principal n√£o espera por elas.\n"
"* \"_Panics_\" em _threads_ s√£o independentes uns dos outros.\n"
"  * \"_Panics_\" podem carregar um _payload_ (carga √∫til), que pode ser descompactado com "
"`downcast_ref`."

#: src/concurrency/threads.md:32
msgid ""
"* Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is\n"
"  not waiting.\n"
"\n"
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for\n"
"  the thread to finish.\n"
"\n"
"* Trigger a panic in the thread, notice how this doesn't affect `main`.\n"
"\n"
"* Use the `Result` return value from `handle.join()` to get access to the panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""

#: src/concurrency/scoped-threads.md:1
msgid "# Scoped Threads"
msgstr "# Threads com Escopo"

#: src/concurrency/scoped-threads.md:3
msgid "Normal threads cannot borrow from their environment:"
msgstr "_Threads_ normais n√£o podem emprestar de seu ambiente:"

#: src/concurrency/scoped-threads.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Ol√°!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:17
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "No entanto, voc√™ pode usar uma [_thread_ com escopo][1] para isso:"

#: src/concurrency/scoped-threads.md:19
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Comprimento: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"

#: src/concurrency/scoped-threads.md:37
#, fuzzy
msgid ""
"* The reason for that is that when the `thread::scope` function completes, all the threads are "
"guaranteed to be joined, so they can return borrowed data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by "
"any number of threads.\n"
"    "
msgstr ""
"<details>\n"
"    \n"
"* A raz√£o para isso √© que, quando a fun√ß√£o `thread::scope` for conclu√≠da, todas as _threads_ ser√£o "
"unidas, para que possam retornar dados emprestados.\n"
"* Aplicam-se as regras normais de empr√©stimo do Rust: o empr√©stimo pode ser mut√°vel, para uma "
"`thread` ou imut√°vel para\n"
"qualquer n√∫mero de _threads_.\n"
"    \n"
"</details>"

#: src/concurrency/channels.md:1
msgid "# Channels"
msgstr "# Channels (Canais)"

#: src/concurrency/channels.md:3
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"Os _channels_ (canais) em Rust t√™m duas partes: um `Sender<T>` e um `Receiver<T>`. As duas partes\n"
"est√£o conectadas atrav√©s do _channel_, mas voc√™ s√≥ v√™ os _end-points_."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` implement `Clone` "
"(so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the counterpart `Sender` "
"or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` significa Multi-Produtor, √önico-Consumidor. `Sender` e `SyncSender` implementam `Clone` "
"(ent√£o\n"
"  voc√™ pode criar v√°rios produtores), mas `Receiver` (consumidores) n√£o.\n"
"* `send()` e `recv()` retornam `Result`. Se retornarem `Err`, significa que a contraparte `Sender` "
"ou\n"
"  `Receiver` √© descartada e o canal √© fechado."

#: src/concurrency/channels/unbounded.md:1
msgid "# Unbounded Channels"
msgstr "# Canais ilimitados"

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Voc√™ obt√©m um canal ilimitado e ass√≠ncrono com `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Mensagem {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: enviando a mensagem: {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: feito\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"

#: src/concurrency/channels/bounded.md:1
msgid "# Bounded Channels"
msgstr "# Canais Delimitados"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid "With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "Canais limitados e s√≠ncronos fazem `send` bloquear o _thread_ atual:"

#: src/concurrency/channels/bounded.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Mensagem {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: enviando a mensagem: {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: feito\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"

#: src/concurrency/channels/bounded.md:31
msgid ""
"* Calling `send` will block the current thread until there is space in the channel for the new "
"message. The thread can be blocked indefinitely if there is nobody who reads from the channel.\n"
"* A call to `send` will abort with an error (that is why it returns `Result`) if the channel is "
"closed. A channel is closed when the receiver is dropped.\n"
"* A bounded channel with a size of zero is called a \"rendezvous channel\". Every send will block "
"the current thread until another thread calls `read`.\n"
"    "
msgstr ""

#: src/concurrency/send-sync.md:1
msgid "# `Send` and `Sync`"
msgstr "# `Send` e `Sync`"

#: src/concurrency/send-sync.md:3
msgid "How does Rust know to forbid shared access across thread? The answer is in two traits:"
msgstr ""
"Como o Rust sabe proibir o acesso compartilhado entre threads? A resposta est√° em duas "
"caracter√≠sticas:"

#: src/concurrency/send-sync.md:5
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a thread\n"
"  boundary."
msgstr ""
"* [`Send`][1]: um tipo `T` √© `Send` se for seguro mover um `T` entre _threads_\n"
"* [`Sync`][2]: um tipo `T` √© `Sync` se for seguro mover um `&T` entre _threads_"

#: src/concurrency/send-sync.md:10
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically derive them for your "
"types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement them manually when "
"you\n"
"know it is valid."
msgstr ""
"`Send` e `Sync` s√£o [`unsafe traits`][3]. O compilador os derivar√° automaticamente para seus "
"tipos\n"
"desde que contenham apenas os tipos `Send` e `Sync`. Voc√™ tamb√©m pode implement√°-los manualmente "
"quando\n"
"souber que s√£o v√°lidos."

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"* One can think of these traits as markers that the type has certain thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  "
msgstr ""
"* Pode-se pensar nesses _traits_ como marcadores de que o tipo possui certas propriedades de "
"seguran√ßa de _threads_.\n"
"* Eles podem ser usados nas restri√ß√µes gen√©ricas como _traits_ normais.\n"
"  \n"
"</details>"

#: src/concurrency/send-sync/send.md:1
msgid "# `Send`"
msgstr "# `Send`"

#: src/concurrency/send-sync/send.md:3
msgid "> A type `T` is [`Send`][1] if it is safe to move a `T` value to another thread."
msgstr "> Um tipo `T` √© [`Send`][1] se for seguro mover um valor `T` para outro _thread_."

#: src/concurrency/send-sync/send.md:5
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will run\n"
"in that thread. So the question is when you can allocate a value in one thread\n"
"and deallocate it in another."
msgstr ""
"O efeito de mover a propriedade (ownership) para outro _thread_ √© que os _destructors_ ser√£o "
"executados\n"
"nessa _thread_. Ent√£o a quest√£o √©: quando voc√™ pode alocar um valor em um _thread_\n"
"e desaloc√°-lo em outro?"

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from a\n"
"single thread."
msgstr ""

#: src/concurrency/send-sync/sync.md:1
msgid "# `Sync`"
msgstr "# `Sync`"

#: src/concurrency/send-sync/sync.md:3
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from multiple\n"
"> threads at the same time."
msgstr ""
"> Um tipo `T` √© [`Sync`][1] se for seguro acessar um valor `T` de v√°rias\n"
"> threads ao mesmo tempo."

#: src/concurrency/send-sync/sync.md:6
msgid "More precisely, the definition is:"
msgstr "Mais precisamente, a defini√ß√£o √©:"

#: src/concurrency/send-sync/sync.md:8
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> `T` √© `Sync` se e somente se `&T` √© `Send`"

#: src/concurrency/send-sync/sync.md:14
msgid ""
"This statement is essentially a shorthand way of saying that if a type is thread-safe for shared "
"use, it is also thread-safe to pass references of it across threads."
msgstr ""
"Essa instru√ß√£o √© essencialmente uma maneira abreviada de dizer que, se um tipo √© _thread-safe_ "
"para uso compartilhado, tamb√©m √© _thread-safe_ passar refer√™ncias a ele entre _threads_."

#: src/concurrency/send-sync/sync.md:16
msgid ""
"This is because if a type is Sync it means that it can be shared across multiple threads without "
"the risk of data races or other synchronization issues, so it is safe to move it to another "
"thread. A reference to the type is also safe to move to another thread, because the data it "
"references can be accessed from any thread safely."
msgstr ""
"Isso ocorre porque, se um tipo for `Sync`, significa que ele pode ser compartilhado entre v√°rios "
"_threads_ sem o risco de corridas de dados ou outros problemas de sincroniza√ß√£o, portanto, √© "
"seguro mov√™-lo para outro _thread_. Uma refer√™ncia ao tipo tamb√©m √© segura para mover para outro "
"_thread_, porque os dados a que ela faz refer√™ncia podem ser acessados de qualquer _thread_ com "
"seguran√ßa."

#: src/concurrency/send-sync/examples.md:1
msgid "# Examples"
msgstr "# Exemplos"

#: src/concurrency/send-sync/examples.md:3
msgid "## `Send + Sync`"
msgstr "## `Send + Sync`"

#: src/concurrency/send-sync/examples.md:5
msgid "Most types you come across are `Send + Sync`:"
msgstr "A maioria dos tipos que voc√™ encontra s√£o `Send + Sync`:"

#: src/concurrency/send-sync/examples.md:7
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitamente _thread-safe_ via contagem de refer√™ncia at√¥mica.\n"
"* `Mutex<T>`: Explicitamente _thread-safe_ via bloqueio interno.\n"
"* `AtomicBool`, `AtomicU8`, ...: Usa instru√ß√µes at√¥micas especiais."

#: src/concurrency/send-sync/examples.md:14
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"Os tipos gen√©ricos s√£o tipicamente `Send + Sync` quando os par√¢metros de tipo s√£o\n"
"`Send + Sync`."

#: src/concurrency/send-sync/examples.md:17
msgid "## `Send + !Sync`"
msgstr "## `Send + !Sync`"

#: src/concurrency/send-sync/examples.md:19
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"Esses tipos podem ser movidos para outras _threads_, mas n√£o s√£o seguros para _threads_.\n"
"Normalmente por causa da mutabilidade interior:"

#: src/concurrency/send-sync/examples.md:22
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
msgid "## `!Send + Sync`"
msgstr "## `!Send + Sync`"

#: src/concurrency/send-sync/examples.md:29
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr "Esses tipos s√£o _thread-safe_, mas n√£o podem ser movidos para outro _thread_:"

#: src/concurrency/send-sync/examples.md:31
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on the\n"
"  thread which created them."
msgstr ""
"* `MutexGuard<T>`: Usa primitivas a n√≠vel de sistema operacional que devem ser desalocadas no\n"
" _thread_ que as criou."

#: src/concurrency/send-sync/examples.md:34
msgid "## `!Send + !Sync`"
msgstr "## `!Send + !Sync`"

#: src/concurrency/send-sync/examples.md:36
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr "Esses tipos n√£o s√£o _thread-safe_ e n√£o podem ser movidos para outros _threads_:"

#: src/concurrency/send-sync/examples.md:38
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: cada `Rc<T>` tem uma refer√™ncia a um `RcBox<T>`, que cont√©m uma\n"
"  contagem de refer√™ncia n√£o at√¥mica.\n"
"* `*const T`, `*mut T`: Rust assume que ponteiros brutos podem ter\n"
"  considera√ß√µes de especiais de concorr√™ncia."

#: src/concurrency/shared_state.md:1
msgid "# Shared State"
msgstr "# Estado Compartilhado"

#: src/concurrency/shared_state.md:3
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is\n"
"primarily done via two types:"
msgstr ""
"Rust usa o sistema de tipos para impor a sincroniza√ß√£o de dados compartilhados. Isso √©\n"
"feito principalmente atrav√©s de dois tipos:"

#: src/concurrency/shared_state.md:6
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], refer√™ncia at√¥mica contada `T`: manipula o compartilhamento entre _threads_ e\n"
"  toma o cuidado de desalocar `T` quando a √∫ltima refer√™ncia √© descartada,\n"
"* [`Mutex<T>`][2]: garante acesso mutuamente exclusivo ao valor `T`."

#: src/concurrency/shared_state/arc.md:1
msgid "# `Arc`"
msgstr "# `Arc`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid "[`Arc<T>`][1] allows shared read-only access via `Arc::clone`:"
msgstr "[`Arc<T>`][1] permite acesso somente leitura compartilhado por meio de seu m√©todo `clone`:"

#: src/concurrency/shared_state/arc.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"

#: src/concurrency/shared_state/arc.md:29
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but after that the use of "
"the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc` significa \"Atomic Reference Counted\", uma vers√£o _thread-safe_ de `Rc` que usa opera√ß√µes "
"at√¥micas.\n"
"* `Arc<T>` implementa `Clone` quer `T` o fa√ßa ou n√£o. Ele implementa `Send` e `Sync` se `T`\n"
"  implementa os dois.\n"
"* `Arc::clone()` tem o custo das opera√ß√µes at√¥micas que s√£o executadas, mas depois disso o uso do\n"
"  `T` √© gratuito.\n"
"* Cuidado com os ciclos de refer√™ncia, `Arc` n√£o usa um coletor de lixo para detect√°-los.\n"
"    * `std::sync::Weak` pode ajudar."

#: src/concurrency/shared_state/mutex.md:1
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"[`Mutex<T>`][1] garante exclus√£o m√∫tua _e_ permite acesso mut√°vel a `T`\n"
"por tr√°s de uma interface somente leitura:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr ""
"Observe como temos uma implementa√ß√£o [`impl<T: Send> Sync for Mutex<T>`][2]\n"
"encoberta."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"* `Mutex` in Rust looks like a collection with just one element - the protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The `MutexGuard` ensures that "
"the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes \"poisoned\" to signal "
"that\n"
"      the data it protected might be in an inconsistent state. Calling `lock()` on a poisoned "
"mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error to recover the data\n"
"      regardless."
msgstr ""
"<details>\n"
"    \n"
"* `Mutex` em Rust parece uma cole√ß√£o com apenas um elemento - os dados protegidos.\n"
"    * N√£o √© poss√≠vel esquecer de adquirir o mutex antes de acessar os dados protegidos.\n"
"* Voc√™ pode obter um `&mut T` de um `&Mutex<T>` obtendo um bloqueio (_lock_). O `MutexGuard` "
"garante que o\n"
"  `&mut T` n√£o sobrevive al√©m do bloqueio (_lock_).\n"
"* `Mutex<T>` implementa `Send` e `Sync` se `T` implementa `Send`.\n"
"* O bloqueio para leitura e grava√ß√£o - `RwLock`.\n"
"* Por que `lock()` retorna um `Result`?\n"
"    * Se o thread que manteve o `Mutex` entrou em p√¢nico, o `Mutex` torna-se \"envenenado\" para "
"sinalizar que\n"
"      os dados protegidos podem estar em um estado inconsistente. Ao chamar `lock()` em um mutex "
"envenenado\n"
"      o retorno √© uma falha com um [`PoisonError`]. Voc√™ pode chamar `into_inner()` no erro para "
"recuperar os dados\n"
"      independentemente."

#: src/concurrency/shared_state/example.md:3
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Vamos ver `Arc` e `Mutex` em a√ß√£o:"

#: src/concurrency/shared_state/example.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"

#: src/concurrency/shared_state/example.md:23
msgid "Possible solution:"
msgstr ""

#: src/concurrency/shared_state/example.md:25
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:49
msgid "Notable parts:"
msgstr ""

#: src/concurrency/shared_state/example.md:51
#, fuzzy
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another thread. Note `move` "
"was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as possible."
msgstr ""
"* `v` √© agrupado em ambos `Arc` e `Mutex`, porque seus interesses s√£o ortogonais.\n"
"  * Envolver um `Mutex` em um `Arc` √© um padr√£o comum para compartilhar o estado mut√°vel entre "
"threads.\n"
"* `v: Arc<_>` precisa ser clonado como `v2` antes que possa ser movido para outro thread. Note que "
"`move` foi adicionado √† assinatura lambda.\n"
"* Os blocos s√£o introduzidos para restringir o escopo do `LockGuard` tanto quanto poss√≠vel.\n"
"* Ainda precisamos adquirir o `Mutex` para imprimir nosso `Vec`."

#: src/exercises/concurrency/morning.md:3
msgid "Let us practice our new concurrency skills with"
msgstr "Vamos praticar nossas novas habilidades de concorr√™ncia com:"

#: src/exercises/concurrency/morning.md:5
#, fuzzy
msgid ""
"* Dining philosophers: a classic problem in concurrency.\n"
"\n"
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"* Verificador de link _multi-threads_: um projeto maior  no qual voc√™ usar√° o Cargo para\n"
"  baixar as depend√™ncias e tamb√©m verificar os links em paralelo."

#: src/exercises/concurrency/dining-philosophers.md:1
msgid "# Dining Philosophers"
msgstr "# Fil√≥sofos jantando"

#: src/exercises/concurrency/dining-philosophers.md:3
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "O problema dos fil√≥sofos jantando √© um problema cl√°ssico em concorr√™ncia:"

#: src/exercises/concurrency/dining-philosophers.md:5
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has their\n"
"> own place at the table. There is a fork between each plate. The dish served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will only\n"
"> be available when their two nearest neighbors are thinking, not eating. After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> Cinco fil√≥sofos jantam juntos na mesma mesa. Cada fol√≥sofo tem seu\n"
"> pr√≥prio lugar √† mesa. H√° um garfo entre cada prato. O prato servido √©\n"
"> uma esp√©cie de espaguete que se come com dois garfos. Cada fil√≥sofo pode\n"
"> somente pensar ou comer, alternadamente. Al√©m disso, um fil√≥sofo s√≥ pode comer seu\n"
"> espaguete quando ele t√™m garfo esquerdo e direito. Assim, dois garfos s√≥\n"
"> estar√£o dispon√≠veis quando seus dois vizinhos mais pr√≥ximos estiverem pensando, n√£o comendo. "
"Depois de\n"
"> um fil√≥sofo individual termina de comer, ele abaixa os dois garfos."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) for\n"
"this exercise. Copy the code below to a file called `src/main.rs`, fill out the\n"
"blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Voc√™ precisar√° de uma [instala√ß√£o do Cargo][../../cargo/running-locally.md] local para\n"
"esse exerc√≠cio. Copie o c√≥digo abaixo para o arquivo `src/main.rs`, preencha os espa√ßos em "
"branco,\n"
"e teste se `cargo run` n√£o trava:"

#: src/exercises/concurrency/dining-philosophers.md:19
msgid ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
msgid "You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:1
msgid "# Multi-threaded Link Checker"
msgstr "# Verificador de links _multi-threads_"

#: src/exercises/concurrency/link-checker.md:3
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until all\n"
"pages have been validated."
msgstr ""
"Vamos usar nosso novo conhecimento para criar um verificador de links _multi-threads_. \n"
"Comece em uma p√°gina da web e verifique se os links na p√°gina s√£o v√°lidos. \n"
"Verifique recursivamente outras p√°ginas no mesmo dom√≠nio e continue fazendo isso at√© que todas\n"
"as p√°ginas tenham sido validadas."

#: src/exercises/concurrency/link-checker.md:8
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Para isso, voc√™ precisar√° de um cliente HTTP como [`reqwest`][1]. Crie um novo\n"
"Project com o Cargo e adicione `reqwest` como uma depend√™ncia:"

#: src/exercises/concurrency/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"

#: src/exercises/concurrency/link-checker.md:17
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> Se `cargo add` falhar com `error: no such subcommand`, edite o\n"
"> arquivo `Cargo.toml` √† m√£o. Adicione as depend√™ncias listadas abaixo."

#: src/exercises/concurrency/link-checker.md:20
msgid "You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr ""
"Voc√™ tamb√©m precisar√° de uma maneira de encontrar links. Podemos usar [`scraper`][2] para isso:"

#: src/exercises/concurrency/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""
"```shell\n"
"$ cargo add scraper\n"
"```"

#: src/exercises/concurrency/link-checker.md:26
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] for\n"
"that:"
msgstr ""
"Por fim, precisaremos de alguma forma de lidar com os erros. Usamos [`thiserror`][3] para\n"
"isso:"

#: src/exercises/concurrency/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""
"```shell\n"
"$ cargo add thiserror\n"
"```"

#: src/exercises/concurrency/link-checker.md:33
msgid "The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "As chamadas `cargo add` ir√£o atualizar o arquivo `Cargo.toml` para ficar assim:"

#: src/exercises/concurrency/link-checker.md:37
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[depend√™ncias]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/concurrency/link-checker.md:50
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"Agora voc√™ pode baixar a p√°gina inicial. Tente com um pequeno site como\n"
"`https://www.google.org/`."

#: src/exercises/concurrency/link-checker.md:53
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Seu arquivo `src/main.rs` deve se parecer com isto:"

#: src/exercises/concurrency/link-checker.md:57
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}\n"
"\n"
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"\n"
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: {err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Ok(valid_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:100
msgid "Run the code in `src/main.rs` with"
msgstr "Execute o c√≥digo em `src/main.rs` com"

#: src/exercises/concurrency/link-checker.md:102
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/exercises/concurrency/link-checker.md:106 src/exercises/concurrency/chat-app.md:140
msgid "## Tasks"
msgstr "## Tarefas"

#: src/exercises/concurrency/link-checker.md:108
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that you\n"
"  don't end up being blocked by the site."
msgstr ""
"* Use _threads_ para verificar os links em paralelo: envie as URLs a serem verificadas para um\n"
"  _channel_ e deixe alguns _threads_ verificarem as URLs em paralelo.\n"
"* Estenda isso para extrair recursivamente links de todas as p√°ginas no\n"
"  dom√≠nio `www.google.org`. Coloque um limite m√°ximo de 100 p√°ginas ou menos para que voc√™\n"
"  n√£o acabe sendo bloqueado pelo site."

#: src/async.md:1
#, fuzzy
msgid "# Async Rust"
msgstr "# Por que Rust?"

#: src/async.md:3
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed concurrently by\n"
"executing each task until it would block, then switching to another task that is\n"
"ready to make progress. The model allows running a larger number of tasks on a\n"
"limited number of threads. This is because the per-task overhead is typically\n"
"very low and operating systems provide primitives for efficiently identifying\n"
"I/O that is able to proceed."
msgstr ""

#: src/async.md:10
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work that\n"
"may be completed in the future. Futures are \"polled\" until they signal that\n"
"they are complete."
msgstr ""

#: src/async.md:14
msgid ""
"Futures are polled by an async runtime, and several different runtimes are\n"
"available."
msgstr ""

#: src/async.md:17
#, fuzzy
msgid "## Comparisons"
msgstr "# Compara√ß√£o"

#: src/async.md:19
msgid ""
" * Python has a similar model in its `asyncio`. However, its `Future` type is\n"
"   callback-based, and not polled. Async Python programs require a \"loop\",\n"
"   similar to a runtime in Rust.\n"
"\n"
" * JavaScript's `Promise` is similar, but again callback-based. The language\n"
"   runtime implements the event loop, so many of the details of Promise\n"
"   resolution are hidden."
msgstr ""

#: src/async/async-await.md:1
msgid "# `async`/`await`"
msgstr ""

#: src/async/async-await.md:3
msgid "At a high level, async Rust code looks very much like \"normal\" sequential code:"
msgstr ""

#: src/async/async-await.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"
msgstr ""

#: src/async/async-await.md:27
msgid ""
"* Note that this is a simplified example to show the syntax. There is no long\n"
"  running operation or any real concurrency in it!\n"
"\n"
"* What is the return type of an async call?\n"
"  * Use `let future: () = async_main(10);` in `main` to see the type.\n"
"\n"
"* The \"async\" keyword is syntactic sugar. The compiler replaces the return type\n"
"  with a future. \n"
"\n"
"* You cannot make `main` async, without additional instructions to the compiler\n"
"  on how to use the returned future.\n"
"\n"
"* You need an executor to run async code. `block_on` blocks the current thread\n"
"  until the provided future has run to completion. \n"
"\n"
"* `.await` asynchronously waits for the completion of another operation. Unlike\n"
"  `block_on`, `.await` doesn't block the current thread.\n"
"\n"
"* `.await` can only be used inside an `async` function (or block; these are\n"
"  introduced later). "
msgstr ""

#: src/async/futures.md:1
#, fuzzy
msgid "# Futures"
msgstr "# Closures"

#: src/async/futures.md:3
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)\n"
"is a trait, implemented by objects that represent an operation that may not be\n"
"complete yet. A future can be polled, and `poll` returns a\n"
"[`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""

#: src/async/futures.md:8
msgid ""
"```rust\n"
"use std::pin::Pin;\n"
"use std::task::Context;\n"
"\n"
"pub trait Future {\n"
"    type Output;\n"
"    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n"
"}\n"
"\n"
"pub enum Poll<T> {\n"
"    Ready(T),\n"
"    Pending,\n"
"}\n"
"```"
msgstr ""

#: src/async/futures.md:23
msgid ""
"An async function returns an `impl Future`. It's also possible (but uncommon) to\n"
"implement `Future` for your own types. For example, the `JoinHandle` returned\n"
"from `tokio::spawn` implements `Future` to allow joining to it."
msgstr ""

#: src/async/futures.md:27
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function to\n"
"pause until that Future is ready, and then evaluates to its output."
msgstr ""

#: src/async/futures.md:32
msgid ""
"* The `Future` and `Poll` types are implemented exactly as shown; click the\n"
"  links to show the implementations in the docs.\n"
"\n"
"* We will not get to `Pin` and `Context`, as we will focus on writing async\n"
"  code, rather than building new async primitives. Briefly:\n"
"\n"
"  * `Context` allows a Future to schedule itself to be polled again when an\n"
"    event occurs.\n"
"\n"
"  * `Pin` ensures that the Future isn't moved in memory, so that pointers into\n"
"    that future remain valid. This is required to allow references to remain\n"
"    valid after an `.await`."
msgstr ""

#: src/async/runtimes.md:1
#, fuzzy
msgid "# Runtimes"
msgstr "# Garantias de tempo de execu√ß√£o"

#: src/async/runtimes.md:3
msgid ""
"A *runtime* provides support for performing operations asynchronously (a\n"
"*reactor*) and is responsible for executing futures (an *executor*). Rust does not have a\n"
"\"built-in\" runtime, but several options are available:"
msgstr ""

#: src/async/runtimes.md:7
msgid ""
" * [Tokio](https://tokio.rs/) - performant, with a well-developed ecosystem of\n"
"   functionality like [Hyper](https://hyper.rs/) for HTTP or\n"
"   [Tonic](https://github.com/hyperium/tonic) for gRPC.\n"
" * [async-std](https://async.rs/) - aims to be a \"std for async\", and includes a\n"
"   basic runtime in `async::task`.\n"
" * [smol](https://docs.rs/smol/latest/smol/) - simple and lightweight"
msgstr ""

#: src/async/runtimes.md:14
msgid ""
"Several larger applications have their own runtimes. For example,\n"
"[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib."
"rs)\n"
"already has one."
msgstr ""

#: src/async/runtimes.md:20
msgid ""
"* Note that of the listed runtimes, only Tokio is supported in the Rust\n"
"  playground. The playground also does not permit any I/O, so most interesting\n"
"  async things can't run in the playground.\n"
"\n"
"* Futures are \"inert\" in that they do not do anything (not even start an I/O\n"
"  operation) unless there is an executor polling them. This differs from JS\n"
"  Promises, for example, which will run to completion even if they are never\n"
"  used."
msgstr ""

#: src/async/runtimes/tokio.md:1
msgid "# Tokio"
msgstr ""

#: src/async/runtimes/tokio.md:4
msgid "Tokio provides: "
msgstr ""

#: src/async/runtimes/tokio.md:6
msgid ""
"* A multi-threaded runtime for executing asynchronous code.\n"
"* An asynchronous version of the standard library.\n"
"* A large ecosystem of libraries."
msgstr ""

#: src/async/runtimes/tokio.md:10
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main task: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/runtimes/tokio.md:33
msgid ""
"* With the `tokio::main` macro we can now make `main` async.\n"
"\n"
"* The `spawn` function creates a new, concurrent \"task\".\n"
"\n"
"* Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""

#: src/async/runtimes/tokio.md:39
msgid "**Further exploration:**"
msgstr ""

#: src/async/runtimes/tokio.md:41
msgid ""
"* Why does `count_to` not (usually) get to 10? This is an example of async\n"
"  cancellation. `tokio::spawn` returns a handle which can be awaited to wait\n"
"  until it finishes.\n"
"\n"
"* Try `count_to(10).await` instead of spawning.\n"
"\n"
"* Try awaiting the task returned from `tokio::spawn`."
msgstr ""

#: src/async/tasks.md:1
#, fuzzy
msgid "# Tasks"
msgstr "## Tarefas"

#: src/async/tasks.md:3
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr ""

#: src/async/tasks.md:5
msgid ""
"A task has a single top-level future which the executor polls to make progress.\n"
"That future may have one or more nested futures that its `poll` method polls,\n"
"corresponding loosely to a call stack. Concurrency within a task is possible by\n"
"polling multiple child futures, such as racing a timer and an I/O operation."
msgstr ""

#: src/async/tasks.md:10
msgid ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"connection from {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await {\n"
"                println!(\"socket error: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap().trim();\n"
"                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"socket error: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"socket error: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/tasks.md:52 src/async/control-flow/join.md:36
msgid "Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""

#: src/async/tasks.md:54
msgid ""
"* Ask students to visualize what the state of the example server would be with a\n"
"  few connected clients. What tasks exist? What are their Futures?\n"
"\n"
"* This is the first time we've seen an `async` block. This is similar to a\n"
"  closure, but does not take any arguments. Its return value is a Future,\n"
"  similar to an `async fn`. \n"
"\n"
"* Refactor the async block into a function, and improve the error handling using `?`."
msgstr ""

#: src/async/channels.md:1
#, fuzzy
msgid "# Async Channels"
msgstr "# Channels (Canais)"

#: src/async/channels.md:3
msgid "Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""

#: src/async/channels.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    std::mem::drop(sender);\n"
"    ping_handler_task.await.expect(\"Something went wrong in ping handler task.\");\n"
"}\n"
"```"
msgstr ""

#: src/async/channels.md:35
msgid ""
"* Change the channel size to `3` and see how it affects the execution.\n"
"\n"
"* Overall, the interface is similar to the `sync` channels as seen in the\n"
"  [morning class](concurrency/channels.md).\n"
"\n"
"* Try removing the `std::mem::drop` call. What happens? Why?\n"
"\n"
"* The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that\n"
"  implement both `sync` and `async` `send` and `recv`. This can be convenient\n"
"  for complex applications with both IO and heavy CPU processing tasks.\n"
"\n"
"* What makes working with `async` channels preferable is the ability to combine\n"
"  them with other `future`s to combine them and create complex control flow."
msgstr ""

#: src/async/control-flow.md:1
#, fuzzy
msgid "# Futures Control Flow"
msgstr "# Controle de fluxo"

#: src/async/control-flow.md:3
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. We\n"
"have already seen tasks, that function as independent threads of execution."
msgstr ""

#: src/async/control-flow.md:6
msgid ""
"- [Join](control-flow/join.md)\n"
"- [Select](control-flow/select.md)"
msgstr ""

#: src/async/control-flow/join.md:1
msgid "# Join"
msgstr ""

#: src/async/control-flow/join.md:3
msgid ""
"A join operation waits until all of a set of futures are ready, and\n"
"returns a collection of their results. This is similar to `Promise.all` in\n"
"JavaScript or `asyncio.gather` in Python."
msgstr ""

#: src/async/control-flow/join.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &str) -> Result<usize> {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/join.md:38
msgid ""
"* For multiple futures of disjoint types, you can use `std::future::join!` but\n"
"  you must know how many futures you will have at compile time. This is\n"
"  currently in the `futures` crate, soon to be stabilised in `std::future`.\n"
"\n"
"* The risk of `join` is that one of the futures may never resolve, this would\n"
"  cause your program to stall. \n"
"\n"
"* You can also combine `join_all` with `join!` for instance to join all requests\n"
"  to an http service as well as a database query. Try adding a\n"
"  `tokio::time::sleep` to the future, using `futures::join!`. This is not a\n"
"  timeout (that requires `select!`, explained in the next chapter), but demonstrates `join!`."
msgstr ""

#: src/async/control-flow/select.md:1
#, fuzzy
msgid "# Select"
msgstr "# Configurar"

#: src/async/control-flow/select.md:3
msgid ""
"A select operation waits until any of a set of futures is ready, and responds to\n"
"that future's result. In JavaScript, this is similar to `Promise.race`. In\n"
"Python, it compares to `asyncio.wait(task_set,\n"
"return_when=asyncio.FIRST_COMPLETED)`."
msgstr ""

#: src/async/control-flow/select.md:8
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, each\n"
"of the form `pattern = future => statement`. When the `future` is ready, the\n"
"`statement` is executed with the variables in `pattern` bound to the `future`'s\n"
"result."
msgstr ""

#: src/async/control-flow/select.md:13
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receiver<String>,\n"
"    mut dog_rcv: Receiver<String>,\n"
") -> Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: cat_name? }),\n"
"        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Failed to send cat.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Failed to send dog.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"Winner is {winner:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/select.md:62
msgid ""
"* In this example, we have a race between a cat and a dog.\n"
"  `first_animal_to_finish_race` listens to both channels and will pick whichever\n"
"  arrives first. Since the dog takes 50ms, it wins against the cat that\n"
"  take 500ms seconds.\n"
"\n"
"* You can use `oneshot` channels in this example as the channels are supposed to\n"
"  receive only one `send`.\n"
"\n"
"* Try adding a deadline to the race, demonstrating selecting different sorts of\n"
"  futures.\n"
"\n"
"* Note that `select!` drops unmatched branches, which cancels their futures.\n"
"  It is easiest to use when every execution of `select!` creates new futures.\n"
"\n"
"    * An alternative is to pass `&mut future` instead of the future itself, but\n"
"      this can lead to issues, further discussed in the pinning slide."
msgstr ""

#: src/async/pitfalls.md:1
msgid "# Pitfalls of async/await"
msgstr ""

#: src/async/pitfalls.md:3
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent asynchronous "
"programming. However, the async/await model in Rust also comes with its share of pitfalls and "
"footguns. We illustrate some of them in this chapter:"
msgstr ""

#: src/async/pitfalls.md:5
msgid ""
"- [Blocking the Executor](pitfalls/blocking-executor.md)\n"
"- [Pin](pitfalls/pin.md)\n"
"- [Async Traits](pitfall/async-traits.md)\n"
"- [Cancellation](pitfalls/cancellation.md)"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:1
msgid "# Blocking the executor"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:3
msgid ""
"Most async runtimes only allow IO tasks to run concurrently.\n"
"This means that CPU blocking tasks will block the executor and prevent other tasks from being "
"executed.\n"
"An easy workaround is to use async equivalent methods where possible."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
msgid ""
"* Run the code and see that the sleeps happen consecutively rather than\n"
"  concurrently.\n"
"\n"
"* The `\"current_thread\"` flavor puts all tasks on a single thread. This makes the\n"
"  effect more obvious, but the bug is still present in the multi-threaded\n"
"  flavor.\n"
"\n"
"* Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result.\n"
"\n"
"* Another fix would be to `tokio::task::spawn_blocking` which spawns an actual\n"
"  thread and transforms its handle into a future without blocking the executor.\n"
"\n"
"* You should not think of tasks as OS threads. They do not map 1 to 1 and most\n"
"  executors will allow many tasks to run on a single OS thread. This is\n"
"  particularly problematic when interacting with other libraries via FFI, where\n"
"  that library might depend on thread-local storage or map to specific OS\n"
"  threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such situations.\n"
"\n"
"* Use sync mutexes with care. Holding a mutex over an `.await` may cause another\n"
"  task to block, and that task may be running on the same thread."
msgstr ""

#: src/async/pitfalls/pin.md:1
msgid "# Pin"
msgstr ""

#: src/async/pitfalls/pin.md:3
msgid ""
"When you await a future, all local variables (that would ordinarily be stored on\n"
"a stack frame) are instead stored in the Future for the current async block. If your\n"
"future has pointers to data on the stack, those pointers might get invalidated.\n"
"This is unsafe."
msgstr ""

#: src/async/pitfalls/pin.md:8
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't\n"
"change. That is why we need to `pin` futures. Using the same future repeatedly\n"
"in a `select!` often leads to issues with pinned values."
msgstr ""

#: src/async/pitfalls/pin.md:12
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// A worker which listens for work on a queue and performs it.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() => {\n"
"                sleep(Duration::from_millis(10)).await; // Pretend to work.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"failed to send response\");\n"
"                iterations += 1;\n"
"            }\n"
"            // TODO: report number of iterations every 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// A requester which requests work and waits for it to complete.\n"
"async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"failed to send on work queue\");\n"
"    rx.await.expect(\"failed waiting for response\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:68
msgid ""
"* You may recognize this as an example of the actor pattern. Actors\n"
"  typically call `select!` in a loop.\n"
"\n"
"* This serves as a summation of a few of the previous lessons, so take your time\n"
"  with it.\n"
"\n"
"    * Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }`\n"
"      to the `select!`. This will never execute. Why?\n"
"\n"
"    * Instead, add a `timeout_fut` containing that future outside of the `loop`:\n"
"\n"
"        ```rust,compile_fail\n"
"        let mut timeout_fut = sleep(Duration::from_millis(100));\n"
"        loop {\n"
"            select! {\n"
"                ..,\n"
"                _ = timeout_fut => { println!(..); },\n"
"            }\n"
"        }\n"
"        ```\n"
"    * This still doesn't work. Follow the compiler errors, adding `&mut` to the\n"
"      `timeout_fut` in the `select!` to work around the move, then using\n"
"      `Box::pin`:\n"
"\n"
"        ```rust,compile_fail\n"
"        let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
"        loop {\n"
"            select! {\n"
"                ..,\n"
"                _ = &mut timeout_fut => { println!(..); },\n"
"            }\n"
"        }\n"
"        ```\n"
"\n"
"    * This compiles, but once the timeout expires it is `Poll::Ready` on every\n"
"      iteration (a fused future would help with this). Update to reset\n"
"      `timeout_fut` every time it expires.\n"
"\n"
"* Box allocates on the heap. In some cases, `std::pin::pin!` (only recently\n"
"  stabilized, with older code often using `tokio::pin!`) is also an option, but\n"
"  that is difficult to use for a future that is reassigned.\n"
"\n"
"* Another alternative is to not use `pin` at all but spawn another task that will send to a "
"`oneshot` channel every 100ms."
msgstr ""

#: src/async/pitfalls/async-traits.md:1
#, fuzzy
msgid "# Async Traits"
msgstr "# Traits (Caracter√≠sticas)"

#: src/async/pitfalls/async-traits.md:3
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An experimental feature "
"exists in nightly and should be stabilized in the mid term.](https://blog.rust-lang.org/inside-"
"rust/2022/11/17/async-fn-in-trait-nightly.html))"
msgstr ""

#: src/async/pitfalls/async-traits.md:5
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) provides a workaround "
"through a macro:"
msgstr ""

#: src/async/pitfalls/async-traits.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper for FixedSleeper {\n"
"    async fn sleep(&self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"running all sleepers..\");\n"
"        for sleeper in &sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/async-traits.md:49
#, fuzzy
msgid "<details>  "
msgstr "<details>"

#: src/async/pitfalls/async-traits.md:51
msgid ""
"* `async_trait` is easy to use, but note that it's using heap allocations to\n"
"  achieve this. This heap allocation has performance overhead.\n"
"\n"
"* The challenges in language support for `async trait` are deep Rust and\n"
"  probably not worth describing in-depth. Niko Matsakis did a good job of\n"
"  explaining them in [this\n"
"  post](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/)\n"
"  if you are interested in digging deeper.\n"
"\n"
"* Try creating a new sleeper struct that will sleep for a random amount of time\n"
"  and adding it to the Vec."
msgstr ""

#: src/async/pitfalls/cancellation.md:1
#, fuzzy
msgid "# Cancellation"
msgstr "## Instala√ß√£o"

#: src/async/pitfalls/cancellation.md:3
msgid ""
"Dropping a future implies it can never be polled again. This is called *cancellation*\n"
"and it can occur at any `await` point. Care is needed to ensure the system works\n"
"correctly even when futures are cancelled. For example, it shouldn't deadlock or\n"
"lose data."
msgstr ""

#: src/async/pitfalls/cancellation.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use std::io::{self, ErrorKind};\n"
"use std::time::Duration;\n"
"use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};\n"
"\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream }\n"
"    }\n"
"\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        let mut bytes = Vec::new();\n"
"        let mut buf = [0];\n"
"        while self.stream.read(&mut buf[..]).await? != 0 {\n"
"            bytes.push(buf[0]);\n"
"            if buf[0] == b'\\n' {\n"
"                break;\n"
"            }\n"
"        }\n"
"        if bytes.is_empty() {\n"
"            return Ok(None)\n"
"        }\n"
"        let s = String::from_utf8(bytes)\n"
"            .map_err(|_| io::Error::new(ErrorKind::InvalidData, \"not UTF-8\"))?;\n"
"        Ok(Some(s))\n"
"    }\n"
"}\n"
"\n"
"async fn slow_copy(source: String, mut dest: DuplexStream) -> std::io::Result<()> {\n"
"    for b in source.bytes() {\n"
"        dest.write_u8(b).await?;\n"
"        tokio::time::sleep(Duration::from_millis(10)).await\n"
"    }\n"
"    Ok(())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> std::io::Result<()> {\n"
"    let (client, server) = tokio::io::duplex(5);\n"
"    let handle = tokio::spawn(slow_copy(\"hi\\nthere\\n\".to_owned(), client));\n"
"\n"
"    let mut lines = LinesReader::new(server);\n"
"    let mut interval = tokio::time::interval(Duration::from_millis(60));\n"
"    loop {\n"
"        tokio::select! {\n"
"            _ = interval.tick() => println!(\"tick!\"),\n"
"            line = lines.next() => if let Some(l) = line? {\n"
"                print!(\"{}\", l)\n"
"            } else {\n"
"                break\n"
"            },\n"
"        }\n"
"    }\n"
"    handle.await.unwrap()?;\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/cancellation.md:72
msgid ""
"* The compiler doesn't help with cancellation-safety. You need to read API\n"
"  documentation and consider what state your `async fn` holds.\n"
"\n"
"* Unlike `panic` and `?`, cancellation is part of normal control flow\n"
"  (vs error-handling).\n"
"\n"
"* The example loses parts of the string.\n"
"\n"
"    * Whenever the `tick()` branch finishes first, `next()` and its `buf` are dropped.\n"
"\n"
"    * `LinesReader` can be made cancellation-safe by makeing `buf` part of the struct:\n"
"        ```rust,compile_fail\n"
"        struct LinesReader {\n"
"            stream: DuplexStream,\n"
"            bytes: Vec<u8>,\n"
"            buf: [u8; 1],\n"
"        }\n"
"\n"
"        impl LinesReader {\n"
"            fn new(stream: DuplexStream) -> Self {\n"
"                Self { stream, bytes: Vec::new(), buf: [0] }\n"
"            }\n"
"            async fn next(&mut self) -> io::Result<Option<String>> {\n"
"                // prefix buf and bytes with self.\n"
"                // ...\n"
"                let raw = std::mem::take(&mut self.bytes);\n"
"                let s = String::from_utf8(raw)\n"
"                // ...\n"
"            }\n"
"        }\n"
"        ```\n"
"\n"
"* [`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick)\n"
"  is cancellation-safe because it keeps track of whether a tick has been 'delivered'.\n"
"\n"
"* [`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read)\n"
"  is cancellation-safe because it either returns or doesn't read data.\n"
"\n"
"* [`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line)\n"
"  is similar to the example and *isn't* cancellation-safe. See its documentation\n"
"  for details and alternatives."
msgstr ""

#: src/exercises/concurrency/afternoon.md:3
msgid "To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"* Dining philosophers: we already saw this problem in the morning. This time\n"
"  you are going to implement it with Async Rust.\n"
"\n"
"* A Broadcast Chat Application: this is a larger project that allows you\n"
"  experiment with more advanced Async Rust features."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:1
#, fuzzy
msgid "# Dining Philosophers - Async"
msgstr "# Fil√≥sofos jantando"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the\n"
"problem."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local\n"
"[Cargo installation](../../cargo/running-locally.md) for this exercise. Copy\n"
"the code below to a file called `src/main.rs`, fill out the blanks, and test\n"
"that `cargo run` does not deadlock:"
msgstr ""
"Voc√™ precisar√° de uma [instala√ß√£o do Cargo][../../cargo/running-locally.md] local para\n"
"esse exerc√≠cio. Copie o c√≥digo abaixo para o arquivo `src/main.rs`, preencha os espa√ßos em "
"branco,\n"
"e teste se `cargo run` n√£o trava:"

#: src/exercises/concurrency/dining-philosophers-async.md:13
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name)).await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:57
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency.\n"
"You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:62
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", \"rt-multi-thread\"]}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:72
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module\n"
"from the `tokio` crate."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:77
msgid "* Can you make your implementation single-threaded? "
msgstr ""

#: src/exercises/concurrency/chat-app.md:1
msgid "# Broadcast Chat Application"
msgstr ""

#: src/exercises/concurrency/chat-app.md:3
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast\n"
"chat application. We have a chat server that the clients connect to and publish\n"
"their messages. The client reads user messages from the standard input, and\n"
"sends them to the server. The chat server broadcasts each message that it\n"
"receives to all the clients."
msgstr ""

#: src/exercises/concurrency/chat-app.md:9
msgid ""
"For this, we use [a broadcast channel][1] on the server, and\n"
"[`tokio_websockets`][2] for the communication between the client and the\n"
"server."
msgstr ""

#: src/exercises/concurrency/chat-app.md:13
msgid "Create a new Cargo project and add the following dependencies:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:15
msgid "`Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = \"0.3.28\"\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = \"0.3.2\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:32
msgid "## The required APIs"
msgstr ""

#: src/exercises/concurrency/chat-app.md:33
msgid ""
"You are going to need the following functions from `tokio` and\n"
"[`tokio_websockets`][2]. Spend a few minutes to familiarize yourself with the\n"
"API. "
msgstr ""

#: src/exercises/concurrency/chat-app.md:37
msgid ""
"- [WebsocketStream::next()][3]: for asynchronously reading messages from a\n"
"  Websocket Stream.\n"
"- [SinkExt::send()][4] implemented by `WebsocketStream`: for asynchronously\n"
"  sending messages on a Websocket Stream.\n"
"- [Lines::next_line()][5]: for asynchronously reading user messages\n"
"  from the standard input.\n"
"- [Sender::subscribe()][6]: for subscribing to a broadcast channel."
msgstr ""

#: src/exercises/concurrency/chat-app.md:46
#, fuzzy
msgid "## Two binaries"
msgstr "# Bin√°rios Rust"

#: src/exercises/concurrency/chat-app.md:48
msgid ""
"Normally in a Cargo project, you can have only one binary, and one\n"
"`src/main.rs` file. In this project, we need two binaries. One for the client,\n"
"and one for the server. You could potentially make them two separate Cargo\n"
"projects, but we are going to put them in a single Cargo project with two\n"
"binaries. For this to work, the client and the server code should go under\n"
"`src/bin` (see the [documentation][7]). "
msgstr ""

#: src/exercises/concurrency/chat-app.md:55
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and\n"
"`src/bin/client.rs`, respectively. Your task is to complete these files as\n"
"described below. "
msgstr ""

#: src/exercises/concurrency/chat-app.md:59 src/exercises/concurrency/solutions-afternoon.md:117
msgid "`src/bin/server.rs`:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:61
msgid "<!-- File src/bin/server.rs -->"
msgstr ""

#: src/exercises/concurrency/chat-app.md:63
msgid ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:102 src/exercises/concurrency/solutions-afternoon.md:202
msgid "`src/bin/client.rs`:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:104
msgid "<!-- File src/bin/client.rs -->"
msgstr ""

#: src/exercises/concurrency/chat-app.md:106
msgid ""
"```rust,compile_fail\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let mut ws_stream = ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\"))\n"
"        .connect()\n"
"        .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:127
#, fuzzy
msgid "## Running the binaries"
msgstr "# Executando o curso"

#: src/exercises/concurrency/chat-app.md:128
msgid "Run the server with:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:130
#, fuzzy
msgid ""
"```shell\n"
"$ cargo run --bin server\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/exercises/concurrency/chat-app.md:134
msgid "and the client with:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:136
#, fuzzy
msgid ""
"```shell\n"
"$ cargo run --bin client\n"
"```"
msgstr ""
"```shell\n"
"$ cargo run\n"
"```"

#: src/exercises/concurrency/chat-app.md:142
msgid ""
"* Implement the `handle_connection` function in `src/bin/server.rs`.\n"
"  * Hint: Use `tokio::select!` for concurrently performing two tasks in a\n"
"    continuous loop. One task receives messages from the client and broadcasts\n"
"    them. The other sends messages received by the server to the client.\n"
"* Complete the main function in `src/bin/client.rs`.\n"
"  * Hint: As before, use `tokio::select!` in a continuous loop for concurrently\n"
"    performing two tasks: (1) reading user messages from standard input and\n"
"    sending them to the server, and (2) receiving messages from the server, and\n"
"    displaying them for the user.\n"
"* Optional: Once you are done, change the code to broadcast messages to all\n"
"  clients, but the sender of the message."
msgstr ""

#: src/thanks.md:1
msgid "# Thanks!"
msgstr "# Obrigado!"

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust ü¶Ä!_ We hope you enjoyed it and that it\n"
"was useful."
msgstr ""
"_Obrigado por fazer o Comprehensive Rust ü¶Ä!_ Esperamos que tenha gostado e que\n"
"tenha sido √∫til."

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would love\n"
"to hear from you."
msgstr ""
"N√≥s nos divertimos muito montando o curso. O curso n√£o √© perfeito,\n"
"portanto, se voc√™ identificou algum erro ou tem ideias para melhorias, entre em\n"
"[entre em contato conosco em\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). N√≥s adorar√≠amos\n"
"ouvir voc√™."

#: src/other-resources.md:1
msgid "# Other Rust Resources"
msgstr "# Outros recursos de Rust"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr ""
"A comunidade Rust tem abund√¢ncia de recursos gratuitos e de alta qualidade\n"
"on-line."

#: src/other-resources.md:6
msgid "## Official Documentation"
msgstr "## Documenta√ß√£o Oficial"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "O projeto Rust hospeda muitos recursos. Estes cobrem Rust em geral:"

#: src/other-resources.md:10
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the Rust\n"
"  syntax via a series of examples which showcase different constructs. Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [A Linguagem de Programa√ß√£o Rust](https://doc.rust-lang.org/book/): o\n"
"  livro gratuito can√¥nico sobre Rust. Abrange o idioma em detalhes e inclui alguns\n"
"  projetos para as pessoas constru√≠rem.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): abrange a sintaxe de Rust\n"
"  por meio de uma s√©rie de exemplos que mostram diferentes constru√ß√µes. As vezes\n"
"  inclui pequenos exerc√≠cios onde voc√™ √© solicitado a expandir o c√≥digo dos\n"
"  exemplos.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): documenta√ß√£o completa da\n"
"  biblioteca padr√£o para Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): um livro incompleto\n"
"  que descreve a gram√°tica Rust e o modelo de mem√≥ria."

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Mais guias especializados hospedados no site oficial do Rust:"

#: src/other-resources.md:24
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [O Rustonomicon](https://doc.rust-lang.org/nomicon/): cobre Rust inseguro,\n"
"  incluindo trabalhar com ponteiros brutos e fazer interface com outras linguagens\n"
"  (FFI).\n"
"* [Programa√ß√£o ass√≠ncrona em Rust](https://rust-lang.github.io/async-book/):\n"
"  abrange o novo modelo de programa√ß√£o ass√≠ncrona que foi introduzido ap√≥s o\n"
"  Rust Book ser escrito.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): uma\n"
"  introdu√ß√£o ao uso do Rust em dispositivos embarcados sem um sistema operacional."

#: src/other-resources.md:33
msgid "## Unofficial Learning Material"
msgstr "## Material de aprendizagem n√£o oficial"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Uma pequena sele√ß√£o de outros guias e tutoriais para Rust:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): a\n"
"  series of small presentations covering both basic and advanced part of the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and the\n"
"  second is a set of 11 modules which covers Rust syntax and basic constructs.\n"
"* [Learn Rust With Entirely Too Many Linked\n"
"  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth\n"
"  exploration of Rust's memory management rules, through implementing a few\n"
"  different types of list structures."
msgstr ""
"* [Aprenda Rust da maneira perigosa](http://cliffle.com/p/dangerust/): cobre Rust\n"
"  da perspectiva de programadores C de baixo n√≠vel.\n"
"* [Rust para Programadores Embedded C](https://docs.opentitan.org/doc/ug/rust_for_c/):\n"
"  cobre Rust da perspectiva dos desenvolvedores que escrevem firmware em C.\n"
"* [Rust para profissionais](https://overexact.com/rust-for-professionals/):\n"
"  cobre a sintaxe do Rust usando compara√ß√µes lado a lado com outras linguagens\n"
"  como C, C++, Java, JavaScript e Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): mais de 100 exerc√≠cios para ajudar\n"
"  voc√™ aprende Rust.\n"
"* [Ensino Ferroso\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): uma\n"
"  s√©rie de pequenas apresenta√ß√µes abrangendo tanto a parte b√°sica quanto a avan√ßada da\n"
"  Linguagem Rust. Outros t√≥picos como WebAssembly e async/await tamb√©m s√£o\n"
"  abordados.\n"
"* [S√©rie Iniciante a\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) e\n"
"  [D√™ seus primeiros passos com\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): dois\n"
"  guias Rust voltados para novos desenvolvedores. O primeiro √© um conjunto de 35 v√≠deos e o\n"
"  o segundo √© um conjunto de 11 m√≥dulos que cobrem a sintaxe Rust e as constru√ß√µes b√°sicas."

#: src/other-resources.md:63
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) for\n"
"even more Rust books."
msgstr ""
"Consulte o [Little Book of Rust Books](https://lborb.github.io/book/) para\n"
"ainda mais livros Rust."

#: src/credits.md:1
msgid "# Credits"
msgstr "# Cr√©ditos"

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of useful\n"
"resources."
msgstr ""
"O material aqui se baseia em muitas fontes excelentes de documenta√ß√£o do Rust.\n"
"Consulte a p√°gina em [outros recursos](other-resources.md) para obter uma lista completa de "
"recursos √∫teis\n"
"."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache 2.0\n"
"license, please see\n"
"[`LICENSE`](https://github.com/google/comprehensive-rust/blob/main/LICENSE) for\n"
"details."
msgstr ""
"O material do Comprehensive Rust √© licenciado sob os termos da licen√ßa Apache 2.0\n"
", consulte [`LICENSE`](../LICENSE) para obter detalhes."

#: src/credits.md:12
msgid "## Rust by Example"
msgstr "## Rust by Example"

#: src/credits.md:14
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"Alguns exemplos e exerc√≠cios foram copiados e adaptados de [Rust by\n"
"Exemplo](https://doc.rust-lang.org/rust-by-example/). por favor veja o\n"
"diret√≥rio `third_party/rust-by-example/` para detalhes, incluindo os termos de\n"
"licen√ßa."

#: src/credits.md:19
msgid "## Rust on Exercism"
msgstr "## Rust on Exercism"

#: src/credits.md:21
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the license\n"
"terms."
msgstr ""
"Alguns exerc√≠cios foram copiados e adaptados de [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). por favor veja o\n"
"diret√≥rio `third_party/rust-on-exercism/` para obter detalhes, incluindo os termos\n"
"licen√ßa."

#: src/credits.md:26
msgid "## CXX"
msgstr "## CXX"

#: src/credits.md:28
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` directory\n"
"for details, including the license terms."
msgstr ""
"A se√ß√£o [Interoperability with C++](android/interoperability/cpp.md) usa uma\n"
"imagem de [CXX](https://cxx.rs/). Consulte o diret√≥rio `third_party/cxx/`\n"
"para obter detalhes, incluindo os termos da licen√ßa."

#: src/exercises/solutions.md:1
msgid "# Solutions"
msgstr "# Solu√ß√µes"

#: src/exercises/solutions.md:3
msgid "You will find solutions to the exercises on the following pages."
msgstr "Voc√™ encontrar√° solu√ß√µes para os exerc√≠cios nas p√°ginas seguintes."

#: src/exercises/solutions.md:5
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"Sinta-se √† vontade para fazer perguntas sobre as solu√ß√µes [no\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Nos informe\n"
"se voc√™ tiver uma solu√ß√£o diferente ou melhor do que a apresentada aqui."

#: src/exercises/solutions.md:10
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **Nota:** Ignore os coment√°rios `// ANCHOR: label` e `// ANCHOR_END: label`\n"
"> que voc√™ v√™ nas solu√ß√µes. Eles est√£o l√° para tornar poss√≠vel\n"
"> reutilizar partes das solu√ß√µes como exerc√≠cios."

#: src/exercises/day-1/solutions-morning.md:1
msgid "# Day 1 Morning Exercises"
msgstr "# Dia 1 Exerc√≠cios matinais"

#: src/exercises/day-1/solutions-morning.md:3
msgid "## Arrays and `for` Loops"
msgstr "## Vetores e la√ßos `for`"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "([voltar ao exerc√≠cio](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:78
#, fuzzy
msgid "### Bonus question"
msgstr "## Pergunta B√¥nus"

#: src/exercises/day-1/solutions-morning.md:80
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-of-slices "
"(`&[&[i32]]`) as the input type to transpose and thus make our function handle any size of matrix. "
"However, this quickly breaks down: the return type cannot be `&[&[i32]]` since it needs to own the "
"data you return."
msgstr ""
"Isso necessita a utiliza√ß√£o de conceitos mais avan√ßados. Pode parecer que poder√≠amos usar uma "
"slice de slices (`&[&[i32]]`) como o tipo de entrada para `transposta` e, assim, fazer nossa "
"fun√ß√£o lidar com qualquer tamanho de matriz. No entanto, isso falha rapidamente: o tipo de retorno "
"n√£o pode ser `&[&[i32]]`, pois ele precisa possuir os dados que voc√™ retorna."

#: src/exercises/day-1/solutions-morning.md:82
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work out-of-the-box "
"either: it's hard to convert from `Vec<Vec<i32>>` to `&[&[i32]]` so now you cannot easily use "
"`pretty_print` either."
msgstr ""
"Voc√™ pode tentar usar algo como `Vec<Vec<i32>>`, mas isso tamb√©m n√£o funciona muito bem: √© dif√≠cil "
"converter de `Vec<Vec<i32>>` para `&[&[i32]] ` ent√£o agora voc√™ tamb√©m n√£o pode usar "
"`impressao_formatada` facilmente."

#: src/exercises/day-1/solutions-morning.md:84
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::AsRef`][1] trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""
"Assim que chegarmos aos _traits_ and _generics_, podemos usar o _trait_ [`std::convert::AsRef`][1] "
"para abstrair qualquer coisa\n"
"que pode ser referenciada como um _slice_."

#: src/exercises/day-1/solutions-morning.md:86
#, fuzzy
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""
"fn impressao_formatada<T, Linha, Matriz>(matriz: Matriz)\n"
"where\n"
"    T: Debug,\n"
"    // Linha referencia uma slice de itens\n"
"    Linha: AsRef<[T]>,\n"
"    // Matriz referencia uma slice de linhas\n"
"    Matriz: AsRef<[Linha]>\n"
"{\n"
"    for linha in matriz.as_ref() {\n"
"        println!(\"{:?}\", linha.as_ref());\n"
"    }\n"
"}"

#: src/exercises/day-1/solutions-morning.md:113
msgid ""
"In addition, the type itself would not enforce that the child slices are of the same length, so "
"such variable could contain an invalid matrix."
msgstr ""
"Al√©m disso, o pr√≥prio tipo n√£o imporia que as slices filhas tenham o mesmo comprimento, portanto, "
"tal vari√°vel poderia conter uma matriz inv√°lida."

#: src/exercises/day-1/solutions-afternoon.md:1
msgid "# Day 1 Afternoon Exercises"
msgstr "# Dia 1 Exerc√≠cios da Tarde"

#: src/exercises/day-1/solutions-afternoon.md:3
msgid "## Designing a Library"
msgstr "## Projetando uma biblioteca"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](book-library.md))"
msgstr "([voltar ao exerc√≠cio](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    // ANCHOR_END: setup\n"
"\n"
"    // ANCHOR: Library_new\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and year\")\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}, published in {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        // Using a closure and a built-in method:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Longer hand-written solution:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: {}\", library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
msgid "# Day 2 Morning Exercises"
msgstr "# Dia 2 Exerc√≠cios matinais"

#: src/exercises/day-2/solutions-morning.md:3
msgid "## Points and Polygons"
msgstr "## Pontos e Pol√≠gonos"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](points-polygons.md))"
msgstr "([voltar ao exerc√≠cio](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}\n"
"\n"
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}\n"
"\n"
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
msgid "# Day 2 Afternoon Exercises"
msgstr "# Dia 2 Exerc√≠cios da Tarde"

#: src/exercises/day-2/solutions-afternoon.md:3
msgid "## Luhn Algorithm"
msgstr "## Algoritmo de Luhn"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr "([voltar ao exerc√≠cio](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {cc_number} a valid credit card number? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:97
msgid "## Strings and Iterators"
msgstr "## Strings e iteradores"

#: src/exercises/day-2/solutions-afternoon.md:99
msgid "([back to exercise](strings-iterators.md))"
msgstr "([voltar ao exerc√≠cio](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:101
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"\n"
"    let mut request_segments = request_path.split('/');\n"
"\n"
"    for prefix_segment in prefix.split('/') {\n"
"        let Some(request_segment) = request_segments.next() else {\n"
"            return false;\n"
"        };\n"
"        if request_segment != prefix_segment && prefix_segment != \"*\" {\n"
"            return false;\n"
"        }\n"
"    }\n"
"    true\n"
"\n"
"    // Alternatively, Iterator::zip() lets us iterate simultaneously over "
"prefix\n"
"    // and request segments. The zip() iterator is finished as soon as one "
"of\n"
"    // the source iterators is finished, but we need to iterate over all "
"request\n"
"    // segments. A neat trick that makes zip() work is to use map() and "
"chain()\n"
"    // to produce an iterator that returns Some(str) for each pattern "
"segments,\n"
"    // and then returns None indefinitely.\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", "
"\"/v1/publishers/abc/books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", "
"\"/v1/parent/publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", "
"\"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
msgid "# Day 3 Morning Exercise"
msgstr "# Dia 3 Exerc√≠cio matinal"

#: src/exercises/day-3/solutions-morning.md:3
msgid "## A Simple GUI Library"
msgstr "## Uma biblioteca GUI simples"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr "([voltar ao exerc√≠cio](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }\n"
"\n"
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
msgid "# Day 3 Afternoon Exercises"
msgstr "# Dia 3 Exerc√≠cios da Tarde"

#: src/exercises/day-3/solutions-afternoon.md:3
msgid "## Safe FFI Wrapper"
msgstr "## Wrapper FFI Seguro"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([voltar ao exerc√≠cio](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi\n"
"\n"
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: {err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"no-such-directory\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_empty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\"]);\n"
"        Ok(())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo Diaries\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\", \"bar.png\", \"crab.rs\", \"foo.txt\"]);\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "# Bare Metal Rust Morning Exercise"
msgstr "# Dia 3 Exerc√≠cio matinal"

#: src/exercises/bare-metal/solutions-morning.md:3
#, fuzzy
msgid "## Compass"
msgstr "# Compara√ß√£o"

#: src/exercises/bare-metal/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([voltar ao exerc√≠cio](for-loops.md))"

#: src/exercises/bare-metal/solutions-morning.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"// ANCHOR_END: top\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"// ANCHOR: main\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // ANCHOR_END: main\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Set up display and timer.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    // ANCHOR: loop\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // ANCHOR_END: loop\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, image, 100);\n"
"\n"
"        // If button A is pressed, switch to the next mode and briefly blink all LEDs on.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometer,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        match self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (value - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_value, min(value, max_value))\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:1
msgid "# Bare Metal Rust Afternoon"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:3
msgid "## RTC driver"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([voltar ao exerc√≠cio](luhn.md))"

#: src/exercises/bare-metal/solutions-afternoon.md:7
msgid "`main.rs`:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:9
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"// ANCHOR_END: top\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"// ANCHOR: imports\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"// ANCHOR_END: imports\n"
"\n"
"/// Base address of the PL031 RTC.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// The IRQ used by the PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"// ANCHOR: main\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"    // ANCHOR_END: main\n"
"\n"
"    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // Wait for 3 seconds, without interrupts.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // Wait another 3 seconds for an interrupt.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // ANCHOR: main_end\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"// ANCHOR_END: main_end\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:149
msgid "`pl031.rs`:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:151
msgid ""
"```rust\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Data register\n"
"    dr: u32,\n"
"    /// Match register\n"
"    mr: u32,\n"
"    /// Load register\n"
"    lr: u32,\n"
"    /// Control register\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Interrupt Mask Set or Clear register\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Raw Interrupt Status\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Masked Interrupt Status\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Interrupt Clear Register\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver for a PL031 real-time clock.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of a\n"
"    /// PL031 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Reads the current RTC value.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() }\n"
"    }\n"
"\n"
"    /// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }\n"
"    }\n"
"\n"
"    /// Returns whether the match register matches the RTC value, whether or not\n"
"    /// the interrupt is enabled.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris).read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true iff `matched` returns true and the interrupt is\n"
"    /// masked.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis).read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false the\n"
"    /// interrupt is disabled.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc).write_volatile(imsc) }\n"
"    }\n"
"\n"
"    /// Clears a pending interrupt, if any.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Rtc {}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "# Concurrency Morning Exercise"
msgstr "# Dia 3 Exerc√≠cio matinal"

#: src/exercises/concurrency/solutions-morning.md:3
msgid "## Dining Philosophers"
msgstr "## Fil√≥sofos jantando"

#: src/exercises/concurrency/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([voltar ao exerc√≠cio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();\n"
"\n"
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "# Concurrency Afternoon Exercise"
msgstr "# Dia 1 Exerc√≠cios da Tarde"

#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "## Dining Philosophers - Async"
msgstr "## Fil√≥sofos jantando"

#: src/exercises/concurrency/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([voltar ao exerc√≠cio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-afternoon.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: Sender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name)).await\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        // ANCHOR: Philosopher-eat-body\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"        // ANCHOR_END: Philosopher-eat-body\n"
"\n"
"        // The locks are dropped here\n"
"        // ANCHOR: Philosopher-eat-end\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    // Create forks\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));\n"
"\n"
"    // Create philosophers\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = forks[i].clone();\n"
"            let right_fork = forks[(i + 1) % PHILOSOPHERS.len()].clone();\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork: if i % 2 == 0 { left_fork.clone() } else { right_fork.clone() },\n"
"                right_fork: if i % 2 == 0 { right_fork } else { left_fork },\n"
"                thoughts: tx.clone(),\n"
"            });\n"
"        }\n"
"        (philosophers, rx)\n"
"        // tx is dropped here, so we don't need to explicitly drop it later\n"
"    };\n"
"\n"
"    // Make them think and eat\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Output their thoughts\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Here is a thought: {thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:113
msgid "## Broadcast Chat Application"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:115
#, fuzzy
msgid "([back to exercise](chat-app.md))"
msgstr "([voltar ao exerc√≠cio](luhn.md))"

#: src/exercises/concurrency/solutions-afternoon.md:119
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::sink::SinkExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: handle_connection\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    // ANCHOR_END: handle_connection\n"
"\n"
"    ws_stream\n"
"        .send(Message::text(\"Welcome to chat! Type a message\".into()))\n"
"        .await?;\n"
"    let mut bcast_rx = bcast_tx.subscribe();\n"
"\n"
"    // A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        let msg = msg.as_text()?;\n"
"                        println!(\"From client {addr:?} {msg:?}\");\n"
"                        bcast_tx.send(msg.into())?;\n"
"                    }\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            msg = bcast_rx.recv() => {\n"
"                ws_stream.send(Message::text(msg?)).await?;\n"
"            }\n"
"        }\n"
"    }\n"
"    // ANCHOR: main\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:204
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let mut ws_stream = ClientBuilder::from_uri(Uri::from_static(\"ws://127.0.0.1:2000\"))\n"
"        .connect()\n"
"        .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"    // ANCHOR_END: setup\n"
"    // Continuous loop for concurrently sending and receiving messages.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => println!(\"From server: {}\", msg.as_text()?),\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            res = stdin.next_line() => {\n"
"                match res {\n"
"                    Ok(None) => return Ok(()),\n"
"                    Ok(Some(line)) => ws_stream.send(Message::text(line.to_string())).await?,\n"
"                    Err(err) => return Err(err.into()),\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#~ msgid "Closures"
#~ msgstr "Closures"

#~ msgid "Day 4: Morning"
#~ msgstr "Dia 4: Manh√£"

#~ msgid "Day 4: Afternoon"
#~ msgstr "Dia 4: Tarde"

#~ msgid "Day 4 Morning"
#~ msgstr "Dia 4 Manh√£"

#~ msgid "On Day 4, we will cover Android-specific things such as:"
#~ msgstr "No Dia 4, abordaremos assuntos espec√≠ficos do Android, como:"

#~ msgid ""
#~ "* Building Android components in Rust.\n"
#~ "* AIDL servers and clients.\n"
#~ "* Interoperability with C, C++, and Java."
#~ msgstr ""
#~ "* Construindo componentes Android em Rust.\n"
#~ "* Servidores e clientes AIDL.\n"
#~ "* Interoperabilidade com C, C++ e Java."

#~ msgid ""
#~ "It is important to note that this course does not cover Android **application** \n"
#~ "development in Rust, and that the Android-specific parts are specifically about\n"
#~ "writing code for Android itself, the operating system. "
#~ msgstr ""
#~ "√â importante observar que este curso n√£o cobre o desenvolvimento de **aplicativos** para "
#~ "Android\n"
#~ "em Rust, e que as partes espec√≠ficas do Android s√£o relacionadas a\n"
#~ "escrever c√≥digo para o sistema operacional Android."

#~ msgid ""
#~ "* Learn how to use async Rust --- we'll only mention async Rust when\n"
#~ "  covering traditional concurrency primitives. Please see [Asynchronous\n"
#~ "  Programming in Rust](https://rust-lang.github.io/async-book/) instead for\n"
#~ "  details on this topic.\n"
#~ "* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
#~ "  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
#~ "  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
#~ msgstr ""
#~ "* Uso de async Rust --- s√≥ mencionaremos o async Rust quando\n"
#~ "  cobrirmos primitivas de concorr√™ncia tradicionais. Consulte [Ass√≠ncrono\n"
#~ "  Programa√ß√£o em Rust](https://rust-lang.github.io/async-book/) para mais\n"
#~ "  detalhes sobre este tema.\n"
#~ "* Desenvolvimento de macros, consulte [Cap√≠tulo 19.5 no Rust\n"
#~ "  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) e [Rust by\n"
#~ "  Example](https://doc.rust-lang.org/rust-by-example/macros.html) em vez disso."

#~ msgid ""
#~ "1. Make yourself familiar with the course material. We've included speaker notes\n"
#~ "   on some of the pages to help highlight the key points (please help us by\n"
#~ "   contributing more speaker notes!). You should make sure to open the speaker\n"
#~ "   notes in a popup (click the link with a little arrow next to \"Speaker\n"
#~ "   Notes\"). This way you have a clean screen to present to the class."
#~ msgstr ""
#~ "1. Familiarize-se com o material do curso. Inclu√≠mos notas do instrutor\n"
#~ "   em algumas das p√°ginas para ajudar a destacar os pontos chave (por favor, ajude-nos\n"
#~ "   contribuindo com mais notas do instrutor!). Voc√™ deve certificar-se de abrir as notas\n"
#~ "   do instrutor em um pop-up (clique no link com uma pequena seta ao lado de \"Speaker\n"
#~ "   Notes\"). Dessa forma, voc√™ tem uma tela limpa para apresentar √† turma."

#~ msgid ""
#~ "2. Decide on the dates. Since the course is large, we recommend that you\n"
#~ "   schedule the four days over two weeks. Course participants have said that\n"
#~ "   they find it helpful to have a gap in the course since it helps them process\n"
#~ "   all the information we give them."
#~ msgstr ""
#~ "2. Decida as datas. Como o curso √© grande, recomendamos que voc√™\n"
#~ "   agende os quatro dias em duas semanas. Os participantes do curso disseram que\n"
#~ "   eles acham √∫til ter uma pausa no curso, pois os ajuda a processar\n"
#~ "   todas as informa√ß√µes que lhes damos."

#~ msgid ""
#~ "3. Find a room large enough for your in-person participants. We recommend a\n"
#~ "   class size of 15-20 people. That's small enough that people are comfortable\n"
#~ "   asking questions --- it's also small enough that one instructor will have\n"
#~ "   time to answer the questions."
#~ msgstr ""
#~ "3. Encontre uma sala suficientemente grande para seus participantes presenciais. Recomendamos\n"
#~ "   turmas de 15 a 20 pessoas. Isso √© suficientemente pequeno para que as pessoas se sintam "
#~ "confort√°veis\n"
#~ "   em fazer perguntas --- e para que um instrutor tenha\n"
#~ "   tempo para responder √†s perguntas."

#~ msgid ""
#~ "4. On the day of your course, show up to the room a little early to set things\n"
#~ "   up. We recommend presenting directly using `mdbook serve` running on your\n"
#~ "   laptop (see the [installation instructions][5]). This ensures optimal performance with no "
#~ "lag as you change pages.\n"
#~ "   Using your laptop will also allow you to fix typos as you or the course\n"
#~ "   participants spot them."
#~ msgstr ""
#~ "4. No dia do seu curso, chegue um pouco mais cedo na sala para acertar as coisas.\n"
#~ "   Recomendamos apresentar diretamente usando `mdbook serve` rodando em seu\n"
#~ "   laptop. Isso garante um desempenho ideal sem atrasos quando voc√™ muda de p√°gina.\n"
#~ "   Usar seu laptop tamb√©m permitir√° que voc√™ corrija erros de digita√ß√£o enquanto voc√™ ou\n"
#~ "   os participantes os identificam."

#~ msgid ""
#~ "5. Let people solve the exercises by themselves or in small groups. Make sure to\n"
#~ "   ask people if they're stuck or if there is anything you can help with. When\n"
#~ "   you see that several people have the same problem, call it out to the class\n"
#~ "   and offer a solution, e.g., by showing people where to find the relevant\n"
#~ "   information in the standard library."
#~ msgstr ""
#~ "5. Deixe as pessoas resolverem os exerc√≠cios sozinhas ou em pequenos grupos. Tenha certeza de\n"
#~ "   perguntar √†s pessoas se elas est√£o com dificuldades ou se h√° algo em que voc√™ possa ajudar. "
#~ "Quando\n"
#~ "   voc√™ v√™ que v√°rias pessoas t√™m o mesmo problema, chame a turma\n"
#~ "   e ofere√ßa uma solu√ß√£o, por exemplo, mostrando √†s pessoas onde encontrar as informa√ß√µes "
#~ "relevantes\n"
#~ "   na biblioteca padr√£o."

#~ msgid ""
#~ "> **Exercise for Day 4:** Do you interface with some C/C++ code in your project\n"
#~ "> which we could attempt to move to Rust? The fewer dependencies the better.\n"
#~ "> Parsing code would be ideal."
#~ msgstr ""
#~ "> **Exerc√≠cio para o dia 4:** Voc√™ faz interface com algum c√≥digo C/C++ em seu projeto\n"
#~ "> que poder√≠amos tentar mover para Rust? Quanto menos depend√™ncias, melhor.\n"
#~ "> Analisar o c√≥digo seria o ideal."

#~ msgid ""
#~ "[1]: https://rust-analyzer.github.io/\n"
#~ "[2]: https://code.visualstudio.com/\n"
#~ "[3]: https://rustup.rs/\n"
#~ "[4]: https://www.jetbrains.com/clion/\n"
#~ "[5]: https://www.jetbrains.com/rust/\n"
#~ "[6]: https://github.com/rust-lang/rustfmt"
#~ msgstr ""
#~ "[1]: https://rust-analyzer.github.io/\n"
#~ "[2]: https://code.visualstudio.com/\n"
#~ "[3]: https://rustup.rs/\n"
#~ "[4]: https://www.jetbrains.com/clion/\n"
#~ "[5]: https://www.jetbrains.com/rust/"

#~ msgid ""
#~ "* `rustc`: the Rust compiler which turns `.rs` files into binaries and other\n"
#~ "  intermediate formats."
#~ msgstr ""
#~ "* `rustc`: o compilador Rust que transforma arquivos `.rs` em bin√°rios e outros\n"
#~ "  formatos intermedi√°rios[^rustc]."

#~ msgid ""
#~ "* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
#~ "  download dependencies hosted on <https://crates.io> and it will pass them to\n"
#~ "  `rustc` when building your project. Cargo also comes with a built-in test\n"
#~ "  runner which is used to execute unit tests."
#~ msgstr ""
#~ "* `cargo`: o gerenciador de depend√™ncias Rust e a ferramenta de compila√ß√£o. O Cargo sabe como\n"
#~ "  baixar as depend√™ncias hospedadas em <https://crates.io> e as passar√° para\n"
#~ "  o `rustc` ao compilar o seu projeto. O Cargo tamb√©m vem com um executor de testes\n"
#~ "  embutido que √© usado para executar testes unit√°rios."

#~ msgid ""
#~ "* Rust has a rapid release schedule with a new release coming out\n"
#~ "  every six weeks. New releases maintain backwards compatibility with\n"
#~ "  old releases --- plus they enable new functionality."
#~ msgstr ""
#~ "* Rust tem um r√°pido cronograma de lan√ßamento com um novo lan√ßamento saindo\n"
#~ "  a cada seis semanas. Novos lan√ßamentos mant√™m compatibilidade com vers√µes anteriores\n"
#~ "  --- al√©m disso, eles permitem novas funcionalidades."

#~ msgid "* There are three release channels: \"stable\", \"beta\", and \"nightly\"."
#~ msgstr "* Existem tr√™s canais de lan√ßamento: \"stable\", \"beta\" e \"nightly\"."

#~ msgid ""
#~ "* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
#~ "  \"stable\" every six weeks."
#~ msgstr ""
#~ "* Novos recursos est√£o sendo testados em \"nightly\", \"beta\" √© o que se torna\n"
#~ "  \"est√°vel\" a cada seis semanas."

#~ msgid ""
#~ "* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
#~ "  editions were Rust 2015 and Rust 2018."
#~ msgstr ""
#~ "* Rust tamb√©m tem [edi√ß√µes]: a edi√ß√£o atual √© Rust 2021. Edi√ß√µes\n"
#~ "  anteriores foram Rust 2015 e Rust 2018."

#~ msgid ""
#~ "  * The editions are allowed to make backwards incompatible changes to\n"
#~ "    the language."
#~ msgstr ""
#~ "  * As edi√ß√µes podem fazer altera√ß√µes incompat√≠veis com vers√µes anteriores\n"
#~ "    da linguagem."

#~ msgid ""
#~ "  * To prevent breaking code, editions are opt-in: you select the\n"
#~ "    edition for your crate via the `Cargo.toml` file."
#~ msgstr ""
#~ "  * Para evitar rupturas, as edi√ß√µes s√£o opcionais: voc√™ seleciona a\n"
#~ "    edi√ß√£o para o seu crate atrav√©s do arquivo `Cargo.toml`."

#~ msgid ""
#~ "  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
#~ "    written for different editions."
#~ msgstr ""
#~ "  * Para evitar a divis√£o do ecossistema, os compiladores Rust podem misturar c√≥digo\n"
#~ "    escrito para diferentes edi√ß√µes."

#~ msgid ""
#~ "  * Mention that it is quite rare to ever use the compiler directly not through `cargo` (most "
#~ "users never do)."
#~ msgstr ""
#~ "  * Mencione que √© muito raro usar o compilador diretamente, n√£o atrav√©s do `cargo` (a maioria "
#~ "dos usu√°rios nunca o faz)."

#~ msgid ""
#~ "  * It might be worth alluding that Cargo itself is an extremely powerful and comprehensive "
#~ "tool.  It is capable of many advanced features including but not limited to: \n"
#~ "      * Project/package structure\n"
#~ "      * [workspaces]\n"
#~ "      * Dev Dependencies and Runtime Dependency management/caching\n"
#~ "      * [build scripting]\n"
#~ "      * [global installation]\n"
#~ "      * It is also extensible with sub command plugins as well (such as [cargo clippy]).\n"
#~ "  * Read more from the [official Cargo Book]"
#~ msgstr ""
#~ "  * Pode valer a pena mencionar que o Cargo √© uma ferramenta extremamente poderosa e "
#~ "abrangente. Ele √© capaz de muitos recursos avan√ßados, incluindo, entre outros:\n"
#~ "      * Estrutura do projeto/pacote\n"
#~ "      * [workspaces]\n"
#~ "      * Gerenciamento de depend√™ncias de desenvolvimento e depend√™ncias de tempo de execu√ß√£o/"
#~ "cache\n"
#~ "      * [scripts de compila√ß√£o]\n"
#~ "      * [instala√ß√£o global]\n"
#~ "      * Tamb√©m √© extens√≠vel com plugins de subcomando (como [cargo clippy]).\n"
#~ "  * Leia mais no [livro oficial do Cargo]"

#~ msgid "[editions]: https://doc.rust-lang.org/edition-guide/"
#~ msgstr "[edi√ß√µes]: https://doc.rust-lang.org/edition-guide/"

#~ msgid "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"
#~ msgstr "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"

#~ msgid "[build scripting]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"
#~ msgstr "[scripts de compila√ß√£o]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"

#~ msgid "[global installation]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"
#~ msgstr "[instala√ß√£o global]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"

#~ msgid "[cargo clippy]: https://github.com/rust-lang/rust-clippy"
#~ msgstr "[cargo clippy]: https://github.com/rust-lang/rust-clippy"

#~ msgid "[official Cargo Book]: https://doc.rust-lang.org/cargo/"
#~ msgstr "[livro oficial do Cargo]: https://doc.rust-lang.org/cargo/"

#~ msgid ""
#~ "* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
#~ "  code and open it in the real Playground to demonstrate unit tests."
#~ msgstr ""
#~ "* Os playgrounds incorporados n√£o podem executar testes unit√°rios. Copie e cole o\n"
#~ "  c√≥digo e abra-o no Playground real para demonstrar os testes unit√°rios."

#~ msgid "1. Click the \"Copy to clipboard\" button on the example you want to copy."
#~ msgstr "1. Clique no bot√£o \"Copiar para a √°rea de transfer√™ncia\" no exemplo que deseja copiar."

#~ msgid "2. Use `cargo new exercise` to create a new `exercise/` directory for your code:"
#~ msgstr "2. Use `cargo new exercise` para criar um novo diret√≥rio `exercise/` para o seu c√≥digo:"

#~ msgid "3. Navigate into `exercise/` and use `cargo run` to build and run your binary:"
#~ msgstr "3. Navegue at√© `exercise/` e use `cargo run` para compilar e executar seu bin√°rio:"

#~ msgid ""
#~ "4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
#~ "   example, using the example on the previous page, make `src/main.rs` look like"
#~ msgstr ""
#~ "4. Substitua o c√≥digo de exemplo em `src/main.rs` pelo seu pr√≥prio c√≥digo. Por\n"
#~ "   exemplo, usando o c√≥digo da p√°gina anterior, fa√ßa `src/main.rs` parecer"

#~ msgid "5. Use `cargo run` to build and run your updated binary:"
#~ msgstr "5. Use `cargo run` para compilar e executar seu bin√°rio atualizado:"

#~ msgid ""
#~ "6. Use `cargo check` to quickly check your project for errors, use `cargo build`\n"
#~ "   to compile it without running it. You will find the output in `target/debug/`\n"
#~ "   for a normal debug build. Use `cargo build --release` to produce an optimized\n"
#~ "   release build in `target/release/`."
#~ msgstr ""
#~ "6. Use `cargo check` para verificar rapidamente se h√° erros em seu projeto, use `cargo build`\n"
#~ "   para compil√°-lo sem execut√°-lo. Voc√™ encontrar√° a sa√≠da em `target/debug/`\n"
#~ "   para uma compila√ß√£o de depura√ß√£o. Use `cargo build --release` para produzir um bin√°rio\n"
#~ "   otimizado em `target/release/`."

#~ msgid ""
#~ "7. You can add dependencies for your project by editing `Cargo.toml`. When you\n"
#~ "   run `cargo` commands, it will automatically download and compile missing\n"
#~ "   dependencies for you."
#~ msgstr ""
#~ "7. Voc√™ pode adicionar depend√™ncias ao seu projeto editando `Cargo.toml`. Quando voc√™\n"
#~ "   executar os comandos `cargo`, ele ir√° baixar e compilar automaticamente\n"
#~ "   as depend√™ncias para voc√™."

#~ msgid "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"
#~ msgstr "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"

#~ msgid ""
#~ "* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
#~ "  references, functions, and methods."
#~ msgstr ""
#~ "* Sintaxe b√°sica do Rust: vari√°veis, tipos escalares e compostos, enums, structs,\n"
#~ "  refer√™ncias, fun√ß√µes e m√©todos."

#~ msgid ""
#~ "* Memory management: stack vs heap, manual memory management, scope-based memory\n"
#~ "  management, and garbage collection."
#~ msgstr ""
#~ "* Gerenciamento de mem√≥ria: stack versus heap, gerenciamento manual de mem√≥ria, gerenciamento "
#~ "de mem√≥ria\n"
#~ "   baseada em escopo e garbage collection (coleta de lixo)."

#~ msgid "* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
#~ msgstr "* Ownership: sem√¢ntica de movimento, c√≥pia e clonagem, empr√©stimo e tempos de vida."

#~ msgid "[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#~ msgid ""
#~ "* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
#~ "  imperative (not functional) and it doesn't try to reinvent things unless\n"
#~ "  absolutely necessary."
#~ msgstr ""
#~ "* Rust √© muito parecido com outras linguagens na tradi√ß√£o do C/C++/Java. √â\n"
#~ "  imperativo (n√£o funcional) e n√£o tenta reinventar as coisas a menos que\n"
#~ "  absolutamente necess√°rio."

#~ msgid "* Rust is modern with full support for things like Unicode."
#~ msgstr "* Rust √© moderno com amplo suporte para coisas como Unicode."

#~ msgid ""
#~ "* Rust uses macros for situations where you want to have a variable number of\n"
#~ "  arguments (no function [overloading](basic-syntax/functions-interlude.md))."
#~ msgstr ""
#~ "* Rust usa macros para situa√ß√µes em que voc√™ deseja ter um n√∫mero vari√°vel de\n"
#~ "  argumentos (sem [overloading](basic-syntax/functions-interlude.md) de fun√ß√µes)."

#~ msgid ""
#~ "* Explain that all variables are statically typed. Try removing `i32` to trigger\n"
#~ "  type inference. Try with `i8` instead and trigger a runtime integer overflow."
#~ msgstr ""
#~ "* Explique que todas as vari√°veis s√£o estaticamente tipadas. Tente remover `i32` para acionar "
#~ "a\n"
#~ "  infer√™ncia de tipo. Em vez disso, tente com `i8` e dispare um estouro de n√∫mero inteiro em "
#~ "tempo de execu√ß√£o."

#~ msgid "* Change `let mut x` to `let x`, discuss the compiler error."
#~ msgstr "* Altere `let mut x` para `let x`, discuta o erro do compilador."

#~ msgid ""
#~ "* Show how `print!` gives a compilation error if the arguments don't match the\n"
#~ "  format string."
#~ msgstr ""
#~ "* Mostre como `print!` gera um erro de compila√ß√£o se os argumentos n√£o combinam com a\n"
#~ "  sequ√™ncia de formato."

#~ msgid ""
#~ "* Show how you need to use `{}` as a placeholder if you want to print an\n"
#~ "  expression which is more complex than just a single variable."
#~ msgstr ""
#~ "* Mostre como voc√™ precisa usar `{}` como espa√ßo reservado se quiser imprimir uma\n"
#~ "  express√£o que √© mais complexa do que apenas uma √∫nica vari√°vel."

#~ msgid ""
#~ "* Show the students the standard library, show them how to search for `std::fmt`\n"
#~ "  which has the rules of the formatting mini-language. It's important that the\n"
#~ "  students become familiar with searching in the standard library."
#~ msgstr ""
#~ "* Mostre aos alunos a biblioteca padr√£o, mostre como pesquisar `std::fmt`, \n"
#~ "  que possui as regras da mini-linguagem de formata√ß√£o. √â importante que\n"
#~ "  os alunos se familiarizem com pesquisas na biblioteca padr√£o."

#~ msgid ""
#~ "* Experience with C or C++: Rust eliminates a whole class of _runtime errors_\n"
#~ "  via the borrow checker. You get performance like in C and C++, but you don't\n"
#~ "  have the memory unsafety issues. In addition, you get a modern language with\n"
#~ "  constructs like pattern matching and built-in dependency management."
#~ msgstr ""
#~ "* Experi√™ncia com C ou C++: Rust elimina toda uma classe de _erros de tempo de execu√ß√£o_\n"
#~ "  atrav√©s do verificador de empr√©stimo. Voc√™ obt√©m desempenho como em C e C++, mas n√£o\n"
#~ "  tem problemas de inseguran√ßa de mem√≥ria. Al√©m disso, voc√™ obt√©m uma linguagem moderna com\n"
#~ "  constru√ß√µes como correspond√™ncia de padr√µes e gerenciamento de depend√™ncias integrado."

#~ msgid ""
#~ "[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
#~ "[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
#~ "[reference cycle]: https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"
#~ msgstr ""
#~ "[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
#~ "[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
#~ "[refer√™ncia c√≠clica]: https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"

#~ msgid ""
#~ "* Bounds checking cannot be disabled with a compiler flag. It can also\n"
#~ "  not be disabled directly with the `unsafe` keyword. However,\n"
#~ "  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
#~ "  which does not do bounds checking."
#~ msgstr ""
#~ "* A verifica√ß√£o de limites n√£o pode ser desativada com um sinalizador de compilador. Tamb√©m "
#~ "n√£o\n"
#~ "  pode ser desativado diretamente com a palavra-chave `unsafe`. No entanto,\n"
#~ "  `unsafe` permite que voc√™ chame fun√ß√µes como `slice::get_unchecked`\n"
#~ "  que n√£o faz verifica√ß√£o de limites."

#~ msgid ""
#~ "* Zero-cost abstractions, similar to C++, means that you don't have to 'pay'\n"
#~ "  for higher-level programming constructs with memory or CPU. For example,\n"
#~ "  writing a loop using `for` should result in roughly the same low level\n"
#~ "  instructions as using the `.iter().fold()` construct."
#~ msgstr ""
#~ "* Abstra√ß√µes de custo zero, semelhantes ao C++, significa que voc√™ n√£o precisa 'pagar'\n"
#~ "  com mem√≥ria ou CPU por constru√ß√µes de programa√ß√£o de alto n√≠vel. Por exemplo,\n"
#~ "  escrever um loop usando `for` deve resultar aproximadamente nas mesmas instru√ß√µes\n"
#~ "  de baixo n√≠vel como ao usar a constru√ß√£o `.iter().fold()`."

#~ msgid ""
#~ "* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also\n"
#~ "  known as 'sum types', which allow the type system to express things like\n"
#~ "  `Option<T>` and `Result<T, E>`."
#~ msgstr ""
#~ "* Pode valer a pena mencionar que enums em Rust tamb√©m s√£o 'tipos de dados alg√©bricos', tamb√©m\n"
#~ "  conhecidos como 'tipos de soma', os quais permitem que o sistema de tipos expresse coisas "
#~ "como\n"
#~ "  `Option<T>` e `Result<T, E>`."

#~ msgid ""
#~ "* Remind people to read the errors --- many developers have gotten used to\n"
#~ "  ignore lengthy compiler output. The Rust compiler is significantly more\n"
#~ "  talkative than other compilers. It will often provide you with _actionable_\n"
#~ "  feedback, ready to copy-paste into your code."
#~ msgstr ""
#~ "* Lembre as pessoas de lerem os erros --- muitos desenvolvedores se acostumaram\n"
#~ "  a ignorar as longas sa√≠da do compilador. O compilador Rust √© significativamente mais\n"
#~ "  verboso do que outros compiladores. Muitas vezes, ele fornecer√° a voc√™ feedback\n"
#~ "  _utiliz√°vel_, pronto para copiar e colar em seu c√≥digo."

#~ msgid ""
#~ "* The Rust standard library is small compared to languages like Java, Python,\n"
#~ "  and Go. Rust does not come with several things you might consider standard and\n"
#~ "  essential:"
#~ msgstr ""
#~ "* A biblioteca padr√£o do Rust √© pequena comparada a linguagens como Java, Python,\n"
#~ "  e Go. Rust n√£o vem com v√°rias coisas que voc√™ pode considerar padr√£o e\n"
#~ "  essencial:"

#~ msgid ""
#~ "  * a random number generator, but see [rand].\n"
#~ "  * support for SSL or TLS, but see [rusttls].\n"
#~ "  * support for JSON, but see [serde_json]."
#~ msgstr ""
#~ "  * um gerador de n√∫meros aleat√≥rios, mas veja [rand].\n"
#~ "  * suporte para SSL ou TLS, mas consulte [rusttls].\n"
#~ "  * suporte para JSON, mas consulte [serde_json]."

#~ msgid ""
#~ "  The reasoning behind this is that functionality in the standard library cannot\n"
#~ "  go away, so it has to be very stable. For the examples above, the Rust\n"
#~ "  community is still working on finding the best solution --- and perhaps there\n"
#~ "  isn't a single \"best solution\" for some of these things."
#~ msgstr ""
#~ "  O racioc√≠nio por tr√°s disso √© que as funcionalidades na biblioteca padr√£o n√£o podem\n"
#~ "  ser descartadas, portanto t√™m que ser muito est√°veis. Para os exemplos acima, a comunidade\n"
#~ "  Rust ainda est√° trabalhando para encontrar a melhor solu√ß√£o --- e talvez n√£o\n"
#~ "  haja uma √∫nica \"melhor solu√ß√£o\" para algumas dessas coisas."

#~ msgid ""
#~ "  Rust comes with a built-in package manager in the form of Cargo and this makes\n"
#~ "  it trivial to download and compile third-party crates. A consequence of this\n"
#~ "  is that the standard library can be smaller."
#~ msgstr ""
#~ "  O Rust vem com um gerenciador de pacotes embutido na forma de Cargo e isso torna\n"
#~ "  trivial baixar e compilar crates de terceiros. Uma consequ√™ncia disso\n"
#~ "  √© que a biblioteca padr√£o pode ser menor."

#~ msgid ""
#~ "  Discovering good third-party crates can be a problem. Sites like\n"
#~ "  <https://lib.rs/> help with this by letting you compare health metrics for\n"
#~ "  crates to find a good and trusted one.\n"
#~ "  \n"
#~ "* [rust-analyzer] is a well supported LSP implementation used in major\n"
#~ "  IDEs and text editors."
#~ msgstr ""
#~ "  Descobrir bons crates de terceiros pode ser um problema. Sites como\n"
#~ "  <https://lib.rs/> ajudam com isso, permitindo que voc√™ compare m√©tricas para\n"
#~ "  para encontrar um crate bom e confi√°vel.\n"
#~ "  \n"
#~ "* [rust-analyzer] √© uma implementa√ß√£o LSP bem suportada usada em grandes\n"
#~ "  IDEs e editores de texto."

#~ msgid ""
#~ "[rand]: https://docs.rs/rand/\n"
#~ "[rusttls]: https://docs.rs/rustls/\n"
#~ "[serde_json]: https://docs.rs/serde_json/\n"
#~ "[rust-analyzer]: https://rust-analyzer.github.io/"
#~ msgstr ""
#~ "[rand]: https://docs.rs/rand/\n"
#~ "[rusttls]: https://docs.rs/rustls/\n"
#~ "[serde_json]: https://docs.rs/serde_json/\n"
#~ "[rust-analyzer]: https://rust-analyzer.github.io/"

#~ msgid ""
#~ "* Arrays have elements of the same type, `T`, and length, `N`, which is a compile-time "
#~ "constant.\n"
#~ "  Note that the length of the array is *part of its type*, which means that `[u8; 3]` and\n"
#~ "  `[u8; 4]` are considered two different types."
#~ msgstr ""
#~ "* Vetores possuem elementos do mesmo tipo, `T`, e comprimento, `N`, que √© uma constante de "
#~ "tempo de compila√ß√£o.\n"
#~ "  Observe que o comprimento do vetor √© *parte de seu tipo*, o que significa que `[u8; 3]` e\n"
#~ "  `[u8; 4]` s√£o considerados dois tipos diferentes."

#~ msgid "* We can use literals to assign values to arrays."
#~ msgstr "* Podemos usar literais para atribuir valores a vetores."

#~ msgid ""
#~ "* In the main function, the print statement asks for the debug implementation with the `?` "
#~ "format\n"
#~ "  parameter: `{}` gives the default output, `{:?}` gives the debug output. We\n"
#~ "  could also have used `{a}` and `{a:?}` without specifying the value after the\n"
#~ "  format string."
#~ msgstr ""
#~ "* Na fun√ß√£o `main`, a instru√ß√£o print solicita a implementa√ß√£o de depura√ß√£o com um `?` no\n"
#~ "  formatador: `{}` fornece a sa√≠da padr√£o, `{:?}` fornece a sa√≠da de depura√ß√£o. N√≥s\n"
#~ "  tamb√©m poder√≠amos ter usado `{a}` e `{a:?}` sem especificar o valor ap√≥s a\n"
#~ "  sequ√™ncia de formatadores."

#~ msgid ""
#~ "* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be easier to read."
#~ msgstr ""
#~ "* Adicionando `#`, por exemplo `{a:#?}`, chama um formatador de \"impress√£o bonita\", que pode "
#~ "ser mais f√°cil de ler."

#~ msgid "* Like arrays, tuples have a fixed length."
#~ msgstr "* Assim como os vetores, as tuplas t√™m um comprimento fixo."

#~ msgid "* Tuples group together values of different types into a compound type."
#~ msgstr "* As tuplas agrupam valores de tipos diferentes em um tipo composto."

#~ msgid ""
#~ "* Fields of a tuple can be accessed by the period and the index of the value, e.g. `t.0`, `t.1`."
#~ msgstr ""
#~ "* Os campos de uma tupla podem ser acessados pelo 'ponto' e pelo √≠ndice do valor, por exemplo "
#~ "`t.0`, `t.1`."

#~ msgid ""
#~ "<details>\n"
#~ "Key points:"
#~ msgstr ""
#~ "<details>\n"
#~ "Pontos chave:"

#~ msgid ""
#~ "* We create a slice by borrowing `a` and specifying the starting and ending indexes in brackets."
#~ msgstr ""
#~ "* Criamos uma slice pegando emprestado `a` e especificando os √≠ndices inicial e final entre "
#~ "colchetes."

#~ msgid ""
#~ "* If the slice starts at index 0, Rust's range syntax allows us to drop the starting index, "
#~ "meaning that `&a[0..a.len()]` and `&a[..a.len()]` are identical.\n"
#~ "    \n"
#~ "* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are identical."
#~ msgstr ""
#~ "* Se a slice come√ßa no √≠ndice 0, a sintaxe de intervalo do Rust nos permite descartar o √≠ndice "
#~ "inicial, o que significa que `&a[0..a.len()]` e `&a[..a.len()]` s√£o id√™nticos .\n"
#~ "    \n"
#~ "* O mesmo vale para o √∫ltimo √≠ndice, ent√£o `&a[2..a.len()]` e `&a[2..]` s√£o id√™nticos."

#~ msgid "* To easily create a slice of the full array, we can therefore use `&a[..]`."
#~ msgstr "* Para criar facilmente uma slice do vetor completo, podemos usar `&a[..]`."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: &str = \"World\";\n"
#~ "    println!(\"s1: {s1}\");"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: &str = \"Mundo\";\n"
#~ "    println!(\"s1: {s1}\");"

#~ msgid ""
#~ "* `&str` introduces a string slice, which is an immutable reference to UTF-8 encoded string "
#~ "data \n"
#~ "  stored in a block of memory. String literals (`\"Hello\"`), are stored in the program's "
#~ "binary."
#~ msgstr ""
#~ "* `&str` introduz uma slice de string, que √© uma refer√™ncia imut√°vel para dados de string "
#~ "codificados em UTF-8\n"
#~ "  armazenados em um bloco de mem√≥ria. String literais (`\"Hello\"`), s√£o armazenados no bin√°rio "
#~ "do programa."

#~ msgid ""
#~ "* Rust's `String` type is a wrapper around a vector of bytes. As with a `Vec<T>`, it is owned.\n"
#~ "    \n"
#~ "* As with many other types `String::from()` creates a string from a string literal; `String::"
#~ "new()` \n"
#~ "  creates a new empty string, to which string data can be added using the `push()` and "
#~ "`push_str()` methods."
#~ msgstr ""
#~ "* O tipo `String` do Rust √© um wrapper em torno de um vetor de bytes. Tal como acontece com um "
#~ "`Vec<T>`, ele √© um valor.\n"
#~ "    \n"
#~ "* Assim como muitos outros tipos, `String::from()` cria uma string a partir de uma string "
#~ "literal; `String::new()`\n"
#~ "  cria uma nova string vazia, na qual os dados da string podem ser adicionados usando os "
#~ "m√©todos `push()` e `push_str()`."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    fizzbuzz_to(20); // Definido abaixo, nenhuma declara√ß√£o pr√©via √© necess√°ria\n"
#~ "}"

#~ msgid ""
#~ "fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit type `()`\n"
#~ "    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
#~ "        (true,  true)  => println!(\"fizzbuzz\"),\n"
#~ "        (true,  false) => println!(\"fizz\"),\n"
#~ "        (false, true)  => println!(\"buzz\"),\n"
#~ "        (false, false) => println!(\"{n}\"),\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "fn fizzbuzz(n: u32) -> () {  //  // Nenhum valor de retorno significa retornar o tipo unit√°rio "
#~ "`()`\n"
#~ "    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
#~ "        (true,  true)  => println!(\"fizzbuzz\"),\n"
#~ "        (true,  false) => println!(\"fizz\"),\n"
#~ "        (false, true)  => println!(\"buzz\"),\n"
#~ "        (false, false) => println!(\"{n}\"),\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
#~ "    for i in 1..=n {\n"
#~ "        fizzbuzz(i);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn fizzbuzz_to(n: u32) { // `-> ()` normalmente √© omitido\n"
#~ "    for i in 1..=n {\n"
#~ "        fizzbuzz(i);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "  (Type annotations added for clarity, but they can be elided.)"
#~ msgstr "  (As anota√ß√µes de tipo foram adicionadas para maior clareza, mas podem ser omitidas.)"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Rectangle {\n"
#~ "    width: u32,\n"
#~ "    height: u32,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Retangulo {\n"
#~ "    largura: u32,\n"
#~ "    altura: u32,\n"
#~ "}"

#~ msgid ""
#~ "impl Rectangle {\n"
#~ "    fn area(&self) -> u32 {\n"
#~ "        self.width * self.height\n"
#~ "    }"
#~ msgstr ""
#~ "impl Retangulo {\n"
#~ "    fn area(&self) -> u32 {\n"
#~ "        self.largura * self.altura\n"
#~ "    }"

#~ msgid ""
#~ "    fn inc_width(&mut self, delta: u32) {\n"
#~ "        self.width += delta;\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn aumenta_largura(&mut self, delta: u32) {\n"
#~ "        self.largura += delta;\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn escolha_um<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}"

#~ msgid "</defails>"
#~ msgstr "</defails>"

#~ msgid "* Arrays and `for` loops."
#~ msgstr "* Vetores e la√ßos `for`."

#~ msgid "* Alternatively, use the Rust Playground."
#~ msgstr "* Como alternativa, use o Rust Playground."

#~ msgid "[solutions]: solutions-morning.md"
#~ msgstr "[solu√ß√µes]: solutions-morning.md"

#~ msgid "[Using Cargo]: ../../cargo.md"
#~ msgstr "[Utiliza√ß√£o do Cargo]: ../../cargo.md"

#~ msgid "1. Execute the above program and look at the compiler error."
#~ msgstr "1. Execute o programa acima e observe o erro do compilador."

#~ msgid "2. Update the code above to use `into()` to do the conversion."
#~ msgstr "2. Atualize o c√≥digo acima para usar `into()` para fazer a convers√£o."

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
#~ "[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
#~ "[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
#~ "[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
#~ "[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"

#~ msgid ""
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    print!(\"Interagindo sobre uma faixa:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", vetor[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}"
#~ msgstr ""
#~ "fn transposta(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}"

#~ msgid ""
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}"
#~ msgstr ""
#~ "fn impressao_formatada(matriz: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let matriz = [\n"
#~ "        [101, 102, 103], // <-- o coment√°rio faz com que o rustfmt adicione uma nova linha\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];"

#~ msgid ""
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);"
#~ msgstr ""
#~ "    println!(\"matriz:\");\n"
#~ "    impressao_formatada(&matriz);"

#~ msgid ""
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let transposta = transposta(matriz);\n"
#~ "    println!(\"Transposta:\");\n"
#~ "    impressao_formatada(&transposta);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn takes_u32(x: u32) {\n"
#~ "    println!(\"u32: {x}\");\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn recebe_u32(x: u32) {\n"
#~ "    println!(\"u32: {x}\");\n"
#~ "}"

#~ msgid ""
#~ "fn takes_i8(y: i8) {\n"
#~ "    println!(\"i8: {y}\");\n"
#~ "}"
#~ msgstr ""
#~ "fn recebe_u8(y: i8) {\n"
#~ "    println!(\"i8: {y}\");\n"
#~ "}"

#~ msgid ""
#~ "    takes_u32(x);\n"
#~ "    takes_i8(y);\n"
#~ "    // takes_u32(y);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    recebe_u32(x);\n"
#~ "    recebe_u8(y);\n"
#~ "    // recebe_u32(y);\n"
#~ "}\n"
#~ "```"

#~ msgid "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"
#~ msgstr "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"Antes: {a}\");"

#~ msgid ""
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");"
#~ msgstr ""
#~ "    {\n"
#~ "        let a = \"Ol√°\";\n"
#~ "        println!(\"Escopo interno: {a}\");"

#~ msgid ""
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }"
#~ msgstr ""
#~ "        let a = true;\n"
#~ "        println!(\"Sobreposi√ß√£o no escopo interno: {a}\");\n"
#~ "    }"

#~ msgid ""
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"Depois: {a}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "* Heap: Storage of values outside of function calls.\n"
#~ "  * Values have dynamic sizes determined at runtime.\n"
#~ "  * Slightly slower than the stack: some book-keeping needed.\n"
#~ "  * No guarantee of memory locality."
#~ msgstr ""
#~ "* Heap: Armazenamento de valores fora das chamadas de fun√ß√£o.\n"
#~ "  * Os valores t√™m tamanhos din√¢micos determinados em tempo de execu√ß√£o.\n"
#~ "  * Ligeiramente mais lento que o stack: √© necess√°ria alguma contabilidade.\n"
#~ "  * Sem garantia de localiza√ß√£o na mem√≥ria."

#~ msgid ""
#~ "* Mention that a `String` is backed by a `Vec`, so it has a capacity and length and can grow if "
#~ "mutable via reallocation on the heap."
#~ msgstr ""
#~ "* Mencione que um `String` √© baseada em um `Vec`, ent√£o ele tem capacidade e comprimento e pode "
#~ "crescer se for mut√°vel por meio de realoca√ß√£o no heap."

#~ msgid ""
#~ "* If students ask about it, you can mention that the underlying memory is heap allocated using "
#~ "the [System Allocator] and custom allocators can be implemented using the [Allocator API]"
#~ msgstr ""
#~ "* Se os alunos perguntarem sobre isso, voc√™ pode mencionar que a mem√≥ria do heap √© alocada "
#~ "usando o [System Allocator] e alocadores personalizados podem ser implementados usando a "
#~ "[Allocator API]"

#~ msgid ""
#~ "* We can inspect the memory layout with `unsafe` code. However, you should point out that this "
#~ "is rightfully unsafe!"
#~ msgstr ""
#~ "* Pode-se inspecionar o layout de mem√≥ria com c√≥digo `unsafe`. Entretanto, deve-se salientar "
#~ "que isto √© inseguro!"

#~ msgid ""
#~ "[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
#~ "[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"
#~ msgstr ""
#~ "[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
#~ "[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"

#~ msgid "* You may be asked about destructors here, the [Drop] trait is the Rust equivalent."
#~ msgstr ""
#~ "* Voc√™ pode ser questionado sobre destrutores aqui, o trait [Drop] √© o equivalente em Rust."

#~ msgid ""
#~ "[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
#~ "[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
#~ "[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
#~ "[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
#~ "[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
#~ msgstr ""
#~ "[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
#~ "[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
#~ "[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
#~ "[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
#~ "[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "struct Point(i32, i32);"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "struct Ponto(i32, i32);"

#~ msgid "* In Rust, you clones are explicit (by using `clone`)."
#~ msgstr "* No Rust, clones s√£o expl√≠citos (usando `clone`)."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn diz_ola(nome: String) {\n"
#~ "    println!(\"Ol√° {nome}\")\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Copy, Clone, Debug)]\n"
#~ "struct Point(i32, i32);"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "#[derive(Copy, Clone, Debug)]\n"
#~ "struct Ponto(i32, i32);"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Ponto(i32, i32);"

#~ msgid ""
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
#~ "}"
#~ msgstr ""
#~ "fn somar(p1: &Ponto, p2: &Ponto) -> Ponto {\n"
#~ "    Ponto(p1.0 + p2.0, p1.1 + p2.1)\n"
#~ "}"

#~ msgid ""
#~ "Notes on stack returns:\n"
#~ "* Demonstrate that the return from `add` is cheap because the compiler can eliminate the copy "
#~ "operation. Change the above code to print stack addresses and run it on the [Playground]. In "
#~ "the \"DEBUG\" optimization level, the addresses should change, while the stay the same when "
#~ "changing to the \"RELEASE\" setting:"
#~ msgstr ""
#~ "Notas sobre retornos de pilha:\n"
#~ "* Demonstre que o retorno de `somar` √© barato porque o compilador pode eliminar a opera√ß√£o de "
#~ "c√≥pia. Altere o c√≥digo acima para imprimir endere√ßos de pilha e execute-o no [Playground]. No "
#~ "n√≠vel de otimiza√ß√£o \"DEBUG\", os endere√ßos devem mudar, enquanto permanecem os mesmos ao mudar "
#~ "para a configura√ß√£o \"RELEASE\":"

#~ msgid ""
#~ "  ```rust,editable\n"
#~ "  #[derive(Debug)]\n"
#~ "  struct Point(i32, i32);"
#~ msgstr ""
#~ "  ```rust, editable\n"
#~ "  #[derive(Debug)]\n"
#~ "  struct Ponto(i32, i32);"

#~ msgid ""
#~ "  fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
#~ "      println!(\"&p.0: {:p}\", &p.0);\n"
#~ "      p\n"
#~ "  }"
#~ msgstr ""
#~ "  fn somar(p1: &Ponto, p2: &Ponto) -> Ponto {\n"
#~ "      let p = Ponto(p1.0 + p2.0, p1.1 + p2.1);\n"
#~ "      println!(\"&p.0: {:p}\", &p.0);\n"
#~ "      p\n"
#~ "  }"

#~ msgid "[Playground]: https://play.rust-lang.org/"
#~ msgstr "[Playground]: https://play.rust-lang.org/"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let mut a: i32 = 10;\n"
#~ "    let b: &i32 = &a;"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let mut a: i32 = 10;\n"
#~ "    let b: &i32 = &a;"

#~ msgid ""
#~ "    {\n"
#~ "        let c: &mut i32 = &mut a;\n"
#~ "        *c = 20;\n"
#~ "    }"
#~ msgstr ""
#~ "    {\n"
#~ "        let c: &mut i32 = &mut a;\n"
#~ "        *c = 20;\n"
#~ "    }"

#~ msgid ""
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}"
#~ msgstr ""
#~ "fn mais_a_esquerda<'a>(p1: &'a Ponto, p2: &'a Ponto) -> &'a Ponto{\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}"

#~ msgid ""
#~ "* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), resulting in the "
#~ "following code:\n"
#~ "  ```rust,ignore\n"
#~ "  #[derive(Debug)]\n"
#~ "  struct Point(i32, i32);"
#~ msgstr ""
#~ "* Mova a declara√ß√£o de `p2` e `p3` para um novo escopo (`{ ... }`), resultando no seguinte "
#~ "c√≥digo:\n"
#~ "  ```rust, ignore\n"
#~ "  #[derive(Debug)]\n"
#~ "  struct Ponto(i32, i32);"

#~ msgid ""
#~ "  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "      if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "  }"
#~ msgstr ""
#~ "  fn mais_a_esquerda<'a>(p1: &'a Ponto, p2: &'a Ponto) -> &'a Ponto {\n"
#~ "      if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "  }"

#~ msgid ""
#~ "  fn main() {\n"
#~ "      let p1: Point = Point(10, 10);\n"
#~ "      let p3: &Point;\n"
#~ "      {\n"
#~ "          let p2: Point = Point(20, 20);\n"
#~ "          p3 = left_most(&p1, &p2);\n"
#~ "      }\n"
#~ "      println!(\"left-most point: {:?}\", p3);\n"
#~ "  }\n"
#~ "  ```\n"
#~ "  Note how this does not compile since `p3` outlives `p2`."
#~ msgstr ""
#~ "  fn main() {\n"
#~ "      let p1: Ponto = Ponto(10, 10);\n"
#~ "      let p3: &Ponto;\n"
#~ "      {\n"
#~ "          let p2: Ponto = Ponto(20, 20);\n"
#~ "          p3 = mais_a_esquerda(&p1, &p2);\n"
#~ "      }\n"
#~ "      println!(\"Ponto mais √† esquerda: {:?}\", p3);\n"
#~ "  }\n"
#~ "  ```\n"
#~ "  Observe como isso n√£o compila, pois `p3` sobrevive a `p2`."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Destaque<'doc>(&'doc str);"

#~ msgid ""
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}"
#~ msgstr ""
#~ "fn apagar(texto: String) {\n"
#~ "    println!(\"Tchau {texto}!\");\n"
#~ "}"

#~ msgid "* A small book library,"
#~ msgstr "* Uma pequena biblioteca de livros,"

#~ msgid "[solutions]: solutions-afternoon.md"
#~ msgstr "[solu√ß√µes]: solutions-afternoon.md"

#~ msgid ""
#~ "struct Library {\n"
#~ "    books: Vec<Book>,\n"
#~ "}"
#~ msgstr ""
#~ "struct Biblioteca {\n"
#~ "    livros: Vec<Livro>,\n"
#~ "}"

#~ msgid ""
#~ "struct Book {\n"
#~ "    title: String,\n"
#~ "    year: u16,\n"
#~ "}"
#~ msgstr ""
#~ "struct Livro {\n"
#~ "    titulo: String,\n"
#~ "    ano: u16,\n"
#~ "}"

#~ msgid ""
#~ "impl Book {\n"
#~ "    // This is a constructor, used below.\n"
#~ "    fn new(title: &str, year: u16) -> Book {\n"
#~ "        Book {\n"
#~ "            title: String::from(title),\n"
#~ "            year,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Livro {\n"
#~ "    // Este √© um construtor, usado abaixo.\n"
#~ "    fn new(titulo: &str, ano: u16) -> Livro {\n"
#~ "        Livro {\n"
#~ "            titulo: String::from(titulo),\n"
#~ "            ano,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// This makes it possible to print Book values with {}.\n"
#~ "impl std::fmt::Display for Book {\n"
#~ "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
#~ "        write!(f, \"{} ({})\", self.title, self.year)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "// Isso torna poss√≠vel imprimir valores de livro com {}.\n"
#~ "impl std::fmt::Display for Livro {\n"
#~ "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
#~ "        write!(f, \"{} ({})\", self.titulo, self.ano)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl Library {\n"
#~ "    fn new() -> Library {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "impl Biblioteca {\n"
#~ "    fn new() -> Biblioteca {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    //fn len(self) -> usize {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"
#~ msgstr ""
#~ "    //fn tamanho(self) -> usize {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"

#~ msgid ""
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"
#~ msgstr ""
#~ "    //fn tem_livros(self) -> bool {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"

#~ msgid ""
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"
#~ msgstr ""
#~ "    //fn adiciona_livro(self, livro: Livro) {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"

#~ msgid ""
#~ "    //fn print_books(self) {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"
#~ msgstr ""
#~ "    //fn imprime_acervo(self) {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}"

#~ msgid ""
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "}"
#~ msgstr ""
#~ "    //fn livro_mais_antigo(self) -> Option<&Livro> {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "}"

#~ msgid ""
#~ "// This shows the desired behavior. Uncomment the code below and\n"
#~ "// implement the missing methods. You will need to update the\n"
#~ "// method signatures, including the \"self\" parameter! You may\n"
#~ "// also need to update the variable bindings within main.\n"
#~ "fn main() {\n"
#~ "    let library = Library::new();"
#~ msgstr ""
#~ "// Isso mostra o comportamento desejado. Descomente o c√≥digo abaixo e\n"
#~ "// implemente os m√©todos ausentes. Voc√™ precisar√° atualizar as\n"
#~ "// assinaturas de m√©todo, incluindo o par√¢metro \"self\"! Voc√™ poder√°\n"
#~ "// tamb√©m precisar atualizar as liga√ß√µes de vari√°veis dentro de main.\n"
#~ "fn main() {\n"
#~ "    let biblioteca = Biblioteca::new();"

#~ msgid ""
#~ "    //println!(\"Our library is empty: {}\", library.is_empty());\n"
#~ "    //\n"
#~ "    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
#~ "    //\n"
#~ "    //library.print_books();\n"
#~ "    //\n"
#~ "    //match library.oldest_book() {\n"
#~ "    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
#~ "    //    None => println!(\"My library is empty!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"Our library has {} books\", library.len());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "   // println!(\"Nossa biblioteca est√° vazia: {}\", biblioteca.tem_livros());\n"
#~ "   // \n"
#~ "   // biblioteca.adiciona_livro(Livro::new(\"Lord of the Rings\", 1954));\n"
#~ "   // biblioteca.adiciona_livro(Livro::new(\"Alice's Adventures in Wonderland\", 1865));\n"
#~ "   // \n"
#~ "   // biblioteca.imprime_acervo();\n"
#~ "   // \n"
#~ "   // match biblioteca.livro_mais_antigo() {\n"
#~ "   //  Some(livro) => println!(\"Meu livro mais antigo √© {livro}\"),\n"
#~ "   //  None => println!(\"Minha biblioteca est√° vazia!\"),\n"
#~ "   // }\n"
#~ "   // \n"
#~ "   // println!(\"Nossa biblioteca tem {} livros\", biblioteca.tamanho());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();"

#~ msgid ""
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "    fn into_iter(self) -> Self::IntoIter;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    fn into_iter(self) -> Self::IntoIter;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"

#~ msgid ""
#~ "    for word in &v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }"
#~ msgstr ""
#~ "    for palavra in &v {\n"
#~ "        println!(\"Palavra: {palavra}\");\n"
#~ "    }"

#~ msgid ""
#~ "    for word in v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    for palavra in v {\n"
#~ "        println!(\"Palavra: {palavra}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "* Structs, enums, methods."
#~ msgstr "* Estruturas (`structs`), enumera√ß√µes (`enums`) e m√©todos."

#~ msgid "* Pattern matching: destructuring enums, structs, and arrays."
#~ msgstr "* Correspond√™ncia de padr√µes: desestruturando _enums_, _structs_ e vetores."

#~ msgid ""
#~ "* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and\n"
#~ "  `continue`."
#~ msgstr ""
#~ "* Constru√ß√µes de fluxo de controle: `if`, `if let`, `while`, `while let`, `break` e\n"
#~ "  `continue`."

#~ msgid ""
#~ "* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`\n"
#~ "  and `Arc`."
#~ msgstr ""
#~ "* A Biblioteca Padr√£o: `String`, `Option` e `Result`, `Vec`, `HashMap`, `Rc`\n"
#~ "  e 'Arc'."

#~ msgid "* Modules: visibility, paths, and filesystem hierarchy."
#~ msgstr "* M√≥dulos: visibilidade, caminhos e hierarquia do sistema de arquivos."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "struct Pessoa {\n"
#~ "    nome: String,\n"
#~ "    idade: u8,\n"
#~ "}"

#~ msgid ""
#~ "<details>\n"
#~ "Key Points: "
#~ msgstr ""
#~ "<details>\n"
#~ "Pontos chave:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Point(i32, i32);"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "struct Ponto(i32, i32);"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "struct PoundOfForce(f64);\n"
#~ "struct Newtons(f64);"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "struct PoundOfForce(f64);\n"
#~ "struct Newtons(f64);"

#~ msgid ""
#~ "fn compute_thruster_force() -> PoundOfForce {\n"
#~ "    todo!(\"Ask a rocket scientist at NASA\")\n"
#~ "}"
#~ msgstr ""
#~ "fn compute_thruster_force() -> PoundOfForce {\n"
#~ "    todo!(\"Pergunte a um cientista de foguetes da NASA\")\n"
#~ "}"

#~ msgid ""
#~ "fn set_thruster_force(force: Newtons) {\n"
#~ "    // ...\n"
#~ "}"
#~ msgstr ""
#~ "fn set_thruster_force(force: Newtons) {\n"
#~ "    // ...\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let force = compute_thruster_force();\n"
#~ "    set_thruster_force(force);\n"
#~ "}"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let force = compute_thruster_force();\n"
#~ "    set_thruster_force(force);\n"
#~ "}"

#~ msgid "```"
#~ msgstr "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Pessoa {\n"
#~ "    nome: String,\n"
#~ "    idade: u8,\n"
#~ "}"

#~ msgid ""
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Person {\n"
#~ "        Person { name, age }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Pessoa {\n"
#~ "    fn new(nome: String, idade: u8) -> Pessoa {\n"
#~ "        Pessoa { nome, idade }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let peter = Person::new(String::from(\"Peter\"), 27);\n"
#~ "    println!(\"{peter:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let pedro = Pessoa::new(String::from(\"Pedro\"), 27);\n"
#~ "    println!(\"{pedro:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The `new` function could be written using `Self` as a type, as it is interchangeable with the "
#~ "struct type name"
#~ msgstr ""
#~ "A fun√ß√£o `new` pode ser escrita usando `Self` como um tipo, j√° que √© intercambi√°vel com o name "
#~ "do tipo _struct_"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Self {\n"
#~ "        Self { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "```\n"
#~ "    \n"
#~ "</details>"
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "impl Pessoa {\n"
#~ "    fn new(nome: String, idade: u8) -> Self {\n"
#~ "        Self { nome, idade }\n"
#~ "    }\n"
#~ "}\n"
#~ "```\n"
#~ "    \n"
#~ "</details>"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn generate_random_number() -> i32 {\n"
#~ "    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn gerador_numero_aleatorio() -> i32 {\n"
#~ "    4 // Escolhido por jogada de dados justa. Garantido para ser aleat√≥rio.\n"
#~ "}"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "enum CoinFlip {\n"
#~ "    Heads,\n"
#~ "    Tails,\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "enum CaraCoroa {\n"
#~ "    Cara,\n"
#~ "    Coroa,\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    println!(\"You got: {:?}\", flip_coin());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    println!(\"Voc√™ tem: {:?}\", jogar_moeda());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "<details>\n"
#~ "    \n"
#~ "Key Points:"
#~ msgstr ""
#~ "<details>\n"
#~ "    \n"
#~ "Pontos chave:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // Variant without payload\n"
#~ "    KeyPress(char),           // Tuple struct variant\n"
#~ "    Click { x: i64, y: i64 }, // Full struct variant\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad, // Variante sem payload\n"
#~ "    KeyPress(char), // Variante da estrutura da tupla\n"
#~ "    Click { x: i64, y: i64 }, // Variante de struct completa\n"
#~ "}"

#~ msgid ""
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event{\n"
#~ "        WebEvent::PageLoad => println!(\"p√°gina carregada\"),\n"
#~ "        WebEvent::KeyPress(c) => println!(\"pressionou '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicou em x={x}, y={y}\"),\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };"

#~ msgid ""
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}"
#~ msgstr ""
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}"

#~ msgid ""
#~ "<details>\n"
#~ "    \n"
#~ "Key Points: \n"
#~ " * Internally Rust is using a field (discriminant) to keep track of the enum variant.\n"
#~ " * `Bar` enum demonstrates that there is a way to control the discriminant value and type. If "
#~ "`repr` is removed, the discriminant type takes 2 bytes, becuase 10001 fits 2 bytes.\n"
#~ " * As a niche optimization an enum discriminant is merged with the pointer so that "
#~ "`Option<&Foo>` is the same size as `&Foo`.\n"
#~ " * `Option<bool>` is another example of tight packing.\n"
#~ " * For [some types](https://doc.rust-lang.org/std/option/#representation), Rust guarantees that "
#~ "`size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
#~ " * Zero-sized types allow for efficient implementation of `HashSet` using `HashMap` with `()` "
#~ "as the value."
#~ msgstr ""
#~ "<details>\n"
#~ "    \n"
#~ "Pontos chave:\n"
#~ " * Internamente Rust est√° usando um campo (discriminante) para acompanhar a variante da enum.\n"
#~ " * A Enum `Bar` demonstra que existe uma maneira de controlar o valor e o tipo discriminante. "
#~ "Se `repr` for removido, o tipo discriminante ocupa 2 bytes, porque 10001 cabe 2 bytes.\n"
#~ " * Como uma otimiza√ß√£o de nicho, um discriminante de Enum √© mesclado com o ponteiro para que "
#~ "`Option<&Foo>` seja do mesmo tamanho que `&Foo`.\n"
#~ " * `Option<bool>` √© outro exemplo de empacotamento compacto.\n"
#~ " * Para [alguns tipos](https://doc.rust-lang.org/std/option/#representation), Rust garante que "
#~ "o `size_of::<T>()` √© igual a `size_of::<Option<T> >()`.\n"
#~ " * Tipos de tamanho zero permitem a implementa√ß√£o eficiente de `HashSet` usando `HashMap` com "
#~ "`()` como valor."

#~ msgid ""
#~ "Example code if you want to show how the bitwise representation *may* look like in practice.\n"
#~ "It's important to note that the compiler provides no guarantees regarding this representation, "
#~ "therefore this is totally unsafe."
#~ msgstr ""
#~ "C√≥digo de exemplo se voc√™ quiser mostrar como a representa√ß√£o bit a bit *pode* parecer na "
#~ "pr√°tica.\n"
#~ " √â importante observar que o compilador n√£o oferece garantias quanto a essa representa√ß√£o, "
#~ "portanto, isso √© totalmente inseguro."

#~ msgid ""
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        println!(\"Bitwise representation of bool\");\n"
#~ "        dbg_bits!(false, u8);\n"
#~ "        dbg_bits!(true, u8);"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    // TOTALMENTE INSEGURO. Rust n√£o oferece nenhuma garantia sobre a\n"
#~ "    // representa√ß√£o bit a bit de tipos.\n"
#~ "    unsafe {\n"
#~ "        println!(\"Representa√ß√£o bit a bit do tipo bool\");\n"
#~ "        dbg_bits!(false, u8);\n"
#~ "        dbg_bits!(true, u8);"

#~ msgid ""
#~ "        println!(\"Bitwise representation of Option<bool>\");\n"
#~ "        dbg_bits!(None::<bool>, u8);\n"
#~ "        dbg_bits!(Some(false), u8);\n"
#~ "        dbg_bits!(Some(true), u8);"
#~ msgstr ""
#~ "        println!(\"Representa√ß√£o bit a bit do tipo Option<bool>\");\n"
#~ "        dbg_bits!(None::<bool>, u8);\n"
#~ "        dbg_bits!(Some(false), u8);\n"
#~ "        dbg_bits!(Some(true), u8);"

#~ msgid ""
#~ "        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
#~ "        dbg_bits!(Some(Some(false)), u8);\n"
#~ "        dbg_bits!(Some(Some(true)), u8);\n"
#~ "        dbg_bits!(Some(None::<bool>), u8);\n"
#~ "        dbg_bits!(None::<Option<bool>>, u8);"
#~ msgstr ""
#~ "        println!(\"Representa√ß√£o bit a bit do tipo Option<Option<bool>>\");\n"
#~ "        dbg_bits!(Some(Some(false)), u8);\n"
#~ "        dbg_bits!(Some(Some(true)), u8);\n"
#~ "        dbg_bits!(Some(None::<bool>), u8);\n"
#~ "        dbg_bits!(None::<Option<bool>>, u8);"

#~ msgid ""
#~ "        println!(\"Bitwise representation of Option<&i32>\");\n"
#~ "        dbg_bits!(None::<&i32>, usize);\n"
#~ "        dbg_bits!(Some(&0i32), usize);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "        println!(\"Representa√ß√£o bit a bit do tipo Option<&i32>\");\n"
#~ "        dbg_bits!(None::<&i32>, usize);\n"
#~ "        dbg_bits!(Some(&0i32), usize);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "More complex example if you want to discuss what happens when we chain more than 256 `Option`s "
#~ "together."
#~ msgstr ""
#~ "Exemplo mais complexo se voc√™ quiser discutir o que acontece quando encadeamos mais de 256 "
#~ "`Option` juntas."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#![recursion_limit = \"1000\"]"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#![recursion_limit = \"1000\"]"

#~ msgid "use std::mem::transmute;"
#~ msgstr "use std::mem::transmute;"

#~ msgid ""
#~ "// Macro to wrap a value in 2^n Some() where n is the number of \"@\" signs.\n"
#~ "// Increasing the recursion limit is required to evaluate this macro.\n"
#~ "macro_rules! many_options {\n"
#~ "    ($value:expr) => { Some($value) };\n"
#~ "    ($value:expr, @) => {\n"
#~ "        Some(Some($value))\n"
#~ "    };\n"
#~ "    ($value:expr, @ $($more:tt)+) => {\n"
#~ "        many_options!(many_options!($value, $($more)+), $($more)+)\n"
#~ "    };\n"
#~ "}"
#~ msgstr ""
#~ "// Macro para envolver um valor com Some() 2^n vezes onde n √© o n√∫mero de simbolos \"@\"\n"
#~ "// √â necess√°rio aumentar o limite de recurs√£o para utilizar essa macro.\n"
#~ "macro_rules! many_options {\n"
#~ "    ($value:expr) => { Some($value) };\n"
#~ "    ($value:expr, @) => {\n"
#~ "        Some(Some($value))\n"
#~ "    };\n"
#~ "    ($value:expr, @ $($more:tt)+) => {\n"
#~ "        many_options!(many_options!($value, $($more)+), $($more)+)\n"
#~ "    };\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        assert_eq!(many_options!(false), Some(false));\n"
#~ "        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
#~ "        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    // TOTALMENTE INSEGURO. Rust n√£o oferece nenhuma garantia sobre a\n"
#~ "    // representa√ß√£o bit a bit de tipos.\n"
#~ "    unsafe {\n"
#~ "        assert_eq!(many_options!(false), Some(false));\n"
#~ "        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
#~ "        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"

#~ msgid ""
#~ "        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@), u8);"
#~ msgstr ""
#~ "        println!(\"Representa√ß√£o bit a bit de uma cadeia de 128 Option's.\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@), u8);"

#~ msgid ""
#~ "        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@@), u16);"
#~ msgstr ""
#~ "        println!(\"Representa√ß√£o bit a bit de uma cadeia de 256 Option's.\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@@), u16);"

#~ msgid ""
#~ "        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
#~ "        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "        println!(\"Representa√ß√£o bit a bit de uma cadeia de 257 Option's.\");\n"
#~ "        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "impl Person {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Hello, my name is {}\", self.name);\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Pessoa {\n"
#~ "    fn diz_ola(&self) {\n"
#~ "        println!(\"Ol√°, meu nome √© {}\", self.nome);\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    peter.say_hello();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let pedro = Pessoa {\n"
#~ "        nome: String::from(\"Pedro\"),\n"
#~ "        idade: 27,\n"
#~ "    };\n"
#~ "    pedro.diz_ola();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Race {\n"
#~ "    name: String,\n"
#~ "    laps: Vec<i32>,\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Corrida {\n"
#~ "    nome: String,\n"
#~ "    voltas: Vec<i32>,\n"
#~ "}"

#~ msgid ""
#~ "impl Race {\n"
#~ "    fn new(name: &str) -> Race {  // No receiver, a static method\n"
#~ "        Race { name: String::from(name), laps: Vec::new() }\n"
#~ "    }"
#~ msgstr ""
#~ "impl Corrida {\n"
#~ "    fn new(nome: &str) -> Corrida {  // Um m√©todo est√°tico, sem a defini√ß√£o de um receptor.\n"
#~ "        Corrida { nome: String::from(nome), voltas: Vec::new() }\n"
#~ "    }"

#~ msgid ""
#~ "    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access to self\n"
#~ "        self.laps.push(lap);\n"
#~ "    }"
#~ msgstr ""
#~ "    fn adiciona_volta(&mut self, volta: i32) { // Acesso emprestado de leitura e grava√ß√£o "
#~ "exclusivo para self\n"
#~ "        self.voltas.push(volta);\n"
#~ "    }"

#~ msgid ""
#~ "    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
#~ "        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
#~ "        for (idx, lap) in self.laps.iter().enumerate() {\n"
#~ "            println!(\"Lap {idx}: {lap} sec\");\n"
#~ "        }\n"
#~ "    }"
#~ msgstr ""
#~ "    fn imprime_voltas(&self) { // Acesso emprestado compartilhado e somente leitura para self\n"
#~ "        println!(\"Gravadas {} voltas para {}:\", self.voltas.len(), self.nome);\n"
#~ "        for (idx, volta) in self.voltas.iter().enumerate() {\n"
#~ "            println!(\"Volta {idx}: {volta} seg.\");\n"
#~ "        }\n"
#~ "    }"

#~ msgid ""
#~ "    fn finish(self) {  // Exclusive ownership of self\n"
#~ "        let total = self.laps.iter().sum::<i32>();\n"
#~ "        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn finaliza(self) { // ownership exclusiva de self\n"
#~ "        let total = self.voltas.iter().sum::<i32>();\n"
#~ "        println!(\"A corrida {} terminou, tempo total da volta: {}\", self.nome, total);\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let mut race = Race::new(\"Monaco Grand Prix\");\n"
#~ "    race.add_lap(70);\n"
#~ "    race.add_lap(68);\n"
#~ "    race.print_laps();\n"
#~ "    race.add_lap(71);\n"
#~ "    race.print_laps();\n"
#~ "    race.finish();\n"
#~ "    // race.add_lap(42);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let mut corrida = Corrida::new(\"Grande Pr√™mio de M√¥naco\");\n"
#~ "    corrida.adiciona_volta(70);\n"
#~ "    corrida.adiciona_volta(68);\n"
#~ "    corrida.imprime_voltas();\n"
#~ "    corrida.adiciona_volta(71);\n"
#~ "    corrida.imprime_voltas();\n"
#~ "    corrida.finaliza();\n"
#~ "    // corrida.adiciona_volta(42);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let input = 'x';"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let input = 'x';"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum Result {\n"
#~ "    Ok(i32),\n"
#~ "    Err(String),\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum Result {\n"
#~ "    Ok(i32),\n"
#~ "    Err(String),\n"
#~ "}"

#~ msgid ""
#~ "fn divide_in_two(n: i32) -> Result {\n"
#~ "    if n % 2 == 0 {\n"
#~ "        Result::Ok(n / 2)\n"
#~ "    } else {\n"
#~ "        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "fn divide_por_dois(n: i32) -> Result {\n"
#~ "    if n % 2 == 0 {\n"
#~ "        Result::Ok(n/2)\n"
#~ "    } else {\n"
#~ "        Result::Err(format!(\"N√£o √© poss√≠vel dividir {} em duas partes iguais\", n))\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Foo {\n"
#~ "    x: (u32, u32),\n"
#~ "    y: u32,\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "struct Foo {\n"
#~ "    x: (u32, u32),\n"
#~ "    y: u32,\n"
#~ "}"

#~ msgid ""
#~ "* Change the literal values in `foo` to match with the other patterns.\n"
#~ "* Add a new field to `Foo` and make changes to the pattern as needed.\n"
#~ "</details>"
#~ msgstr ""
#~ "* Altere os valores literais em `foo` para corresponderem com outros padr√µes.\n"
#~ "* Adicione um novo campo em `Foo` e fa√ßa as altera√ß√µes no padr√£o conforme necess√°rio.\n"
#~ "</details>"

#~ msgid "* Destructuring of slices of unknown length also works with patterns of fixed length."
#~ msgstr ""
#~ "* Desestruturar slices de tamanho desconhecido tamb√©m funciona com padr√µes de tamanho fixo."

#~ msgid "* Simple struct which tracks health statistics."
#~ msgstr "* Estrutura simples que rastreia as estat√≠sticas de sa√∫de."

#~ msgid ""
#~ "struct User {\n"
#~ "    name: String,\n"
#~ "    age: u32,\n"
#~ "    weight: f32,\n"
#~ "}"
#~ msgstr ""
#~ "struct Usuario {\n"
#~ "    nome: String,\n"
#~ "    idade: u32,\n"
#~ "    peso: f32,\n"
#~ "}"

#~ msgid ""
#~ "impl User {\n"
#~ "    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "impl Usuario {\n"
#~ "    pub fn new(nome: String, idade: u32, peso: f32) -> Self {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn name(&self) -> &str {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn nome(&self) -> &str {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn age(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn idade(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn weight(&self) -> f32 {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn peso(&self) -> f32 {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn set_age(&mut self, new_age: u32) {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn setar_idade(&mut self, nova_idade: u32) {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn set_weight(&mut self, new_weight: f32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    pub fn setar_peso(&mut self, novo_peso: f32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
#~ "}"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let bob = Usuario::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    println!(\"Sou {} e minha idade √© {}\", bob.nome(), bob.idade());\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_weight() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.weight(), 155.2);\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_peso() {\n"
#~ "    let bob = Usuario::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.peso(), 155.2);\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_set_age() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.age(), 32);\n"
#~ "    bob.set_age(33);\n"
#~ "    assert_eq!(bob.age(), 33);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_setar_idade() {\n"
#~ "    let mut bob = Usuario::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.idade(), 32);\n"
#~ "    bob.setar_idade(33);\n"
#~ "    assert_eq!(bob.idade(), 33);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remova isso quando terminar sua implementa√ß√£o.\n"
#~ "#![allow(unused_variables, dead_code)]"

#~ msgid ""
#~ "pub struct Point {\n"
#~ "    // add fields\n"
#~ "}"
#~ msgstr ""
#~ "pub struct Ponto {\n"
#~ "    // adicione os campos\n"
#~ "}"

#~ msgid ""
#~ "impl Point {\n"
#~ "    // add methods\n"
#~ "}"
#~ msgstr ""
#~ "impl Ponto {\n"
#~ "    // adicione os m√©todos\n"
#~ "}"

#~ msgid ""
#~ "pub struct Polygon {\n"
#~ "    // add fields\n"
#~ "}"
#~ msgstr ""
#~ "pub struct Poligono {\n"
#~ "    // adicione os campos\n"
#~ "}"

#~ msgid ""
#~ "impl Polygon {\n"
#~ "    // add methods\n"
#~ "}"
#~ msgstr ""
#~ "impl Poligono {\n"
#~ "    // adicione os m√©todos\n"
#~ "}"

#~ msgid ""
#~ "pub struct Circle {\n"
#~ "    // add fields\n"
#~ "}"
#~ msgstr ""
#~ "pub struct Circulo {\n"
#~ "    // adicione os campos\n"
#~ "}"

#~ msgid ""
#~ "impl Circle {\n"
#~ "    // add methods\n"
#~ "}"
#~ msgstr ""
#~ "impl Circulo {\n"
#~ "    // adicione os m√©todos\n"
#~ "}"

#~ msgid ""
#~ "pub enum Shape {\n"
#~ "    Polygon(Polygon),\n"
#~ "    Circle(Circle),\n"
#~ "}"
#~ msgstr ""
#~ "pub enum Forma {\n"
#~ "    Poligono(Poligono),\n"
#~ "    Circulo(Circulo),\n"
#~ "}"

#~ msgid ""
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;"
#~ msgstr ""
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;"

#~ msgid ""
#~ "    fn round_two_digits(x: f64) -> f64 {\n"
#~ "        (x * 100.0).round() / 100.0\n"
#~ "    }"
#~ msgstr ""
#~ "    fn arredonda_dois_digitos(x: f64) -> f64 {\n"
#~ "        (x * 100.0).round() / 100.0\n"
#~ "    }"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_point_magnitude() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
#~ "    }"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_magnitude_ponto() {\n"
#~ "        let p1 = Ponto::new(12, 13);\n"
#~ "        assert_eq!(arredonda_dois_digitos(p1.magnitude()), 17.69);\n"
#~ "    }"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_point_dist() {\n"
#~ "        let p1 = Point::new(10, 10);\n"
#~ "        let p2 = Point::new(14, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
#~ "    }"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_distancia_pontos() {\n"
#~ "        let p1 = Ponto::new(10, 10);\n"
#~ "        let p2 = Ponto::new(14, 13);\n"
#~ "        assert_eq!(arredonda_dois_digitos(p1.dist(p2)), 5.00);\n"
#~ "    }"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_point_add() {\n"
#~ "        let p1 = Point::new(16, 16);\n"
#~ "        let p2 = p1 + Point::new(-4, 3);\n"
#~ "        assert_eq!(p2, Point::new(12, 19));\n"
#~ "    }"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_somar_pontos() {\n"
#~ "        let p1 = Ponto::new(16, 16);\n"
#~ "        let p2 = p1 + Ponto::new(-4, 3);\n"
#~ "        assert_eq!(p2, Ponto::new(12, 19));\n"
#~ "    }"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_polygon_left_most_point() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_poligono_ponto_mais_a_esquerda() {\n"
#~ "        let p1 = Ponto::new(12, 13);\n"
#~ "        let p2 = Ponto::new(16, 16);"

#~ msgid ""
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "        assert_eq!(poly.left_most_point(), Some(p1));\n"
#~ "    }"
#~ msgstr ""
#~ "        let mut poly = Poligono::new();\n"
#~ "        poly.adiciona_ponto(p1);\n"
#~ "        poly.adiciona_ponto(p2);\n"
#~ "        assert_eq!(poly.ponto_mais_a_esquerda(), Some(p1));\n"
#~ "    }"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_polygon_iter() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_poligono_iter() {\n"
#~ "        let p1 = Ponto::new(12, 13);\n"
#~ "        let p2 = Ponto::new(16, 16);"

#~ msgid ""
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);"
#~ msgstr ""
#~ "        let mut poly = Poligono::new();\n"
#~ "        poly.adiciona_ponto(p1);\n"
#~ "        poly.adiciona_ponto(p2);"

#~ msgid ""
#~ "        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
#~ "        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
#~ "    }"
#~ msgstr ""
#~ "        let pontos = poly.iter().cloned().collect::<Vec<_>>();\n"
#~ "        assert_eq!(pontos, vec![Ponto::new(12, 13), Ponto::new(16, 16)]);\n"
#~ "    }"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_shape_perimeters() {\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(Point::new(12, 13));\n"
#~ "        poly.add_point(Point::new(17, 11));\n"
#~ "        poly.add_point(Point::new(16, 16));\n"
#~ "        let shapes = vec![\n"
#~ "            Shape::from(poly),\n"
#~ "            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimeters = shapes\n"
#~ "            .iter()\n"
#~ "            .map(Shape::perimeter)\n"
#~ "            .map(round_two_digits)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_perimetros_da_forma() {\n"
#~ "        let mut poly = Poligono::new();\n"
#~ "        poly.adiciona_ponto(Ponto::new(12, 13));\n"
#~ "        poly.adiciona_ponto(Ponto::new(17, 11));\n"
#~ "        poly.adiciona_ponto(Ponto::new(16, 16));\n"
#~ "        let formas = vec![\n"
#~ "            Forma::from(poly),\n"
#~ "            Forma::from(Circulo::new(Ponto::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimetros = formas\n"
#~ "            .iter()\n"
#~ "            .map(Forma::perimetro)\n"
#~ "            .map(arredonda_dois_digitos)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimetros, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn double(x: i32) -> i32 {\n"
#~ "    x + x\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn dobro(x: i32) -> i32 {\n"
#~ "    x + x\n"
#~ "}"

#~ msgid "You use `if` very similarly to how you would in other languages:"
#~ msgstr "Voc√™ usa `if` de forma muito semelhante a como faria em outras linguagens:"

#~ msgid "If you want to match a value against a pattern, you can use `if let`:"
#~ msgstr "Se voc√™ deseja corresponder um valor a um padr√£o, pode usar `if let`:"

#~ msgid ""
#~ "* `if let` can be more concise than `match`, e.g., when only one case is interesting. In "
#~ "contrast, `match` requires all branches to be covered.\n"
#~ "    * For the similar use case consider demonstrating a newly stabilized [`let else`](https://"
#~ "github.com/rust-lang/rust/pull/93628) feature.\n"
#~ "* A common usage is handling `Some` values when working with `Option`.\n"
#~ "* Unlike `match`, `if let` does not support guard clauses for pattern matching."
#~ msgstr ""
#~ "* `if let` pode ser mais conciso que `match`, por exemplo, quando apenas um caso √© "
#~ "interessante. Em contraste, `match` requer que todas as ramifica√ß√µes sejam cobertas.\n"
#~ "    * Para o caso de uso semelhante, considere demonstrar um recurso [`let else`](https://"
#~ "github.com/rust-lang/rust/pull/93628) recentemente estabilizado.\n"
#~ "* Um uso comum √© lidar com valores `Some` ao trabalhar com `Option`.\n"
#~ "* Ao contr√°rio de `match`, `if let` n√£o suporta cl√°usulas de guarda para correspond√™ncia de "
#~ "padr√µes."

#~ msgid "The `while` keyword works very similar to other languages:"
#~ msgstr "A palavra-chave `while` funciona de maneira muito semelhante a outras linguagens:"

#~ msgid ""
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# `for` expressions"
#~ msgstr "# Express√µes Para (`for`)"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];"

#~ msgid ""
#~ "<details>\n"
#~ "    \n"
#~ "* Break the `loop` with a value (e.g. `break 8`) and print it out."
#~ msgstr ""
#~ "<details>\n"
#~ "    \n"
#~ "* Break o `loop` com um valor (ex. `break 8`) e mostre-o."

#~ msgid ""
#~ "* [`Option` and `Result`](std/option-result.md) types: used for optional values\n"
#~ "  and [error handling](error-handling.md)."
#~ msgstr ""
#~ "* Tipos [`Option` e `Result`](std/option-result.md): usados para valores opcionais\n"
#~ "  e [manipula√ß√£o de erros](error-handling.md)."

#~ msgid "* [`String`](std/string.md): the default string type used for owned data."
#~ msgstr ""
#~ "* [`String`](std/string.md): o tipo de cadeia de caracteres padr√£o extens√≠vel usado para dados."

#~ msgid "* [`Vec`](std/vec.md): a standard extensible vector."
#~ msgstr "* [`Vec`](std/vec.md): um vetor extens√≠vel padr√£o."

#~ msgid ""
#~ "* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
#~ "  algorithm."
#~ msgstr ""
#~ "* [`HashMap`](std/hashmap.md): um tipo de mapa hash com o algoritmo de hashing configur√°vel."

#~ msgid "* [`Box`](std/box.md): an owned pointer for heap-allocated data."
#~ msgstr "* [`Box`](std/box.md): um ponteiro pr√≥prio para dados alocados em heap."

#~ msgid "* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated data."
#~ msgstr ""
#~ "* [`Rc`](std/rc.md): um ponteiro de contagem de refer√™ncia compartilhado para dados alocados em "
#~ "heap."

#~ msgid ""
#~ "    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
#~ "    println!(\"idx: {idx:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let idx: Result<usize, usize> = numeros.binary_search(&10);\n"
#~ "    println!(\"Indice: {idx:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::new();\n"
#~ "    s1.push_str(\"Hello\");\n"
#~ "    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::new();\n"
#~ "    s1.push_str(\"Ol√°\");\n"
#~ "    println!(\"s1: tamanho = {}, capacidade = {}\", s1.len(), s1.capacity());"

#~ msgid ""
#~ "    let mut s2 = String::with_capacity(s1.len() + 1);\n"
#~ "    s2.push_str(&s1);\n"
#~ "    s2.push('!');\n"
#~ "    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());"
#~ msgstr ""
#~ "    let mut s2 = String::with_capacity(s1.len() + 1);\n"
#~ "    s2.push_str(&s1);\n"
#~ "    s2.push('!');\n"
#~ "    println!(\"s2: tamanho = {}, capacidade = {}\", s2.len(), s2.capacity());"

#~ msgid ""
#~ "    let s3 = String::from(\"üá®üá≠\");\n"
#~ "    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
#~ "             s3.chars().count());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let s3 = String::from(\"üá®üá≠\");\n"
#~ "    println!(\"s3: tamanho = {}, n√∫mero de caracteres = {}\", s3.len(),\n"
#~ "             s3.chars().count());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
#~ "[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
#~ "[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"

#~ msgid ""
#~ "* `len` returns the size of the `String` in bytes, not its length in characters.\n"
#~ "* `chars` returns an iterator over the actual characters.\n"
#~ "* `String` implements `Deref<Target = str>` which transparently gives it access to `str`'s "
#~ "methods."
#~ msgstr ""
#~ "* `len` retorna o tamanho da `String` em bytes, n√£o seu comprimento em caracteres.\n"
#~ "* `chars` retorna um iterador sobre os caracteres reais.\n"
#~ "* `String` implementa `Deref<Target = str>` que d√° acesso transparente aos m√©todos de `str`."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v1 = Vec::new();\n"
#~ "    v1.push(42);\n"
#~ "    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let mut v1 = Vec::new();\n"
#~ "    v1.push(42);\n"
#~ "    println!(\"v1: tamanho = {}, capacidade = {}\", v1.len(), v1.capacity());"

#~ msgid ""
#~ "    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
#~ "    v2.extend(v1.iter());\n"
#~ "    v2.push(9999);\n"
#~ "    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());"
#~ msgstr ""
#~ "    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
#~ "    v2.extend(v1.iter());\n"
#~ "    v2.push(9999);\n"
#~ "    println!(\"v2: tamanho = {}, capacidade = {}\", v2.len(), v2.capacity());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "    // Canonical macro to initialize a vector with elements.\n"
#~ "    let mut v3 = vec![0, 0, 1, 2, 3, 4];"
#~ msgstr ""
#~ "    // Macro can√¥nica para inicializar um vetor com elementos.\n"
#~ "    let mut v3 = vec![0, 0, 1, 2, 3, 4];"

#~ msgid ""
#~ "    // Retain only the even elements.\n"
#~ "    v3.retain(|x| x % 2 == 0);\n"
#~ "    println!(\"{v3:?}\");"
#~ msgstr ""
#~ "    // Ret√©m somente os elementos pares.\n"
#~ "    v3.retain(|x| x % 2 == 0);\n"
#~ "    println!(\"{v3:?}\");"

#~ msgid ""
#~ "    // Remove consecutive duplicates.\n"
#~ "    v3.dedup();\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    // Remove valores duplicados consecutivos.\n"
#~ "    v3.dedup();\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
#~ "[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
#~ "[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let mut page_counts = HashMap::new();\n"
#~ "    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
#~ "    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
#~ "    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let mut meus_livros = HashMap::new();\n"
#~ "    meus_livros.insert(\"Aventuras de Huckleberry Finn\".to_string(), 207);\n"
#~ "    meus_livros.insert(\"Contos de Fadas dos Grimms\".to_string(), 751);\n"
#~ "    meus_livros.insert(\"Orgulho e Preconceito\".to_string(), 303);"

#~ msgid ""
#~ "    if !page_counts.contains_key(\"Les Mis√©rables\") {\n"
#~ "        println!(\"We know about {} books, but not Les Mis√©rables.\",\n"
#~ "                 page_counts.len());\n"
#~ "    }"
#~ msgstr ""
#~ "    if !meus_livros.contains_key(\"Os Miser√°veis\") {\n"
#~ "        println!(\"Tenho {} livros, mas n√£o Os Miser√°veis.\",\n"
#~ "                 meus_livros.len());\n"
#~ "    }"

#~ msgid ""
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
#~ "        match page_counts.get(book) {\n"
#~ "            Some(count) => println!(\"{book}: {count} pages\"),\n"
#~ "            None => println!(\"{book} is unknown.\")\n"
#~ "        }\n"
#~ "    }"
#~ msgstr ""
#~ "    for livro in [\"Orgulho e Preconceito\", \"Alice no Pa√≠s das Maravilhas\"] {\n"
#~ "        match meus_livros.get(livro) {\n"
#~ "            Some(paginas) => println!(\"{livro}: {paginas} p√°ginas\"),\n"
#~ "            None => println!(\"{livro} √© desconhecido.\")\n"
#~ "        }\n"
#~ "    }"

#~ msgid ""
#~ "    // Use the .entry() method to insert a value if nothing is found.\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
#~ "        let page_count: &mut i32 = page_counts.entry(book.to_string()).or_insert(0);\n"
#~ "        *page_count += 1;\n"
#~ "    }"
#~ msgstr ""
#~ "    // Use o m√©todo .entry() para inserir um valor, caso este n√£o seja encontrado.\n"
#~ "    for livro in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
#~ "        let meu_livro: &mut i32 = meus_livros.entry(livro.to_string()).or_insert(0);\n"
#~ "        *meu_livro += 1;\n"
#~ "    }"

#~ msgid ""
#~ "    println!(\"{page_counts:#?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"{meus_livros:#?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
#~ msgstr "* Diferente de `vec!`, infelizmente n√£o h√° uma macro padr√£o `hashmap!`."

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
#~ "[2]: https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
#~ "[2]: https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "enum List<T> {\n"
#~ "    Cons(T, Box<List<T>>),\n"
#~ "    Nil,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "enum List<T> {\n"
#~ "    Cons(T, Box<List<T>>),\n"
#~ "    Nil,\n"
#~ "}"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                           Heap\n"
#~ ".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
#~ ":                         :     :                                               :\n"
#~ ":    list                 :     :                                               :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":   | Tag    | Cons  |    :     : .->| Tag    | Cons   | .->| Tag    | Nil  |   :\n"
#~ ":   | 0      | 1     |    :     : |  | 0      | 2      | |  | ////// | //// |   :\n"
#~ ":   | 1      | o-----+----+-----+-'  | 1      | o------+-'  | ////// | //// |   :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":                         :     :                                               :\n"
#~ ":                         :     :                                               :\n"
#~ "`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                           Heap\n"
#~ ".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
#~ ":                         :     :                                               :\n"
#~ ":    lista                :     :                                               :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":   | Tag    | Cons  |    :     : .->| Tag    | Cons   | .->| Tag    | Nil  |   :\n"
#~ ":   | 0      | 1     |    :     : |  | 0      | 2      | |  | ////// | //// |   :\n"
#~ ":   | 1      | o-----+----+-----+-'  | 1      | o------+-'  | ////// | //// |   :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":                         :     :                                               :\n"
#~ ":                         :     :                                               :\n"
#~ "`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "* Remove the `Box` in the List definition and show the compiler error. `Recursive with "
#~ "indirection` is a hint you might want to use a Box or reference of some kind, instead of "
#~ "storing a value directly.   \n"
#~ "    \n"
#~ "</details>"
#~ msgstr ""
#~ "* Remova a `Box` da defini√ß√£o da `List` e veja o erro apresentado pelo compilador. `Recursive "
#~ "with indirection` √© o aviso que voc√™ vai receber.</details>"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::rc::Rc;"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::rc::Rc;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let mut a = Rc::new(10);\n"
#~ "    let mut b = a.clone();"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let mut a = Rc::new(10);\n"
#~ "    let mut b = a.clone();"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
#~ "[2]: https://doc.rust-lang.org/std/cell/index.html\n"
#~ "[3]: ../concurrency/shared_state/arc.md\n"
#~ "[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
#~ "[2]: https://doc.rust-lang.org/std/cell/index.html\n"
#~ "[3]: ../concurrency/shared_state/arc.md\n"
#~ "[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::rc::{Rc, Weak};\n"
#~ "use std::cell::RefCell;"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::rc::{Rc, Weak};\n"
#~ "use std::cell::RefCell;"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "struct Node {\n"
#~ "    value: i64,\n"
#~ "    parent: Option<Weak<RefCell<Node>>>,\n"
#~ "    children: Vec<Rc<RefCell<Node>>>,\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "struct No {\n"
#~ "    valor: i64,\n"
#~ "    pai: Option<Weak<RefCell<No>>>,\n"
#~ "    filhos: Vec<Rc<RefCell<No>>>,\n"
#~ "}"

#~ msgid ""
#~ "    println!(\"graph: {root:#?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"grafo: {raiz:#?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "mod foo {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the foo module\");\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "mod foo {\n"
#~ "    pub fn qualquer_coisa() {\n"
#~ "        println!(\"Qualquer coisa no m√≥dulo foo\");\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "mod bar {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the bar module\");\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "mod bar {\n"
#~ "    pub fn qualquer_coisa() {\n"
#~ "        println!(\"Qualquer coisa no modulo bar\");\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    foo::do_something();\n"
#~ "    bar::do_something();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    foo::qualquer_coisa();\n"
#~ "    bar::qualquer_coisa();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "mod outer {\n"
#~ "    fn private() {\n"
#~ "        println!(\"outer::private\");\n"
#~ "    }"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "mod exterior {\n"
#~ "    fn privado() {\n"
#~ "        println!(\"externo::privado\");\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn public() {\n"
#~ "        println!(\"outer::public\");\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn public() {\n"
#~ "        println!(\"externo::p√∫blico\");\n"
#~ "    }"

#~ msgid ""
#~ "    mod inner {\n"
#~ "        fn private() {\n"
#~ "            println!(\"outer::inner::private\");\n"
#~ "        }"
#~ msgstr ""
#~ "    mod interior {\n"
#~ "        fn privado() {\n"
#~ "            println!(\"externo::interno::privado\");\n"
#~ "        }"

#~ msgid ""
#~ "        pub fn public() {\n"
#~ "            println!(\"outer::inner::public\");\n"
#~ "            super::private();\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "        pub fn public() {\n"
#~ "            println!(\"externo::interno::p√∫blico\");\n"
#~ "            super::privado();\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    outer::public();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    exterior::public();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "1. As a relative path:\n"
#~ "   * `foo` or `self::foo` refers to `foo` in the current module,\n"
#~ "   * `super::foo` refers to `foo` in the parent module."
#~ msgstr ""
#~ "1. Como caminho relativo:\n"
#~ "   * `foo` ou `self::foo` refere-se a `foo` no m√≥dulo atual,\n"
#~ "   * `super::foo` refere-se a `foo` no m√≥dulo pai."

#~ msgid "* Ignore all spaces. Reject number with less than two digits."
#~ msgstr "* Ignora todos os espa√ßos. Rejeita n√∫meros com menos de dois d√≠gitos."

#~ msgid ""
#~ "* Moving from right to left, double every second digit: for the number `1234`,\n"
#~ "  we double `3` and `1`."
#~ msgstr ""
#~ "* Movendo-se da direita para a esquerda, dobra cada segundo d√≠gito: para o n√∫mero `1234`,\n"
#~ "  dobra os n√∫meros `3` e `1`."

#~ msgid ""
#~ "* After doubling a digit, sum the digits. So doubling `7` becomes `14` which\n"
#~ "  becomes `5`."
#~ msgstr ""
#~ "* Depois de dobrar um d√≠gito, soma os d√≠gitos. Assim, duplicar `7` resulta em `14` que\n"
#~ "  resulta em `5`."

#~ msgid "* Sum all the undoubled and doubled digits."
#~ msgstr "* Soma todos os d√≠gitos n√£o duplicados e duplicados."

#~ msgid "* The credit card number is valid if the sum ends with `0`."
#~ msgstr "* O n√∫mero do cart√£o de cr√©dito √© v√°lido se a soma terminar em `0`."

#~ msgid ""
#~ "pub fn luhn(cc_number: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}"
#~ msgstr ""
#~ "pub fn luhn(numero_cc: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_non_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_nao_numerico() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_empty_cc_number() {\n"
#~ "    assert!(!luhn(\"\"));\n"
#~ "    assert!(!luhn(\" \"));\n"
#~ "    assert!(!luhn(\"  \"));\n"
#~ "    assert!(!luhn(\"    \"));\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_vazio() {\n"
#~ "    assert!(!luhn(\"\"));\n"
#~ "    assert!(!luhn(\" \"));\n"
#~ "    assert!(!luhn(\"  \"));\n"
#~ "    assert!(!luhn(\"    \"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_single_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"0\"));\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_um_numero() {\n"
#~ "    assert!(!luhn(\"0\"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_two_digit_cc_number() {\n"
#~ "    assert!(luhn(\" 0 0 \"));\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_dois_numeros() {\n"
#~ "    assert!(luhn(\" 0 0 \"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_valid_cc_number() {\n"
#~ "    assert!(luhn(\"4263 9826 4026 9299\"));\n"
#~ "    assert!(luhn(\"4539 3195 0343 6467\"));\n"
#~ "    assert!(luhn(\"7992 7398 713\"));\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_valido() {\n"
#~ "    assert!(luhn(\"4263 9826 4026 9299\"));\n"
#~ "    assert!(luhn(\"4539 3195 0343 6467\"));\n"
#~ "    assert!(luhn(\"7992 7398 713\"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_invalid_cc_number() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_invalido() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}"

#~ msgid ""
#~ "pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}"
#~ msgstr ""
#~ "pub fn correspondencia_prefixo(prefixo: &str, caminho_requisitado: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_correspondencia_sem_curinga() {\n"
#~ "    assert!(correspondencia_prefixo(\"/v1/autores\", \"/v1/autores\"));\n"
#~ "    assert!(correspondencia_prefixo(\"/v1/autores\", \"/v1/autores/abc-123\"));\n"
#~ "    assert!(correspondencia_prefixo(\"/v1/autores\", \"/v1/autores/abc/livros\"));"

#~ msgid ""
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
#~ "}"
#~ msgstr ""
#~ "    assert!(!correspondencia_prefixo(\"/v1/autores\", \"/v1\"));\n"
#~ "    assert!(!correspondencia_prefixo(\"/v1/autores\", \"/v1/autoresLivros\"));\n"
#~ "    assert!(!correspondencia_prefixo(\"/v1/autores\", \"/v1/parent/autores\"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_matches_with_wildcard() {\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/bar/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books/book1\"\n"
#~ "    ));"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_correspondencia_com_curinga() {\n"
#~ "    assert!(correspondencia_prefixo(\n"
#~ "        \"/v1/autores/*/livros\",\n"
#~ "        \"/v1/autores/foo/livros\"\n"
#~ "    ));\n"
#~ "    assert!(correspondencia_prefixo(\n"
#~ "        \"/v1/autores/*/livros\",\n"
#~ "        \"/v1/autores/bar/livros\"\n"
#~ "    ));\n"
#~ "    assert!(correspondencia_prefixo(\n"
#~ "        \"/v1/autores/*/livros\",\n"
#~ "        \"/v1/autores/foo/livros/livro1\"\n"
#~ "    ));"

#~ msgid ""
#~ "    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
#~ "    assert!(!prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    assert!(!correspondencia_prefixo(\"/v1/autores/*/livros\", \"/v1/autores\"));\n"
#~ "    assert!(!correspondencia_prefixo(\n"
#~ "        \"/v1/autores/*/livros\",\n"
#~ "        \"/v1/autores/foo/livrosPorAutor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "* Traits: deriving traits, default methods, and important standard library\n"
#~ "  traits."
#~ msgstr ""
#~ "* Traits (Caracter√≠sticas): Traits derivadas, m√©todos padr√£o e Traits importantes da biblioteca "
#~ "padr√£o."

#~ msgid ""
#~ "* Generics: generic data types, generic methods, monomorphization, and trait\n"
#~ "  objects."
#~ msgstr ""
#~ "* Generics (Gen√©ricos): tipos de dados gen√©ricos, m√©todos gen√©ricos, monomorfiza√ß√£o e trait\n"
#~ "  objetos."

#~ msgid "* Error handling: panics, `Result`, and the try operator `?`."
#~ msgstr "* Tratamento de erros: p√¢nico (_panics_), `Result` e o operador _try_ `?`."

#~ msgid "* Testing: unit tests, documentation tests, and integration tests."
#~ msgstr "* Testes: testes unit√°rios, testes de documenta√ß√£o e testes de integra√ß√£o."

#~ msgid ""
#~ "* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
#~ "  functions."
#~ msgstr ""
#~ "* Rust inseguro (unsafe): ponteiros brutos, vari√°veis est√°ticas, fun√ß√µes inseguras e fun√ß√µes "
#~ "externas."

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Greet {\n"
#~ "    fn say_hello(&self);\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Saudar {\n"
#~ "    fn diz_ola(&self);\n"
#~ "}"

#~ msgid ""
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}"
#~ msgstr ""
#~ "struct Cachorro {\n"
#~ "    nome: String,\n"
#~ "}"

#~ msgid "struct Cat;  // No name, cats won't respond to it anyway."
#~ msgstr "struct Gato; // Sem nome, os gatos n√£o v√£o responder de qualquer maneira."

#~ msgid ""
#~ "impl Greet for Dog {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Wuf, my name is {}!\", self.name);\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Saudar for Cachorro {\n"
#~ "    fn diz_ola(&self) {\n"
#~ "        println!(\"Wuf, meu nome √© {}!\", self.nome);\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl Greet for Cat {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Miau!\");\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Saudar for Gato {\n"
#~ "    fn diz_ola(&self) {\n"
#~ "        println!(\"Miau!\");\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let pets: Vec<Box<dyn Greet>> = vec![\n"
#~ "        Box::new(Dog { name: String::from(\"Fido\") }),\n"
#~ "        Box::new(Cat),\n"
#~ "    ];\n"
#~ "    for pet in pets {\n"
#~ "        pet.say_hello();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let pets: Vec<Box<dyn Saudar>> = vec![\n"
#~ "        Box::new(Cachorro{ nome: String::from(\"Fido\") }),\n"
#~ "        Box::new(Gato),\n"
#~ "    ];\n"
#~ "    for pet in pets {\n"
#~ "        pet.diz_ola();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Compare these outputs in the above example:\n"
#~ "```rust,ignore\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
#~ "```"
#~ msgstr ""
#~ "Compare essas sa√≠das no exemplo acima:\n"
#~ "```rust, ignore\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
#~ "struct Player {\n"
#~ "    name: String,\n"
#~ "    strength: u8,\n"
#~ "    hit_points: u8,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
#~ "struct Jogador {\n"
#~ "    nome: String,\n"
#~ "    forca: u8,\n"
#~ "    pontos_vida: u8,\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Equals {\n"
#~ "    fn equal(&self, other: &Self) -> bool;\n"
#~ "    fn not_equal(&self, other: &Self) -> bool {\n"
#~ "        !self.equal(other)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Iguais {\n"
#~ "    fn igual(&self, outro: &Self) -> bool;\n"
#~ "    fn diferente(&self, outro: &Self) -> bool {\n"
#~ "        !self.igual(outro)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "struct Centimeter(i16);"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "struct Centimetro(i16);"

#~ msgid ""
#~ "impl Equals for Centimeter {\n"
#~ "    fn equal(&self, other: &Centimeter) -> bool {\n"
#~ "        self.0 == other.0\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Iguais for Centimetro {\n"
#~ "    fn igual(&self, outro: &Centimetro) -> bool {\n"
#~ "        self.0 == outro.0\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let a = Centimeter(10);\n"
#~ "    let b = Centimeter(20);\n"
#~ "    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
#~ "    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let a = Centimetro(10);\n"
#~ "    let b = Centimetro(20);\n"
#~ "    println!(\"{a:?} √© igual a {b:?}: {}\", a.igual(&b));\n"
#~ "    println!(\"{a:?} √© diferente de {b:?}: {}\", a.diferente(&b));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "* `IntoIterator` is the trait that makes for loops work. It is implemented by collection types "
#~ "such as\n"
#~ "  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also implement it.\n"
#~ "* The `Iterator` trait implements many common functional programming operations over "
#~ "collections \n"
#~ "  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can find all the "
#~ "documentation\n"
#~ "  about them. In Rust these functions should produce the code as efficient as equivalent "
#~ "imperative\n"
#~ "  implementations.\n"
#~ "    \n"
#~ "</details>"
#~ msgstr ""
#~ "* `IntoIterator` √© o recurso que faz com que os la√ßos funcionem. √â implementado por tipos de "
#~ "cole√ß√£o, como\n"
#~ "  `Vec<T>` e refer√™ncias a eles, como `&Vec<T>` e `&[T]`. Os intervalos tamb√©m o implementam.\n"
#~ "* O _trait_ `Iterator` implementa muitas opera√ß√µes de programa√ß√£o funcional comuns sobre "
#~ "cole√ß√µes\n"
#~ "  (por exemplo, `mapa`, `filtro`, `redu√ß√£o`, etc). Este √© o _trait_ onde voc√™ pode encontrar "
#~ "toda a documenta√ß√£o\n"
#~ "  sobre eles. Em Rust, essas fun√ß√µes devem produzir o c√≥digo t√£o eficiente quanto a "
#~ "implementa√ß√£o imperativa equivalente.\n"
#~ "    \n"
#~ "</details>"

#~ msgid "[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
#~ "[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
#~ "[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
#~ "[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
#~ "[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"

#~ msgid ""
#~ "fn count_lines<R: Read>(reader: R) -> usize {\n"
#~ "    let buf_reader = BufReader::new(reader);\n"
#~ "    buf_reader.lines().count()\n"
#~ "}"
#~ msgstr ""
#~ "fn contar_linhas<R: Read>(reader: R) -> usize {\n"
#~ "    let buf_reader = BufReader::new(reader);\n"
#~ "    buf_reader.lines().count()\n"
#~ "}"

#~ msgid ""
#~ "fn main() -> Result<()> {\n"
#~ "    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
#~ "    println!(\"lines in slice: {}\", count_lines(slice));"
#~ msgstr ""
#~ "fn main() -> Result<()> {\n"
#~ "    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
#~ "    println!(\"linhas na slice: {}\", contar_linhas(slice));"

#~ msgid ""
#~ "    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
#~ "    println!(\"lines in file: {}\", count_lines(file));\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
#~ "    println!(\"linhas no arquivo: {}\", contar_linhas(file));\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::io::{Result, Write};"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "use std::io::{Result, Write};"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
#~ "[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
#~ "[3]: https://doc.rust-lang.org/std/io/trait.Write.html"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
#~ "[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
#~ "[3]: https://doc.rust-lang.org/std/io/trait.Write.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Copy, Clone)]\n"
#~ "struct Point { x: i32, y: i32 }"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Copy, Clone)]\n"
#~ "struct Ponto { x: i32, y: i32 }"

#~ msgid ""
#~ "impl std::ops::Add for Point {\n"
#~ "    type Output = Self;"
#~ msgstr ""
#~ "impl std::ops::Add for Ponto {\n"
#~ "    type Output = Self;"

#~ msgid ""
#~ "    fn add(self, other: Self) -> Self {\n"
#~ "        Self {x: self.x + other.x, y: self.y + other.y}\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn add(self, other: Self) -> Self {\n"
#~ "        Self {x: self.x + other.x, y: self.y + other.y}\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 10, y: 20 };\n"
#~ "    let p2 = Point { x: 100, y: 200 };\n"
#~ "    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let p1 = Ponto { x: 10, y: 20 };\n"
#~ "    let p2 = Ponto { x: 100, y: 200 };\n"
#~ "    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
#~ "}\n"
#~ "```"

#~ msgid "[1]: https://doc.rust-lang.org/std/ops/index.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/ops/index.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Droppable {\n"
#~ "    name: &'static str,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Excluivel {\n"
#~ "    nome: &'static str,\n"
#~ "}"

#~ msgid ""
#~ "impl Drop for Droppable {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        println!(\"Dropping {}\", self.name);\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Drop for Excluivel {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        println!(\"Executando 'Drop' {}\", self.nome);\n"
#~ "    }\n"
#~ "}"

#~ msgid "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Derived {\n"
#~ "    x: u32,\n"
#~ "    y: String,\n"
#~ "    z: Implemented,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Derivado {\n"
#~ "    x: u32,\n"
#~ "    y: String,\n"
#~ "    z: Implementado,\n"
#~ "}"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "struct Implemented(String);"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "struct Implementado(String);"

#~ msgid ""
#~ "impl Default for Implemented {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self(\"John Smith\".into())\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Default for Implementado {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self(\"Fulano de tal\".into())\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let default_struct: Derived = Default::default();\n"
#~ "    println!(\"{default_struct:#?}\");"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let estrutura_default: Derivado = Default::default();\n"
#~ "    println!(\"{estrutura_default:#?}\");"

#~ msgid ""
#~ "    let almost_default_struct = Derived {\n"
#~ "        y: \"Y is set!\".into(),\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "    println!(\"{almost_default_struct:#?}\");"
#~ msgstr ""
#~ "    let estrutura_quase_default = Derivado {\n"
#~ "        y: \"Y √© atribu√≠do!\".into(),\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "    println!(\"{estrutura_quase_default:#?}\");"

#~ msgid ""
#~ "    let nothing: Option<Derived> = None;\n"
#~ "    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
#~ "}"
#~ msgstr ""
#~ "    let nada: Option<Derivado> = None;\n"
#~ "    println!(\"{:#?}\", nada.unwrap_or_default());\n"
#~ "}"

#~ msgid "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T> {\n"
#~ "    x: T,\n"
#~ "    y: T,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Ponto<T> {\n"
#~ "    x: T,\n"
#~ "    y: T,\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T>(T, T);"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Ponto<T>(T, T);"

#~ msgid ""
#~ "impl<T> Point<T> {\n"
#~ "    fn x(&self) -> &T {\n"
#~ "        &self.0  // + 10\n"
#~ "    }"
#~ msgstr ""
#~ "impl<T> Ponto<T> {\n"
#~ "    fn x(&self) -> &T {\n"
#~ "        &self.0 // + 10\n"
#~ "    }"

#~ msgid ""
#~ "    // fn set_x(&mut self, x: T)\n"
#~ "}"
#~ msgstr ""
#~ "    // fn set_x(&mut self, x: T)\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let p = Point(5, 10);\n"
#~ "    println!(\"p.x = {}\", p.x());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let p = Ponto(5, 10);\n"
#~ "    println!(\"p.x = {}\", p.x());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "// Syntactic sugar for:\n"
#~ "//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
#~ "fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
#~ "    x.into() + 42_000_000\n"
#~ "}"
#~ msgstr ""
#~ "//   A√ßucar sint√°tico para:\n"
#~ "//   fn somar_42_milhoes<T: Into<i32>>(x: T) -> i32 {\n"
#~ "fn somar_42_milhoes(x: impl Into<i32>) -> i32 {\n"
#~ "    x.into() + 42_000_000\n"
#~ "}"

#~ msgid "// struct NotClonable;"
#~ msgstr "// struct NotClonable;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let foo = String::from(\"foo\");\n"
#~ "    let pair = duplicate(foo);\n"
#~ "    println!(\"{pair:?}\");"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let foo = String::from(\"foo\");\n"
#~ "    let par = duplicar(foo);\n"
#~ "    println!(\"{par:?}\");"

#~ msgid ""
#~ "    let many = add_42_millions(42_i8);\n"
#~ "    println!(\"{many}\");\n"
#~ "    let many_more = add_42_millions(10_000_000);\n"
#~ "    println!(\"{many_more}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let muito = somar_42_milhoes(42_i8);\n"
#~ "    println!(\"{muito}\");\n"
#~ "    let muito_mais = somar_42_milhoes(10_000_000);\n"
#~ "    println!(\"{muito_mais}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Show a `where` clause, students will encounter it when reading code.\n"
#~ "    \n"
#~ "```rust,ignore\n"
#~ "fn duplicate<T>(a: T) -> (T, T)\n"
#~ "where\n"
#~ "    T: Clone,\n"
#~ "{\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "Mostre uma cl√°usula `where`, os alunos a encontrar√£o ao ler o c√≥digo.\n"
#~ "    \n"
#~ "```rust, ignore\n"
#~ "fn duplicar<T>(a: T) -> (T, T)\n"
#~ "where\n"
#~ "    T: Clone,\n"
#~ "{\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::fmt::Display;"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "use std::fmt::Display;"

#~ msgid ""
#~ "fn get_x(name: impl Display) -> impl Display {\n"
#~ "    format!(\"Hello {name}\")\n"
#~ "}"
#~ msgstr ""
#~ "fn get_x(nome: impl Display) -> impl Display {\n"
#~ "    format!(\"Ol√° {nome}\")\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let x = get_x(\"foo\");\n"
#~ "    println!(\"{x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let x = get_x(\"foo\");\n"
#~ "    println!(\"{x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let add_3 = |x| x + 3;\n"
#~ "    let mul_5 = |x| x * 5;"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let soma_3 = |x| x + 3;\n"
#~ "    let multiplica_5 = |x| x * 5;"

#~ msgid ""
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
#~ "    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"soma_3: {}\", aplicar_com_registro(soma_3, 10));\n"
#~ "    println!(\"multiplica_5: {}\", aplicar_com_registro(multiplica_5, 20));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum Option_i32 {\n"
#~ "    Some(i32),\n"
#~ "    None,\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "enum Option_i32 {\n"
#~ "    Some (i32),\n"
#~ "    None,\n"
#~ "}"

#~ msgid ""
#~ "enum Option_f64 {\n"
#~ "    Some(f64),\n"
#~ "    None,\n"
#~ "}"
#~ msgstr ""
#~ "enum Option_f64 {\n"
#~ "    Some (f64),\n"
#~ "    None,\n"
#~ "}"

#~ msgid "We've seen how a function can take arguments which implement a trait:"
#~ msgstr "Vimos como uma fun√ß√£o pode receber argumentos que implementam um `trait` :"

#~ msgid ""
#~ "fn print<T: Display>(x: T) {\n"
#~ "    println!(\"Your value: {x}\");\n"
#~ "}"
#~ msgstr ""
#~ "fn print<T: Display>(x: T) {\n"
#~ "    println!(\"Seu valor: {}\", x);\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    print(123);\n"
#~ "    print(\"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    print(123);\n"
#~ "    print(\"Ol√°\");\n"
#~ "}\n"
#~ "```"

#~ msgid "However, how can we store a collection of mixed types which implement `Display`?"
#~ msgstr "No entanto, como podemos armazenar uma cole√ß√£o de tipos mistos que implementam `Display`?"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let xs = vec![123, \"Hello\"];\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let xs = vec![123, \"Ol√°\"];\n"
#~ "}\n"
#~ "```"

#~ msgid "For this, we need _trait objects_:"
#~ msgstr "Para isso, precisamos de objetos de _traits_:"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), Box::new(\"Hello\")];\n"
#~ "    for x in xs {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), Box::new(\"Ol√°\")];\n"
#~ "    for x in xs {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Similarly, you need a trait object if you want to return different types\n"
#~ "implementing a trait:"
#~ msgstr ""
#~ "Da mesma forma, voc√™ precisa de um objeto de _traits_ se quiser retornar valores diferentes\n"
#~ "implementando um `trait`:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
#~ "    if n > 0 {\n"
#~ "        Box::new(0..n)\n"
#~ "    } else {\n"
#~ "        Box::new((n..0).rev())\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn numeros(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
#~ "    if n > 0 {\n"
#~ "        Box::new(0..n)\n"
#~ "    } else {\n"
#~ "        Box::new((n..0).rev())\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", numbers(-5).collect::<Vec<_>>());\n"
#~ "    println!(\"{:?}\", numbers(5).collect::<Vec<_>>());\n"
#~ "}"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", numeros(-5).collect::<Vec<_>>());\n"
#~ "    println!(\"{:?}\", numeros(5).collect::<Vec<_>>());\n"
#~ "}"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remova isso quando terminar sua implementa√ß√£o.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]"

#~ msgid ""
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;"
#~ msgstr ""
#~ "pub trait Widget {\n"
#~ "    /// Largura natural de `self`.\n"
#~ "    fn width(&self) -> usize;"

#~ msgid ""
#~ "    /// Draw the widget into a buffer.\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"
#~ msgstr ""
#~ "    /// Desenha o widget em um buffer.\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"

#~ msgid ""
#~ "    /// Draw the widget on standard output.\n"
#~ "    fn draw(&self) {\n"
#~ "        let mut buffer = String::new();\n"
#~ "        self.draw_into(&mut buffer);\n"
#~ "        println!(\"{buffer}\");\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    /// Desenha o widget na sa√≠da padr√£o.\n"
#~ "    fn draw(&self) {\n"
#~ "        let mut buffer = String::new();\n"
#~ "        self.draw_into(&mut buffer);\n"
#~ "        println!(\"{}\", &buffer);\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "pub struct Label {\n"
#~ "    label: String,\n"
#~ "}"
#~ msgstr ""
#~ "pub struct Label {\n"
#~ "    label: String,\n"
#~ "}"

#~ msgid ""
#~ "impl Label {\n"
#~ "    fn new(label: &str) -> Label {\n"
#~ "        Label {\n"
#~ "            label: label.to_owned(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Label {\n"
#~ "    fn new(label: &str) -> Label {\n"
#~ "        Label {\n"
#~ "            label: label.to_owned(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "pub struct Button {\n"
#~ "    label: Label,\n"
#~ "    callback: Box<dyn FnMut()>,\n"
#~ "}"
#~ msgstr ""
#~ "pub struct Button {\n"
#~ "    label: Label,\n"
#~ "    callback: Box<dyn FnMut()>,\n"
#~ "}"

#~ msgid ""
#~ "impl Button {\n"
#~ "    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
#~ "        Button {\n"
#~ "            label: Label::new(label),\n"
#~ "            callback,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Button {\n"
#~ "    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
#~ "        Button {\n"
#~ "            label: Label::new(label),\n"
#~ "            callback,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "pub struct Window {\n"
#~ "    title: String,\n"
#~ "    widgets: Vec<Box<dyn Widget>>,\n"
#~ "}"
#~ msgstr ""
#~ "pub struct Window {\n"
#~ "    title: String,\n"
#~ "    widgets: Vec<Box<dyn Widget>>,\n"
#~ "}"

#~ msgid ""
#~ "impl Window {\n"
#~ "    fn new(title: &str) -> Window {\n"
#~ "        Window {\n"
#~ "            title: title.to_owned(),\n"
#~ "            widgets: Vec::new(),\n"
#~ "        }\n"
#~ "    }"
#~ msgstr ""
#~ "impl Window {\n"
#~ "    fn new(title: &str) -> Window {\n"
#~ "        Window {\n"
#~ "            title: title.to_owned(),\n"
#~ "            widgets: Vec::new(),\n"
#~ "        }\n"
#~ "    }"

#~ msgid ""
#~ "    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
#~ "        self.widgets.push(widget);\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
#~ "        self.widgets.push(widget);\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }"
#~ msgstr ""
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Click me!\",\n"
#~ "        Box::new(|| println!(\"You clicked the button!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"Esta √© uma pequena demonstra√ß√£o de GUI de texto."
#~ "\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Clique em mim!\",\n"
#~ "        Box::new(|| println!(\"Voc√™ clicou no bot√£o!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "```"

#~ msgid "This is a small text GUI demo."
#~ msgstr "Esta √© uma pequena demonstra√ß√£o de GUI de texto."

#~ msgid ""
#~ "| Click me! |\n"
#~ "```"
#~ msgstr ""
#~ "| Clique-me! |\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::panic;"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::panic;"

#~ msgid ""
#~ "let result = panic::catch_unwind(|| {\n"
#~ "    println!(\"hello!\");\n"
#~ "});\n"
#~ "assert!(result.is_ok());"
#~ msgstr ""
#~ "let result = panic::catch_unwind(|| {\n"
#~ "    println!(\"Ol√°!\");\n"
#~ "});\n"
#~ "assert!(result.is_ok());"

#~ msgid ""
#~ "let result = panic::catch_unwind(|| {\n"
#~ "    panic!(\"oh no!\");\n"
#~ "});\n"
#~ "assert!(result.is_err());\n"
#~ "```"
#~ msgstr ""
#~ "let result = panic::catch_unwind(|| {\n"
#~ "    panic!(\"oh n√£o!\");\n"
#~ "});\n"
#~ "assert!(result.is_err());\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::fs::File;\n"
#~ "use std::io::Read;"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::fs::File;\n"
#~ "use std::io::Read;"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::fs;\n"
#~ "use std::io::{self, Read};"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "use std::fs;\n"
#~ "use std::io::{self, Read};"

#~ msgid ""
#~ "fn read_username(path: &str) -> Result<String, io::Error> {\n"
#~ "    let username_file_result = fs::File::open(path);"
#~ msgstr ""
#~ "fn ler_nome_usuario(caminho: &str) -> Result<String, io::Error> {\n"
#~ "    let arquivo_nome_usuario_result = fs::File::open(caminho);"

#~ msgid ""
#~ "    let mut username_file = match username_file_result {\n"
#~ "        Ok(file) => file,\n"
#~ "        Err(e) => return Err(e),\n"
#~ "    };"
#~ msgstr ""
#~ "    let mut arquivo_nome_usuario = match arquivo_nome_usuario_result {\n"
#~ "        Ok(arquivo) => arquivo,\n"
#~ "        Err(e) => return Err(e),\n"
#~ "    };"

#~ msgid "    let mut username = String::new();"
#~ msgstr "    let mut nome_usuario = String::new();"

#~ msgid ""
#~ "    match username_file.read_to_string(&mut username) {\n"
#~ "        Ok(_) => Ok(username),\n"
#~ "        Err(e) => Err(e),\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    match arquivo_nome_usuario.read_to_string(&mut nome_usuario) {\n"
#~ "        Ok(_) => Ok(nome_usuario),\n"
#~ "        Err(e) => Err(e),\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
#~ "    let nome_usuario = ler_nome_usuario(\"config.dat\");\n"
#~ "    println!(\"Nome de usu√°rio ou erro: {nome_usuario:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::error::Error;\n"
#~ "use std::fmt::{self, Display, Formatter};\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::{self, Read};"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::error::Error;\n"
#~ "use std::fmt::{self, Display, Formatter};\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::{self, Read};"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    IoError(io::Error),\n"
#~ "    EmptyUsername(String),\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "enum LerNomeUsuarioError {\n"
#~ "    IoError(io::Error),\n"
#~ "    NomeUsuarioVazio(String),\n"
#~ "}"

#~ msgid "impl Error for ReadUsernameError {}"
#~ msgstr "impl Error for LerNomeUsuarioError {}"

#~ msgid ""
#~ "impl Display for ReadUsernameError {\n"
#~ "    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
#~ "        match self {\n"
#~ "            Self::IoError(e) => write!(f, \"IO error: {}\", e),\n"
#~ "            Self::EmptyUsername(filename) => write!(f, \"Found no username in {}\", filename),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Display for LerNomeUsuarioError {\n"
#~ "    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
#~ "        match self {\n"
#~ "            Self::IoError(e) => write!(f, \"Erro de E/S: {}\", e),\n"
#~ "            Self::NomeUsuarioVazio(arquivo) => write!(f, \"N√£o foi encontrado nome de usu√°rio "
#~ "em {}\", arquivo),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl From<io::Error> for ReadUsernameError {\n"
#~ "    fn from(err: io::Error) -> ReadUsernameError {\n"
#~ "        ReadUsernameError::IoError(err)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl From<io::Error> for LerNomeUsuarioError {\n"
#~ "    fn from(err: io::Error) -> LerNomeUsuarioError {\n"
#~ "        LerNomeUsuarioError::IoError(err)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}"
#~ msgstr ""
#~ "fn ler_nome_usuario(caminho: &str) -> Result<String, LerNomeUsuarioError> {\n"
#~ "    let mut nome_usuario = String::with_capacity(100);\n"
#~ "    File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
#~ "    if nome_usuario.is_empty() {\n"
#~ "        return Err(LerNomeUsuarioError::NomeUsuarioVazio(String::from(caminho)));\n"
#~ "    }\n"
#~ "    Ok(nome_usuario)\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    let nome_usuario = ler_nome_usuario(\"config.dat\");\n"
#~ "    println!(\"Nome de usu√°rio ou erro: {nome_usuario:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;"

#~ msgid ""
#~ "#[derive(Debug, Error)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    #[error(\"Could not read: {0}\")]\n"
#~ "    IoError(#[from] io::Error),\n"
#~ "    #[error(\"Found no username in {0}\")]\n"
#~ "    EmptyUsername(String),\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Debug, Error)]\n"
#~ "enum LerNomeUsuarioError {\n"
#~ "    #[error(\"N√£o foi poss√≠vel ler: {0}\")]\n"
#~ "    IoError(#[from] io::Error),\n"
#~ "    #[error(\"N√£o foi encontrado o nome do usu√°rio em {0}\")]\n"
#~ "    NomeUsuarioVazio(String),\n"
#~ "}"

#~ msgid ""
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}"
#~ msgstr ""
#~ "fn ler_nome_usuario(caminho: &str) -> Result<String, LerNomeUsuarioError> {\n"
#~ "    let mut nome_usuario = String::with_capacity(100);\n"
#~ "    fs::File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
#~ "    if nome_usuario.is_empty() {\n"
#~ "        return Err(LerNomeUsuarioError::NomeUsuarioVazio(String::from(caminho)));\n"
#~ "    }\n"
#~ "    Ok(nome_usuario)\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match ler_nome_usuario(\"config.dat\") {\n"
#~ "        Ok(nome_usuario) => println!(\"Nome de usu√°rio: {nome_usuario}\"),\n"
#~ "        Err(err) => println!(\"Erro: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "use std::error::Error;"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "use std::error::Error;"

#~ msgid ""
#~ "#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
#~ "#[error(\"Found no username in {0}\")]\n"
#~ "struct EmptyUsernameError(String);"
#~ msgstr ""
#~ "#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
#~ "#[error(\"Nome de usu√°rio n√£o encontrado em {0}\")]\n"
#~ "struct NomeUsuarioVazioError(String);"

#~ msgid ""
#~ "fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(EmptyUsernameError(String::from(path)).into());\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}"
#~ msgstr ""
#~ "fn ler_nome_usuario(caminho: &str) -> Result<String, Box<dyn Error>> {\n"
#~ "    let mut nome_usuario = String::with_capacity(100);\n"
#~ "    File::open(caminho)?.read_to_string(&mut nome_usuario)?;\n"
#~ "    if nome_usuario.is_empty() {\n"
#~ "        return Err(NomeUsuarioVazioError(String::from(caminho)).into());\n"
#~ "    }\n"
#~ "    Ok (nome_usuario)\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use anyhow::{Context, Result, bail};"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs};\n"
#~ "use std::io::Read;\n"
#~ "use anyhow::{Context, Result, bail};"

#~ msgid ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err:?}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match ler_nome_usuario(\"config.dat\") {\n"
#~ "        Ok(nome_usuario) => println!(\"Nome de usu√°rio: {nome_usuario}\"),\n"
#~ "        Err(err) => println!(\"Erro: {err:?}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "* Unit tests are supported throughout your code."
#~ msgstr "* Os testes unit√°rios s√£o suportados em todo o seu c√≥digo."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn first_word(text: &str) -> &str {\n"
#~ "    match text.find(' ') {\n"
#~ "        Some(idx) => &text[..idx],\n"
#~ "        None => &text,\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn primeira_palavra(text: &str) -> &str {\n"
#~ "    match text.find(' ') {\n"
#~ "        Some(idx) => &text[..idx],\n"
#~ "        None => &text,\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_empty() {\n"
#~ "    assert_eq!(first_word(\"\"), \"\");\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn teste_vazio() {\n"
#~ "    assert_eq!(primeira_palavra(\"\"), \"\");\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_single_word() {\n"
#~ "    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_uma_palavra() {\n"
#~ "    assert_eq!(primeira_palavra(\"Ol√°\"), \"Ol√°\");\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_multiple_words() {\n"
#~ "    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_multiplas_palavras() {\n"
#~ "    assert_eq!(primeira_palavra(\"Ol√° Mundo\"), \"Ol√°\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn helper(a: &str, b: &str) -> String {\n"
#~ "    format!(\"{a} {b}\")\n"
#~ "}"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn helper(a: &str, b: &str) -> String {\n"
#~ "    format!(\"{a} {b}\")\n"
#~ "}"

#~ msgid ""
#~ "pub fn main() {\n"
#~ "    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
#~ "}"
#~ msgstr ""
#~ "pub fn main() {\n"
#~ "    println!(\"{}\", helper(\"Ol√°\", \"Mundo\"));\n"
#~ "}"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_helper() {\n"
#~ "        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_helper() {\n"
#~ "        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use my_library::init;"
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "use minha_biblioteca::init;"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut num = 5;"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let mut num = 5;"

#~ msgid ""
#~ "    let r1 = &mut num as *mut i32;\n"
#~ "    let r2 = &num as *const i32;"
#~ msgstr ""
#~ "    let r1 = &mut num as *mut i32;\n"
#~ "    let r2 = &num as *const i32;"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static mut COUNTER: u32 = 0;"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "static mut CONTADOR: u32 = 0;"

#~ msgid ""
#~ "fn add_to_counter(inc: u32) {\n"
#~ "    unsafe { COUNTER += inc; }  // Potential data race!\n"
#~ "}"
#~ msgstr ""
#~ "fn add_to_counter(inc: u32) {\n"
#~ "    unsafe { CONTADOR += inc; } // Potencial corrida de dados!\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    add_to_counter(42);"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    add_to_counter(42);"

#~ msgid ""
#~ "    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    unsafe { println!(\"CONTADOR: {}\", CONTADOR); } // Potencial corrida de dados!\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[repr(C)]\n"
#~ "union MyUnion {\n"
#~ "    i: u8,\n"
#~ "    b: bool,\n"
#~ "}"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[repr(C)]\n"
#~ "union MinhaUnion {\n"
#~ "    i: u8,\n"
#~ "    b: bool,\n"
#~ "}"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let emojis = \"üóª‚ààüåè\";"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "fn main() {\n"
#~ "    let emojis = \"üóª‚ààüåè\";"

#~ msgid ""
#~ "    // Safe because the indices are in the correct order, within the bounds of\n"
#~ "    // the string slice, and lie on UTF-8 sequence boundaries.\n"
#~ "    unsafe {\n"
#~ "        println!(\"{}\", emojis.get_unchecked(0..4));\n"
#~ "        println!(\"{}\", emojis.get_unchecked(4..7));\n"
#~ "        println!(\"{}\", emojis.get_unchecked(7..11));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    // Seguro porque os √≠ndices est√£o na ordem correta, dentro dos limites da\n"
#~ "    // slice da string e fica nos limites da sequ√™ncia UTF-8.\n"
#~ "    unsafe {\n"
#~ "        println!(\"{}\", emojis.get_unchecked(0..4));\n"
#~ "        println!(\"{}\", emojis.get_unchecked(4..7));\n"
#~ "        println!(\"{}\", emojis.get_unchecked(7..11));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let mut a = 42;\n"
#~ "    let mut b = 66;"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let mut a = 42;\n"
#~ "    let mut b = 66;"

#~ msgid ""
#~ "    // Safe because ...\n"
#~ "    unsafe {\n"
#~ "        swap(&mut a, &mut b);\n"
#~ "    }"
#~ msgstr ""
#~ "    // Seguro porque...\n"
#~ "    unsafe {\n"
#~ "        troca(&mut a, &mut b);\n"
#~ "    }"

#~ msgid ""
#~ "    println!(\"a = {}, b = {}\", a, b);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"a = {}, b = {}\", a, b);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::mem::size_of_val;\n"
#~ "use std::slice;"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "use std::mem::size_of_val;\n"
#~ "use std::slice;"

#~ msgid ""
#~ "// Safe because u32 has a defined representation and no padding.\n"
#~ "unsafe impl AsBytes for u32 {}\n"
#~ "```"
#~ msgstr ""
#~ "// Seguro porque u32 tem uma representa√ß√£o definida e nenhum preenchimento.\n"
#~ "unsafe impl AsBytes for u32 {}\n"
#~ "```"

#~ msgid "[solution]: solutions-afternoon.md"
#~ msgstr "[solu√ß√£o]: solutions-afternoon.md"

#~ msgid ""
#~ "You will also want to browse the [`std::ffi`] module, particular for [`CStr`]\n"
#~ "and [`CString`] types which are used to hold NUL-terminated strings coming from\n"
#~ "C. The [Nomicon] also has a very useful chapter about FFI."
#~ msgstr ""
#~ "Voc√™ tamb√©m deve procurar o m√≥dulo [`std::ffi`], especialmente para [`CStr`]\n"
#~ "e tipos [`CString`] que s√£o usados para armazenar strings terminadas com NULL vindas do\n"
#~ "C. O [Nomicon] tamb√©m tem um cap√≠tulo muito √∫til sobre FFI."

#~ msgid ""
#~ "[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
#~ "[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
#~ "[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
#~ "[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"
#~ msgstr ""
#~ "[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
#~ "[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
#~ "[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
#~ "[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"

#~ msgid ""
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
#~ msgstr ""
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#~ msgid ""
#~ "    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct DIR {\n"
#~ "        _data: [u8; 0],\n"
#~ "        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
#~ "    }"
#~ msgstr ""
#~ "    // Tipo opaco. Consulte https://doc.rust-lang.org/nomicon/ffi.html.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct DIR {\n"
#~ "        _data: [u8; 0],\n"
#~ "        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
#~ "    }"

#~ msgid ""
#~ "    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_ino: c_long,\n"
#~ "        pub d_off: c_ulong,\n"
#~ "        pub d_reclen: c_ushort,\n"
#~ "        pub d_type: c_char,\n"
#~ "        pub d_name: [c_char; 256],\n"
#~ "    }"
#~ msgstr ""
#~ "    // Layout para readdir(3) e defini√ß√µes em /usr/include/x86_64-linux-gnu.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_ino: c_long,\n"
#~ "        pub d_off: c_ulong,\n"
#~ "        pub d_reclen: c_ushort,\n"
#~ "        pub d_type: c_char,\n"
#~ "        pub d_name: [c_char; 256],\n"
#~ "    }"

#~ msgid ""
#~ "    extern \"C\" {\n"
#~ "        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "        pub fn closedir(s: *mut DIR) -> c_int;\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    extern \"C\" {\n"
#~ "        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "        pub fn closedir(s: *mut DIR) -> c_int;\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "use std::ffi::{CStr, CString, OsStr, OsString};\n"
#~ "use std::os::unix::ffi::OsStrExt;"
#~ msgstr ""
#~ "use std::ffi::{CStr, CString, OsStr, OsString};\n"
#~ "use std::os::unix::ffi::OsStrExt;"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}"

#~ msgid ""
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Chama opendir e retorna um valor Ok se funcionou,\n"
#~ "        // caso contr√°rio, retorna Err com uma mensagem.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Continue chamando readdir at√© obter um ponteiro NULL de volta.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"arquivos: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid "# Welcome to Day 4"
#~ msgstr "# Bem-vindo ao Dia 4"

#~ msgid "Today we will look at two main topics:"
#~ msgstr "Hoje veremos dois t√≥picos principais:"

#~ msgid "* Concurrency: threads, channels, shared state, `Send` and `Sync`."
#~ msgstr "* Concorr√™ncia: _threads_, _channels_, estado compartilhado, `Send` e `Sync`."

#~ msgid ""
#~ "* Android: building binaries and libraries, using AIDL, logging, and\n"
#~ "  interoperability with C, C++, and Java."
#~ msgstr ""
#~ "* Android: construindo bin√°rios e bibliotecas, usando AIDL, log e\n"
#~ "  interoperabilidade com C, C++ e Java."

#~ msgid "# Fearless Concurrency"
#~ msgstr "# Concorr√™ncia sem medo"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"

#~ msgid ""
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Thread principal: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "* Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is\n"
#~ "  not waiting."
#~ msgstr ""
#~ "* Observe que o _thread_ √© interrompido antes de atingir 10 ‚Äî o _thread_ principal n√£o\n"
#~ "  o espera."

#~ msgid ""
#~ "* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for\n"
#~ "  the thread to finish."
#~ msgstr ""
#~ "* Use `let handle = thread::spawn(...)` e posteriormente `handle.join()` para aguardar\n"
#~ "  a `thread` terminar."

#~ msgid "* Trigger a panic in the thread, notice how this doesn't affect `main`."
#~ msgstr "* Acione um p√¢nico (`panic`) na _thread_ e observe como isso n√£o afeta a _thread_ `main`."

#~ msgid ""
#~ "* Use the `Result` return value from `handle.join()` to get access to the panic\n"
#~ "  payload. This is a good time to talk about [`Any`]."
#~ msgstr ""
#~ "* Use o valor de retorno `Result` de `handle.join()` para obter acesso ao\n"
#~ "  _payload_ do `panic` gerado. Este √© um bom momento para falar sobre [`Any`]."

#~ msgid "[`Any`]: https://doc.rust-lang.org/std/any/index.html"
#~ msgstr "[`Qualquer`]: https://doc.rust-lang.org/std/any/index.html"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let s = String::from(\"Ol√°\");"

#~ msgid ""
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Comprimento: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;"

#~ msgid "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();"

#~ msgid ""
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());"
#~ msgstr ""
#~ "    println!(\"Recebido: {:?}\", rx.recv());\n"
#~ "    println!(\"Recebido: {:?}\", rx.recv());"

#~ msgid ""
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Recebido: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"

#~ msgid ""
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {}\", msg);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: obteve {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);"

#~ msgid ""
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: obteve {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
#~ "[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
#~ "[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;"

#~ msgid ""
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "use std::sync::Mutex;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let v: Mutex<Vec<i32>> = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let v: Mutex<Vec<i32>> = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());"

#~ msgid ""
#~ "    {\n"
#~ "        let v: &Mutex<Vec<i32>> = &v;\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }"
#~ msgstr ""
#~ "    {\n"
#~ "        let v: &Mutex<Vec<i32>> = &v;\n"
#~ "        let mut guarda= v.lock().unwrap();\n"
#~ "        guarda.push(40);\n"
#~ "    }"

#~ msgid ""
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
#~ "[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
#~ "[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
#~ "[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
#~ "[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"

#~ msgid ""
#~ "[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html  \n"
#~ "    \n"
#~ "</details>"
#~ msgstr ""
#~ "[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html\n"
#~ "    \n"
#~ "</details>"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "// use std::sync::{Arc, Mutex};"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "// use std::sync::{Arc, Mutex};"

#~ msgid ""
#~ "    handle.join().unwrap();\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    handle.join().unwrap();\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Possible solution:\n"
#~ "    \n"
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;"
#~ msgstr ""
#~ "Solu√ß√£o poss√≠vel:\n"
#~ "    \n"
#~ "```rust, editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"

#~ msgid ""
#~ "    let v2 = v.clone();\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });"
#~ msgstr ""
#~ "    let v2 = v.clone();\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });"

#~ msgid ""
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }"
#~ msgstr ""
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }"

#~ msgid "    handle.join().unwrap();"
#~ msgstr "    handle.join().unwrap();"

#~ msgid ""
#~ "    {\n"
#~ "        let v = v.lock().unwrap();\n"
#~ "        println!(\"v: {v:?}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```\n"
#~ "    \n"
#~ "Notable parts:"
#~ msgstr ""
#~ "    {\n"
#~ "        let v = v.lock().unwrap();\n"
#~ "        println!(\"v: {v:?}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```\n"
#~ "    \n"
#~ "Partes importantes:"

#~ msgid ""
#~ "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
#~ "[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
#~ "[3]: ../unsafe/unsafe-traits.md"
#~ msgstr ""
#~ "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
#~ "[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
#~ "[3]: ../unsafe/unsafe-traits.md"

#~ msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#~ msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"

#~ msgid "* Dining philosophers: a classic problem in concurrency."
#~ msgstr "* _Dining philosophers_: um problema cl√°ssico em concorr√™ncia."

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"

#~ msgid "struct Fork;"
#~ msgstr "struct Garfo;"

#~ msgid ""
#~ "struct Philosopher {\n"
#~ "    name: String,\n"
#~ "    // left_fork: ...\n"
#~ "    // right_fork: ...\n"
#~ "    // thoughts: ...\n"
#~ "}"
#~ msgstr ""
#~ "struct Filosofo {\n"
#~ "    nome: String,\n"
#~ "    // garfo_esquerda: ...\n"
#~ "    // garfo_direita: ...\n"
#~ "    // pensamentos: ...\n"
#~ "}"

#~ msgid ""
#~ "impl Philosopher {\n"
#~ "    fn think(&self) {\n"
#~ "        self.thoughts\n"
#~ "            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
#~ "            .unwrap();\n"
#~ "    }"
#~ msgstr ""
#~ "impl Filosofo {\n"
#~ "    fn pensa(&self) {\n"
#~ "        self.pensamento\n"
#~ "            .send(format!(\"Eureka! {} tem uma nova ideia!\", &self.nome))\n"
#~ "            .unwrap();\n"
#~ "    }"

#~ msgid ""
#~ "    fn eat(&self) {\n"
#~ "        // Pick up forks...\n"
#~ "        println!(\"{} is eating...\", &self.name);\n"
#~ "        thread::sleep(Duration::from_millis(10));\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn come(&self) {\n"
#~ "        // Pegar garfos...\n"
#~ "        println!(\"{} est√° comendo...\", &self.nome);\n"
#~ "        thread::sleep(Duration::from_millis(10));\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "static PHILOSOPHERS: &[&str] =\n"
#~ "    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];"
#~ msgstr ""
#~ "static FILOSOFOS: &[&str] =\n"
#~ "&[\"S√≥crates\", \"Plat√£o\", \"Arist√≥teles\", \"Tales\", \"Pit√°goras\"];"

#~ msgid ""
#~ "fn main() {\n"
#~ "    // Create forks"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    // Criar garfos"

#~ msgid "    // Create philosophers"
#~ msgstr "    // Criar filosofos"

#~ msgid "    // Make them think and eat"
#~ msgstr "    // Fa√ßa-os pensar e comer"

#~ msgid ""
#~ "    // Output their thoughts\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    // Mostrar seus pensamentos\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "use reqwest::blocking::{get, Response};\n"
#~ "use reqwest::Url;\n"
#~ "use scraper::{Html, Selector};\n"
#~ "use thiserror::Error;"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "use reqwest::blocking::{get, Response};\n"
#~ "use reqwest::Url;\n"
#~ "use scraper::{Html, Selector};\n"
#~ "use thiserror::Error;"

#~ msgid ""
#~ "#[derive(Error, Debug)]\n"
#~ "enum Error {\n"
#~ "    #[error(\"request error: {0}\")]\n"
#~ "    ReqwestError(#[from] reqwest::Error),\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Error, Debug)]\n"
#~ "enum Error{\n"
#~ "    #[error(\"erro de solicita√ß√£o: {0}\")]\n"
#~ "    ReqwestError(#[from] reqwest::Error),\n"
#~ "}"

#~ msgid ""
#~ "fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
#~ "    let base_url = response.url().to_owned();\n"
#~ "    let document = response.text()?;\n"
#~ "    let html = Html::parse_document(&document);\n"
#~ "    let selector = Selector::parse(\"a\").unwrap();"
#~ msgstr ""
#~ "fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
#~ "    let base_url = response.url().to_owned();\n"
#~ "    let document = response.text()?;\n"
#~ "    let html = Html::parse_document(&document);\n"
#~ "    let selector = Selector::parse(\"a\").unwrap();"

#~ msgid ""
#~ "    let mut valid_urls = Vec::new();\n"
#~ "    for element in html.select(&selector) {\n"
#~ "        if let Some(href) = element.value().attr(\"href\") {\n"
#~ "            match base_url.join(href) {\n"
#~ "                Ok(url) => valid_urls.push(url),\n"
#~ "                Err(err) => {\n"
#~ "                    println!(\"On {base_url}: could not parse {href:?}: {err} (ignored)\",);\n"
#~ "                }\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }"
#~ msgstr ""
#~ "    let mut valid_urls = Vec::new();\n"
#~ "    for element in html.select(&selector) {\n"
#~ "        if let Some(href) = element.value().attr(\"href\") {\n"
#~ "            match base_url.join(href) {\n"
#~ "                Ok(url) => valid_urls.push(url),\n"
#~ "                Err(err) => {\n"
#~ "                    println!(\"Em {base_url}: n√£o foi poss√≠vel analisar {href:?}: {err} "
#~ "(ignorado)\",);\n"
#~ "                }\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }"

#~ msgid ""
#~ "    Ok(valid_urls)\n"
#~ "}"
#~ msgstr ""
#~ "    Ok(valid_urls)\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
#~ "    let response = get(start_url).unwrap();\n"
#~ "    match extract_links(response) {\n"
#~ "        Ok(links) => println!(\"Links: {links:#?}\"),\n"
#~ "        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
#~ "    let response = get(start_url).unwrap();\n"
#~ "    match extract_links(response) {\n"
#~ "        Ok(links) => println!(\"Links: {links:#?}\"),\n"
#~ "        Err(err) => println!(\"N√£o foi poss√≠vel extrair os links: {err:#}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[1]: https://docs.rs/reqwest/\n"
#~ "[2]: https://docs.rs/scraper/\n"
#~ "[3]: https://docs.rs/thiserror/"
#~ msgstr ""
#~ "[1]: https://docs.rs/reqwest/\n"
#~ "[2]: https://docs.rs/scraper/\n"
#~ "[3]: https://docs.rs/thiserror/"

#~ msgid ""
#~ "```rust\n"
#~ "//! Rust demo."
#~ msgstr ""
#~ "```rust\n"
#~ "//! Demonstra√ß√£o de Rust."

#~ msgid ""
#~ "[crates]: https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"
#~ msgstr ""
#~ "[crates]: https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"

#~ msgid ""
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust demo."
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "//! Demonstra√ß√£o de rust."

#~ msgid ""
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;"
#~ msgstr ""
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Greeting library."
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "//! Biblioteca de Sauda√ß√£o."

#~ msgid ""
#~ "```java\n"
#~ "package com.example.birthdayservice;"
#~ msgstr ""
#~ "```java\n"
#~ "package com.example.birthdayservice;"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Implementation of the `IBirthdayService` AIDL interface.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
#~ "IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;"
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "//! Implementa√ß√£o da interface AIDL `IBirthdayService`.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
#~ "IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;"

#~ msgid ""
#~ "/// The `IBirthdayService` implementation.\n"
#~ "pub struct BirthdayService;"
#~ msgstr ""
#~ "/// A implementa√ß√£o `IBirthdayService`.\n"
#~ "pub struct BirthdayService;"

#~ msgid "impl binder::Interface for BirthdayService {}"
#~ msgstr "impl binder::Interface for BirthdayService {}"

#~ msgid ""
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Feliz Anivers√°rio {name}, parab√©ns pelos {years} anos!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
#~ "BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;"
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "//! Servi√ßo de anivers√°rio.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
#~ "BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;"

#~ msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
#~ msgstr "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
#~ "IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;"
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "//! Servi√ßo de anivers√°rio.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
#~ "IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;"

#~ msgid ""
#~ "/// Connect to the BirthdayService.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}"
#~ msgstr ""
#~ "/// Conecte-se ao Servi√ßo de Anivers√°rio.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}"

#~ msgid ""
#~ "/// Call the birthday service.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);"
#~ msgstr ""
#~ "/// Chamada ao servi√ßo de anivers√°rio.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);"

#~ msgid ""
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Falha ao conectar ao BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust logging demo."
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "//! Demonstra√ß√£o de registro de rust."

#~ msgid "use log::{debug, error, info};"
#~ msgstr "use log::{debug, error, info};"

#~ msgid ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}"
#~ msgstr ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}"

#~ msgid ""
#~ "void print_card(const card* card);\n"
#~ "```"
#~ msgstr ""
#~ "void print_card(const card* card);\n"
#~ "```"

#~ msgid ""
#~ "```c\n"
#~ "#include <stdio.h>\n"
#~ "#include \"libbirthday.h\""
#~ msgstr ""
#~ "```c\n"
#~ "#include <stdio.h>\n"
#~ "#include \"libbirthday.h\""

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "//! Bindgen demo."
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "//! Demonstra√ß√£o do Bingen."

#~ msgid "use birthday_bindgen::{card, print_card};"
#~ msgstr "use birthday_bindgen::{card, print_card};"

#~ msgid ""
#~ "```rust,editable\n"
#~ "//! Rust FFI demo.\n"
#~ "#![deny(improper_ctypes_definitions)]"
#~ msgstr ""
#~ "```rust, editable\n"
#~ "//! Demonstra√ß√£o de uso do FFI com Rust.\n"
#~ "#![deny(improper_ctypes_definitions)]"

#~ msgid "use std::os::raw::c_int;"
#~ msgstr "use std::os::raw::c_int;"

#~ msgid ""
#~ "```c\n"
#~ "#ifndef ANALYSE_H\n"
#~ "#define ANALYSE_H"
#~ msgstr ""
#~ "```c\n"
#~ "#ifndef ANALYSE_H\n"
#~ "#define ANALYSE_H"

#~ msgid ""
#~ "#endif\n"
#~ "```"
#~ msgstr ""
#~ "#endif\n"
#~ "```"

#~ msgid ""
#~ "```c\n"
#~ "#include \"analyze.h\""
#~ msgstr ""
#~ "```c\n"
#~ "#include \"analyze.h\""

#~ msgid ""
#~ "[1]: https://cxx.rs/\n"
#~ "[2]: https://cxx.rs/tutorial.html"
#~ msgstr ""
#~ "[1]: https://cxx.rs/\n"
#~ "[2]: https://cxx.rs/tutorial.html"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI demo."
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "//! Demonstra√ß√£o FFI Rust <-> Java."

#~ msgid ""
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;"
#~ msgstr ""
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;"

#~ msgid ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);"
#~ msgstr ""
#~ "```java\n"
#~ "classe HelloWorld{\n"
#~ "    private static native String hello(String name);"

#~ msgid ""
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }"
#~ msgstr ""
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }"

#~ msgid "* Call your AIDL service with a client written in Rust."
#~ msgstr "* Chame seu servi√ßo AIDL com um cliente escrito em Rust."

#~ msgid ""
#~ "// ANCHOR: transpose\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    // ANCHOR_END: transpose\n"
#~ "    let mut result = [[0; 3]; 3];\n"
#~ "    for i in 0..3 {\n"
#~ "        for j in 0..3 {\n"
#~ "            result[j][i] = matrix[i][j];\n"
#~ "        }\n"
#~ "    }\n"
#~ "    return result;\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: transpose\n"
#~ "fn transposta(matriz: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    // ANCHOR_END: transpose\n"
#~ "    let mut resultado = [[0; 3]; 3];\n"
#~ "    for i in 0..3 {\n"
#~ "        for j in 0..3 {\n"
#~ "            resultado[j][i] = matriz[i][j];\n"
#~ "        }\n"
#~ "    }\n"
#~ "    return resultado;\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: pretty_print\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    // ANCHOR_END: pretty_print\n"
#~ "    for row in matrix {\n"
#~ "        println!(\"{row:?}\");\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: pretty_print\n"
#~ "fn impressao_formatada(matriz: &[[i32; 3]; 3]) {\n"
#~ "    // ANCHOR_END: pretty_print\n"
#~ "    for linha in matriz {\n"
#~ "        println!(\"{linha:?}\");\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: tests\n"
#~ "#[test]\n"
#~ "fn test_transpose() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], //\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    assert_eq!(\n"
#~ "        transposed,\n"
#~ "        [\n"
#~ "            [101, 201, 301], //\n"
#~ "            [102, 202, 302],\n"
#~ "            [103, 203, 303],\n"
#~ "        ]\n"
#~ "    );\n"
#~ "}\n"
#~ "// ANCHOR_END: tests"
#~ msgstr ""
#~ "// ANCHOR: tests\n"
#~ "#[test]\n"
#~ "fn test_transposta() {\n"
#~ "    let matriz = [\n"
#~ "        [101, 102, 103], //\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "    let matriz_transposta = transposta(matriz);\n"
#~ "    assert_eq!(\n"
#~ "        matriz_transposta,\n"
#~ "        [\n"
#~ "            [101, 201, 301], //\n"
#~ "            [102, 202, 302],\n"
#~ "            [103, 203, 303],\n"
#~ "        ]\n"
#~ "    );\n"
#~ "}\n"
#~ "// ANCHOR_END: tests"

#~ msgid ""
#~ "// ANCHOR: main\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];"
#~ msgstr ""
#~ "// ANCHOR: main\n"
#~ "fn main() {\n"
#~ "    let matriz = [\n"
#~ "        [101, 102, 103], // <-- o coment√°rio faz com que o rustfmt adicione uma nova linha\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];"

#~ msgid ""
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```\n"
#~ "### Bonus question"
#~ msgstr ""
#~ "    let matriz_transposta = transposta(matriz);\n"
#~ "    println!(\"Transposta:\");\n"
#~ "    impressao_formatada(&matriz_transposta);\n"
#~ "}\n"
#~ "```\n"
#~ "### Pergunta b√¥nus"

#~ msgid ""
#~ "```rust\n"
#~ "use std::convert::AsRef;\n"
#~ "use std::fmt::Debug;"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::convert::AsRef;\n"
#~ "use std::fmt::Debug;"

#~ msgid ""
#~ "fn main() {\n"
#~ "    // &[&[i32]]\n"
#~ "    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
#~ "    // [[&str; 2]; 2]\n"
#~ "    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
#~ "    // Vec<Vec<i32>>\n"
#~ "    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    // &[&[i32]]\n"
#~ "    impressao_formatada(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
#~ "    // [[&str; 2]; 2]\n"
#~ "    impressao_formatada([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
#~ "    // Vec<Vec<i32>>\n"
#~ "    impressao_formatada(vec![vec![1, 2], vec![3, 4]]);\n"
#~ "}\n"
#~ "```"

#~ msgid "[1]: https://doc.rust-lang.org/std/convert/trait.AsRef.html"
#~ msgstr "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"

#~ msgid ""
#~ "// ANCHOR: setup\n"
#~ "struct Library {\n"
#~ "    books: Vec<Book>,\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: configura√ß√£o\n"
#~ "struct Biblioteca {\n"
#~ "    livros: Vec<Livro>,\n"
#~ "}"

#~ msgid ""
#~ "// This makes it possible to print Book values with {}.\n"
#~ "impl std::fmt::Display for Book {\n"
#~ "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
#~ "        write!(f, \"{} ({})\", self.title, self.year)\n"
#~ "    }\n"
#~ "}\n"
#~ "// ANCHOR_END: setup"
#~ msgstr ""
#~ "// Isso torna poss√≠vel imprimir valores de livros com {}.\n"
#~ "impl std::fmt::Display for Livro {\n"
#~ "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
#~ "        write!(f, \"{} ({})\", self.titulo, self.ano)\n"
#~ "    }\n"
#~ "}\n"
#~ "// ANCHOR_END: Configura√ß√£o"

#~ msgid ""
#~ "// ANCHOR: Library_new\n"
#~ "impl Library {\n"
#~ "    fn new() -> Library {\n"
#~ "        // ANCHOR_END: Library_new\n"
#~ "        Library { books: Vec::new() }\n"
#~ "    }"
#~ msgstr ""
#~ "impl Biblioteca {\n"
#~ "    // ANCHOR: Library_new\n"
#~ "    fn new() -> Biblioteca {\n"
#~ "        // ANCHOR_END: Library_new\n"
#~ "        Biblioteca { livros: Vec::new() }\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Library_len\n"
#~ "    //fn len(self) -> usize {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "    // ANCHOR_END: Library_len\n"
#~ "    fn len(&self) -> usize {\n"
#~ "        self.books.len()\n"
#~ "    }"
#~ msgstr ""
#~ "    // ANCHOR: Library_len\n"
#~ "    //fn len(self) -> usize {\n"
#~ "    // unimplemented!()\n"
#~ "    ///}\n"
#~ "    // ANCHOR_END: Library_len\n"
#~ "    fn tamanho(&self) -> usize {\n"
#~ "        self.livros.len()\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Library_is_empty\n"
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "    // ANCHOR_END: Library_is_empty\n"
#~ "    fn is_empty(&self) -> bool {\n"
#~ "        self.books.is_empty()\n"
#~ "    }"
#~ msgstr ""
#~ "    // ANCHOR: Library_is_empty\n"
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    // unimplemented!()\n"
#~ "    //}\n"
#~ "    // ANCHOR_END: Library_is_empty\n"
#~ "    fn esta_vazia(&self) -> bool {\n"
#~ "        self.livros.is_empty()\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Library_add_book\n"
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "    // ANCHOR_END: Library_add_book\n"
#~ "    fn add_book(&mut self, book: Book) {\n"
#~ "        self.books.push(book)\n"
#~ "    }"
#~ msgstr ""
#~ "    // ANCHOR: Library_add_book\n"
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    // unimplemented!()\n"
#~ "    ///}\n"
#~ "    // ANCHOR_END: Library_add_book\n"
#~ "    fn adiciona_livro(&mut self, livro: Livro) {\n"
#~ "        self.livros.push(livro)\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Library_print_books\n"
#~ "    //fn print_books(self) {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "    // ANCHOR_END: Library_print_books\n"
#~ "    fn print_books(&self) {\n"
#~ "        for book in &self.books {\n"
#~ "            println!(\"{}\", book);\n"
#~ "        }\n"
#~ "    }"
#~ msgstr ""
#~ "    // ANCHOR: Library_print_books\n"
#~ "    //fn print_books(self) {\n"
#~ "    // unimplemented!()\n"
#~ "    ///}\n"
#~ "    // ANCHOR_END: Library_print_books\n"
#~ "    fn imprime_livros(&self) {\n"
#~ "        for livro in &self.livros {\n"
#~ "            println!(\"{}\", livro);\n"
#~ "        }\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Library_oldest_book\n"
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    //    unimplemented!()\n"
#~ "    //}\n"
#~ "    // ANCHOR_END: Library_oldest_book\n"
#~ "    fn oldest_book(&self) -> Option<&Book> {\n"
#~ "        self.books.iter().min_by_key(|book| book.year)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    // ANCHOR: Library_oldest_book\n"
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    // n√£o implementado!()\n"
#~ "    ///}\n"
#~ "    // ANCHOR_END: Library_oldest_book\n"
#~ "    fn livro_mais_antigo(&self) -> Option<&Livro> {\n"
#~ "        self.livros.iter().min_by_key(|livro| livro.ano)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: main\n"
#~ "// This shows the desired behavior. Uncomment the code below and\n"
#~ "// implement the missing methods. You will need to update the\n"
#~ "// method signatures, including the \"self\" parameter! You may\n"
#~ "// also need to update the variable bindings within main.\n"
#~ "fn main() {\n"
#~ "    let library = Library::new();"
#~ msgstr ""
#~ "// ANCHOR: main\n"
#~ "// Isso mostra o comportamento desejado. Descomente o c√≥digo abaixo e\n"
#~ "// implementa os m√©todos ausentes. Voc√™ precisar√° atualizar o\n"
#~ "// assinaturas de m√©todo, incluindo o par√¢metro \"self\"! Voc√™ pode\n"
#~ "// tamb√©m precisa atualizar as liga√ß√µes de vari√°veis dentro de main.\n"
#~ "fn main() {\n"
#~ "    let mut biblioteca = Biblioteca::new();"

#~ msgid ""
#~ "    //println!(\"Our library is empty: {}\", library.is_empty());\n"
#~ "    //\n"
#~ "    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
#~ "    //\n"
#~ "    //library.print_books();\n"
#~ "    //\n"
#~ "    //match library.oldest_book() {\n"
#~ "    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
#~ "    //    None => println!(\"My library is empty!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"Our library has {} books\", library.len());\n"
#~ "}\n"
#~ "// ANCHOR_END: main"
#~ msgstr ""
#~ "    //println!(\"Nossa biblioteca est√° vazia: {}\", biblioteca.esta_vazia());\n"
#~ "    //\n"
#~ "    //biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
#~ "    //biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", "
#~ "1865));\n"
#~ "    //\n"
#~ "    //biblioteca.imprime_livros();\n"
#~ "    //\n"
#~ "    //match biblioteca.livro_mais_antigo() {\n"
#~ "    // Some(livro) => println!(\"Meu livro mais antigo √© {livro}\"),\n"
#~ "    // None => println!(\"Minha biblioteca est√° vazia!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"Nossa biblioteca tem {} livros\", biblioteca.tamanho());\n"
#~ "}\n"
#~ "// ANCHOR_END: main"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_library_len() {\n"
#~ "    let mut library = Library::new();\n"
#~ "    assert_eq!(library.len(), 0);\n"
#~ "    assert!(library.is_empty());"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_tamanho_biblioteca() {\n"
#~ "    let mut biblioteca = Biblioteca::new();\n"
#~ "    assert_eq!(biblioteca.tamanho(), 0);\n"
#~ "    assert!(biblioteca.esta_vazia());"

#~ msgid ""
#~ "    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
#~ "    assert_eq!(library.len(), 2);\n"
#~ "    assert!(!library.is_empty());\n"
#~ "}"
#~ msgstr ""
#~ "    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
#~ "    biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", "
#~ "1865));\n"
#~ "    assert_eq!(biblioteca.tamanho(), 2);\n"
#~ "    assert!(!biblioteca.esta_vazia());\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_library_is_empty() {\n"
#~ "    let mut library = Library::new();\n"
#~ "    assert!(library.is_empty());"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_biblioteca_esta_vazia() {\n"
#~ "    let mut biblioteca = Biblioteca::new();\n"
#~ "    assert!(biblioteca.esta_vazia());"

#~ msgid ""
#~ "    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    assert!(!library.is_empty());\n"
#~ "}"
#~ msgstr ""
#~ "    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
#~ "    assert!(!biblioteca.esta_vazia());\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_library_print_books() {\n"
#~ "    let mut library = Library::new();\n"
#~ "    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
#~ "    // We could try and capture stdout, but let us just call the\n"
#~ "    // method to start with.\n"
#~ "    library.print_books();\n"
#~ "}"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_biblioteca_imprime_livros() {\n"
#~ "    let mut biblioteca = Biblioteca::new();\n"
#~ "    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
#~ "    biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", "
#~ "1865));\n"
#~ "    // Poder√≠amos tentar capturar stdout, mas vamos apenas chamar o\n"
#~ "    // m√©todo para come√ßar.\n"
#~ "    biblioteca.imprime_livros();\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_library_oldest_book() {\n"
#~ "    let mut library = Library::new();\n"
#~ "    assert!(library.oldest_book().is_none());"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_biblioteca_livro_mais_antigo() {\n"
#~ "    let mut biblioteca = Biblioteca::new();\n"
#~ "    assert!(biblioteca.livro_mais_antigo().is_none());"

#~ msgid ""
#~ "    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    assert_eq!(\n"
#~ "        library.oldest_book().map(|b| b.title.as_str()),\n"
#~ "        Some(\"Lord of the Rings\")\n"
#~ "    );"
#~ msgstr ""
#~ "    biblioteca.adiciona_livro(Livro::new(\"O Senhor dos An√©is\", 1954));\n"
#~ "    assert_eq!(\n"
#~ "        biblioteca.livro_mais_antigo().map(|b| b.titulo.as_str()),\n"
#~ "        Some(\"O Senhor dos An√©is\")\n"
#~ "    );"

#~ msgid ""
#~ "    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
#~ "    assert_eq!(\n"
#~ "        library.oldest_book().map(|b| b.title.as_str()),\n"
#~ "        Some(\"Alice's Adventures in Wonderland\")\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    biblioteca.adiciona_livro(Livro::new(\"As Aventuras de Alice no Pa√≠s das Maravilhas\", "
#~ "1865));\n"
#~ "    assert_eq!(\n"
#~ "        biblioteca.livro_mais_antigo().map(|b| b.titulo.as_str()),\n"
#~ "        Some(\"As Aventuras de Alice no Pa√≠s das Maravilhas\")\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
#~ "// ANCHOR: Point\n"
#~ "pub struct Point {\n"
#~ "    // ANCHOR_END: Point\n"
#~ "    x: i32,\n"
#~ "    y: i32,\n"
#~ "}"
#~ msgstr ""
#~ "#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
#~ "// ANCHOR: Point\n"
#~ "pub struct Ponto {\n"
#~ "    // ANCHOR_END: Point\n"
#~ "    x: i32,\n"
#~ "    y: i32,\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Point-impl\n"
#~ "impl Point {\n"
#~ "    // ANCHOR_END: Point-impl\n"
#~ "    pub fn new(x: i32, y: i32) -> Point {\n"
#~ "        Point { x, y }\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: Point-impl\n"
#~ "impl Ponto {\n"
#~ "    // ANCHOR_END: Point-impl\n"
#~ "    pub fn new(x: i32, y: i32) -> Ponto {\n"
#~ "        Ponto { x, y }\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn magnitude(self) -> f64 {\n"
#~ "        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn magnitude(self) -> f64 {\n"
#~ "        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn dist(self, other: Point) -> f64 {\n"
#~ "        (self - other).magnitude()\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    pub fn dist(self, outro: Ponto) -> f64 {\n"
#~ "        (self - outro).magnitude()\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "    fn add(self, other: Self) -> Self::Output {\n"
#~ "        Self {\n"
#~ "            x: self.x + other.x,\n"
#~ "            y: self.y + other.y,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn add(self, outro: Self) -> Self::Output {\n"
#~ "        Self {\n"
#~ "            x: self.x + outro.x,\n"
#~ "            y: self.y + outro.y,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl std::ops::Sub for Point {\n"
#~ "    type Output = Self;"
#~ msgstr ""
#~ "impl std::ops::Sub for Ponto {\n"
#~ "    type Output = Self;"

#~ msgid ""
#~ "    fn sub(self, other: Self) -> Self::Output {\n"
#~ "        Self {\n"
#~ "            x: self.x - other.x,\n"
#~ "            y: self.y - other.y,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    fn sub(self, outro: Self) -> Self::Output {\n"
#~ "        Self {\n"
#~ "            x: self.x - outro.x,\n"
#~ "            y: self.y - outro.y,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Polygon\n"
#~ "pub struct Polygon {\n"
#~ "    // ANCHOR_END: Polygon\n"
#~ "    points: Vec<Point>,\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: Polygon\n"
#~ "pub struct Poligono {\n"
#~ "    // ANCHOR_END: Polygon\n"
#~ "    pontos: Vec<Ponto>,\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Polygon-impl\n"
#~ "impl Polygon {\n"
#~ "    // ANCHOR_END: Polygon-impl\n"
#~ "    pub fn new() -> Polygon {\n"
#~ "        Polygon { points: Vec::new() }\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: Polygon-impl\n"
#~ "impl Poligono {\n"
#~ "    pub fn new() -> Poligono {\n"
#~ "        Poligono { pontos: Vec::new() }\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn add_point(&mut self, point: Point) {\n"
#~ "        self.points.push(point);\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn adiciona_ponto(&mut self, ponto: Ponto) {\n"
#~ "        self.pontos.push(ponto);\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn left_most_point(&self) -> Option<Point> {\n"
#~ "        self.points.iter().min_by_key(|p| p.x).copied()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn ponto_mais_a_esquerda(&self) -> Option<Ponto> {\n"
#~ "        self.pontos.iter().min_by_key(|p| p.x).copied()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
#~ "        self.points.iter()\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn iter(&self) -> impl Iterator<Item = &Ponto> {\n"
#~ "        self.pontos.iter()\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn length(&self) -> f64 {\n"
#~ "        if self.points.is_empty() {\n"
#~ "            return 0.0;\n"
#~ "        }"
#~ msgstr ""
#~ "    pub fn comprimento(&self) -> f64 {\n"
#~ "        if self.pontos.is_empty() {\n"
#~ "            return 0.0;\n"
#~ "        }"

#~ msgid ""
#~ "        let mut result = 0.0;\n"
#~ "        let mut last_point = self.points[0];\n"
#~ "        for point in &self.points[1..] {\n"
#~ "            result += last_point.dist(*point);\n"
#~ "            last_point = *point;\n"
#~ "        }\n"
#~ "        result += last_point.dist(self.points[0]);\n"
#~ "        result\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "        let mut resultado = 0.0;\n"
#~ "        let mut ultimo_ponto = self.pontos[0];\n"
#~ "        for ponto in &self.pontos[1..] {\n"
#~ "            resultado += ultimo_ponto.dist(*ponto);\n"
#~ "            ultimo_ponto = *ponto;\n"
#~ "        }\n"
#~ "        resultado += ultimo_ponto.dist(self.pontos[0]);\n"
#~ "        resultado\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Circle\n"
#~ "pub struct Circle {\n"
#~ "    // ANCHOR_END: Circle\n"
#~ "    center: Point,\n"
#~ "    radius: i32,\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: Circle\n"
#~ "pub struct Circulo {\n"
#~ "    // ANCHOR_END: Circle\n"
#~ "    centro: Ponto,\n"
#~ "    raio: i32,\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Circle-impl\n"
#~ "impl Circle {\n"
#~ "    // ANCHOR_END: Circle-impl\n"
#~ "    pub fn new(center: Point, radius: i32) -> Circle {\n"
#~ "        Circle { center, radius }\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: Circle-impl\n"
#~ "impl Circulo {\n"
#~ "    pub fn new(centro: Ponto, raio: i32) -> Circulo {\n"
#~ "        Circulo { centro, raio }\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn circumference(&self) -> f64 {\n"
#~ "        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
#~ "    }"
#~ msgstr ""
#~ "    pub fn circunferencia(&self) -> f64 {\n"
#~ "        2.0 * std::f64::consts::PI * f64::from(self.raio)\n"
#~ "    }"

#~ msgid ""
#~ "    pub fn dist(&self, other: &Self) -> f64 {\n"
#~ "        self.center.dist(other.center)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    pub fn dist(&self, outro: &Self) -> f64 {\n"
#~ "        self.centro.dist(outro.centro)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Shape\n"
#~ "pub enum Shape {\n"
#~ "    Polygon(Polygon),\n"
#~ "    Circle(Circle),\n"
#~ "}\n"
#~ "// ANCHOR_END: Shape"
#~ msgstr ""
#~ "// ANCHOR: Shape\n"
#~ "pub enum Forma {\n"
#~ "    Poligono(Poligono),\n"
#~ "    Circulo(Circulo),\n"
#~ "}\n"
#~ "// ANCHOR_END: Shape"

#~ msgid ""
#~ "impl From<Polygon> for Shape {\n"
#~ "    fn from(poly: Polygon) -> Self {\n"
#~ "        Shape::Polygon(poly)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl From<Poligono> for Forma {\n"
#~ "    fn from(poli: Poligono) -> Self {\n"
#~ "        Forma::Poligono(poli)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl From<Circle> for Shape {\n"
#~ "    fn from(circle: Circle) -> Self {\n"
#~ "        Shape::Circle(circle)\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl From<Circulo> for Forma {\n"
#~ "    fn from(circulo: Circulo) -> Self {\n"
#~ "        Forma::Circulo(circulo)\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "impl Shape {\n"
#~ "    pub fn perimeter(&self) -> f64 {\n"
#~ "        match self {\n"
#~ "            Shape::Polygon(poly) => poly.length(),\n"
#~ "            Shape::Circle(circle) => circle.circumference(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "impl Forma {\n"
#~ "    pub fn perimetro(&self) -> f64 {\n"
#~ "        match self {\n"
#~ "            Forma::Poligono(poli) => poli.comprimento(),\n"
#~ "            Forma::Circulo(circulo) => circulo.circunferencia(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: unit-tests\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;"
#~ msgstr ""
#~ "// ANCHOR: unit-tests\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;"

#~ msgid ""
#~ "    #[test]\n"
#~ "    fn test_shape_perimeters() {\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(Point::new(12, 13));\n"
#~ "        poly.add_point(Point::new(17, 11));\n"
#~ "        poly.add_point(Point::new(16, 16));\n"
#~ "        let shapes = vec![\n"
#~ "            Shape::from(poly),\n"
#~ "            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimeters = shapes\n"
#~ "            .iter()\n"
#~ "            .map(Shape::perimeter)\n"
#~ "            .map(round_two_digits)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}\n"
#~ "// ANCHOR_END: unit-tests"
#~ msgstr ""
#~ "    #[test]\n"
#~ "    fn test_forma_perimetros() {\n"
#~ "        let mut poli = Poligono::new();\n"
#~ "        poli.adiciona_ponto(Ponto::new(12, 13));\n"
#~ "        poli.adiciona_ponto(Ponto::new(17, 11));\n"
#~ "        poli.adiciona_ponto(Ponto::new(16, 16));\n"
#~ "        let formas = vec![\n"
#~ "            Forma::from(poli),\n"
#~ "            Forma::from(Circulo::new(Ponto::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimetros = formas\n"
#~ "            .iter()\n"
#~ "            .map(Forma::perimetro)\n"
#~ "            .map(arredonda_dois_digitos)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimetros, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}\n"
#~ "// ANCHOR_END: unit-tests"

#~ msgid ""
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "// ANCHOR: luhn\n"
#~ "pub fn luhn(cc_number: &str) -> bool {\n"
#~ "    // ANCHOR_END: luhn\n"
#~ "    let mut digits_seen = 0;\n"
#~ "    let mut sum = 0;\n"
#~ "    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
#~ "        match ch.to_digit(10) {\n"
#~ "            Some(d) => {\n"
#~ "                sum += if i % 2 == 1 {\n"
#~ "                    let dd = d * 2;\n"
#~ "                    dd / 10 + dd % 10\n"
#~ "                } else {\n"
#~ "                    d\n"
#~ "                };\n"
#~ "                digits_seen += 1;\n"
#~ "            }\n"
#~ "            None => return false,\n"
#~ "        }\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: luhn\n"
#~ "pub fn luhn(numero_cc: &str) -> bool {\n"
#~ "    // ANCHOR_END: luhn\n"
#~ "    let mut digitos_vistos = 0;\n"
#~ "    let mut soma = 0;\n"
#~ "    for (i, ch) in numero_cc.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
#~ "        match ch.to_digit(10) {\n"
#~ "            Some(d) => {\n"
#~ "                soma += if i % 2 == 1 {\n"
#~ "                    let dd = d * 2;\n"
#~ "                    dd / 10 + dd % 10\n"
#~ "                } else {\n"
#~ "                    d\n"
#~ "                };\n"
#~ "                digitos_vistos += 1;\n"
#~ "            }\n"
#~ "            None => return false,\n"
#~ "        }\n"
#~ "    }"

#~ msgid ""
#~ "    if digits_seen < 2 {\n"
#~ "        return false;\n"
#~ "    }"
#~ msgstr ""
#~ "    if digitos_vistos < 2 {\n"
#~ "        return false;\n"
#~ "    }"

#~ msgid ""
#~ "    sum % 10 == 0\n"
#~ "}"
#~ msgstr ""
#~ "    soma % 10 == 0\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    let cc_number = \"1234 5678 1234 5670\";\n"
#~ "    println!(\n"
#~ "        \"Is {} a valid credit card number? {}\",\n"
#~ "        cc_number,\n"
#~ "        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
#~ "    );\n"
#~ "}"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    let numero_cc = \"1234 5678 1234 5670\";\n"
#~ "    println!(\n"
#~ "        \"{} √© um n√∫mero de cart√£o de cr√©dito v√°lido? {}\",\n"
#~ "        numero_cc,\n"
#~ "        if luhn(numero_cc) { \"Sim\" } else { \"N√£o\" }\n"
#~ "    );\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: unit-tests\n"
#~ "#[test]\n"
#~ "fn test_non_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: unit-tests\n"
#~ "#[test]\n"
#~ "fn test_numero_cc_nao_numerico() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}"

#~ msgid ""
#~ "#[test]\n"
#~ "fn test_invalid_cc_number() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}\n"
#~ "// ANCHOR_END: unit-tests\n"
#~ "```"
#~ msgstr ""
#~ "#[test]\n"
#~ "fn test_numero_cc_invalido() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}\n"
#~ "// ANCHOR_END: unit-tests\n"
#~ "```"

#~ msgid ""
#~ "// ANCHOR: prefix_matches\n"
#~ "pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
#~ "    // ANCHOR_END: prefix_matches\n"
#~ "    let prefixes = prefix.split('/');\n"
#~ "    let request_paths = request_path\n"
#~ "        .split('/')\n"
#~ "        .map(|p| Some(p))\n"
#~ "        .chain(std::iter::once(None));"
#~ msgstr ""
#~ "// ANCHOR: prefix_matches\n"
#~ "pub fn correspondencia_prefixo(prefixo: &str, caminho_requisitado: &str) -> bool {\n"
#~ "// ANCHOR_END: prefix_matches\n"
#~ "    let prefixos = prefixo.split('/');\n"
#~ "    let caminhos_requisitados = caminho_requisitado\n"
#~ "        .split('/')\n"
#~ "        .map(|p| Some(p))\n"
#~ "        .chain(std::iter::once(None));"

#~ msgid ""
#~ "    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
#~ "        match request_path {\n"
#~ "            Some(request_path) => {\n"
#~ "                if (prefix != \"*\") && (prefix != request_path) {\n"
#~ "                    return false;\n"
#~ "                }\n"
#~ "            }\n"
#~ "            None => return false,\n"
#~ "        }\n"
#~ "    }\n"
#~ "    true\n"
#~ "}"
#~ msgstr ""
#~ "    for (prefixo, caminho_requisitado) in prefixos.zip(caminhos_requisitados) {\n"
#~ "        match caminho_requisitado {\n"
#~ "            Some(caminho_requisitado) => {\n"
#~ "                if (prefixo != \"*\") && (prefixo != caminho_requisitado) {\n"
#~ "                    return false;\n"
#~ "                }\n"
#~ "            }\n"
#~ "            None => return false,\n"
#~ "        }\n"
#~ "    }\n"
#~ "    true\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: unit-tests\n"
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
#~ msgstr ""
#~ "// ANCHOR: unit-tests\n"
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(correspondencia_prefixo(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(correspondencia_prefixo(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
#~ "    assert!(correspondencia_prefixo(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"

#~ msgid ""
#~ "    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
#~ "    assert!(!prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "// ANCHOR_END: unit-tests"
#~ msgstr ""
#~ "    assert!(!correspondencia_prefixo(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
#~ "    assert!(!correspondencia_prefixo(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "// ANCHOR_END: unit-tests"

#~ msgid ""
#~ "// ANCHOR: setup\n"
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;"
#~ msgstr ""
#~ "// ANCHOR: setup\n"
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;"

#~ msgid "// ANCHOR_END: setup"
#~ msgstr "// ANCHOR_END: setup"

#~ msgid ""
#~ "// ANCHOR: Window-width\n"
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        // ANCHOR_END: Window-width\n"
#~ "        std::cmp::max(\n"
#~ "            self.title.chars().count(),\n"
#~ "            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
#~ "        )\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: Window-width\n"
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        // ANCHOR_END: Window-width\n"
#~ "        std::cmp::max(\n"
#~ "            self.title.chars().count(),\n"
#~ "            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
#~ "        )\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Window-draw_into\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        // ANCHOR_END: Window-draw_into\n"
#~ "        let mut inner = String::new();\n"
#~ "        for widget in &self.widgets {\n"
#~ "            widget.draw_into(&mut inner);\n"
#~ "        }"
#~ msgstr ""
#~ "    // ANCHOR: Window-draw_into\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        // ANCHOR_END: Window-draw_into\n"
#~ "        let mut inner = String::new();\n"
#~ "        for widget in &self.widgets {\n"
#~ "            widget.draw_into(&mut inner);\n"
#~ "        }"

#~ msgid "        let window_width = self.width();"
#~ msgstr "        let window_width = self.width();"

#~ msgid ""
#~ "        // TODO: after learning about error handling, you can change\n"
#~ "        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
#~ "        // the ?-operator here instead of .unwrap().\n"
#~ "        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
#~ "        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
#~ "        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
#~ "        for line in inner.lines() {\n"
#~ "            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
#~ "        }\n"
#~ "        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "        // TODO: depois de aprender sobre tratamento de erros, voc√™ pode alterar\n"
#~ "        // draw_into para retornar Result<(), std::fmt::Error>. Ent√£o use\n"
#~ "        // o operador ? aqui em vez de .unwrap().\n"
#~ "        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
#~ "        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
#~ "        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
#~ "        for line in inner.lines() {\n"
#~ "            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
#~ "        }\n"
#~ "        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Button-width\n"
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        // ANCHOR_END: Button-width\n"
#~ "        self.label.width() + 8 // add a bit of padding\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: Button-width\n"
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        // ANCHOR_END: Button-width\n"
#~ "        self.label.width() + 8 // add a bit of padding\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Button-draw_into\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        // ANCHOR_END: Button-draw_into\n"
#~ "        let width = self.width();\n"
#~ "        let mut label = String::new();\n"
#~ "        self.label.draw_into(&mut label);"
#~ msgstr ""
#~ "    // ANCHOR: Button-draw_into\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        // ANCHOR_END: Button-draw_into\n"
#~ "        let width = self.width();\n"
#~ "        let mut label = String::new();\n"
#~ "        self.label.draw_into(&mut label);"

#~ msgid ""
#~ "        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
#~ "        for line in label.lines() {\n"
#~ "            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
#~ "        }\n"
#~ "        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
#~ "        for line in label.lines() {\n"
#~ "            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
#~ "        }\n"
#~ "        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Label-width\n"
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        // ANCHOR_END: Label-width\n"
#~ "        self.label\n"
#~ "            .lines()\n"
#~ "            .map(|line| line.chars().count())\n"
#~ "            .max()\n"
#~ "            .unwrap_or(0)\n"
#~ "    }"
#~ msgstr ""
#~ "// ANCHOR: Label-width\n"
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        // ANCHOR_END: Label-width\n"
#~ "        self.label\n"
#~ "            .lines()\n"
#~ "            .map(|line| line.chars().count())\n"
#~ "            .max()\n"
#~ "            .unwrap_or(0)\n"
#~ "    }"

#~ msgid ""
#~ "    // ANCHOR: Label-draw_into\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        // ANCHOR_END: Label-draw_into\n"
#~ "        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "    // ANCHOR: Label-draw_into\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        // ANCHOR_END: Label-draw_into\n"
#~ "        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: main\n"
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Click me!\",\n"
#~ "        Box::new(|| println!(\"You clicked the button!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "// ANCHOR_END: main\n"
#~ "```"
#~ msgstr ""
#~ "// ANCHOR: main\n"
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"Esta √© uma pequena demonstra√ß√£o de GUI de texto."
#~ "\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Clique em mim!\",\n"
#~ "        Box::new(|| println!(\"Voc√™ clicou no bot√£o!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "// ANCHOR_END: main\n"
#~ "```"

#~ msgid ""
#~ "// ANCHOR: ffi\n"
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
#~ msgstr ""
#~ "// ANCHOR: ffi\n"
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"

#~ msgid ""
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}\n"
#~ "// ANCHOR_END: ffi"
#~ msgstr ""
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}\n"
#~ "// ANCHOR_END: ffi"

#~ msgid ""
#~ "// ANCHOR: DirectoryIterator\n"
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        // ANCHOR_END: DirectoryIterator\n"
#~ "        let path = CString::new(path).map_err(|err| format!(\"Invalid path: {err}\"))?;\n"
#~ "        // SAFETY: path.as_ptr() cannot be NULL.\n"
#~ "        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
#~ "        if dir.is_null() {\n"
#~ "            Err(format!(\"Could not open {:?}\", path))\n"
#~ "        } else {\n"
#~ "            Ok(DirectoryIterator { path, dir })\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: DirectoryIterator\n"
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        // ANCHOR_END: DirectoryIterator\n"
#~ "        let path = CString::new(path).map_err(|err| format!(\"Caminho inv√°lido: {err}\"))?;\n"
#~ "        // SAFETY: path.as_ptr() cannot be NULL.\n"
#~ "        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
#~ "        if dir.is_null() {\n"
#~ "            Err(format!(\"N√£o foi poss√≠vel abrir {:?}\", path))\n"
#~ "        } else {\n"
#~ "            Ok(DirectoryIterator { path, dir })\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Iterator\n"
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        // ANCHOR_END: Iterator\n"
#~ "        // SAFETY: self.dir is never NULL.\n"
#~ "        let dirent = unsafe { ffi::readdir(self.dir) };\n"
#~ "        if dirent.is_null() {\n"
#~ "            // We have reached the end of the directory.\n"
#~ "            return None;\n"
#~ "        }\n"
#~ "        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
#~ "        // terminated.\n"
#~ "        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
#~ "        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
#~ "        Some(os_str.to_owned())\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: Iterator\n"
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        // ANCHOR_END: Iterator\n"
#~ "        // SAFETY: self.dir is never NULL.\n"
#~ "        let dirent = unsafe { ffi::readdir(self.dir) };\n"
#~ "        if dirent.is_null() {\n"
#~ "            // We have reached the end of the directory.\n"
#~ "            return None;\n"
#~ "        }\n"
#~ "        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
#~ "        // terminated.\n"
#~ "        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
#~ "        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
#~ "        Some(os_str.to_owned())\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Drop\n"
#~ "impl Drop for DirectoryIterator {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Call closedir as needed.\n"
#~ "        // ANCHOR_END: Drop\n"
#~ "        if !self.dir.is_null() {\n"
#~ "            // SAFETY: self.dir is not NULL.\n"
#~ "            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
#~ "                panic!(\"Could not close {:?}\", self.path);\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "// ANCHOR: Drop\n"
#~ "impl Drop for DirectoryIterator {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Call closedir as needed.\n"
#~ "        // ANCHOR_END: Drop\n"
#~ "        if !self.dir.is_null() {\n"
#~ "            // SAFETY: self.dir is not NULL.\n"
#~ "            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
#~ "                panic!(\"N√£o foi poss√≠vel fechar {:?}\", self.path);\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: main\n"
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "// ANCHOR_END: main\n"
#~ "```"
#~ msgstr ""
#~ "// ANCHOR: main\n"
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"Arquivos: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "// ANCHOR_END: main\n"
#~ "```"

#~ msgid "# Day 4 Morning Exercise"
#~ msgstr "# Dia 4 Exerc√≠cio matinal"

#~ msgid ""
#~ "// ANCHOR: Philosopher\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"
#~ msgstr ""
#~ "// ANCHOR: Philosopher\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;"

#~ msgid ""
#~ "struct Philosopher {\n"
#~ "    name: String,\n"
#~ "    // ANCHOR_END: Philosopher\n"
#~ "    left_fork: Arc<Mutex<Fork>>,\n"
#~ "    right_fork: Arc<Mutex<Fork>>,\n"
#~ "    thoughts: mpsc::SyncSender<String>,\n"
#~ "}"
#~ msgstr ""
#~ "struct Filosofo {\n"
#~ "    nome: String,\n"
#~ "    // ANCHOR_END: Philosopher\n"
#~ "    garfo_esquerda: Arc<Mutex<Garfo>>,\n"
#~ "    garfo_direita: Arc<Mutex<Garfo>>,\n"
#~ "    pensamentos: mpsc::SyncSender<String>,\n"
#~ "}"

#~ msgid ""
#~ "// ANCHOR: Philosopher-think\n"
#~ "impl Philosopher {\n"
#~ "    fn think(&self) {\n"
#~ "        self.thoughts\n"
#~ "            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
#~ "            .unwrap();\n"
#~ "    }\n"
#~ "    // ANCHOR_END: Philosopher-think"
#~ msgstr ""
#~ "// ANCHOR: Philosopher-think\n"
#~ "impl Filosofo {\n"
#~ "    fn pensar(&self) {\n"
#~ "        self.pensamentos\n"
#~ "            .send(format!(\"Eureka! {} teve uma nova ideia!\", &self.nome))\n"
#~ "            .unwrap();\n"
#~ "    }\n"
#~ "    // ANCHOR_END: Philosopher-think"

#~ msgid ""
#~ "    // ANCHOR: Philosopher-eat\n"
#~ "    fn eat(&self) {\n"
#~ "        // ANCHOR_END: Philosopher-eat\n"
#~ "        println!(\"{} is trying to eat\", &self.name);\n"
#~ "        let left = self.left_fork.lock().unwrap();\n"
#~ "        let right = self.right_fork.lock().unwrap();"
#~ msgstr ""
#~ "    // ANCHOR: Philosopher-eat\n"
#~ "    fn comer(&self) {\n"
#~ "        // ANCHOR_END: Philosopher-eat\n"
#~ "        println!(\"{} est√° tentando comer\", &self.nome);\n"
#~ "        let _esquerda = self.garfo_esquerda.lock().unwrap();\n"
#~ "        let _direita = self.garfo_direita.lock().unwrap();"

#~ msgid ""
#~ "        // ANCHOR: Philosopher-eat-end\n"
#~ "        println!(\"{} is eating...\", &self.name);\n"
#~ "        thread::sleep(Duration::from_millis(10));\n"
#~ "    }\n"
#~ "}"
#~ msgstr ""
#~ "        // ANCHOR: Philosopher-eat-end\n"
#~ "        println!(\"{} est√° comendo...\", &self.nome);\n"
#~ "        thread::sleep(Duration::from_millis(10));\n"
#~ "    }\n"
#~ "}"

#~ msgid ""
#~ "fn main() {\n"
#~ "    // ANCHOR_END: Philosopher-eat-end\n"
#~ "    let (tx, rx) = mpsc::sync_channel(10);"
#~ msgstr ""
#~ "fn main() {\n"
#~ "    // ANCHOR_END: Philosopher-eat-end\n"
#~ "    let (tx, rx) = mpsc::sync_channel(10);"

#~ msgid ""
#~ "    let forks = (0..PHILOSOPHERS.len())\n"
#~ "        .map(|_| Arc::new(Mutex::new(Fork)))\n"
#~ "        .collect::<Vec<_>>();"
#~ msgstr ""
#~ "    let garfos = (0..FILOSOFOS.len())\n"
#~ "        .map(|_| Arc::new(Mutex::new(Garfo)))\n"
#~ "        .collect::<Vec<_>>();"

#~ msgid ""
#~ "    for i in 0..forks.len() {\n"
#~ "        let tx = tx.clone();\n"
#~ "        let mut left_fork = forks[i].clone();\n"
#~ "        let mut right_fork = forks[(i + 1) % forks.len()].clone();"
#~ msgstr ""
#~ "    for i in 0..garfos.len() {\n"
#~ "        let tx = tx.clone();\n"
#~ "        let mut garfo_esquerda = garfos[i].clone();\n"
#~ "        let mut garfo_direita = garfos[(i + 1) % garfos.len()].clone();"

#~ msgid ""
#~ "        // To avoid a deadlock, we have to break the symmetry\n"
#~ "        // somewhere. This will swap the forks without deinitializing\n"
#~ "        // either of them.\n"
#~ "        if i == forks.len() - 1 {\n"
#~ "            std::mem::swap(&mut left_fork, &mut right_fork);\n"
#~ "        }"
#~ msgstr ""
#~ "        // Para evitar um impasse, temos que quebrar a simetria\n"
#~ "        // algum lugar. Isso ir√° trocar os garfos sem desinicializar\n"
#~ "        // qualquer um deles.\n"
#~ "        if i == garfos.len() - 1 {\n"
#~ "            std::mem::swap(&mut garfo_esquerda, &mut garfo_direita);\n"
#~ "        }"

#~ msgid ""
#~ "        let philosopher = Philosopher {\n"
#~ "            name: PHILOSOPHERS[i].to_string(),\n"
#~ "            thoughts: tx,\n"
#~ "            left_fork,\n"
#~ "            right_fork,\n"
#~ "        };"
#~ msgstr ""
#~ "        let filosofo = Filosofo {\n"
#~ "            nome: FILOSOFOS[i].to_string(),\n"
#~ "            pensamentos: tx,\n"
#~ "            garfo_esquerda,\n"
#~ "            garfo_direita,\n"
#~ "        };"

#~ msgid ""
#~ "        thread::spawn(move || {\n"
#~ "            for _ in 0..100 {\n"
#~ "                philosopher.eat();\n"
#~ "                philosopher.think();\n"
#~ "            }\n"
#~ "        });\n"
#~ "    }"
#~ msgstr ""
#~ "        thread::spawn(move || {\n"
#~ "            for _ in 0..100 {\n"
#~ "                filosofo.comer();\n"
#~ "                filosofo.pensar();\n"
#~ "            }\n"
#~ "        });\n"
#~ "    }"

#~ msgid ""
#~ "    drop(tx);\n"
#~ "    for thought in rx {\n"
#~ "        println!(\"{thought}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "    drop(tx);\n"
#~ "    for pensamento in rx {\n"
#~ "        println!(\"{pensamento}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "* `Box` is like `std::unique_ptr` in C++.\n"
#~ "* In the above example, you can even leave out the `*` in the `println!` statement thanks to "
#~ "`Deref`."
#~ msgstr ""
#~ "* `Box` √© como `std::unique_ptr` em C++.\n"
#~ "* No exemplo acima, voc√™ pode at√© deixar de fora o `*` na declara√ß√£o `println!` gra√ßas a "
#~ "`Deref`."
