msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust ü¶Ä\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-06-07 17:56+0100\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3.1\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust ü¶Ä"
msgstr "Benvenuti a Comprehensive Rust ü¶Ä"

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "Esecuzione del corso"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "Struttura del corso"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "Tasti rapidi"

#: src/SUMMARY.md:7
msgid "Translations"
msgstr "Traduzioni"

#: src/SUMMARY.md:8
msgid "Using Cargo"
msgstr "Utilizzo di Cargo"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "Ecosistema di Rust"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "Esempi di codice"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "Eseguire Cargo in locale"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "Giorno 1: Mattino"

#: src/SUMMARY.md:18 src/SUMMARY.md:75 src/SUMMARY.md:128 src/SUMMARY.md:185 src/SUMMARY.md:211
#: src/SUMMARY.md:259
msgid "Welcome"
msgstr "Benvenuti"

#: src/SUMMARY.md:19
msgid "What is Rust?"
msgstr "Cos‚Äô√® Rust?"

#: src/SUMMARY.md:20
msgid "Hello World!"
msgstr "Hello World!"

#: src/SUMMARY.md:21
msgid "Small Example"
msgstr "Piccolo esempio"

#: src/SUMMARY.md:22
msgid "Why Rust?"
msgstr "Perch√© Rust?"

#: src/SUMMARY.md:23
msgid "Compile Time Guarantees"
msgstr "Garanzie alla Compilazione"

#: src/SUMMARY.md:24
msgid "Runtime Guarantees"
msgstr "Garanzie all‚ÄôEsecuzione"

#: src/SUMMARY.md:25
msgid "Modern Features"
msgstr "Funzionalit√† moderne"

#: src/SUMMARY.md:26
msgid "Basic Syntax"
msgstr "Sintassi di base"

#: src/SUMMARY.md:27
msgid "Scalar Types"
msgstr "Tipi Scalari"

#: src/SUMMARY.md:28
msgid "Compound Types"
msgstr "Tipi Composti"

#: src/SUMMARY.md:29
msgid "References"
msgstr "Riferimenti"

#: src/SUMMARY.md:30
msgid "Dangling References"
msgstr "Riferimenti pendenti"

#: src/SUMMARY.md:31
msgid "Slices"
msgstr "Slice"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "Differenza tra String e str"

#: src/SUMMARY.md:33
msgid "Functions"
msgstr "Funzioni"

#: src/SUMMARY.md:34
msgid "Rustdoc"
msgstr "Rustico"

#: src/SUMMARY.md:35 src/SUMMARY.md:82
msgid "Methods"
msgstr "Metodi"

#: src/SUMMARY.md:36
msgid "Overloading"
msgstr "Overloading"

#: src/SUMMARY.md:37 src/SUMMARY.md:66 src/SUMMARY.md:90 src/SUMMARY.md:119 src/SUMMARY.md:148
#: src/SUMMARY.md:177 src/SUMMARY.md:204 src/SUMMARY.md:225 src/SUMMARY.md:251 src/SUMMARY.md:273
#: src/SUMMARY.md:293
msgid "Exercises"
msgstr "Esercizi"

#: src/SUMMARY.md:38
msgid "Implicit Conversions"
msgstr "Conversione implicita"

#: src/SUMMARY.md:39
msgid "Arrays and for Loops"
msgstr "Array e Cicli for"

#: src/SUMMARY.md:41
msgid "Day 1: Afternoon"
msgstr "Giorno 1: Pomeriggio"

#: src/SUMMARY.md:43
msgid "Variables"
msgstr "Variabili"

#: src/SUMMARY.md:44
msgid "Type Inference"
msgstr "Inferenza del Tipo"

#: src/SUMMARY.md:45
msgid "static & const"
msgstr "static & const"

#: src/SUMMARY.md:46
msgid "Scopes and Shadowing"
msgstr "Scope e Shadowing"

#: src/SUMMARY.md:47
msgid "Memory Management"
msgstr "Gestione della Memoria"

#: src/SUMMARY.md:48
msgid "Stack vs Heap"
msgstr "Stack vs Heap"

#: src/SUMMARY.md:49
msgid "Stack Memory"
msgstr "Memoria sullo Stack"

#: src/SUMMARY.md:50
msgid "Manual Memory Management"
msgstr "Gestione manuale della Memoria"

#: src/SUMMARY.md:51
msgid "Scope-Based Memory Management"
msgstr "Gestione della Memoria basata su Scope"

#: src/SUMMARY.md:52
msgid "Garbage Collection"
msgstr "Garbage Collection"

#: src/SUMMARY.md:53
msgid "Rust Memory Management"
msgstr "Gestione della Memoria in Rust"

#: src/SUMMARY.md:54
msgid "Comparison"
msgstr "Comparazione"

#: src/SUMMARY.md:55
msgid "Ownership"
msgstr "Propriet√†"

#: src/SUMMARY.md:56
msgid "Move Semantics"
msgstr "Semantica di move"

#: src/SUMMARY.md:57
msgid "Moved Strings in Rust"
msgstr "Stringhe a cui √® applicata move"

#: src/SUMMARY.md:58
msgid "Double Frees in Modern C++"
msgstr "Doppio applicazione di free in C++ moderno"

#: src/SUMMARY.md:59
msgid "Moves in Function Calls"
msgstr "Move nelle Chiamate a Funzione"

#: src/SUMMARY.md:60
msgid "Copying and Cloning"
msgstr "Copiare (Copy) e Clonare (Clone)"

#: src/SUMMARY.md:61
msgid "Borrowing"
msgstr "Prestito (Borrowing)"

#: src/SUMMARY.md:62
msgid "Shared and Unique Borrows"
msgstr "Prestito (Borrow) Condiviso (Shared) e Unico (Unique)"

#: src/SUMMARY.md:63
msgid "Lifetimes"
msgstr "Lifetime"

#: src/SUMMARY.md:64
msgid "Lifetimes in Function Calls"
msgstr "Lifetime in Chiamate a Funzione"

#: src/SUMMARY.md:65
msgid "Lifetimes in Data Structures"
msgstr "Lifetime in Strutture Dati"

#: src/SUMMARY.md:67
msgid "Designing a Library"
msgstr "Progettare una Libreria"

#: src/SUMMARY.md:68
msgid "Iterators and Ownership"
msgstr "Iteratori (Iterators) e Propriet√† (Ownership)"

#: src/SUMMARY.md:71
msgid "Day 2: Morning"
msgstr "2¬∞ giorno: Mattina"

#: src/SUMMARY.md:76
msgid "Structs"
msgstr "Strutture (Struct)"

#: src/SUMMARY.md:77
msgid "Tuple Structs"
msgstr "Strutture a Tupla (Tuple Structs)"

#: src/SUMMARY.md:78
msgid "Field Shorthand Syntax"
msgstr "Sintassi abbreviata per Campo (Field)"

#: src/SUMMARY.md:79
msgid "Enums"
msgstr "Enumerazioni (Enums)"

#: src/SUMMARY.md:80
msgid "Variant Payloads"
msgstr "Payload Variabili (Variant Payloads)"

#: src/SUMMARY.md:81
msgid "Enum Sizes"
msgstr "Dimensione degli Enum"

#: src/SUMMARY.md:83
msgid "Method Receiver"
msgstr "Ricevitore (Receiver) del Metodo"

#: src/SUMMARY.md:84 src/SUMMARY.md:159 src/SUMMARY.md:272
msgid "Example"
msgstr "Esempio"

#: src/SUMMARY.md:85
msgid "Pattern Matching"
msgstr "Pattern Matching"

#: src/SUMMARY.md:86
msgid "Destructuring Enums"
msgstr "Destrutturazione di Enum"

#: src/SUMMARY.md:87
msgid "Destructuring Structs"
msgstr "Destrutturazione di Struct"

#: src/SUMMARY.md:88
msgid "Destructuring Arrays"
msgstr "Destrutturazione di Array"

#: src/SUMMARY.md:89
msgid "Match Guards"
msgstr "Match Guards"

#: src/SUMMARY.md:91
msgid "Health Statistics"
msgstr "Salute (Health) Statistics"

#: src/SUMMARY.md:92
msgid "Points and Polygons"
msgstr "Punti e Poligoni"

#: src/SUMMARY.md:94
msgid "Day 2: Afternoon"
msgstr "2¬∞ giorno: Pomeriggio"

#: src/SUMMARY.md:96 src/SUMMARY.md:286
msgid "Control Flow"
msgstr "Flusso di Controllo"

#: src/SUMMARY.md:97
msgid "Blocks"
msgstr "Blocchi"

#: src/SUMMARY.md:98
msgid "if expressions"
msgstr "espressioni IF"

#: src/SUMMARY.md:99
msgid "if let expressions"
msgstr "espressioni IF LET"

#: src/SUMMARY.md:100
msgid "while expressions"
msgstr "espressioni WHILE"

#: src/SUMMARY.md:101
msgid "while let expressions"
msgstr "espressioni WHILE LET"

#: src/SUMMARY.md:102
msgid "for expressions"
msgstr "espressioni FOR"

#: src/SUMMARY.md:103
msgid "loop expressions"
msgstr "espressioni LOOP"

#: src/SUMMARY.md:104
msgid "match expressions"
msgstr "espressioni MATCH"

#: src/SUMMARY.md:105
msgid "break & continue"
msgstr "break & continue"

#: src/SUMMARY.md:106
msgid "Standard Library"
msgstr "Libreria standard"

#: src/SUMMARY.md:107
msgid "Option and Result"
msgstr "Option e Result"

#: src/SUMMARY.md:108
msgid "String"
msgstr "Stringa (String)"

#: src/SUMMARY.md:109
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:110
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:111
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:112
msgid "Recursive Data Types"
msgstr "Tipi di dati ricorsivi"

#: src/SUMMARY.md:113
msgid "Niche Optimization"
msgstr "Ottimizzazioni di nicchia"

#: src/SUMMARY.md:114
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:115
msgid "Modules"
msgstr "Moduli"

#: src/SUMMARY.md:116
msgid "Visibility"
msgstr "Visibilit√†"

#: src/SUMMARY.md:117
msgid "Paths"
msgstr "Percorsi (Paths)"

#: src/SUMMARY.md:118
msgid "Filesystem Hierarchy"
msgstr "Gerarchia del filesystem"

#: src/SUMMARY.md:120
msgid "Luhn Algorithm"
msgstr "Algoritmo di Luhn"

#: src/SUMMARY.md:121
msgid "Strings and Iterators"
msgstr "Stringhe (Strings) e Iteratori (Iterators)"

#: src/SUMMARY.md:124
msgid "Day 3: Morning"
msgstr "3¬∞ giorno: Mattina"

#: src/SUMMARY.md:129
msgid "Generics"
msgstr "Generics"

#: src/SUMMARY.md:130
msgid "Generic Data Types"
msgstr "Tipi di dati Generic"

#: src/SUMMARY.md:131
msgid "Generic Methods"
msgstr "Metodi Generic"

#: src/SUMMARY.md:132
msgid "Monomorphization"
msgstr "Monomorfizzazione (Monomorphization)"

#: src/SUMMARY.md:133
msgid "Traits"
msgstr "Traits"

#: src/SUMMARY.md:134
msgid "Trait Objects"
msgstr "Oggetti che implementano Trait (Trait Objects)"

#: src/SUMMARY.md:135
msgid "Deriving Traits"
msgstr "Tratti derivati"

#: src/SUMMARY.md:136
msgid "Default Methods"
msgstr "Metodi predefiniti (Default Methods)"

#: src/SUMMARY.md:137
msgid "Trait Bounds"
msgstr "Trait Bounds"

#: src/SUMMARY.md:138
msgid "impl Trait"
msgstr "impl Trait"

#: src/SUMMARY.md:139
msgid "Important Traits"
msgstr "Trait importanti"

#: src/SUMMARY.md:140
msgid "Iterator"
msgstr "Iteratore (Iterator)"

#: src/SUMMARY.md:141
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:142
msgid "From and Into"
msgstr "From e Into (Trait)"

#: src/SUMMARY.md:143
msgid "Read and Write"
msgstr "Read e Write"

#: src/SUMMARY.md:144
msgid "Drop"
msgstr "Rilascio (Drop)"

#: src/SUMMARY.md:145
msgid "Default"
msgstr "Predefinito (Default)"

#: src/SUMMARY.md:146
msgid "Operators: Add, Mul, ..."
msgstr "Operatori: Add, Mul, ..."

#: src/SUMMARY.md:147
msgid "Closures: Fn, FnMut, FnOnce"
msgstr "Closures: Fn, FnMut, FnOnce"

#: src/SUMMARY.md:149
msgid "A Simple GUI Library"
msgstr "Una semplice libreria per Interfacce Grafiche"

#: src/SUMMARY.md:151
msgid "Day 3: Afternoon"
msgstr "3¬∞ giorno: Pomeriggio"

#: src/SUMMARY.md:153
msgid "Error Handling"
msgstr "Gestione degli errori"

#: src/SUMMARY.md:154
msgid "Panics"
msgstr "Panico (Panics)"

#: src/SUMMARY.md:155
msgid "Catching Stack Unwinding"
msgstr "Catturare lo Stack Unwinding"

#: src/SUMMARY.md:156
msgid "Structured Error Handling"
msgstr "Gestione strutturata degli errori"

#: src/SUMMARY.md:157
msgid "Propagating Errors with ?"
msgstr "Propagazione degli errori con ?"

#: src/SUMMARY.md:158
msgid "Converting Error Types"
msgstr "Conversione dei tipi di errore"

#: src/SUMMARY.md:160
msgid "Deriving Error Enums"
msgstr "Derivazione di Enumerazioni (Enums) di errori"

#: src/SUMMARY.md:161
msgid "Dynamic Error Types"
msgstr "Tipi di errori dinamici"

#: src/SUMMARY.md:162
msgid "Adding Context to Errors"
msgstr "Aggiungere contesto agli errori"

#: src/SUMMARY.md:163
msgid "Testing"
msgstr "Testare"

#: src/SUMMARY.md:164
msgid "Unit Tests"
msgstr "Test per unit√†"

#: src/SUMMARY.md:165
msgid "Test Modules"
msgstr "Moduli (Module) di Test"

#: src/SUMMARY.md:166
msgid "Documentation Tests"
msgstr "Test nella documentazione"

#: src/SUMMARY.md:167
msgid "Integration Tests"
msgstr "Test di integrazione"

#: src/SUMMARY.md:168
msgid "Useful crates"
msgstr "Crates utili"

#: src/SUMMARY.md:169
msgid "Unsafe Rust"
msgstr "Unsafe Rust"

#: src/SUMMARY.md:170
msgid "Dereferencing Raw Pointers"
msgstr "Dereferenziamento dei Puntatori (Pointers) Grezzi (Raw)"

#: src/SUMMARY.md:171
msgid "Mutable Static Variables"
msgstr "Variabili Statiche Mutabili"

#: src/SUMMARY.md:172
msgid "Unions"
msgstr "Unioni"

#: src/SUMMARY.md:173
msgid "Calling Unsafe Functions"
msgstr "Chiamare Funzioni Unsafe"

#: src/SUMMARY.md:174
msgid "Writing Unsafe Functions"
msgstr "Creare Funzioni Unsafe"

#: src/SUMMARY.md:175
msgid "Extern Functions"
msgstr "Funzioni Esterne (Extern)"

#: src/SUMMARY.md:176
msgid "Implementing Unsafe Traits"
msgstr "Implementare Unsafe Traits"

#: src/SUMMARY.md:178
msgid "Safe FFI Wrapper"
msgstr "Safe FFI Wrapper"

#: src/SUMMARY.md:181 src/SUMMARY.md:249
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:186
msgid "Setup"
msgstr "Setup"

#: src/SUMMARY.md:187
msgid "Build Rules"
msgstr "Regole (Rules) di Build"

#: src/SUMMARY.md:188
msgid "Binary"
msgstr "Binario"

#: src/SUMMARY.md:189
msgid "Library"
msgstr "Libreria (Library)"

#: src/SUMMARY.md:190
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:191
msgid "Interface"
msgstr "Interfaccia"

#: src/SUMMARY.md:192
msgid "Implementation"
msgstr "Implementazione"

#: src/SUMMARY.md:193
msgid "Server"
msgstr "Server"

#: src/SUMMARY.md:194
msgid "Deploy"
msgstr "Deploy"

#: src/SUMMARY.md:195
msgid "Client"
msgstr "Client"

#: src/SUMMARY.md:196
msgid "Changing API"
msgstr "Cambiare API"

#: src/SUMMARY.md:197 src/SUMMARY.md:240
msgid "Logging"
msgstr "Logging"

#: src/SUMMARY.md:198
msgid "Interoperability"
msgstr "Interoperabilit√†"

#: src/SUMMARY.md:199
msgid "With C"
msgstr "Con C"

#: src/SUMMARY.md:200
msgid "Calling C with Bindgen"
msgstr "Invocare C con Bindgen"

#: src/SUMMARY.md:201
msgid "Calling Rust from C"
msgstr "Invocare Rust da C"

#: src/SUMMARY.md:202
msgid "With C++"
msgstr "Con C++"

#: src/SUMMARY.md:203
msgid "With Java"
msgstr "Con Java"

#: src/SUMMARY.md:207
msgid "Bare Metal: Morning"
msgstr "Bare Metal: Mattino"

#: src/SUMMARY.md:212
msgid "no_std"
msgstr "no_std"

#: src/SUMMARY.md:213
msgid "A Minimal Example"
msgstr "Un Esempio Minimo"

#: src/SUMMARY.md:214
msgid "alloc"
msgstr "alloc"

#: src/SUMMARY.md:215
msgid "Microcontrollers"
msgstr "Microcontroller"

#: src/SUMMARY.md:216
msgid "Raw MMIO"
msgstr "Raw MMIO"

#: src/SUMMARY.md:217
msgid "PACs"
msgstr "PAC"

#: src/SUMMARY.md:218
msgid "HAL Crates"
msgstr "HAL Crates"

#: src/SUMMARY.md:219
msgid "Board Support Crates"
msgstr "Crate di supporto per Board"

#: src/SUMMARY.md:220
msgid "The Type State Pattern"
msgstr "Il modello (Pattern) di Type State"

#: src/SUMMARY.md:221
msgid "embedded-hal"
msgstr "embedded-hal"

#: src/SUMMARY.md:222
msgid "probe-rs, cargo-embed"
msgstr "probe-rs, cargo-embed"

#: src/SUMMARY.md:223
msgid "Debugging"
msgstr "Debugging"

#: src/SUMMARY.md:224 src/SUMMARY.md:242
msgid "Other Projects"
msgstr "Altri Progetti"

#: src/SUMMARY.md:226
msgid "Compass"
msgstr "Bussola"

#: src/SUMMARY.md:228
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: Pomeriggio"

#: src/SUMMARY.md:230
msgid "Application Processors"
msgstr "Processori di Applicazioni"

#: src/SUMMARY.md:231
msgid "Inline Assembly"
msgstr "Inline Assembly"

#: src/SUMMARY.md:232
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md:233
msgid "Let's Write a UART Driver"
msgstr "Scriviamo un driver UART"

#: src/SUMMARY.md:234
msgid "More Traits"
msgstr "Traits addizionali"

#: src/SUMMARY.md:235
msgid "A Better UART Driver"
msgstr "Un migliore driver UART"

#: src/SUMMARY.md:236
msgid "Bitflags"
msgstr "Bitflag"

#: src/SUMMARY.md:237
msgid "Multiple Registers"
msgstr "Registri multipli"

#: src/SUMMARY.md:238
msgid "Driver"
msgstr "Driver"

#: src/SUMMARY.md:239 src/SUMMARY.md:241
msgid "Using It"
msgstr "Usandolo"

#: src/SUMMARY.md:243
msgid "Useful Crates"
msgstr "Crates Utili"

#: src/SUMMARY.md:244
msgid "zerocopy"
msgstr "zerocopy"

#: src/SUMMARY.md:245
msgid "aarch64-paging"
msgstr "paginazione aarch64 (aarch64-paging)"

#: src/SUMMARY.md:246
msgid "buddy_system_allocator"
msgstr "buddy_system_allocator"

#: src/SUMMARY.md:247
msgid "tinyvec"
msgstr "tinyvec"

#: src/SUMMARY.md:248
msgid "spin"
msgstr "rotazione (spin)"

#: src/SUMMARY.md:250
msgid "vmbase"
msgstr "vmbase"

#: src/SUMMARY.md:252
msgid "RTC Driver"
msgstr "Driver RTC"

#: src/SUMMARY.md:255
msgid "Concurrency: Morning"
msgstr "Concurrenzy: Mattino"

#: src/SUMMARY.md:260
msgid "Threads"
msgstr "Threads"

#: src/SUMMARY.md:261
msgid "Scoped Threads"
msgstr "Thread con Scope (Scoped Threads)"

#: src/SUMMARY.md:262
msgid "Channels"
msgstr "Canali (Channels)"

#: src/SUMMARY.md:263
msgid "Unbounded Channels"
msgstr "Canali illimitati (Unbounded Channels)"

#: src/SUMMARY.md:264
msgid "Bounded Channels"
msgstr "Canali delimitati (Bounded Channels)"

#: src/SUMMARY.md:265
msgid "Send and Sync"
msgstr "Send e Sync"

#: src/SUMMARY.md:265
msgid "Send"
msgstr "Send (Inviare)"

#: src/SUMMARY.md:265
msgid "Sync"
msgstr "Sync (Sincronizzare)"

#: src/SUMMARY.md:268
msgid "Examples"
msgstr "Esempi"

#: src/SUMMARY.md:269
msgid "Shared State"
msgstr "Stato Condiviso"

#: src/SUMMARY.md:270
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:271
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:274 src/SUMMARY.md:294
msgid "Dining Philosophers"
msgstr "Filosofi a tavola"

#: src/SUMMARY.md:275
msgid "Multi-threaded Link Checker"
msgstr "Correttore di Link a Thread multipli"

#: src/SUMMARY.md:277
msgid "Concurrency: Afternoon"
msgstr "Giorno 1: Pomeriggio"

#: src/SUMMARY.md:279
msgid "Async Basics"
msgstr "Nozioni di base sulla programmazione Async (asincrona)"

#: src/SUMMARY.md:280
msgid "async/await"
msgstr "Async/await"

#: src/SUMMARY.md:281
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md:282
msgid "Runtimes"
msgstr "Esecutori"

#: src/SUMMARY.md:283
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md:284
msgid "Tasks"
msgstr "Compiti (Tasks)"

#: src/SUMMARY.md:285
msgid "Async Channels"
msgstr "Canali asincroni (Async Channels)"

#: src/SUMMARY.md:287
msgid "Join"
msgstr "Giunzione (Join)"

#: src/SUMMARY.md:288
msgid "Select"
msgstr "Selezione (Select)"

#: src/SUMMARY.md:289
msgid "Pitfalls"
msgstr "Insidie"

#: src/SUMMARY.md:290
msgid "Blocking the Executor"
msgstr "Blocco dell‚ÄôEsecutore"

#: src/SUMMARY.md:291
msgid "Pin"
msgstr "Spillo (Pin)"

#: src/SUMMARY.md:292
msgid "Async Traits"
msgstr "Trait asincroni (Async Trait)"

#: src/SUMMARY.md:295
msgid "Elevator Operations"
msgstr "# Operazioni dell‚ÄôAscensore"

#: src/SUMMARY.md:298
msgid "Final Words"
msgstr "Parole finali"

#: src/SUMMARY.md:302
msgid "Thanks!"
msgstr "Grazie!"

#: src/SUMMARY.md:303
msgid "Other Resources"
msgstr "Altre risorse"

#: src/SUMMARY.md:304
msgid "Credits"
msgstr "Crediti"

#: src/SUMMARY.md:307
msgid "Solutions"
msgstr "Soluzioni"

#: src/SUMMARY.md:312
msgid "Day 1 Morning"
msgstr "Giorno 1 Mattina"

#: src/SUMMARY.md:313
msgid "Day 1 Afternoon"
msgstr "Giorno 1 Pomeriggio"

#: src/SUMMARY.md:314
msgid "Day 2 Morning"
msgstr "Giorno 2 Mattina"

#: src/SUMMARY.md:315
msgid "Day 2 Afternoon"
msgstr "Giorno 2 Pomeriggio"

#: src/SUMMARY.md:316
msgid "Day 3 Morning"
msgstr "Giorno 3 Mattina"

#: src/SUMMARY.md:317
msgid "Day 3 Afternoon"
msgstr "Giorno 3 Pomeriggio"

#: src/SUMMARY.md:318
msgid "Bare Metal Rust Morning"
msgstr "Mattina su Bare Metal Rust"

#: src/SUMMARY.md:319
msgid "Bare Metal Rust Afternoon"
msgstr "Pomeriggio su Bare Metal Rust"

#: src/SUMMARY.md:320
msgid "Concurrency Morning"
msgstr "Mattina su Concorrenza"

#: src/SUMMARY.md:321
msgid "Concurrency Afternoon"
msgstr "Giorno 1: Pomeriggio"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust ü¶Ä"
msgstr "# Benvenuti a Comprehensive Rust ü¶Ä"

#: src/welcome.md:3
#, fuzzy
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/"
"build.yml?style=flat-square)](https://github.com/google/comprehensive-rust/actions/workflows/build."
"yml?query=branch%3Amain)"
msgstr ""
"[![Crea flusso di lavoro](https://img.shields.io/github/actions/workflow/status/google/"
"comprehensive-rust/build.yml?style=flat-square)](https://github.com /google/comprehensive-rust/"
"actions/workflows/build.yml)"

#: src/welcome.md:3
msgid "Build workflow"
msgstr "Crea flusso di lavoro"

#: src/welcome.md:3
#, fuzzy
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/"
"build.yml?style=flat-square)](https://github.com/google/comprehensive-rust/actions/workflows/build."
"yml?query=branch%3Amain)\n"
"[![GitHub contributors](https://img.shields.io/github/contributors/google/comprehensive-rust?"
"style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)"
msgstr ""
"[![Crea flusso di lavoro](https://img.shields.io/github/actions/workflow/status/google/"
"comprehensive-rust/build.yml?style=flat-square)](https://github.com /google/comprehensive-rust/"
"actions/workflows/build.yml)\n"
"[![Contributori di GitHub](https://img.shields.io/github/contributors/google/comprehensive-rust?"
"style=flat-square)](https://github.com/google/comprehensive-rust/graphs /contributori)"

#: src/welcome.md:4
msgid "GitHub contributors"
msgstr "Collaboratori di GitHub"

#: src/welcome.md:4
#, fuzzy
msgid ""
"[![GitHub contributors](https://img.shields.io/github/contributors/google/comprehensive-rust?"
"style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)\n"
"[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Contributori di GitHub](https://img.shields.io/github/contributors/google/comprehensive-rust?"
"style=flat-square)](https://github.com/google/comprehensive-rust/graphs /contributori)\n"
"[![Stelle di GitHub](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-"
"square)](https://github.com/google/comprehensive-rust/stargazers )"

#: src/welcome.md:5
msgid "GitHub stars"
msgstr "Stelle di GitHub"

#: src/welcome.md:5
#, fuzzy
msgid ""
"[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
"(https://github.com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Stelle di GitHub](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-"
"square)](https://github.com/google/comprehensive-rust/stargazers )"

#: src/welcome.md:7
#, fuzzy
msgid ""
"This is a three day Rust course developed by the Android team. The course covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like generics\n"
"and error handling. It also includes Android-specific content on the last day."
msgstr ""
"Questo √® un corso Rust di tre giorni sviluppato dal team Android. Il corso copre\n"
"l'intero spettro di Rust, dalla sintassi di base ad argomenti avanzati come i generici\n"
"e gestione degli errori. Include anche contenuti specifici per Android nell'ultimo giorno."

#: src/welcome.md:11
#, fuzzy
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know anything\n"
"about Rust and hope to:"
msgstr ""
"L'obiettivo del corso √® insegnarti Rust. Partiamo dal presupposto che tu non sappia nulla\n"
"su Rust e spero di:"

#: src/welcome.md:14
#, fuzzy
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* Fornire una comprensione completa della sintassi e del linguaggio di Rust.\n"
"* Consentono di modificare i programmi esistenti e scrivere nuovi programmi in Rust.\n"
"* Mostra i comuni idiomi di Rust."

#: src/welcome.md:18
#, fuzzy
msgid ""
"The first three days show you the fundamentals of Rust. Following this, you're\n"
"invited to dive into one or more spezialized topics:"
msgstr ""
"I primi tre giorni ti mostrano i fondamenti di Rust. A seguito di questo, sei\n"
"invitato ad approfondire uno o pi√π argomenti specialistici:"

#: src/welcome.md:21
#, fuzzy
msgid ""
"* [Android](android.md): a half-day course on using Rust for Android platform\n"
"  development (AOSP). This includes interoperability wtih C, C++, and Java.\n"
"* [Bare-metal](bare-metal.md): a full day class on using Rust for bare-metal\n"
"  (embedded) development. Both microcontrollers and application processors are\n"
"  covered.\n"
"* [Concurrency](concurrency.md): a full day class on concurrency in Rust. We\n"
"  cover both classical concurrency (preemptively scheduling using threads and\n"
"  mutextes) and async/await concurrency (cooperative multitasking using\n"
"  futures)."
msgstr ""
"* [Android](android.md): un corso di mezza giornata sull'utilizzo della piattaforma Rust per "
"Android\n"
"  sviluppo (AOSP). Ci√≤ include l'interoperabilit√† con C, C++ e Java.\n"
"* [Bare-metal](bare-metal.md): una lezione di un'intera giornata sull'utilizzo di Rust per bare-"
"metal\n"
"  sviluppo (incorporato). Lo sono sia i microcontrollori che i processori applicativi\n"
"  coperto.\n"
"* [Concurrency](concurrency.md): una lezione di un'intera giornata sulla concorrenza in Rust. Noi\n"
"  coprire sia la concorrenza classica (pianificazione preventiva utilizzando thread e\n"
"  mutextes) e async/await concurrency (multitasking cooperativo tramite\n"
"  futuri)."

#: src/welcome.md:32
msgid "## Non-Goals"
msgstr "## Non goal"

#: src/welcome.md:34
#, fuzzy
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few days.\n"
"Some non-goals of this course are:"
msgstr ""
"Rust √® un linguaggio vasto e non saremo in grado di coprirlo tutto in pochi giorni.\n"
"Alcuni non-obiettivi di questo corso sono:"

#: src/welcome.md:37
#, fuzzy
msgid ""
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* Scopri come sviluppare macro, per favore vedi [Capitolo 19.5 in Rust\n"
"  Libro](https://doc.rust-lang.org/book/ch19-06-macros.html) e [Rust by\n"
"  Esempio](https://doc.rust-lang.org/rust-by-example/macros.html) invece."

#: src/welcome.md:41
msgid "## Assumptions"
msgstr "## Ipotesi"

#: src/welcome.md:43
#, fuzzy
msgid ""
"The course assumes that you already know how to program. Rust is a statically\n"
"typed language and we will sometimes make comparisons with C and C++ to better\n"
"explain or contrast the Rust approach."
msgstr ""
"Il corso presuppone che tu sappia gi√† programmare. La ruggine √® staticamente\n"
"linguaggio digitato e talvolta faremo confronti migliori con C e C++\n"
"spiegare o contrastare l'approccio di Rust."

#: src/welcome.md:47
#, fuzzy
msgid ""
"If you know how to program in a dynamically typed language such as Python or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Se sai come programmare in un linguaggio tipizzato dinamicamente come Python o\n"
"JavaScript, allora sarai anche in grado di seguire bene."

#: src/welcome.md:50 src/cargo/rust-ecosystem.md:19 src/cargo/code-samples.md:22
#: src/cargo/running-locally.md:68 src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8 src/why-rust/modern.md:19
#: src/basic-syntax/scalar-types.md:19 src/basic-syntax/compound-types.md:28
#: src/basic-syntax/slices.md:18 src/basic-syntax/string-slices.md:25
#: src/basic-syntax/functions.md:33 src/basic-syntax/rustdoc.md:22 src/basic-syntax/methods.md:32
#: src/basic-syntax/functions-interlude.md:25 src/exercises/day-1/morning.md:9
#: src/exercises/day-1/for-loops.md:90 src/basic-syntax/variables.md:15
#: src/basic-syntax/type-inference.md:24 src/basic-syntax/static-and-const.md:46
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27 src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/exercises/day-1/book-library.md:100
#: src/structs/tuple-structs.md:35 src/structs/field-shorthand.md:25 src/enums.md:31
#: src/enums/variant-payloads.md:33 src/enums/sizes.md:27 src/methods.md:28
#: src/methods/receiver.md:23 src/methods/example.md:44 src/pattern-matching.md:23
#: src/pattern-matching/destructuring-enums.md:33 src/pattern-matching/destructuring-structs.md:21
#: src/pattern-matching/destructuring-arrays.md:19 src/pattern-matching/match-guards.md:20
#: src/exercises/day-2/morning.md:9 src/exercises/day-2/points-polygons.md:115
#: src/control-flow/blocks.md:40 src/control-flow/if-expressions.md:33
#: src/control-flow/if-let-expressions.md:21 src/control-flow/while-let-expressions.md:24
#: src/control-flow/for-expressions.md:23 src/control-flow/loop-expressions.md:25
#: src/control-flow/match-expressions.md:26 src/std.md:23 src/std/option-result.md:16
#: src/std/string.md:28 src/std/vec.md:35 src/std/hashmap.md:36 src/std/box.md:32
#: src/std/box-recursive.md:31 src/std/rc.md:29 src/modules.md:26 src/modules/visibility.md:37
#: src/modules/filesystem.md:42 src/exercises/day-2/afternoon.md:5 src/generics/data-types.md:19
#: src/generics/methods.md:23 src/traits/trait-objects.md:70 src/traits/default-methods.md:30
#: src/traits/trait-bounds.md:33 src/traits/impl-trait.md:21 src/traits/iterator.md:30
#: src/traits/from-iterator.md:15 src/traits/from-into.md:27 src/traits/drop.md:32
#: src/traits/default.md:38 src/traits/operators.md:24 src/traits/closures.md:23
#: src/exercises/day-3/morning.md:5 src/error-handling/result.md:25
#: src/error-handling/try-operator.md:46 src/error-handling/converting-error-types-example.md:48
#: src/error-handling/deriving-error-enums.md:37 src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26 src/unsafe/raw-pointers.md:25
#: src/unsafe/mutable-static-variables.md:30 src/unsafe/unions.md:19
#: src/unsafe/writing-unsafe-functions.md:31 src/unsafe/extern-functions.md:19
#: src/unsafe/unsafe-traits.md:28 src/exercises/day-3/afternoon.md:5
#: src/android/interoperability/with-c/rust.md:81 src/exercises/android/morning.md:10
#: src/bare-metal/minimal.md:15 src/bare-metal/alloc.md:37 src/bare-metal/microcontrollers.md:23
#: src/bare-metal/microcontrollers/mmio.md:62 src/bare-metal/microcontrollers/pacs.md:47
#: src/bare-metal/microcontrollers/hals.md:37 src/bare-metal/microcontrollers/board-support.md:26
#: src/bare-metal/microcontrollers/type-state.md:30
#: src/bare-metal/microcontrollers/embedded-hal.md:17 src/bare-metal/microcontrollers/probe-rs.md:14
#: src/bare-metal/microcontrollers/debugging.md:25
#: src/bare-metal/microcontrollers/other-projects.md:16 src/exercises/bare-metal/morning.md:5
#: src/bare-metal/aps.md:7 src/bare-metal/aps/inline-assembly.md:41 src/bare-metal/aps/mmio.md:7
#: src/bare-metal/aps/uart.md:53 src/bare-metal/aps/uart/traits.md:22
#: src/bare-metal/aps/better-uart.md:24 src/bare-metal/aps/better-uart/bitflags.md:35
#: src/bare-metal/aps/better-uart/registers.md:39 src/bare-metal/aps/better-uart/driver.md:62
#: src/bare-metal/aps/better-uart/using.md:49 src/bare-metal/aps/logging.md:48
#: src/bare-metal/aps/logging/using.md:44 src/bare-metal/useful-crates/zerocopy.md:43
#: src/bare-metal/useful-crates/aarch64-paging.md:26
#: src/bare-metal/useful-crates/buddy_system_allocator.md:24
#: src/bare-metal/useful-crates/tinyvec.md:21 src/bare-metal/useful-crates/spin.md:21
#: src/bare-metal/android/vmbase.md:19 src/exercises/bare-metal/afternoon.md:5
#: src/concurrency/threads.md:28 src/concurrency/scoped-threads.md:35 src/concurrency/channels.md:25
#: src/concurrency/send-sync.md:18 src/concurrency/send-sync/send.md:11
#: src/concurrency/send-sync/sync.md:12 src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/mutex.md:29 src/concurrency/shared_state/example.md:21
#: src/exercises/concurrency/morning.md:10 src/async/async-await.md:23 src/async/futures.md:30
#: src/async/runtimes.md:18 src/async/runtimes/tokio.md:31 src/async/tasks.md:51
#: src/async/channels.md:33 src/async/control-flow/join.md:34 src/async/control-flow/select.md:59
#: src/async/pitfalls/blocking-executor.md:27 src/async/pitfalls/pin.md:66
#: src/exercises/concurrency/afternoon.md:11
#: src/exercises/concurrency/dining-philosophers-async.md:75
#, fuzzy
msgid "<details>"
msgstr "<dettagli>"

#: src/welcome.md:52
#, fuzzy
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"Questo √® un esempio di _nota del relatore_. Useremo questi per aggiungere ulteriori\n"
"informazioni alle diapositive. Questi potrebbero essere punti chiave che l'istruttore dovrebbe\n"
"copertina cos√¨ come le risposte alle domande tipiche che sorgono in classe."

#: src/welcome.md:56 src/cargo/rust-ecosystem.md:67 src/cargo/code-samples.md:35
#: src/cargo/running-locally.md:74 src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:40 src/hello-world/small-example.md:44 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22 src/why-rust/modern.md:66
#: src/basic-syntax/scalar-types.md:43 src/basic-syntax/compound-types.md:62
#: src/basic-syntax/references.md:28 src/basic-syntax/slices.md:36
#: src/basic-syntax/string-slices.md:44 src/basic-syntax/functions.md:41
#: src/basic-syntax/rustdoc.md:33 src/basic-syntax/methods.md:45
#: src/basic-syntax/functions-interlude.md:30 src/exercises/day-1/morning.md:28
#: src/exercises/day-1/for-loops.md:95 src/basic-syntax/variables.md:20
#: src/basic-syntax/type-inference.md:48 src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/copy-clone.md:51
#: src/ownership/borrowing.md:51 src/ownership/shared-unique-borrows.md:29
#: src/ownership/lifetimes-function-calls.md:60 src/ownership/lifetimes-data-structures.md:30
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:104 src/structs.md:41
#: src/structs/tuple-structs.md:43 src/structs/field-shorthand.md:72 src/enums.md:41
#: src/enums/variant-payloads.md:45 src/enums/sizes.md:155 src/methods.md:41
#: src/methods/receiver.md:29 src/methods/example.md:53 src/pattern-matching.md:35
#: src/pattern-matching/destructuring-enums.md:39 src/pattern-matching/destructuring-structs.md:29
#: src/pattern-matching/destructuring-arrays.md:46 src/pattern-matching/match-guards.md:28
#: src/exercises/day-2/morning.md:15 src/exercises/day-2/points-polygons.md:125
#: src/control-flow/blocks.md:46 src/control-flow/if-expressions.md:37
#: src/control-flow/if-let-expressions.md:41 src/control-flow/while-let-expressions.md:29
#: src/control-flow/for-expressions.md:30 src/control-flow/loop-expressions.md:32
#: src/control-flow/match-expressions.md:33 src/std.md:31 src/std/option-result.md:25
#: src/std/string.md:42 src/std/vec.md:49 src/std/hashmap.md:66 src/std/box.md:39
#: src/std/box-recursive.md:41 src/std/rc.md:69 src/modules.md:32 src/modules/visibility.md:48
#: src/modules/filesystem.md:71 src/exercises/day-2/afternoon.md:11 src/generics/data-types.md:25
#: src/generics/methods.md:31 src/traits/trait-objects.md:83 src/traits/default-methods.md:41
#: src/traits/trait-bounds.md:50 src/traits/impl-trait.md:44 src/traits/iterator.md:42
#: src/traits/from-iterator.md:26 src/traits/from-into.md:33 src/traits/drop.md:42
#: src/traits/default.md:47 src/traits/operators.md:38 src/traits/closures.md:38
#: src/exercises/day-3/morning.md:11 src/error-handling/result.md:33
#: src/error-handling/try-operator.md:53 src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45 src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32 src/unsafe/raw-pointers.md:43
#: src/unsafe/mutable-static-variables.md:35 src/unsafe/unions.md:28
#: src/unsafe/writing-unsafe-functions.md:38 src/unsafe/extern-functions.md:28
#: src/unsafe/unsafe-traits.md:37 src/exercises/day-3/afternoon.md:11
#: src/android/interoperability/with-c/rust.md:86 src/exercises/android/morning.md:15
#: src/bare-metal/no_std.md:65 src/bare-metal/minimal.md:26 src/bare-metal/alloc.md:49
#: src/bare-metal/microcontrollers.md:29 src/bare-metal/microcontrollers/mmio.md:72
#: src/bare-metal/microcontrollers/pacs.md:65 src/bare-metal/microcontrollers/hals.md:49
#: src/bare-metal/microcontrollers/board-support.md:40
#: src/bare-metal/microcontrollers/type-state.md:43
#: src/bare-metal/microcontrollers/embedded-hal.md:23 src/bare-metal/microcontrollers/probe-rs.md:29
#: src/bare-metal/microcontrollers/debugging.md:38
#: src/bare-metal/microcontrollers/other-projects.md:26 src/exercises/bare-metal/morning.md:11
#: src/bare-metal/aps.md:15 src/bare-metal/aps/inline-assembly.md:58 src/bare-metal/aps/mmio.md:17
#: src/bare-metal/aps/uart/traits.md:27 src/bare-metal/aps/better-uart.md:28
#: src/bare-metal/aps/better-uart/bitflags.md:40 src/bare-metal/aps/better-uart/registers.md:46
#: src/bare-metal/aps/better-uart/driver.md:67 src/bare-metal/aps/better-uart/using.md:55
#: src/bare-metal/aps/logging.md:52 src/bare-metal/aps/logging/using.md:49
#: src/bare-metal/useful-crates/zerocopy.md:53 src/bare-metal/useful-crates/aarch64-paging.md:33
#: src/bare-metal/useful-crates/buddy_system_allocator.md:30
#: src/bare-metal/useful-crates/tinyvec.md:26 src/bare-metal/useful-crates/spin.md:30
#: src/bare-metal/android/vmbase.md:25 src/exercises/bare-metal/afternoon.md:11
#: src/concurrency/threads.md:45 src/concurrency/scoped-threads.md:40 src/concurrency/channels.md:32
#: src/concurrency/send-sync.md:23 src/concurrency/send-sync/send.md:16
#: src/concurrency/send-sync/sync.md:18 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/mutex.md:45 src/concurrency/shared_state/example.md:56
#: src/exercises/concurrency/morning.md:16 src/async/async-await.md:48 src/async/futures.md:45
#: src/async/runtimes.md:29 src/async/runtimes/tokio.md:49 src/async/tasks.md:64
#: src/async/channels.md:49 src/async/control-flow/join.md:50 src/async/control-flow/select.md:77
#: src/async/pitfalls/blocking-executor.md:50 src/async/pitfalls/pin.md:112
#: src/async/pitfalls/async-traits.md:63 src/exercises/concurrency/afternoon.md:17
#: src/exercises/concurrency/dining-philosophers-async.md:79
#, fuzzy
msgid "</details>"
msgstr "</dettagli>"

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# Esecuzione del corso"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
#, fuzzy
msgid "> This page is for the course instructor."
msgstr "> Questa pagina √® per l'istruttore del corso."

#: src/running-the-course.md:5
#, fuzzy
msgid ""
"Here is a bit of background information about how we've been running the course\n"
"internally at Google."
msgstr ""
"Ecco alcune informazioni di base su come abbiamo condotto il corso\n"
"internamente a Google."

#: src/running-the-course.md:8
msgid "Before you run the course, you will want to:"
msgstr "Prima di eseguire il corso, vorrai:"

#: src/running-the-course.md:10
#, fuzzy
msgid ""
"1. Make yourself familiar with the course material. We've included speaker notes\n"
"   to help highlight the key points (please help us by contributing more speaker\n"
"   notes!). When presenting, you should make sure to open the speaker notes in a\n"
"   popup (click the link with a little arrow next to \"Speaker Notes\"). This way\n"
"   you have a clean screen to present to the class.\n"
"\n"
"1. Decide on the dates. Since the course takes at least three full days, we recommend that you\n"
"   schedule the days over two weeks. Course participants have said that\n"
"   they find it helpful to have a gap in the course since it helps them process\n"
"   all the information we give them.\n"
"\n"
"1. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-25 people. That's small enough that people are comfortable\n"
"   asking questions --- it's also small enough that one instructor will have\n"
"   time to answer the questions. Make sure the room has _desks_ for yourself and for the\n"
"   students: you will all need to be able to sit and work with your laptops.\n"
"   In particular, you will be doing a lot of live-coding as an instructor, so a lectern won't\n"
"   be very helpful for you.\n"
"\n"
"1. On the day of your course, show up to the room a little early to set things\n"
"   up. We recommend presenting directly using `mdbook serve` running on your\n"
"   laptop (see the [installation instructions][3]). This ensures optimal performance with no lag "
"as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them.\n"
"\n"
"1. Let people solve the exercises by themselves or in small groups.\n"
"   We typically spend 30-45 minutes on exercises in the morning and in the afternoon (including "
"time to review the solutions).\n"
"   Make sure to\n"
"   ask people if they're stuck or if there is anything you can help with. When\n"
"   you see that several people have the same problem, call it out to the class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"1. Acquisisci familiarit√† con il materiale del corso. Abbiamo incluso le note del relatore\n"
"   per aiutare a evidenziare i punti chiave (per favore aiutateci contribuendo con pi√π relatori\n"
"   Appunti!). Durante la presentazione, assicurati di aprire le note del relatore in formato a\n"
"   popup (fare clic sul collegamento con una piccola freccia accanto a \"Note del relatore\"). Da "
"questa parte\n"
"   hai uno schermo pulito da presentare alla classe.\n"
"\n"
"1. Seleziona il tuo argomento per il pomeriggio del quarto giorno. Questo pu√≤ essere basato su\n"
"   il pubblico che ti aspetti o sulla tua esperienza.\n"
"\n"
"1. Decidi le date. Poich√© il corso √® grande, ti consigliamo di farlo\n"
"   programmare i giorni su due settimane. Lo hanno detto i partecipanti al corso\n"
"   trovano utile avere una pausa nel corso poich√© li aiuta a elaborare\n"
"   tutte le informazioni che diamo loro.\n"
"\n"
"1. Trova una stanza abbastanza grande per i tuoi partecipanti di persona. Consigliamo un\n"
"   dimensione della classe di 15-20 persone. √à abbastanza piccolo da permettere alle persone di "
"sentirsi a proprio agio\n"
"   fare domande --- √® anche abbastanza piccolo che un istruttore avr√†\n"
"   tempo per rispondere alle domande. Assicurati che la stanza abbia _scrivanie_ per te e per il\n"
"   studenti: dovrete essere tutti in grado di sedervi e lavorare con i vostri laptop.\n"
"   In particolare, eseguirai molto codice dal vivo come istruttore, quindi un leggio no\n"
"   essere molto utile per te.\n"
"\n"
"1. Il giorno del corso, presentati in aula un po' prima per sistemare le cose\n"
"   su. Ti consigliamo di presentare direttamente utilizzando `mdbook serve` in esecuzione sul tuo\n"
"   laptop (vedere le [istruzioni di installazione][3]). Ci√≤ garantisce prestazioni ottimali senza "
"ritardi quando si cambiano le pagine.\n"
"   L'uso del tuo laptop ti consentir√† anche di correggere errori di battitura come te o il corso\n"
"   i partecipanti li individuano.\n"
"\n"
"1. Lascia che le persone risolvano gli esercizi da sole o in piccoli gruppi. Assicurati che\n"
"   chiedi alle persone se sono bloccate o se c'√® qualcosa in cui puoi aiutarle. Quando\n"
"   vedi che diverse persone hanno lo stesso problema, segnalalo alla classe\n"
"   e offrire una soluzione, ad esempio mostrando alle persone dove trovare le informazioni "
"pertinenti\n"
"   informazioni nella libreria standard."

#: src/running-the-course.md:43
#, fuzzy
msgid ""
"That is all, good luck running the course! We hope it will be as much fun for\n"
"you as it has been for us!"
msgstr ""
"Questo √® tutto, buona fortuna con il corso! Speriamo che sar√† altrettanto divertente per\n"
"te come lo √® stato per noi!"

#: src/running-the-course.md:46
#, fuzzy
msgid ""
"Please [provide feedback][1] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][2]!"
msgstr ""
"Si prega di [fornire feedback][1] in seguito in modo che possiamo continuare a migliorare il\n"
"corso. Ci piacerebbe sapere cosa ha funzionato bene per te e cosa si pu√≤ fare\n"
"Meglio. Anche i tuoi studenti sono i benvenuti a [inviarci feedback][2]!"

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# Struttura del corso"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "Il corso √® veloce e copre un sacco di terreno:"

#: src/running-the-course/course-structure.md:7
#, fuzzy
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust."
msgstr ""
"* Giorno 1: Basic Rust, propriet√† e controllo del prestito.\n"
"* Giorno 2: tipi di dati composti, pattern matching, libreria standard.\n"
"* Giorno 3: Tratti e generici, gestione degli errori, test, Rust non sicuro."

#: src/running-the-course/course-structure.md:11
msgid "## Deep Dives"
msgstr "## Immersioni profonde"

#: src/running-the-course/course-structure.md:13
#, fuzzy
msgid ""
"In addition to the 3-day class on Rust Fundamentals, we cover some more\n"
"specialized topics:"
msgstr ""
"Oltre alla lezione di 3 giorni sui fondamenti della ruggine, ne copriamo altri\n"
"argomenti specialistici:"

#: src/running-the-course/course-structure.md:16
msgid "### Android"
msgstr "### Android"

#: src/running-the-course/course-structure.md:18
#, fuzzy
msgid ""
"The [Android Deep Dive](../android.md) is a half-day course on using Rust for\n"
"Android platform development. This includes interoperability wtih C, C++, and\n"
"Java."
msgstr ""
"L'[Android Deep Dive](../android.md) √® un corso di mezza giornata sull'utilizzo di Rust per\n"
"Sviluppo della piattaforma Android. Ci√≤ include l'interoperabilit√† con C, C++ e\n"
"Giava."

#: src/running-the-course/course-structure.md:22
#, fuzzy
msgid ""
"You will need an [AOSP checkout][1]. Make a checkout of the [course\n"
"repository][2] on the same machine and move the `src/android/` directory into\n"
"the root of your AOSP checkout. This will ensure that the Android build system\n"
"sees the `Android.bp` files in `src/android/`."
msgstr ""
"Avrai bisogno di un [checkout AOSP][1]. Fai un checkout del [corso\n"
"repository][2] sulla stessa macchina e sposta la directory `src/android/` in\n"
"la radice del tuo checkout AOSP. Ci√≤ garantir√† che il sistema di compilazione Android\n"
"vede i file `Android.bp` in `src/android/`."

#: src/running-the-course/course-structure.md:27
#, fuzzy
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build all\n"
"Android examples using `src/android/build_all.sh`. Read the script to see the\n"
"commands it runs and make sure they work when you run them by hand."
msgstr ""
"Assicurati che `adb sync` funzioni con il tuo emulatore o dispositivo reale e precompila tutto\n"
"Esempi di Android che utilizzano `src/android/build_all.sh`. Leggi lo script per vedere il file\n"
"comandi che esegue e assicurati che funzionino quando li esegui a mano."

#: src/running-the-course/course-structure.md:34
msgid "### Bare-Metal"
msgstr "### Bare-Metal"

#: src/running-the-course/course-structure.md:36
#, fuzzy
msgid ""
"The [Bare-Metal Deep Dive](../bare-metal.md): a full day class on using Rust for\n"
"bare-metal (embedded) development. Both microcontrollers and application\n"
"processors are covered."
msgstr ""
"The [Bare-Metal Deep Dive](../bare-metal.md): una lezione di un'intera giornata sull'uso di Rust "
"per\n"
"sviluppo bare metal (incorporato). Sia i microcontrollori che l'applicazione\n"
"i processori sono coperti."

#: src/running-the-course/course-structure.md:40
#, fuzzy
msgid ""
"For the microcontroller part, you will need to buy the [BBC\n"
"micro:bit](https://microbit.org/) v2 development board ahead of time. Everybody\n"
"will need to install a number of packages as described on the [welcome\n"
"page](../bare-metal.md)."
msgstr ""
"Per la parte del microcontrollore, dovrai acquistare il [BBC\n"
"micro:bit](https://microbit.org/) scheda di sviluppo v2 in anticipo. Tutti\n"
"dovr√† installare un certo numero di pacchetti come descritto nel file [welcome\n"
"page](../bare-metal.md)."

#: src/running-the-course/course-structure.md:45
msgid "### Concurrency"
msgstr "### Concorrenza"

#: src/running-the-course/course-structure.md:47
#, fuzzy
msgid ""
"The [Concurrency Deep Dive](../concurrency.md) is a full day class on classical\n"
"as well as `async`/`await` concurrency."
msgstr ""
"Il [Concurrency Deep Dive](../concurrency.md) √® un corso di un'intera giornata sulla musica "
"classica\n"
"cos√¨ come la concorrenza `async`/`await`."

#: src/running-the-course/course-structure.md:50
#, fuzzy
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready to\n"
"go. You can then copy/paste the examples into `src/main.rs` to experiment with\n"
"them:"
msgstr ""
"Avrai bisogno di una nuova configurazione della cassa e delle dipendenze scaricate e pronte per\n"
"andare. Puoi quindi copiare/incollare gli esempi in `src/main.rs` per sperimentare\n"
"loro:"

#: src/running-the-course/course-structure.md:54
msgid ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio --features full\n"
"cargo run\n"
"```"
msgstr ""

#: src/running-the-course/course-structure.md:61
msgid "## Format"
msgstr "## Formato"

#: src/running-the-course/course-structure.md:63
#, fuzzy
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr ""
"Il corso √® pensato per essere molto interattivo e si consiglia di lasciare il\n"
"le domande guidano l'esplorazione di Rust!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# Tasti rapidi"

#: src/running-the-course/keyboard-shortcuts.md:3
#, fuzzy
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Ci sono diverse utili scorciatoie da tastiera in mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
#, fuzzy
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Freccia-sinistra</kbd>: passa alla pagina precedente.\n"
"* <kbd>Freccia-destra</kbd>: passa alla pagina successiva.\n"
"* <kbd>Ctrl + Invio</kbd>: esegue l'esempio di codice attivo.\n"
"* <kbd>s</kbd>: attiva la barra di ricerca."

#: src/running-the-course/translations.md:1
msgid "# Translations"
msgstr "# Traduzioni"

#: src/running-the-course/translations.md:3
#, fuzzy
msgid ""
"The course has been translated into other languages by a set of wonderful\n"
"volunteers:"
msgstr ""
"Il corso √® stato tradotto in altre lingue da una serie di meravigliosi\n"
"volontari:"

#: src/running-the-course/translations.md:6
#, fuzzy
msgid ""
"* [Brazilian Portuguese][pt-BR] by [@rastringer] and [@hugojacob].\n"
"* [Korean][ko] by [@keispace], [@jiyongp] and [@jooyunghan]."
msgstr ""
"* [Portoghese brasiliano][pt-BR] di [@rastringer] e [@hugojacob].\n"
"* [Coreano][ko] di [@keispace], [@jiyongp] e [@jooyunghan]."

#: src/running-the-course/translations.md:9
#, fuzzy
msgid "Use the language picker in the top-right corner to switch between languages."
msgstr "Usa il selettore di lingua nell'angolo in alto a destra per passare da una lingua all'altra."

#: src/running-the-course/translations.md:11
#, fuzzy
msgid ""
"If you want to help with this effort, please see [our instructions] for how to\n"
"get going. Translations are coordinated on the [issue tracker]."
msgstr ""
"Se vuoi aiutare con questo sforzo, consulta [le nostre istruzioni] per sapere come farlo\n"
"andare avanti. Le traduzioni sono coordinate su [issue tracker]."

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# Utilizzo di Cargo"

#: src/cargo.md:3
#, fuzzy
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc.rust-lang.org/cargo/), "
"the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want to\n"
"give a brief overview of what Cargo is and how it fits into the wider ecosystem\n"
"and how it fits into this training."
msgstr ""
"Quando inizi a leggere di Rust, incontrerai presto [Cargo](https://doc.rust-lang.org/cargo/), lo "
"strumento standard\n"
"utilizzato nell'ecosistema Rust per creare ed eseguire applicazioni Rust. Qui vogliamo\n"
"fornire una breve panoramica di cos'√® Cargo e di come si inserisce nell'ecosistema pi√π ampio\n"
"e come si inserisce in questa formazione."

#: src/cargo.md:8
msgid "## Installation"
msgstr "## Installazione"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "### Rustup (consigliato)"

#: src/cargo.md:12
#, fuzzy
msgid ""
"You can follow the instructions to install cargo and rust compiler, among other standard ecosystem "
"tools with the [rustup][3] tool, which is maintained by the Rust Foundation."
msgstr ""
"Puoi seguire le istruzioni per installare il compilatore cargo e rust, tra gli altri strumenti "
"standard dell'ecosistema con lo strumento [rustup][3], gestito dalla Rust Foundation."

#: src/cargo.md:14
#, fuzzy
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line utility that you can use "
"to install/switch toolchains, setup cross compilation, etc."
msgstr ""
"Insieme a cargo e rustc, Rustup si installer√† come un'utilit√† della riga di comando che puoi "
"utilizzare per installare/cambiare toolchain, configurare la compilazione incrociata, ecc."

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### Gestori di pacchetti"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
#, fuzzy
msgid "On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust formatter][6] with"
msgstr "Su Debian/Ubuntu, puoi installare Cargo, il sorgente Rust e il [Rust formatter][6] con"

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""

#: src/cargo.md:26
#, fuzzy
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"Ci√≤ consentir√† a [rust-analyzer][1] di saltare alle definizioni. Si consiglia di utilizzare\n"
"[VS Code][2] per modificare il codice (ma qualsiasi editor compatibile con LSP funziona)."

#: src/cargo.md:29
#, fuzzy
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do their own analysis but "
"have their own tradeoffs. If you prefer them, you can install the [Rust Plugin][5]. Please take "
"note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"Ad alcune persone piace anche usare la famiglia di IDE [JetBrains][4], che eseguono le proprie "
"analisi ma hanno i propri compromessi. Se li preferisci, puoi installare il [Rust Plugin][5]. "
"Tieni presente che a partire da gennaio 2023 il debug funziona solo sulla versione CLion della "
"suite JetBrains IDEA."

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# L'ecosistema di Rust"

#: src/cargo/rust-ecosystem.md:3
#, fuzzy
msgid "The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "L'ecosistema Rust √® costituito da una serie di strumenti, di cui i principali sono:"

#: src/cargo/rust-ecosystem.md:5
#, fuzzy
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and other\n"
"  intermediate formats.\n"
"\n"
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests.\n"
"\n"
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and `rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustc`: il compilatore Rust che trasforma i file `.rs` in binari e altro\n"
"  formati intermedi.\n"
"\n"
"* `cargo`: il gestore delle dipendenze di Rust e lo strumento di compilazione. Il carico sa come\n"
"  scarica le dipendenze ospitate su <https://crates.io> e le passer√† a\n"
"  `rustc` quando costruisci il tuo progetto. Cargo include anche un test integrato\n"
"  runner che viene utilizzato per eseguire unit test.\n"
"\n"
"* `rustup`: il programma di installazione e aggiornamento della toolchain di Rust. Questo "
"strumento √® utilizzato per\n"
"  installare e aggiornare `rustc` e `cargo` quando vengono rilasciate nuove versioni di Rust.\n"
"  Inoltre, `rustup` pu√≤ anche scaricare la documentazione per lo standard\n"
"  biblioteca. Puoi avere pi√π versioni di Rust installate contemporaneamente e `rustup`\n"
"  ti permetter√† di passare da uno all'altro secondo necessit√†."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25 src/hello-world/small-example.md:27
#: src/why-rust/runtime.md:10 src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/pattern-matching/destructuring-enums.md:35 src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:50 src/concurrency/threads.md:30
#: src/async/async-await.md:25
msgid "Key points:"
msgstr "Punti chiave:"

#: src/cargo/rust-ecosystem.md:23
#, fuzzy
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality.\n"
"\n"
"* There are three release channels: \"stable\", \"beta\", and \"nightly\".\n"
"\n"
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks.\n"
"\n"
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018.\n"
"\n"
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language.\n"
"\n"
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file.\n"
"\n"
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions.\n"
"\n"
"  * Mention that it is quite rare to ever use the compiler directly not through `cargo` (most "
"users never do).\n"
"\n"
"  * It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  "
"It is capable of many advanced features including but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as [cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"* Rust ha un programma di rilascio rapido con una nuova versione in uscita\n"
"  ogni sei settimane. Le nuove versioni mantengono la retrocompatibilit√† con\n"
"  vecchie versioni --- in pi√π abilitano nuove funzionalit√†.\n"
"\n"
"* Esistono tre canali di rilascio: \"stable\", \"beta\" e \"nightly\".\n"
"\n"
"* Le nuove funzionalit√† vengono testate su \"nightly\", \"beta\" √® ci√≤ che diventa\n"
"  \"stabile\" ogni sei settimane.\n"
"\n"
"* Rust ha anche [edizioni]: l'edizione attuale √® Rust 2021. Precedente\n"
"  le edizioni erano Rust 2015 e Rust 2018.\n"
"\n"
"  * Le edizioni possono apportare modifiche incompatibili con le versioni precedenti\n"
"    la lingua.\n"
"\n"
"  * Per evitare di violare il codice, le edizioni sono opt-in: selezioni il file\n"
"    edizione per la tua cassa tramite il file `Cargo.toml`.\n"
"\n"
"  * Per evitare di dividere l'ecosistema, i compilatori di Rust possono mescolare il codice\n"
"    scritto per diverse edizioni.\n"
"\n"
"  * Menziona che √® abbastanza raro usare il compilatore direttamente non attraverso `cargo` (la "
"maggior parte degli utenti non lo fa mai).\n"
"\n"
"  * Potrebbe valere la pena accennare al fatto che Cargo stesso √® uno strumento estremamente "
"potente e completo. √à in grado di offrire molte funzionalit√† avanzate, tra cui, a titolo "
"esemplificativo ma non esaustivo:\n"
"      * Struttura del progetto/pacchetto\n"
"      * [aree di lavoro]\n"
"      * Dipendenze di sviluppo e gestione/memorizzazione nella cache delle dipendenze di runtime\n"
"      * [costruisci script]\n"
"      * [installazione globale]\n"
"      * √à anche estensibile anche con plug-in di comandi secondari (come [cargo clippy]).\n"
"  * Leggi di pi√π dal [libro ufficiale dei carichi]"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# Esempi di codice in questo Corso"

#: src/cargo/code-samples.md:3
#, fuzzy
msgid ""
"For this training, we will mostly explore the Rust language through examples\n"
"which can be executed through your browser. This makes the setup much easier and\n"
"ensures a consistent experience for everyone."
msgstr ""
"Per questa formazione, esploreremo principalmente il linguaggio Rust attraverso esempi\n"
"che pu√≤ essere eseguito tramite il tuo browser. Questo rende la configurazione molto pi√π semplice "
"e\n"
"garantisce un'esperienza coerente per tutti."

#: src/cargo/code-samples.md:7
#, fuzzy
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do the\n"
"exercises. On the last day, we will do a larger exercise which shows you how to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"L'installazione di Cargo √® ancora incoraggiata: ti render√† pi√π facile fare il\n"
"esercizi. L'ultimo giorno faremo un esercizio pi√π ampio che ti mostrer√† come farlo\n"
"lavora con le dipendenze e per questo hai bisogno di Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "I blocchi di codice in questo corso sono completamente interattivi:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""

#: src/cargo/code-samples.md:19
#, fuzzy
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the\n"
"text box."
msgstr ""
"Puoi usare <kbd>Ctrl + Invio</kbd> per eseguire il codice quando il focus √® in\n"
"casella di testo."

#: src/cargo/code-samples.md:24
#, fuzzy
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr ""
"La maggior parte degli esempi di codice sono modificabili come mostrato sopra. Alcuni esempi di "
"codice\n"
"non sono modificabili per vari motivi:"

#: src/cargo/code-samples.md:27
#, fuzzy
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests.\n"
"\n"
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* I playground incorporati non possono eseguire unit test. Copia e incolla il file\n"
"  code e aprilo nel Playground reale per dimostrare i test unitari.\n"
"\n"
"* I playground incorporati perdono il loro stato nel momento in cui navighi\n"
"  via dalla pagina! Questo √® il motivo per cui gli studenti dovrebbero\n"
"  risolvere gli esercizi utilizzando un'installazione locale di Rust o tramite il\n"
"  Terreno di gioco."

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# Esecuzione del codice in locale con Cargo"

#: src/cargo/running-locally.md:3
#, fuzzy
msgid ""
"If you want to experiment with the code on your own system, then you will need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"Se vuoi sperimentare il codice sul tuo sistema, avrai bisogno di\n"
"per installare prima Rust. Fallo seguendo le [istruzioni nel file Rust\n"
"Libro][1]. Questo dovrebbe darti un `rustc` e un `cargo` funzionanti. Al tempo di\n"
"scrivendo, l'ultima versione stabile di Rust ha questi numeri di versione:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:15
#, fuzzy
msgid ""
"With this is in place, then follow these steps to build a Rust binary from one\n"
"of the examples in this training:"
msgstr ""
"Con questo √® a posto, segui questi passaggi per creare un binario Rust da uno\n"
"degli esempi in questa formazione:"

#: src/cargo/running-locally.md:18
msgid ""
"1. Click the \"Copy to clipboard\" button on the example you want to copy.\n"
"\n"
"2. Use `cargo new exercise` to create a new `exercise/` directory for your code:\n"
"\n"
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```\n"
"\n"
"3. Navigate into `exercise/` and use `cargo run` to build and run your binary:\n"
"\n"
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```\n"
"\n"
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look like\n"
"\n"
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```\n"
"\n"
"5. Use `cargo run` to build and run your updated binary:\n"
"\n"
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```\n"
"\n"
"6. Use `cargo check` to quickly check your project for errors, use `cargo build`\n"
"   to compile it without running it. You will find the output in `target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an optimized\n"
"   release build in `target/release/`.\n"
"\n"
"7. You can add dependencies for your project by editing `Cargo.toml`. When you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""

#: src/cargo/running-locally.md:70
#, fuzzy
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"Cerca di incoraggiare i partecipanti alla classe a installare Cargo e utilizzare a\n"
"editore locale. Semplificher√† la loro vita poich√© avranno a\n"
"normale ambiente di sviluppo."

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# Benvenuto al primo giorno"

#: src/welcome-day-1.md:3
#, fuzzy
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr ""
"Questo √® il primo giorno di Comprehensive Rust. Copriremo molto terreno\n"
"Oggi:"

#: src/welcome-day-1.md:6
#, fuzzy
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods.\n"
"\n"
"* Memory management: stack vs heap, manual memory management, scope-based memory\n"
"  management, and garbage collection.\n"
"\n"
"* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"* Sintassi di base di Rust: variabili, tipi scalari e composti, enum, struct,\n"
"  riferimenti, funzioni e metodi.\n"
"\n"
"* Gestione della memoria: stack vs heap, gestione manuale della memoria, memoria basata "
"sull'ambito\n"
"  gestione e raccolta dei rifiuti.\n"
"\n"
"* Propriet√†: semantica di spostamento, copia e clonazione, prestito e durata."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Ricorda agli studenti che:"

#: src/welcome-day-1.md:18
#, fuzzy
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, i.e.,\n"
"    keep the related to how Rust does things vs some other language. It can be\n"
"    hard to find the right balance, but err on the side of allowing discussions\n"
"    since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we talk about things ahead of the slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* Dovrebbero fare domande quando le ricevono, non salvarle fino alla fine.\n"
"* La lezione √® pensata per essere interattiva e le discussioni sono molto incoraggiate!\n"
"  * In qualit√† di istruttore, dovresti cercare di mantenere le discussioni pertinenti, ad es.\n"
"    mantieni la relazione con il modo in cui Rust fa le cose rispetto a qualche altra lingua. Pu√≤ "
"essere\n"
"    difficile trovare il giusto equilibrio, ma peccare per permettere discussioni\n"
"    poich√© coinvolgono le persone molto pi√π della comunicazione unidirezionale.\n"
"* Le domande probabilmente significheranno che parleremo di cose prima delle diapositive.\n"
"  * Questo √® perfettamente a posto! La ripetizione √® una parte importante dell'apprendimento. "
"Ricordare\n"
"    che le diapositive sono solo un supporto e sei libero di saltarle come preferisci\n"
"    Piace."

#: src/welcome-day-1.md:29
#, fuzzy
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to speak\n"
"about the famous borrow checker. The way Rust handles memory is a major feature\n"
"and we should show students this right away."
msgstr ""
"L'idea per il primo giorno √® mostrare _quanto basta_ di Rust per poter parlare\n"
"sul famoso controllo dei prestiti. Il modo in cui Rust gestisce la memoria √® una caratteristica "
"importante\n"
"e dovremmo mostrarlo subito agli studenti."

#: src/welcome-day-1.md:33
#, fuzzy
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Se stai insegnando questo in un'aula, questo √® un buon posto per esaminare il\n"
"programma. Suggeriamo di dividere la giornata in due parti (seguendo le slide):"

#: src/welcome-day-1.md:36
#, fuzzy
msgid ""
"* Morning: 9:00 to 12:00,\n"
"* Afternoon: 13:00 to 16:00."
msgstr ""
"* Mattina: dalle 9:00 alle 12:00,\n"
"* Pomeriggio: dalle 13:00 alle 16:00."

#: src/welcome-day-1.md:39
#, fuzzy
msgid ""
"You can of course adjust this as necessary. Please make sure to include breaks,\n"
"we recommend a break every hour!"
msgstr ""
"Ovviamente puoi regolarlo se necessario. Assicurati di includere pause,\n"
"consigliamo una pausa ogni ora!"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# Cos'√® Rust?"

#: src/welcome-day-1/what-is-rust.md:3
#, fuzzy
msgid "Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr "Rust √® un nuovo linguaggio di programmazione che ha avuto la sua versione [1.0 nel 2015][1]:"

#: src/welcome-day-1/what-is-rust.md:5
#, fuzzy
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust √® un linguaggio compilato staticamente con un ruolo simile a C++\n"
"  * `rustc` utilizza LLVM come backend.\n"
"* Rust supporta molte [piattaforme e\n"
"  architetture](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* La ruggine viene utilizzata per un'ampia gamma di dispositivi:\n"
"  * firmware e caricatori di avvio,\n"
"  * display intelligenti,\n"
"  * cellulari,\n"
"  * desktop,\n"
"  * server."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust √® usato nelle stesse aree di C++:"

#: src/welcome-day-1/what-is-rust.md:23
#, fuzzy
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* Elevata flessibilit√†.\n"
"* Alto livello di controllo.\n"
"* Pu√≤ essere ridotto a dispositivi molto vincolati come i telefoni cellulari.\n"
"* Non ha runtime o garbage collection.\n"
"* Si concentra su affidabilit√† e sicurezza senza sacrificare le prestazioni."

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# Ciao mondo!"

#: src/hello-world.md:3
#, fuzzy
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr ""
"Passiamo al programma Rust pi√π semplice possibile, un classico Hello World\n"
"programma:"

#: src/hello-world.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hello üåç!\");\n"
"}\n"
"```"
msgstr ""

#: src/hello-world.md:12
msgid "What you see:"
msgstr "Quello che vedi:"

#: src/hello-world.md:14
#, fuzzy
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* Le funzioni sono introdotte con `fn`.\n"
"* I blocchi sono delimitati da parentesi graffe come in C e C++.\n"
"* La funzione `main` √® il punto di ingresso del programma.\n"
"* Rust ha macro igieniche, `println!` ne √® un esempio.\n"
"* Le stringhe Rust sono codificate in UTF-8 e possono contenere qualsiasi carattere Unicode."

#: src/hello-world.md:22
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will see\n"
"a ton of it over the next four days so we start small with something familiar."
msgstr ""
"Questa diapositiva cerca di mettere gli studenti a proprio agio con il codice Rust. Vedranno\n"
"un sacco di esso nei prossimi quattro giorni, quindi iniziamo in piccolo con qualcosa di familiare."

#: src/hello-world.md:27
#, fuzzy
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary.\n"
"\n"
"* Rust is modern with full support for things like Unicode.\n"
"\n"
"* Rust uses macros for situations where you want to have a variable number of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md)).\n"
"\n"
"* Macros being 'hygienic' means they don't accidentally capture identifiers from\n"
"  the scope they are used in. Rust macros are actually only\n"
"  [partially hygenic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)."
msgstr ""
"* Rust √® molto simile ad altri linguaggi della tradizione C/C++/Java. √à\n"
"  imperativo (non funzionale) e non cerca di reinventare le cose a meno che\n"
"  assolutamente necessario.\n"
"\n"
"* Rust √® moderno con pieno supporto per cose come Unicode.\n"
"\n"
"* Rust utilizza le macro per le situazioni in cui si desidera avere un numero variabile di\n"
"  argomenti (nessuna funzione [sovraccarico](basic-syntax/functions-interlude.md)).\n"
"\n"
"* Le macro essendo \"igieniche\" significa che non catturano accidentalmente identificatori da\n"
"  l'ambito in cui vengono utilizzate. Le macro di Rust sono in realt√† solo\n"
"  [parzialmente igienico](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)."

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# Piccolo esempio"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Ecco un piccolo programma di esempio in Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/hello-world/small-example.md:23
#, fuzzy
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop will\n"
"always end, but this is not yet proved. Edit the code and play with different\n"
"inputs."
msgstr ""
"Il codice implementa la congettura di Collatz: si ritiene che il ciclo lo far√†\n"
"finiscono sempre, ma questo non √® ancora provato. Modifica il codice e gioca con diversi\n"
"ingressi."

#: src/hello-world/small-example.md:29
#, fuzzy
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer overflow.\n"
"\n"
"* Change `let mut x` to `let x`, discuss the compiler error.\n"
"\n"
"* Show how `print!` gives a compilation error if the arguments don't match the\n"
"  format string.\n"
"\n"
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable.\n"
"\n"
"* Show the students the standard library, show them how to search for `std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that the\n"
"  students become familiar with searching in the standard library."
msgstr ""
"* Spiegare che tutte le variabili sono tipizzate staticamente. Prova a rimuovere \"i32\" per "
"attivare\n"
"  inferenza di tipo. Prova invece con `i8` e attiva un overflow di runtime integer.\n"
"\n"
"* Modificare `let mut x` in `let x`, discutere l'errore del compilatore.\n"
"\n"
"* Mostra come `print!` restituisce un errore di compilazione se gli argomenti non corrispondono a\n"
"  stringa di formato.\n"
"\n"
"* Mostra come devi usare `{}` come segnaposto se vuoi stampare un file\n"
"  espressione che √® pi√π complessa di una singola variabile.\n"
"\n"
"* Mostra agli studenti la libreria standard, mostra loro come cercare `std::fmt`\n"
"  che ha le regole del mini-linguaggio di formattazione. √à importante che il\n"
"  gli studenti acquisiscono familiarit√† con la ricerca nella libreria standard."

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# Perch√© Rust?"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Alcuni punti di forza unici di Rust:"

#: src/why-rust.md:5
#, fuzzy
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* Sicurezza della memoria del tempo di compilazione.\n"
"* Mancanza di comportamento runtime non definito.\n"
"* Funzionalit√† del linguaggio moderno."

#: src/why-rust.md:11
#, fuzzy
msgid ""
"Make sure to ask the class which languages they have experience with. Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr ""
"Assicurati di chiedere alla classe con quali lingue ha esperienza. Dipendente\n"
"nella risposta puoi evidenziare diverse caratteristiche di Rust:"

#: src/why-rust.md:14
#, fuzzy
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you don't\n"
"  have the memory unsafety issues. In addition, you get a modern language with\n"
"  constructs like pattern matching and built-in dependency management.\n"
"\n"
"* Experience with Java, Go, Python, JavaScript...: You get the same memory safety\n"
"  as in those languages, plus a similar high-level language feeling. In addition\n"
"  you get fast and predictable performance like C and C++ (no garbage collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* Esperienza con C o C++: Rust elimina un'intera classe di _errori di runtime_\n"
"  tramite il controllo del prestito. Ottieni prestazioni come in C e C++, ma non lo fai\n"
"  hanno i problemi di sicurezza della memoria. Inoltre, ottieni un linguaggio moderno con\n"
"  costrutti come il pattern matching e la gestione delle dipendenze incorporata.\n"
"\n"
"* Esperienza con Java, Go, Python, JavaScript...: Ottieni la stessa sicurezza della memoria\n"
"  come in quelle lingue, pi√π una simile sensazione linguistica di alto livello. Inoltre\n"
"  ottieni prestazioni veloci e prevedibili come C e C++ (nessun Garbage Collector)\n"
"  cos√¨ come l'accesso all'hardware di basso livello (se ne hai bisogno)"

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# Garanzie a Tempo di Compilazione"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Gestione statica della memoria in fase di compilazione:"

#: src/why-rust/compile-time.md:5
#, fuzzy
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* Nessuna variabile non inizializzata.\n"
"* Nessuna perdita di memoria (_principalmente_, vedi note).\n"
"* Nessuna doppia libera.\n"
"* Nessun utilizzo dopo-gratis.\n"
"* Nessun puntatore `NULL`.\n"
"* Nessun mutex bloccato dimenticato.\n"
"* Nessuna gara di dati tra i thread.\n"
"* Nessuna invalidazione dell'iteratore."

#: src/why-rust/compile-time.md:16
#, fuzzy
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr ""
"√à possibile produrre perdite di memoria in (sicuro) Rust. Qualche esempio\n"
"Sono:"

#: src/why-rust/compile-time.md:19
#, fuzzy
msgid ""
"* You can for use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* Puoi usare [`Box::leak`] per far trapelare un puntatore. Un uso di questo potrebbe\n"
"  be per ottenere variabili statiche inizializzate in runtime e di dimensioni runtime\n"
"* Puoi usare [`std::mem::forget`] per fare in modo che il compilatore \"dimentichi\"\n"
"  un valore (il che significa che il distruttore non viene mai eseguito).\n"
"* Puoi anche creare accidentalmente un [ciclo di riferimento] con `Rc` o\n"
"  'Arco'.\n"
"* In effetti, alcuni considereranno il popolamento infinito di una raccolta un ricordo\n"
"  perdite e la ruggine non protegge da quelle."

#: src/why-rust/compile-time.md:28
#, fuzzy
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr ""
"Ai fini di questo corso, si dovrebbe intendere \"Nessuna perdita di memoria\".\n"
"come \"Praticamente nessuna perdita di memoria * accidentale *\"."

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# Garanzie di autonomia"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Nessun comportamento indefinito in fase di esecuzione:"

#: src/why-rust/runtime.md:5
#, fuzzy
msgid ""
"* Array access is bounds checked.\n"
"* Integer overflow is defined."
msgstr ""
"* L'accesso all'array √® controllato dai limiti.\n"
"* L'overflow di numeri interi √® definito."

#: src/why-rust/runtime.md:12
#, fuzzy
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`).\n"
"\n"
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* L'overflow di numeri interi √® definito tramite un flag in fase di compilazione. Le opzioni sono\n"
"  o un panico (un crash controllato del programma) o un wrap-around\n"
"  semantica. Per impostazione predefinita, ottieni il panico in modalit√† di debug (`cargo build`)\n"
"  e wrap-around in modalit√† rilascio (`cargo build --release`).\n"
"\n"
"* Il controllo dei limiti non pu√≤ essere disabilitato con un flag del compilatore. Io posso anche\n"
"  non essere disabilitato direttamente con la parola chiave `unsafe`. Tuttavia,\n"
"  `unsafe` ti permette di chiamare funzioni come `slice::get_unchecked`\n"
"  che non esegue il controllo dei limiti."

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# Funzionalit√† moderne"

#: src/why-rust/modern.md:3
#, fuzzy
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr "Rust √® costruito con tutta l'esperienza maturata negli ultimi 40 anni."

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## Caratteristiche del linguaggio"

#: src/why-rust/modern.md:7
#, fuzzy
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* Enumerazioni e pattern matching.\n"
"* Generici.\n"
"* Nessun FFI in testa.\n"
"* Astrazioni a costo zero."

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## Tooling"

#: src/why-rust/modern.md:14
#, fuzzy
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* Grandi errori del compilatore.\n"
"* Gestore delle dipendenze integrato.\n"
"* Supporto integrato per i test.\n"
"* Eccellente supporto del protocollo Language Server."

#: src/why-rust/modern.md:23
#, fuzzy
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to 'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct.\n"
"\n"
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`.\n"
"\n"
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with _actionable_\n"
"  feedback, ready to copy-paste into your code.\n"
"\n"
"* The Rust standard library is small compared to languages like Java, Python,\n"
"  and Go. Rust does not come with several things you might consider standard and\n"
"  essential:\n"
"\n"
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json].\n"
"\n"
"  The reasoning behind this is that functionality in the standard library cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps there\n"
"  isn't a single \"best solution\" for some of these things.\n"
"\n"
"  Rust comes with a built-in package manager in the form of Cargo and this makes\n"
"  it trivial to download and compile third-party crates. A consequence of this\n"
"  is that the standard library can be smaller.\n"
"\n"
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"* Astrazioni a costo zero, simili a C++, significa che non devi \"pagare\"\n"
"  per costrutti di programmazione di livello superiore con memoria o CPU. Per esempio,\n"
"  scrivere un ciclo usando `for` dovrebbe comportare all'incirca lo stesso livello basso\n"
"  istruzioni come usare il costrutto `.iter().fold()`.\n"
"\n"
"* Potrebbe valere la pena ricordare che anche le enum di Rust sono \"tipi di dati algebrici\".\n"
"  noti come \"tipi di somma\", che consentono al sistema di tipi di esprimere cose come\n"
"  `Opzione<T>` e `Risultato<T, E>`.\n"
"\n"
"* Ricorda alle persone di leggere gli errori --- a cui molti sviluppatori si sono abituati\n"
"  ignora il lungo output del compilatore. Il compilatore Rust √® molto di pi√π\n"
"  loquace rispetto ad altri compilatori. Ti fornir√† spesso _actionable_\n"
"  feedback, pronto per il copia-incolla nel tuo codice.\n"
"\n"
"* La libreria standard di Rust √® piccola rispetto a linguaggi come Java, Python,\n"
"  e vai. Rust non viene fornito con molte cose che potresti considerare standard e\n"
"  essenziale:\n"
"\n"
"  * un generatore di numeri casuali, ma vedi [rand].\n"
"  * supporto per SSL o TLS, ma vedi [rusttls].\n"
"  * supporto per JSON, ma vedi [serde_json].\n"
"\n"
"  Il ragionamento alla base di ci√≤ √® che la funzionalit√† nella libreria standard non pu√≤\n"
"  andare via, quindi deve essere molto stabile. Per gli esempi precedenti, Rust\n"
"  la comunit√† sta ancora lavorando per trovare la soluzione migliore --- e forse l√¨\n"
"  non √® un'unica \"soluzione migliore\" per alcune di queste cose.\n"
"\n"
"  Rust viene fornito con un gestore di pacchetti integrato sotto forma di Cargo e questo rende\n"
"  √® banale scaricare e compilare casse di terze parti. Una conseguenza di ci√≤\n"
"  √® che la libreria standard pu√≤ essere pi√π piccola.\n"
"\n"
"  La scoperta di buone casse di terze parti pu√≤ essere un problema. Siti come\n"
"  <https://lib.rs/> aiuta in questo consentendoti di confrontare le metriche di salute per\n"
"  casse per trovarne una buona e fidata.\n"
"  \n"
"* [rust-analyzer] √® un'implementazione LSP ben supportata utilizzata in major\n"
"  IDE ed editor di testo."

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# Sintassi di base"

#: src/basic-syntax.md:3
#, fuzzy
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Gran parte della sintassi di Rust ti sar√† familiare da C, C++ o Java:"

#: src/basic-syntax.md:5
#, fuzzy
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* ...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* I blocchi e gli ambiti sono delimitati da parentesi graffe.\n"
"* I commenti di riga iniziano con `//`, i commenti di blocco sono delimitati da `/* ...\n"
"  */'.\n"
"* Parole chiave come \"if\" e \"while\" funzionano allo stesso modo.\n"
"* L'assegnazione delle variabili viene eseguita con `=`, il confronto viene eseguito con `==`."

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# Tipi scalari"

#: src/basic-syntax/scalar-types.md:3
#, fuzzy
msgid ""
"|                        | Types                                      | "
"Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, "
"`123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, "
"`10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | `3.14`, `-10.0e20`, "
"`2f32`    |\n"
"| Strings                | `&str`                                     | `\"foo\"`, "
"`\"two\\nlines\"`       |\n"
"| Unicode scalar values  | `char`                                     | `'a'`, `'Œ±'`, "
"`'‚àû'`           |\n"
"| Booleans               | `bool`                                     | `true`, "
"`false`               |"
msgstr ""
"| | Tipi | Letterali |\n"
"|------------------------|------------------------ "
"---------------------|---------------------------- --|\n"
"| Interi con segno | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123i64` |\n"
"| Interi senza segno | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10u16` |\n"
"| Numeri in virgola mobile | `f32`, `f64` | `3.14`, `-10.0e20`, `2f32` |\n"
"| Corde | `&str` | `\"pippo\"`, `\"due\\nrighe\"` |\n"
"| Valori scalari Unicode | `char` | `'a'`, `'Œ±'`, `'‚àû'` |\n"
"| Booleani | `bool` | `vero`, `falso` |"

#: src/basic-syntax/scalar-types.md:12
msgid "The types have widths as follows:"
msgstr "I tipi hanno larghezze come segue:"

#: src/basic-syntax/scalar-types.md:14
#, fuzzy
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* `iN`, `uN` e `fN` sono larghi _N_ bit,\n"
"* `isize` e `usize` sono la larghezza di un puntatore,\n"
"* `char` √® largo 32 bit,\n"
"* `bool` √® largo 8 bit."

#: src/basic-syntax/scalar-types.md:21
msgid "There are a few syntaxes which are not shown above:"
msgstr "Ci sono alcune sintassi che non sono mostrate sopra:"

#: src/basic-syntax/scalar-types.md:23
msgid ""
"- Raw strings allow you to create a `&str` value with escapes disabled: `r\"\\n\"\n"
"  == \"\\\\\\\\n\"`. You can embed double-quotes by using an equal amount of `#` on\n"
"  either side of the quotes:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"      println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"  }\n"
"  ```\n"
"\n"
"- Byte strings allow you to create a `&[u8]` value directly:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(\"{:?}\", b\"abc\");\n"
"      println!(\"{:?}\", &[97, 98, 99]);\n"
"  }\n"
"  ```"
msgstr ""

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# Tipi Composti (Compound)"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"
msgstr ""

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Assegnazione e accesso all‚ÄôArray:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Assegnazione e accesso alla Tupla:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Array:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that `[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types.\n"
"\n"
"* We can use literals to assign values to arrays.\n"
"\n"
"* In the main function, the print statement asks for the debug implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after the\n"
"  format string.\n"
"\n"
"* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be easier to read."
msgstr ""

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Tuple:"

#: src/basic-syntax/compound-types.md:49
#, fuzzy
msgid ""
"* Like arrays, tuples have a fixed length.\n"
"\n"
"* Tuples group together values of different types into a compound type.\n"
"\n"
"* Fields of a tuple can be accessed by the period and the index of the value, e.g. `t.0`, `t.1`.\n"
"\n"
"* The empty tuple `()` is also known as the \"unit type\". It is both a type, and\n"
"  the only valid value of that type - that is to say both the type and its value\n"
"  are expressed as `()`. It is used to indicate, for example, that a function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* Come gli array, le tuple hanno una lunghezza fissa.\n"
"\n"
"* Le tuple raggruppano valori di tipi diversi in un tipo composto.\n"
"\n"
"* √à possibile accedere ai campi di una tupla tramite il punto e l'indice del valore, ad es. `t.0`, "
"`t.1`.\n"
"\n"
"* La tupla vuota `()` √® anche nota come \"tipo di unit√†\". √à sia un tipo che\n"
"  l'unico valore valido di quel tipo, vale a dire sia il tipo che il suo valore\n"
"  sono espressi come `()`. Viene utilizzato per indicare, ad esempio, che una funzione o\n"
"  expression non ha alcun valore di ritorno, come vedremo in una diapositiva futura.\n"
"    * Puoi pensarlo come un \"vuoto\" che pu√≤ esserti familiare da altri\n"
"      linguaggi di programmazione."

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# Riferimenti"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Come C++, Rust ha riferimenti:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Alcune note:"

#: src/basic-syntax/references.md:16
#, fuzzy
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values over their lifetime."
msgstr ""
"* Dobbiamo dereferenziare `ref_x` quando lo assegni, in modo simile ai puntatori C e C++.\n"
"* In alcuni casi Rust dereferenzia automaticamente, in particolare durante l'invocazione\n"
"  metodi (prova `ref_x.count_ones()`).\n"
"* I riferimenti dichiarati come `mut` possono essere associati a valori diversi nel corso della "
"loro durata."

#: src/basic-syntax/references.md:21
msgid ""
"<details>\n"
"Key points:"
msgstr ""
"<details>\n"
"Punti chiave:"

#: src/basic-syntax/references.md:24
#, fuzzy
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound to\n"
"  different values, while the second represents a reference to a mutable value."
msgstr ""
"* Assicurati di notare la differenza tra `let mut ref_x: &i32` e `let ref_x:\n"
"  &mut i32`. Il primo rappresenta un riferimento mutevole a cui pu√≤ essere associato\n"
"  valori diversi, mentre il secondo rappresenta un riferimento a un valore mutabile."

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# Riferimenti Penzolanti (Dangling References)"

#: src/basic-syntax/references-dangling.md:3
#, fuzzy
msgid "Rust will statically forbid dangling references:"
msgstr "Rust proibir√† staticamente i riferimenti penzolanti:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
#, fuzzy
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* Si dice che un riferimento \"prenda in prestito\" il valore a cui si riferisce.\n"
"* Rust tiene traccia delle vite di tutti i riferimenti per assicurarsi che durino a lungo\n"
"  Abbastanza.\n"
"* Parleremo di pi√π del prestito quando arriveremo alla propriet√†."

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# Slices"

#: src/basic-syntax/slices.md:3
#, fuzzy
msgid "A slice gives you a view into a larger collection:"
msgstr "Una sezione ti offre una vista in una raccolta pi√π ampia:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"\n"
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:15
#, fuzzy
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* Le sezioni prendono in prestito i dati dal tipo a fette.\n"
"* Domanda: Cosa succede se modifichi `a[3]`?"

#: src/basic-syntax/slices.md:20
#, fuzzy
msgid ""
"* We create a slice by borrowing `a` and specifying the starting and ending indexes in brackets.\n"
"\n"
"* If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the starting index, "
"meaning that `&a[0..a.len()]` and `&a[..a.len()]` are identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are identical.\n"
"\n"
"* To easily create a slice of the full array, we can therefore use `&a[..]`.\n"
"\n"
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` (`&[i32]`) no longer "
"mentions the array length. This allows us to perform computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to remain 'alive' (in scope) "
"for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, but the answer is that "
"for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read the data from both `a` "
"and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* Creiamo una sezione prendendo in prestito `a` e specificando gli indici iniziale e finale tra "
"parentesi.\n"
"\n"
"* Se la slice inizia all'indice 0, la sintassi dell'intervallo di Rust ci consente di eliminare "
"l'indice iniziale, il che significa che `&a[0..a.len()]` e `&a[..a.len()]` sono identici .\n"
"    \n"
"* Lo stesso vale per l'ultimo indice, quindi `&a[2..a.len()]` e `&a[2..]` sono identici.\n"
"\n"
"* Per creare facilmente una porzione dell'array completo, possiamo quindi utilizzare `&a[..]`.\n"
"\n"
"* `s` √® un riferimento a una porzione di `i32`s. Si noti che il tipo di `s` (`&[i32]`) non "
"menziona pi√π la lunghezza dell'array. Questo ci permette di eseguire il calcolo su fette di "
"diverse dimensioni.\n"
" \n"
"* Le fette prendono sempre in prestito da un altro oggetto. In questo esempio, `a` deve rimanere "
"'vivo' (nello scope) almeno quanto la nostra fetta.\n"
"    \n"
"* La domanda sulla modifica di `a[3]` pu√≤ innescare una discussione interessante, ma la risposta √® "
"che per motivi di sicurezza della memoria\n"
"  non puoi farlo tramite \"a\" dopo aver creato una sezione, ma puoi leggere i dati sia da \"a\" "
"che da \"s\" in modo sicuro.\n"
"  Maggiori dettagli saranno spiegati nella sezione controllo del prestito."

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String` vs `str`"

#: src/basic-syntax/string-slices.md:3
#, fuzzy
msgid "We can now understand the two string types in Rust:"
msgstr "Ora possiamo comprendere i due tipi di stringhe in Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminologia di Rust:"

#: src/basic-syntax/string-slices.md:22
#, fuzzy
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` un riferimento immutabile a uno slice di stringa.\n"
"* `String` un buffer di stringa mutabile."

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 encoded string data \n"
"  stored in a block of memory. String literals (`‚ÄùHello‚Äù`), are stored in the program‚Äôs binary.\n"
"\n"
"* Rust‚Äôs `String` type is a wrapper around a vector of bytes. As with a `Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string literal; `String::"
"new()` \n"
"  creates a new empty string, to which string data can be added using the `push()` and "
"`push_str()` methods.\n"
"\n"
"* The `format!()` macro is a convenient way to generate an owned string from dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of `std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string "
"optimization).\n"
"    "
msgstr ""

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# Funzioni"

#: src/basic-syntax/functions.md:3
#, fuzzy
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview "
"question:"
msgstr ""
"Una versione Rust della famosa domanda dell'intervista [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    print_fizzbuzz_to(20);\n"
"}\n"
"\n"
"fn is_divisible(n: u32, divisor: u32) -> bool {\n"
"    if divisor == 0 {\n"
"        return false;\n"
"    }\n"
"    n % divisor == 0\n"
"}\n"
"\n"
"fn fizzbuzz(n: u32) -> String {\n"
"    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
"    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
"    if fizz.is_empty() && buzz.is_empty() {\n"
"        return format!(\"{n}\");\n"
"    }\n"
"    format!(\"{fizz}{buzz}\")\n"
"}\n"
"\n"
"fn print_fizzbuzz_to(n: u32) {\n"
"    for i in 1..=n {\n"
"        println!(\"{}\", fizzbuzz(i));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward declarations nor headers are "
"necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some programming languages), then "
"a return type.\n"
"* The last expression in a function body (or any block) becomes the return value. Simply omit the "
"`;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The compiler will infer "
"this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `print_fizzbuzz_to()` contains `=n`, which causes it "
"to include the upper bound."
msgstr ""

#: src/basic-syntax/rustdoc.md:1
msgid "# Rustdoc"
msgstr "# Rustdoc"

#: src/basic-syntax/rustdoc.md:3
#, fuzzy
msgid "All language items in Rust can be documented using special `///` syntax."
msgstr ""
"Tutti gli elementi del linguaggio in Rust possono essere documentati usando la sintassi speciale "
"`///`."

#: src/basic-syntax/rustdoc.md:5
msgid ""
"```rust,editable\n"
"/// Determine whether the first argument is divisible by the second argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return value\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/rustdoc.md:17
#, fuzzy
msgid ""
"The contents are treated as Markdown. All published Rust library crates are\n"
"automatically documented at [`docs.rs`](https://docs.rs) using the\n"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is\n"
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"I contenuti sono trattati come Markdown. Tutti i crate della libreria Rust pubblicati lo sono\n"
"documentato automaticamente in [`docs.rs`](https://docs.rs) utilizzando il file\n"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) strumento. √à\n"
"idiomatico per documentare tutti gli elementi pubblici in un'API utilizzando questo modello."

#: src/basic-syntax/rustdoc.md:24
#, fuzzy
msgid ""
"* Show students the generated docs for the `rand` crate at\n"
"  [`docs.rs/rand`](https://docs.rs/rand).\n"
"\n"
"* This course does not include rustdoc on slides, just to save space, but in\n"
"  real code they should be present.\n"
"\n"
"* Inner doc comments are discussed later (in the page on modules) and need not\n"
"  be addressed here."
msgstr ""
"* Mostra agli studenti i documenti generati per la cassa `rand` su\n"
"  [`docs.rs/rand`](https://docs.rs/rand).\n"
"\n"
"* Questo corso non include rustdoc sulle diapositive, solo per risparmiare spazio, ma in\n"
"  codice reale dovrebbero essere presenti.\n"
"\n"
"* I commenti interni al documento sono discussi pi√π avanti (nella pagina sui moduli) e non sono "
"necessari\n"
"  essere affrontato qui."

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# Metodi"

#: src/basic-syntax/methods.md:3
#, fuzzy
msgid ""
"Methods are functions associated with a type. The `self` argument of a method is\n"
"an instance of the type it is associated with:"
msgstr ""
"I metodi sono funzioni associate a un tipo. L'argomento `self` di un metodo √®\n"
"un'istanza del tipo a cui √® associata:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:30
#, fuzzy
msgid "* We will look much more at methods in today's exercise and in tomorrow's class."
msgstr "* Approfondiremo maggiormente i metodi nell'esercizio di oggi e nella lezione di domani."

#: src/basic-syntax/methods.md:34
msgid ""
"- Add a `Rectangle::new` constructor and call this from `main`:\n"
"\n"
"    ```rust,editable,compile_fail\n"
"    fn new(width: u32, height: u32) -> Rectangle {\n"
"        Rectangle { width, height }\n"
"    }\n"
"    ```\n"
"\n"
"- Add a `Rectangle::new_square(width: u32)` constructor to illustrate that\n"
"  constructors can take arbitrary parameters."
msgstr ""

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# Overloading di Funzione"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "Overloading non √® supportato:"

#: src/basic-syntax/functions-interlude.md:5
#, fuzzy
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* Ogni funzione ha una singola implementazione:\n"
"  * Accetta sempre un numero fisso di parametri.\n"
"  * Accetta sempre un singolo set di tipi di parametro.\n"
"* I valori predefiniti non sono supportati:\n"
"  * Tutti i siti di chiamata hanno lo stesso numero di argomenti.\n"
"  * Le macro sono talvolta utilizzate come alternativa."

#: src/basic-syntax/functions-interlude.md:12
#, fuzzy
msgid "However, function parameters can be generic:"
msgstr "Tuttavia, i parametri delle funzioni possono essere generici:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions-interlude.md:27
#, fuzzy
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind of limited\n"
"  polymorphism on argument types. We will see more details in a later section."
msgstr ""
"* Quando si usano i generici, `Into<T>` della libreria standard pu√≤ fornire una sorta di limited\n"
"  polimorfismo sui tipi di argomento. Vedremo maggiori dettagli in una sezione successiva."

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# Giorno 1: Esercizi Mattutini"

#: src/exercises/day-1/morning.md:3
#, fuzzy
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "In questi esercizi esploreremo due parti di Rust:"

#: src/exercises/day-1/morning.md:5
#, fuzzy
msgid ""
"* Implicit conversions between types.\n"
"\n"
"* Arrays and `for` loops."
msgstr ""
"* Conversioni implicite tra tipi.\n"
"\n"
"* Array e cicli `for`."

#: src/exercises/day-1/morning.md:11
#, fuzzy
msgid "A few things to consider while solving the exercises:"
msgstr "Alcune cose da considerare durante la risoluzione degli esercizi:"

#: src/exercises/day-1/morning.md:13
#, fuzzy
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for details\n"
"  on installing Rust.\n"
"\n"
"* Alternatively, use the Rust Playground."
msgstr ""
"* Utilizzare un'installazione locale di Rust, se possibile. In questo modo puoi ottenere\n"
"  completamento automatico nel tuo editor. Vedi la pagina su [Utilizzo del carico] per i dettagli\n"
"  sull'installazione di Rust.\n"
"\n"
"* In alternativa, usa Rust Playground."

#: src/exercises/day-1/morning.md:19
#, fuzzy
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose\n"
"their state if you navigate away from the page."
msgstr ""
"Gli snippet di codice non sono modificabili di proposito: gli snippet di codice in linea perdono\n"
"il loro stato se esci dalla pagina."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/bare-metal/morning.md:7
#: src/exercises/bare-metal/afternoon.md:7 src/exercises/concurrency/morning.md:12
#: src/exercises/concurrency/afternoon.md:13
#, fuzzy
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "Dopo aver esaminato gli esercizi, puoi esaminare le [soluzioni] fornite."

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# Conversioni Implicite"

#: src/exercises/day-1/implicit-conversions.md:3
#, fuzzy
msgid ""
"Rust will not automatically apply _implicit conversions_ between types ([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust non applicher√† automaticamente le _conversioni implicite_ tra i tipi ([a differenza di\n"
"C++][3]). Puoi vederlo in un programma come questo:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"\n"
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;\n"
"\n"
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
#, fuzzy
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single `from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted into\n"
"another type."
msgstr ""
"Tutti i tipi interi di Rust implementano [`From<T>`][1] e [`Into<T>`][2]\n"
"tratti per farci convertire tra di loro. Il tratto `From<T>` ha un singolo `from()`\n"
"e allo stesso modo, il tratto `Into<T>` ha un singolo metodo `into()`.\n"
"L'implementazione di questi tratti √® il modo in cui un tipo esprime ci√≤ in cui pu√≤ essere "
"convertito\n"
"un altro tipo."

#: src/exercises/day-1/implicit-conversions.md:25
#, fuzzy
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"La libreria standard ha un'implementazione di `From<i8> for i16`, che significa\n"
"che possiamo convertire una variabile `x` di tipo `i8` in una `i16` chiamando\n"
"`i16::da(x)`. O, pi√π semplicemente, con `x.into()`, perch√© `From<i8> for i16`\n"
"l'implementazione crea automaticamente un'implementazione di `Into<i16> per i8`."

#: src/exercises/day-1/implicit-conversions.md:30
#, fuzzy
msgid ""
"The same applies for your own `From` implementations for your own types, so it is\n"
"sufficient to only implement `From` to get a respective `Into` implementation automatically."
msgstr ""
"Lo stesso vale per le tue implementazioni `From` per i tuoi tipi, cos√¨ √®\n"
"sufficiente implementare solo `From` per ottenere automaticamente una rispettiva implementazione "
"`Into`."

#: src/exercises/day-1/implicit-conversions.md:33
#, fuzzy
msgid ""
"1. Execute the above program and look at the compiler error.\n"
"\n"
"2. Update the code above to use `into()` to do the conversion.\n"
"\n"
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented for\n"
"   the pairs you check."
msgstr ""
"1. Eseguire il programma precedente e osservare l'errore del compilatore.\n"
"\n"
"2. Aggiorna il codice sopra per utilizzare `into()` per eseguire la conversione.\n"
"\n"
"3. Cambia i tipi di `x` e `y` in altre cose (come `f32`, `bool`,\n"
"   `i128`) per vedere quali tipi √® possibile convertire in quali altri tipi. Tentativo\n"
"   convertire caratteri piccoli in caratteri grandi e viceversa. Controlla il\n"
"   [documentazione della libreria standard][1] per vedere se `From<T>` √® implementato per\n"
"   le coppie che controlli."

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# Array e Cicli `for`"

#: src/exercises/day-1/for-loops.md:3
#, fuzzy
msgid "We saw that an array can be declared like this:"
msgstr "Abbiamo visto che un array pu√≤ essere dichiarato in questo modo:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:9
#, fuzzy
msgid "You can print such an array by asking for its debug representation with `{:?}`:"
msgstr "Puoi stampare un tale array chiedendo la sua rappresentazione di debug con `{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:18
#, fuzzy
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr ""
"Rust ti consente di iterare cose come array e intervalli usando il `for`\n"
"parola chiave:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:38
#, fuzzy
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix and\n"
"a function `transpose` which will transpose a matrix (turn rows into columns):"
msgstr ""
"Usa quanto sopra per scrivere una funzione `pretty_print` che stampa in modo grazioso una matrice "
"e\n"
"una funzione `transpose` che traspone una matrice (trasforma le righe in colonne):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           ‚éõ‚é°1 2 3‚é§‚éû      ‚é°1 4 7‚é§\n"
"\"transpose\"‚éú‚é¢4 5 6‚é•‚éü  \"==\"‚é¢2 5 8‚é•\n"
"           ‚éù‚é£7 8 9‚é¶‚é†      ‚é£3 6 9‚é¶\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
#, fuzzy
msgid "Hard-code both functions to operate on 3 √ó 3 matrices."
msgstr "Hard-code entrambe le funzioni per operare su matrici 3 √ó 3."

#: src/exercises/day-1/for-loops.md:49
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/> e implementa il file\n"
"funzioni:"

#: src/exercises/day-1/for-loops.md:52
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## Domanda bonus"

#: src/exercises/day-1/for-loops.md:82
#, fuzzy
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 √ó 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"Potresti usare fette `&[i32]` invece di matrici 3 √ó 3 codificate per il tuo\n"
"argomenti e tipi restituiti? Qualcosa come \"&[&[i32]]\" per un oggetto bidimensionale\n"
"fetta di fette. Perch√© o perch√© no?"

#: src/exercises/day-1/for-loops.md:87
#, fuzzy
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality\n"
"implementation."
msgstr ""
"Guarda la [cassa `ndarray`](https://docs.rs/ndarray/) per una qualit√† di produzione\n"
"implementazione."

#: src/exercises/day-1/for-loops.md:92
#, fuzzy
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"La soluzione e la risposta alla sezione bonus sono disponibili nel\n"
"[Soluzione](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "# Variabili"

#: src/basic-syntax/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable by\n"
"default:"
msgstr ""
"Rust fornisce sicurezza di tipo tramite tipizzazione statica. Le associazioni variabili sono "
"immutabili da\n"
"predefinito:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
#, fuzzy
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the types less and less as "
"the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the function like syntax of "
"`println!(\"x: {}\", x)`"
msgstr ""
"* A causa dell'inferenza del tipo, `i32` √® facoltativo. Mostreremo gradualmente i tipi sempre meno "
"man mano che il corso procede.\n"
"* Nota che poich√© `println!` √® una macro, `x` non viene spostata, anche usando la sintassi di "
"funzione simile a `println!(\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:1
#, fuzzy
msgid "# Type Inference"
msgstr "# Digitare Inferenza"

#: src/basic-syntax/type-inference.md:3
#, fuzzy
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust esaminer√† come la variabile viene _usata_ per determinare il tipo:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"\n"
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;\n"
"\n"
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:26
#, fuzzy
msgid ""
"This slide demonstrates how the Rust compiler infers types based on constraints given by variable "
"declarations and usages."
msgstr ""
"Questa diapositiva mostra come il compilatore Rust deduce i tipi in base ai vincoli dati dalle "
"dichiarazioni e dagli usi delle variabili."

#: src/basic-syntax/type-inference.md:28
#, fuzzy
msgid ""
"It is very important to emphasize that variables declared like this are not of some sort of "
"dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical to the explicit "
"declaration of a type.\n"
"The compiler does the job for us and helps us write more concise code."
msgstr ""
"√à molto importante sottolineare che le variabili dichiarate in questo modo non sono di una sorta "
"di \"qualsiasi tipo\" dinamico che pu√≤\n"
"detenere alcun dato. Il codice macchina generato da tale dichiarazione √® identico alla "
"dichiarazione esplicita di un tipo.\n"
"Il compilatore fa il lavoro per noi e ci aiuta a scrivere codice pi√π conciso."

#: src/basic-syntax/type-inference.md:32
#, fuzzy
msgid ""
"The following code tells the compiler to copy into a certain generic container without the code "
"ever explicitly specifying the contained type, using `_` as a placeholder:"
msgstr ""
"Il codice seguente indica al compilatore di copiare in un determinato contenitore generico senza "
"che il codice specifichi mai esplicitamente il tipo contenuto, utilizzando `_` come segnaposto:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"\n"
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
#, fuzzy
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) relies "
"on `FromIterator`, which [`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) si basa "
"su `FromIterator`, che [`HashSet`](https:/ /doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implementa."

#: src/basic-syntax/static-and-const.md:1
#, fuzzy
msgid "# Static and Constant Variables"
msgstr "# Variabili statiche e costanti"

#: src/basic-syntax/static-and-const.md:3
#, fuzzy
msgid "Global state is managed with static and constant variables."
msgstr "Lo stato globale √® gestito con variabili statiche e costanti."

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr "## `const`"

#: src/basic-syntax/static-and-const.md:7
#, fuzzy
msgid "You can declare compile-time constants:"
msgstr "Puoi dichiarare costanti in fase di compilazione:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"\n"
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}\n"
"\n"
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:27
#, fuzzy
msgid "According the the [Rust RFC Book][1] these are inlined upon use."
msgstr "Secondo il [Rust RFC Book][1] questi sono incorporati dopo l'uso."

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr "## `static`"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "Puoi anche dichiarare variabili statiche:"

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:41
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have an actual associated "
"memory location.  This is useful for unsafe and embedded code, and the variable lives through the "
"entirety of the program execution."
msgstr ""
"Come notato nel [Rust RFC Book][1], questi non sono allineati durante l'uso e hanno una posizione "
"di memoria associata effettiva. Questo √® utile per il codice non sicuro e incorporato e la "
"variabile vive per tutta l'esecuzione del programma."

#: src/basic-syntax/static-and-const.md:44
#, fuzzy
msgid "We will look at mutating static data in the [chapter on Unsafe Rust](../unsafe.md)."
msgstr "Esamineremo la modifica dei dati statici nel [capitolo su Unsafe Rust](../unsafe.md)."

#: src/basic-syntax/static-and-const.md:48
#, fuzzy
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable global variable in C+"
"+.\n"
"* It isn't super common that one would need a runtime evaluated constant, but it is helpful and "
"safer than using a static."
msgstr ""
"* Menziona che `const` si comporta semanticamente in modo simile a `constexpr` del C++.\n"
"* `static`, d'altra parte, √® molto pi√π simile a una `const` o variabile globale mutabile in C++.\n"
"* Non √® molto comune che si abbia bisogno di una costante valutata in fase di esecuzione, ma √® "
"utile e pi√π sicura rispetto all'utilizzo di una statica."

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# Scopes (Ambiti) e Shadowing"

#: src/basic-syntax/scopes-shadowing.md:3
#, fuzzy
msgid ""
"You can shadow variables, both those from outer scopes and variables from the\n"
"same scope:"
msgstr ""
"Puoi ombreggiare le variabili, sia quelle degli ambiti esterni che le variabili del file\n"
"stessa portata:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"\n"
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }\n"
"\n"
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:25
#, fuzzy
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing both variable's memory "
"locations exist at the same time. Both are available under the same name, depending where you use "
"it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory locations when "
"shadowing an immutable variable in a scope, even if the type does not change."
msgstr ""
"* Definizione: l'ombreggiatura √® diversa dalla mutazione, perch√© dopo l'ombreggiatura le locazioni "
"di memoria di entrambe le variabili esistono contemporaneamente. Entrambi sono disponibili con lo "
"stesso nome, a seconda di dove lo usi nel codice.\n"
"* Una variabile di ombreggiatura pu√≤ avere un tipo diverso.\n"
"* L'ombreggiatura all'inizio sembra oscura, ma √® utile per conservare i valori dopo `.unwrap()`.\n"
"* Il codice seguente dimostra perch√© il compilatore non pu√≤ semplicemente riutilizzare le "
"posizioni di memoria durante lo shadowing di una variabile immutabile in un ambito, anche se il "
"tipo non cambia."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# Gestione della Memoria"

#: src/memory-management.md:3
#, fuzzy
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Tradizionalmente, le lingue sono state suddivise in due grandi categorie:"

#: src/memory-management.md:5
#, fuzzy
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ..."
msgstr ""
"* Controllo completo tramite gestione manuale della memoria: C, C++, Pascal, ...\n"
"* Piena sicurezza tramite la gestione automatica della memoria in fase di esecuzione: Java, "
"Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust offre un nuovo mix:"

#: src/memory-management.md:10
#, fuzzy
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> Pieno controllo *e* sicurezza tramite applicazione in fase di compilazione della memoria "
"corretta\n"
"> gestione."

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "Lo fa con un concetto di ownership (propriet√†) esplicito."

#: src/memory-management.md:15
#, fuzzy
msgid "First, let's refresh how memory management works."
msgstr "Innanzitutto, aggiorniamo il funzionamento della gestione della memoria."

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# Lo Stack (Pila) vs l‚ÄôHeap"

#: src/memory-management/stack-vs-heap.md:3
#, fuzzy
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality.\n"
"\n"
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* Stack: area continua di memoria per le variabili locali.\n"
"  * I valori hanno dimensioni fisse note al momento della compilazione.\n"
"  * Estremamente veloce: basta spostare un puntatore dello stack.\n"
"  * Facile da gestire: segue le chiamate alle funzioni.\n"
"  * Ottima localit√† di memoria.\n"
"\n"
"* Heap: archiviazione di valori al di fuori delle chiamate di funzione.\n"
"  * I valori hanno dimensioni dinamiche determinate in fase di esecuzione.\n"
"  * Leggermente pi√π lento della pila: √® necessaria un po' di contabilit√†.\n"
"  * Nessuna garanzia di localit√† di memoria."

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# Memoria sullo Stack"

#: src/memory-management/stack.md:3
#, fuzzy
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically sized\n"
"data on the heap:"
msgstr ""
"La creazione di una `Stringa` mette i dati di dimensioni fisse nello stack e dimensionati "
"dinamicamente\n"
"dati sull'heap:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/memory-management/stack.md:28
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and length and can grow if "
"mutable via reallocation on the heap.\n"
"\n"
"* If students ask about it, you can mention that the underlying memory is heap allocated using the "
"[System Allocator] and custom allocators can be implemented using the [Allocator API]\n"
"\n"
"* We can inspect the memory layout with `unsafe` code. However, you should point out that this is "
"rightfully unsafe!\n"
"\n"
"    ```rust,editable\n"
"    fn main() {\n"
"        let mut s1 = String::from(\"Hello\");\n"
"        s1.push(' ');\n"
"        s1.push_str(\"world\");\n"
"        // DON'T DO THIS AT HOME! For educational purposes only.\n"
"        // String provides no guarantees about its layout, so this could lead to\n"
"        // undefined behavior.\n"
"        unsafe {\n"
"            let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"            println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"        }\n"
"    }\n"
"    ```"
msgstr ""

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# Gestione manuale della Memoria"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Allocate e de-allocate voi stessi la memoria dell'heap."

#: src/memory-management/manual.md:5
#, fuzzy
msgid ""
"If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks."
msgstr ""
"Se non fatto con cura, ci√≤ pu√≤ portare a arresti anomali, bug, vulnerabilit√† di sicurezza e "
"perdite di memoria."

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## Esempio C"

#: src/memory-management/manual.md:9
#, fuzzy
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "Devi chiamare `free` su ogni puntatore allocato con `malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
#, fuzzy
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr ""
"La memoria viene persa se la funzione ritorna in anticipo tra `malloc` e `free`: the\n"
"puntatore √® perso e non possiamo deallocare la memoria."

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# Gestione della memoria basata sullo Scope (ambito)"

#: src/memory-management/scope-based.md:3
#, fuzzy
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr "Costruttori e distruttori ti consentono di agganciarti alla vita di un oggetto."

#: src/memory-management/scope-based.md:5
#, fuzzy
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception is\n"
"raised."
msgstr ""
"Avvolgendo un puntatore in un oggetto, puoi liberare memoria quando l'oggetto √®\n"
"distrutto. Il compilatore garantisce che ci√≤ accada, anche se lo √® un'eccezione\n"
"sollevato."

#: src/memory-management/scope-based.md:9
#, fuzzy
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and gives\n"
"you smart pointers."
msgstr ""
"Questo √® spesso chiamato _l'acquisizione delle risorse √® l'inizializzazione_ (RAII) e d√†\n"
"puntatori intelligenti."

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## Esempio C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/scope-based.md:20
#, fuzzy
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* L'oggetto `std::unique_ptr` √® allocato nello stack e punta a\n"
"  memoria allocata nell'heap.\n"
"* Alla fine di `say_hello`, verr√† eseguito il distruttore `std::unique_ptr`.\n"
"* Il distruttore libera l'oggetto `Person` a cui punta."

#: src/memory-management/scope-based.md:25
#, fuzzy
msgid "Special move constructors are used when passing ownership to a function:"
msgstr ""
"I costruttori di mosse speciali vengono utilizzati quando si passa la propriet√† a una funzione:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "# Gestione automatica della Memoria"

#: src/memory-management/garbage-collection.md:3
#, fuzzy
msgid ""
"An alternative to manual and scope-based memory management is automatic memory\n"
"management:"
msgstr ""
"Un'alternativa alla gestione della memoria manuale e basata sull'ambito √® la memoria automatica\n"
"gestione:"

#: src/memory-management/garbage-collection.md:6
#, fuzzy
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the programmer."
msgstr ""
"* Il programmatore non alloca o dealloca mai la memoria in modo esplicito.\n"
"* Un Garbage Collector trova la memoria inutilizzata e la dealloca per il programmatore."

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Esempio Java"

#: src/memory-management/garbage-collection.md:11
#, fuzzy
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "L'oggetto `person` non viene deallocato dopo che `sayHello` restituisce:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# Gestione della Memoria in Rust"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "La gestione della memoria in Rust √® un mix:"

#: src/memory-management/rust.md:5
#, fuzzy
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you choose, can be a single "
"unique pointer, reference counted, or atomically reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even have no cost at "
"runtime like C."
msgstr ""
"* Sicuro e corretto come Java, ma senza un garbage collector.\n"
"* A seconda dell'astrazione (o combinazione di astrazioni) scelta, pu√≤ trattarsi di un singolo "
"puntatore univoco, del conteggio dei riferimenti o del conteggio dei riferimenti atomici.\n"
"* Basato sull'ambito come C++, ma il compilatore applica la piena aderenza.\n"
"* Un utente Rust pu√≤ scegliere l'astrazione giusta per la situazione, alcuni addirittura non hanno "
"alcun costo in fase di esecuzione come C."

#: src/memory-management/rust.md:10
#, fuzzy
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "Raggiunge questo modellando _ownership_ in modo esplicito."

#: src/memory-management/rust.md:14
#, fuzzy
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper "
"types such as [Box], [Vec], [Rc], or [Arc]. These encapsulate ownership and memory allocation via "
"various means, and prevent the potential errors in C.\n"
"\n"
"* You may be asked about destructors here, the [Drop] trait is the Rust equivalent."
msgstr ""
"* Se ti viene chiesto come a questo punto, puoi menzionare che in Rust questo √® solitamente "
"gestito da tipi di wrapper RAII come [Box], [Vec], [Rc] o [Arc]. Questi incapsulano la propriet√† e "
"l'allocazione della memoria tramite vari mezzi e prevengono i potenziali errori in C.\n"
"\n"
"* Qui ti potrebbe essere chiesto dei distruttori, il tratto [Drop] √® l'equivalente di Rust."

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# Confronto"

#: src/memory-management/comparison.md:3
#, fuzzy
msgid "Here is a rough comparison of the memory management techniques."
msgstr "Ecco un confronto approssimativo delle tecniche di gestione della memoria."

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## Vantaggi di Tecniche differenti di gestione della Memoria"

#: src/memory-management/comparison.md:7
#, fuzzy
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Manuale come C:\n"
"  * Nessun sovraccarico di runtime.\n"
"* Automatico come Java:\n"
"  * Completamente automatico.\n"
"  * Sicuro e corretto.\n"
"* Basato sull'ambito come C++:\n"
"  * Parzialmente automatico.\n"
"  * Nessun sovraccarico di runtime.\n"
"* Basato sull'ambito imposto dal compilatore come Rust:\n"
"  * Applicato dal compilatore.\n"
"  * Nessun sovraccarico di runtime.\n"
"  * Sicuro e corretto."

#: src/memory-management/comparison.md:20
#, fuzzy
msgid "## Cons of Different Memory Management Techniques"
msgstr "## Contro di diverse tecniche di gestione della memoria"

#: src/memory-management/comparison.md:22
#, fuzzy
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Manuale come C:\n"
"  * Usa-dopo-gratis.\n"
"  * Doppia libera.\n"
"  * Perdite di memoria.\n"
"* Automatico come Java:\n"
"  * La raccolta dei rifiuti si interrompe.\n"
"  * Ritardi del distruttore.\n"
"* Basato sull'ambito come C++:\n"
"  * Complesso, opt-in dal programmatore.\n"
"  * Potenziale per uso dopo-gratis.\n"
"* Applicato al compilatore e basato sull'ambito come Rust:\n"
"  * Qualche complessit√† iniziale.\n"
"  * Pu√≤ rifiutare programmi validi."

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# Ownership (Propriet√†)"

#: src/ownership.md:3
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error to\n"
"use a variable outside its scope:"
msgstr ""
"Tutte le associazioni di variabili hanno un _scope_ in cui sono valide ed √® un errore\n"
"usa una variabile al di fuori del suo ambito:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""

#: src/ownership.md:18
#, fuzzy
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* Alla fine dell'ambito, la variabile viene _eliminata_ ei dati vengono liberati.\n"
"* Un distruttore pu√≤ essere eseguito qui per liberare risorse.\n"
"* Diciamo che la variabile _possiede_ il valore."

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# Semantica di Move (Spostamento)"

#: src/ownership/move-semantics.md:3
#, fuzzy
msgid "An assignment will transfer ownership between variables:"
msgstr "Un'assegnazione trasferir√† la propriet√† tra le variabili:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/move-semantics.md:14
#, fuzzy
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* L'assegnazione di \"s1\" a \"s2\" trasferisce la propriet√†.\n"
"* I dati sono stati _spostati_ da `s1` e `s1` non √® pi√π accessibile.\n"
"* Quando `s1` esce dall'ambito, non accade nulla: non ha propriet√†.\n"
"* Quando `s2` esce dall'ambito, i dati della stringa vengono liberati.\n"
"* C'√® sempre _esattamente_ un legame di variabile che possiede un valore."

#: src/ownership/move-semantics.md:22
#, fuzzy
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by value unless you use "
"`std::move` (and the move constructor is defined!).\n"
"\n"
"* In Rust, clones are explicit (by using `clone`)."
msgstr ""
"* Menziona che questo √® l'opposto dei valori predefiniti in C++, che copia per valore a meno che "
"tu non usi `std::move` (e il costruttore di movimento √® definito!).\n"
"\n"
"* In Rust, i cloni sono espliciti (utilizzando `clone`)."

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# Stringhe mosse/spostate in Rust"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
#, fuzzy
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* I dati dell'heap da `s1` vengono riutilizzati per `s2`.\n"
"* Quando `s1` esce dall'ambito, non accade nulla (√® stato spostato da)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Prima di muovere a `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Dopo il muovere a `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# Double Free in C++ moderno"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "C++ moderno risolve questo problema in modo diverso:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:10
#, fuzzy
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* I dati dell'heap da `s1` vengono duplicati e `s2` ottiene la propria copia indipendente.\n"
"* Quando `s1` e `s2` escono dall'ambito, ciascuno libera la propria memoria."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Prima dell'assegnazione di copia (copy-assignment):"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Dopo l'assegnazione di copia (copy-assignment):"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:1
#, fuzzy
msgid "# Moves in Function Calls"
msgstr "# Sposta nelle chiamate di funzione"

#: src/ownership/moves-function-calls.md:3
#, fuzzy
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr ""
"Quando si passa un valore a una funzione, il valore viene assegnato alla funzione\n"
"parametro. Questo trasferisce la propriet√†:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:20
#, fuzzy
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. Afterwards, `name` "
"cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the `say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) and if `say_hello` "
"accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call (`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making move semantics the "
"default, and by forcing programmers to make clones explicit."
msgstr ""
"* Con la prima chiamata a `say_hello`, `main` rinuncia alla propriet√† di `name`. Successivamente, "
"`name` non pu√≤ pi√π essere utilizzato all'interno di `main`.\n"
"* La memoria heap allocata per `name` verr√† liberata alla fine della funzione `say_hello`.\n"
"* `main` pu√≤ mantenere la propriet√† se passa `name` come riferimento (`&name`) e se `say_hello` "
"accetta un riferimento come parametro.\n"
"* In alternativa, `main` pu√≤ passare un clone di `name` nella prima chiamata (`name.clone()`).\n"
"* Rust rende pi√π difficile del C++ creare copie inavvertitamente rendendo la semantica di "
"spostamento l'impostazione predefinita e costringendo i programmatori a rendere espliciti i cloni."

#: src/ownership/copy-clone.md:1
#, fuzzy
msgid "# Copying and Cloning"
msgstr "# Copia e clonazione"

#: src/ownership/copy-clone.md:3
#, fuzzy
msgid "While move semantics are the default, certain types are copied by default:"
msgstr ""
"Sebbene la semantica di spostamento sia l'impostazione predefinita, alcuni tipi vengono copiati "
"per impostazione predefinita:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:14
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Questi tipi implementano il tratto `Copy`."

#: src/ownership/copy-clone.md:16
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr "Puoi acconsentire esplicitamente ai tuoi tipi per utilizzare la semantica della copia:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:30
#, fuzzy
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* Dopo l'assegnazione, sia `p1` che `p2` possiedono i propri dati.\n"
"* Possiamo anche usare `p1.clone()` per copiare esplicitamente i dati."

#: src/ownership/copy-clone.md:35
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Copiare e clonare non sono la stessa cosa:"

#: src/ownership/copy-clone.md:37
#, fuzzy
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by implementing the "
"`Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* La copia si riferisce a copie bit per bit di aree di memoria e non funziona su oggetti "
"arbitrari.\n"
"* La copia non consente la logica personalizzata (a differenza dei costruttori di copia in C++).\n"
"* La clonazione √® un'operazione pi√π generale e consente anche un comportamento personalizzato "
"implementando il tratto `Clone`.\n"
"* La copia non funziona sui tipi che implementano il tratto `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
#, fuzzy
msgid "In the above example, try the following:"
msgstr "Nell'esempio precedente, prova quanto segue:"

#: src/ownership/copy-clone.md:44
#, fuzzy
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because `String` is not a `Copy` "
"type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in the `println!` for  "
"`p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* Aggiungi un campo `String` a `struct Point`. Non verr√† compilato perch√© `String` non √® un tipo "
"`Copy`.\n"
"* Rimuovi `Copy` dall'attributo `derive`. L'errore del compilatore √® ora in `println!` per `p1`.\n"
"* Dimostra che funziona se invece cloni `p1`."

#: src/ownership/copy-clone.md:48
#, fuzzy
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way to generate code in "
"Rust\n"
"at compile time. In this case the default implementations of `Copy` and `Clone` traits are "
"generated."
msgstr ""
"Se gli studenti chiedono informazioni su `derive`, √® sufficiente dire che questo √® un modo per "
"generare codice in Rust\n"
"in fase di compilazione. In questo caso vengono generate le implementazioni predefinite dei tratti "
"`Copy` e `Clone`."

#: src/ownership/borrowing.md:1
#, fuzzy
msgid "# Borrowing"
msgstr "# Prendere in prestito"

#: src/ownership/borrowing.md:3
#, fuzzy
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr ""
"Invece di trasferire la propriet√† quando chiami una funzione, puoi lasciare che a\n"
"funzione _prende in prestito_ il valore:"

#: src/ownership/borrowing.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:22
#, fuzzy
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* La funzione `add` _prende in prestito_ due punti e restituisce un nuovo punto.\n"
"* Il chiamante mantiene la propriet√† degli ingressi."

#: src/ownership/borrowing.md:27
#, fuzzy
msgid "Notes on stack returns:"
msgstr "Note sui resi dello stack:"

#: src/ownership/borrowing.md:28
msgid ""
"* Demonstrate that the return from `add` is cheap because the compiler can eliminate the copy "
"operation. Change the above code to print stack addresses and run it on the [Playground]. In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay the same when changing "
"to the \"RELEASE\" setting:\n"
"\n"
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);\n"
"\n"
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification because constructors can "
"have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always "
"performs a simple and efficient `memcpy` copy."
msgstr ""

#: src/ownership/shared-unique-borrows.md:1
#, fuzzy
msgid "# Shared and Unique Borrows"
msgstr "# Prestiti condivisi e unici"

#: src/ownership/shared-unique-borrows.md:3
#, fuzzy
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "Rust pone dei vincoli sui modi in cui puoi prendere in prestito i valori:"

#: src/ownership/shared-unique-borrows.md:5
#, fuzzy
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* Puoi avere uno o pi√π valori `&T` in qualsiasi momento, _oppure_\n"
"* Puoi avere esattamente un valore `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"\n"
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/shared-unique-borrows.md:25
#, fuzzy
msgid ""
"* The above code does not compile because `a` is borrowed as mutable (through `c`) and as "
"immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` to make the code "
"compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before the new mutable "
"borrow of `a` through `c`. This is a feature of the borrow checker called \"non-lexical "
"lifetimes\"."
msgstr ""
"* Il codice precedente non viene compilato perch√© `a` √® preso in prestito come mutabile "
"(attraverso `c`) e come immutabile (attraverso `b`) allo stesso tempo.\n"
"* Sposta l'istruzione `println!` per `b` prima dell'ambito che introduce `c` per far compilare il "
"codice.\n"
"* Dopo tale modifica, il compilatore si rende conto che `b` √® sempre e solo usato prima del nuovo "
"prestito mutabile da `a` a `c`. Questa √® una caratteristica del controllo del prestito chiamata "
"\"vita non lessicale\"."

#: src/ownership/lifetimes.md:1
#, fuzzy
msgid "# Lifetimes"
msgstr "# Vite"

#: src/ownership/lifetimes.md:3
#, fuzzy
msgid "A borrowed value has a _lifetime_:"
msgstr "Un valore preso in prestito ha una _durata_:"

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that there is\n"
"    a valid solution."
msgstr ""

#: src/ownership/lifetimes-function-calls.md:1
#, fuzzy
msgid "# Lifetimes in Function Calls"
msgstr "# Durata delle chiamate di funzione"

#: src/ownership/lifetimes-function-calls.md:3
#, fuzzy
msgid "In addition to borrowing its arguments, a function can return a borrowed value:"
msgstr ""
"Oltre a prendere in prestito i suoi argomenti, una funzione pu√≤ restituire un valore preso in "
"prestito:"

#: src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:21
#, fuzzy
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` √® un parametro generico, viene dedotto dal compilatore.\n"
"* Le durate iniziano con `'` e `'a` √® un tipico nome predefinito.\n"
"* Leggi `&'a Point` come \"un `Punto` preso in prestito che √® valido almeno per il\n"
"  vita `a`\".\n"
"  * La parte _almeno_ √® importante quando i parametri si trovano in ambiti diversi."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), resulting in the following "
"code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);\n"
"\n"
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`.\n"
"\n"
"* Reset the workspace and change the function signature to `fn left_most<'a, 'b>(p1: &'a Point, "
"p2: &'a Point) -> &'b Point`. This will not compile because the relationship between the lifetimes "
"`'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global variable).\n"
"  * Which one is it? The compiler needs to to know, so at the call site the returned reference is "
"not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""

#: src/ownership/lifetimes-data-structures.md:1
#, fuzzy
msgid "# Lifetimes in Data Structures"
msgstr "# Durata nelle strutture dati"

#: src/ownership/lifetimes-data-structures.md:3
#, fuzzy
msgid "If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr "Se un tipo di dati memorizza dati presi in prestito, deve essere annotato con una durata:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:25
#, fuzzy
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data underlying the "
"contained `&str` lives at least as long as any instance of `Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), the borrow checker "
"throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This can be useful for "
"creating lightweight views, but it generally makes them somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one lifetime annotation. This "
"can be necessary if there is a need to describe lifetime relationships between the references "
"themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases."
msgstr ""
"* Nell'esempio precedente, l'annotazione su \"Highlight\" impone che i dati sottostanti a \"&str\" "
"contenuti durino almeno quanto qualsiasi istanza di \"Highlight\" che utilizza quei dati.\n"
"* Se `text` viene consumato prima della fine della vita di `fox` (o `dog`), il controllo del "
"prestito genera un errore.\n"
"* I tipi con dati presi in prestito costringono gli utenti a conservare i dati originali. Questo "
"pu√≤ essere utile per creare viste leggere, ma in genere le rende un po' pi√π difficili da usare.\n"
"* Quando possibile, fare in modo che le strutture dati possiedano direttamente i propri dati.\n"
"* Alcune strutture con pi√π riferimenti all'interno possono avere pi√π di un'annotazione di durata. "
"Ci√≤ pu√≤ essere necessario se √® necessario descrivere le relazioni di durata tra i riferimenti "
"stessi, oltre alla durata della struttura stessa. Questi sono casi d'uso molto avanzati."

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "# Day 1: Afternoon Exercises"
msgstr "# Giorno 1: Esercizi pomeridiani"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Vedremo due cose:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid ""
"* A small book library,\n"
"\n"
"* Iterators and ownership (hard)."
msgstr ""
"* Una piccola biblioteca di libri,\n"
"\n"
"* Iteratori e propriet√† (hard)."

#: src/exercises/day-1/book-library.md:1
#, fuzzy
msgid "# Designing a Library"
msgstr "# Progettare una libreria"

#: src/exercises/day-1/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For now,\n"
"you just need to know part of its API:"
msgstr ""
"Impareremo molto di pi√π sulle strutture e sul tipo `Vec<T>` domani. Per adesso,\n"
"devi solo conoscere parte della sua API:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"middle value: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:18
#, fuzzy
msgid ""
"Use this to create a library application. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Usalo per creare un'applicazione libreria. Copia il codice qui sotto per\n"
"<https://play.rust-lang.org/> e aggiorna i tipi per farlo compilare:"

#: src/exercises/day-1/book-library.md:21
msgid ""
"```rust,should_panic\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        todo!(\"Initialize and return a `Library` value\")\n"
"    }\n"
"\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and year\")\n"
"    //}\n"
"\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"}\n"
"\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: {}\", library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:102
#, fuzzy
msgid "[Solution](solutions-afternoon.md#designing-a-library)"
msgstr "[Soluzione](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:1
#, fuzzy
msgid "# Iterators and Ownership"
msgstr "# Iteratori e propriet√†"

#: src/exercises/day-1/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr ""
"Il modello di propriet√† di Rust influisce su molte API. Un esempio di questo √® il\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) e\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"tratti."

#: src/exercises/day-1/iterators-and-ownership.md:8
#, fuzzy
msgid "## `Iterator`"
msgstr "## `Iteratore`"

#: src/exercises/day-1/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` back:"
msgstr ""
"I tratti sono come interfacce: descrivono il comportamento (metodi) per un tipo. IL\n"
"Il tratto \"Iterator\" dice semplicemente che puoi chiamare \"next\" fino a quando non ottieni "
"\"Nessuno\":"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "Usi questo tratto in questo modo:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "Qual √® il tipo restituito dall'iteratore? Metti alla prova la tua risposta qui:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "Perch√© viene utilizzato questo tipo?"

#: src/exercises/day-1/iterators-and-ownership.md:48
#, fuzzy
msgid "## `IntoIterator`"
msgstr "## `IntoIterator`"

#: src/exercises/day-1/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the iterator:"
msgstr ""
"Il tratto `Iterator` ti dice come _iterare_ una volta che hai creato un file\n"
"iteratore. Il tratto correlato `IntoIterator` ti dice come creare l'iteratore:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"\n"
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr ""
"La sintassi qui significa che ogni implementazione di \"IntoIterator\" deve\n"
"dichiarare due tipi:"

#: src/exercises/day-1/iterators-and-ownership.md:65
#, fuzzy
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: il tipo su cui iteriamo, come `i8`,\n"
"* `IntoIter`: il tipo `Iterator` restituito dal metodo `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Nota che \"IntoIter\" e \"Item\" sono collegati: l'iteratore deve avere lo stesso\n"
"Tipo `Item`, che significa che restituisce `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Come prima, qual √® il tipo restituito dall'iteratore?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:83
#, fuzzy
msgid "## `for` Loops"
msgstr "## cicli `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"Ora che conosciamo sia `Iterator` che `IntoIterator`, possiamo creare cicli `for`.\n"
"Chiamano `into_iter()` su un'espressione e itera sul risultato\n"
"iteratore:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"\n"
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "Qual √® il tipo di \"parola\" in ogni ciclo?"

#: src/exercises/day-1/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for [`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"%26%27a%20Vec%3CT%2C%20A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"Vec%3CT%2C%20A%3E)\n"
"to check your answers."
msgstr ""
"Sperimenta con il codice sopra e poi consulta la documentazione per [`impl\n"
"IntoIteratore per\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"%26%27a%20Vec%3CT%2C%20A%3E)\n"
"e [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"Vec%3CT%2C%20A%3E)\n"
"per controllare le tue risposte."

#: src/welcome-day-2.md:1
#, fuzzy
msgid "# Welcome to Day 2"
msgstr "# Benvenuto al giorno 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Ora che abbiamo visto una discreta quantit√† di ruggine, continueremo con:"

#: src/welcome-day-2.md:5
#, fuzzy
msgid ""
"* Structs, enums, methods.\n"
"\n"
"* Pattern matching: destructuring enums, structs, and arrays.\n"
"\n"
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and\n"
"  `continue`.\n"
"\n"
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`\n"
"  and `Arc`.\n"
"\n"
"* Modules: visibility, paths, and filesystem hierarchy."
msgstr ""
"* Struct, enum, metodi.\n"
"\n"
"* Pattern matching: destrutturazione di enum, struct e array.\n"
"\n"
"* Costrutti del flusso di controllo: `if`, `if let`, `while`, `while let`, `break` e\n"
"  `continua`.\n"
"\n"
"* La libreria standard: `String`, `Option` e `Result`, `Vec`, `HashMap`, `Rc`\n"
"  e \"Arco\".\n"
"\n"
"* Moduli: visibilit√†, percorsi e gerarchia del filesystem."

#: src/structs.md:1
#, fuzzy
msgid "# Structs"
msgstr "# Strutture"

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Come C e C++, Rust supporta le strutture personalizzate:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""

#: src/structs.md:29
#, fuzzy
msgid ""
"<details>\n"
"Key Points: "
msgstr ""
"<dettagli>\n"
"Punti chiave:"

#: src/structs.md:32
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following slides.\n"
"* This may be a good time to let people know there are different types of structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a trait on some type "
"but don‚Äôt have any data that you want to store in the value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the old struct without "
"having to explicitly type it all out. It must always be the last element."
msgstr ""

#: src/structs/tuple-structs.md:1
#, fuzzy
msgid "# Tuple Structs"
msgstr "# Strutture di tuple"

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "Se i nomi dei campi non sono importanti, puoi utilizzare una struttura di tupla:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr "Questo √® spesso usato per i wrapper a campo singolo (chiamati newtypes):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"* Newtypes are a great way to encode additional information about the value in a primitive type, "
"for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer have to validate it "
"again at every use: 'PhoneNumber(String)` or `OddNumber(u32)`.\n"
"* Demonstrate how to add a `f64` value to a `Newtons` type by accessing the single field in the "
"newtype.\n"
"  *  Rust generally doesn‚Äôt like inexplicit things, like automatic unwrapping or for instance "
"using booleans as integers.\n"
"  *  Operator overloading is discussed on Day 3 (generics). "
msgstr ""
"* I newtype sono un ottimo modo per codificare informazioni aggiuntive sul valore in un tipo "
"primitivo, ad esempio:\n"
"  * Il numero √® misurato in alcune unit√†: `Newton` nell'esempio precedente.\n"
"  * Il valore ha superato una certa convalida quando √® stato creato, quindi non √® pi√π necessario "
"convalidarlo nuovamente a ogni utilizzo: 'Numero di telefono (Stringa)` o `Numero dispari (u32)`.\n"
"* Dimostra come aggiungere un valore `f64` a un tipo `Newtons` accedendo al singolo campo nel "
"newtype.\n"
"  * A Rust in genere non piacciono le cose inesplicite, come l'unwrapping automatico o, ad "
"esempio, l'uso di valori booleani come numeri interi.\n"
"  * Il sovraccarico degli operatori viene discusso il giorno 3 (generici)."

#: src/structs/field-shorthand.md:1
#, fuzzy
msgid "# Field Shorthand Syntax"
msgstr "# Sintassi abbreviata dei campi"

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr ""
"Se disponi gi√† di variabili con i nomi corretti, puoi creare il file\n"
"struct usando una scorciatoia:"

#: src/structs/field-shorthand.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:27
msgid ""
"*  The `new` function could be written using `Self` as a type, as it is interchangeable with the "
"struct type name\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Person {\n"
"         name: String,\n"
"         age: u8,\n"
"     }\n"
"     impl Person {\n"
"         fn new(name: String, age: u8) -> Self {\n"
"             Self { name, age }\n"
"         }\n"
"     }\n"
"     ```    \n"
"* Implement the `Default` trait for the struct. Define some fields and use the default values for "
"the other fields.\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Person {\n"
"         name: String,\n"
"         age: u8,\n"
"     }\n"
"     impl Default for Person {\n"
"         fn default() -> Person {\n"
"             Person {\n"
"                 name: \"Bot\".to_string(),\n"
"                 age: 0,\n"
"             }\n"
"         }\n"
"     }\n"
"     fn create_default() {\n"
"         let tmp = Person {\n"
"             ..Default::default()\n"
"         };\n"
"         let tmp = Person {\n"
"             name: \"Sam\".to_string(),\n"
"             ..Default::default()\n"
"         };\n"
"     }\n"
"     ```\n"
"\n"
"* Methods are defined in the `impl` block.\n"
"* Use struct update syntax to define a new structure using `peter`. Note that the variable `peter` "
"will no longer be accessible afterwards.\n"
"* Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""

#: src/enums.md:1
#, fuzzy
msgid "# Enums"
msgstr "# Enum"

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr ""
"La parola chiave `enum` consente la creazione di un tipo che ne ha alcuni\n"
"diverse varianti:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:33 src/enums/sizes.md:29 src/methods.md:30 src/methods/example.md:46
#: src/pattern-matching.md:25 src/pattern-matching/match-guards.md:22 src/control-flow/blocks.md:42
#, fuzzy
msgid "Key Points:"
msgstr "Punti chiave:"

#: src/enums.md:35
#, fuzzy
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and `Tail`. You might note "
"the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or one with different "
"types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate structs but then they "
"wouldn‚Äôt be the same type as they would if they were all defined in an enum. "
msgstr ""
"* Le enumerazioni consentono di raccogliere un insieme di valori in un unico tipo\n"
"* Questa pagina offre un tipo di enum `CoinFlip` con due varianti `Heads` e `Tail`. Potresti "
"notare lo spazio dei nomi quando usi le varianti.\n"
"* Questo potrebbe essere un buon momento per confrontare Struct ed Enum:\n"
"  * In entrambi, puoi avere una versione semplice senza campi (unit struct) o una con diversi tipi "
"di campi (variant payload).\n"
"  * In entrambi, le funzioni associate sono definite all'interno di un blocco `impl`.\n"
"  * Potresti persino implementare le diverse varianti di un'enumerazione con strutture separate, "
"ma non sarebbero dello stesso tipo che sarebbero se fossero tutte definite in un'enumerazione."

#: src/enums/variant-payloads.md:1
#, fuzzy
msgid "# Variant Payloads"
msgstr "# Payload varianti"

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"√à possibile definire enumerazioni pi√π ricche in cui le varianti contengono dati. √à quindi "
"possibile utilizzare il\n"
"istruzione `match` per estrarre i dati da ciascuna variante:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"* The values in the enum variants can only be accessed after being pattern matched. The pattern "
"binds references to the fields in the \"match arm\" after the `=>`.\n"
"  * The expression is matched against the patterns from top to bottom. There is no fall-through "
"like in C or C++.\n"
"  * The match expression has a value. The value is the last expression in the match arm which was "
"executed.\n"
"  * Starting from the top we look for what pattern matches the value then run the code following "
"the arrow. Once we find a match, we stop. \n"
"* Demonstrate what happens when the search is inexhaustive. Note the advantage the Rust compiler "
"provides by confirming when all cases are handled. \n"
"* `match` inspects a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling `std::mem::discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs where comparing field "
"values doesn't affect equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level "
"`struct Click { ... }`. The inlined version cannot implement traits, for example.  \n"
"  "
msgstr ""
"* √à possibile accedere ai valori nelle varianti enum solo dopo essere stati abbinati al modello. "
"Il modello lega i riferimenti ai campi nel \"match arm\" dopo il `=>`.\n"
"  * L'espressione viene confrontata con i modelli dall'alto verso il basso. Non c'√® fall-through "
"come in C o C++.\n"
"  * L'espressione di corrispondenza ha un valore. Il valore √® l'ultima espressione nel braccio di "
"corrispondenza che √® stata eseguita.\n"
"  * Partendo dall'alto cerchiamo quale modello corrisponde al valore, quindi eseguiamo il codice "
"seguendo la freccia. Una volta trovata una corrispondenza, ci fermiamo.\n"
"* Dimostrare cosa succede quando la ricerca √® inesauribile. Nota il vantaggio fornito dal "
"compilatore Rust confermando quando tutti i casi vengono gestiti.\n"
"* `match` ispeziona un campo discriminante nascosto in `enum`.\n"
"* √à possibile recuperare il discriminante chiamando `std::mem::discriminant()`\n"
"  * Ci√≤ √® utile, ad esempio, se si implementa `PartialEq` per strutture in cui il confronto dei "
"valori dei campi non influisce sull'uguaglianza.\n"
"* `WebEvent::Click { ... }` non √® esattamente la stessa cosa di `WebEvent::Click(Click)` con una "
"`struct Click { ... }` di primo livello. La versione inline non pu√≤ implementare tratti, per "
"esempio.\n"
"  "

#: src/enums/sizes.md:1
#, fuzzy
msgid "# Enum Sizes"
msgstr "# Enum Dimensioni"

#: src/enums/sizes.md:3
#, fuzzy
msgid "Rust enums are packed tightly, taking constraints due to alignment into account:"
msgstr ""
"Gli enum di Rust sono imballati strettamente, tenendo conto dei vincoli dovuti all'allineamento:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size!(Foo);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:25
#, fuzzy
msgid "* See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr "* Vedere il [riferimento Rust](https://doc.rust-lang.org/reference/type-layout.html)."

#: src/enums/sizes.md:31
msgid ""
" * Internally Rust is using a field (discriminant) to keep track of the enum variant.\n"
"\n"
" * You can control the discriminant if needed (e.g., for compatibility with C):\n"
" \n"
"     ```rust,editable\n"
"     #[repr(u32)]\n"
"     enum Bar {\n"
"         A,  // 0\n"
"         B = 10000,\n"
"         C,  // 10001\n"
"     }\n"
"     \n"
"     fn main() {\n"
"         println!(\"A: {}\", Bar::A as u32);\n"
"         println!(\"B: {}\", Bar::B as u32);\n"
"         println!(\"C: {}\", Bar::C as u32);\n"
"     }\n"
"     ```\n"
"\n"
"    Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2\n"
"    bytes.\n"
"\n"
"\n"
" * Try out other types such as\n"
" \n"
"     * `dbg_size!(bool)`: size 1 bytes, align: 1 bytes,\n"
"     * `dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche optimization, see below),\n"
"     * `dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),\n"
"     * `dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer optimization, see "
"below).\n"
"\n"
" * Niche optimization: Rust will merge use unused bit patterns for the enum\n"
"   discriminant.\n"
"\n"
" * Null pointer optimization: For [some\n"
"   types](https://doc.rust-lang.org/std/option/#representation), Rust guarantees\n"
"   that `size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
"\n"
"     Example code if you want to show how the bitwise representation *may* look like in practice.\n"
"     It's important to note that the compiler provides no guarantees regarding this "
"representation, therefore this is totally unsafe.\n"
"\n"
"     ```rust,editable\n"
"     use std::mem::transmute;\n"
"\n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"         // representation of types.\n"
"         unsafe {\n"
"             println!(\"Bitwise representation of bool\");\n"
"             dbg_bits!(false, u8);\n"
"             dbg_bits!(true, u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<bool>\");\n"
"             dbg_bits!(None::<bool>, u8);\n"
"             dbg_bits!(Some(false), u8);\n"
"             dbg_bits!(Some(true), u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"             dbg_bits!(Some(Some(false)), u8);\n"
"             dbg_bits!(Some(Some(true)), u8);\n"
"             dbg_bits!(Some(None::<bool>), u8);\n"
"             dbg_bits!(None::<Option<bool>>, u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<&i32>\");\n"
"             dbg_bits!(None::<&i32>, usize);\n"
"             dbg_bits!(Some(&0i32), usize);\n"
"         }\n"
"     }\n"
"     ```\n"
"\n"
"     More complex example if you want to discuss what happens when we chain more than 256 "
"`Option`s together.\n"
"\n"
"     ```rust,editable\n"
"     #![recursion_limit = \"1000\"]\n"
"\n"
"     use std::mem::transmute;\n"
"     \n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     // Macro to wrap a value in 2^n Some() where n is the number of \"@\" signs.\n"
"     // Increasing the recursion limit is required to evaluate this macro.\n"
"     macro_rules! many_options {\n"
"         ($value:expr) => { Some($value) };\n"
"         ($value:expr, @) => {\n"
"             Some(Some($value))\n"
"         };\n"
"         ($value:expr, @ $($more:tt)+) => {\n"
"             many_options!(many_options!($value, $($more)+), $($more)+)\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"         // representation of types.\n"
"         unsafe {\n"
"             assert_eq!(many_options!(false), Some(false));\n"
"             assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"             assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));\n"
"\n"
"             println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"             dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"             dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"\n"
"             println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"             dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"\n"
"             println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"             dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"         }\n"
"     }\n"
"     ```"
msgstr ""

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with an\n"
"`impl` block:"
msgstr ""
"Rust ti consente di associare funzioni ai tuoi nuovi tipi. Lo fai con un\n"
"Blocco `impl`:"

#: src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:31
#, fuzzy
msgid ""
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), the first parameter "
"represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method receiver syntax and to help "
"keep them more organized. By using methods we can keep all the implementation code in one "
"predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name "
"could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in and can be used "
"elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used to refer to individual "
"fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from `self` by modifying the "
"code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   "
msgstr ""
"* Pu√≤ essere utile introdurre metodi confrontandoli con funzioni.\n"
"  * I metodi vengono chiamati su un'istanza di un tipo (come struct o enum), il primo parametro "
"rappresenta l'istanza come `self`.\n"
"  * Gli sviluppatori possono scegliere di utilizzare i metodi per sfruttare la sintassi del "
"ricevitore del metodo e per mantenerli pi√π organizzati. Utilizzando i metodi possiamo mantenere "
"tutto il codice di implementazione in un posto prevedibile.\n"
"* Sottolinea l'uso della parola chiave `self`, un ricevitore di metodo.\n"
"  * Mostra che √® un termine abbreviato per `self:&Self` e forse mostra come potrebbe essere usato "
"anche il nome struct.\n"
"  * Spiega che `Self` √® un alias di tipo per il tipo in cui si trova il blocco `impl` e pu√≤ essere "
"utilizzato altrove nel blocco.\n"
"  * Nota come `self` viene utilizzato come altre strutture e la notazione con punto pu√≤ essere "
"utilizzata per fare riferimento a singoli campi.\n"
"  * Questo potrebbe essere un buon momento per dimostrare in che modo `&self` differisce da `self` "
"modificando il codice e provando a eseguire say_hello due volte.\n"
"* Di seguito descriviamo la distinzione tra ricevitori di metodi.\n"
"   "

#: src/methods/receiver.md:1
#, fuzzy
msgid "# Method Receiver"
msgstr "# Ricevitore del metodo"

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. There\n"
"are other possible receivers for a method:"
msgstr ""
"Il `&self` sopra indica che il metodo prende in prestito l'oggetto in modo immutabile. L√†\n"
"sono altri possibili ricevitori per un metodo:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. The\n"
"  method becomes the owner of the object. The object will be dropped (deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted.\n"
"* `mut self`: same as above, but while the method owns the object, it can\n"
"  mutate it too. Complete ownership does not automatically mean mutability.\n"
"* No receiver: this becomes a static method on the struct. Typically used to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: prende in prestito l'oggetto dal chiamante usando un oggetto condiviso e immutabile\n"
"  riferimento. L'oggetto pu√≤ essere riutilizzato in seguito.\n"
"* `&mut self`: prende in prestito l'oggetto dal chiamante usando un oggetto unico e mutabile\n"
"  riferimento. L'oggetto pu√≤ essere riutilizzato in seguito.\n"
"* `self`: assume la propriet√† dell'oggetto e lo allontana dal chiamante. IL\n"
"  metodo diventa il proprietario dell'oggetto. L'oggetto verr√† eliminato (deallocato)\n"
"  quando il metodo ritorna, a meno che la sua propriet√† non sia esplicita\n"
"  trasmesso.\n"
"* `mut self`: come sopra, ma mentre il metodo possiede l'oggetto, pu√≤ farlo\n"
"  muta anche questo. Propriet√† completa non significa automaticamente mutabilit√†.\n"
"* Nessun ricevitore: questo diventa un metodo statico sulla struttura. Tipicamente utilizzato per\n"
"  creare costruttori che sono chiamati \"nuovi\" per convenzione."

#: src/methods/receiver.md:19
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"Oltre alle varianti su \"self\", ci sono anche\n"
"[tipi di wrapper speciali](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"possono essere tipi di ricevitore, come `Box<Self>`."

#: src/methods/receiver.md:25
#, fuzzy
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". These constraints always "
"come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It isn't possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) method on it."
msgstr ""
"Prendi in considerazione l'enfasi su \"condiviso e immutabile\" e \"unico e mutevole\". Questi "
"vincoli arrivano sempre\n"
"insieme in Rust a causa delle regole del correttore in prestito, e \"self\" non fa eccezione. Non "
"√® possibile\n"
"fare riferimento a una struttura da pi√π posizioni e chiamare un metodo mutante (`&mut self`) su di "
"essa."

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
#, fuzzy
msgid "# Example"
msgstr "# Esempio"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access to self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:47
#, fuzzy
msgid ""
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the variable values and if/"
"how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` twice.\n"
"* Note that although the method receivers are different, the non-static functions are called the "
"same way in the main body. Rust enables automatic referencing and dereferencing when calling "
"methods. Rust automatically adds in the `&`, `*`, `muts` so that that object matches the method "
"signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated over. We describe "
"vectors in more detail in the afternoon. "
msgstr ""
"* Tutti e quattro i metodi qui usano un ricevitore metodo diverso.\n"
"  * Puoi indicare come ci√≤ cambia ci√≤ che la funzione pu√≤ fare con i valori delle variabili e se/"
"come pu√≤ essere riutilizzata in `main`.\n"
"  * Puoi mostrare l'errore che appare quando provi a chiamare `finish` due volte.\n"
"* Si noti che sebbene i destinatari del metodo siano diversi, le funzioni non statiche sono "
"chiamate allo stesso modo nel corpo principale. Rust abilita la referenziazione e la "
"dereferenziazione automatica quando si chiamano i metodi. Rust aggiunge automaticamente `&`, `*`, "
"`muts` in modo che quell'oggetto corrisponda alla firma del metodo.\n"
"* Potresti sottolineare che `print_laps` sta usando un vettore che viene iterato. Descriviamo i "
"vettori in modo pi√π dettagliato nel pomeriggio."

#: src/pattern-matching.md:1
#, fuzzy
msgid "# Pattern Matching"
msgstr "# Corrispondenza modello"

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"La parola chiave `match` ti consente di confrontare un valore con uno o pi√π _pattern_. IL\n"
"i confronti vengono effettuati dall'alto verso il basso e vince la prima partita."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "I modelli possono essere valori semplici, in modo simile a `switch` in C e C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "Il modello `_` √® un modello di caratteri jolly che corrisponde a qualsiasi valore."

#: src/pattern-matching.md:26
#, fuzzy
msgid ""
"* You might point out how some specific characters are being used when in a pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a wildcard character with "
"a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, as the term can show "
"up in error messages.\n"
"   "
msgstr ""
"* Potresti sottolineare come vengono utilizzati alcuni caratteri specifici quando in uno schema\n"
"  * `|` come `o`\n"
"  * `..` pu√≤ espandersi quanto deve essere\n"
"  * `1..=5` rappresenta un intervallo inclusivo\n"
"  * `_` √® un carattere jolly\n"
"* Pu√≤ essere utile mostrare come funziona l'associazione, ad esempio sostituendo un carattere "
"jolly con una variabile o rimuovendo le virgolette intorno a `q`.\n"
"* Puoi dimostrare la corrispondenza su un riferimento.\n"
"* Questo potrebbe essere un buon momento per far emergere il concetto di modelli inconfutabili, "
"poich√© il termine pu√≤ apparire nei messaggi di errore.\n"
"   "

#: src/pattern-matching/destructuring-enums.md:1
#, fuzzy
msgid "# Destructuring Enums"
msgstr "# Destrutturazione delle enum"

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is how\n"
"you inspect the structure of your types. Let us start with a simple `enum` type:"
msgstr ""
"I modelli possono anche essere usati per associare variabili a parti dei tuoi valori. Questo √® "
"come\n"
"ispezioni la struttura dei tuoi tipi. Iniziamo con un semplice tipo `enum`:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second arm,\n"
"`msg` is bound to the error message."
msgstr ""
"Qui abbiamo usato le braccia per _destrutturare_ il valore `Result`. Nel primo\n"
"arm, \"half\" √® legato al valore all'interno della variante \"Ok\". Nel secondo braccio,\n"
"`msg` √® associato al messaggio di errore."

#: src/pattern-matching/destructuring-enums.md:36
#, fuzzy
msgid ""
"* The `if`/`else` expression is returning an enum that is later unpacked with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying the errors when running "
"the code. Point out the places where your code is now inexhaustive and how the compiler tries to "
"give you hints."
msgstr ""
"* L'espressione `if`/`else` restituisce un enum che viene successivamente decompresso con un "
"`match`.\n"
"* Puoi provare ad aggiungere una terza variante alla definizione enum e visualizzare gli errori "
"durante l'esecuzione del codice. Indica i punti in cui il tuo codice √® ora inesausto e come il "
"compilatore cerca di darti suggerimenti."

#: src/pattern-matching/destructuring-structs.md:1
#, fuzzy
msgid "# Destructuring Structs"
msgstr "# Strutture destrutturanti"

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "Puoi anche destrutturare `structs`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
#, fuzzy
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"* The distinction between a capture and a constant expression can be hard to\n"
"  spot. Try changing the `2` in the second arm to a variable, and see that it subtly\n"
"  doesn't work. Change it to a `const` and see it working again."
msgstr ""
"* Cambia i valori letterali in `foo` in modo che corrispondano agli altri modelli.\n"
"* Aggiungi un nuovo campo a \"Foo\" e apporta le modifiche al modello secondo necessit√†.\n"
"* La distinzione tra una cattura e un'espressione costante pu√≤ essere difficile da fare\n"
"  macchiare. Prova a cambiare il \"2\" nel secondo braccio in una variabile e osservalo "
"sottilmente\n"
"  non funziona. Cambialo in un `const` e guardalo funzionare di nuovo."

#: src/pattern-matching/destructuring-arrays.md:1
#, fuzzy
msgid "# Destructuring Arrays"
msgstr "# Array destrutturanti"

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid "You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "Puoi destrutturare array, tuple e slice abbinando i loro elementi:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:21
msgid ""
"* Destructuring of slices of unknown length also works with patterns of fixed length.\n"
"\n"
"\n"
"     ```rust,editable\n"
"     fn main() {\n"
"         inspect(&[0, -2, 3]);\n"
"         inspect(&[0, -2, 3, 4]);\n"
"     }\n"
"\n"
"     #[rustfmt::skip]\n"
"     fn inspect(slice: &[i32]) {\n"
"         println!(\"Tell me about {slice:?}\");\n"
"         match slice {\n"
"             &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"             &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"             _          => println!(\"All elements were ignored\"),\n"
"         }\n"
"     }\n"
"     ```\n"
"  \n"
"* Create a new pattern using `_` to represent an element. \n"
"* Add more values to the array.\n"
"* Point out that how `..` will expand to account for different number of elements.\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""

#: src/pattern-matching/match-guards.md:1
#, fuzzy
msgid "# Match Guards"
msgstr "# Partita Guardie"

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"Durante la corrispondenza, puoi aggiungere una _guard_ a un pattern. Questo √® un booleano "
"arbitrario\n"
"espressione che verr√† eseguita se il modello corrisponde:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:23
#, fuzzy
msgid ""
"* Match guards as a separate syntax feature are important and necessary when we wish to concisely "
"express more complex ideas than patterns alone would allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. An `if` expression "
"inside of the branch block (after `=>`) happens after the match arm is selected. Failing the `if` "
"condition inside of that block won't result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a pattern with an `|`."
msgstr ""
"* Le guardie di corrispondenza come caratteristica di sintassi separata sono importanti e "
"necessarie quando desideriamo esprimere in modo conciso idee pi√π complesse di quanto i soli schemi "
"consentirebbero.\n"
"* Non sono la stessa cosa dell'espressione `if` separata all'interno del braccio della "
"corrispondenza. Un'espressione `if` all'interno del blocco di diramazione (dopo `=>`) si verifica "
"dopo che √® stato selezionato il braccio di corrispondenza. Il fallimento della condizione \"if\" "
"all'interno di quel blocco non comporter√† altre braccia\n"
"dell'espressione `match` originale considerata.\n"
"* √à possibile utilizzare le variabili definite nel modello nell'espressione if.\n"
"* La condizione definita nella guardia si applica a ogni espressione in un modello con un `|`."

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "# Day 2: Morning Exercises"
msgstr "# Giorno 2: Esercizi mattutini"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Esamineremo i metodi di implementazione in due contesti:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid ""
"* Simple struct which tracks health statistics.\n"
"\n"
"* Multiple structs and enums for a drawing library."
msgstr ""
"* Struttura semplice che tiene traccia delle statistiche sulla salute.\n"
"\n"
"* Strutture multiple ed enum per una libreria di disegni."

#: src/exercises/day-2/health-statistics.md:1
#, fuzzy
msgid "# Health Statistics"
msgstr "# Statistiche sanitarie"

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, you\n"
"need to keep track of users' health statistics."
msgstr ""
"Stai lavorando all'implementazione di un sistema di monitoraggio sanitario. Come parte di questo, "
"tu\n"
"necessit√† di tenere traccia delle statistiche sulla salute degli utenti."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a `User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"Inizierai con alcune funzioni stubbed in un blocco `impl` cos√¨ come in un `User`\n"
"definizione di struttura. Il tuo obiettivo √® implementare i metodi eliminati sul file\n"
"`User` `struct` definito nel blocco `impl`."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"methods:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/> e inserisci quello mancante\n"
"metodi:"

#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:1
#, fuzzy
msgid "# Polygon Struct"
msgstr "# Struttura poligonale"

#: src/exercises/day-2/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make the\n"
"tests pass:"
msgstr ""
"Creeremo una struttura `Polygon` che contiene alcuni punti. Copia il codice qui sotto\n"
"a <https://play.rust-lang.org/> e inserire i metodi mancanti per rendere il file\n"
"i test superano:"

#: src/exercises/day-2/points-polygons.md:7
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Point {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Point {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Circle {\n"
"    // add methods\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key part\n"
"of the exercise is to specify those correctly. You don't have to modify the tests."
msgstr ""
"Poich√© le firme del metodo mancano nelle dichiarazioni del problema, la parte chiave\n"
"dell'esercizio √® specificarli correttamente. Non √® necessario modificare i test."

#: src/exercises/day-2/points-polygons.md:120
#, fuzzy
msgid "Other interesting parts of the exercise:"
msgstr "Altre parti interessanti dell'esercizio:"

#: src/exercises/day-2/points-polygons.md:122
#, fuzzy
msgid ""
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes don't borrow their "
"arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be addable via \"+\". Note that "
"we do not discuss generics until Day 3."
msgstr ""
"* Deriva un tratto `Copy` per alcune strutture, poich√© nei test i metodi a volte non prendono in "
"prestito i loro argomenti.\n"
"* Scopri che il tratto `Add` deve essere implementato affinch√© due oggetti possano essere aggiunti "
"tramite \"+\". Si noti che non discuteremo di farmaci generici fino al giorno 3."

#: src/control-flow.md:1
#, fuzzy
msgid "# Control Flow"
msgstr "# Flusso di controllo"

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then becomes\n"
"the value of the `if` expression. Other control flow expressions work similarly\n"
"in Rust."
msgstr ""
"Come abbiamo visto, \"if\" √® un'espressione in Rust. √à usato in modo condizionale\n"
"valutare uno dei due blocchi, ma i blocchi possono avere un valore che poi diventa\n"
"il valore dell'espressione \"if\". Altre espressioni del flusso di controllo funzionano in modo "
"simile\n"
"a Ruggine."

#: src/control-flow/blocks.md:1
#, fuzzy
msgid "# Blocks"
msgstr "# Blocchi"

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust has a value and a type: the value is the last expression of the\n"
"block:"
msgstr ""
"Un blocco in Rust ha un valore e un tipo: il valore √® l'ultima espressione del\n"
"bloccare:"

#: src/control-flow/blocks.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:25
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"La stessa regola viene utilizzata per le funzioni: il valore del corpo della funzione √® the\n"
"valore di ritorno:"

#: src/control-flow/blocks.md:28
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:38
msgid "However if the last expression ends with `;`, then the resulting value and type is `()`."
msgstr ""

#: src/control-flow/blocks.md:43
#, fuzzy
msgid ""
"* The point of this slide is to show that blocks have a type and value in Rust. \n"
"* You can show how the value of the block changes by changing the last line in the block. For "
"instance, adding/removing a semicolon or using a `return`.\n"
"   "
msgstr ""
"* Lo scopo di questa diapositiva √® mostrare che i blocchi hanno un tipo e un valore in Rust.\n"
"* Puoi mostrare come cambia il valore del blocco cambiando l'ultima riga nel blocco. Ad esempio, "
"aggiungendo/rimuovendo un punto e virgola o utilizzando un `return`.\n"
"   "

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "# `if` expressions"
msgstr "# Espressioni `if`"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid ""
"You use [`if`\n"
"expressions](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions)\n"
"exactly like `if` statements in other languages:"
msgstr ""
"Tu usi [`if`\n"
"espressioni](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions)\n"
"esattamente come le dichiarazioni `if` in altre lingue:"

#: src/control-flow/if-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:18
#, fuzzy
msgid ""
"In addition, you can use `if` as an expression. The last expression of each\n"
"block becomes the value of the `if` expression:"
msgstr ""
"Inoltre, puoi usare \"if\" come espressione. L'ultima espressione di ciascuno\n"
"block diventa il valore dell'espressione `if`:"

#: src/control-flow/if-expressions.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:35
msgid ""
"Because `if` is an expression and must have a particular type, both of its branch blocks must have "
"the same type. Consider showing what happens if you add `;` after `x / 2` in the second example."
msgstr ""

#: src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "# `if let` expressions"
msgstr "# Espressioni `if let`"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid ""
"The [`if let`\n"
"expression](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions)\n"
"lets you execute different code depending on whether a value matches a pattern:"
msgstr ""
"Il [`se lasciato`\n"
"espressione](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions)\n"
"ti consente di eseguire codice diverso a seconda che un valore corrisponda a un modello:"

#: src/control-flow/if-let-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:18 src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:23
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns in\n"
"Rust."
msgstr ""
"Vedi [pattern matching](../pattern-matching.md) per maggiori dettagli sui pattern in\n"
"Ruggine."

#: src/control-flow/if-let-expressions.md:23
msgid ""
"* `if let` can be more concise than `match`, e.g., when only one case is interesting. In contrast, "
"`match` requires all branches to be covered.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern matching.\n"
"* Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-example/flow_control/let_else."
"html) construct allows to do a destructuring assignment, or if it fails, have a non-returning "
"block branch (panic/return/break/continue):\n"
"\n"
"   ```rust,editable\n"
"   fn main() {\n"
"       println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
"   }\n"
"    \n"
"   fn second_word_to_upper(s: &str) -> Option<String> {\n"
"       let mut it = s.split(' ');\n"
"       let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
"           return None;\n"
"       };\n"
"       Some(item.to_uppercase())\n"
"   }"
msgstr ""

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "# `while` loops"
msgstr "# `while` si ripete"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-"
"loops)\n"
"works very similar to other languages:"
msgstr ""
"La [parola chiave `while`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#predicate-loops)\n"
"funziona in modo molto simile ad altre lingue:"

#: src/control-flow/while-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "# `while let` loops"
msgstr "# `while let` va in loop"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-pattern-loops)\n"
"variant which repeatedly tests a value against a pattern:"
msgstr ""
"Come con `if let`, c'√® un [`while let`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#predicate-pattern-loops)\n"
"variante che verifica ripetutamente un valore rispetto a un modello:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"Qui l'iteratore restituito da `v.iter()` restituir√† una `Option<i32>` su ogni\n"
"chiamata a `next()`. Restituisce `Some(x)` finch√© non √® finito, dopodich√© lo far√†\n"
"restituire \"Nessuno\". Il `while let` ci consente di continuare a scorrere tutti gli elementi."

#: src/control-flow/while-let-expressions.md:26
#, fuzzy
msgid ""
"* Point out that the `while let` loop will keep going as long as the value matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if statement that breaks when "
"there is no value to unwrap for `iter.next()`. The `while let` provides syntactic sugar for the "
"above scenario.\n"
"    "
msgstr ""
"* Fai notare che il ciclo `while let` continuer√† finch√© il valore corrisponde al modello.\n"
"* Potresti riscrivere il ciclo `while let` come un ciclo infinito con un'istruzione if che si "
"interrompe quando non c'√® alcun valore da scartare per `iter.next()`. Il `while let` fornisce lo "
"zucchero sintattico per lo scenario di cui sopra.\n"
"    "

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "# `for` loops"
msgstr "# Cicli `for`"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is closely\n"
"related to the [`while let` loop](while-let-expression.md). It will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"Il [ciclo `for`](https://doc.rust-lang.org/std/keyword.for.html) √® strettamente\n"
"relativo al [ciclo `while let`](while-let-expression.md). Lo far√†\n"
"chiama automaticamente `into_iter()` sull'espressione e quindi itera su di essa:"

#: src/control-flow/for-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"\n"
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:21
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "Puoi usare `break` e `continue` qui come al solito."

#: src/control-flow/for-expressions.md:25
#, fuzzy
msgid ""
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change vector `v` to be "
"mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"* L'iterazione dell'indice non √® una sintassi speciale in Rust solo per quel caso.\n"
"* `(0..10)` √® un intervallo che implementa un tratto `Iterator`.\n"
"* `step_by` √® un metodo che restituisce un altro `Iterator` che salta ogni altro elemento.\n"
"* Modifica gli elementi nel vettore e spiega gli errori del compilatore. Cambia il vettore `v` in "
"modo che sia mutabile e il ciclo for in `for x in v.iter_mut()`."

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "# `loop` expressions"
msgstr "# Espressioni `loop`"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#infinite-loops)\n"
"which creates an endless loop."
msgstr ""
"Infine, c'√® una [parola chiave `loop`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#infinite-loops)\n"
"che crea un loop infinito."

#: src/control-flow/loop-expressions.md:6
#, fuzzy
msgid "Here you must either `break` or `return` to stop the loop:"
msgstr "Qui devi \"break\" o \"return\" per interrompere il ciclo:"

#: src/control-flow/loop-expressions.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:27
#, fuzzy
msgid ""
"* Break the `loop` with a value (e.g. `break 8`) and print it out.\n"
"* Note that `loop` is the only looping construct which returns a non-trivial\n"
"  value. This is because it's guaranteed to be entered at least once (unlike\n"
"  `while` and `for` loops)."
msgstr ""
"* Interrompi il `loop` con un valore (ad es. `break 8`) e stampalo.\n"
"* Si noti che `loop` √® l'unico costrutto di ciclo che restituisce un valore non banale\n"
"  valore. Questo perch√© √® garantito che venga inserito almeno una volta (a differenza di\n"
"  cicli `while` e `for`)."

#: src/control-flow/match-expressions.md:1
#, fuzzy
msgid "# `match` expressions"
msgstr "# Espressioni `match`"

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The [`match` keyword](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n"
"is used to match a value against one or more patterns. In that sense, it works\n"
"like a series of `if let` expressions:"
msgstr ""
"La [parola chiave `match`](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n"
"viene utilizzato per confrontare un valore con uno o pi√π modelli. In questo senso funziona\n"
"come una serie di espressioni `if let`:"

#: src/control-flow/match-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/match-expressions.md:20
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Come `if let`, ogni braccio di corrispondenza deve avere lo stesso tipo. Il tipo √® l'ultimo\n"
"espressione del blocco, se esiste. Nell'esempio precedente, il tipo √® `()`."

#: src/control-flow/match-expressions.md:28
#, fuzzy
msgid ""
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::args().next()` returns an `Option<String>`, but we cannot match against "
"`String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, this turns "
"`Option<String>` into `Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside `Option`."
msgstr ""
"* Salva l'espressione di corrispondenza in una variabile e stampala.\n"
"* Rimuovi `.as_deref()` e spiega l'errore.\n"
"    * `std::env::args().next()` restituisce un `Option<String>`, ma non possiamo confrontare "
"`String`.\n"
"    * `as_deref()` trasforma una `Opzione<T>` in `Opzione<&T::Target>`. Nel nostro caso, questo "
"trasforma `Option<String>` in `Option<&str>`.\n"
"    * Ora possiamo usare il pattern matching per confrontare con `&str` all'interno di `Option`."

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "# `break` and `continue`"
msgstr "# `interrompi` e `continua`"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"- If you want to exit a loop early, use [`break`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#break-expressions),\n"
"- If you want to immediately start\n"
"the next iteration use [`continue`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#continue-expressions)."
msgstr ""
"- Se vuoi uscire prima da un ciclo, usa [`break`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#break-expressions),\n"
"- Se vuoi iniziare subito\n"
"l'iterazione successiva usa [`continue`](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#continue-expressions)."

#: src/control-flow/break-continue.md:7
#, fuzzy
msgid ""
"Both `continue` and `break` can optionally take a label argument which is used\n"
"to break out of nested loops:"
msgstr ""
"Sia `continue` che `break` possono facoltativamente accettare un argomento label che viene "
"utilizzato\n"
"per uscire dai cicli nidificati:"

#: src/control-flow/break-continue.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:28
#, fuzzy
msgid "In this case we break the outer loop after 3 iterations of the inner loop."
msgstr "In questo caso interrompiamo il ciclo esterno dopo 3 iterazioni del ciclo interno."

#: src/std.md:1
#, fuzzy
msgid "# Standard Library"
msgstr "# Libreria standard"

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common types\n"
"used by Rust library and programs. This way, two libraries can work together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust viene fornito con una libreria standard che aiuta a stabilire un insieme di tipi comuni\n"
"utilizzato dalla libreria e dai programmi Rust. In questo modo, due librerie possono lavorare "
"insieme\n"
"senza problemi perch√© entrambi usano lo stesso tipo `Stringa`."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "I tipi di vocabolario comuni includono:"

#: src/std.md:9
#, fuzzy
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional values\n"
"  and [error handling](error-handling.md).\n"
"\n"
"* [`String`](std/string.md): the default string type used for owned data.\n"
"\n"
"* [`Vec`](std/vec.md): a standard extensible vector.\n"
"\n"
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm.\n"
"\n"
"* [`Box`](std/box.md): an owned pointer for heap-allocated data.\n"
"\n"
"* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated data."
msgstr ""
"* [Tipi `Option` e `Result`](std/option-result.md): usati per valori facoltativi\n"
"  e [gestione degli errori](error-handling.md).\n"
"\n"
"* [`String`](std/string.md): il tipo di stringa predefinito utilizzato per i dati di propriet√†.\n"
"\n"
"* [`Vec`](std/vec.md): un vettore estensibile standard.\n"
"\n"
"* [`HashMap`](std/hashmap.md): un tipo di mappa hash con un hash configurabile\n"
"  algoritmo.\n"
"\n"
"* [`Box`](std/box.md): un puntatore di propriet√† per i dati allocati nell'heap.\n"
"\n"
"* [`Rc`](std/rc.md): un puntatore con conteggio dei riferimenti condiviso per i dati allocati "
"nell'heap."

#: src/std.md:25
#, fuzzy
msgid ""
"  * In fact, Rust contains several layers of the Standard Library: `core`, `alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on `libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as `Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"  * Infatti, Rust contiene diversi strati della Libreria Standard: `core`, `alloc` e `std`.\n"
"  * `core` include i tipi e le funzioni pi√π basilari che non dipendono da `libc`, allocator o\n"
"    anche la presenza di un sistema operativo.\n"
"  * `alloc` include tipi che richiedono un allocatore heap globale, come `Vec`, `Box` e `Arc`.\n"
"  * Le applicazioni embedded di Rust spesso usano solo `core` e talvolta `alloc`."

#: src/std/option-result.md:1
#, fuzzy
msgid "# `Option` and `Result`"
msgstr "# `Opzione` e `Risultato`"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "I tipi rappresentano dati facoltativi:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/option-result.md:18
#, fuzzy
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should be inserted."
msgstr ""
"* `Option` e `Result` sono ampiamente usati non solo nella libreria standard.\n"
"* `Option<&T>` ha un sovraccarico di spazio pari a zero rispetto a `&T`.\n"
"* `Result` √® il tipo standard per implementare la gestione degli errori, come vedremo il giorno "
"3.\n"
"* `binary_search` restituisce `Result<usize, usize>`.\n"
"  * Se trovato, `Result::Ok` contiene l'indice in cui si trova l'elemento.\n"
"  * Altrimenti, `Result::Err` contiene l'indice in cui tale elemento dovrebbe essere inserito."

#: src/std/string.md:1
#, fuzzy
msgid "# String"
msgstr "# Corda"

#: src/std/string.md:3
#, fuzzy
msgid "[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr "[`String`][1] √® il buffer di stringa UTF-8 espandibile allocato nell'heap standard:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"üá®üá≠\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can call all\n"
"`str` methods on a `String`."
msgstr ""
"`String` implementa [`Deref<Target = str>`][2], il che significa che puoi chiamare tutti\n"
"metodi `str` su una `stringa`."

#: src/std/string.md:30
msgid ""
"* `String::new` returns a new empty string, use `String::with_capacity` when you know how much "
"data you want to push to the string.\n"
"* `String::len` returns the size of the `String` in bytes (which can be different from its length "
"in characters).\n"
"* `String::chars` returns an iterator over the actual characters. Note that a `char` can be "
"different from what a human will consider a \"character\" due to [grapheme clusters](https://docs."
"rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html).\n"
"*  When people refer to strings they could either be talking about `&str` or `String`.  \n"
"* When a type implements `Deref<Target = T>`, the compiler will let you transparently call methods "
"from `T`.\n"
"    * `String` implements `Deref<Target = str>` which transparently gives it access to `str`'s "
"methods.\n"
"    * Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;.\n"
"* `String` is implemented as a wrapper around a vector of bytes, many of the operations you see "
"supported on vectors are also supported on `String`, but with some extra guarantees.\n"
"* Compare the different ways to index a `String`:\n"
"    * To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, out-of-bounds.\n"
"    * To a substring by using `s3[0..4]`, where that slice is on character boundaries or not."
msgstr ""

#: src/std/vec.md:1
#, fuzzy
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
#, fuzzy
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[`Vec`][1] √® il buffer ridimensionabile allocato nell'heap standard:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call slice\n"
"methods on a `Vec`."
msgstr ""
"`Vec` implementa [`Deref<Target = [T]>`][2], il che significa che puoi chiamare slice\n"
"metodi su un `Vec`."

#: src/std/vec.md:37
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data it contains is "
"stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at compile time. It can "
"grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` explicitly. As "
"always\n"
"  with Rust type inference, the `T` was established during the first `push` call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""

#: src/std/hashmap.md:1
#, fuzzy
msgid "# `HashMap`"
msgstr "# `Mappa hash`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Mappa hash standard con protezione dagli attacchi HashDoS:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les Mis√©rables\") {\n"
"        println!(\"We know about {} books, but not Les Mis√©rables.\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string()).or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
msgid ""
"* `HashMap` is not defined in the prelude and needs to be brought into scope.\n"
"* Try the following lines of code. The first line will see if a book is in the hashmap and if not "
"return an alternative value. The second line will insert the alternative value in the hashmap if "
"the book is not found.\n"
"\n"
"     ```rust,ignore\n"
"       let pc1 = page_counts\n"
"           .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"           .unwrap_or(&336);\n"
"       let pc2 = page_counts\n"
"           .entry(\"The Hunger Games\".to_string())\n"
"           .or_insert(374);\n"
"       ```\n"
"* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.\n"
"  * Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1], which allows us to "
"easily initialize a hash map from a literal array:\n"
"\n"
"     ```rust,ignore\n"
"       let page_counts = HashMap::from([\n"
"         (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"         (\"The Hunger Games\".to_string(), 374),\n"
"       ]);\n"
"       ```\n"
"\n"
" * Alternatively HashMap can be built from any `Iterator` which yields key-value tuples.\n"
"* We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make examples easier. "
"Using references in collections can, of course, be done,\n"
"  but it can lead into complications with the borrow checker.\n"
"  * Try removing `to_string()` from the example above and see if it still compiles. Where do you "
"think we might run into issues?"
msgstr ""

#: src/std/box.md:1
#, fuzzy
msgid "# `Box`"
msgstr "# `Scatola`"

#: src/std/box.md:3
#, fuzzy
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1] √® un puntatore di propriet√† ai dati sull'heap:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"`Box<T>` implementa `Deref<Target = T>`, il che significa che puoi [chiamare metodi\n"
"da `T` direttamente su un `Box<T>`][2]."

#: src/std/box.md:34
#, fuzzy
msgid ""
"* `Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be not null. \n"
"* In the above example, you can even leave out the `*` in the `println!` statement thanks to "
"`Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the Rust compiler wants to "
"know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying large amounts of data "
"on the stack, instead store the data on the heap in a `Box` so only the pointer is moved."
msgstr ""
"* `Box` √® come `std::unique_ptr` in C++, tranne per il fatto che √® garantito che non sia nullo.\n"
"* Nell'esempio sopra, puoi anche tralasciare `*` nell'istruzione `println!` grazie a `Deref`.\n"
"* Una `Box` pu√≤ essere utile quando:\n"
"   * hanno un tipo la cui dimensione non pu√≤ essere conosciuta in fase di compilazione, ma il "
"compilatore Rust vuole conoscere una dimensione esatta.\n"
"   * desidera trasferire la propriet√† di una grande quantit√† di dati. Per evitare di copiare "
"grandi quantit√† di dati nello stack, archivia invece i dati nell'heap in un \"Box\" in modo che "
"venga spostato solo il puntatore."

#: src/std/box-recursive.md:1
#, fuzzy
msgid "# Box with Recursive Data Structures"
msgstr "# Box con strutture dati ricorsive"

#: src/std/box-recursive.md:3
#, fuzzy
msgid "Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"I tipi di dati ricorsivi o i tipi di dati con dimensioni dinamiche devono utilizzare un `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // |   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"* If the `Box` was not used here and we attempted to embed a `List` directly into the `List`,\n"
"the compiler would not compute a fixed size of the struct in memory, it would look infinite.\n"
"\n"
"* `Box` solves this problem as it has the same size as a regular pointer and just points at the "
"next\n"
"element of the `List` in the heap.\n"
"\n"
"* Remove the `Box` in the List definition and show the compiler error. \"Recursive with "
"indirection\" is a hint you might want to use a Box or reference of some kind, instead of storing "
"a value directly.   \n"
"    "
msgstr ""
"* Se la `Box` non √® stata utilizzata qui e abbiamo tentato di incorporare una `Lista` direttamente "
"nella `Lista`,\n"
"il compilatore non calcolerebbe una dimensione fissa della struttura in memoria, sembrerebbe "
"infinita.\n"
"\n"
"* `Box` risolve questo problema poich√© ha le stesse dimensioni di un normale puntatore e punta "
"solo al successivo\n"
"elemento della \"Lista\" nell'heap.\n"
"\n"
"* Rimuovi il `Box` nella definizione dell'elenco e mostra l'errore del compilatore. \"Ricorsivo "
"con indiretto\" √® un suggerimento che potresti voler utilizzare un Box o un riferimento di qualche "
"tipo, invece di memorizzare direttamente un valore.\n"
"    "

#: src/std/box-niche.md:1
#, fuzzy
msgid "# Niche Optimization"
msgstr "# Ottimizzazione di nicchia"

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"Un `Box` non pu√≤ essere vuoto, quindi il puntatore √® sempre valido e non `null`. Questo\n"
"consente al compilatore di ottimizzare il layout della memoria:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                             :\n"
":    list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null |             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/std/rc.md:1
#, fuzzy
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to refer\n"
"to the same data from multiple places:"
msgstr ""
"[`Rc`][1] √® un puntatore condiviso con conteggio dei riferimenti. Usalo quando hai bisogno di fare "
"riferimento\n"
"agli stessi dati da pi√π posizioni:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/rc.md:18
#, fuzzy
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create cycles\n"
"  that will get dropped."
msgstr ""
"* Se hai bisogno di mutare i dati all'interno di un `Rc`, dovrai racchiudere i dati\n"
"  un tipo come [`Cell` o `RefCell`][2].\n"
"* Vedere [`Arc`][3] se ci si trova in un contesto multi-thread.\n"
"* Puoi *declassare* un puntatore condiviso in un puntatore [`Weak`][4] per creare cicli\n"
"  che verr√† abbandonato."

#: src/std/rc.md:31
#, fuzzy
msgid ""
"* `Rc`'s count ensures that its contained value is valid for as long as there are references.\n"
"* Like C++'s `std::shared_ptr`.\n"
"* `Rc::clone` is cheap: it creates a pointer to the same allocation and increases the reference "
"count. Does not make a deep clone and can generally be ignored when looking for performance issues "
"in code.\n"
"* `make_mut` actually clones the inner value if necessary (\"clone-on-write\") and returns a "
"mutable reference.\n"
"* Use `Rc::strong_count` to check the reference count.\n"
"* Compare the different datatypes mentioned. `Box` enables (im)mutable borrows that are enforced "
"at compile time. `RefCell` enables (im)mutable borrows that are enforced at run time and will "
"panic if it fails at runtime.\n"
"* `Rc::downgrade` gives you a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* Il conteggio di `Rc` assicura che il suo valore contenuto sia valido finch√© ci sono "
"riferimenti.\n"
"* Come `std::shared_ptr` di C++.\n"
"* `Rc::clone` √® economico: crea un puntatore alla stessa allocazione e aumenta il conteggio dei "
"riferimenti. Non crea un clone profondo e generalmente pu√≤ essere ignorato quando si cercano "
"problemi di prestazioni nel codice.\n"
"* `make_mut` in realt√† clona il valore interno se necessario (\"clone-on-write\") e restituisce un "
"riferimento mutabile.\n"
"* Usa `Rc::strong_count` per controllare il conteggio dei riferimenti.\n"
"* Confronta i diversi tipi di dati menzionati. `Box` abilita i prestiti (im)mutabili che vengono "
"applicati in fase di compilazione. `RefCell` abilita i prestiti (im)mutabili che vengono applicati "
"in fase di esecuzione e andranno in panico se falliscono in fase di esecuzione.\n"
"* `Rc::downgrade` fornisce un oggetto *debolmente contato* a\n"
"  creare cicli che verranno eliminati correttamente (probabilmente in combinazione con\n"
"  `RefCella`)."

#: src/std/rc.md:41
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;\n"
"\n"
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:1
#, fuzzy
msgid "# Modules"
msgstr "# Moduli"

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Abbiamo visto come i blocchi `impl` ci permettono di utilizzare lo spazio dei nomi per un tipo."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "Allo stesso modo, `mod` ci consente tipi e funzioni dello spazio dei nomi:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:28
#, fuzzy
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that describes how to build a "
"bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable and a library crate "
"compiles to a library.\n"
"* Modules define organization, scope, and are the focus of this section."
msgstr ""
"* I pacchetti forniscono funzionalit√† e includono un file `Cargo.toml` che descrive come costruire "
"un pacchetto di 1+ casse.\n"
"* I crate sono un albero di moduli, in cui un crate binario crea un eseguibile e un crate di "
"libreria viene compilato in una libreria.\n"
"* I moduli definiscono l'organizzazione, l'ambito e sono il fulcro di questa sezione."

#: src/modules/visibility.md:1
#, fuzzy
msgid "# Visibility"
msgstr "# Visibilit√†"

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "I moduli sono un limite di privacy:"

#: src/modules/visibility.md:5
#, fuzzy
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all the\n"
"  descendants of `foo`."
msgstr ""
"* Gli elementi del modulo sono privati per impostazione predefinita (nasconde i dettagli di "
"implementazione).\n"
"* Gli elementi dei genitori e dei fratelli sono sempre visibili.\n"
"* In altre parole, se un elemento √® visibile nel modulo `foo`, √® visibile in tutti i file\n"
"  discendenti di `foo`."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:39
#, fuzzy
msgid "* Use the `pub` keyword to make modules public."
msgstr "* Usa la parola chiave `pub` per rendere pubblici i moduli."

#: src/modules/visibility.md:41
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope of public visibility."
msgstr ""
"Inoltre, ci sono specificatori avanzati `pub(...)` per restringere l'ambito della visibilit√† "
"pubblica."

#: src/modules/visibility.md:43
#, fuzzy
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-"
"path-pubcrate-pubsuper-and-pubself).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of its descendants)."
msgstr ""
"* Vedere il [riferimento Rust](https://doc.rust-lang.org/reference/visibility-and-privacy."
"html#pubin-path-pubcrate-pubsuper-and-pubself).\n"
"* La configurazione della visibilit√† di `pub(crate)` √® un modello comune.\n"
"* Meno comunemente, puoi dare visibilit√† a un percorso specifico.\n"
"* In ogni caso, la visibilit√† deve essere concessa a un modulo predecessore (ea tutti i suoi "
"discendenti)."

#: src/modules/paths.md:1
#, fuzzy
msgid "# Paths"
msgstr "# Percorsi"

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "I percorsi sono risolti come segue:"

#: src/modules/paths.md:5
#, fuzzy
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module.\n"
"\n"
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"1. Come percorso relativo:\n"
"   * `foo` o `self::foo` si riferisce a `foo` nel modulo corrente,\n"
"   * `super::foo` fa riferimento a `foo` nel modulo genitore.\n"
"\n"
"2. Come percorso assoluto:\n"
"   * `crate::foo` fa riferimento a `foo` nella radice del crate corrente,\n"
"   * `bar::foo` si riferisce a `foo` nella cassa `bar`."

#: src/modules/paths.md:13
#, fuzzy
msgid ""
"A module can bring symbols from another module into scope with `use`.\n"
"You will typically see something like this at the top of each module:"
msgstr ""
"Un modulo pu√≤ portare i simboli di un altro modulo nell'ambito con `use`.\n"
"In genere vedrai qualcosa di simile nella parte superiore di ogni modulo:"

#: src/modules/paths.md:16
msgid ""
"```rust,editable\n"
"use std::collections::HashSet;\n"
"use std::mem::transmute;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:1
#, fuzzy
msgid "# Filesystem Hierarchy"
msgstr "# Gerarchia del file system"

#: src/modules/filesystem.md:3
#, fuzzy
msgid "The module content can be omitted:"
msgstr "Il contenuto del modulo pu√≤ essere omesso:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
#, fuzzy
msgid "The `garden` module content is found at:"
msgstr "Il contenuto del modulo `garden` si trova in:"

#: src/modules/filesystem.md:11
#, fuzzy
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden.rs` (moderno stile Rust 2018)\n"
"* `src/garden/mod.rs` (vecchio stile Rust 2015)"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "Allo stesso modo, un modulo `garden::vegetables` pu√≤ essere trovato in:"

#: src/modules/filesystem.md:16
#, fuzzy
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden/vegetables.rs` (moderno stile Rust 2018)\n"
"* `src/garden/vegetables/mod.rs` (vecchio stile Rust 2015)"

#: src/modules/filesystem.md:19
#, fuzzy
msgid "The `crate` root is in:"
msgstr "La radice di `crate` √® in:"

#: src/modules/filesystem.md:21
#, fuzzy
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* `src/lib.rs` (per un crate di libreria)\n"
"* `src/main.rs` (per una cassa binaria)"

#: src/modules/filesystem.md:24
#, fuzzy
msgid ""
"Modules defined in files can be documented, too, using \"inner doc comments\".\n"
"These document the item that contains them -- in this case, a module."
msgstr ""
"Anche i moduli definiti nei file possono essere documentati utilizzando \"commenti interni al "
"documento\".\n"
"Questi documentano l'elemento che li contiene, in questo caso un modulo."

#: src/modules/filesystem.md:27
msgid ""
"```rust,editable,compile_fail\n"
"//! This module implements the garden, including a highly performant germination\n"
"//! implementation.\n"
"\n"
"// Re-export types from this module.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sow the given seed packets.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
"\n"
"/// Harvest the produce in the garden that is ready.\n"
"pub fn harvest(garden: &mut Garden) { todo!() }\n"
"```"
msgstr ""

#: src/modules/filesystem.md:44
msgid ""
"* The change from `module/mod.rs` to `module.rs` doesn't preclude the use of submodules in Rust "
"2018.\n"
"  (It was mandatory in Rust 2015.)\n"
"\n"
"  The following is valid:\n"
"\n"
"  ```ignore\n"
"  src/\n"
"  ‚îú‚îÄ‚îÄ main.rs\n"
"  ‚îú‚îÄ‚îÄ top_module.rs\n"
"  ‚îî‚îÄ‚îÄ top_module/\n"
"      ‚îî‚îÄ‚îÄ sub_module.rs\n"
"  ```\n"
"\n"
"* The main reason for the change is to prevent many files named `mod.rs`, which can be hard\n"
"  to distinguish in IDEs.\n"
"\n"
"* Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but this can be changed\n"
"  with a compiler directive:\n"
"\n"
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```\n"
"\n"
"  This is useful, for example, if you would like to place tests for a module in a file named\n"
"  `some_module_test.rs`, similar to the convention in Go."
msgstr ""

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "# Day 2: Afternoon Exercises"
msgstr "# Giorno 2: Esercizi pomeridiani"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "Gli esercizi di questo pomeriggio si concentreranno su stringhe e iteratori."

#: src/exercises/day-2/luhn.md:1
#, fuzzy
msgid "# Luhn Algorithm"
msgstr "# Algoritmo di Luhn"

#: src/exercises/day-2/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to\n"
"validate credit card numbers. The algorithm takes a string as input and does the\n"
"following to validate the credit card number:"
msgstr ""
"L'[algoritmo di Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) viene utilizzato per\n"
"convalidare i numeri di carta di credito. L'algoritmo prende una stringa come input e fa il\n"
"seguente per convalidare il numero della carta di credito:"

#: src/exercises/day-2/luhn.md:7
#, fuzzy
msgid ""
"* Ignore all spaces. Reject number with less than two digits.\n"
"\n"
"* Moving from right to left, double every second digit: for the number `1234`,\n"
"  we double `3` and `1`.\n"
"\n"
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` which\n"
"  becomes `5`.\n"
"\n"
"* Sum all the undoubled and doubled digits.\n"
"\n"
"* The credit card number is valid if the sum ends with `0`."
msgstr ""
"* Ignora tutti gli spazi. Rifiuta il numero con meno di due cifre.\n"
"\n"
"* Spostandoti da destra a sinistra, raddoppia ogni seconda cifra: per il numero `1234`,\n"
"  raddoppiamo \"3\" e \"1\".\n"
"\n"
"* Dopo aver raddoppiato una cifra, somma le cifre. Quindi raddoppiando \"7\" diventa \"14\" which\n"
"  diventa \"5\".\n"
"\n"
"* Somma tutte le cifre non raddoppiate e raddoppiate.\n"
"\n"
"* Il numero della carta di credito √® valido se la somma termina con `0`."

#: src/exercises/day-2/luhn.md:19
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"Copia il seguente codice in <https://play.rust-lang.org/> e implementa il file\n"
"funzione:"

#: src/exercises/day-2/luhn.md:23
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:1
#, fuzzy
msgid "# Strings and Iterators"
msgstr "# Stringhe e iteratori"

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. The\n"
"server is configured with a number of _path prefixes_ which are matched against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"In questo esercizio, implementerai un componente di instradamento di un server web. IL\n"
"il server √® configurato con un numero di _prefissi di percorso_ che vengono confrontati\n"
"_percorsi di richiesta_. I prefissi di percorso possono contenere un carattere jolly che\n"
"corrisponde a un segmento completo. Vedere i test unitari di seguito."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copia il seguente codice in <https://play.rust-lang.org/> ed esegui i test\n"
"passaggio. Prova a evitare di assegnare un `Vec` per i tuoi risultati intermedi:"

#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-3.md:1
#, fuzzy
msgid "# Welcome to Day 3"
msgstr "# Benvenuto al giorno 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Oggi tratteremo alcuni argomenti pi√π avanzati di Rust:"

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits.\n"
"\n"
"* Generics: generic data types, generic methods, monomorphization, and trait\n"
"  objects.\n"
"\n"
"* Error handling: panics, `Result`, and the try operator `?`.\n"
"\n"
"* Testing: unit tests, documentation tests, and integration tests.\n"
"\n"
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""
"* Tratti: tratti derivati, metodi predefiniti e importante libreria standard\n"
"  tratti.\n"
"\n"
"* Generici: tipi di dati generici, metodi generici, monomorfizzazione e tratto\n"
"  oggetti.\n"
"\n"
"* Gestione degli errori: panic, `Result` e l'operatore try `?`.\n"
"\n"
"* Test: unit test, test di documentazione e test di integrazione.\n"
"\n"
"* Unsafe Rust: puntatori grezzi, variabili statiche, funzioni non sicure ed extern\n"
"  funzioni."

#: src/generics.md:1
#, fuzzy
msgid "# Generics"
msgstr "# Generici"

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as sorting)\n"
"over the types used in the algorithm."
msgstr ""
"Rust supporta i generici, che ti consentono di astrarre un algoritmo (come l'ordinamento)\n"
"sui tipi utilizzati nell'algoritmo."

#: src/generics/data-types.md:1
#, fuzzy
msgid "# Generic Data Types"
msgstr "# Tipi di dati generici"

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Puoi utilizzare i generici per astrarre sul tipo di campo concreto:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/data-types.md:21
msgid ""
"* Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`.\n"
"\n"
"* Fix the code to allow points that have elements of different types."
msgstr ""

#: src/generics/methods.md:1
#, fuzzy
msgid "# Generic Methods"
msgstr "# Metodi generici"

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "Puoi dichiarare un tipo generico sul tuo blocco `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that redundant?\n"
"    * This is because it is a generic implementation section for generic type. They are "
"independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods in this block will only "
"be available for `Point<u32>`."
msgstr ""
"* *D:* Perch√© `T` √® specificato due volte in `impl<T> Point<T> {}`? Non √® ridondante?\n"
"    * Questo perch√© si tratta di una sezione di implementazione generica per un tipo generico. "
"Sono indipendentemente generici.\n"
"    * Significa che questi metodi sono definiti per qualsiasi `T`.\n"
"    * √à possibile scrivere `impl Point<u32> { .. }`.\n"
"      * `Point` √® ancora generico e puoi usare `Point<f64>`, ma i metodi in questo blocco saranno "
"disponibili solo per `Point<u32>`."

#: src/generics/monomorphization.md:1
#, fuzzy
msgid "# Monomorphization"
msgstr "# Monomorfizzazione"

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr "Il codice generico viene trasformato in codice non generico in base ai siti di chiamata:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "si comporta come se scrivessi"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"\n"
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"Questa √® un'astrazione a costo zero: ottieni esattamente lo stesso risultato che se avessi\n"
"codificato a mano le strutture dati senza l'astrazione."

#: src/traits.md:1
#, fuzzy
msgid "# Traits"
msgstr "# Tratti"

#: src/traits.md:3
#, fuzzy
msgid "Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "Rust ti consente di astrarre sui tipi con tratti. Sono simili alle interfacce:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it anyway.\n"
"    }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &P) {\n"
"    println!(\"Who's a cutie? {} is!\", pet.name());\n"
"}\n"
"\n"
"fn main() {\n"
"    let fido = Dog { name: \"Fido\".into() };\n"
"    greet(&fido);\n"
"\n"
"    let captain_floof = Cat;\n"
"    greet(&captain_floof);\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:1
#, fuzzy
msgid "# Trait Objects"
msgstr "# Oggetti tratto"

#: src/traits/trait-objects.md:3
#, fuzzy
msgid "Trait objects allow for values of different types, for instance in a collection:"
msgstr "Gli oggetti tratto consentono valori di tipi diversi, ad esempio in una raccolta:"

#: src/traits/trait-objects.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it anyway.\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec<Box<dyn Pet>> = vec![\n"
"        Box::new(Cat),\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Hello {}!\", pet.name());\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:40
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Layout della memoria dopo l'allocazione di \"animali domestici\":"

#: src/traits/trait-objects.md:42
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  |           :\n"
":                           :     :     | |   |     +---------------+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                 :\n"
"                                  :     | |   |     +----------------------+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" |    :\n"
"                                  :     | |         +----------------------+    : \n"
"                                  :     | |                                     : \n"
"                                  :     | |   +-+                               :   \n"
"                                  :     | '-->|\\|                               :     \n"
"                                  :     |     +-+                               :    \n"
"                                  :     |                                       : \n"
"                                  :     |     +----------------------+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" |          : \n"
"                                  :           +----------------------+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:72
msgid ""
"* Types that implement a given trait may be of different sizes. This makes it impossible to have "
"things like `Vec<Pet>` in the example above.\n"
"* `dyn Pet` is a way to tell the compiler about a dynamically sized type that implements `Pet`.\n"
"* In the example, `pets` holds *fat pointers* to objects that implement `Pet`. The fat pointer "
"consists of two components, a pointer to the actual object and a pointer to the virtual method "
"table for the `Pet` implementation of that particular object.\n"
"* Compare these outputs in the above example:\n"
"     ```rust,ignore\n"
"         println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"         println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"         println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"         println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
"     ```"
msgstr ""

#: src/traits/deriving-traits.md:1
#, fuzzy
msgid "# Deriving Traits"
msgstr "# Tratti derivati"

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid "You can let the compiler derive a number of traits:"
msgstr "Puoi lasciare che il compilatore derivi una serie di tratti:"

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:1
#, fuzzy
msgid "# Default Methods"
msgstr "# Metodi predefiniti"

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "I tratti possono implementare il comportamento in termini di altri metodi di tratto:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimeter(i16);\n"
"\n"
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:32
#, fuzzy
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that users are required to\n"
"  implement themselves. Methods with default implementations can rely on required methods.\n"
"\n"
"* Move method `not_equal` to a new trait `NotEqual`.\n"
"\n"
"* Make `NotEqual` a super trait for `Equal`.\n"
"\n"
"* Provide a blanket implementation of `NotEqual` for `Equal`.\n"
"  * With the blanket implementation, you no longer need `NotEqual` as a super trait for `Equal`."
msgstr ""
"* I tratti possono specificare metodi pre-implementati (predefiniti) e metodi richiesti agli "
"utenti\n"
"  implementare se stessi. I metodi con implementazioni predefinite possono fare affidamento sui "
"metodi richiesti.\n"
"\n"
"* Sposta il metodo `not_equal` in un nuovo tratto `NotEqual`.\n"
"\n"
"* Rendi `NotEqual` un super tratto per `Equal`.\n"
"\n"
"* Fornire un'implementazione globale di \"NotEqual\" per \"Equal\".\n"
"  * Con l'implementazione coperta, non hai pi√π bisogno di \"NotEqual\" come super tratto per "
"\"Equal\"."

#: src/traits/trait-bounds.md:1
#, fuzzy
msgid "# Trait Bounds"
msgstr "# Limiti dei tratti"

#: src/traits/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to implement\n"
"some trait, so that you can call this trait's methods."
msgstr ""
"Quando si lavora con i generici, spesso si desidera richiedere i tipi da implementare\n"
"qualche tratto, in modo da poter chiamare i metodi di questo tratto."

#: src/traits/trait-bounds.md:6
#, fuzzy
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Puoi farlo con `T: Trait` o `impl Trait`:"

#: src/traits/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:35
#, fuzzy
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr "Mostra una clausola `where`, gli studenti la incontreranno durante la lettura del codice."

#: src/traits/trait-bounds.md:37
msgid ""
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:46
#, fuzzy
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of \":\" can be arbitrary, "
"like `Option<T>`.\n"
"    "
msgstr ""
"* Riordina la firma della funzione se hai molti parametri.\n"
"* Ha funzionalit√† aggiuntive che lo rendono pi√π potente.\n"
"    * Se qualcuno lo chiede, la caratteristica extra √® che il tipo a sinistra di \":\" pu√≤ essere "
"arbitrario, come `Option<T>`.\n"
"    "

#: src/traits/impl-trait.md:1
#, fuzzy
msgid "# `impl Trait`"
msgstr "# `Impl Tratto`"

#: src/traits/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"Simile ai limiti dei tratti, in funzione pu√≤ essere utilizzata una sintassi `impl Trait`\n"
"argomenti e valori restituiti:"

#: src/traits/impl-trait.md:6
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/impl-trait.md:19
#, fuzzy
msgid "* `impl Trait` allows you to work with types which you cannot name."
msgstr "* `impl Trait` ti permette di lavorare con tipi che non puoi nominare."

#: src/traits/impl-trait.md:23
#, fuzzy
msgid "The meaning of `impl Trait` is a bit different in the different positions."
msgstr "Il significato di \"impl Trait\" √® leggermente diverso nelle diverse posizioni."

#: src/traits/impl-trait.md:25
#, fuzzy
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with a trait bound.\n"
"\n"
"* For a return type, it means that the return type is some concrete type that implements the "
"trait,\n"
"  without naming the type. This can be useful when you don't want to expose the concrete type in "
"a\n"
"  public API.\n"
"\n"
"  Inference is hard in return position. A function returning `impl Foo` picks\n"
"  the concrete type it returns, without writing it out in the source. A function\n"
"  returning a generic type like `collect<B>() -> B` can return any type\n"
"  satisfying `B`, and the caller may need to choose one, such as with `let x:\n"
"  Vec<_> = foo.collect()` or with the turbofish, `foo.collect::<Vec<_>>()`."
msgstr ""
"* Per un parametro, `impl Trait` √® come un parametro generico anonimo con un tratto associato.\n"
"\n"
"* Per un tipo restituito, significa che il tipo restituito √® un tipo concreto che implementa il "
"tratto,\n"
"  senza nominare il tipo. Questo pu√≤ essere utile quando non vuoi esporre il tipo concreto in a\n"
"  API pubblica.\n"
"\n"
"  L'inferenza √® difficile nella posizione di ritorno. Una funzione che restituisce le scelte `impl "
"Foo`\n"
"  il tipo concreto che restituisce, senza scriverlo nella fonte. Una funzione\n"
"  restituire un tipo generico come `collect<B>() -> B` pu√≤ restituire qualsiasi tipo\n"
"  soddisfacente `B`, e il chiamante potrebbe aver bisogno di sceglierne uno, come con `let x:\n"
"  Vec<_> = foo.collect()` o con il turbofish, `foo.collect::<Vec<_>>()`."

#: src/traits/impl-trait.md:37
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` type are the same "
"type.\n"
"It would not work for this particular function, as the type we expect as input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, we'd need two\n"
"independent generic parameters."
msgstr ""
"Questo esempio √® fantastico, perch√© utilizza `impl Display` due volte. Aiuta a spiegarlo\n"
"nulla qui impone che sia _lo stesso_ tipo `impl Display`. Se usiamo un singolo\n"
"`T: Display`, imporrebbe il vincolo secondo cui l'input `T` e il tipo restituito `T` sono dello "
"stesso tipo.\n"
"Non funzionerebbe per questa particolare funzione, poich√© probabilmente non lo √® il tipo che ci "
"aspettiamo come input\n"
"quale `formato!` restituisce. Se volessimo fare lo stesso tramite la sintassi `: Display`, ne "
"avremmo bisogno di due\n"
"parametri generici indipendenti."

#: src/traits/important-traits.md:1
#, fuzzy
msgid "# Important Traits"
msgstr "# Tratti importanti"

#: src/traits/important-traits.md:3
#, fuzzy
msgid "We will now look at some of the most common traits of the Rust standard library:"
msgstr "Vedremo ora alcuni dei tratti pi√π comuni della libreria standard di Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* [`Iterator`][1] e [`IntoIterator`][2] usati nei cicli `for`,\n"
"* [`From`][3] e [`Into`][4] utilizzati per convertire i valori,\n"
"* [`Read`][5] e [`Write`][6] usati per IO,\n"
"* [`Add`][7], [`Mul`][8], ... utilizzato per l'overload degli operatori e\n"
"* [`Drop`][9] usato per definire i distruttori.\n"
"* [`Default`][10] utilizzato per costruire un'istanza predefinita di un tipo."

#: src/traits/iterator.md:1
#, fuzzy
msgid "# Iterators"
msgstr "# Iteratori"

#: src/traits/iterator.md:3
#, fuzzy
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "Puoi implementare il tratto [`Iterator`][1] sui tuoi tipi:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator for Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"* The `Iterator` trait implements many common functional programming operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can find all the "
"documentation\n"
"  about them. In Rust these functions should produce the code as efficient as equivalent "
"imperative\n"
"  implementations.\n"
"    \n"
"* `IntoIterator` is the trait that makes for loops work. It is implemented by collection types "
"such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also implement it. This is "
"why\n"
"  you can iterate over a vector with `for i in some_vec { .. }` but\n"
"  `some_vec.next()` doesn't exist."
msgstr ""
"* Il tratto `Iterator` implementa molte comuni operazioni di programmazione funzionale sulle "
"raccolte\n"
"  (ad es. `map`, `filter`, `reduce`, ecc.). Questo √® il tratto in cui puoi trovare tutta la "
"documentazione\n"
"  su di loro. In Rust queste funzioni dovrebbero produrre il codice tanto efficiente quanto "
"imperativo equivalente\n"
"  implementazioni.\n"
"    \n"
"* `IntoIterator` √® la caratteristica che fa funzionare i cicli for. √à implementato da tipi di "
"raccolta come\n"
"  `Vec<T>` e riferimenti ad essi come `&Vec<T>` e `&[T]`. Anche le gamme lo implementano. Ecco "
"perch√©\n"
"  puoi iterare su un vettore con `for i in some_vec { .. }` ma\n"
"  `some_vec.next()` non esiste."

#: src/traits/from-iterator.md:1
#, fuzzy
msgid "# FromIterator"
msgstr "# FromIterator"

#: src/traits/from-iterator.md:3
#, fuzzy
msgid "[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr "[`FromIterator`][1] consente di creare una raccolta da un [`Iterator`][2]."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
#, fuzzy
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"Implementa `Iterator`\n"
"`fn collect<B>(self) -> B\n"
"Dove\n"
"    B: FromIterator<Self::Item>,\n"
"    S√©: dimensionato`"

#: src/traits/from-iterator.md:23
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Ci sono anche implementazioni che ti permettono di fare cose interessanti come convertire un file\n"
"`Iterator<Item = Result<V, E>>` in un `Result<Vec<V>, E>`."

#: src/traits/from-into.md:1
#, fuzzy
msgid "# `From` and `Into`"
msgstr "# `Da` e `Into`"

#: src/traits/from-into.md:3
#, fuzzy
msgid "Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr "I tipi implementano [`From`][1] e [`Into`][2] per facilitare le conversioni di tipo:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
#, fuzzy
msgid "[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr "[`Into`][2] viene implementato automaticamente quando [`From`][1] √® implementato:"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:29
#, fuzzy
msgid ""
"* That's why it is common to only implement `From`, as your type will get `Into` implementation "
"too.\n"
"* When declaring a function argument input type like \"anything that can be converted into a "
"`String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that _only_ implement `Into`.\n"
"    "
msgstr ""
"* Ecco perch√© √® comune implementare solo `From`, poich√© anche il tuo tipo otterr√† "
"l'implementazione di `Into`.\n"
"* Quando si dichiara un tipo di input per l'argomento di una funzione come \"qualsiasi cosa che "
"pu√≤ essere convertita in una `Stringa`\", la regola √® opposta, si dovrebbe usare `Into`.\n"
"  La tua funzione accetter√† tipi che implementano `From` e quelli che _solo_ implementano `Into`.\n"
"    "

#: src/traits/read-write.md:1
#, fuzzy
msgid "# `Read` and `Write`"
msgstr "# `Leggi` e `Scrivi`"

#: src/traits/read-write.md:3
#, fuzzy
msgid "Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "Usando [`Read`][1] e [`BufRead`][2], puoi astrarre su fonti `u8`:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
#, fuzzy
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "Allo stesso modo, [`Write`][3] ti consente di astrarre sui sink `u8`:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:1
#, fuzzy
msgid "# The `Drop` Trait"
msgstr "# Il tratto `Drop`"

#: src/traits/drop.md:3
#, fuzzy
msgid "Values which implement [`Drop`][1] can specify code to run when they go out of scope:"
msgstr ""
"I valori che implementano [`Drop`][1] possono specificare il codice da eseguire quando escono "
"dall'ambito:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:34 src/traits/operators.md:26
#, fuzzy
msgid "Discussion points:"
msgstr "Punti di discussione:"

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"* Why doesn't `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* Perch√© `Drop::drop` non accetta `self`?\n"
"    * Risposta breve: se cos√¨ fosse, `std::mem::drop` verrebbe chiamato alla fine di\n"
"        il blocco, risultando in un'altra chiamata a `Drop::drop` e uno stack\n"
"        traboccare!\n"
"* Prova a sostituire `drop(a)` con `a.drop()`."

#: src/traits/default.md:1
#, fuzzy
msgid "# The `Default` Trait"
msgstr "# Il tratto `Predefinito`"

#: src/traits/default.md:3
#, fuzzy
msgid "[`Default`][1] trait provides a default implementation of a trait."
msgstr "Il tratto [`Default`][1] fornisce un'implementazione predefinita di un tratto."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/traits/default.md:40
#, fuzzy
msgid ""
"  * It can be implemented directly or it can be derived via `#[derive(Default)]`.\n"
"  * Derived implementation will produce an instance where all fields are set to their default "
"values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values (e.g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and provides convenience "
"methods that use it."
msgstr ""
"  * Pu√≤ essere implementato direttamente o pu√≤ essere derivato tramite `#[derive(Default)]`.\n"
"  * L'implementazione derivata produrr√† un'istanza in cui tutti i campi sono impostati sui valori "
"predefiniti.\n"
"    * Ci√≤ significa che anche tutti i tipi nella struttura devono implementare `Default`.\n"
"  * I tipi Rust standard spesso implementano `Default` con valori ragionevoli (ad esempio `0`, "
"`\"\"`, ecc.).\n"
"  * La copia parziale della struttura funziona bene con default.\n"
"  * La libreria standard di Rust sa che i tipi possono implementare `Default` e fornisce comodi "
"metodi che lo utilizzano."

#: src/traits/operators.md:1
#, fuzzy
msgid "# `Add`, `Mul`, ..."
msgstr "# `Aggiungi`, `Mul`, ..."

#: src/traits/operators.md:3
#, fuzzy
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr "L'overload degli operatori √® implementato tramite i tratti in [`std::ops`][1]:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter?\n"
"    * Short answer: Type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor of a\n"
"        trait."
msgstr ""
"* Puoi implementare `Aggiungi` per `&Punto`. In quali situazioni √® utile?\n"
"    * Risposta: `Add:add` consuma `self`. Se digita \"T\" per cui sei\n"
"        l'overloading dell'operatore non √® `Copy`, dovresti considerare l'overloading\n"
"        anche l'operatore per `&T`. Ci√≤ evita inutili clonazioni sul file\n"
"        sito di chiamata.\n"
"* Perch√© `Output` √® un tipo associato? Potrebbe essere reso un parametro di tipo?\n"
"    * Risposta breve: i parametri di tipo sono controllati dal chiamante, ma\n"
"        i tipi associati (come `Output`) sono controllati dall'implementatore di a\n"
"        tratto."

#: src/traits/closures.md:1
#, fuzzy
msgid "# Closures"
msgstr "# Chiusure"

#: src/traits/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Le chiusure o le espressioni lambda hanno tipi che non possono essere nominati. Tuttavia, loro\n"
"implementare speciali [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) e\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) caratteristiche:"

#: src/traits/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;\n"
"\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""

#: src/traits/closures.md:25
#, fuzzy
msgid "If you have an `FnOnce`, you may only call it once. It might consume captured values."
msgstr "Se hai un `FnOnce`, puoi chiamarlo solo una volta. Potrebbe consumare i valori acquisiti."

#: src/traits/closures.md:27
#, fuzzy
msgid ""
"An `FnMut` might mutate captured values, so you can call it multiple times but not concurrently."
msgstr ""
"Un `FnMut` potrebbe mutare i valori catturati, quindi puoi chiamarlo pi√π volte ma non "
"contemporaneamente."

#: src/traits/closures.md:29
#, fuzzy
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures nothing at all, so it "
"can\n"
"be called multiple times concurrently."
msgstr ""
"Un \"Fn\" non consuma n√© muta i valori acquisiti, o forse non cattura nulla, quindi pu√≤ farlo\n"
"essere chiamato pi√π volte contemporaneamente."

#: src/traits/closures.md:32
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever an `FnMut` or "
"`FnOnce`\n"
"is called for."
msgstr ""
"\"FnMut\" √® un sottotipo di \"FnOnce\". \"Fn\" √® un sottotipo di \"FnMut\" e \"FnOnce\". Cio√®. "
"puoi usare un\n"
"`FnMut` ovunque sia richiesto un `FnOnce` e puoi usare un `Fn` ovunque sia `FnMut` o `FnOnce`\n"
"√® richiesto."

#: src/traits/closures.md:36
#, fuzzy
msgid "`move` closures only implement `FnOnce`."
msgstr "Le chiusure `move` implementano solo `FnOnce`."

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "# Day 3: Morning Exercises"
msgstr "# Giorno 3: Esercizi mattutini"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Progetteremo una libreria GUI classica di tratti e oggetti di tratto."

#: src/exercises/day-3/simple-gui.md:1
#, fuzzy
msgid "# A Simple GUI Library"
msgstr "# Una semplice libreria GUI"

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"Progettiamo una libreria GUI classica utilizzando la nostra nuova conoscenza dei tratti e\n"
"oggetti di tratto."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "Avremo una serie di widget nella nostra libreria:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Window`: ha un `title` e contiene altri widget.\n"
"* `Button`: ha una `label` e una funzione di callback che viene richiamata quando il\n"
"  pulsante viene premuto.\n"
"* `Etichetta`: ha una `etichetta`."

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "I widget implementeranno un tratto `Widget`, vedi sotto."

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/>, inserisci i campi mancanti\n"
"metodi `draw_into` in modo da implementare il tratto `Widget`:"

#: src/exercises/day-3/simple-gui.md:18
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr "L'output del programma sopra pu√≤ essere qualcosa di semplice come questo:"

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========\n"
"\n"
"This is a small text GUI demo.\n"
"\n"
"| Click me! |\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:142
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"Se vuoi disegnare un testo allineato, puoi usare il\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"operatori di formattazione. In particolare, nota come puoi riempire con diversi\n"
"caratteri (qui un `'/'`) e come puoi controllare l'allineamento:"

#: src/exercises/day-3/simple-gui.md:147
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:156
#, fuzzy
msgid "Using such alignment tricks, you can for example produce output like this:"
msgstr "Usando tali trucchi di allineamento, puoi ad esempio produrre un output come questo:"

#: src/exercises/day-3/simple-gui.md:158
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/error-handling.md:1
#, fuzzy
msgid "# Error Handling"
msgstr "# Gestione degli errori"

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"La gestione degli errori in Rust viene eseguita utilizzando un flusso di controllo esplicito:"

#: src/error-handling.md:5
#, fuzzy
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* Le funzioni che possono avere errori lo elencano nel loro tipo di ritorno,\n"
"* Non ci sono eccezioni."

#: src/error-handling/panics.md:1
#, fuzzy
msgid "# Panics"
msgstr "# Panico"

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "Rust attiver√† un panico se si verifica un errore fatale in fase di esecuzione:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panics.md:12
#, fuzzy
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* I panico sono per errori irrecuperabili e imprevisti.\n"
"  * I panici sono sintomi di bug nel programma.\n"
"* Usa API senza panico (come `Vec::get`) se il crash non √® accettabile."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "# Catching the Stack Unwinding"
msgstr "# Catturare lo srotolamento della pila"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid "By default, a panic will cause the stack to unwind. The unwinding can be caught:"
msgstr ""
"Per impostazione predefinita, un panico causer√† lo srotolamento dello stack. Lo svolgimento pu√≤ "
"essere catturato:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hello!\");\n"
"});\n"
"assert!(result.is_ok());\n"
"\n"
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh no!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:19
#, fuzzy
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* Questo pu√≤ essere utile nei server che dovrebbero continuare a funzionare anche se un singolo\n"
"  la richiesta va in crash.\n"
"* Questo non funziona se `panic = 'abort'` √® impostato nel tuo `Cargo.toml`."

#: src/error-handling/result.md:1
#, fuzzy
msgid "# Structured Error Handling with `Result`"
msgstr "# Gestione strutturata degli errori con `Result`"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors are\n"
"expected as part of normal operation:"
msgstr ""
"Abbiamo gi√† visto l'enumerazione `Result`. Questo √® usato in modo pervasivo quando ci sono errori\n"
"previsto come parte del normale funzionamento:"

#: src/error-handling/result.md:6
msgid ""
"```rust,editable\n"
"use std::fs::File;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where an error should never "
"happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but it is worth "
"mentioning. \n"
"    It contains a lot of convenience methods and functions that help functional-style "
"programming. \n"
"    "
msgstr ""
"  * Come con `Option`, il valore riuscito si trova all'interno di `Result`, costringendo lo "
"sviluppatore a farlo\n"
"    estrarlo esplicitamente. Questo incoraggia il controllo degli errori. Nel caso in cui non "
"dovesse mai verificarsi un errore,\n"
"    √à possibile chiamare `unwrap()` o `expect()`, e anche questo √® un segnale dell'intenzione "
"dello sviluppatore.\n"
"  * La documentazione `Result` √® una lettura consigliata. Non durante il corso, ma vale la pena "
"menzionarlo.\n"
"    Contiene molti metodi e funzioni utili che aiutano la programmazione in stile funzionale.\n"
"    "

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "# Propagating Errors with `?`"
msgstr "# Propagazione degli errori con `?`"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you turn\n"
"the common"
msgstr ""
"L'operatore try `?` viene utilizzato per restituire errori al chiamante. Ti fa girare\n"
"il comune"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "nel molto pi√π semplice"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handing code:"
msgstr "Possiamo usarlo per semplificare il nostro codice di gestione degli errori:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:50 src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, empty file, file with "
"username."
msgstr ""
"* La variabile `username` pu√≤ essere `Ok(string)` o `Err(error)`.\n"
"* Usa la chiamata `fs::write` per testare i diversi scenari: nessun file, file vuoto, file con "
"nome utente."

#: src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
#, fuzzy
msgid "# Converting Error Types"
msgstr "# Conversione dei tipi di errore"

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid "The effective expansion of `?` is a little more complicated than previously indicated:"
msgstr "L'effettiva espansione di `?` √® un po' pi√π complicata di quanto precedentemente indicato:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "funziona allo stesso modo di"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the\n"
"type returned by the function:"
msgstr ""
"La chiamata `From::from` qui significa che tentiamo di convertire il tipo di errore in\n"
"tipo restituito dalla funzione:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error for ReadUsernameError {}\n"
"\n"
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username in {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types-example.md:55
#, fuzzy
msgid ""
"It is good practice for all error types to implement `std::error::Error`, which requires `Debug` "
"and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too where possible, to "
"make\n"
"life easier for tests and consumers of your library. In this case we can't easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"√à buona pratica per tutti i tipi di errore implementare `std::error::Error`, che richiede `Debug` "
"e\n"
"`Display`. In genere √® utile per loro implementare anche `Clone` e `Eq`, ove possibile, per fare\n"
"vita pi√π facile per i test e i consumatori della tua libreria. In questo caso non possiamo farlo "
"facilmente, perch√©\n"
"`io::Error` non li implementa."

#: src/error-handling/deriving-error-enums.md:1
#, fuzzy
msgid "# Deriving Error Enums"
msgstr "# Derivazione delle enumerazioni degli errori"

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create an\n"
"error enum like we did on the previous page:"
msgstr ""
"Il crate [thiserror](https://docs.rs/thiserror/) √® un modo popolare per creare un\n"
"error enum come abbiamo fatto nella pagina precedente:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the `#[from]` attribute is "
"added).\n"
"It also works for structs."
msgstr ""
"La macro deriva di `thiserror` implementa automaticamente `std::error::Error` e facoltativamente "
"`Display`\n"
"(se vengono forniti gli attributi `#[error(...)]`) e `From` (se viene aggiunto l'attributo "
"`#[from]`).\n"
"Funziona anche per le strutture."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "Non influisce sulla tua API pubblica, il che lo rende utile per le librerie."

#: src/error-handling/dynamic-errors.md:1
#, fuzzy
msgid "# Dynamic Error Types"
msgstr "# Tipi di errori dinamici"

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"A volte vogliamo consentire la restituzione di qualsiasi tipo di errore senza scrivere la nostra "
"copertura enum\n"
"tutte le diverse possibilit√†. `std::error::Error` lo rende facile."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different error cases differently "
"in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` in the public API of "
"a\n"
"library, but it can be a good option in a program where you just want to display the error "
"message\n"
"somewhere."
msgstr ""
"Ci√≤ consente di risparmiare sul codice, ma rinuncia alla possibilit√† di gestire in modo pulito "
"diversi casi di errore in modo diverso\n"
"il programma. Pertanto, generalmente non √® una buona idea utilizzare `Box<dyn Error>` nell'API "
"pubblica di a\n"
"library, ma pu√≤ essere una buona opzione in un programma in cui si desidera solo visualizzare il "
"messaggio di errore\n"
"in qualche luogo."

#: src/error-handling/error-contexts.md:1
#, fuzzy
msgid "# Adding Context to Errors"
msgstr "# Aggiunta di contesto agli errori"

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"La cassa ampiamente utilizzata [comunque](https://docs.rs/anyhow/) pu√≤ aiutarti ad aggiungere\n"
"informazioni contestuali ai tuoi errori e ti permette di averne meno\n"
"tipi di errore personalizzati:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such it's again generally "
"not\n"
"  a good choice for the public API of a library, but is widely used in applications.\n"
"* Actual error type inside of it can be extracted for examination if necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* `comunque::Risultato<V>` √® un alias di tipo per `Risultato<V, comunque::Errore>`.\n"
"* `anyhow::Error` √® essenzialmente un wrapper attorno a `Box<dyn Error>`. In quanto tale, "
"generalmente non lo √®\n"
"  una buona scelta per l'API pubblica di una libreria, ma √® ampiamente utilizzata nelle "
"applicazioni.\n"
"* Il tipo di errore effettivo all'interno di esso pu√≤ essere estratto per l'esame, se necessario.\n"
"* La funzionalit√† fornita da `anyhow::Result<T>` potrebbe essere familiare agli sviluppatori Go, "
"in quanto fornisce\n"
"  modelli di utilizzo ed ergonomia simili a `(T, errore)` di Go."

#: src/testing.md:1
#, fuzzy
msgid "# Testing"
msgstr "# Test"

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust e Cargo sono dotati di un semplice framework di unit test:"

#: src/testing.md:5
#, fuzzy
msgid ""
"* Unit tests are supported throughout your code.\n"
"\n"
"* Integration tests are supported via the `tests/` directory."
msgstr ""
"* I test unitari sono supportati in tutto il codice.\n"
"\n"
"* I test di integrazione sono supportati tramite la directory `tests/`."

#: src/testing/unit-tests.md:1
#, fuzzy
msgid "# Unit Tests"
msgstr "# Test unitari"

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Contrassegna i test unitari con `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Usa `cargo test` per trovare ed eseguire i test unitari."

#: src/testing/test-modules.md:1
#, fuzzy
msgid "# Test Modules"
msgstr "# Moduli di prova"

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"I test unitari vengono spesso inseriti in un modulo nidificato (esegui test sul file\n"
"[Parco giochi](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
#, fuzzy
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* Questo ti consente di testare unitamente gli aiutanti privati.\n"
"* L'attributo `#[cfg(test)]` √® attivo solo quando esegui `cargo test`."

#: src/testing/doc-tests.md:1
#, fuzzy
msgid "# Documentation Tests"
msgstr "# Test di documentazione"

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust ha il supporto integrato per i test di documentazione:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
#, fuzzy
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* I blocchi di codice nei commenti `///` sono visti automaticamente come codice Rust.\n"
"* Il codice verr√† compilato ed eseguito come parte di `cargo test`.\n"
"* Prova il codice precedente su [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:1
#, fuzzy
msgid "# Integration Tests"
msgstr "# Test di integrazione"

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr "Se desideri testare la tua libreria come client, utilizza un test di integrazione."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crea un file `.rs` in `tests/`:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Questi test hanno accesso solo all'API pubblica del tuo crate."

#: src/testing/useful-crates.md:1
#, fuzzy
msgid "## Useful crates for writing tests"
msgstr "# Casse utili"

#: src/testing/useful-crates.md:3
#, fuzzy
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust ha il supporto integrato per i test di documentazione:"

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr ""

#: src/testing/useful-crates.md:7
msgid ""
"* [googletest](https://docs.rs/googletest): Comprehensive test assertion library in the tradition "
"of GoogleTest for C++.\n"
"* [proptest](https://docs.rs/proptest): Property-based testing for Rust.\n"
"* [rstest](https://docs.rs/rstest): Support for fixtures and parameterised tests."
msgstr ""

#: src/unsafe.md:1
#, fuzzy
msgid "# Unsafe Rust"
msgstr "# Ruggine non sicura"

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Il linguaggio Rust ha due parti:"

#: src/unsafe.md:5
#, fuzzy
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are violated."
msgstr ""
"* **Safe Rust:** memoria sicura, nessun comportamento indefinito possibile.\n"
"* **Unsafe Rust:** pu√≤ attivare un comportamento indefinito se vengono violate le precondizioni."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to know\n"
"what Unsafe Rust is."
msgstr ""
"Vedremo Rust per lo pi√π sicuro in questo corso, ma √® importante saperlo\n"
"cos'√® Unsafe Rust."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Il codice non sicuro √® solitamente piccolo e isolato e la sua correttezza dovrebbe essere "
"attentamente\n"
"documentato. Di solito √® racchiuso in uno strato di astrazione sicuro."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust ti d√† accesso a cinque nuove funzionalit√†:"

#: src/unsafe.md:16
#, fuzzy
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* Dereferenzia i puntatori grezzi.\n"
"* Accedi o modifica variabili statiche mutabili.\n"
"* Accedi ai campi `union`.\n"
"* Richiama funzioni `non sicure`, comprese le funzioni `extern`.\n"
"* Implementa i tratti \"non sicuri\"."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see\n"
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"Tratteremo brevemente le capacit√† non sicure in seguito. Per tutti i dettagli, vedere\n"
"[Capitolo 19.1 nel Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"e il [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety rules."
msgstr ""
"Unsafe Rust non significa che il codice non sia corretto. Significa che gli sviluppatori hanno\n"
"ha disattivato le funzionalit√† di sicurezza del compilatore e deve scrivere il codice corretto\n"
"loro stessi. Significa che il compilatore non applica pi√π le regole di sicurezza della memoria di "
"Rust."

#: src/unsafe/raw-pointers.md:1
#, fuzzy
msgid "# Dereferencing Raw Pointers"
msgstr "# Dereferenziazione dei puntatori grezzi"

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "La creazione di puntatori √® sicura, ma la loro dereferenziazione richiede `unsafe`:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:27
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"√à buona norma (e richiesto dalla guida allo stile di Android Rust) scrivere un commento per "
"ciascuno\n"
"Blocco `unsafe` che spiega come il codice al suo interno soddisfi i requisiti di sicurezza "
"dell'unsafe\n"
"operazioni che sta compiendo."

#: src/unsafe/raw-pointers.md:31
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"Nel caso di dereferenze puntatore, ci√≤ significa che i puntatori devono essere\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), ovvero:"

#: src/unsafe/raw-pointers.md:34
#, fuzzy
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * Il puntatore deve essere diverso da null.\n"
" * Il puntatore deve essere _dereferenceable_ (entro i limiti di un singolo oggetto allocato).\n"
" * L'oggetto non deve essere stato deallocato.\n"
" * Non devono esserci accessi contemporanei alla stessa posizione.\n"
" * Se il puntatore √® stato ottenuto lanciando un riferimento, l'oggetto sottostante deve essere "
"live e no\n"
"   riferimento pu√≤ essere utilizzato per accedere alla memoria."

#: src/unsafe/raw-pointers.md:41
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr "Nella maggior parte dei casi anche il puntatore deve essere correttamente allineato."

#: src/unsafe/mutable-static-variables.md:1
#, fuzzy
msgid "# Mutable Static Variables"
msgstr "# Variabili statiche mutabili"

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "√à sicuro leggere una variabile statica immutabile:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr ""
"Tuttavia, poich√© possono verificarsi corse di dati, non √® sicuro leggere e scrivere mutabili\n"
"variabili statiche:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases where it might make "
"sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working with some C APIs."
msgstr ""
"L'uso di una statica mutabile √® generalmente una cattiva idea, ma ci sono alcuni casi in cui "
"potrebbe avere senso\n"
"nel codice `no_std` di basso livello, come implementare un allocatore di heap o lavorare con "
"alcune API C."

#: src/unsafe/unions.md:1
#, fuzzy
msgid "# Unions"
msgstr "# Sindacati"

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "Le unioni sono come le enum, ma devi monitorare tu stesso il campo attivo:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally "
"needed\n"
"for interacting with C library APIs."
msgstr ""
"Le unioni sono molto raramente necessarie in Rust poich√© di solito puoi usare un enum. "
"Occasionalmente sono necessari\n"
"per interagire con le API della libreria C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"Se vuoi solo reinterpretare i byte come un tipo diverso, probabilmente lo vuoi\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) o una "
"cassaforte\n"
"wrapper come la cassa [`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:1
#, fuzzy
msgid "# Calling Unsafe Functions"
msgstr "# Chiamata di funzioni non sicure"

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"Una funzione o un metodo pu√≤ essere contrassegnato come \"non sicuro\" se ha precondizioni "
"aggiuntive\n"
"deve sostenere per evitare comportamenti indefiniti:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"üóª‚ààüåè\";\n"
"\n"
"    // Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..7) }));\n"
"\n"
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:1
#, fuzzy
msgid "# Writing Unsafe Functions"
msgstr "# Scrittura di funzioni non sicure"

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular conditions to avoid "
"undefined\n"
"behaviour."
msgstr ""
"Puoi contrassegnare le tue funzioni come \"non sicure\" se richiedono condizioni particolari per "
"evitare undefined\n"
"comportamento."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid "We wouldn't actually use pointers for this because it can be done safely with references."
msgstr ""
"In realt√† non useremmo i puntatori per questo perch√© pu√≤ essere fatto in sicurezza con i "
"riferimenti."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an `unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see what happens."
msgstr ""
"Si noti che il codice non sicuro √® consentito all'interno di una funzione non sicura senza un "
"blocco `unsafe`. Noi possiamo\n"
"proibiscilo con `#[deny(unsafe_op_in_unsafe_fn)]`. Prova ad aggiungerlo e guarda cosa succede."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "# Calling External Code"
msgstr "# Chiamata codice esterno"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling\n"
"them is thus unsafe:"
msgstr ""
"Le funzioni di altri linguaggi potrebbero violare le garanzie di Rust. Chiamata\n"
"loro √® quindi pericoloso:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with pointers which might\n"
"violate Rust's memory model, but in general any C function might have undefined behaviour under "
"any\n"
"arbitrary circumstances."
msgstr ""
"Questo di solito √® solo un problema per le funzioni esterne che fanno cose con i puntatori che "
"potrebbero\n"
"violare il modello di memoria di Rust, ma in generale qualsiasi funzione C potrebbe avere un "
"comportamento indefinito sotto qualsiasi\n"
"circostanze arbitrarie."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""

#: src/unsafe/unsafe-traits.md:1
#, fuzzy
msgid "# Implementing Unsafe Traits"
msgstr "# Implementazione di tratti non sicuri"

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"Come con le funzioni, puoi contrassegnare un tratto come \"non sicuro\" se l'implementazione deve "
"garantire\n"
"condizioni particolari per evitare comportamenti indefiniti."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Ad esempio, la cassa \"zerocopy\" ha un tratto non sicuro che sembra\n"
"[qualcosa del genere](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Dovrebbe esserci una sezione `# Safety` su Rustdoc per il tratto che spiega i requisiti per\n"
"il tratto da implementare in modo sicuro."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid "The actual safety section for `AsBytes` is rather longer and more complicated."
msgstr "L'attuale sezione sulla sicurezza per `AsBytes` √® piuttosto lunga e complicata."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "I tratti incorporati \"Invia\" e \"Sincronizza\" non sono sicuri."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "# Day 3: Afternoon Exercises"
msgstr "# Giorno 3: Esercizi pomeridiani"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "Costruiamo un wrapper sicuro per leggere il contenuto della directory!"

#: src/exercises/day-3/afternoon.md:7
#, fuzzy
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "Dopo aver esaminato l'esercizio, puoi esaminare la [soluzione] fornita."

#: src/exercises/day-3/safe-ffi-wrapper.md:1
#, fuzzy
msgid "# Safe FFI Wrapper"
msgstr "# Wrapper FFI sicuro"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust ha un ottimo supporto per le funzioni di chiamata attraverso una funzione _foreign\n"
"interfaccia_ (FFI). Lo useremo per costruire un wrapper sicuro per `libc`\n"
"funzioni che useresti da C per leggere i nomi dei file di una directory."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Ti consigliamo di consultare le pagine di manuale:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
#, fuzzy
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`] module. There you find a number of\n"
"string types which you need for the exercise:"
msgstr ""
"Dovrai anche sfogliare il modulo [`std::ffi`]. L√¨ trovi un numero di\n"
"tipi di stringa necessari per l'esercizio:"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
#, fuzzy
msgid ""
"| Types                      | Encoding       | Use                            |\n"
"|----------------------------|----------------|--------------------------------|\n"
"| [`str`] and [`String`]     | UTF-8          | Text processing in Rust        |\n"
"| [`CStr`] and [`CString`]   | NUL-terminated | Communicating with C functions |\n"
"| [`OsStr`] and [`OsString`] | OS-specific    | Communicating with the OS      |"
msgstr ""
"| Tipi | Codifica | Usa |\n"
"|----------------------------|----------------|--- -----------------------------|\n"
"| [`str`] e [`String`] | UTF-8 | Elaborazione del testo in Rust |\n"
"| [`CStr`] e [`CString`] | con terminazione NUL | Comunicare con le funzioni C |\n"
"| [`OsStr`] e [`OsString`] | specifico del sistema operativo | Comunicazione con il sistema "
"operativo |"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid "You will convert between all these types:"
msgstr "Potrai convertire tra tutti questi tipi:"

#: src/exercises/day-3/safe-ffi-wrapper.md:24
#, fuzzy
msgid ""
"- `&str` to `CString`: you need to allocate space for a trailing `\\0` character,\n"
"- `CString` to `*const i8`: you need a pointer to call C functions,\n"
"- `*const i8` to `&CStr`: you need something which can find the trailing `\\0` character,\n"
"- `&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some unknow data\",\n"
"- `&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use\n"
"  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html)\n"
"  to create it,\n"
"- `&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to return it and call\n"
"  `readdir` again."
msgstr ""
"- Da `&str` a `CString`: √® necessario allocare spazio per un carattere finale `\\0`,\n"
"- Da `CString` a `*const i8`: √® necessario un puntatore per chiamare le funzioni C,\n"
"- Da `*const i8` a `&CStr`: hai bisogno di qualcosa che possa trovare il carattere finale `\\0`,\n"
"- da `&CStr` a `&[u8]`: una fetta di byte √® l'interfaccia universale per \"alcuni dati "
"sconosciuti\",\n"
"- Da `&[u8]` a `&OsStr`: `&OsStr` √® un passo verso `OsString`, usa\n"
"  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html)\n"
"  per crearlo,\n"
"- `&OsStr` a `OsString`: √® necessario clonare i dati in `&OsStr` per poterlo restituire e "
"chiamare\n"
"  `readdir` di nuovo."

#: src/exercises/day-3/safe-ffi-wrapper.md:34
#, fuzzy
msgid "The [Nomicon] also has a very useful chapter about FFI."
msgstr "Il [Nomicon] ha anche un capitolo molto utile su FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:45
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"functions and methods:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/> e inserisci quello mancante\n"
"funzioni e metodi:"

#: src/exercises/day-3/safe-ffi-wrapper.md:48
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout as per man entry for dirent\n"
"    #[cfg(target_os = \"macos\")]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android.md:1
#, fuzzy
msgid "# Welcome to Rust in Android"
msgstr "# Benvenuto in Rust su Android"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust √® supportato per lo sviluppo della piattaforma nativa su Android. Ci√≤ significa che\n"
"puoi scrivere nuovi servizi del sistema operativo in Rust, oltre ad estenderli\n"
"servizi esistenti."

#: src/android.md:7
#, fuzzy
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try to\n"
"> find a little corner of your code base where we can move some lines of code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> Oggi tenteremo di chiamare Rust da uno dei tuoi progetti. Quindi prova a\n"
"> trova un piccolo angolo della tua base di codice in cui possiamo spostare alcune righe di "
"codice\n"
"> Ruggine. Minori sono le dipendenze e i tipi \"esotici\", meglio √®. Qualcosa che\n"
"> analizza alcuni byte grezzi sarebbe l'ideale."

#: src/android/setup.md:1
#, fuzzy
msgid "# Setup"
msgstr "# Impostare"

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you have\n"
"access to one or create a new one with:"
msgstr ""
"Useremo un dispositivo virtuale Android per testare il nostro codice. Assicurati di avere\n"
"accedi a uno o creane uno nuovo con:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"Si prega di consultare il [Sviluppatore Android\n"
"Codelab](https://source.android.com/docs/setup/start) per i dettagli."

#: src/android/build-rules.md:1
#, fuzzy
msgid "# Build Rules"
msgstr "# Crea regole"

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr "Il sistema di compilazione Android (Soong) supporta Rust tramite una serie di moduli:"

#: src/android/build-rules.md:5
#, fuzzy
msgid ""
"| Module Type       | "
"Description                                                                                        "
"|\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust "
"binary.                                                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and `dylib` "
"variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard Rust test "
"harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging "
"`libfuzzer`.                                                |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that provides an interface for "
"a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library containing Rust bindings to C "
"libraries.              |"
msgstr ""
"| Tipo di modulo | Descrizione |\n"
"|-------------------|-------------------------------------- "
"-------------------------------------------------- ---------------------|\n"
"| `binario_ruggine` | Produce un binario Rust. |\n"
"| `libreria_ruggine` | Produce una libreria Rust e fornisce entrambe le varianti `rlib` e `dylib`. "
"|\n"
"| `ruggine_ffi` | Produce una libreria Rust C utilizzabile dai moduli `cc` e fornisce varianti sia "
"statiche che condivise. |\n"
"| `rust_proc_macro` | Produce una libreria Rust `proc-macro`. Questi sono analoghi ai plugin del "
"compilatore. |\n"
"| `test_ruggine` | Produce un file binario di test Rust che utilizza il cablaggio di test Rust "
"standard. |\n"
"| `ruggine_fuzz` | Produce un binario fuzz di Rust sfruttando `libfuzzer`. |\n"
"| `protobuf_ruggine` | Genera il codice sorgente e produce una libreria Rust che fornisce "
"un'interfaccia per un particolare protobuf. |\n"
"| `ruggine_bindgen` | Genera il codice sorgente e produce una libreria Rust contenente "
"collegamenti Rust alle librerie C. |"

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Vedremo successivamente `rust_binary` e `rust_library`."

#: src/android/build-rules/binary.md:1
#, fuzzy
msgid "# Rust Binaries"
msgstr "# Binari Rust"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, create\n"
"the following files:"
msgstr ""
"Iniziamo con una semplice applicazione. Alla radice di un checkout AOSP, create\n"
"i seguenti file:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "_ciao_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "_ciao_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo.\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Ora puoi creare, inviare ed eseguire il binario:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
#, fuzzy
msgid "# Rust Libraries"
msgstr "# Librerie ruggine"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "Usa `rust_library` per creare una nuova libreria Rust per Android."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Qui dichiariamo una dipendenza da due librerie:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* `libgreeting`, che definiamo di seguito,\n"
"* `libtextwrap`, che √® una cassa gi√† venduta\n"
"  [`external/rust/crates/`][crates]."

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "_ciao_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Costruisci, spingi ed esegui il binario come prima:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:1
#, fuzzy
msgid "# AIDL"
msgstr "#AIDL"

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Il [linguaggio di definizione dell'interfaccia Android\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) √® supportato in Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* Il codice Rust pu√≤ chiamare i server AIDL esistenti,\n"
"* Puoi creare nuovi server AIDL in Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "# AIDL Interfaces"
msgstr "# Interfacce AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Dichiari l'API del tuo servizio utilizzando un'interfaccia AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"

#: src/android/aidl/interface.md:7
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "*birthday_service/aidl/Android.bp*:"
msgstr "*servizio_compleanno/aidl/Android.bp*:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the vendor\n"
"partition."
msgstr ""
"Aggiungi \"vendor_available: true\" se il tuo file AIDL √® utilizzato da un file binario nel "
"fornitore\n"
"partizione."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "# Service Implementation"
msgstr "# Implementazione del servizio"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Ora possiamo implementare il servizio AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "*birthday_service/src/lib.rs*:"
msgstr "*servizio_compleanno/src/lib.rs*:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;\n"
"\n"
"impl binder::Interface for BirthdayService {}\n"
"\n"
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28 src/android/aidl/client.md:37
#, fuzzy
msgid "*birthday_service/Android.bp*:"
msgstr "*servizio_compleanno/Android.bp*:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
#, fuzzy
msgid "# AIDL Server"
msgstr "# Server AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "Infine, possiamo creare un server che espone il servizio:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "*birthday_service/src/server.rs*:"
msgstr "*servizio_compleanno/src/server.rs*:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:1
#, fuzzy
msgid "# Deploy"
msgstr "# Distribuisci"

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Ora possiamo creare, inviare e avviare il servizio:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "In un altro terminale, controlla che il servizio sia in esecuzione:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:18
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "Puoi anche chiamare il servizio con `service call`:"

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
#, fuzzy
msgid "# AIDL Client"
msgstr "# Cliente AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr "Infine, possiamo creare un client Rust per il nostro nuovo servizio."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "*birthday_service/src/client.rs*:"
msgstr "*servizio_compleanno/src/client.rs*:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Si noti che il client non dipende da `libbirthdayservice`."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Crea, invia ed esegui il client sul tuo dispositivo:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:1
#, fuzzy
msgid "# Changing API"
msgstr "# Modifica dell'API"

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients specify a\n"
"list of lines for the birthday card:"
msgstr ""
"Estendiamo l'API con pi√π funzionalit√†: vogliamo consentire ai client di specificare a\n"
"elenco delle righe per il biglietto d'auguri:"

#: src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:1 src/bare-metal/aps/logging.md:1
#, fuzzy
msgid "# Logging"
msgstr "# Registrazione"

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) or\n"
"`stdout` (on-host):"
msgstr ""
"Dovresti usare la cassa `log` per accedere automaticamente a `logcat` (sul dispositivo) o\n"
"`stdout` (sull'host):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_ciao_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_ciao_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"\n"
"use log::{debug, error, info};\n"
"\n"
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr "Crea, invia ed esegui il file binario sul tuo dispositivo:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "I log vengono visualizzati in `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:1
#, fuzzy
msgid "# Interoperability"
msgstr "# Interoperabilit√†"

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This means\n"
"that you can:"
msgstr ""
"Rust ha un eccellente supporto per l'interoperabilit√† con altri linguaggi. Questo significa\n"
"che tu puoi:"

#: src/android/interoperability.md:6
#, fuzzy
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* Richiama le funzioni di Rust da altre lingue.\n"
"* Funzioni di chiamata scritte in altri linguaggi da Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"Quando chiami funzioni in una lingua straniera diciamo che stai usando a\n"
"_interfaccia funzione straniera_, nota anche come FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "# Interoperability with C"
msgstr "# Interoperabilit√† con C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust ha il pieno supporto per il collegamento di file oggetto con una convenzione di chiamata C.\n"
"Allo stesso modo, puoi esportare le funzioni di Rust e chiamarle da C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Puoi farlo a mano se vuoi:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr ""
"Lo abbiamo gi√† visto nel [Safe FFI Wrapper\n"
"esercizio](../../exercises/day-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr ""
"> Ci√≤ presuppone la piena conoscenza della piattaforma di destinazione. Non consigliato per\n"
"> produzione."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "Vedremo le opzioni migliori in seguito."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "# Using Bindgen"
msgstr "# Utilizzo di Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"Lo strumento [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)\n"
"pu√≤ generare automaticamente collegamenti da un file di intestazione C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Per prima cosa crea una piccola libreria C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperabilit√†/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;\n"
"\n"
"void print_card(const card* card);\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperabilit√†/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Aggiungi questo al tuo file `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperabilit√†/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr ""
"Crea un file di intestazione wrapper per la libreria (non strettamente necessario in questo\n"
"esempio):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperabilit√†/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Ora puoi generare automaticamente le associazioni:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Infine, possiamo usare i binding nel nostro programma Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperabilit√†/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Infine, possiamo eseguire test generati automaticamente per garantire che i binding funzionino:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "# Calling Rust"
msgstr "# Calling Rust"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Esportare le funzioni e i tipi di Rust in C √® facile:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperabilit√†/ruggine/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperabilit√†/ruggine/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperabilit√†/ruggine/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Ora possiamo chiamarlo da un binario C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperabilit√†/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperabilit√†/ruggine/analisi/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol will just be the name "
"of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` disabilita la solita alterazione del nome di Rust, quindi il simbolo esportato sar√† "
"solo il nome di\n"
"la funzione. Puoi anche usare `#[export_name = \"some_name\"]` per specificare il nome che "
"desideri."

#: src/android/interoperability/cpp.md:1
#, fuzzy
msgid "# With C++"
msgstr "# Con C++"

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between Rust\n"
"and C++."
msgstr ""
"Il [CXX crate][1] rende possibile l'interoperabilit√† sicura tra Rust\n"
"e C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "L'approccio generale √® simile al seguente:"

#: src/android/interoperability/cpp.md:8
#, fuzzy
msgid "<img src=\"cpp/overview.svg\">"
msgstr "<img src=\"cpp/overview.svg\">"

#: src/android/interoperability/cpp.md:10
#, fuzzy
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr "Vedere il [tutorial CXX][2] per un esempio completo di utilizzo di questo."

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "# Interoperability with Java"
msgstr "# Interoperabilit√† con Java"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java pu√≤ caricare oggetti condivisi tramite [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). Il [`jni`\n"
"crate](https://docs.rs/jni/) consente di creare una libreria compatibile."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Innanzitutto, creiamo una funzione Rust da esportare in Java:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperabilit√†/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32 src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperabilit√†/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "Infine, possiamo chiamare questa funzione da Java:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperabilit√†/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Infine, puoi creare, sincronizzare ed eseguire il binario:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/android/morning.md:1 src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1 src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
#, fuzzy
msgid "# Exercises"
msgstr "# Esercizi"

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with and\n"
"try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Questo √® un esercizio di gruppo: esamineremo uno dei progetti con cui lavori e\n"
"prova a integrarci un po' di ruggine. Alcuni suggerimenti:"

#: src/exercises/android/morning.md:6
#, fuzzy
msgid ""
"* Call your AIDL service with a client written in Rust.\n"
"\n"
"* Move a function from your project to Rust and call it."
msgstr ""
"* Chiama il tuo servizio AIDL con un client scritto in Rust.\n"
"\n"
"* Sposta una funzione dal tuo progetto a Rust e chiamala."

#: src/exercises/android/morning.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nessuna soluzione viene fornita qui poich√© questo √® a tempo indeterminato: si basa su qualcuno "
"dentro\n"
"la classe ha un pezzo di codice che puoi consegnare a Rust al volo."

#: src/bare-metal.md:1
#, fuzzy
msgid "# Welcome to Bare Metal Rust"
msgstr "# Benvenuto in Bare Metal Rust"

#: src/bare-metal.md:3
#, fuzzy
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people who are familiar with "
"the\n"
"basics of Rust (perhaps from completing the Comprehensive Rust course), and ideally also have "
"some\n"
"experience with bare-metal programming in some other language such as C."
msgstr ""
"Questo √® un corso autonomo di un giorno sul bare metal Rust, rivolto a persone che hanno "
"familiarit√† con il\n"
"nozioni di base di Rust (forse completando il corso completo di Rust), e idealmente anche averne "
"alcune\n"
"esperienza con la programmazione bare metal in qualche altro linguaggio come C."

#: src/bare-metal.md:7
#, fuzzy
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS underneath us. This "
"will\n"
"be divided into several parts:"
msgstr ""
"Oggi parleremo di Rust 'bare-metal': eseguire il codice Rust senza un sistema operativo sotto di "
"noi. Questo sar√†\n"
"essere suddiviso in pi√π parti:"

#: src/bare-metal.md:10
#, fuzzy
msgid ""
"- What is `no_std` Rust?\n"
"- Writing firmware for microcontrollers.\n"
"- Writing bootloader / kernel code for application processors.\n"
"- Some useful crates for bare-metal Rust development."
msgstr ""
"- Cos'√® \"no_std\" Rust?\n"
"- Scrittura firmware per microcontrollori.\n"
"- Scrittura del codice bootloader/kernel per i processori delle applicazioni.\n"
"- Alcune casse utili per lo sviluppo di ruggine a metallo nudo."

#: src/bare-metal.md:15
#, fuzzy
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit](https://microbit.org/) "
"v2\n"
"as an example. It's a [development board](https://tech.microbit.org/hardware/) based on the "
"Nordic\n"
"nRF51822 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, "
"and\n"
"an on-board SWD debugger."
msgstr ""
"Per la parte del corso sui microcontrollori utilizzeremo la [BBC micro:bit](https://microbit.org/) "
"v2\n"
"come esempio. √à una [scheda di sviluppo](https://tech.microbit.org/hardware/) basata sul Nordic\n"
"microcontrollore nRF51822 con alcuni LED e pulsanti, un accelerometro e una bussola collegati a "
"I2C e\n"
"un debugger SWD integrato."

#: src/bare-metal.md:20
#, fuzzy
msgid "To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr "Per iniziare, installa alcuni strumenti che ci serviranno in seguito. Su gLinux o Debian:"

#: src/bare-metal.md:22
msgid ""
"```bash\n"
"sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-config qemu-system-"
"arm\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal.md:30
#, fuzzy
msgid "And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr "E dai agli utenti del gruppo `plugdev` l'accesso al programmatore micro:bit:"

#: src/bare-metal.md:32
msgid ""
"```bash\n"
"echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", GROUP=\"plugdev\"' |\\\n"
"  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
"sudo udevadm control --reload-rules\n"
"```"
msgstr ""

#: src/bare-metal.md:38
#, fuzzy
msgid "On MacOS:"
msgstr "Su macOS:"

#: src/bare-metal.md:40
msgid ""
"```bash\n"
"xcode-select --install\n"
"brew install gdb picocom qemu\n"
"brew install --cask gcc-aarch64-embedded\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal/no_std.md:1
#, fuzzy
msgid "# `no_std`"
msgstr "# `no_std`"

#: src/bare-metal/no_std.md:3
#, fuzzy
msgid ""
"<table>\n"
"<tr>\n"
"<th>"
msgstr ""
"<tabella>\n"
"<tr>\n"
"<th>"

#: src/bare-metal/no_std.md:7
#, fuzzy
msgid "`core`"
msgstr "`nucleo`"

#: src/bare-metal/no_std.md:9 src/bare-metal/no_std.md:14
#, fuzzy
msgid ""
"</th>\n"
"<th>"
msgstr ""
"</th>\n"
"<th>"

#: src/bare-metal/no_std.md:12
#, fuzzy
msgid "`alloc`"
msgstr "`alloc`"

#: src/bare-metal/no_std.md:17
#, fuzzy
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md:19
#, fuzzy
msgid ""
"</th>\n"
"</tr>\n"
"<tr valign=\"top\">\n"
"<td>"
msgstr ""
"</th>\n"
"</tr>\n"
"<tr valign=\"top\">\n"
"<td>"

#: src/bare-metal/no_std.md:24
#, fuzzy
msgid ""
"* Slices, `&str`, `CStr`\n"
"* `NonZeroU8`...\n"
"* `Option`, `Result`\n"
"* `Display`, `Debug`, `write!`...\n"
"* `Iterator`\n"
"* `panic!`, `assert_eq!`...\n"
"* `NonNull` and all the usual pointer-related functions\n"
"* `Future` and `async`/`await`\n"
"* `fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`...\n"
"* `Duration`"
msgstr ""
"* Fette, `&str`, `CStr`\n"
"* `NonZeroU8`...\n"
"* `Opzione`, `Risultato`\n"
"* `Display`, `Debug`, `write!`...\n"
"* `Iteratore`\n"
"* `panico!`, `assert_eq!`...\n"
"* `NonNull` e tutte le solite funzioni relative ai puntatori\n"
"* `Future` e `async`/`await`\n"
"* `fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`...\n"
"* `Durata`"

#: src/bare-metal/no_std.md:35 src/bare-metal/no_std.md:42
#, fuzzy
msgid ""
"</td>\n"
"<td>"
msgstr ""
"</td>\n"
"<td>"

#: src/bare-metal/no_std.md:38
#, fuzzy
msgid ""
"* `Box`, `Cow`, `Arc`, `Rc`\n"
"* `Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`\n"
"* `String`, `CString`, `format!`"
msgstr ""
"* `Scatola`, `Mucca`, `Arco`, `Rc`\n"
"* `Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`\n"
"* `Stringa`, `CStringa`, `formato!`"

#: src/bare-metal/no_std.md:45
#, fuzzy
msgid ""
"* `Error`\n"
"* `HashMap`\n"
"* `Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`\n"
"* `File` and the rest of `fs`\n"
"* `println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`\n"
"* `Path`, `OsString`\n"
"* `net`\n"
"* `Command`, `Child`, `ExitCode`\n"
"* `spawn`, `sleep` and the rest of `thread`\n"
"* `SystemTime`, `Instant`"
msgstr ""
"* `Errore`\n"
"* `Mappa hash`\n"
"* `Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`\n"
"* `File` e il resto di `fs`\n"
"* `println!`, `Read`, `Write`, `Stdin`, `Stdout` e il resto di `io`\n"
"* `Percorso`, `OsString`\n"
"* `rete`\n"
"* `Comando`, `Figlio`, `CodiceUscita`\n"
"* `spawn`, `sleep` e il resto di `thread`\n"
"* `SystemTime`, `Instant`"

#: src/bare-metal/no_std.md:56
#, fuzzy
msgid ""
"</td>\n"
"</tr>\n"
"</table>\n"
"\n"
"<details>"
msgstr ""
"</td>\n"
"</tr>\n"
"</table>\n"
"\n"
"<dettagli>"

#: src/bare-metal/no_std.md:62
#, fuzzy
msgid ""
"* `HashMap` depends on RNG.\n"
"* `std` re-exports the contents of both `core` and `alloc`."
msgstr ""
"* `HashMap` dipende da RNG.\n"
"* `std` riesporta il contenuto sia di `core` che di `alloc`."

#: src/bare-metal/minimal.md:1
#, fuzzy
msgid "# A minimal `no_std` program"
msgstr "# Un programma `no_std` minimo"

#: src/bare-metal/minimal.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::panic::PanicInfo;\n"
"\n"
"#[panic_handler]\n"
"fn panic(_panic: &PanicInfo) -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/minimal.md:17
msgid ""
"* This will compile to an empty binary.\n"
"* `std` provides a panic handler; without it we must provide our own.\n"
"* It can also be provided by another crate, such as `panic-halt`.\n"
"* Depending on the target, you may need to compile with `panic = \"abort\"` to avoid an error "
"about\n"
"  `eh_personality`.\n"
"* Note that there is no `main` or any other entry point; it's up to you to define your own entry\n"
"  point. This will typically involve a linker script and some assembly code to set things up "
"ready\n"
"  for Rust code to run."
msgstr ""

#: src/bare-metal/alloc.md:1
#, fuzzy
msgid "# `alloc`"
msgstr "# `alloc`"

#: src/bare-metal/alloc.md:3
#, fuzzy
msgid ""
"To use `alloc` you must implement a\n"
"[global (heap) allocator](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"Per usare `alloc` devi implementare a\n"
"[allocatore globale (heap)](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."

#: src/bare-metal/alloc.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Now we can do things that require heap allocation.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/alloc.md:39
msgid ""
"* `buddy_system_allocator` is a third-party crate implementing a basic buddy system allocator. "
"Other\n"
"  crates are available, or you can write your own or hook into your existing allocator.\n"
"* The const parameter of `LockedHeap` is the max order of the allocator; i.e. in this case it can\n"
"  allocate regions of up to 2**32 bytes.\n"
"* If any crate in your dependency tree depends on `alloc` then you must have exactly one global\n"
"  allocator defined in your binary. Usually this is done in the top-level binary crate.\n"
"* `extern crate panic_halt as _` is necessary to ensure that the `panic_halt` crate is linked in "
"so\n"
"  we get its panic handler.\n"
"* This example will build but not run, as it doesn't have an entry point."
msgstr ""

#: src/bare-metal/microcontrollers.md:1
#, fuzzy
msgid "# Microcontrollers"
msgstr "# Microcontrollori"

#: src/bare-metal/microcontrollers.md:3
#, fuzzy
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for Cortex M "
"microcontrollers."
msgstr ""
"Il crate `cortex_m_rt` fornisce (tra le altre cose) un gestore di reset per i microcontrollori "
"Cortex M."

#: src/bare-metal/microcontrollers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use cortex_m_rt::entry;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers.md:21
#, fuzzy
msgid "Next we'll look at how to access peripherals, with increasing levels of abstraction."
msgstr "Successivamente vedremo come accedere alle periferiche, con livelli crescenti di astrazione."

#: src/bare-metal/microcontrollers.md:25
#, fuzzy
msgid ""
"* The `cortex_m_rt::entry` macro requires that the function have type `fn() -> !`, because "
"returning\n"
"  to the reset handler doesn't make sense.\n"
"* Run the example with `cargo embed --bin minimal`"
msgstr ""
"* La macro `cortex_m_rt::entry` richiede che la funzione abbia il tipo `fn() -> !`, perch√© "
"restituisce\n"
"  al gestore di ripristino non ha senso.\n"
"* Esegui l'esempio con `cargo embed --bin minimal`"

#: src/bare-metal/microcontrollers/mmio.md:1
#, fuzzy
msgid "# Raw MMIO"
msgstr "# MMIO grezzo"

#: src/bare-metal/microcontrollers/mmio.md:3
#, fuzzy
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try turning on an LED on our\n"
"micro:bit:"
msgstr ""
"La maggior parte dei microcontrollori accede alle periferiche tramite IO mappato in memoria. "
"Proviamo ad accendere un LED sul nostro\n"
"micro:bit:"

#: src/bare-metal/microcontrollers/mmio.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// GPIO port 0 peripheral address\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// GPIO peripheral offsets\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// PIN_CNF fields\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
"const PULL_DISABLED: u32 = 0x0 << 2;\n"
"const DRIVE_S0S1: u32 = 0x0 << 8;\n"
"const SENSE_DISABLED: u32 = 0x0 << 16;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 << 28);\n"
"        gpio0_outset.write_volatile(1 << 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:64
#, fuzzy
msgid ""
"* GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 to the first row."
msgstr ""
"* Il pin 21 di GPIO 0 √® collegato alla prima colonna della matrice LED e il pin 28 alla prima riga."

#: src/bare-metal/microcontrollers/mmio.md:66 src/bare-metal/microcontrollers/pacs.md:59
#: src/bare-metal/microcontrollers/hals.md:43 src/bare-metal/microcontrollers/board-support.md:34
#, fuzzy
msgid "Run the example with:"
msgstr "Esegui l'esempio con:"

#: src/bare-metal/microcontrollers/mmio.md:68
msgid ""
"```sh\n"
"cargo embed --bin mmio\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:1
#, fuzzy
msgid "# Peripheral Access Crates"
msgstr "# Casse di accesso periferico"

#: src/bare-metal/microcontrollers/pacs.md:3
#, fuzzy
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust wrappers for\n"
"memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index."
"html)\n"
"files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) genera wrapper Rust per lo pi√π sicuri per\n"
"periferiche mappate in memoria da [CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index."
"html)\n"
"File."

#: src/bare-metal/microcontrollers/pacs.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:49
#, fuzzy
msgid ""
"* SVD (System View Description) files are XML files typically provided by silicon vendors which\n"
"  describe the memory map of the device.\n"
"  * They are organised by peripheral, register, field and value, with names, descriptions, "
"addresses\n"
"    and so on.\n"
"  * SVD files are often buggy and incomplete, so there are various projects which patch the\n"
"    mistakes, add missing details, and publish the generated crates.\n"
"* `cortex-m-rt` provides the vector table, among other things.\n"
"* If you `cargo install cargo-binutils` then you can run\n"
"  `cargo objdump --bin pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"* I file SVD (System View Description) sono file XML generalmente forniti da fornitori di silicio "
"che\n"
"  descrivere la mappa di memoria del dispositivo.\n"
"  * Sono organizzati per periferica, registro, campo e valore, con nomi, descrizioni, indirizzi\n"
"    e cos√¨ via.\n"
"  * I file SVD sono spesso difettosi e incompleti, quindi ci sono vari progetti che correggono il "
"file\n"
"    errori, aggiungere i dettagli mancanti e pubblicare le casse generate.\n"
"* `cortex-m-rt` fornisce la tabella dei vettori, tra le altre cose.\n"
"* Se `cargo installi cargo-binutils` allora puoi eseguire\n"
"  `cargo objdump --bin pac -- -d --no-show-raw-insn` per vedere il binario risultante."

#: src/bare-metal/microcontrollers/pacs.md:61
msgid ""
"```sh\n"
"cargo embed --bin pac\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:1
#, fuzzy
msgid "# HAL crates"
msgstr "# casse HAL"

#: src/bare-metal/microcontrollers/hals.md:3
#, fuzzy
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates) "
"for\n"
"many microcontrollers provide wrappers around various peripherals. These generally implement "
"traits\n"
"from [`embedded-hal`](https://crates.io/crates/embedded-hal)."
msgstr ""
"[Casse HAL](https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates) per\n"
"molti microcontrollori forniscono wrapper attorno a varie periferiche. Questi generalmente "
"implementano i tratti\n"
"da [`embedded-hal`](https://crates.io/crates/embedded-hal)."

#: src/bare-metal/microcontrollers/hals.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Create HAL wrapper for GPIO port 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:39
#, fuzzy
msgid ""
" * `set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait.\n"
" * HAL crates exist for many Cortex-M and RISC-V devices, including various STM32, GD32, nRF, "
"NXP,\n"
"   MSP430, AVR and PIC microcontrollers."
msgstr ""
" * `set_low` e `set_high` sono metodi sul tratto `embedded_hal` `OutputPin`.\n"
" * Esistono casse HAL per molti dispositivi Cortex-M e RISC-V, inclusi vari STM32, GD32, nRF, "
"NXP,\n"
"   Microcontrollori MSP430, AVR e PIC."

#: src/bare-metal/microcontrollers/hals.md:45
msgid ""
"```sh\n"
"cargo embed --bin hal\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:1
#, fuzzy
msgid "# Board support crates"
msgstr "# Casse di supporto della scheda"

#: src/bare-metal/microcontrollers/board-support.md:3
#, fuzzy
msgid ""
"Board support crates provide a further level of wrapping for a specific board for convenience."
msgstr ""
"Le casse di supporto della tavola forniscono un ulteriore livello di avvolgimento per una tavola "
"specifica per comodit√†."

#: src/bare-metal/microcontrollers/board-support.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::Board;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let mut board = Board::take().unwrap();\n"
"\n"
"    board.display_pins.col1.set_low().unwrap();\n"
"    board.display_pins.row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:28
#, fuzzy
msgid ""
" * In this case the board support crate is just providing more useful names, and a bit of\n"
"   initialisation.\n"
" * The crate may also include drivers for some on-board devices outside of the microcontroller\n"
"   itself.\n"
"   * `microbit-v2` includes a simple driver for the LED matrix."
msgstr ""
" * In questo caso la cassa di supporto della scheda fornisce solo nomi pi√π utili e un po' di\n"
"   inizializzazione.\n"
" * Il crate pu√≤ anche includere driver per alcuni dispositivi integrati al di fuori del "
"microcontrollore\n"
"   si.\n"
"   * `microbit-v2` include un semplice driver per la matrice LED."

#: src/bare-metal/microcontrollers/board-support.md:36
msgid ""
"```sh\n"
"cargo embed --bin board_support\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:1
#, fuzzy
msgid "# The type state pattern"
msgstr "# Il modello di stato del tipo"

#: src/bare-metal/microcontrollers/type-state.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Error, moved.\n"
"\n"
"    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);\n"
"    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03.into_push_pull_output(Level::Low);\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:32
#, fuzzy
msgid ""
" * Pins don't implement `Copy` or `Clone`, so only one instance of each can exist. Once a pin is\n"
"   moved out of the port struct nobody else can take it.\n"
" * Changing the configuration of a pin consumes the old pin instance, so you can‚Äôt keep use the "
"old\n"
"   instance afterwards.\n"
" * The type of a value indicates the state that it is in: e.g. in this case, the configuration "
"state\n"
"   of a GPIO pin. This encodes the state machine into the type system, and ensures that you don't\n"
"   try to use a pin in a certain way without properly configuring it first. Illegal state\n"
"   transitions are caught at compile time.\n"
" * You can call `is_high` on an input pin and `set_high` on an output pin, but not vice-versa.\n"
" * Many HAL crates follow this pattern."
msgstr ""
" * I pin non implementano `Copy` o `Clone`, quindi pu√≤ esistere solo un'istanza di ciascuno. Una "
"volta che uno spillo √®\n"
"   spostato fuori dalla struttura portuale nessun altro pu√≤ prenderlo.\n"
" * La modifica della configurazione di un pin consuma la vecchia istanza del pin, quindi non puoi "
"continuare a utilizzare il vecchio\n"
"   esempio dopo.\n"
" * Il tipo di un valore indica lo stato in cui si trova: ad es. in questo caso, lo stato di "
"configurazione\n"
"   di un pin GPIO. Questo codifica la macchina a stati nel sistema di tipi e garantisce che non lo "
"fai\n"
"   provare a utilizzare un pin in un certo modo senza prima configurarlo correttamente. Stato "
"illegale\n"
"   le transizioni vengono rilevate in fase di compilazione.\n"
" * Puoi chiamare `is_high` su un pin di input e `set_high` su un pin di output, ma non viceversa.\n"
" * Molte casse HAL seguono questo schema."

#: src/bare-metal/microcontrollers/embedded-hal.md:1
#, fuzzy
msgid "# `embedded-hal`"
msgstr "# `hal incorporato`"

#: src/bare-metal/microcontrollers/embedded-hal.md:3
#, fuzzy
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a number of traits\n"
"covering common microcontroller peripherals."
msgstr ""
"Il crate [`embedded-hal`](https://crates.io/crates/embedded-hal) fornisce una serie di "
"caratteristiche\n"
"che copre le comuni periferiche del microcontrollore."

#: src/bare-metal/microcontrollers/embedded-hal.md:6
#, fuzzy
msgid ""
" * GPIO\n"
" * ADC\n"
" * I2C, SPI, UART, CAN\n"
" * RNG\n"
" * Timers\n"
" * Watchdogs"
msgstr ""
" * GPIO\n"
" *ADC\n"
" * I2C, SPI, UART, PU√í\n"
" * RNG\n"
" * Timer\n"
" * Cani da guardia"

#: src/bare-metal/microcontrollers/embedded-hal.md:13
#, fuzzy
msgid ""
"Other crates then implement\n"
"[drivers](https://github.com/rust-embedded/awesome-embedded-rust#driver-crates) in terms of these\n"
"traits, e.g. an accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"Altre casse quindi implementano\n"
"[driver](https://github.com/rust-embedded/awesome-embedded-rust#driver-crates) in termini di "
"questi\n"
"tratti, ad es. un driver dell'accelerometro potrebbe richiedere un'implementazione del bus I2C o "
"SPI."

#: src/bare-metal/microcontrollers/embedded-hal.md:19
#, fuzzy
msgid ""
" * There are implementations for many microcontrollers, as well as other platforms such as Linux "
"on\n"
"Raspberry Pi.\n"
" * There is work in progress on an `async` version of `embedded-hal`, but it isn't stable yet."
msgstr ""
" * Ci sono implementazioni per molti microcontrollori, cos√¨ come altre piattaforme come Linux su\n"
"Lampone Pi.\n"
" * C'√® lavoro in corso su una versione `async` di `embedded-hal`, ma non √® ancora stabile."

#: src/bare-metal/microcontrollers/probe-rs.md:1
#, fuzzy
msgid "# `probe-rs`, `cargo-embed`"
msgstr "# `probe-rs`, `cargo-embed`"

#: src/bare-metal/microcontrollers/probe-rs.md:3
#, fuzzy
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, like OpenOCD but better\n"
"integrated."
msgstr ""
"[probe-rs](https://probe.rs/) √® un utile set di strumenti per il debug integrato, come OpenOCD ma "
"migliore\n"
"integrato."

#: src/bare-metal/microcontrollers/probe-rs.md:6
#, fuzzy
msgid ""
"* <abbr title=\"Serial Wire Debug\">SWD</abbr> and JTAG via CMSIS-DAP, ST-Link and J-Link probes\n"
"* GDB stub and Microsoft <abbr title=\"Debug Adapter Protocol\">DAP</abbr> server\n"
"* Cargo integration"
msgstr ""
"* <abbr title=\"Serial Wire Debug\">SWD</abbr> e JTAG tramite sonde CMSIS-DAP, ST-Link e J-Link\n"
"* GDB stub e server Microsoft <abbr title=\"Debug Adapter Protocol\">DAP</abbr>\n"
"* Integrazione del carico"

#: src/bare-metal/microcontrollers/probe-rs.md:10
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log\n"
"<abbr title=\"Real Time Transfers\">RTT</abbr> output and connect GDB. It's configured by an\n"
"`Embed.toml` file in your project directory."
msgstr ""
"`cargo-embed` √® un sottocomando cargo per compilare e aggiornare binari, log\n"
"<abbr title=\"Real Time Transfers\">RTT</abbr> emette e collega GDB. √à configurato da un\n"
"\"Embed.toml\" nella directory del progetto."

#: src/bare-metal/microcontrollers/probe-rs.md:16
#, fuzzy
msgid ""
"* [CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is an Arm standard\n"
"  protocol over USB for an in-circuit debugger to access the CoreSight Debug Access Port of "
"various\n"
"  Arm Cortex processors. It's what the on-board debugger on the BBC micro:bit uses.\n"
"* ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is a range from\n"
"  SEGGER.\n"
"* The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial Wire Debug.\n"
"* probe-rs is a library which you can integrate into your own tools if you want to.\n"
"* The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/) "
"lets\n"
"  VSCode and other IDEs debug code running on any supported microcontroller.\n"
"* cargo-embed is a binary built using the probe-rs library.\n"
"* RTT (Real Time Transfers) is a mechanism to transfer data between the debug host and the target\n"
"  through a number of ringbuffers."
msgstr ""
"* [CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) √® uno standard Arm\n"
"  protocollo su USB per un debugger in-circuit per accedere alla porta di accesso di debug "
"CoreSight di vari\n"
"  Processori Arm Cortex. √à ci√≤ che utilizza il debugger integrato sul micro: bit della BBC.\n"
"* ST-Link √® una gamma di debugger in-circuit di ST Microelectronics, J-Link √® una gamma di\n"
"  SEGGER.\n"
"* La porta di accesso al debug √® in genere un'interfaccia JTAG a 5 pin o un cavo di debug seriale "
"a 2 pin.\n"
"* probe-rs √® una libreria che puoi integrare nei tuoi strumenti se lo desideri.\n"
"* Il [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/) "
"consente\n"
"  VSCode e altri IDE eseguono il debug del codice in esecuzione su qualsiasi microcontrollore "
"supportato.\n"
"* cargo-embed √® un binario creato utilizzando la libreria probe-rs.\n"
"* RTT (Real Time Transfers) √® un meccanismo per trasferire i dati tra l'host di debug e il target\n"
"  attraverso una serie di ringbuffer."

#: src/bare-metal/microcontrollers/debugging.md:1
#, fuzzy
msgid "# Debugging"
msgstr "# Debug"

#: src/bare-metal/microcontrollers/debugging.md:3
#, fuzzy
msgid "Embed.toml:"
msgstr "Incorpora.toml:"

#: src/bare-metal/microcontrollers/debugging.md:5
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:13
#, fuzzy
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "In un terminale sotto `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md:15
msgid ""
"```sh\n"
"cargo embed --bin board_support debug\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:19
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "In un altro terminale nella stessa directory:"

#: src/bare-metal/microcontrollers/debugging.md:21
msgid ""
"```sh\n"
"gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=\"target "
"remote :1337\"\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:27
#, fuzzy
msgid "In GDB, try running:"
msgstr "In GDB, prova a eseguire:"

#: src/bare-metal/microcontrollers/debugging.md:29
msgid ""
"```gdb\n"
"b src/bin/board_support.rs:29\n"
"b src/bin/board_support.rs:30\n"
"b src/bin/board_support.rs:32\n"
"c\n"
"c\n"
"c\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:1 src/bare-metal/aps/other-projects.md:1
#, fuzzy
msgid "# Other projects"
msgstr "# Altri progetti"

#: src/bare-metal/microcontrollers/other-projects.md:3
#, fuzzy
msgid ""
" * [RTIC](https://rtic.rs/)\n"
"   * \"Real-Time Interrupt-driven Concurrency\"\n"
"   * Shared resource management, message passing, task scheduling, timer queue\n"
" * [Embassy](https://embassy.dev/)\n"
"   * `async` executors with priorities, timers, networking, USB\n"
" * [TockOS](https://www.tockos.org/documentation/getting-started)\n"
"   * Security-focused RTOS with preemptive scheduling and Memory Protection Unit support\n"
" * [Hubris](https://hubris.oxide.computer/)\n"
"   * Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, "
"IPC\n"
" * [Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)\n"
" * Some platforms have `std` implementations, e.g.\n"
"   [esp-idf](https://esp-rs.github.io/book/overview/using-the-standard-library.html)."
msgstr ""
" * [RTIC](https://rtic.rs/)\n"
"   * \"Concorrenza basata su interrupt in tempo reale\"\n"
"   * Gestione delle risorse condivise, passaggio di messaggi, pianificazione delle attivit√†, coda "
"del timer\n"
" * [Ambasciata](https://embassy.dev/)\n"
"   * Esecutori `async` con priorit√†, timer, networking, USB\n"
" * [TockOS](https://www.tockos.org/documentation/getting-started)\n"
"   * RTOS incentrato sulla sicurezza con pianificazione preventiva e supporto dell'unit√† di "
"protezione della memoria\n"
" * [Hubris](https://hubris.oxide.computer/)\n"
"   * Microkernel RTOS di Oxide Computer Company con protezione della memoria, driver non "
"privilegiati, IPC\n"
" * [Binding per FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)\n"
" * Alcune piattaforme hanno implementazioni `std`, ad es.\n"
"   [esp-idf](https://esp-rs.github.io/book/overview/using-the-standard-library.html)."

#: src/bare-metal/microcontrollers/other-projects.md:18
#, fuzzy
msgid ""
" * RTIC can be considered either an RTOS or a concurrency framework.\n"
"   * It doesn't include any HALs.\n"
"   * It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for scheduling rather than a\n"
"     proper kernel.\n"
"   * Cortex-M only.\n"
" * Google uses TockOS on the Haven microcontroller for Titan security keys.\n"
" * FreeRTOS is mostly written in C, but there are Rust bindings for writing applications."
msgstr ""
" * RTIC pu√≤ essere considerato un RTOS o un framework di concorrenza.\n"
"   * Non include nessun HAL.\n"
"   * Utilizza Cortex-M NVIC (Nested Virtual Interrupt Controller) per la pianificazione piuttosto "
"che un\n"
"     kernel corretto.\n"
"   * Solo Cortex-M.\n"
" * Google utilizza TockOS sul microcontrollore Haven per le chiavi di sicurezza Titan.\n"
" * FreeRTOS √® principalmente scritto in C, ma ci sono collegamenti Rust per la scrittura di "
"applicazioni."

#: src/exercises/bare-metal/morning.md:3
#, fuzzy
msgid "We will read the direction from an I2C compass, and log the readings to a serial port."
msgstr "Leggeremo la direzione da una bussola I2C e registreremo le letture su una porta seriale."

#: src/exercises/bare-metal/compass.md:1
#, fuzzy
msgid "# Compass"
msgstr "# Bussola"

#: src/exercises/bare-metal/compass.md:3
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a serial port. If you "
"have\n"
"time, try displaying it on the LEDs somehow too, or use the buttons somehow."
msgstr ""
"Leggeremo la direzione da una bussola I2C e registreremo le letture su una porta seriale. Se hai\n"
"tempo, prova a visualizzarlo in qualche modo anche sui LED o usa i pulsanti in qualche modo."

#: src/exercises/bare-metal/compass.md:6
#, fuzzy
msgid "Hints:"
msgstr "Suggerimenti:"

#: src/exercises/bare-metal/compass.md:8
#, fuzzy
msgid ""
"- Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) and\n"
"  [`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) crates, as well as the\n"
"  [micro:bit hardware](https://tech.microbit.org/hardware/).\n"
"- The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.\n"
"- TWI is another name for I2C, so the I2C master peripheral is called TWIM.\n"
"- The LSM303AGR driver needs something implementing the `embedded_hal::blocking::i2c::WriteRead`\n"
"  trait. The\n"
"  [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"struct\n"
"  implements this.\n"
"- You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/struct.Board.html)\n"
"  struct with fields for the various pins and peripherals.\n"
"- You can also look at the\n"
"  [nRF52833 datasheet](https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf) if you want, "
"but\n"
"  it shouldn't be necessary for this exercise."
msgstr ""
"- Controlla la documentazione per [`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) e\n"
"  [`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) e le\n"
"  [micro:bit hardware](https://tech.microbit.org/hardware/).\n"
"- L'unit√† di misura inerziale LSM303AGR √® collegata al bus I2C interno.\n"
"- TWI √® un altro nome per I2C, quindi la periferica master I2C si chiama TWIM.\n"
"- Il driver LSM303AGR necessita di qualcosa che implementi `embedded_hal::blocking::i2c::"
"WriteRead`\n"
"  tratto. IL\n"
"  [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html) "
"struttura\n"
"  implementa questo.\n"
"- Hai un [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/struct.Board.html)\n"
"  struct con campi per i vari pin e periferiche.\n"
"- Puoi anche guardare il\n"
"  [scheda tecnica nRF52833](https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf) se vuoi, "
"ma\n"
"  non dovrebbe essere necessario per questo esercizio."

#: src/exercises/bare-metal/compass.md:23
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and look in the "
"`compass`\n"
"directory for the following files."
msgstr ""
"Scarica il [modello di esercizio](../../comprehensive-rust-exercises.zip) e guarda nella "
"`bussola`\n"
"directory per i seguenti file."

#: src/exercises/bare-metal/compass.md:26 src/exercises/bare-metal/rtc.md:19
#: src/exercises/concurrency/elevator.md:17
#, fuzzy
msgid "`src/main.rs`:"
msgstr "`src/principale.rs`:"

#: src/exercises/bare-metal/compass.md:28 src/exercises/bare-metal/rtc.md:21
#: src/exercises/concurrency/dining-philosophers.md:17 src/exercises/concurrency/link-checker.md:55
#: src/exercises/concurrency/dining-philosophers-async.md:11 src/exercises/concurrency/elevator.md:19
#, fuzzy
msgid "<!-- File src/main.rs -->"
msgstr "<!-- File src/main.rs -->"

#: src/exercises/bare-metal/compass.md:30
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:64 src/exercises/bare-metal/rtc.md:385
#: src/exercises/concurrency/elevator.md:365
#, fuzzy
msgid "`Cargo.toml` (you shouldn't need to change this):"
msgstr "`Cargo.toml` (non dovrebbe essere necessario modificarlo):"

#: src/exercises/bare-metal/compass.md:66 src/exercises/bare-metal/rtc.md:387
#: src/exercises/concurrency/dining-philosophers.md:63 src/exercises/concurrency/link-checker.md:35
#: src/exercises/concurrency/dining-philosophers-async.md:60
#: src/exercises/concurrency/elevator.md:367
#, fuzzy
msgid "<!-- File Cargo.toml -->"
msgstr "<!-- File Cargo.toml -->"

#: src/exercises/bare-metal/compass.md:68
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"compass\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"cortex-m-rt = \"0.7.3\"\n"
"embedded-hal = \"0.2.6\"\n"
"lsm303agr = \"0.2.2\"\n"
"microbit-v2 = \"0.13.0\"\n"
"panic-halt = \"0.2.0\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:85
#, fuzzy
msgid "`Embed.toml` (you shouldn't need to change this):"
msgstr "`Embed.toml` (non dovrebbe essere necessario modificarlo):"

#: src/exercises/bare-metal/compass.md:87
#, fuzzy
msgid "<!-- File Embed.toml -->"
msgstr "<!-- File Incorpora.toml -->"

#: src/exercises/bare-metal/compass.md:89
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"\n"
"[debug.reset]\n"
"halt_afterwards = true\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:100 src/exercises/bare-metal/rtc.md:985
#, fuzzy
msgid "`.cargo/config.toml` (you shouldn't need to change this):"
msgstr "`.cargo/config.toml` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/compass.md:102 src/exercises/bare-metal/rtc.md:987
#, fuzzy
msgid "<!-- File .cargo/config.toml -->"
msgstr "<!-- File .cargo/config.toml -->"

#: src/exercises/bare-metal/compass.md:104
msgid ""
"```toml\n"
"[build]\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\"-C\", \"link-arg=-Tlink.x\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:112
#, fuzzy
msgid "See the serial output on Linux with:"
msgstr "Guarda l'output seriale su Linux con:"

#: src/exercises/bare-metal/compass.md:114
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/ttyACM0\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
#, fuzzy
msgid "Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"O su Mac OS qualcosa di simile (il nome del dispositivo potrebbe essere leggermente diverso):"

#: src/exercises/bare-metal/compass.md:120
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:124
#, fuzzy
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Usa Ctrl+A Ctrl+Q per uscire da picocom."

#: src/bare-metal/aps.md:1
#, fuzzy
msgid "# Application processors"
msgstr "# Processori di applicazioni"

#: src/bare-metal/aps.md:3
#, fuzzy
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. Now let's try "
"writing\n"
"something for Cortex-A. For simplicity we'll just work with QEMU's aarch64\n"
"['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) board."
msgstr ""
"Finora abbiamo parlato di microcontrollori, come la serie Arm Cortex-M. Ora proviamo a scrivere\n"
"qualcosa per Cortex-A. Per semplicit√† lavoreremo solo con aarch64 di QEMU\n"
"['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) scheda."

#: src/bare-metal/aps.md:9
#, fuzzy
msgid ""
"* Broadly speaking, microcontrollers don't have an MMU or multiple levels of privilege (exception\n"
"  levels on Arm CPUs, rings on x86), while application processors do.\n"
"* QEMU supports emulating various different machines or board models for each architecture. The\n"
"  'virt' board doesn't correspond to any particular real hardware, but is designed purely for\n"
"  virtual machines."
msgstr ""
"* In generale, i microcontrollori non hanno una MMU o pi√π livelli di privilegio (eccezione\n"
"  livelli su CPU Arm, anelli su x86), mentre i processori delle applicazioni lo fanno.\n"
"* QEMU supporta l'emulazione di diverse macchine o modelli di scheda per ciascuna architettura. "
"IL\n"
"  La scheda 'virt' non corrisponde a nessun particolare hardware reale, ma √® progettata "
"esclusivamente per\n"
"  macchine virtuali."

#: src/bare-metal/aps/inline-assembly.md:1
#, fuzzy
msgid "# Inline assembly"
msgstr "# Assemblaggio in linea"

#: src/bare-metal/aps/inline-assembly.md:3
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with Rust code. For example,\n"
"to make an <abbr title=\"hypervisor call\">HVC</abbr> to tell the firmware to power off the system:"
msgstr ""
"A volte abbiamo bisogno di usare l'assembly per fare cose che non sono possibili con il codice "
"Rust. Per esempio,\n"
"per effettuare un <abbr title=\"hypervisor call\">HVC</abbr> per dire al firmware di spegnere il "
"sistema:"

#: src/bare-metal/aps/inline-assembly.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
"    unsafe {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            options(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:39
#, fuzzy
msgid ""
"(If you actually want to do this, use the [`smccc`][1] crate which has wrappers for all these "
"functions.)"
msgstr "(Se vuoi davvero farlo, usa la cassa [`smccc`][1] che ha wrapper per tutte queste funzioni.)"

#: src/bare-metal/aps/inline-assembly.md:43
#, fuzzy
msgid ""
"* PSCI is the Arm Power State Coordination Interface, a standard set of functions to manage "
"system\n"
"  and CPU power states, among other things. It is implemented by EL3 firmware and hypervisors on\n"
"  many systems.\n"
"* The `0 => _` syntax means initialise the register to 0 before running the inline assembly code,\n"
"  and ignore its contents afterwards. We need to use `inout` rather than `in` because the call "
"could\n"
"  potentially clobber the contents of the registers.\n"
"* This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because it is called from "
"our\n"
"  entry point in `entry.S`.\n"
"* `_x0`‚Äì`_x3` are the values of registers `x0`‚Äì`x3`, which are conventionally used by the "
"bootloader\n"
"  to pass things like a pointer to the device tree. According to the standard aarch64 calling\n"
"  convention (which is what `extern \"C\"` specifies to use), registers `x0`‚Äì`x7` are used for "
"the\n"
"  first 8 arguments passed to a function, so `entry.S` doesn't need to do anything special except\n"
"  make sure it doesn't change these registers.\n"
"* Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/examples`."
msgstr ""
"* PSCI √® l'Arm Power State Coordination Interface, un insieme standard di funzioni per gestire il "
"sistema\n"
"  e gli stati di alimentazione della CPU, tra le altre cose. √à implementato dal firmware EL3 e "
"dagli hypervisor su\n"
"  molti sistemi.\n"
"* La sintassi `0 => _` significa inizializzare il registro a 0 prima di eseguire il codice "
"assembly inline,\n"
"  e ignorarne il contenuto in seguito. Dobbiamo usare \"inout\" piuttosto che \"in\" perch√© la "
"chiamata potrebbe\n"
"  potenzialmente intasare il contenuto dei registri.\n"
"* Questa funzione `main` deve essere `#[no_mangle]` e `extern \"C\"` perch√© viene chiamata dal "
"nostro\n"
"  punto di ingresso in \"entry.S\".\n"
"* `_x0`‚Äì`_x3` sono i valori dei registri `x0`‚Äì`x3`, che sono convenzionalmente utilizzati dal "
"bootloader\n"
"  per passare cose come un puntatore all'albero dei dispositivi. Secondo la chiamata standard "
"aarch64\n"
"  convenzione (che √® ci√≤ che `extern \"C\"` specifica di usare), i registri `x0`‚Äì`x7` sono usati "
"per\n"
"  primi 8 argomenti passati a una funzione, quindi `entry.S` non ha bisogno di fare niente di "
"speciale tranne\n"
"  assicurati che non modifichi questi registri.\n"
"* Eseguire l'esempio in QEMU con `make qemu_psci` in `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/mmio.md:1
#, fuzzy
msgid "# Volatile memory access for MMIO"
msgstr "# Accesso alla memoria volatile per MMIO"

#: src/bare-metal/aps/mmio.md:3
#, fuzzy
msgid ""
" * Use `pointer::read_volatile` and `pointer::write_volatile`.\n"
" * Never hold a reference.\n"
" * `addr_of!` lets you get fields of structs without creating an intermediate reference."
msgstr ""
" * Usa `pointer::read_volatile` e `pointer::write_volatile`.\n"
" * Non tenere mai un riferimento.\n"
" * `addr_of!` consente di ottenere campi di struct senza creare un riferimento intermedio."

#: src/bare-metal/aps/mmio.md:9
#, fuzzy
msgid ""
" * Volatile access: read or write operations may have side-effects, so prevent the compiler or\n"
"   hardware from reordering, duplicating or eliding them.\n"
"   * Usually if you write and then read, e.g. via a mutable reference, the compiler may assume "
"that\n"
"     the value read is the same as the value just written, and not bother actually reading "
"memory.\n"
" * Some existing crates for volatile access to hardware do hold references, but this is unsound.\n"
"   Whenever a reference exist, the compiler may choose to dereference it.\n"
" * Use the `addr_of!` macro to get struct field pointers from a pointer to the struct."
msgstr ""
" * Accesso volatile: le operazioni di lettura o scrittura possono avere effetti collaterali, "
"quindi impedisci al compilatore o\n"
"   hardware dal riordinarli, duplicarli o eliminarli.\n"
"   * Di solito se scrivi e poi leggi, ad es. tramite un riferimento mutabile, il compilatore pu√≤ "
"assumerlo\n"
"     il valore letto √® uguale al valore appena scritto, e non disturba effettivamente la lettura "
"della memoria.\n"
" * Alcuni crate esistenti per l'accesso volatile all'hardware contengono riferimenti, ma questo "
"non √® corretto.\n"
"   Ogni volta che esiste un riferimento, il compilatore pu√≤ scegliere di dereferenziarlo.\n"
" * Usa la macro `addr_of!` per ottenere i puntatori di campo struct da un puntatore alla struct."

#: src/bare-metal/aps/uart.md:1
#, fuzzy
msgid "# Let's write a UART driver"
msgstr "# Scriviamo un driver UART"

#: src/bare-metal/aps/uart.md:3
#, fuzzy
msgid "The QEMU 'virt' machine has a [PL011][1] UART, so let's write a driver for that."
msgstr "La macchina QEMU 'virt' ha un [PL011][1] UART, quindi scriviamo un driver per quello."

#: src/bare-metal/aps/uart.md:5
msgid ""
"```rust,editable\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Minimal driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of a\n"
"    /// PL011 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart.md:55
#, fuzzy
msgid ""
"* Note that `Uart::new` is unsafe while the other methods are safe. This is because as long as "
"the\n"
"  caller of `Uart::new` guarantees that its safety requirements are met (i.e. that there is only\n"
"  ever one instance of the driver for a given UART, and nothing else aliasing its address space),\n"
"  then it is always safe to call `write_byte` later because we can assume the necessary\n"
"  preconditions.\n"
"* We could have done it the other way around (making `new` safe but `write_byte` unsafe), but "
"that\n"
"  would be much less convenient to use as every place that calls `write_byte` would need to "
"reason\n"
"  about the safety\n"
"* This is a common pattern for writing safe wrappers of unsafe code: moving the burden of proof "
"for\n"
"  soundness from a large number of places to a smaller number of places."
msgstr ""
"* Nota che `Uart::new` non √® sicuro mentre gli altri metodi sono sicuri. Questo perch√© finch√© il\n"
"  chiamante di `Uart::new` garantisce che i suoi requisiti di sicurezza siano soddisfatti (cio√® "
"che ci sia solo\n"
"  mai un'istanza del driver per un dato UART, e nient'altro che alias il suo spazio degli "
"indirizzi),\n"
"  quindi √® sempre sicuro chiamare `write_byte` in seguito perch√© possiamo assumere il necessario\n"
"  precondizioni.\n"
"* Avremmo potuto fare il contrario (rendere `new` sicuro ma `write_byte` non sicuro), ma quello\n"
"  sarebbe molto meno conveniente da usare poich√© ogni posto che chiama `write_byte` dovrebbe "
"ragionare\n"
"  sulla sicurezza\n"
"* Questo √® un modello comune per scrivere wrapper sicuri di codice non sicuro: spostare l'onere "
"della prova per\n"
"  solidit√† da un gran numero di posti a un numero minore di posti."

#: src/bare-metal/aps/uart.md:66
#, fuzzy
msgid "</detais>"
msgstr "</detais>"

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "# More traits"
msgstr "# Altri tratti"

#: src/bare-metal/aps/uart/traits.md:3
#, fuzzy
msgid "We derived the `Debug` trait. It would be useful to implement a few more traits too."
msgstr "Abbiamo derivato il tratto `Debug`. Sarebbe utile implementare anche qualche altro tratto."

#: src/bare-metal/aps/uart/traits.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:24
#, fuzzy
msgid ""
"* Implementing `Write` lets us use the `write!` and `writeln!` macros with our `Uart` type.\n"
"* Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/examples`."
msgstr ""
"* L'implementazione di `Write` ci permette di usare le macro `write!` e `writeln!` con il nostro "
"tipo `Uart`.\n"
"* Esegui l'esempio in QEMU con `make qemu_minimal` sotto `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/better-uart.md:1
#, fuzzy
msgid "# A better UART driver"
msgstr "# Un driver UART migliore"

#: src/bare-metal/aps/better-uart.md:3
#, fuzzy
msgid ""
"The PL011 actually has [a bunch more registers][1], and adding offsets to construct pointers to "
"access\n"
"them is error-prone and hard to read. Plus, some of them are bit fields which would be nice to\n"
"access in a structured way."
msgstr ""
"Il PL011 in realt√† ha [un mucchio di registri in pi√π][1] e aggiunge offset per costruire puntatori "
"a cui accedere\n"
"√® soggetto a errori e difficile da leggere. Inoltre, alcuni di loro sono campi di bit che "
"sarebbero carini\n"
"accedere in modo strutturato."

#: src/bare-metal/aps/better-uart.md:7
#, fuzzy
msgid ""
"| Offset | Register name | Width |\n"
"| ------ | ------------- | ----- |\n"
"| 0x00   | DR            | 12    |\n"
"| 0x04   | RSR           | 4     |\n"
"| 0x18   | FR            | 9     |\n"
"| 0x20   | ILPR          | 8     |\n"
"| 0x24   | IBRD          | 16    |\n"
"| 0x28   | FBRD          | 6     |\n"
"| 0x2c   | LCR_H         | 8     |\n"
"| 0x30   | CR            | 16    |\n"
"| 0x34   | IFLS          | 6     |\n"
"| 0x38   | IMSC          | 11    |\n"
"| 0x3c   | RIS           | 11    |\n"
"| 0x40   | MIS           | 11    |\n"
"| 0x44   | ICR           | 11    |\n"
"| 0x48   | DMACR         | 3     |"
msgstr ""
"| Compensazione | Registra nome | Larghezza |\n"
"| ------ | ------------- | ----- |\n"
"| 0x00 | DR | 12 |\n"
"| 0x04 | RSR | 4 |\n"
"| 0x18 | FR | 9 |\n"
"| 0x20 | ILPR | 8 |\n"
"| 0x24 | BIRS | 16 |\n"
"| 0x28 | FBRD | 6 |\n"
"| 0x2c | LCR_H | 8 |\n"
"| 0x30 | CR | 16 |\n"
"| 0x34 | IFL | 6 |\n"
"| 0x38 | IMSC | 11 |\n"
"| 0x3c | RIS| 11 |\n"
"| 0x40 | MIS | 11 |\n"
"| 0x44 | CRI | 11 |\n"
"| 0x48 | DMACR | 3 |"

#: src/bare-metal/aps/better-uart.md:26
#, fuzzy
msgid "- There are also some ID registers which have been omitted for brevity."
msgstr "- Sono inoltre presenti alcuni registri identificativi che per brevit√† sono stati omessi."

#: src/bare-metal/aps/better-uart/bitflags.md:1
#, fuzzy
msgid "# Bitflags"
msgstr "# Bitflag"

#: src/bare-metal/aps/better-uart/bitflags.md:3
#, fuzzy
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for working with bitflags."
msgstr ""
"Il crate [`bitflags`](https://crates.io/crates/bitflags) √® utile per lavorare con i bitflags."

#: src/bare-metal/aps/better-uart/bitflags.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:37
#, fuzzy
msgid ""
"* The `bitflags!` macro creates a newtype something like `Flags(u16)`, along with a bunch of "
"method\n"
"  implementations to get and set flags."
msgstr ""
"* La macro `bitflags!` crea un nuovo tipo qualcosa come `Flags(u16)`, insieme a una serie di "
"metodi\n"
"  implementazioni per ottenere e impostare flag."

#: src/bare-metal/aps/better-uart/registers.md:1
#, fuzzy
msgid "# Multiple registers"
msgstr "# Pi√π registri"

#: src/bare-metal/aps/better-uart/registers.md:3
#, fuzzy
msgid "We can use a struct to represent the memory layout of the UART's registers."
msgstr "Possiamo usare una struct per rappresentare il layout di memoria dei registri dell'UART."

#: src/bare-metal/aps/better-uart/registers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:41
#, fuzzy
msgid ""
"* [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-representation) tells\n"
"  the compiler to lay the struct fields out in order, following the same rules as C. This is\n"
"  necessary for our struct to have a predictable layout, as default Rust representation allows "
"the\n"
"  compiler to (among other things) reorder fields however it sees fit."
msgstr ""
"* [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-representation) "
"indica\n"
"  il compilatore per disporre i campi struct in ordine, seguendo le stesse regole di C. Questo √®\n"
"  necessario affinch√© la nostra struttura abbia un layout prevedibile, poich√© la rappresentazione "
"predefinita di Rust lo consente\n"
"  compilatore per (tra le altre cose) riordinare i campi come meglio crede."

#: src/bare-metal/aps/better-uart/driver.md:1
#, fuzzy
msgid "# Driver"
msgstr "# Autista"

#: src/bare-metal/aps/better-uart/driver.md:3
#, fuzzy
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "Ora usiamo la nuova struttura `Registers` nel nostro driver."

#: src/bare-metal/aps/better-uart/driver.md:5
msgid ""
"```rust,editable,compile_fail\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of a\n"
"    /// PL011 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:64
#, fuzzy
msgid ""
"* Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual fields without "
"creating\n"
"  an intermediate reference, which would be unsound."
msgstr ""
"* Notare l'uso di `addr_of!` / `addr_of_mut!` per ottenere puntatori a singoli campi senza creare\n"
"  un riferimento intermedio, che sarebbe errato."

#: src/bare-metal/aps/better-uart/using.md:1 src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "# Using it"
msgstr "# Usandolo"

#: src/bare-metal/aps/better-uart/using.md:3
#, fuzzy
msgid ""
"Let's write a small program using our driver to write to the serial console, and echo incoming\n"
"bytes."
msgstr ""
"Scriviamo un piccolo programma usando il nostro driver per scrivere sulla console seriale ed echo "
"in entrata\n"
"byte."

#: src/bare-metal/aps/better-uart/using.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(b) = uart.read_byte() {\n"
"            uart.write_byte(b);\n"
"            match b {\n"
"                b'\\r' => {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' => break,\n"
"                _ => {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
#, fuzzy
msgid ""
"* As in the [inline assembly](../inline-assembly.md) example, this `main` function is called from "
"our\n"
"  entry point code in `entry.S`. See the speaker notes there for details.\n"
"* Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"* Come nell'esempio [inline assembly](../inline-assembly.md), questa funzione `main` √® chiamata "
"dal nostro\n"
"  codice del punto di ingresso in \"entry.S\". Vedi le note del relatore l√¨ per i dettagli.\n"
"* Esegui l'esempio in QEMU con `make qemu` sotto `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/logging.md:3
#, fuzzy
msgid ""
"It would be nice to be able to use the logging macros from the [`log`][1] crate. We can do this "
"by\n"
"implementing the `Log` trait."
msgstr ""
"Sarebbe bello poter usare le macro di registrazione dalla cassa [`log`][1]. Possiamo farlo con\n"
"implementando il tratto `Log`."

#: src/bare-metal/aps/logging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging.md:50
#, fuzzy
msgid "* The unwrap in `log` is safe because we initialise `LOGGER` before calling `set_logger`."
msgstr "* L'unwrap in `log` √® sicuro perch√© inizializziamo `LOGGER` prima di chiamare `set_logger`."

#: src/bare-metal/aps/logging/using.md:3
#, fuzzy
msgid "We need to initialise the logger before we use it."
msgstr "Dobbiamo inizializzare il logger prima di usarlo."

#: src/bare-metal/aps/logging/using.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
#, fuzzy
msgid ""
"* Note that our panic handler can now log details of panics.\n"
"* Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/examples`."
msgstr ""
"* Nota che il nostro gestore del panico ora pu√≤ registrare i dettagli dei panico.\n"
"* Eseguire l'esempio in QEMU con `make qemu_logger` in `src/bare-metal/aps/examples`."

#: src/bare-metal/aps/other-projects.md:3
#, fuzzy
msgid ""
" * [oreboot](https://github.com/oreboot/oreboot)\n"
"   * \"coreboot without the C\"\n"
"   * Supports x86, aarch64 and RISC-V.\n"
"   * Relies on LinuxBoot rather than having many drivers itself.\n"
" * [Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials)\n"
"   * Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling, "
"page tables\n"
"   * Not all very well written, so beware.\n"
" * [`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)\n"
"   * Static analysis to determine maximum stack usage."
msgstr ""
" * [oreboot](https://github.com/oreboot/oreboot)\n"
"   * \"coreboot senza la C\"\n"
"   * Supporta x86, aarch64 e RISC-V.\n"
"   * Si basa su LinuxBoot piuttosto che avere molti driver.\n"
" * [Tutorial sul sistema operativo Rust RaspberryPi](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)\n"
"   * Inizializzazione, driver UART, bootloader semplice, JTAG, livelli di eccezione, gestione "
"delle eccezioni, tabelle delle pagine\n"
"   * Non tutto molto ben scritto, quindi attenzione.\n"
" * [`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)\n"
"   * Analisi statica per determinare l'utilizzo massimo dello stack."

#: src/bare-metal/useful-crates.md:1
#, fuzzy
msgid "# Useful crates"
msgstr "# Casse utili"

#: src/bare-metal/useful-crates.md:3
#, fuzzy
msgid "We'll go over a few crates which solve some common problems in bare-metal programming."
msgstr ""
"Esamineremo alcune casse che risolvono alcuni problemi comuni nella programmazione bare-metal."

#: src/bare-metal/useful-crates/zerocopy.md:1
#, fuzzy
msgid "# `zerocopy`"
msgstr "# `zerocopia`"

#: src/bare-metal/useful-crates/zerocopy.md:3
#, fuzzy
msgid ""
"The [`zerocopy`][1] crate (from Fuchsia) provides traits and macros for safely converting between\n"
"byte sequences and other types."
msgstr ""
"La cassa [`zerocopy`][1] (da Fuchsia) fornisce tratti e macro per la conversione sicura tra\n"
"sequenze di byte e altri tipi."

#: src/bare-metal/useful-crates/zerocopy.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use zerocopy::AsBytes;\n"
"\n"
"#[repr(u32)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"enum RequestType {\n"
"    #[default]\n"
"    In = 0,\n"
"    Out = 1,\n"
"    Flush = 4,\n"
"}\n"
"\n"
"#[repr(C)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"struct VirtioBlockRequest {\n"
"    request_type: RequestType,\n"
"    reserved: u32,\n"
"    sector: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let request = VirtioBlockRequest {\n"
"        request_type: RequestType::Flush,\n"
"        sector: 42,\n"
"        ..Default::default()\n"
"    };\n"
"\n"
"    assert_eq!(\n"
"        request.as_bytes(),\n"
"        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:40
#, fuzzy
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), but can be useful "
"for\n"
"working with structures shared with hardware e.g. by DMA, or sent over some external interface."
msgstr ""
"Questo non √® adatto per MMIO (poich√© non utilizza letture e scritture volatili), ma pu√≤ essere "
"utile per\n"
"lavorare con strutture condivise con l'hardware, ad es. tramite DMA o inviato tramite "
"un'interfaccia esterna."

#: src/bare-metal/useful-crates/zerocopy.md:45
#, fuzzy
msgid ""
"* `FromBytes` can be implemented for types for which any byte pattern is valid, and so can safely "
"be\n"
"  converted from an untrusted sequence of bytes.\n"
"* Attempting to derive `FromBytes` for these types would fail, because `RequestType` doesn't use "
"all\n"
"  possible u32 values as discriminants, so not all byte patterns are valid.\n"
"* `zerocopy::byteorder` has types for byte-order aware numeric primitives.\n"
"* Run the example with `cargo run` under `src/bare-metal/useful-crates/zerocopy-example/`. (It "
"won't\n"
"  run in the Playground because of the crate dependency.)"
msgstr ""
"* `FromBytes` pu√≤ essere implementato per i tipi per i quali qualsiasi modello di byte √® valido, e "
"quindi pu√≤ tranquillamente esserlo\n"
"  convertito da una sequenza di byte non attendibile.\n"
"* Il tentativo di derivare `FromBytes` per questi tipi fallirebbe, perch√© `RequestType` non usa "
"tutti\n"
"  possibili valori u32 come discriminanti, quindi non tutti i modelli di byte sono validi.\n"
"* `zerocopy::byteorder` ha tipi per primitive numeriche che riconoscono l'ordine dei byte.\n"
"* Esegui l'esempio con `cargo run` sotto `src/bare-metal/useful-crates/zerocopy-example/`. (Non lo "
"far√†\n"
"  eseguito nel Parco giochi a causa della dipendenza dalla cassa.)"

#: src/bare-metal/useful-crates/aarch64-paging.md:1
#, fuzzy
msgid "# `aarch64-paging`"
msgstr "# `aarch64-paging`"

#: src/bare-metal/useful-crates/aarch64-paging.md:3
#, fuzzy
msgid ""
"The [`aarch64-paging`][1] crate lets you create page tables according to the AArch64 Virtual "
"Memory\n"
"System Architecture."
msgstr ""
"Il crate [`aarch64-paging`][1] consente di creare tabelle di pagine in base alla memoria virtuale "
"AArch64\n"
"Architettura di sistema."

#: src/bare-metal/useful-crates/aarch64-paging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paging::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Create a new page table with identity mapping.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map a 2 MiB region of memory as read-only.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Set `TTBR0_EL1` to activate the page table.\n"
"idmap.activate();\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
#, fuzzy
msgid ""
"* For now it only supports EL1, but support for other exception levels should be straightforward "
"to\n"
"  add.\n"
"* This is used in Android for the [Protected VM Firmware][2].\n"
"* There's no easy way to run this example, as it needs to run on real hardware or under QEMU."
msgstr ""
"* Per ora supporta solo EL1, ma il supporto per altri livelli di eccezione dovrebbe essere "
"semplice\n"
"  aggiungere.\n"
"* Viene utilizzato in Android per il [Firmware VM protetto][2].\n"
"* Non esiste un modo semplice per eseguire questo esempio, poich√© deve essere eseguito su hardware "
"reale o sotto QEMU."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:1
#, fuzzy
msgid "# `buddy_system_allocator`"
msgstr "# `buddy_system_allocator`"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
#, fuzzy
msgid ""
"[`buddy_system_allocator`][1] is a third-party crate implementing a basic buddy system allocator.\n"
"It can be used both for [`LockedHeap`][2] implementing [`GlobalAlloc`][3] so you can use the\n"
"standard `alloc` crate (as we saw [before][4]), or for allocating other address space. For "
"example,\n"
"we might want to allocate MMIO space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`][1] √® un crate di terze parti che implementa un allocatore di sistema "
"buddy di base.\n"
"Pu√≤ essere utilizzato sia per [`LockedHeap`][2] che implementa [`GlobalAlloc`][3] in modo da poter "
"utilizzare il\n"
"crate standard `alloc` (come abbiamo visto [prima][4]), o per allocare altro spazio di indirizzi. "
"Per esempio,\n"
"potremmo voler allocare spazio MMIO per PCI BAR:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use buddy_system_allocator::FrameAllocator;\n"
"use core::alloc::Layout;\n"
"\n"
"fn main() {\n"
"    let mut allocator = FrameAllocator::<32>::new();\n"
"    allocator.add_frame(0x200_0000, 0x400_0000);\n"
"\n"
"    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
"    let bar = allocator\n"
"        .alloc_aligned(layout)\n"
"        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
"    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:26
#, fuzzy
msgid ""
"* PCI BARs always have alignment equal to their size.\n"
"* Run the example with `cargo run` under `src/bare-metal/useful-crates/allocator-example/`. (It "
"won't\n"
"  run in the Playground because of the crate dependency.)"
msgstr ""
"* Le barre PCI hanno sempre un allineamento uguale alla loro dimensione.\n"
"* Esegui l'esempio con `cargo run` sotto `src/bare-metal/useful-crates/allocator-example/`. (Non "
"lo far√†\n"
"  eseguito nel Parco giochi a causa della dipendenza dalla cassa.)"

#: src/bare-metal/useful-crates/tinyvec.md:1
#, fuzzy
msgid "# `tinyvec`"
msgstr "# `tinyvec`"

#: src/bare-metal/useful-crates/tinyvec.md:3
#, fuzzy
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without heap allocation.\n"
"[`tinyvec`][1] provides this: a vector backed by an array or slice, which could be statically\n"
"allocated or on the stack, which keeps track of how many elements are used and panics if you try "
"to\n"
"use more than are allocated."
msgstr ""
"A volte vuoi qualcosa che possa essere ridimensionato come un `Vec`, ma senza allocazione "
"dell'heap.\n"
"[`tinyvec`][1] fornisce questo: un vettore supportato da un array o da una slice, che potrebbe "
"essere staticamente\n"
"allocato o in pila, che tiene traccia di quanti elementi vengono utilizzati e va in panico se ci "
"provi\n"
"utilizzare pi√π di quanto assegnato."

#: src/bare-metal/useful-crates/tinyvec.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use tinyvec::{array_vec, ArrayVec};\n"
"\n"
"fn main() {\n"
"    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.push(7);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.remove(1);\n"
"    println!(\"{numbers:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:23
#, fuzzy
msgid ""
"* `tinyvec` requires that the element type implement `Default` for initialisation.\n"
"* The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"* `tinyvec` richiede che il tipo di elemento implementi `Default` per l'inizializzazione.\n"
"* Rust Playground include `tinyvec`, quindi questo esempio funzioner√† correttamente in linea."

#: src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "# `spin`"
msgstr "# `gira`"

#: src/bare-metal/useful-crates/spin.md:3
#, fuzzy
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` are not available in\n"
"`core` or `alloc`. How can we manage synchronisation or interior mutability, such as for sharing\n"
"state between different CPUs?"
msgstr ""
"`std::sync::Mutex` e le altre primitive di sincronizzazione da `std::sync` non sono disponibili "
"in\n"
"`core` o `alloc`. Come gestire la sincronizzazione o la mutevolezza interiore, ad esempio per la "
"condivisione\n"
"stato tra diverse CPU?"

#: src/bare-metal/useful-crates/spin.md:7
#, fuzzy
msgid "The [`spin`][1] crate provides spinlock-based equivalents of many of these primitives."
msgstr "La cassa [`spin`][1] fornisce equivalenti basati su spinlock di molte di queste primitive."

#: src/bare-metal/useful-crates/spin.md:9
msgid ""
"```rust,editable,compile_fail\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
"\n"
"fn main() {\n"
"    println!(\"count: {}\", counter.lock());\n"
"    *counter.lock() += 2;\n"
"    println!(\"count: {}\", counter.lock());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:23
msgid ""
"* Be careful to avoid deadlock if you take locks in interrupt handlers.\n"
"* `spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, `Barrier` and "
"`Once`\n"
"  from `std::sync`;  and `Lazy` for lazy initialisation.\n"
"* The [`once_cell`][2] crate also has some useful types for late initialisation with a slightly\n"
"  different approach to `spin::once::Once`.\n"
"* The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""

#: src/bare-metal/android.md:1
#, fuzzy
msgid "# Android"
msgstr "#Androide"

#: src/bare-metal/android.md:3
#, fuzzy
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a `rust_ffi_static` Soong rule to "
"build\n"
"your Rust code, then a `cc_binary` with a linker script to produce the binary itself, and then a\n"
"`raw_binary` to convert the ELF to a raw binary ready to be run."
msgstr ""
"Per costruire un binario Rust bare-metal in AOSP, devi usare una regola `rust_ffi_static` Soong "
"per costruire\n"
"il tuo codice Rust, poi un `cc_binary` con uno script linker per produrre il binario stesso, e poi "
"a\n"
"`raw_binary` per convertire l'ELF in un binario grezzo pronto per essere eseguito."

#: src/bare-metal/android.md:7
msgid ""
"```soong\n"
"rust_ffi_static {\n"
"    name: \"libvmbase_example\",\n"
"    defaults: [\"vmbase_ffi_defaults\"],\n"
"    crate_name: \"vmbase_example\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libvmbase\",\n"
"    ],\n"
"}\n"
"\n"
"cc_binary {\n"
"    name: \"vmbase_example\",\n"
"    defaults: [\"vmbase_elf_defaults\"],\n"
"    srcs: [\n"
"        \"idmap.S\",\n"
"    ],\n"
"    static_libs: [\n"
"        \"libvmbase_example\",\n"
"    ],\n"
"    linker_scripts: [\n"
"        \"image.ld\",\n"
"        \":vmbase_sections\",\n"
"    ],\n"
"}\n"
"\n"
"raw_binary {\n"
"    name: \"vmbase_example_bin\",\n"
"    stem: \"vmbase_example.bin\",\n"
"    src: \":vmbase_example\",\n"
"    enabled: false,\n"
"    target: {\n"
"        android_arm64: {\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:1
#, fuzzy
msgid "# vmbase"
msgstr "# vbase"

#: src/bare-metal/android/vmbase.md:3
#, fuzzy
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase][1] library provides a linker script and "
"useful\n"
"defaults for the build rules, along with an entry point, UART console logging and more."
msgstr ""
"Per le VM in esecuzione in crosvm su aarch64, la libreria [vmbase][1] fornisce uno script linker e "
"utili\n"
"impostazioni predefinite per le regole di compilazione, insieme a un punto di ingresso, la "
"registrazione della console UART e altro ancora."

#: src/bare-metal/android/vmbase.md:6
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use vmbase::{main, println};\n"
"\n"
"main!(main);\n"
"\n"
"pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
"    println!(\"Hello world\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:21
#, fuzzy
msgid ""
"* The `main!` macro marks your main function, to be called from the `vmbase` entry point.\n"
"* The `vmbase` entry point handles console initialisation, and issues a PSCI_SYSTEM_OFF to "
"shutdown\n"
"  the VM if your main function returns."
msgstr ""
"* La macro `main!` contrassegna la tua funzione principale, da chiamare dal punto di ingresso "
"`vmbase`.\n"
"* Il punto di ingresso `vmbase` gestisce l'inizializzazione della console ed emette un "
"PSCI_SYSTEM_OFF per l'arresto\n"
"  la VM se la tua funzione principale ritorna."

#: src/exercises/bare-metal/afternoon.md:3
#, fuzzy
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "Scriveremo un driver per il dispositivo orologio in tempo reale PL031."

#: src/exercises/bare-metal/rtc.md:1
#, fuzzy
msgid "# RTC driver"
msgstr "# Driver RTC"

#: src/exercises/bare-metal/rtc.md:3
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031][1] real-time clock at 0x9010000. For this exercise, "
"you\n"
"should write a driver for it."
msgstr ""
"La macchina QEMU aarch64 virt ha un orologio in tempo reale [PL031][1] a 0x9010000. Per questo "
"esercizio, tu\n"
"dovrebbe scrivere un driver per esso."

#: src/exercises/bare-metal/rtc.md:6
#, fuzzy
msgid ""
"1. Use it to print the current time to the serial console. You can use the [`chrono`][2] crate "
"for\n"
"   date/time formatting.\n"
"2. Use the match register and raw interrupt status to busy-wait until a given time, e.g. 3 "
"seconds\n"
"   in the future. (Call [`core::hint::spin_loop`][3] inside the loop.)\n"
"3. _Extension if you have time:_ Enable and handle the interrupt generated by the RTC match. You "
"can\n"
"   use the driver provided in the [`arm-gic`][4] crate to configure the Arm Generic Interrupt "
"Controller.\n"
"   - Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`.\n"
"   - Once the interrupt is enabled, you can put the core to sleep via `arm_gic::wfi()`, which will "
"cause the core to sleep until it receives an interrupt.\n"
"   "
msgstr ""
"1. Usalo per stampare l'ora corrente sulla console seriale. Puoi usare la cassa [`chrono`][2] per\n"
"   formattazione data/ora.\n"
"2. Utilizzare il registro delle corrispondenze e lo stato di interrupt non elaborato per attendere "
"occupato fino a un determinato momento, ad es. 3 secondi\n"
"   in futuro. (Chiama [`core::hint::spin_loop`][3] all'interno del ciclo.)\n"
"3. _Estensione se hai tempo:_ Abilita e gestisci l'interrupt generato dalla corrispondenza RTC. "
"Puoi\n"
"   utilizzare il driver fornito nella cassa [`arm-gic`][4] per configurare Arm Generic Interrupt "
"Controller.\n"
"   - Usa l'interrupt RTC, che √® cablato al GIC come `IntId::spi(2)`.\n"
"   - Una volta abilitato l'interrupt, puoi mettere il core in sleep tramite `arm_gic::wfi()`, che "
"far√† dormire il core finch√© non riceve un interrupt.\n"
"   "

#: src/exercises/bare-metal/rtc.md:16
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and look in the `rtc`\n"
"directory for the following files."
msgstr ""
"Scarica il [modello di esercizio](../../comprehensive-rust-exercises.zip) e cerca in `rtc`\n"
"directory per i seguenti file."

#: src/exercises/bare-metal/rtc.md:23
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Create instance of RTC driver and print current time.\n"
"\n"
"    // TODO: Wait for 3 seconds.\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:75
#, fuzzy
msgid "`src/exceptions.rs` (you should only need to change this for the 3rd part of the exercise):"
msgstr "`src/exceptions.rs` (dovresti solo cambiarlo per la terza parte dell'esercizio):"

#: src/exercises/bare-metal/rtc.md:77
#, fuzzy
msgid "<!-- File src/exceptions.rs -->"
msgstr "<!-- File src/exception.rs -->"

#: src/exercises/bare-metal/rtc.md:79
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
#, fuzzy
msgid "`src/logger.rs` (you shouldn't need to change this):"
msgstr "`src/logger.rs` (non dovrebbe essere necessario modificarlo):"

#: src/exercises/bare-metal/rtc.md:151
#, fuzzy
msgid "<!-- File src/logger.rs -->"
msgstr "<!-- File src/logger.rs -->"

#: src/exercises/bare-metal/rtc.md:153
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: main\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:210
#, fuzzy
msgid "`src/pl011.rs` (you shouldn't need to change this):"
msgstr "`src/pl011.rs` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:212
#, fuzzy
msgid "<!-- File src/pl011.rs -->"
msgstr "<!-- File src/pl011.rs -->"

#: src/exercises/bare-metal/rtc.md:214
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Flags\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART Receive Status Register / Error Clear Register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 << 0;\n"
"        /// Parity error.\n"
"        const PE = 1 << 1;\n"
"        /// Break error.\n"
"        const BE = 1 << 2;\n"
"        /// Overrun error.\n"
"        const OE = 1 << 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Registers\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registers\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of a\n"
"    /// PL011 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:389
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"rtc\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"arm-gic = \"0.1.0\"\n"
"bitflags = \"2.0.0\"\n"
"chrono = { version = \"0.4.24\", default-features = false }\n"
"log = \"0.4.17\"\n"
"smccc = \"0.1.1\"\n"
"spin = \"0.9.8\"\n"
"\n"
"[build-dependencies]\n"
"cc = \"1.0.73\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:410
#, fuzzy
msgid "`build.rs` (you shouldn't need to change this):"
msgstr "`build.rs` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:412
#, fuzzy
msgid "<!-- File build.rs -->"
msgstr "<!-- File build.rs -->"

#: src/exercises/bare-metal/rtc.md:414
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:446
#, fuzzy
msgid "`entry.S` (you shouldn't need to change this):"
msgstr "`entry.S` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:448
#, fuzzy
msgid "<!-- File entry.S -->"
msgstr "<!-- Voce file.S -->"

#: src/exercises/bare-metal/rtc.md:450
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << 28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | ."
"L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations required to prepare "
"the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-"
"x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:595
#, fuzzy
msgid "`exceptions.S` (you shouldn't need to change this):"
msgstr "`eccezioni.S` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:597
#, fuzzy
msgid "<!-- File exceptions.S -->"
msgstr "<!-- File eccezioni.S -->"

#: src/exercises/bare-metal/rtc.md:599
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,\n"
" * which can be used as the first and second arguments of a subsequent call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving 18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:780
#, fuzzy
msgid "`idmap.S` (you shouldn't need to change this):"
msgstr "`idmap.S` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:782
#, fuzzy
msgid "<!-- File idmap.S -->"
msgstr "<!-- File idmap.S -->"

#: src/exercises/bare-metal/rtc.md:784
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:829
#, fuzzy
msgid "`image.ld` (you shouldn't need to change this):"
msgstr "`image.ld` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:831
#, fuzzy
msgid "<!-- File image.ld -->"
msgstr "<!-- File image.ld -->"

#: src/exercises/bare-metal/rtc.md:833
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:940
#, fuzzy
msgid "`Makefile` (you shouldn't need to change this):"
msgstr "`Makefile` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:942
#, fuzzy
msgid "<!-- File Makefile -->"
msgstr "<!-- File Makefile -->"

#: src/exercises/bare-metal/rtc.md:944
msgid ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"# you may not use this file except in compliance with the License.\n"
"# You may obtain a copy of the License at\n"
"#\n"
"#      http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Unless required by applicable law or agreed to in writing, software\n"
"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"# See the License for the specific language governing permissions and\n"
"# limitations under the License.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel "
"$< -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:989
msgid ""
"```toml\n"
"[build]\n"
"target = \"aarch64-unknown-none\"\n"
"rustflags = [\"-C\", \"link-arg=-Timage.ld\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:995
#, fuzzy
msgid "Run the code in QEMU with `make qemu`."
msgstr "Esegui il codice in QEMU con `make qemu`."

#: src/concurrency.md:1
#, fuzzy
msgid "# Welcome to Concurrency in Rust"
msgstr "Benvenuti a Comprehensive Rust ü¶Ä"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust ha il pieno supporto per la concorrenza utilizzando i thread del sistema operativo con mutex "
"e\n"
"canali."

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Il sistema di tipo Rust gioca un ruolo importante nella creazione di molti bug di concorrenza\n"
"bug in fase di compilazione. Questo √® spesso indicato come _concorrenza senza paura_ da quando tu\n"
"pu√≤ fare affidamento sul compilatore per garantire la correttezza in fase di esecuzione."

#: src/concurrency/threads.md:1
#, fuzzy
msgid "# Threads"
msgstr "# Discussioni"

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr "I thread Rust funzionano in modo simile ai thread in altre lingue:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
#, fuzzy
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* I thread sono tutti thread demoni, il thread principale non li aspetta.\n"
"* I thread panic sono indipendenti l'uno dall'altro.\n"
"  * Panics pu√≤ trasportare un payload, che pu√≤ essere decompresso con `downcast_ref`."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"* Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is\n"
"  not waiting.\n"
"\n"
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for\n"
"  the thread to finish.\n"
"\n"
"* Trigger a panic in the thread, notice how this doesn't affect `main`.\n"
"\n"
"* Use the `Result` return value from `handle.join()` to get access to the panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""
"* Si noti che il thread viene interrotto prima che raggiunga 10 ‚Äî il thread principale lo √®\n"
"  non aspettare.\n"
"\n"
"* Usa `let handle = thread::spawn(...)` e successivamente `handle.join()` per aspettare\n"
"  il filo per finire.\n"
"\n"
"* Attivare un panico nel thread, notare come questo non influisca su `main`.\n"
"\n"
"* Usa il valore di ritorno `Result` da `handle.join()` per ottenere l'accesso al panico\n"
"  carico utile. Questo √® un buon momento per parlare di [`Any`]."

#: src/concurrency/scoped-threads.md:1
#, fuzzy
msgid "# Scoped Threads"
msgstr "# Thread con ambito"

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "I thread normali non possono prendere in prestito dal loro ambiente:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:17
#, fuzzy
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "Tuttavia, puoi utilizzare un [thread con ambito][1] per questo:"

#: src/concurrency/scoped-threads.md:19
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:37
#, fuzzy
msgid ""
"* The reason for that is that when the `thread::scope` function completes, all the threads are "
"guaranteed to be joined, so they can return borrowed data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by "
"any number of threads.\n"
"    "
msgstr ""
"* La ragione di ci√≤ √® che quando la funzione `thread::scope` viene completata, √® garantito che "
"tutti i thread vengano uniti, in modo che possano restituire dati presi in prestito.\n"
"* Si applicano le normali regole di prestito di Rust: puoi prendere in prestito in modo mutabile "
"da un thread o immutabile da un numero qualsiasi di thread.\n"
"    "

#: src/concurrency/channels.md:1
#, fuzzy
msgid "# Channels"
msgstr "# Canali"

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"I canali Rust hanno due parti: un `Sender<T>` e un `Receiver<T>`. Le due parti\n"
"sono collegati tramite il canale, ma vedi solo i punti finali."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
#, fuzzy
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` implement `Clone` "
"(so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the counterpart `Sender` "
"or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` sta per Multi-Producer, Single-Consumer. `Sender` e `SyncSender` implementano `Clone` "
"(quindi\n"
"  puoi creare pi√π produttori) ma `Receiver` no.\n"
"* `send()` e `recv()` restituiscono `Risultato`. Se restituiscono \"Err\", significa che la "
"controparte \"Mittente\" o\n"
"  `Receiver` viene eliminato e il canale viene chiuso."

#: src/concurrency/channels/unbounded.md:1
#, fuzzy
msgid "# Unbounded Channels"
msgstr "# Canali illimitati"

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Ottieni un canale illimitato e asincrono con `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {}\", msg);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:1
#, fuzzy
msgid "# Bounded Channels"
msgstr "# Canali delimitati"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr "I canali limitati e sincroni fanno in modo che `send` blocchi il thread corrente:"

#: src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "# `Send` and `Sync`"
msgstr "# `Invia` e `Sincronizza`"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid "How does Rust know to forbid shared access across thread? The answer is in two traits:"
msgstr ""
"Come fa Rust a sapere di vietare l'accesso condiviso attraverso il thread? La risposta √® in due "
"tratti:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a thread\n"
"  boundary."
msgstr ""
"* [`Send`][1]: un tipo `T` √® `Send` se √® sicuro spostare una `T` attraverso un thread\n"
"  confine.\n"
"* [`Sync`][2]: un tipo `T` √® `Sync` se √® sicuro spostare una `&T` attraverso un thread\n"
"  confine."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically derive them for your "
"types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement them manually when "
"you\n"
"know it is valid."
msgstr ""
"\"Send\" e \"Sync\" sono [tratti non sicuri][3]. Il compilatore li deriver√† automaticamente per i "
"tuoi tipi\n"
"purch√© contengano solo i tipi \"Send\" e \"Sync\". Puoi anche implementarli manualmente quando tu\n"
"sapere che √® valido."

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"* One can think of these traits as markers that the type has certain thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  "
msgstr ""
"* Si pu√≤ pensare a questi tratti come indicatori che il tipo ha determinate propriet√† di sicurezza "
"del thread.\n"
"* Possono essere usati nei vincoli generici come tratti normali.\n"
"  "

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "# `Send`"
msgstr "# `Invia`"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid "> A type `T` is [`Send`][1] if it is safe to move a `T` value to another thread."
msgstr "> Un tipo `T` √® [`Send`][1] se √® sicuro spostare un valore `T` in un altro thread."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will run\n"
"in that thread. So the question is when you can allocate a value in one thread\n"
"and deallocate it in another."
msgstr ""
"L'effetto dello spostamento della propriet√† su un altro thread √® che i _destructors_ verranno "
"eseguiti\n"
"in quel filo. Quindi la domanda √® quando puoi allocare un valore in un thread\n"
"e deallocarlo in un altro."

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from a\n"
"single thread."
msgstr ""

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "# `Sync`"
msgstr "# `Sincronizza`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from multiple\n"
"> threads at the same time."
msgstr ""
"> Un tipo `T` √® [`Sync`][1] se √® sicuro accedere a un valore `T` da pi√π\n"
"> thread contemporaneamente."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Pi√π precisamente la definizione √®:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> `T` √® `Sync` se e solo se `&T` √® `Send`"

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is thread-safe for shared "
"use, it is also thread-safe to pass references of it across threads."
msgstr ""
"Questa affermazione √® essenzialmente un modo abbreviato per dire che se un tipo √® thread-safe per "
"l'uso condiviso, √® anche thread-safe per passarne i riferimenti attraverso i thread."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across multiple threads without "
"the risk of data races or other synchronization issues, so it is safe to move it to another "
"thread. A reference to the type is also safe to move to another thread, because the data it "
"references can be accessed from any thread safely."
msgstr ""
"Questo perch√© se un tipo √® Sync significa che pu√≤ essere condiviso tra pi√π thread senza il rischio "
"di corse di dati o altri problemi di sincronizzazione, quindi √® sicuro spostarlo su un altro "
"thread. Un riferimento al tipo √® anche sicuro da spostare in un altro thread, perch√© √® possibile "
"accedere ai dati a cui fa riferimento da qualsiasi thread in modo sicuro."

#: src/concurrency/send-sync/examples.md:1
#, fuzzy
msgid "# Examples"
msgstr "# Esempi"

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "## `Send + Sync`"
msgstr "## \"Invia + Sincronizza\"."

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "La maggior parte dei tipi che incontri sono \"Invia + sincronizzazione\":"

#: src/concurrency/send-sync/examples.md:7
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"I tipi generici sono in genere \"Send + Sync\" quando i parametri di tipo lo sono\n"
"\"Invia + Sincronizza\"."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "## `Send + !Sync`"
msgstr "## \"Invia + !Sincronizza\"."

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"Questi tipi possono essere spostati in altri thread, ma non sono thread-safe.\n"
"Tipicamente a causa della mutevolezza interna:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Ricevitore<T>`\n"
"* `Cella<T>`\n"
"* `RefCella<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "## `!Send + Sync`"
msgstr "## `!Invia + Sincronizza`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr "Questi tipi sono thread-safe, ma non possono essere spostati in un altro thread:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on the\n"
"  thread which created them."
msgstr ""
"* `MutexGuard<T>`: utilizza primitive a livello di sistema operativo che devono essere deallocate "
"su\n"
"  thread che li ha creati."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "## `!Send + !Sync`"
msgstr "## `!Invia + !Sync`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr "Questi tipi non sono thread-safe e non possono essere spostati in altri thread:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: ogni `Rc<T>` ha un riferimento a un `RcBox<T>`, che contiene un\n"
"  conteggio dei riferimenti non atomici.\n"
"* `*const T`, `*mut T`: Rust presuppone che i puntatori grezzi possano avere caratteri speciali\n"
"  considerazioni sulla concorrenza"

#: src/concurrency/shared_state.md:1
#, fuzzy
msgid "# Shared State"
msgstr "# Stato condiviso"

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is\n"
"primarily done via two types:"
msgstr ""
"Rust utilizza il sistema dei tipi per imporre la sincronizzazione dei dati condivisi. Questo √®\n"
"fatto principalmente tramite due tipi:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], riferimento atomico contato `T`: gestisce la condivisione tra thread e\n"
"  si occupa di deallocare `T` quando viene eliminato l'ultimo riferimento,\n"
"* [`Mutex<T>`][2]: garantisce l'accesso mutuamente esclusivo al valore `T`."

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "# `Arc`"
msgstr "# `Arco`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid "[`Arc<T>`][1] allows shared read-only access via `Arc::clone`:"
msgstr "[`Arc<T>`][1] consente l'accesso condiviso in sola lettura tramite `Arc::clone`:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but after that the use of "
"the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc` sta per \"Atomic Reference Counted\", una versione thread-safe di `Rc` che usa atomic\n"
"  operazioni.\n"
"* `Arc<T>` implementa `Clone` indipendentemente dal fatto che `T` lo faccia. Implementa `Send` e "
"`Sync` se e solo `T`\n"
"  li implementa entrambi.\n"
"* `Arc::clone()` ha il costo delle operazioni atomiche che vengono eseguite, ma dopo ci√≤ l'uso di\n"
"  `T` √® gratuito.\n"
"* Attenzione ai cicli di riferimento, `Arc` non usa un garbage collector per rilevarli.\n"
"    * `std::sync::Weak` pu√≤ aiutare."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"[`Mutex<T>`][1] garantisce l'esclusione reciproca _e_ consente l'accesso mutabile a `T`\n"
"dietro un'interfaccia di sola lettura:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr ""
"Nota come abbiamo una coperta [`impl<T: Send> Sync per Mutex<T>`][2].\n"
"implementazione."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"* `Mutex` in Rust looks like a collection with just one element - the protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The `MutexGuard` ensures that "
"the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes \"poisoned\" to signal "
"that\n"
"      the data it protected might be in an inconsistent state. Calling `lock()` on a poisoned "
"mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error to recover the data\n"
"      regardless."
msgstr ""
"* `Mutex` in Rust sembra una raccolta con un solo elemento: i dati protetti.\n"
"    * Non √® possibile dimenticare di acquisire il mutex prima di accedere ai dati protetti.\n"
"* Puoi ottenere un `&mut T` da un `&Mutex<T>` prendendo il lock. Il `MutexGuard` assicura che il "
"file\n"
"  `&mut T` non sopravvive al blocco mantenuto.\n"
"* `Mutex<T>` implementa sia `Send` che `Sync` se `T` implementa `Send`.\n"
"* Una controparte del blocco lettura-scrittura - `RwLock`.\n"
"* Perch√© `lock()` restituisce un `Risultato`?\n"
"    * Se il thread che conteneva il `Mutex` va nel panico, il `Mutex` diventa \"avvelenato\" per "
"segnalare che\n"
"      i dati protetti potrebbero trovarsi in uno stato incoerente. Chiamare `lock()` su un mutex "
"avvelenato\n"
"      fallisce con un [`PoisonError`]. Puoi chiamare `into_inner()` sull'errore per recuperare i "
"dati\n"
"      indipendentemente."

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Vediamo `Arc` e `Mutex` in azione:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
#, fuzzy
msgid "Possible solution:"
msgstr "Possibile soluzione:"

#: src/concurrency/shared_state/example.md:25
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:49
#, fuzzy
msgid "Notable parts:"
msgstr "Parti notevoli:"

#: src/concurrency/shared_state/example.md:51
#, fuzzy
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another thread. Note `move` "
"was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as possible."
msgstr ""
"* `v` √® racchiuso sia in `Arc` che in `Mutex`, perch√© i loro interessi sono ortogonali.\n"
"  * Avvolgere un `Mutex` in un `Arc` √® un modello comune per condividere lo stato mutabile tra i "
"thread.\n"
"* `v: Arc<_>` deve essere clonato come `v2` prima di poter essere spostato in un altro thread. "
"Nota che \"move\" √® stato aggiunto alla firma lambda.\n"
"* I blocchi vengono introdotti per restringere il pi√π possibile l'ambito di `LockGuard`."

#: src/exercises/concurrency/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "Mettiamo in pratica le nostre nuove abilit√† di concorrenza con"

#: src/exercises/concurrency/morning.md:5
#, fuzzy
msgid ""
"* Dining philosophers: a classic problem in concurrency.\n"
"\n"
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"* Filosofi a tavola: un classico problema in concorrenza.\n"
"\n"
"* Verifica link multi-thread: un progetto pi√π ampio in cui utilizzerai Cargo\n"
"  scaricare le dipendenze e quindi controllare i collegamenti in parallelo."

#: src/exercises/concurrency/dining-philosophers.md:1
#, fuzzy
msgid "# Dining Philosophers"
msgstr "# Filosofi da pranzo"

#: src/exercises/concurrency/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "Il problema dei filosofi da pranzo √® un classico problema in concorrenza:"

#: src/exercises/concurrency/dining-philosophers.md:5
#, fuzzy
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has their\n"
"> own place at the table. There is a fork between each plate. The dish served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will only\n"
"> be available when their two nearest neighbors are thinking, not eating. After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> Cinque filosofi cenano insieme alla stessa tavola. Ogni filosofo ha il suo\n"
"> proprio posto a tavola. C'√® una forchetta tra ogni piatto. Il piatto servito √®\n"
"> una specie di spaghetto che si mangia con due forchette. Ogni filosofo pu√≤\n"
"> solo alternativamente pensa e mangia. Inoltre, un filosofo pu√≤ solo mangiare il loro\n"
"> gli spaghetti quando hanno sia la forchetta destra che quella sinistra. Quindi solo due "
"forchette\n"
"> essere disponibile quando i loro due vicini pi√π vicini stanno pensando, non mangiando. Dopo\n"
"> un singolo filosofo finisce di mangiare, metteranno gi√π entrambe le forchette."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) for\n"
"this exercise. Copy the code below to a file called `src/main.rs`, fill out the\n"
"blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Avrai bisogno di un'[installazione Cargo](../../cargo/running-locally.md) locale per\n"
"questo esercizio. Copia il codice qui sotto in un file chiamato `src/main.rs`, compila il file\n"
"spazi vuoti e verificare che `cargo run` non vada in stallo:"

#: src/exercises/concurrency/dining-philosophers.md:19
msgid ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
#, fuzzy
msgid "You can use the following `Cargo.toml`:"
msgstr "Puoi usare il seguente `Cargo.toml`:"

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:1
#, fuzzy
msgid "# Multi-threaded Link Checker"
msgstr "# Verifica link multi-thread"

#: src/exercises/concurrency/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until all\n"
"pages have been validated."
msgstr ""
"Usiamo le nostre nuove conoscenze per creare un verificatore di collegamenti multi-thread. "
"Dovrebbe\n"
"iniziare da una pagina Web e verificare che i collegamenti sulla pagina siano validi. Dovrebbe\n"
"controlla ricorsivamente altre pagine sullo stesso dominio e continua a farlo fino a quando all\n"
"le pagine sono state convalidate."

#: src/exercises/concurrency/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Per questo, avrai bisogno di un client HTTP come [`reqwest`][1]. Crea un nuovo\n"
"Progetto Cargo e `richiedilo` come dipendenza con:"

#: src/exercises/concurrency/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:17
#, fuzzy
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> Se `cargo add` fallisce con `error: no such subcommand`, modifica il file\n"
"> File `Cargo.toml` a mano. Aggiungere le dipendenze elencate di seguito."

#: src/exercises/concurrency/link-checker.md:20
#, fuzzy
msgid "You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr "Avrai anche bisogno di un modo per trovare i link. Possiamo usare [`scraper`][2] per questo:"

#: src/exercises/concurrency/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] for\n"
"that:"
msgstr ""
"Infine, avremo bisogno di un modo per gestire gli errori. Usiamo [`thiserror`][3] per\n"
"Quello:"

#: src/exercises/concurrency/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:33
#, fuzzy
msgid "The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "Le chiamate `cargo add` aggiorneranno il file `Cargo.toml` in questo modo:"

#: src/exercises/concurrency/link-checker.md:37
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:50
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"Ora puoi scaricare la pagina iniziale. Prova con un piccolo sito come\n"
"`https://www.google.org/`."

#: src/exercises/concurrency/link-checker.md:53
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Il tuo file `src/main.rs` dovrebbe assomigliare a questo:"

#: src/exercises/concurrency/link-checker.md:57
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}\n"
"\n"
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"\n"
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: {err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Ok(valid_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:100
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Esegui il codice in `src/main.rs` con"

#: src/exercises/concurrency/link-checker.md:102
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:106
#, fuzzy
msgid "## Tasks"
msgstr "## Compiti"

#: src/exercises/concurrency/link-checker.md:108
#, fuzzy
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that you\n"
"  don't end up being blocked by the site."
msgstr ""
"* Usa i thread per controllare i collegamenti in parallelo: invia gli URL da controllare a a\n"
"  channel e lasciare che alcuni thread controllino gli URL in parallelo.\n"
"* Estendilo per estrarre in modo ricorsivo i collegamenti da tutte le pagine del file\n"
"  dominio \"www.google.org\". Metti un limite massimo di 100 pagine o gi√π di l√¨ in modo che tu\n"
"  non finire per essere bloccato dal sito."

#: src/async.md:1
#, fuzzy
msgid "# Async Rust"
msgstr "# Ruggine asincrona"

#: src/async.md:3
#, fuzzy
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed concurrently by\n"
"executing each task until it would block, then switching to another task that is\n"
"ready to make progress. The model allows running a larger number of tasks on a\n"
"limited number of threads. This is because the per-task overhead is typically\n"
"very low and operating systems provide primitives for efficiently identifying\n"
"I/O that is able to proceed."
msgstr ""
"\"Async\" √® un modello di concorrenza in cui pi√π attivit√† vengono eseguite contemporaneamente da\n"
"eseguire ogni attivit√† fino a quando non si bloccherebbe, quindi passare a un'altra attivit√† che "
"√®\n"
"pronto a fare progressi. Il modello consente di eseguire un numero maggiore di attivit√† su a\n"
"numero limitato di thread. Questo perch√© il sovraccarico per attivit√† √® in genere\n"
"molto basso e i sistemi operativi forniscono primitive per l'identificazione efficiente\n"
"I/O che √® in grado di procedere."

#: src/async.md:10
#, fuzzy
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work that\n"
"may be completed in the future. Futures are \"polled\" until they signal that\n"
"they are complete."
msgstr ""
"L'operazione asincrona di Rust si basa sui \"futuri\", che rappresentano il lavoro che\n"
"potrebbe essere completata in futuro. I futures vengono \"interrogati\" fino a quando non lo "
"segnalano\n"
"sono completi."

#: src/async.md:14
#, fuzzy
msgid ""
"Futures are polled by an async runtime, and several different runtimes are\n"
"available."
msgstr ""
"I futures vengono interrogati da un runtime asincrono e diversi runtime lo sono\n"
"disponibile."

#: src/async.md:17
#, fuzzy
msgid "## Comparisons"
msgstr "Comparazione"

#: src/async.md:19
#, fuzzy
msgid ""
" * Python has a similar model in its `asyncio`. However, its `Future` type is\n"
"   callback-based, and not polled. Async Python programs require a \"loop\",\n"
"   similar to a runtime in Rust.\n"
"\n"
" * JavaScript's `Promise` is similar, but again callback-based. The language\n"
"   runtime implements the event loop, so many of the details of Promise\n"
"   resolution are hidden."
msgstr ""
" * Python ha un modello simile nel suo `asyncio`. Tuttavia, il suo tipo \"Futuro\" √®\n"
"   basato su callback e non su polling. I programmi Python asincroni richiedono un \"loop\",\n"
"   simile a un runtime in Rust.\n"
"\n"
" * La \"promessa\" di JavaScript √® simile, ma ancora una volta basata su callback. La lingua\n"
"   runtime implementa il ciclo di eventi, tanti dei dettagli di Promise\n"
"   risoluzione sono nascosti."

#: src/async/async-await.md:1
#, fuzzy
msgid "# `async`/`await`"
msgstr "# `asincrono`/`aspetta`"

#: src/async/async-await.md:3
#, fuzzy
msgid "At a high level, async Rust code looks very much like \"normal\" sequential code:"
msgstr ""
"Ad alto livello, il codice asincrono di Rust assomiglia molto al codice sequenziale \"normale\":"

#: src/async/async-await.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"
msgstr ""

#: src/async/async-await.md:27
msgid ""
"* Note that this is a simplified example to show the syntax. There is no long\n"
"  running operation or any real concurrency in it!\n"
"\n"
"* What is the return type of an async call?\n"
"  * Use `let future: () = async_main(10);` in `main` to see the type.\n"
"\n"
"* The \"async\" keyword is syntactic sugar. The compiler replaces the return type\n"
"  with a future. \n"
"\n"
"* You cannot make `main` async, without additional instructions to the compiler\n"
"  on how to use the returned future.\n"
"\n"
"* You need an executor to run async code. `block_on` blocks the current thread\n"
"  until the provided future has run to completion. \n"
"\n"
"* `.await` asynchronously waits for the completion of another operation. Unlike\n"
"  `block_on`, `.await` doesn't block the current thread.\n"
"\n"
"* `.await` can only be used inside an `async` function (or block; these are\n"
"  introduced later). "
msgstr ""

#: src/async/futures.md:1
#, fuzzy
msgid "# Futures"
msgstr "# Futuri"

#: src/async/futures.md:3
#, fuzzy
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)\n"
"is a trait, implemented by objects that represent an operation that may not be\n"
"complete yet. A future can be polled, and `poll` returns a\n"
"[`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Futuro`](https://doc.rust-lang.org/std/future/trait.Future.html)\n"
"√® un tratto, implementato da oggetti che rappresentano un'operazione che potrebbe non essere\n"
"ancora completo. √à possibile eseguire il polling di un futuro e `poll` restituisce a\n"
"[`Sondaggio`](https://doc.rust-lang.org/std/task/enum.Poll.html)."

#: src/async/futures.md:8
msgid ""
"```rust\n"
"use std::pin::Pin;\n"
"use std::task::Context;\n"
"\n"
"pub trait Future {\n"
"    type Output;\n"
"    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n"
"}\n"
"\n"
"pub enum Poll<T> {\n"
"    Ready(T),\n"
"    Pending,\n"
"}\n"
"```"
msgstr ""

#: src/async/futures.md:23
#, fuzzy
msgid ""
"An async function returns an `impl Future`. It's also possible (but uncommon) to\n"
"implement `Future` for your own types. For example, the `JoinHandle` returned\n"
"from `tokio::spawn` implements `Future` to allow joining to it."
msgstr ""
"Una funzione asincrona restituisce un `impl Future`. √à anche possibile (ma non comune).\n"
"implementa `Future` per i tuoi tipi. Ad esempio, √® stato restituito \"JoinHandle\".\n"
"da `tokio::spawn` implementa `Future` per consentire l'unione ad esso."

#: src/async/futures.md:27
#, fuzzy
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function to\n"
"pause until that Future is ready, and then evaluates to its output."
msgstr ""
"La parola chiave `.await`, applicata a un Future, fa s√¨ che la funzione async corrente si attivi\n"
"mettere in pausa fino a quando Future non √® pronto, quindi valuta il suo output."

#: src/async/futures.md:32
msgid ""
"* The `Future` and `Poll` types are implemented exactly as shown; click the\n"
"  links to show the implementations in the docs.\n"
"\n"
"* We will not get to `Pin` and `Context`, as we will focus on writing async\n"
"  code, rather than building new async primitives. Briefly:\n"
"\n"
"  * `Context` allows a Future to schedule itself to be polled again when an\n"
"    event occurs.\n"
"\n"
"  * `Pin` ensures that the Future isn't moved in memory, so that pointers into\n"
"    that future remain valid. This is required to allow references to remain\n"
"    valid after an `.await`."
msgstr ""

#: src/async/runtimes.md:1
#, fuzzy
msgid "# Runtimes"
msgstr "# Runtime"

#: src/async/runtimes.md:3
#, fuzzy
msgid ""
"A *runtime* provides support for performing operations asynchronously (a\n"
"*reactor*) and is responsible for executing futures (an *executor*). Rust does not have a\n"
"\"built-in\" runtime, but several options are available:"
msgstr ""
"Un *runtime* fornisce supporto per l'esecuzione di operazioni in modo asincrono (a\n"
"*reattore*) ed √® responsabile dell'esecuzione dei futures (un *esecutore*). La ruggine non ha un\n"
"runtime \"incorporato\", ma sono disponibili diverse opzioni:"

#: src/async/runtimes.md:7
#, fuzzy
msgid ""
" * [Tokio](https://tokio.rs/) - performant, with a well-developed ecosystem of\n"
"   functionality like [Hyper](https://hyper.rs/) for HTTP or\n"
"   [Tonic](https://github.com/hyperium/tonic) for gRPC.\n"
" * [async-std](https://async.rs/) - aims to be a \"std for async\", and includes a\n"
"   basic runtime in `async::task`.\n"
" * [smol](https://docs.rs/smol/latest/smol/) - simple and lightweight"
msgstr ""
" * [Tokio](https://tokio.rs/) - performante, con un ecosistema ben sviluppato di\n"
"   funzionalit√† come [Hyper](https://hyper.rs/) per HTTP o\n"
"   [Tonic](https://github.com/hyperium/tonic) per gRPC.\n"
" * [async-std](https://async.rs/) - mira a essere uno \"std per async\" e include un\n"
"   runtime di base in `async::task`.\n"
" * [smol](https://docs.rs/smol/latest/smol/) - semplice e leggero"

#: src/async/runtimes.md:14
#, fuzzy
msgid ""
"Several larger applications have their own runtimes. For example,\n"
"[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib."
"rs)\n"
"already has one."
msgstr ""
"Diverse applicazioni pi√π grandi hanno i propri tempi di esecuzione. Per esempio,\n"
"[Fucsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib."
"rs)\n"
"ne ha gi√† uno."

#: src/async/runtimes.md:20
#, fuzzy
msgid ""
"* Note that of the listed runtimes, only Tokio is supported in the Rust\n"
"  playground. The playground also does not permit any I/O, so most interesting\n"
"  async things can't run in the playground.\n"
"\n"
"* Futures are \"inert\" in that they do not do anything (not even start an I/O\n"
"  operation) unless there is an executor polling them. This differs from JS\n"
"  Promises, for example, which will run to completion even if they are never\n"
"  used."
msgstr ""
"* Si noti che dei runtime elencati, solo Tokio √® supportato in Rust\n"
"  terreno di gioco. Anche il parco giochi non consente alcun I/O, quindi molto interessante\n"
"  le cose asincrone non possono essere eseguite nel parco giochi.\n"
"\n"
"* I futures sono \"inerti\" in quanto non fanno nulla (nemmeno avviano un I/O\n"
"  operazione) a meno che non ci sia un esecutore che li interroga. Questo differisce da JS\n"
"  Promesse, ad esempio, che andranno a buon fine anche se non lo saranno mai\n"
"  usato."

#: src/async/runtimes/tokio.md:1
#, fuzzy
msgid "# Tokio"
msgstr "# Tokyo"

#: src/async/runtimes/tokio.md:4
#, fuzzy
msgid "Tokio provides: "
msgstr "Tokyo fornisce:"

#: src/async/runtimes/tokio.md:6
#, fuzzy
msgid ""
"* A multi-threaded runtime for executing asynchronous code.\n"
"* An asynchronous version of the standard library.\n"
"* A large ecosystem of libraries."
msgstr ""
"* Un runtime multithread per l'esecuzione di codice asincrono.\n"
"* Una versione asincrona della libreria standard.\n"
"* Un grande ecosistema di biblioteche."

#: src/async/runtimes/tokio.md:10
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main task: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/runtimes/tokio.md:33
#, fuzzy
msgid ""
"* With the `tokio::main` macro we can now make `main` async.\n"
"\n"
"* The `spawn` function creates a new, concurrent \"task\".\n"
"\n"
"* Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"* Con la macro `tokio::main` ora possiamo rendere `main` asincrono.\n"
"\n"
"* La funzione `spawn` crea un nuovo \"task\" simultaneo.\n"
"\n"
"* Nota: `spawn` prende un `Future`, non devi chiamare `.await` su `count_to`."

#: src/async/runtimes/tokio.md:39
#, fuzzy
msgid "**Further exploration:**"
msgstr "**Ulteriori esplorazioni:**"

#: src/async/runtimes/tokio.md:41
#, fuzzy
msgid ""
"* Why does `count_to` not (usually) get to 10? This is an example of async\n"
"  cancellation. `tokio::spawn` returns a handle which can be awaited to wait\n"
"  until it finishes.\n"
"\n"
"* Try `count_to(10).await` instead of spawning.\n"
"\n"
"* Try awaiting the task returned from `tokio::spawn`."
msgstr ""
"* Perch√© `count_to` non arriva (di solito) a 10? Questo √® un esempio di async\n"
"  cancellazione. `tokio::spawn` restituisce un handle che pu√≤ essere atteso per attendere\n"
"  finch√© non finisce.\n"
"\n"
"* Prova `count_to(10).await` invece di spawnare.\n"
"\n"
"* Prova ad attendere il task restituito da `tokio::spawn`."

#: src/async/tasks.md:1
#, fuzzy
msgid "# Tasks"
msgstr "# Compiti"

#: src/async/tasks.md:3
#, fuzzy
msgid ""
"Runtimes have the concept of a \"task\", similar to a thread but much\n"
"less resource-intensive."
msgstr ""
"I runtime hanno il concetto di \"attivit√†\", simile a un thread ma molto\n"
"meno dispendioso in termini di risorse."

#: src/async/tasks.md:6
#, fuzzy
msgid ""
"A task has a single top-level future which the executor polls to make progress.\n"
"That future may have one or more nested futures that its `poll` method polls,\n"
"corresponding loosely to a call stack. Concurrency within a task is possible by\n"
"polling multiple child futures, such as racing a timer and an I/O operation."
msgstr ""
"Un'attivit√† ha un singolo futuro di primo livello che l'esecutore interroga per fare progressi.\n"
"Quel futuro pu√≤ avere uno o pi√π futuri nidificati che il suo metodo \"poll\" esegue il polling,\n"
"corrispondente vagamente a uno stack di chiamate. La concorrenza all'interno di un'attivit√† √® "
"possibile tramite\n"
"polling di pi√π futuri figli, come correre un timer e un'operazione di I/O."

#: src/async/tasks.md:11
msgid ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"connection from {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await {\n"
"                println!(\"socket error: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap().trim();\n"
"                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"socket error: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"socket error: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/tasks.md:53 src/async/control-flow/join.md:36
#, fuzzy
msgid "Copy this example into your prepared `src/main.rs` and run it from there."
msgstr "Copia questo esempio nel tuo `src/main.rs` preparato ed eseguilo da l√¨."

#: src/async/tasks.md:55
#, fuzzy
msgid ""
"* Ask students to visualize what the state of the example server would be with a\n"
"  few connected clients. What tasks exist? What are their Futures?\n"
"\n"
"* This is the first time we've seen an `async` block. This is similar to a\n"
"  closure, but does not take any arguments. Its return value is a Future,\n"
"  similar to an `async fn`. \n"
"\n"
"* Refactor the async block into a function, and improve the error handling using `?`."
msgstr ""
"* Chiedi agli studenti di visualizzare quale sarebbe lo stato del server di esempio con a\n"
"  pochi client connessi. Quali compiti esistono? Quali sono i loro futuri?\n"
"\n"
"* Questa √® la prima volta che vediamo un blocco `async`. Questo √® simile a a\n"
"  chiusura, ma non accetta argomenti. Il suo valore di ritorno √® un Futuro,\n"
"  simile a un `async fn`.\n"
"\n"
"* Rifattorizzare il blocco asincrono in una funzione e migliorare la gestione degli errori "
"utilizzando `?`."

#: src/async/channels.md:1
#, fuzzy
msgid "# Async Channels"
msgstr "# Canali asincroni"

#: src/async/channels.md:3
#, fuzzy
msgid "Several crates have support for `async`/`await`. For instance `tokio` channels:"
msgstr "Diversi crate hanno il supporto per `async`/`await`. Ad esempio i canali `tokio`:"

#: src/async/channels.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    std::mem::drop(sender);\n"
"    ping_handler_task.await.expect(\"Something went wrong in ping handler task.\");\n"
"}\n"
"```"
msgstr ""

#: src/async/channels.md:35
#, fuzzy
msgid ""
"* Change the channel size to `3` and see how it affects the execution.\n"
"\n"
"* Overall, the interface is similar to the `sync` channels as seen in the\n"
"  [morning class](concurrency/channels.md).\n"
"\n"
"* Try removing the `std::mem::drop` call. What happens? Why?\n"
"\n"
"* The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that\n"
"  implement both `sync` and `async` `send` and `recv`. This can be convenient\n"
"  for complex applications with both IO and heavy CPU processing tasks.\n"
"\n"
"* What makes working with `async` channels preferable is the ability to combine\n"
"  them with other `future`s to combine them and create complex control flow."
msgstr ""
"* Cambia la dimensione del canale in \"3\" e guarda come influisce sull'esecuzione.\n"
"\n"
"* Nel complesso, l'interfaccia √® simile ai canali `sync` come si vede nel file\n"
"  [lezione mattutina](concurrency/channels.md).\n"
"\n"
"* Prova a rimuovere la chiamata `std::mem::drop`. Che succede? Perch√©?\n"
"\n"
"* La cassa [Flume](https://docs.rs/flume/latest/flume/) ha canali che\n"
"  implementa sia `sync` che `async` `send` e `recv`. Questo pu√≤ essere conveniente\n"
"  per applicazioni complesse con attivit√† di elaborazione di CPU e IO pesanti.\n"
"\n"
"* Ci√≤ che rende preferibile lavorare con i canali `async` √® la capacit√† di combinare\n"
"  loro con altri `futuri` per combinarli e creare un flusso di controllo complesso."

#: src/async/control-flow.md:1
#, fuzzy
msgid "# Futures Control Flow"
msgstr "# Flusso di controllo dei futures"

#: src/async/control-flow.md:3
#, fuzzy
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. We\n"
"have already seen tasks, that function as independent threads of execution."
msgstr ""
"I futures possono essere combinati insieme per produrre grafici di flusso di calcolo simultanei. "
"Noi\n"
"ho gi√† visto le attivit√†, che funzionano come thread di esecuzione indipendenti."

#: src/async/control-flow.md:6
#, fuzzy
msgid ""
"- [Join](control-flow/join.md)\n"
"- [Select](control-flow/select.md)"
msgstr ""
"- [Partecipa](control-flow/join.md)\n"
"- [Seleziona](control-flow/select.md)"

#: src/async/control-flow/join.md:1
#, fuzzy
msgid "# Join"
msgstr "# Giuntura"

#: src/async/control-flow/join.md:3
#, fuzzy
msgid ""
"A join operation waits until all of a set of futures are ready, and\n"
"returns a collection of their results. This is similar to `Promise.all` in\n"
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"Un'operazione di join attende fino a quando tutti i futures sono pronti e\n"
"restituisce una raccolta dei loro risultati. Questo √® simile a \"Promise.all\" in\n"
"JavaScript o `asyncio.gather` in Python."

#: src/async/control-flow/join.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &str) -> Result<usize> {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/join.md:38
#, fuzzy
msgid ""
"* For multiple futures of disjoint types, you can use `std::future::join!` but\n"
"  you must know how many futures you will have at compile time. This is\n"
"  currently in the `futures` crate, soon to be stabilised in `std::future`.\n"
"\n"
"* The risk of `join` is that one of the futures may never resolve, this would\n"
"  cause your program to stall. \n"
"\n"
"* You can also combine `join_all` with `join!` for instance to join all requests\n"
"  to an http service as well as a database query. Try adding a\n"
"  `tokio::time::sleep` to the future, using `futures::join!`. This is not a\n"
"  timeout (that requires `select!`, explained in the next chapter), but demonstrates `join!`."
msgstr ""
"* Per future multiple di tipi disgiunti, puoi usare `std::future::join!` ma\n"
"  devi sapere quanti futuri avrai al momento della compilazione. Questo √®\n"
"  attualmente nella cassa `futures`, presto sar√† stabilizzata in `std::future`.\n"
"\n"
"* Il rischio di \"unirsi\" √® che uno dei futuri potrebbe non risolversi mai, questo s√¨\n"
"  causare l'arresto del programma.\n"
"\n"
"* Puoi anche combinare `join_all` con `join!`, ad esempio per unire tutte le richieste\n"
"  a un servizio http cos√¨ come una query di database. Prova ad aggiungere un\n"
"  `tokio::time::sleep` nel futuro, usando `futures::join!`. Questo non √® un\n"
"  timeout (che richiede `select!`, spiegato nel prossimo capitolo), ma dimostra `join!`."

#: src/async/control-flow/select.md:1
#, fuzzy
msgid "# Select"
msgstr "# Selezionare"

#: src/async/control-flow/select.md:3
#, fuzzy
msgid ""
"A select operation waits until any of a set of futures is ready, and responds to\n"
"that future's result. In JavaScript, this is similar to `Promise.race`. In\n"
"Python, it compares to `asyncio.wait(task_set,\n"
"return_when=asyncio.FIRST_COMPLETED)`."
msgstr ""
"Un'operazione di selezione attende fino a quando uno qualsiasi di un insieme di futures √® pronto e "
"risponde a\n"
"il risultato di quel futuro. In JavaScript, √® simile a `Promise.race`. In\n"
"Python, confronta con `asyncio.wait(task_set,\n"
"return_when=asyncio.FIRST_COMPLETED)`."

#: src/async/control-flow/select.md:8
#, fuzzy
msgid ""
"This is usually a macro, similar to match, with each arm of the form `pattern =\n"
"future => statement`. When the future is ready, the statement is executed with the\n"
"variable bound to the future's result."
msgstr ""
"Di solito √® una macro, simile a match, con ogni braccio della forma `pattern =\n"
"futuro => istruzione`. Quando il futuro √® pronto, l'istruzione viene eseguita con il\n"
"variabile legata al risultato del futuro."

#: src/async/control-flow/select.md:12
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receiver<String>,\n"
"    mut dog_rcv: Receiver<String>,\n"
") -> Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: cat_name? }),\n"
"        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Failed to send cat.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Failed to send dog.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"Winner is {winner:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/select.md:61
#, fuzzy
msgid ""
"* In this example, we have a race between a cat and a dog.\n"
"  `first_animal_to_finish_race` listens to both channels and will pick whichever\n"
"  arrives first. Since the dog takes 50ms, it wins against the cat that\n"
"  take 500ms seconds.\n"
"\n"
"* You can use `oneshot` channels in this example as the channels are supposed to\n"
"  receive only one `send`.\n"
"\n"
"* Try adding a deadline to the race, demonstrating selecting different sorts of\n"
"  futures.\n"
"\n"
"* Note that `select!` moves the values it is given. It is easiest to use\n"
"  when every execution of `select!` creates new futures. An alternative is to\n"
"  pass `&mut future` instead of the future itself, but this can lead to\n"
"  issues, further discussed in the pinning slide."
msgstr ""
"* In questo esempio, abbiamo una gara tra un gatto e un cane.\n"
"  `first_animal_to_finish_race` ascolta entrambi i canali e sceglier√† quello che preferisci\n"
"  arriva prima. Poich√© il cane impiega 50 ms, vince contro il gatto\n"
"  prendere 500 ms secondi.\n"
"\n"
"* In questo esempio puoi usare i canali `oneshot` come dovrebbero\n"
"  ricevere un solo \"invio\".\n"
"\n"
"* Prova ad aggiungere una scadenza alla gara, dimostrando la selezione di diversi tipi di\n"
"  futuri.\n"
"\n"
"* Nota che `select!` sposta i valori che gli vengono dati. √à pi√π facile da usare\n"
"  quando ogni esecuzione di `select!` crea nuovi futuri. Un'alternativa √®\n"
"  passa `&mut future` invece del futuro stesso, ma questo pu√≤ portare a\n"
"  problemi, ulteriormente discussi nella diapositiva di blocco."

#: src/async/pitfalls.md:1
#, fuzzy
msgid "# Pitfalls of async/await"
msgstr "# Insidie di async/await"

#: src/async/pitfalls.md:3
#, fuzzy
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent asynchronous "
"programming. However, the async/await model in Rust also comes with its share of pitfalls and "
"footguns. We illustrate some of them in this chapter:"
msgstr ""
"Async / await fornisce un'astrazione comoda ed efficiente per la programmazione asincrona "
"simultanea. Tuttavia, anche il modello async/await in Rust ha la sua parte di insidie e pistole. "
"Ne illustriamo alcuni in questo capitolo:"

#: src/async/pitfalls.md:5
#, fuzzy
msgid ""
"- [Blocking the Executor](pitfalls/blocking-executor.md)\n"
"- [Pin](pitfalls/pin.md)\n"
"- [Async Traits](pitfall/async-traits.md)"
msgstr ""
"- [Blocco dell'esecutore](trappole/blocking-executor.md)\n"
"- [Pin](trappole/pin.md)\n"
"- [Tratti asincroni](trapano/async-traits.md)"

#: src/async/pitfalls/blocking-executor.md:1
#, fuzzy
msgid "# Blocking the executor"
msgstr "# Blocco dell'esecutore"

#: src/async/pitfalls/blocking-executor.md:3
#, fuzzy
msgid ""
"Most async runtimes only allow IO tasks to run concurrently.\n"
"This means that CPU blocking tasks will block the executor and prevent other tasks from being "
"executed.\n"
"An easy workaround is to use async equivalent methods where possible."
msgstr ""
"La maggior parte dei runtime asincroni consente solo l'esecuzione simultanea delle attivit√† di I/"
"O.\n"
"Ci√≤ significa che le attivit√† di blocco della CPU bloccheranno l'esecutore e impediranno "
"l'esecuzione di altre attivit√†.\n"
"Una soluzione semplice consiste nell'usare metodi equivalenti asincroni ove possibile."

#: src/async/pitfalls/blocking-executor.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
#, fuzzy
msgid ""
"* Run the code and see that the sleeps happen consecutively rather than\n"
"  concurrently.\n"
"\n"
"* The `\"current_thread\"` flavor puts all tasks on a single thread. This makes the\n"
"  effect more obvious, but the bug is still present in the multi-threaded\n"
"  flavor.\n"
"\n"
"* Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result.\n"
"\n"
"* Another fix would be to `tokio::task::spawn_blocking` which spawns an actual\n"
"  thread and transforms its handle into a future without blocking the executor.\n"
"\n"
"* You should not think of tasks as OS threads. They do not map 1 to 1 and most\n"
"  executors will allow many tasks to run on a single OS thread. This is\n"
"  particularly problematic when interacting with other libraries via FFI, where\n"
"  that library might depend on thread-local storage or map to specific OS\n"
"  threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such situations.\n"
"\n"
"* Use sync mutexes with care. Holding a mutex over an `.await` may cause another\n"
"  task to block, and that task may be running on the same thread."
msgstr ""
"* Esegui il codice e verifica che le interruzioni avvengano consecutivamente anzich√©\n"
"  in concomitanza.\n"
"\n"
"* Il profilo `\"current_thread\"` pone tutte le attivit√† su un singolo thread. Questo rende il\n"
"  effetto pi√π evidente, ma il bug √® ancora presente nel multithread\n"
"  gusto.\n"
"\n"
"* Passa da `std::thread::sleep` a `tokio::time::sleep` e attendi il risultato.\n"
"\n"
"* Un'altra soluzione potrebbe essere `tokio::task::spawn_blocking` che genera un file effettivo\n"
"  thread e trasforma il suo handle in un futuro senza bloccare l'esecutore.\n"
"\n"
"* Non dovresti pensare alle attivit√† come thread del sistema operativo. Non mappano 1 a 1 e la "
"maggior parte\n"
"  gli esecutori consentiranno l'esecuzione di molte attivit√† su un singolo thread del sistema "
"operativo. Questo √®\n"
"  particolarmente problematico quando si interagisce con altre biblioteche tramite FFI, dove\n"
"  quella libreria potrebbe dipendere dall'archiviazione locale del thread o essere mappata su un "
"sistema operativo specifico\n"
"  thread (ad esempio, CUDA). Preferisci `tokio::task::spawn_blocking` in tali situazioni.\n"
"\n"
"* Usa i mutex di sincronizzazione con attenzione. Mantenere un mutex sopra un `.await` pu√≤ "
"causarne un altro\n"
"  attivit√† da bloccare e tale attivit√† potrebbe essere in esecuzione sullo stesso thread."

#: src/async/pitfalls/pin.md:1
#, fuzzy
msgid "# Pin"
msgstr "# Spillo"

#: src/async/pitfalls/pin.md:3
#, fuzzy
msgid ""
"When you await a future, all local variables (that would ordinarily be stored on\n"
"a stack frame) are instead stored in the Future for the current async block. If your\n"
"future has pointers to data on the stack, those pointers might get invalidated.\n"
"This is unsafe."
msgstr ""
"Quando aspetti un futuro, tutte le variabili locali (che normalmente sarebbero memorizzate su\n"
"uno stack frame) vengono invece archiviati in Future per il blocco asincrono corrente. Se tuo\n"
"future ha puntatori ai dati nello stack, quei puntatori potrebbero essere invalidati.\n"
"Questo non √® sicuro."

#: src/async/pitfalls/pin.md:8
#, fuzzy
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't\n"
"change. That is why we need to `pin` futures. Using the same future repeatedly\n"
"in a `select!` often leads to issues with pinned values."
msgstr ""
"Pertanto, √® necessario garantire che gli indirizzi futuri puntino a non farlo\n"
"modifica. Ecco perch√© dobbiamo \"bloccare\" i futuri. Usando ripetutamente lo stesso futuro\n"
"in un `select!` spesso porta a problemi con i valori bloccati."

#: src/async/pitfalls/pin.md:12
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// A worker which listens for work on a queue and performs it.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() => {\n"
"                sleep(Duration::from_millis(10)).await; // Pretend to work.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"failed to send response\");\n"
"                iterations += 1;\n"
"            }\n"
"            // TODO: report number of iterations every 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// A requester which requests work and waits for it to complete.\n"
"async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"failed to send on work queue\");\n"
"    rx.await.expect(\"failed waiting for response\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:68
msgid ""
"* You may recognize this as an example of the actor pattern. Actors\n"
"  typically call `select!` in a loop.\n"
"\n"
"* This serves as a summation of a few of the previous lessons, so take your time\n"
"  with it.\n"
"\n"
"    * Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }`\n"
"      to the `select!`. This will never execute. Why?\n"
"\n"
"    * Instead, add a `timeout_fut` containing that future outside of the `loop`:\n"
"\n"
"        ```rust,compile_fail\n"
"        let mut timeout_fut = sleep(Duration::from_millis(100));\n"
"        loop {\n"
"            select! {\n"
"                ..,\n"
"                _ = timeout_fut => { println!(..); },\n"
"            }\n"
"        }\n"
"        ```\n"
"    * This still doesn't work. Follow the compiler errors, adding `&mut` to the\n"
"      `timeout_fut` in the `select!` to work around the move, then using\n"
"      `Box::pin`:\n"
"\n"
"        ```rust,compile_fail\n"
"        let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
"        loop {\n"
"            select! {\n"
"                ..,\n"
"                _ = &mut timeout_fut => { println!(..); },\n"
"            }\n"
"        }\n"
"        ```\n"
"\n"
"    * This compiles, but once the timeout expires it is `Poll::Ready` on every\n"
"      iteration (a fused future would help with this). Update to reset\n"
"      `timeout_fut` every time it expires.\n"
"\n"
"* Box allocates on the heap. In some cases, `std::pin::pin!` (only recently\n"
"  stabilized, with older code often using `tokio::pin!`) is also an option, but\n"
"  that is difficult to use for a future that is reassigned.\n"
"\n"
"* Another alternative is to not use `pin` at all but spawn another task that will send to a "
"`oneshot` channel every 100ms."
msgstr ""

#: src/async/pitfalls/async-traits.md:1
#, fuzzy
msgid "# Async Traits"
msgstr "# Tratti asincroni"

#: src/async/pitfalls/async-traits.md:3
#, fuzzy
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An experimental feature "
"exists in nightly and should be stabilized in the mid term.](https://blog.rust-lang.org/inside-"
"rust/2022/11/17/async-fn-in-trait-nightly.html))"
msgstr ""
"I metodi asincroni nei tratti non sono ancora supportati nel canale stabile ([Esiste una "
"funzionalit√† sperimentale in nightly e dovrebbe essere stabilizzata a medio termine.](https://blog."
"rust-lang.org/inside-rust/2022/11 /17/async-fn-in-trait-nightly.html))"

#: src/async/pitfalls/async-traits.md:5
#, fuzzy
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) provides a workaround "
"through a macro:"
msgstr ""
"Il crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) fornisce una soluzione "
"tramite una macro:"

#: src/async/pitfalls/async-traits.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper for FixedSleeper {\n"
"    async fn sleep(&self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"running all sleepers..\");\n"
"        for sleeper in &sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/async-traits.md:49
#, fuzzy
msgid "<details>  "
msgstr "<dettagli>"

#: src/async/pitfalls/async-traits.md:51
#, fuzzy
msgid ""
"* `async_trait` is easy to use, but note that it's using heap allocations to\n"
"  achieve this. This heap allocation has performance overhead.\n"
"\n"
"* The challenges in language support for `async trait` are deep Rust and\n"
"  probably not worth describing in-depth. Niko Matsakis did a good job of\n"
"  explaining them in [this\n"
"  post](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/)\n"
"  if you are interested in digging deeper.\n"
"\n"
"* Try creating a new sleeper struct that will sleep for a random amount of time\n"
"  and adding it to the Vec."
msgstr ""
"* `async_trait` √® facile da usare, ma si noti che utilizza allocazioni di heap per\n"
"  raggiungere questo obiettivo. Questa allocazione dell'heap comporta un sovraccarico delle "
"prestazioni.\n"
"\n"
"* Le sfide nel supporto del linguaggio per `async trait` sono il profondo Rust e\n"
"  probabilmente non vale la pena descriverlo in modo approfondito. Niko Matsakis ha fatto un buon "
"lavoro\n"
"  spiegandoli in [questo\n"
"  post](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/)\n"
"  se sei interessato a scavare pi√π a fondo.\n"
"\n"
"* Prova a creare una nuova struttura dormiente che dormir√† per un periodo di tempo casuale\n"
"  e aggiungendolo al Vec."

#: src/exercises/concurrency/afternoon.md:3
msgid "To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"* Dining philosophers: we already saw this problem in the morning. This time\n"
"  you are going to implement it with Async Rust.\n"
"\n"
"* The Elevator Problem: this is a larger project that allows you experiment\n"
"  with more advanced Async Rust features and some of its pitfalls!"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:1
#, fuzzy
msgid "# Dining Philosophers - Async"
msgstr "# Filosofi da pranzo"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the\n"
"problem."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local\n"
"[Cargo installation](../../cargo/running-locally.md) for this exercise. Copy\n"
"the code below to a file called `src/main.rs`, fill out the blanks, and test\n"
"that `cargo run` does not deadlock:"
msgstr ""
"Avrai bisogno di un'[installazione Cargo](../../cargo/running-locally.md) locale per\n"
"questo esercizio. Copia il codice qui sotto in un file chiamato `src/main.rs`, compila il file\n"
"spazi vuoti e verificare che `cargo run` non vada in stallo:"

#: src/exercises/concurrency/dining-philosophers-async.md:13
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name)).await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:57
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency.\n"
"You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:62
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", \"rt-multi-thread\"]}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:72
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module\n"
"from the `tokio` crate."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:77
msgid "* Can you make your implementation single-threaded? "
msgstr ""

#: src/exercises/concurrency/elevator.md:1
#, fuzzy
msgid "# Elevator Operation"
msgstr "# Funzionamento dell'ascensore"

#: src/exercises/concurrency/elevator.md:3
#, fuzzy
msgid ""
"Elevators seem simple. You press a button, doors open, you wait, and you're at\n"
"the floor you requested. But implementing an elevator controller is surprisingly\n"
"difficult! This exercise involves building a simple elevator control that\n"
"operates in a simple simulator."
msgstr ""
"Gli ascensori sembrano semplici. Premi un pulsante, le porte si aprono, aspetti e sei a\n"
"il pavimento che hai richiesto. Ma l'implementazione di un controller per ascensori √® "
"sorprendente\n"
"difficile! Questo esercizio prevede la costruzione di un semplice controllo dell'ascensore\n"
"opera in un semplice simulatore."

#: src/exercises/concurrency/elevator.md:8
#, fuzzy
msgid ""
"The overall design of this elevator uses the actor pattern: you will implement a\n"
"controller task that communicates with other components of the elevator system\n"
"by sending and receiving messages."
msgstr ""
"Il progetto complessivo di questo ascensore utilizza il modello dell'attore: implementerai a\n"
"attivit√† del controller che comunica con altri componenti del sistema di ascensori\n"
"inviando e ricevendo messaggi."

#: src/exercises/concurrency/elevator.md:12
#, fuzzy
msgid "## Getting Started"
msgstr "## Iniziare"

#: src/exercises/concurrency/elevator.md:14
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and look in the "
"`elevator`\n"
"directory for the following files."
msgstr ""
"Scarica il [modello di esercizio](../../comprehensive-rust-exercises.zip) e guarda "
"nell'\"ascensore\"\n"
"directory per i seguenti file."

#: src/exercises/concurrency/elevator.md:21
msgid ""
"```rust,compile_fail\n"
"use building::BuildingEvent;\n"
"use tokio::sync::broadcast;\n"
"\n"
"mod building;\n"
"mod controller;\n"
"mod driver;\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let building = driver::make_building();\n"
"    let (building_task, events_rx, building_cmd_tx, driver_cmd_tx) = building.start();\n"
"\n"
"    tokio::spawn(print_events(events_rx.resubscribe()));\n"
"    tokio::spawn(driver::driver(events_rx.resubscribe(), driver_cmd_tx));\n"
"    tokio::spawn(controller::controller(events_rx, building_cmd_tx));\n"
"    building_task.await.unwrap();\n"
"}\n"
"\n"
"async fn print_events(mut events_rx: broadcast::Receiver<BuildingEvent>) {\n"
"    while let Ok(evt) = events_rx.recv().await {\n"
"        println!(\"BuildingEvent::{:?}\", evt);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/elevator.md:47
#, fuzzy
msgid "`src/building.rs`:"
msgstr "`src/edificio.rs`:"

#: src/exercises/concurrency/elevator.md:49
#, fuzzy
msgid "<!-- File src/building.rs -->"
msgstr "<!-- File src/building.rs -->"

#: src/exercises/concurrency/elevator.md:51
msgid ""
"```rust,compile_fail\n"
"//! The building simulates floors and elevators.\n"
"\n"
"use tokio::sync::{broadcast, mpsc};\n"
"use tokio::task;\n"
"use tokio::time;\n"
"\n"
"#[derive(Debug, Clone)]\n"
"pub enum Direction {\n"
"    Up,\n"
"    Down,\n"
"}\n"
"\n"
"/// A passenger is a person with a destination floor in mind.\n"
"#[derive(Debug)]\n"
"struct Passenger {\n"
"    destination: FloorId,\n"
"}\n"
"\n"
"/// FloorId identifies a floor. These are zero-based integers.\n"
"pub type FloorId = usize;\n"
"\n"
"/// Floor represents the current status of a floor in the building.\n"
"#[derive(Default, Debug)]\n"
"struct Floor {\n"
"    passengers: Vec<Passenger>,\n"
"}\n"
"\n"
"/// ElevatorId identifies an elevator in the building. These are zero-based integers.\n"
"pub type ElevatorId = usize;\n"
"\n"
"/// Elevator represents the current status of an elevator in the building.\n"
"#[derive(Default, Debug)]\n"
"struct Elevator {\n"
"    /// Floor the elevator is currently on. In the simulation the elevator\n"
"    /// transports instantaneously from one floor to the next in a single\n"
"    /// simulation tick.\n"
"    position: FloorId,\n"
"    /// Destination floor for the elevator, if any. This can change at any time.\n"
"    destination: Option<FloorId>,\n"
"    /// Passengers currently on the elevator.\n"
"    passengers: Vec<Passenger>,\n"
"    /// True if the elevator is stopped with the doors open. The elevator\n"
"    /// will not move with the doors open, but they will close at the next\n"
"    /// tick of the simulation.\n"
"    doors_open: bool,\n"
"}\n"
"\n"
"/// A BuildingEvent is an event that occurs in the building.\n"
"#[derive(Debug, Clone)]\n"
"pub enum BuildingEvent {\n"
"    /// A passenger has pressed a floor button in the elevator.\n"
"    FloorButtonPressed(ElevatorId, FloorId),\n"
"    /// A passenger on the given floor has pressed the call button.\n"
"    CallButtonPressed(FloorId, Direction),\n"
"    /// The elevator has arrived at the given floor. If this is the\n"
"    /// elevator's destination, then it will stop open its doors.\n"
"    AtFloor(ElevatorId, FloorId),\n"
"    /// A passenger has been delivered to their desired floor.\n"
"    PassengerDelivered(FloorId),\n"
"}\n"
"\n"
"/// A BuildingCommand tells the building what to do.\n"
"#[derive(Debug)]\n"
"pub enum BuildingCommand {\n"
"    /// Set the elevator's destination. The elevator will close its doors\n"
"    /// if necessary and then begin moving toward this floor.\n"
"    GoToFloor(ElevatorId, FloorId),\n"
"}\n"
"\n"
"/// A DriverCommand is a message from the driver to change the state of\n"
"/// the building.\n"
"#[derive(Debug)]\n"
"pub enum DriverCommand {\n"
"    /// A passenger has arrived and is waiting for an elevator. The passenger will automatically\n"
"    /// press the relevant call button, board the elevator when it arrives, press their floor\n"
"    /// button, and depart when the doors open on their destination floor.\n"
"    PassengerArrived { at: FloorId, destination: FloorId },\n"
"\n"
"    /// Halt all activity in the building and end the building task.\n"
"    Halt,\n"
"}\n"
"\n"
"/// Building manages the current status of the building.\n"
"#[derive(Debug)]\n"
"pub struct Building {\n"
"    floors: Vec<Floor>,\n"
"    elevators: Vec<Elevator>,\n"
"}\n"
"\n"
"impl Building {\n"
"    pub fn new(num_floors: usize, num_elevators: usize) -> Self {\n"
"        let mut floors = vec![];\n"
"        for _ in 0..num_floors {\n"
"            floors.push(Floor::default());\n"
"        }\n"
"        let mut elevators = vec![];\n"
"        for _ in 0..num_elevators {\n"
"            elevators.push(Elevator::default());\n"
"        }\n"
"        Self { floors, elevators }\n"
"    }\n"
"\n"
"    /// Start the building. The resulting channels are used to communicate\n"
"    /// with the building\n"
"    pub fn start(\n"
"        self,\n"
"    ) -> (\n"
"        task::JoinHandle<()>,\n"
"        broadcast::Receiver<BuildingEvent>,\n"
"        mpsc::Sender<BuildingCommand>,\n"
"        mpsc::Sender<DriverCommand>,\n"
"    ) {\n"
"        let (events_tx, events_rx) = broadcast::channel(10);\n"
"        let (building_cmd_tx, building_cmd_rx) = mpsc::channel(10);\n"
"        let (driver_cmd_tx, driver_cmd_rx) = mpsc::channel(10);\n"
"        let task = tokio::spawn(self.run(events_tx, building_cmd_rx, driver_cmd_rx));\n"
"        (task, events_rx, building_cmd_tx, driver_cmd_tx)\n"
"    }\n"
"\n"
"    async fn run(\n"
"        mut self,\n"
"        events_tx: broadcast::Sender<BuildingEvent>,\n"
"        mut building_cmd_rx: mpsc::Receiver<BuildingCommand>,\n"
"        mut driver_cmd_rx: mpsc::Receiver<DriverCommand>,\n"
"    ) {\n"
"        let mut ticker = time::interval(time::Duration::from_millis(100));\n"
"        loop {\n"
"            tokio::select! {\n"
"                Some(BuildingCommand::GoToFloor(el, fl)) = building_cmd_rx.recv() => {\n"
"                    self.elevators[el].destination = Some(fl);\n"
"                }\n"
"                Some(cmd) = driver_cmd_rx.recv() => {\n"
"                    match cmd {\n"
"                        DriverCommand::PassengerArrived{at, destination} => {\n"
"                            self.new_passenger(&events_tx, at, destination).await;\n"
"                        }\n"
"                        DriverCommand::Halt => return,\n"
"                    }\n"
"                }\n"
"                _ = ticker.tick() => self.move_elevators(&events_tx).await\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    /// Move the elevators toward their destinations.\n"
"    async fn move_elevators(&mut self, events_tx: &broadcast::Sender<BuildingEvent>) {\n"
"        for el in 0..self.elevators.len() {\n"
"            let elevator = &mut self.elevators[el];\n"
"\n"
"            // If the elevator's doors are open, close them and wait for the next tick.\n"
"            if elevator.doors_open {\n"
"                elevator.doors_open = false;\n"
"                continue;\n"
"            }\n"
"\n"
"            // If the elevator has somewhere to go, move toward it.\n"
"            if let Some(dest) = elevator.destination {\n"
"                if dest > elevator.position {\n"
"                    elevator.position += 1;\n"
"                }\n"
"                if dest < elevator.position {\n"
"                    elevator.position -= 1;\n"
"                }\n"
"                events_tx\n"
"                    .send(BuildingEvent::AtFloor(el, elevator.position))\n"
"                    .unwrap();\n"
"\n"
"                // If the elevator has reached its destination, open\n"
"                // the doors and let passengers get on and off.\n"
"                if elevator.position == dest {\n"
"                    elevator.destination = None;\n"
"                    elevator.doors_open = true;\n"
"                    self.exchange_passengers(&events_tx, el).await;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    /// Handle a new passenger arriving at the given floor.\n"
"    async fn new_passenger(\n"
"        &mut self,\n"
"        events_tx: &broadcast::Sender<BuildingEvent>,\n"
"        at: FloorId,\n"
"        destination: FloorId,\n"
"    ) {\n"
"        println!(\"Passenger arrived at {} going to {}\", at, destination);\n"
"        if at == destination {\n"
"            events_tx\n"
"                .send(BuildingEvent::PassengerDelivered(destination))\n"
"                .unwrap();\n"
"            return;\n"
"        }\n"
"\n"
"        self.floors[at].passengers.push(Passenger { destination });\n"
"        let dir = if at < destination {\n"
"            Direction::Up\n"
"        } else {\n"
"            Direction::Down\n"
"        };\n"
"        events_tx\n"
"            .send(BuildingEvent::CallButtonPressed(at, dir))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    /// The doors for the given elevator are open, so take on and discharge passengers.\n"
"    async fn exchange_passengers(\n"
"        &mut self,\n"
"        events_tx: &broadcast::Sender<BuildingEvent>,\n"
"        el: ElevatorId,\n"
"    ) {\n"
"        let elevator = &mut self.elevators[el];\n"
"        let fl = elevator.position;\n"
"\n"
"        // Handle passengers leaving the elevator at their floor.\n"
"        let (this_floor, other_floors): (Vec<Passenger>, Vec<Passenger>) = elevator\n"
"            .passengers\n"
"            .drain(..)\n"
"            .partition(|px| px.destination == fl);\n"
"        for px in this_floor {\n"
"            events_tx\n"
"                .send(BuildingEvent::PassengerDelivered(px.destination))\n"
"                .unwrap();\n"
"        }\n"
"        elevator.passengers = other_floors;\n"
"\n"
"        // Handle passengers entering the elevator.\n"
"        for px in self.floors[fl].passengers.drain(..) {\n"
"            events_tx\n"
"                .send(BuildingEvent::FloorButtonPressed(el, px.destination))\n"
"                .unwrap();\n"
"            elevator.passengers.push(px);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/elevator.md:288
#, fuzzy
msgid "`src/driver.rs`:"
msgstr "`src/driver.rs`:"

#: src/exercises/concurrency/elevator.md:290
#, fuzzy
msgid "<!-- File src/driver.rs -->"
msgstr "<!-- File src/driver.rs -->"

#: src/exercises/concurrency/elevator.md:292
msgid ""
"```rust,compile_fail\n"
"//! The driver controls when and where passengers arrive.\n"
"\n"
"use crate::building::{Building, BuildingEvent, DriverCommand};\n"
"use tokio::sync::{broadcast, mpsc};\n"
"\n"
"/// Create a new building to be driven by this driver.\n"
"pub fn make_building() -> Building {\n"
"    Building::new(3, 1)\n"
"}\n"
"\n"
"/// Simulate people arriving at the ground floor and going to the first floor, one by one.\n"
"pub async fn driver(\n"
"    mut events_rx: broadcast::Receiver<BuildingEvent>,\n"
"    driver_cmd_tx: mpsc::Sender<DriverCommand>,\n"
") {\n"
"    for _ in 0..3 {\n"
"        // A passenger has arrived..\n"
"        driver_cmd_tx\n"
"            .send(DriverCommand::PassengerArrived {\n"
"                at: 0,\n"
"                destination: 2,\n"
"            })\n"
"            .await\n"
"            .unwrap();\n"
"\n"
"        // Wait until they are delivered..\n"
"        while let Ok(evt) = events_rx.recv().await {\n"
"            if let BuildingEvent::PassengerDelivered(_) = evt {\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    driver_cmd_tx.send(DriverCommand::Halt).await.unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/elevator.md:330
#, fuzzy
msgid "`src/controller.rs`:"
msgstr "`src/controllore.rs`:"

#: src/exercises/concurrency/elevator.md:332
#, fuzzy
msgid "<!-- File src/controller.rs -->"
msgstr "<!-- File src/controller.rs -->"

#: src/exercises/concurrency/elevator.md:334
msgid ""
"```rust,compile_fail\n"
"//! The controller directs the elevators to operate so that passengers\n"
"//! get to their destinations.\n"
"\n"
"use crate::building::{BuildingCommand, BuildingEvent};\n"
"use tokio::sync::{broadcast, mpsc};\n"
"\n"
"pub async fn controller(\n"
"    mut events_rx: broadcast::Receiver<BuildingEvent>,\n"
"    building_cmd_tx: mpsc::Sender<BuildingCommand>,\n"
") {\n"
"    while let Ok(evt) = events_rx.recv().await {\n"
"        match evt {\n"
"            BuildingEvent::CallButtonPressed(at, _) => {\n"
"                building_cmd_tx\n"
"                    .send(BuildingCommand::GoToFloor(0, at))\n"
"                    .await\n"
"                    .unwrap();\n"
"            }\n"
"            BuildingEvent::FloorButtonPressed(_, destination) => {\n"
"                building_cmd_tx\n"
"                    .send(BuildingCommand::GoToFloor(0, destination))\n"
"                    .await\n"
"                    .unwrap();\n"
"            }\n"
"            _ => {}\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/elevator.md:369
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"elevator\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"full\"] }\n"
"```"
msgstr ""

#: src/exercises/concurrency/elevator.md:381
#, fuzzy
msgid "Use `cargo run` to run the elevator simulation."
msgstr "Usa `cargo run` per eseguire la simulazione dell'ascensore."

#: src/exercises/concurrency/elevator.md:383
#, fuzzy
msgid "## Exercises"
msgstr "Esercizi"

#: src/exercises/concurrency/elevator.md:385
#, fuzzy
msgid ""
"Begin by implementing a controller that can transport the passengers provided by\n"
"the simple driver. There is only one elevator, and passengers always go from\n"
"floor 0 to floor 2, one-by-one."
msgstr ""
"Inizia implementando un controller in grado di trasportare i passeggeri forniti da\n"
"il semplice conducente. C'√® solo un ascensore e i passeggeri vanno sempre da\n"
"piano 0 al piano 2, uno per uno."

#: src/exercises/concurrency/elevator.md:389
#, fuzzy
msgid "Once you have this done, make the problem more complex. Suggested tasks:"
msgstr "Una volta fatto ci√≤, rendi il problema pi√π complesso. Compiti suggeriti:"

#: src/exercises/concurrency/elevator.md:391
#, fuzzy
msgid ""
" * Make the driver more complex, with passengers arriving at random floors with\n"
"   random destinations at random times.\n"
"\n"
" * Create a building with more than one elevator, and adjust the controller to\n"
"   handle this efficiently.\n"
"\n"
" * Add additional events and metadata to analyze your controller's efficiency.\n"
"   What is the distribution of wait time for passengers? Is the result fair?\n"
"\n"
" * Modify the building to support a maximum passenger capacity for each\n"
"   elevator, and modify the controller to take this information into account.\n"
"\n"
" * Update the driver to simulate business traffic, with lots of passengers going\n"
"   up from the ground floor at the same time, and those passengers returning to\n"
"   the ground floor some time later. Can your controller adjust to these\n"
"   circumstances?\n"
"\n"
" * Modify the building to support \"destination dispatch\", where passengers\n"
"   signal their destination floor in the elevator lobby, before boarding the\n"
"   elevator.\n"
"\n"
" * If you are taking the course with other students, trade controllers or\n"
"   drivers with another student to see how robust your design is.\n"
"\n"
" * Build a textual or graphical display of the elevators as they run."
msgstr ""
" * Rendi il conducente pi√π complesso, con i passeggeri che arrivano a piani casuali\n"
"   destinazioni casuali in orari casuali.\n"
"\n"
" * Crea un edificio con pi√π di un ascensore e regola il controller su\n"
"   gestirlo in modo efficiente.\n"
"\n"
" * Aggiungi ulteriori eventi e metadati per analizzare l'efficienza del tuo controller.\n"
"   Qual √® la distribuzione del tempo di attesa per i passeggeri? Il risultato √® giusto?\n"
"\n"
" * Modificare l'edificio per supportare una capacit√† massima di passeggeri per ciascuno\n"
"   elevatore e modificare il controller per tenere conto di queste informazioni.\n"
"\n"
" * Aggiorna il conducente per simulare il traffico aziendale, con molti passeggeri in viaggio\n"
"   dal piano terra allo stesso tempo, e quei passeggeri che tornano a\n"
"   il piano terra qualche tempo dopo. Il tuo controller pu√≤ adattarsi a questi\n"
"   circostanze?\n"
"\n"
" * Modificare l'edificio per supportare la \"spedizione di destinazione\", dove i passeggeri\n"
"   segnala il piano di destinazione nella hall dell'ascensore, prima di salire a bordo\n"
"   ascensore.\n"
"\n"
" * Se stai frequentando il corso con altri studenti, controllori commerciali o\n"
"   driver con un altro studente per vedere quanto √® robusto il tuo progetto.\n"
"\n"
" * Costruisci una visualizzazione testuale o grafica degli ascensori mentre corrono."

#: src/thanks.md:1
#, fuzzy
msgid "# Thanks!"
msgstr "# Grazie!"

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust ü¶Ä!_ We hope you enjoyed it and that it\n"
"was useful."
msgstr ""
"_Grazie per aver preso Comprehensive Rust ü¶Ä!_ Ci auguriamo che ti sia piaciuto e che sia cos√¨\n"
"√® stato utile."

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would love\n"
"to hear from you."
msgstr ""
"Ci siamo divertiti molto a mettere insieme il corso. Il corso non √® perfetto,\n"
"quindi se hai individuato errori o hai idee per miglioramenti, entra\n"
"[contattaci su\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Ci piacerebbe\n"
"avere tue notizie."

#: src/other-resources.md:1
#, fuzzy
msgid "# Other Rust Resources"
msgstr "# Altre risorse di ruggine"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr ""
"La community di Rust ha creato una vasta gamma di risorse gratuite e di alta qualit√†\n"
"in linea."

#: src/other-resources.md:6
#, fuzzy
msgid "## Official Documentation"
msgstr "## Documentazione ufficiale"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "Il progetto Rust ospita molte risorse. Questi coprono Rust in generale:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the Rust\n"
"  syntax via a series of examples which showcase different constructs. Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [Il linguaggio di programmazione Rust](https://doc.rust-lang.org/book/): the\n"
"  canonico libro gratuito su Rust. Copre la lingua in dettaglio e include a\n"
"  pochi progetti da costruire per le persone.\n"
"* [Ruggine per esempio](https://doc.rust-lang.org/rust-by-example/): copre la Ruggine\n"
"  sintassi attraverso una serie di esempi che mostrano diversi costrutti. A volte\n"
"  include piccoli esercizi in cui ti viene chiesto di espandere il codice nel file\n"
"  esempi.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): documentazione completa di\n"
"  la libreria standard per Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): un libro incompleto\n"
"  che descrive la grammatica e il modello di memoria di Rust."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Guide pi√π specializzate ospitate sul sito ufficiale di Rust:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): copre Rust non sicuro,\n"
"  compreso il lavoro con puntatori grezzi e l'interfacciamento con altre lingue\n"
"  (FFI).\n"
"* [Programmazione asincrona in Rust](https://rust-lang.github.io/async-book/):\n"
"  copre il nuovo modello di programmazione asincrona che √® stato introdotto dopo il\n"
"  Rust Book √® stato scritto.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an\n"
"  introduzione all'utilizzo di Rust su dispositivi embedded senza sistema operativo."

#: src/other-resources.md:33
#, fuzzy
msgid "## Unofficial Learning Material"
msgstr "## Materiale didattico non ufficiale"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Una piccola selezione di altre guide e tutorial per Rust:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): a\n"
"  series of small presentations covering both basic and advanced part of the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and the\n"
"  second is a set of 11 modules which covers Rust syntax and basic constructs.\n"
"* [Learn Rust With Entirely Too Many Linked\n"
"  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth\n"
"  exploration of Rust's memory management rules, through implementing a few\n"
"  different types of list structures."
msgstr ""
"* [Impara la ruggine in modo pericoloso](http://cliffle.com/p/dangerust/): copre Rust\n"
"  dal punto di vista dei programmatori C di basso livello.\n"
"* [Ruggine per Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): copre Rust da\n"
"  la prospettiva degli sviluppatori che scrivono firmware in C.\n"
"* [Ruggine per professionisti](https://overexact.com/rust-for-professionals/):\n"
"  copre la sintassi di Rust usando confronti fianco a fianco con altri linguaggi\n"
"  come C, C++, Java, JavaScript e Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): oltre 100 esercizi per aiutarti\n"
"  impari Ruggine.\n"
"* [Insegnamento ferroso\n"
"  Materiale](https://ferrous-systems.github.io/teaching-material/index.html): a\n"
"  serie di piccole presentazioni che coprono sia la parte di base che quella avanzata del\n"
"  Linguaggio ruggine. Sono disponibili anche altri argomenti come WebAssembly e async/await\n"
"  coperto.\n"
"* [Serie per principianti a\n"
"  Ruggine](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) e\n"
"  [Fai i tuoi primi passi con\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): due\n"
"  Guide Rust rivolte ai nuovi sviluppatori. Il primo √® un set di 35 video e il\n"
"  il secondo √® un set di 11 moduli che copre la sintassi di Rust ei costrutti di base.\n"
"* [Impara la ruggine con troppi collegamenti\n"
"  Liste](https://rust-unofficial.github.io/too-many-lists/): approfondimento\n"
"  esplorazione delle regole di gestione della memoria di Rust, implementandone alcune\n"
"  diversi tipi di strutture di elenchi."

#: src/other-resources.md:63
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) for\n"
"even more Rust books."
msgstr ""
"Si prega di consultare il [Little Book of Rust Books](https://lborb.github.io/book/) per\n"
"ancora pi√π libri di Rust."

#: src/credits.md:1
#, fuzzy
msgid "# Credits"
msgstr "# Crediti"

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of useful\n"
"resources."
msgstr ""
"Il materiale qui si basa sulle molte grandi fonti di documentazione di Rust.\n"
"Vedere la pagina su [altre risorse](other-resources.md) per un elenco completo di utili\n"
"risorse."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache 2.0\n"
"license, please see [`LICENSE`](../LICENSE) for details."
msgstr ""
"Il materiale di Comprehensive Rust √® concesso in licenza secondo i termini di Apache 2.0\n"
"licenza, vedere [`LICENSE`](../LICENSE) per i dettagli."

#: src/credits.md:10
#, fuzzy
msgid "## Rust by Example"
msgstr "## Ruggine con l'esempio"

#: src/credits.md:12
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"Alcuni esempi ed esercizi sono stati copiati e adattati da [Rust by\n"
"Esempio](https://doc.rust-lang.org/rust-by-example/). Si prega di consultare il\n"
"directory `Third_party/rust-by-example/` per i dettagli, inclusa la licenza\n"
"termini."

#: src/credits.md:17
#, fuzzy
msgid "## Rust on Exercism"
msgstr "## Ruggine sull'esercizio"

#: src/credits.md:19
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the license\n"
"terms."
msgstr ""
"Alcuni esercizi sono stati copiati e adattati da [Rust on\n"
"Esercizio fisico](https://exercism.org/tracks/rust). Si prega di consultare il\n"
"directory `Third_party/rust-on-exercism/` per i dettagli, inclusa la licenza\n"
"termini."

#: src/credits.md:24
#, fuzzy
msgid "## CXX"
msgstr "##CXX"

#: src/credits.md:26
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` directory\n"
"for details, including the license terms."
msgstr ""
"La sezione [Interoperabilit√† con C++](android/interoperabilit√†/cpp.md) utilizza un file\n"
"immagine da [CXX](https://cxx.rs/). Si prega di consultare la directory `Third_party/cxx/`\n"
"per i dettagli, inclusi i termini di licenza."

#: src/exercises/solutions.md:1
#, fuzzy
msgid "# Solutions"
msgstr "# Soluzioni"

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Troverai le soluzioni degli esercizi nelle pagine seguenti."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"Sentiti libero di fare domande sulle soluzioni [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Facci sapere\n"
"se hai una soluzione diversa o migliore di quella presentata qui."

#: src/exercises/solutions.md:10
#, fuzzy
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **Nota:** Si prega di ignorare `// ANCHOR: etichetta` e `// ANCHOR_END: etichetta`\n"
"> commenti che vedi nelle soluzioni. Sono l√¨ per renderlo possibile\n"
"> riutilizzare parti delle soluzioni come esercizi."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "# Day 1 Morning Exercises"
msgstr "# Giorno 1 Esercizi mattutini"

#: src/exercises/day-1/solutions-morning.md:3
#, fuzzy
msgid "## Arrays and `for` Loops"
msgstr "## Array e cicli `for`"

#: src/exercises/day-1/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](for-loops.md))"
msgstr "([torna all'esercizio](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:78
#, fuzzy
msgid "### Bonus question"
msgstr "### Domanda bonus"

#: src/exercises/day-1/solutions-morning.md:80
#, fuzzy
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-of-slices "
"(`&[&[i32]]`) as the input type to transpose and thus make our function handle any size of matrix. "
"However, this quickly breaks down: the return type cannot be `&[&[i32]]` since it needs to own the "
"data you return."
msgstr ""
"Richiede concetti pi√π avanzati. Potrebbe sembrare che potremmo usare uno slice-of-slice "
"(`&[&[i32]]`) come tipo di input da trasporre e quindi fare in modo che la nostra funzione "
"gestisca qualsiasi dimensione di matrice. Tuttavia, questo si interrompe rapidamente: il tipo "
"restituito non pu√≤ essere `&[&[i32]]` poich√© deve essere proprietario dei dati restituiti."

#: src/exercises/day-1/solutions-morning.md:82
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work out-of-the-box "
"either: it's hard to convert from `Vec<Vec<i32>>` to `&[&[i32]]` so now you cannot easily use "
"`pretty_print` either."
msgstr ""
"Puoi provare a usare qualcosa come `Vec<Vec<i32>>`, ma neanche questo funziona immediatamente: √® "
"difficile convertire da `Vec<Vec<i32>>` a `&[ &[i32]]` quindi ora non puoi nemmeno usare "
"facilmente `pretty_print`."

#: src/exercises/day-1/solutions-morning.md:84
#, fuzzy
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::AsRef`][1] trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""
"Una volta arrivati ai tratti e ai generici, saremo in grado di usare il tratto [`std::convert::"
"AsRef`][1] per astrarre su tutto ci√≤ che pu√≤ essere referenziato come slice."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of the same length, so "
"such variable could contain an invalid matrix."
msgstr ""
"Inoltre, il tipo stesso non imporrebbe che le sezioni figlie abbiano la stessa lunghezza, quindi "
"tale variabile potrebbe contenere una matrice non valida."

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 1 Afternoon Exercises"
msgstr "# Giorno 1 Esercizi pomeridiani"

#: src/exercises/day-1/solutions-afternoon.md:3
#, fuzzy
msgid "## Designing a Library"
msgstr "## Progettare una libreria"

#: src/exercises/day-1/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](book-library.md))"
msgstr "([torna all'esercizio](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    // ANCHOR_END: setup\n"
"\n"
"    // ANCHOR: Library_new\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and year\")\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}, published in {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        // Using a closure and a built-in method:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Longer hand-written solution:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: {}\", library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "# Day 2 Morning Exercises"
msgstr "# Giorno 2 Esercizi mattutini"

#: src/exercises/day-2/solutions-morning.md:3
#, fuzzy
msgid "## Points and Polygons"
msgstr "## Punti e poligoni"

#: src/exercises/day-2/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](points-polygons.md))"
msgstr "([torna all'esercizio](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}\n"
"\n"
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}\n"
"\n"
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 2 Afternoon Exercises"
msgstr "# Giorno 2 Esercizi pomeridiani"

#: src/exercises/day-2/solutions-afternoon.md:3
#, fuzzy
msgid "## Luhn Algorithm"
msgstr "## Algoritmo di Luhn"

#: src/exercises/day-2/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](luhn.md))"
msgstr "([torna all'esercizio](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {cc_number} a valid credit card number? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:97
#, fuzzy
msgid "## Strings and Iterators"
msgstr "## Stringhe e iteratori"

#: src/exercises/day-2/solutions-afternoon.md:99
#, fuzzy
msgid "([back to exercise](strings-iterators.md))"
msgstr "([torna all'esercizio](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:101
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));\n"
"\n"
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "# Day 3 Morning Exercise"
msgstr "# Giorno 3 Esercizio mattutino"

#: src/exercises/day-3/solutions-morning.md:3
#, fuzzy
msgid "## A Simple GUI Library"
msgstr "## Una semplice libreria GUI"

#: src/exercises/day-3/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](simple-gui.md))"
msgstr "([torna all'esercizio](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }\n"
"\n"
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 3 Afternoon Exercises"
msgstr "# Giorno 3 Esercizi pomeridiani"

#: src/exercises/day-3/solutions-afternoon.md:3
#, fuzzy
msgid "## Safe FFI Wrapper"
msgstr "## Involucro FFI sicuro"

#: src/exercises/day-3/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([torna all'esercizio](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout as per man entry for dirent\n"
"    #[cfg(target_os = \"macos\")]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi\n"
"\n"
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: {err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"no-such-directory\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_empty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\"]);\n"
"        Ok(())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo Diaries\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\", \"bar.png\", \"crab.rs\", \"foo.txt\"]);\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "# Bare Metal Rust Morning Exercise"
msgstr "# Esercizio mattutino ruggine metallo nudo"

#: src/exercises/bare-metal/solutions-morning.md:3
#, fuzzy
msgid "## Compass"
msgstr "## Bussola"

#: src/exercises/bare-metal/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([torna all'esercizio](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"// ANCHOR_END: top\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"// ANCHOR: main\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // ANCHOR_END: main\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Set up display and timer.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    // ANCHOR: loop\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // ANCHOR_END: loop\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, image, 100);\n"
"\n"
"        // If button A is pressed, switch to the next mode and briefly blink all LEDs on.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometer,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        match self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (value - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_value, min(value, max_value))\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:1
#, fuzzy
msgid "# Bare Metal Rust Afternoon"
msgstr "# Bare Metal Ruggine Pomeriggio"

#: src/exercises/bare-metal/solutions-afternoon.md:3
#, fuzzy
msgid "## RTC driver"
msgstr "## Driver RTC"

#: src/exercises/bare-metal/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([torna all'esercizio](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md:7
#, fuzzy
msgid "`main.rs`:"
msgstr "`principale.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md:9
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"// ANCHOR_END: top\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"// ANCHOR: imports\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"// ANCHOR_END: imports\n"
"\n"
"/// Base address of the PL031 RTC.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// The IRQ used by the PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"// ANCHOR: main\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"    // ANCHOR_END: main\n"
"\n"
"    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // Wait for 3 seconds, without interrupts.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // Wait another 3 seconds for an interrupt.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // ANCHOR: main_end\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"// ANCHOR_END: main_end\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:149
#, fuzzy
msgid "`pl031.rs`:"
msgstr "`pl031.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md:151
msgid ""
"```rust\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Data register\n"
"    dr: u32,\n"
"    /// Match register\n"
"    mr: u32,\n"
"    /// Load register\n"
"    lr: u32,\n"
"    /// Control register\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Interrupt Mask Set or Clear register\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Raw Interrupt Status\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Masked Interrupt Status\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Interrupt Clear Register\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver for a PL031 real-time clock.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of a\n"
"    /// PL031 device, which must be mapped into the address space of the process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Reads the current RTC value.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() }\n"
"    }\n"
"\n"
"    /// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }\n"
"    }\n"
"\n"
"    /// Returns whether the match register matches the RTC value, whether or not\n"
"    /// the interrupt is enabled.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris).read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true iff `matched` returns true and the interrupt is\n"
"    /// masked.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis).read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false the\n"
"    /// interrupt is disabled.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc).write_volatile(imsc) }\n"
"    }\n"
"\n"
"    /// Clears a pending interrupt, if any.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Rtc {}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "# Concurrency Morning Exercise"
msgstr "# Esercizio mattutino in concorrenza"

#: src/exercises/concurrency/solutions-morning.md:3
#, fuzzy
msgid "## Dining Philosophers"
msgstr "## Filosofi a tavola"

#: src/exercises/concurrency/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([torna all'esercizio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();\n"
"\n"
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "# Concurrency Afternoon Exercise"
msgstr "# Esercizio mattutino in concorrenza"

#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "## Dining Philosophers - Async"
msgstr "## Filosofi a tavola"

#: src/exercises/concurrency/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([torna all'esercizio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-afternoon.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: Sender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name)).await\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        // ANCHOR: Philosopher-eat-body\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"        // ANCHOR_END: Philosopher-eat-body\n"
"\n"
"        // The locks are dropped here\n"
"        // ANCHOR: Philosopher-eat-end\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    // Create forks\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));\n"
"\n"
"    // Create philosophers\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = forks[i].clone();\n"
"            let right_fork = forks[(i + 1) % PHILOSOPHERS.len()].clone();\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork: if i % 2 == 0 { left_fork.clone() } else { right_fork.clone() },\n"
"                right_fork: if i % 2 == 0 { right_fork } else { left_fork },\n"
"                thoughts: tx.clone(),\n"
"            });\n"
"        }\n"
"        (philosophers, rx)\n"
"        // tx is dropped here, so we don't need to explicitly drop it later\n"
"    };\n"
"\n"
"    // Make them think and eat\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Output their thoughts\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Here is a thought: {thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#, fuzzy
#~ msgid "</defails>"
#~ msgstr "</defail>"
