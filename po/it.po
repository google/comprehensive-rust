msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 🦀\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-07-13 07:57+0200\n"
"Last-Translator: Enrico Rivarola\n"
"Language-Team: \n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "Benvenuti a Comprehensive Rust 🦀"

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "Esecuzione del corso"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "Struttura del corso"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "Tasti rapidi"

#: src/SUMMARY.md:7
msgid "Translations"
msgstr "Traduzioni"

#: src/SUMMARY.md:8
msgid "Using Cargo"
msgstr "Utilizzo di Cargo"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "Ecosistema di Rust"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "Esempi di codice"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "Eseguire Cargo in locale"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "Giorno 1: Mattino"

#: src/SUMMARY.md:18 src/SUMMARY.md:75 src/SUMMARY.md:128 src/SUMMARY.md:185
#: src/SUMMARY.md:211 src/SUMMARY.md:261
msgid "Welcome"
msgstr "Benvenuti"

#: src/SUMMARY.md:19
msgid "What is Rust?"
msgstr "Cos’è Rust?"

#: src/SUMMARY.md:20
msgid "Hello World!"
msgstr "Hello World!"

#: src/SUMMARY.md:21
msgid "Small Example"
msgstr "Piccolo esempio"

#: src/SUMMARY.md:22
msgid "Why Rust?"
msgstr "Perché Rust?"

#: src/SUMMARY.md:23
msgid "Compile Time Guarantees"
msgstr "Garanzie alla Compilazione"

#: src/SUMMARY.md:24
msgid "Runtime Guarantees"
msgstr "Garanzie all’Esecuzione"

#: src/SUMMARY.md:25
msgid "Modern Features"
msgstr "Funzionalità moderne"

#: src/SUMMARY.md:26
msgid "Basic Syntax"
msgstr "Sintassi di base"

#: src/SUMMARY.md:27
msgid "Scalar Types"
msgstr "Tipi Scalari"

#: src/SUMMARY.md:28
msgid "Compound Types"
msgstr "Tipi Composti"

#: src/SUMMARY.md:29
msgid "References"
msgstr "Riferimenti"

#: src/SUMMARY.md:30
msgid "Dangling References"
msgstr "Riferimenti pendenti"

#: src/SUMMARY.md:31
msgid "Slices"
msgstr "Slice"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "Differenza tra String e str"

#: src/SUMMARY.md:33
msgid "Functions"
msgstr "Funzioni"

#: src/SUMMARY.md:34
msgid "Rustdoc"
msgstr "Rustdoc"

#: src/SUMMARY.md:35 src/SUMMARY.md:82
msgid "Methods"
msgstr "Metodi"

#: src/SUMMARY.md:36
msgid "Overloading"
msgstr "Overloading"

#: src/SUMMARY.md:37 src/SUMMARY.md:66 src/SUMMARY.md:90 src/SUMMARY.md:119
#: src/SUMMARY.md:148 src/SUMMARY.md:177 src/SUMMARY.md:204 src/SUMMARY.md:225
#: src/SUMMARY.md:253 src/SUMMARY.md:275 src/SUMMARY.md:296
msgid "Exercises"
msgstr "Esercizi"

#: src/SUMMARY.md:38
msgid "Implicit Conversions"
msgstr "Conversione implicita"

#: src/SUMMARY.md:39
msgid "Arrays and for Loops"
msgstr "Array e Cicli for"

#: src/SUMMARY.md:41
msgid "Day 1: Afternoon"
msgstr "Giorno 1: Pomeriggio"

#: src/SUMMARY.md:43
msgid "Variables"
msgstr "Variabili"

#: src/SUMMARY.md:44
msgid "Type Inference"
msgstr "Inferenza del Tipo"

#: src/SUMMARY.md:45
msgid "static & const"
msgstr "static & const"

#: src/SUMMARY.md:46
msgid "Scopes and Shadowing"
msgstr "Scope e Shadowing"

#: src/SUMMARY.md:47
msgid "Memory Management"
msgstr "Gestione della Memoria"

#: src/SUMMARY.md:48
msgid "Stack vs Heap"
msgstr "Stack vs Heap"

#: src/SUMMARY.md:49
msgid "Stack Memory"
msgstr "Memoria sullo Stack"

#: src/SUMMARY.md:50
msgid "Manual Memory Management"
msgstr "Gestione manuale della Memoria"

#: src/SUMMARY.md:51
msgid "Scope-Based Memory Management"
msgstr "Gestione della Memoria basata su Scope"

#: src/SUMMARY.md:52
msgid "Garbage Collection"
msgstr "Garbage Collection"

#: src/SUMMARY.md:53
msgid "Rust Memory Management"
msgstr "Gestione della Memoria in Rust"

#: src/SUMMARY.md:54
msgid "Comparison"
msgstr "Comparazione"

#: src/SUMMARY.md:55
msgid "Ownership"
msgstr "Proprietà"

#: src/SUMMARY.md:56
msgid "Move Semantics"
msgstr "Semantica di move"

#: src/SUMMARY.md:57
msgid "Moved Strings in Rust"
msgstr "Stringhe a cui è applicata move"

#: src/SUMMARY.md:58
msgid "Double Frees in Modern C++"
msgstr "Doppio applicazione di free in C++ moderno"

#: src/SUMMARY.md:59
msgid "Moves in Function Calls"
msgstr "Move nelle Chiamate a Funzione"

#: src/SUMMARY.md:60
msgid "Copying and Cloning"
msgstr "Copiare (Copy) e Clonare (Clone)"

#: src/SUMMARY.md:61
msgid "Borrowing"
msgstr "Prestito (Borrowing)"

#: src/SUMMARY.md:62
msgid "Shared and Unique Borrows"
msgstr "Prestito (Borrow) Condiviso (Shared) e Unico (Unique)"

#: src/SUMMARY.md:63
msgid "Lifetimes"
msgstr "Lifetime"

#: src/SUMMARY.md:64
msgid "Lifetimes in Function Calls"
msgstr "Lifetime in Chiamate a Funzione"

#: src/SUMMARY.md:65
msgid "Lifetimes in Data Structures"
msgstr "Lifetime in Strutture Dati"

#: src/SUMMARY.md:67
msgid "Storing Books"
msgstr "Memorizza i libri"

#: src/SUMMARY.md:68
msgid "Iterators and Ownership"
msgstr "Iteratori (Iterators) e Proprietà (Ownership)"

#: src/SUMMARY.md:71
msgid "Day 2: Morning"
msgstr "Giorno 2: Mattina"

#: src/SUMMARY.md:76
msgid "Structs"
msgstr "Strutture (Struct)"

#: src/SUMMARY.md:77
msgid "Tuple Structs"
msgstr "Strutture a Tupla (Tuple Structs)"

#: src/SUMMARY.md:78
msgid "Field Shorthand Syntax"
msgstr "Sintassi abbreviata per Campo (Field)"

#: src/SUMMARY.md:79
msgid "Enums"
msgstr "Enumerazioni (Enums)"

#: src/SUMMARY.md:80
msgid "Variant Payloads"
msgstr "Payload Variabili (Variant Payloads)"

#: src/SUMMARY.md:81
msgid "Enum Sizes"
msgstr "Dimensione degli Enum"

#: src/SUMMARY.md:83
msgid "Method Receiver"
msgstr "Ricevitore (Receiver) del Metodo"

#: src/SUMMARY.md:84 src/SUMMARY.md:159 src/SUMMARY.md:274
msgid "Example"
msgstr "Esempio"

#: src/SUMMARY.md:85
msgid "Pattern Matching"
msgstr "Pattern Matching"

#: src/SUMMARY.md:86
msgid "Destructuring Enums"
msgstr "Destrutturazione di Enum"

#: src/SUMMARY.md:87
msgid "Destructuring Structs"
msgstr "Destrutturazione di Struct"

#: src/SUMMARY.md:88
msgid "Destructuring Arrays"
msgstr "Destrutturazione di Array"

#: src/SUMMARY.md:89
msgid "Match Guards"
msgstr "Match Guards"

#: src/SUMMARY.md:91
msgid "Health Statistics"
msgstr "Salute (Health) Statistics"

#: src/SUMMARY.md:92
msgid "Points and Polygons"
msgstr "Punti e Poligoni"

#: src/SUMMARY.md:94
msgid "Day 2: Afternoon"
msgstr "Giorno 2: Pomeriggio"

#: src/SUMMARY.md:96 src/SUMMARY.md:288
msgid "Control Flow"
msgstr "Flusso di Controllo"

#: src/SUMMARY.md:97
msgid "Blocks"
msgstr "Blocchi"

#: src/SUMMARY.md:98
msgid "if expressions"
msgstr "espressioni IF"

#: src/SUMMARY.md:99
msgid "if let expressions"
msgstr "espressioni IF LET"

#: src/SUMMARY.md:100
msgid "while expressions"
msgstr "espressioni WHILE"

#: src/SUMMARY.md:101
msgid "while let expressions"
msgstr "espressioni WHILE LET"

#: src/SUMMARY.md:102
msgid "for expressions"
msgstr "espressioni FOR"

#: src/SUMMARY.md:103
msgid "loop expressions"
msgstr "espressioni LOOP"

#: src/SUMMARY.md:104
msgid "match expressions"
msgstr "espressioni MATCH"

#: src/SUMMARY.md:105
msgid "break & continue"
msgstr "break & continue"

#: src/SUMMARY.md:106
msgid "Standard Library"
msgstr "Libreria standard"

#: src/SUMMARY.md:107
msgid "Option and Result"
msgstr "Option e Result"

#: src/SUMMARY.md:108
msgid "String"
msgstr "Stringa (String)"

#: src/SUMMARY.md:109
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:110
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:111
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:112
msgid "Recursive Data Types"
msgstr "Tipi di dati ricorsivi"

#: src/SUMMARY.md:113
msgid "Niche Optimization"
msgstr "Ottimizzazioni di nicchia"

#: src/SUMMARY.md:114
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:115
msgid "Modules"
msgstr "Moduli"

#: src/SUMMARY.md:116
msgid "Visibility"
msgstr "Visibilità"

#: src/SUMMARY.md:117
msgid "Paths"
msgstr "Percorsi (Paths)"

#: src/SUMMARY.md:118
msgid "Filesystem Hierarchy"
msgstr "Gerarchia del filesystem"

#: src/SUMMARY.md:120
msgid "Luhn Algorithm"
msgstr "Algoritmo di Luhn"

#: src/SUMMARY.md:121
msgid "Strings and Iterators"
msgstr "Stringhe (Strings) e Iteratori (Iterators)"

#: src/SUMMARY.md:124
msgid "Day 3: Morning"
msgstr "Giorno 3: Mattina"

#: src/SUMMARY.md:129
msgid "Generics"
msgstr "Generics"

#: src/SUMMARY.md:130
msgid "Generic Data Types"
msgstr "Tipi di dati Generic"

#: src/SUMMARY.md:131
msgid "Generic Methods"
msgstr "Metodi Generic"

#: src/SUMMARY.md:132
msgid "Monomorphization"
msgstr "Monomorfizzazione (Monomorphization)"

#: src/SUMMARY.md:133
msgid "Traits"
msgstr "Traits"

#: src/SUMMARY.md:134
msgid "Trait Objects"
msgstr "Oggetti che implementano Trait (Trait Objects)"

#: src/SUMMARY.md:135
msgid "Deriving Traits"
msgstr "Tratti derivati"

#: src/SUMMARY.md:136
msgid "Default Methods"
msgstr "Metodi predefiniti (Default Methods)"

#: src/SUMMARY.md:137
msgid "Trait Bounds"
msgstr "Trait Bounds"

#: src/SUMMARY.md:138
msgid "impl Trait"
msgstr "impl Trait"

#: src/SUMMARY.md:139
msgid "Important Traits"
msgstr "Trait importanti"

#: src/SUMMARY.md:140
msgid "Iterator"
msgstr "Iteratore (Iterator)"

#: src/SUMMARY.md:141
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:142
msgid "From and Into"
msgstr "From e Into (Trait)"

#: src/SUMMARY.md:143
msgid "Read and Write"
msgstr "Read e Write"

#: src/SUMMARY.md:144
msgid "Drop"
msgstr "Rilascio (Drop)"

#: src/SUMMARY.md:145
msgid "Default"
msgstr "Predefinito (Default)"

#: src/SUMMARY.md:146
msgid "Operators: Add, Mul, ..."
msgstr "Operatori: Add, Mul, ..."

#: src/SUMMARY.md:147
msgid "Closures: Fn, FnMut, FnOnce"
msgstr "Closures: Fn, FnMut, FnOnce"

#: src/SUMMARY.md:149
msgid "A Simple GUI Library"
msgstr "Una semplice libreria per Interfacce Grafiche"

#: src/SUMMARY.md:151
msgid "Day 3: Afternoon"
msgstr "Giorno 3: Pomeriggio"

#: src/SUMMARY.md:153
msgid "Error Handling"
msgstr "Gestione degli errori"

#: src/SUMMARY.md:154
msgid "Panics"
msgstr "Panico (Panics)"

#: src/SUMMARY.md:155
msgid "Catching Stack Unwinding"
msgstr "Catturare lo Stack Unwinding"

#: src/SUMMARY.md:156
msgid "Structured Error Handling"
msgstr "Gestione strutturata degli errori"

#: src/SUMMARY.md:157
msgid "Propagating Errors with ?"
msgstr "Propagazione degli errori con ?"

#: src/SUMMARY.md:158
msgid "Converting Error Types"
msgstr "Conversione dei tipi di errore"

#: src/SUMMARY.md:160
msgid "Deriving Error Enums"
msgstr "Derivazione di Enumerazioni (Enums) di errori"

#: src/SUMMARY.md:161
msgid "Dynamic Error Types"
msgstr "Tipi di errori dinamici"

#: src/SUMMARY.md:162
msgid "Adding Context to Errors"
msgstr "Aggiungere contesto agli errori"

#: src/SUMMARY.md:163
msgid "Testing"
msgstr "Testare"

#: src/SUMMARY.md:164
msgid "Unit Tests"
msgstr "Test per unità"

#: src/SUMMARY.md:165
msgid "Test Modules"
msgstr "Moduli (Module) di Test"

#: src/SUMMARY.md:166
msgid "Documentation Tests"
msgstr "Test nella documentazione"

#: src/SUMMARY.md:167
msgid "Integration Tests"
msgstr "Test di integrazione"

#: src/SUMMARY.md:168
msgid "Useful crates"
msgstr "Crates utili"

#: src/SUMMARY.md:169
msgid "Unsafe Rust"
msgstr "Unsafe Rust"

#: src/SUMMARY.md:170
msgid "Dereferencing Raw Pointers"
msgstr "Dereferenziamento dei Puntatori (Pointers) Grezzi (Raw)"

#: src/SUMMARY.md:171
msgid "Mutable Static Variables"
msgstr "Variabili Statiche Mutabili"

#: src/SUMMARY.md:172
msgid "Unions"
msgstr "Unioni"

#: src/SUMMARY.md:173
msgid "Calling Unsafe Functions"
msgstr "Chiamare Funzioni Unsafe"

#: src/SUMMARY.md:174
msgid "Writing Unsafe Functions"
msgstr "Creare Funzioni Unsafe"

#: src/SUMMARY.md:175
msgid "Extern Functions"
msgstr "Funzioni Esterne (Extern)"

#: src/SUMMARY.md:176
msgid "Implementing Unsafe Traits"
msgstr "Implementare Unsafe Traits"

#: src/SUMMARY.md:178
msgid "Safe FFI Wrapper"
msgstr "Safe FFI Wrapper"

#: src/SUMMARY.md:181 src/SUMMARY.md:251
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:186
msgid "Setup"
msgstr "Setup"

#: src/SUMMARY.md:187
msgid "Build Rules"
msgstr "Regole (Rules) di Build"

#: src/SUMMARY.md:188
msgid "Binary"
msgstr "Binario"

#: src/SUMMARY.md:189
msgid "Library"
msgstr "Libreria (Library)"

#: src/SUMMARY.md:190
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:191
msgid "Interface"
msgstr "Interfaccia"

#: src/SUMMARY.md:192
msgid "Implementation"
msgstr "Implementazione"

#: src/SUMMARY.md:193
msgid "Server"
msgstr "Server"

#: src/SUMMARY.md:194
msgid "Deploy"
msgstr "Deploy"

#: src/SUMMARY.md:195
msgid "Client"
msgstr "Client"

#: src/SUMMARY.md:196
msgid "Changing API"
msgstr "Cambiare API"

#: src/SUMMARY.md:197 src/SUMMARY.md:241
msgid "Logging"
msgstr "Logging"

#: src/SUMMARY.md:198
msgid "Interoperability"
msgstr "Interoperabilità"

#: src/SUMMARY.md:199
msgid "With C"
msgstr "Con C"

#: src/SUMMARY.md:200
msgid "Calling C with Bindgen"
msgstr "Invocare C con Bindgen"

#: src/SUMMARY.md:201
msgid "Calling Rust from C"
msgstr "Invocare Rust da C"

#: src/SUMMARY.md:202
msgid "With C++"
msgstr "Con C++"

#: src/SUMMARY.md:203
msgid "With Java"
msgstr "Con Java"

#: src/SUMMARY.md:207
msgid "Bare Metal: Morning"
msgstr "Bare Metal: Mattino"

#: src/SUMMARY.md:212
msgid "no_std"
msgstr "no_std"

#: src/SUMMARY.md:213
msgid "A Minimal Example"
msgstr "Un Esempio Minimo"

#: src/SUMMARY.md:214
msgid "alloc"
msgstr "alloc"

#: src/SUMMARY.md:215
msgid "Microcontrollers"
msgstr "Microcontroller"

#: src/SUMMARY.md:216
msgid "Raw MMIO"
msgstr "Raw MMIO"

#: src/SUMMARY.md:217
msgid "PACs"
msgstr "PAC"

#: src/SUMMARY.md:218
msgid "HAL Crates"
msgstr "HAL Crates"

#: src/SUMMARY.md:219
msgid "Board Support Crates"
msgstr "Crate di supporto per Board"

#: src/SUMMARY.md:220
msgid "The Type State Pattern"
msgstr "Il modello (Pattern) di Type State"

#: src/SUMMARY.md:221
msgid "embedded-hal"
msgstr "embedded-hal"

#: src/SUMMARY.md:222
msgid "probe-rs, cargo-embed"
msgstr "probe-rs, cargo-embed"

#: src/SUMMARY.md:223
msgid "Debugging"
msgstr "Debugging"

#: src/SUMMARY.md:224 src/SUMMARY.md:244
msgid "Other Projects"
msgstr "Altri Progetti"

#: src/SUMMARY.md:226
msgid "Compass"
msgstr "Bussola"

#: src/SUMMARY.md:228
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal: Pomeriggio"

#: src/SUMMARY.md:230
msgid "Application Processors"
msgstr "Processori di Applicazioni"

#: src/SUMMARY.md:231
msgid "Getting Ready to Rust"
msgstr ""

#: src/SUMMARY.md:232
msgid "Inline Assembly"
msgstr "Inline Assembly"

#: src/SUMMARY.md:233
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md:234
msgid "Let's Write a UART Driver"
msgstr "Scriviamo un driver UART"

#: src/SUMMARY.md:235
msgid "More Traits"
msgstr "Traits addizionali"

#: src/SUMMARY.md:236
msgid "A Better UART Driver"
msgstr "Un migliore driver UART"

#: src/SUMMARY.md:237
msgid "Bitflags"
msgstr "Bitflag"

#: src/SUMMARY.md:238
msgid "Multiple Registers"
msgstr "Registri multipli"

#: src/SUMMARY.md:239
msgid "Driver"
msgstr "Driver"

#: src/SUMMARY.md:240 src/SUMMARY.md:242
msgid "Using It"
msgstr "Usandolo"

#: src/SUMMARY.md:243
msgid "Exceptions"
msgstr "Eccezioni"

#: src/SUMMARY.md:245
msgid "Useful Crates"
msgstr "Crates Utili"

#: src/SUMMARY.md:246
msgid "zerocopy"
msgstr "zerocopy"

#: src/SUMMARY.md:247
msgid "aarch64-paging"
msgstr "paginazione aarch64 (aarch64-paging)"

#: src/SUMMARY.md:248
msgid "buddy_system_allocator"
msgstr "buddy_system_allocator"

#: src/SUMMARY.md:249
msgid "tinyvec"
msgstr "tinyvec"

#: src/SUMMARY.md:250
msgid "spin"
msgstr "rotazione (spin)"

#: src/SUMMARY.md:252
msgid "vmbase"
msgstr "vmbase"

#: src/SUMMARY.md:254
msgid "RTC Driver"
msgstr "Driver RTC"

#: src/SUMMARY.md:257
msgid "Concurrency: Morning"
msgstr "Concorrenza: Mattino"

#: src/SUMMARY.md:262
msgid "Threads"
msgstr "Threads"

#: src/SUMMARY.md:263
msgid "Scoped Threads"
msgstr "Thread con Scope (Scoped Threads)"

#: src/SUMMARY.md:264
msgid "Channels"
msgstr "Canali (Channels)"

#: src/SUMMARY.md:265
msgid "Unbounded Channels"
msgstr "Canali illimitati (Unbounded Channels)"

#: src/SUMMARY.md:266
msgid "Bounded Channels"
msgstr "Canali delimitati (Bounded Channels)"

#: src/SUMMARY.md:267
msgid "Send and Sync"
msgstr "Send e Sync"

#: src/SUMMARY.md:267
msgid "Send"
msgstr "Send (Inviare)"

#: src/SUMMARY.md:267
msgid "Sync"
msgstr "Sync (Sincronizzare)"

#: src/SUMMARY.md:270
msgid "Examples"
msgstr "Esempi"

#: src/SUMMARY.md:271
msgid "Shared State"
msgstr "Stato Condiviso"

#: src/SUMMARY.md:272
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:273
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:276 src/SUMMARY.md:297
msgid "Dining Philosophers"
msgstr "Filosofi a tavola"

#: src/SUMMARY.md:277
msgid "Multi-threaded Link Checker"
msgstr "Correttore di Link a Thread multipli"

#: src/SUMMARY.md:279
msgid "Concurrency: Afternoon"
msgstr "Concorrenza: Pomeriggio"

#: src/SUMMARY.md:281
msgid "Async Basics"
msgstr "Nozioni di base sulla programmazione Async (asincrona)"

#: src/SUMMARY.md:282
msgid "async/await"
msgstr "Async/await"

#: src/SUMMARY.md:283
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md:284
msgid "Runtimes"
msgstr "Esecutori"

#: src/SUMMARY.md:285
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md:286
msgid "Tasks"
msgstr "Compiti (Tasks)"

#: src/SUMMARY.md:287
msgid "Async Channels"
msgstr "Canali asincroni (Async Channels)"

#: src/SUMMARY.md:289
msgid "Join"
msgstr "Giunzione (Join)"

#: src/SUMMARY.md:290
msgid "Select"
msgstr "Selezione (Select)"

#: src/SUMMARY.md:291
msgid "Pitfalls"
msgstr "Insidie"

#: src/SUMMARY.md:292
msgid "Blocking the Executor"
msgstr "Blocco dell’Esecutore"

#: src/SUMMARY.md:293
msgid "Pin"
msgstr "Spillo (Pin)"

#: src/SUMMARY.md:294
msgid "Async Traits"
msgstr "Trait asincroni (Async Trait)"

#: src/SUMMARY.md:295
msgid "Cancellation"
msgstr "Cancellazione (cancellation)"

#: src/SUMMARY.md:298
msgid "Broadcast Chat Application"
msgstr "Applicazione Chat-Broadcast"

#: src/SUMMARY.md:301
msgid "Final Words"
msgstr "Parole finali"

#: src/SUMMARY.md:305
msgid "Thanks!"
msgstr "Grazie!"

#: src/SUMMARY.md:306
msgid "Other Resources"
msgstr "Altre risorse"

#: src/SUMMARY.md:307
msgid "Credits"
msgstr "Crediti"

#: src/SUMMARY.md:310
msgid "Solutions"
msgstr "Soluzioni"

#: src/SUMMARY.md:315
msgid "Day 1 Morning"
msgstr "Giorno 1 Mattina"

#: src/SUMMARY.md:316
msgid "Day 1 Afternoon"
msgstr "Giorno 1 Pomeriggio"

#: src/SUMMARY.md:317
msgid "Day 2 Morning"
msgstr "Giorno 2 Mattina"

#: src/SUMMARY.md:318
msgid "Day 2 Afternoon"
msgstr "Giorno 2 Pomeriggio"

#: src/SUMMARY.md:319
msgid "Day 3 Morning"
msgstr "Giorno 3 Mattina"

#: src/SUMMARY.md:320
msgid "Day 3 Afternoon"
msgstr "Giorno 3 Pomeriggio"

#: src/SUMMARY.md:321
msgid "Bare Metal Rust Morning"
msgstr "Mattina su Bare Metal Rust"

#: src/SUMMARY.md:322
msgid "Bare Metal Rust Afternoon"
msgstr "Pomeriggio su Bare Metal Rust"

#: src/SUMMARY.md:323
msgid "Concurrency Morning"
msgstr "Mattina su Concorrenza"

#: src/SUMMARY.md:324
msgid "Concurrency Afternoon"
msgstr "Giorno 1: Pomeriggio"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust 🦀"
msgstr "# Benvenuti a Comprehensive Rust 🦀"

#: src/welcome.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain)"
msgstr ""

#: src/welcome.md:3
msgid "Build workflow"
msgstr "Stato Build"

#: src/welcome.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain)\n"
"[![GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors)"
msgstr ""

#: src/welcome.md:4
msgid "GitHub contributors"
msgstr "Collaboratori di GitHub"

#: src/welcome.md:4
msgid ""
"[![GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors)\n"
"[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-"
"rust?style=flat-square)](https://github.com/google/comprehensive-rust/"
"stargazers)"
msgstr ""

#: src/welcome.md:5
msgid "GitHub stars"
msgstr "Stelle di GitHub"

#: src/welcome.md:5
msgid ""
"[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-"
"rust?style=flat-square)](https://github.com/google/comprehensive-rust/"
"stargazers)"
msgstr ""

#: src/welcome.md:7
msgid ""
"This is a three day Rust course developed by the Android team. The course "
"covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like "
"generics\n"
"and error handling. It also includes Android-specific content on the last "
"day."
msgstr ""
"Questo è un corso Rust di tre giorni sviluppato dal team Android. Il corso "
"copre\n"
"l'intero spettro di Rust, dalla sintassi di base ad argomenti avanzati come "
"i generici\n"
"e gestione degli errori. Include anche contenuti specifici per Android "
"nell'ultimo giorno."

#: src/welcome.md:11
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything\n"
"about Rust and hope to:"
msgstr ""
"L'obiettivo del corso è insegnarti Rust. Partiamo dal presupposto che tu non "
"sappia nulla\n"
"su Rust e spero di:"

#: src/welcome.md:14
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* Fornire una comprensione completa della sintassi e del linguaggio di "
"Rust.\n"
"* Consentono di modificare i programmi esistenti e scrivere nuovi programmi "
"in Rust.\n"
"* Mostra i comuni idiomi di Rust."

#: src/welcome.md:18
msgid ""
"The first three days show you the fundamentals of Rust. Following this, "
"you're\n"
"invited to dive into one or more specialized topics:"
msgstr ""
"I primi tre giorni ti mostrano i fondamenti di Rust. A seguito di questo, "
"sei\n"
"invitato ad approfondire uno o più argomenti specialistici:"

#: src/welcome.md:21
msgid ""
"* [Android](android.md): a half-day course on using Rust for Android "
"platform\n"
"  development (AOSP). This includes interoperability with C, C++, and Java.\n"
"* [Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-"
"metal\n"
"  (embedded) development. Both microcontrollers and application processors "
"are\n"
"  covered.\n"
"* [Concurrency](concurrency.md): a whole-day class on concurrency in Rust. "
"We\n"
"  cover both classical concurrency (preemptively scheduling using threads "
"and\n"
"  mutexes) and async/await concurrency (cooperative multitasking using\n"
"  futures)."
msgstr ""
"* [Android](android.md): un corso di mezza giornata sull'utilizzo della "
"piattaforma Rust per Android\n"
"  sviluppo (AOSP). Ciò include l'interoperabilità con C, C++ e Java.\n"
"* [Bare-metal](bare-metal.md): una lezione di un'intera giornata "
"sull'utilizzo di Rust per bare-metal\n"
"  sviluppo (incorporato). Lo sono sia i microcontrollori che i processori "
"applicativi\n"
"  coperto.\n"
"* [Concurrency](concurrency.md): una lezione di un'intera giornata sulla "
"concorrenza in Rust. Noi\n"
"  coprire sia la concorrenza classica (pianificazione preventiva utilizzando "
"thread e\n"
"  mutextes) e async/await concurrency (multitasking cooperativo tramite\n"
"  futuri)."

#: src/welcome.md:32
msgid "## Non-Goals"
msgstr "## Non goal"

#: src/welcome.md:34
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days.\n"
"Some non-goals of this course are:"
msgstr ""
"Rust è un linguaggio vasto e non saremo in grado di coprirlo tutto in pochi "
"giorni.\n"
"Alcuni non-obiettivi di questo corso sono:"

#: src/welcome.md:37
msgid ""
"* Learning how to develop macros: please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* Imparare come sviluppare le macro, per favore vedi ['Rust "
"Book' (Capitolo 19.5)](https://doc.rust-lang.org/book/ch19-06-macros.html) e [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html)."

#: src/welcome.md:41
msgid "## Assumptions"
msgstr "## Ipotesi"

#: src/welcome.md:43
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-\n"
"typed language and we will sometimes make comparisons with C and C++ to "
"better\n"
"explain or contrast the Rust approach."
msgstr ""
"Il corso presuppone che tu sappia già programmare. La ruggine è "
"staticamente\n"
"linguaggio digitato e talvolta faremo confronti migliori con C e C++\n"
"spiegare o contrastare l'approccio di Rust."

#: src/welcome.md:47
msgid ""
"If you know how to program in a dynamically-typed language such as Python "
"or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Se sai come programmare in un linguaggio tipizzato dinamicamente come Python "
"o\n"
"JavaScript, allora sarai anche in grado di seguire bene."

#: src/welcome.md:50 src/cargo/rust-ecosystem.md:19
#: src/cargo/code-samples.md:22 src/cargo/running-locally.md:68
#: src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8
#: src/why-rust/modern.md:19 src/basic-syntax/scalar-types.md:19
#: src/basic-syntax/compound-types.md:28 src/basic-syntax/references.md:21
#: src/basic-syntax/slices.md:18 src/basic-syntax/string-slices.md:25
#: src/basic-syntax/functions.md:33 src/basic-syntax/rustdoc.md:22
#: src/basic-syntax/methods.md:32 src/basic-syntax/functions-interlude.md:25
#: src/exercises/day-1/morning.md:9 src/exercises/day-1/for-loops.md:90
#: src/basic-syntax/variables.md:15 src/basic-syntax/type-inference.md:24
#: src/basic-syntax/static-and-const.md:48
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27
#: src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/exercises/day-1/book-library.md:100
#: src/structs.md:29 src/structs/tuple-structs.md:35
#: src/structs/field-shorthand.md:25 src/enums.md:32
#: src/enums/variant-payloads.md:33 src/enums/sizes.md:27 src/methods.md:28
#: src/methods/receiver.md:22 src/methods/example.md:44
#: src/pattern-matching.md:23 src/pattern-matching/destructuring-enums.md:33
#: src/pattern-matching/destructuring-structs.md:21
#: src/pattern-matching/destructuring-arrays.md:19
#: src/pattern-matching/match-guards.md:20 src/exercises/day-2/morning.md:9
#: src/exercises/day-2/points-polygons.md:115 src/control-flow/blocks.md:41
#: src/control-flow/if-expressions.md:33
#: src/control-flow/if-let-expressions.md:21
#: src/control-flow/while-let-expressions.md:24
#: src/control-flow/for-expressions.md:23
#: src/control-flow/loop-expressions.md:25
#: src/control-flow/match-expressions.md:26 src/std.md:23
#: src/std/option-result.md:16 src/std/string.md:28 src/std/vec.md:35
#: src/std/hashmap.md:36 src/std/box.md:32 src/std/box-recursive.md:31
#: src/std/rc.md:29 src/modules.md:26 src/modules/visibility.md:37
#: src/modules/filesystem.md:42 src/exercises/day-2/afternoon.md:5
#: src/generics/data-types.md:19 src/generics/methods.md:23
#: src/traits/trait-objects.md:70 src/traits/default-methods.md:30
#: src/traits/trait-bounds.md:33 src/traits/impl-trait.md:21
#: src/traits/iterator.md:30 src/traits/from-iterator.md:15
#: src/traits/from-into.md:27 src/traits/drop.md:32 src/traits/default.md:38
#: src/traits/operators.md:24 src/traits/closures.md:32
#: src/exercises/day-3/morning.md:5 src/error-handling/result.md:25
#: src/error-handling/try-operator.md:46
#: src/error-handling/converting-error-types-example.md:48
#: src/error-handling/deriving-error-enums.md:37
#: src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26
#: src/unsafe/raw-pointers.md:25 src/unsafe/mutable-static-variables.md:30
#: src/unsafe/unions.md:19 src/unsafe/writing-unsafe-functions.md:31
#: src/unsafe/extern-functions.md:19 src/unsafe/unsafe-traits.md:28
#: src/exercises/day-3/afternoon.md:12
#: src/android/interoperability/with-c/rust.md:81
#: src/exercises/android/morning.md:10 src/bare-metal/minimal.md:15
#: src/bare-metal/alloc.md:37 src/bare-metal/microcontrollers.md:23
#: src/bare-metal/microcontrollers/mmio.md:62
#: src/bare-metal/microcontrollers/pacs.md:47
#: src/bare-metal/microcontrollers/hals.md:37
#: src/bare-metal/microcontrollers/board-support.md:26
#: src/bare-metal/microcontrollers/type-state.md:30
#: src/bare-metal/microcontrollers/embedded-hal.md:17
#: src/bare-metal/microcontrollers/probe-rs.md:14
#: src/bare-metal/microcontrollers/debugging.md:25
#: src/bare-metal/microcontrollers/other-projects.md:16
#: src/exercises/bare-metal/morning.md:5 src/bare-metal/aps.md:7
#: src/bare-metal/aps/entry-point.md:75
#: src/bare-metal/aps/inline-assembly.md:41 src/bare-metal/aps/mmio.md:7
#: src/bare-metal/aps/uart.md:53 src/bare-metal/aps/uart/traits.md:22
#: src/bare-metal/aps/better-uart.md:24
#: src/bare-metal/aps/better-uart/bitflags.md:35
#: src/bare-metal/aps/better-uart/registers.md:39
#: src/bare-metal/aps/better-uart/driver.md:62
#: src/bare-metal/aps/better-uart/using.md:49 src/bare-metal/aps/logging.md:48
#: src/bare-metal/aps/logging/using.md:44 src/bare-metal/aps/exceptions.md:62
#: src/bare-metal/aps/other-projects.md:15
#: src/bare-metal/useful-crates/zerocopy.md:43
#: src/bare-metal/useful-crates/aarch64-paging.md:26
#: src/bare-metal/useful-crates/buddy_system_allocator.md:24
#: src/bare-metal/useful-crates/tinyvec.md:21
#: src/bare-metal/useful-crates/spin.md:21 src/bare-metal/android/vmbase.md:19
#: src/exercises/bare-metal/afternoon.md:5 src/concurrency/threads.md:28
#: src/concurrency/scoped-threads.md:35 src/concurrency/channels.md:25
#: src/concurrency/channels/bounded.md:29 src/concurrency/send-sync.md:18
#: src/concurrency/send-sync/send.md:11 src/concurrency/send-sync/sync.md:12
#: src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/mutex.md:29
#: src/concurrency/shared_state/example.md:21
#: src/exercises/concurrency/morning.md:10 src/async/async-await.md:23
#: src/async/futures.md:30 src/async/runtimes.md:18
#: src/async/runtimes/tokio.md:31 src/async/tasks.md:50
#: src/async/channels.md:33 src/async/control-flow/join.md:34
#: src/async/control-flow/select.md:60
#: src/async/pitfalls/blocking-executor.md:27 src/async/pitfalls/pin.md:66
#: src/async/pitfalls/cancellation.md:70
#: src/exercises/concurrency/afternoon.md:11
#: src/exercises/concurrency/dining-philosophers-async.md:75
msgid "<details>"
msgstr "<details>"

#: src/welcome.md:52
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor "
"should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"Questo è un esempio di _nota del relatore_. Useremo questi per aggiungere "
"ulteriori\n"
"informazioni alle diapositive. Questi potrebbero essere punti chiave che "
"l'istruttore dovrebbe\n"
"copertina così come le risposte alle domande tipiche che sorgono in classe."

#: src/welcome.md:56 src/cargo/rust-ecosystem.md:67
#: src/cargo/code-samples.md:35 src/cargo/running-locally.md:74
#: src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:40 src/hello-world/small-example.md:46 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:23
#: src/why-rust/modern.md:66 src/basic-syntax/scalar-types.md:43
#: src/basic-syntax/compound-types.md:62 src/basic-syntax/references.md:29
#: src/basic-syntax/slices.md:36 src/basic-syntax/string-slices.md:44
#: src/basic-syntax/functions.md:41 src/basic-syntax/rustdoc.md:33
#: src/basic-syntax/methods.md:45 src/basic-syntax/functions-interlude.md:30
#: src/exercises/day-1/morning.md:28 src/exercises/day-1/for-loops.md:95
#: src/basic-syntax/variables.md:20 src/basic-syntax/type-inference.md:48
#: src/basic-syntax/static-and-const.md:55
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/copy-clone.md:51
#: src/ownership/borrowing.md:51 src/ownership/shared-unique-borrows.md:29
#: src/ownership/lifetimes-function-calls.md:60
#: src/ownership/lifetimes-data-structures.md:30
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:104
#: src/structs.md:42 src/structs/tuple-structs.md:44
#: src/structs/field-shorthand.md:72 src/enums.md:42
#: src/enums/variant-payloads.md:45 src/enums/sizes.md:155 src/methods.md:41
#: src/methods/receiver.md:28 src/methods/example.md:53
#: src/pattern-matching.md:35 src/pattern-matching/destructuring-enums.md:39
#: src/pattern-matching/destructuring-structs.md:29
#: src/pattern-matching/destructuring-arrays.md:46
#: src/pattern-matching/match-guards.md:28 src/exercises/day-2/morning.md:15
#: src/exercises/day-2/points-polygons.md:125 src/control-flow/blocks.md:47
#: src/control-flow/if-expressions.md:37
#: src/control-flow/if-let-expressions.md:41
#: src/control-flow/while-let-expressions.md:29
#: src/control-flow/for-expressions.md:30
#: src/control-flow/loop-expressions.md:32
#: src/control-flow/match-expressions.md:33 src/std.md:31
#: src/std/option-result.md:25 src/std/string.md:42 src/std/vec.md:49
#: src/std/hashmap.md:66 src/std/box.md:39 src/std/box-recursive.md:41
#: src/std/rc.md:69 src/modules.md:32 src/modules/visibility.md:48
#: src/modules/filesystem.md:71 src/exercises/day-2/afternoon.md:11
#: src/generics/data-types.md:25 src/generics/methods.md:31
#: src/traits/trait-objects.md:83 src/traits/default-methods.md:60
#: src/traits/trait-bounds.md:50 src/traits/impl-trait.md:44
#: src/traits/iterator.md:42 src/traits/from-iterator.md:26
#: src/traits/from-into.md:33 src/traits/drop.md:42 src/traits/default.md:47
#: src/traits/operators.md:40 src/traits/closures.md:63
#: src/exercises/day-3/morning.md:11 src/error-handling/result.md:33
#: src/error-handling/try-operator.md:53
#: src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45
#: src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32
#: src/unsafe/raw-pointers.md:43 src/unsafe/mutable-static-variables.md:35
#: src/unsafe/unions.md:28 src/unsafe/writing-unsafe-functions.md:38
#: src/unsafe/extern-functions.md:28 src/unsafe/unsafe-traits.md:37
#: src/exercises/day-3/afternoon.md:18
#: src/android/interoperability/with-c/rust.md:86
#: src/exercises/android/morning.md:15 src/bare-metal/no_std.md:65
#: src/bare-metal/minimal.md:26 src/bare-metal/alloc.md:49
#: src/bare-metal/microcontrollers.md:29
#: src/bare-metal/microcontrollers/mmio.md:72
#: src/bare-metal/microcontrollers/pacs.md:65
#: src/bare-metal/microcontrollers/hals.md:49
#: src/bare-metal/microcontrollers/board-support.md:40
#: src/bare-metal/microcontrollers/type-state.md:43
#: src/bare-metal/microcontrollers/embedded-hal.md:23
#: src/bare-metal/microcontrollers/probe-rs.md:29
#: src/bare-metal/microcontrollers/debugging.md:38
#: src/bare-metal/microcontrollers/other-projects.md:26
#: src/exercises/bare-metal/morning.md:11 src/bare-metal/aps.md:15
#: src/bare-metal/aps/entry-point.md:101
#: src/bare-metal/aps/inline-assembly.md:58 src/bare-metal/aps/mmio.md:17
#: src/bare-metal/aps/uart/traits.md:27 src/bare-metal/aps/better-uart.md:28
#: src/bare-metal/aps/better-uart/bitflags.md:40
#: src/bare-metal/aps/better-uart/registers.md:46
#: src/bare-metal/aps/better-uart/driver.md:67
#: src/bare-metal/aps/better-uart/using.md:55 src/bare-metal/aps/logging.md:52
#: src/bare-metal/aps/logging/using.md:49 src/bare-metal/aps/exceptions.md:75
#: src/bare-metal/aps/other-projects.md:29
#: src/bare-metal/useful-crates/zerocopy.md:53
#: src/bare-metal/useful-crates/aarch64-paging.md:33
#: src/bare-metal/useful-crates/buddy_system_allocator.md:30
#: src/bare-metal/useful-crates/tinyvec.md:26
#: src/bare-metal/useful-crates/spin.md:30 src/bare-metal/android/vmbase.md:25
#: src/exercises/bare-metal/afternoon.md:11 src/concurrency/threads.md:45
#: src/concurrency/scoped-threads.md:40 src/concurrency/channels.md:32
#: src/concurrency/channels/bounded.md:35 src/concurrency/send-sync.md:23
#: src/concurrency/send-sync/send.md:16 src/concurrency/send-sync/sync.md:18
#: src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/mutex.md:45
#: src/concurrency/shared_state/example.md:56
#: src/exercises/concurrency/morning.md:16 src/async/async-await.md:48
#: src/async/futures.md:45 src/async/runtimes.md:29
#: src/async/runtimes/tokio.md:49 src/async/tasks.md:63
#: src/async/channels.md:49 src/async/control-flow/join.md:50
#: src/async/control-flow/select.md:79
#: src/async/pitfalls/blocking-executor.md:50 src/async/pitfalls/pin.md:112
#: src/async/pitfalls/async-traits.md:63 src/async/pitfalls/cancellation.md:114
#: src/exercises/concurrency/afternoon.md:17
#: src/exercises/concurrency/dining-philosophers-async.md:79
msgid "</details>"
msgstr "</details>"

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# Esecuzione del corso"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "> This page is for the course instructor."
msgstr "> Questa pagina è per l'istruttore del corso."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course\n"
"internally at Google."
msgstr ""
"Ecco alcune informazioni di base su come abbiamo condotto il corso\n"
"internamente a Google."

#: src/running-the-course.md:8
msgid "Before you run the course, you will want to:"
msgstr "Prima di eseguire il corso, vorrai:"

#: src/running-the-course.md:10
msgid ""
"1. Make yourself familiar with the course material. We've included speaker "
"notes\n"
"   to help highlight the key points (please help us by contributing more "
"speaker\n"
"   notes!). When presenting, you should make sure to open the speaker notes "
"in a\n"
"   popup (click the link with a little arrow next to \"Speaker Notes\"). "
"This way\n"
"   you have a clean screen to present to the class.\n"
"\n"
"1. Decide on the dates. Since the course takes at least three full days, we "
"recommend that you\n"
"   schedule the days over two weeks. Course participants have said that\n"
"   they find it helpful to have a gap in the course since it helps them "
"process\n"
"   all the information we give them.\n"
"\n"
"1. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-25 people. That's small enough that people are "
"comfortable\n"
"   asking questions --- it's also small enough that one instructor will "
"have\n"
"   time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the\n"
"   students: you will all need to be able to sit and work with your "
"laptops.\n"
"   In particular, you will be doing a lot of live-coding as an instructor, "
"so a lectern won't\n"
"   be very helpful for you.\n"
"\n"
"1. On the day of your course, show up to the room a little early to set "
"things\n"
"   up. We recommend presenting directly using `mdbook serve` running on "
"your\n"
"   laptop (see the [installation instructions][3]). This ensures optimal "
"performance with no lag as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them.\n"
"\n"
"1. Let people solve the exercises by themselves or in small groups.\n"
"   We typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions).\n"
"   Make sure to\n"
"   ask people if they're stuck or if there is anything you can help with. "
"When\n"
"   you see that several people have the same problem, call it out to the "
"class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"1. Acquisisci familiarità con il materiale del corso. Abbiamo incluso le "
"note del relatore\n"
"   per aiutare a evidenziare i punti chiave (per favore aiutateci "
"contribuendo con più relatori\n"
"   Appunti!). Durante la presentazione, assicurati di aprire le note del "
"relatore in formato a\n"
"   popup (fare clic sul collegamento con una piccola freccia accanto a "
"\"Note del relatore\"). Da questa parte\n"
"   hai uno schermo pulito da presentare alla classe.\n"
"\n"
"1. Seleziona il tuo argomento per il pomeriggio del quarto giorno. Questo "
"può essere basato su\n"
"   il pubblico che ti aspetti o sulla tua esperienza.\n"
"\n"
"1. Decidi le date. Poiché il corso è grande, ti consigliamo di farlo\n"
"   programmare i giorni su due settimane. Lo hanno detto i partecipanti al "
"corso\n"
"   trovano utile avere una pausa nel corso poiché li aiuta a elaborare\n"
"   tutte le informazioni che diamo loro.\n"
"\n"
"1. Trova una stanza abbastanza grande per i tuoi partecipanti di persona. "
"Consigliamo un\n"
"   dimensione della classe di 15-20 persone. È abbastanza piccolo da "
"permettere alle persone di sentirsi a proprio agio\n"
"   fare domande --- è anche abbastanza piccolo che un istruttore avrà\n"
"   tempo per rispondere alle domande. Assicurati che la stanza abbia "
"_scrivanie_ per te e per il\n"
"   studenti: dovrete essere tutti in grado di sedervi e lavorare con i "
"vostri laptop.\n"
"   In particolare, eseguirai molto codice dal vivo come istruttore, quindi "
"un leggio no\n"
"   essere molto utile per te.\n"
"\n"
"1. Il giorno del corso, presentati in aula un po' prima per sistemare le "
"cose\n"
"   su. Ti consigliamo di presentare direttamente utilizzando `mdbook serve` "
"in esecuzione sul tuo\n"
"   laptop (vedere le [istruzioni di installazione][3]). Ciò garantisce "
"prestazioni ottimali senza ritardi quando si cambiano le pagine.\n"
"   L'uso del tuo laptop ti consentirà anche di correggere errori di "
"battitura come te o il corso\n"
"   i partecipanti li individuano.\n"
"\n"
"1. Lascia che le persone risolvano gli esercizi da sole o in piccoli gruppi. "
"Assicurati che\n"
"   chiedi alle persone se sono bloccate o se c'è qualcosa in cui puoi "
"aiutarle. Quando\n"
"   vedi che diverse persone hanno lo stesso problema, segnalalo alla classe\n"
"   e offrire una soluzione, ad esempio mostrando alle persone dove trovare "
"le informazioni pertinenti\n"
"   informazioni nella libreria standard."

#: src/running-the-course.md:43
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for\n"
"you as it has been for us!"
msgstr ""
"Questo è tutto, buona fortuna con il corso! Speriamo che sarà altrettanto "
"divertente per\n"
"te come lo è stato per noi!"

#: src/running-the-course.md:46
msgid ""
"Please [provide feedback][1] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][2]!"
msgstr ""
"Si prega di [fornire feedback][1] in seguito in modo che possiamo continuare "
"a migliorare il\n"
"corso. Ci piacerebbe sapere cosa ha funzionato bene per te e cosa si può "
"fare\n"
"Meglio. Anche i tuoi studenti sono i benvenuti a [inviarci feedback][2]!"

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# Struttura del corso"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "Il corso è veloce e copre un sacco di terreno:"

#: src/running-the-course/course-structure.md:7
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust."
msgstr ""
"* Giorno 1: Rust base, 'ownership' e 'borrow checker'.\n"
"* Giorno 2: tipi di dati composti, pattern matching, libreria standard.\n"
"* Giorno 3: 'traits' e 'generics', gestione degli errori, test, Rust non sicuro."

#: src/running-the-course/course-structure.md:11
msgid "## Deep Dives"
msgstr "## Immersioni profonde"

#: src/running-the-course/course-structure.md:13
msgid ""
"In addition to the 3-day class on Rust Fundamentals, we cover some more\n"
"specialized topics:"
msgstr ""
"Oltre alla lezione di 3 giorni sui fondamenti di Rust, ne copriamo "
"altri\n"
"argomenti specialistici:"

#: src/running-the-course/course-structure.md:16
msgid "### Android"
msgstr "### Android"

#: src/running-the-course/course-structure.md:18
msgid ""
"The [Android Deep Dive](../android.md) is a half-day course on using Rust "
"for\n"
"Android platform development. This includes interoperability with C, C++, "
"and\n"
"Java."
msgstr ""
"L'[Android Deep Dive](../android.md) è un corso di mezza giornata "
"sull'utilizzo di Rust per\n"
"Sviluppo sulla piattaforma Android. Ciò include l'interoperabilità con C, C+"
"+ e\n"
"Java."

#: src/running-the-course/course-structure.md:22
msgid ""
"You will need an [AOSP checkout][1]. Make a checkout of the [course\n"
"repository][2] on the same machine and move the `src/android/` directory "
"into\n"
"the root of your AOSP checkout. This will ensure that the Android build "
"system\n"
"sees the `Android.bp` files in `src/android/`."
msgstr ""
"Avrai bisogno di un [checkout AOSP][1]. Fai un checkout del [corso\n"
"repository][2] sulla stessa macchina e sposta la directory `src/android/` "
"in\n"
"la radice del tuo checkout AOSP. Ciò garantirà che il sistema di "
"compilazione Android\n"
"vede i file `Android.bp` in `src/android/`."

#: src/running-the-course/course-structure.md:27
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all\n"
"Android examples using `src/android/build_all.sh`. Read the script to see "
"the\n"
"commands it runs and make sure they work when you run them by hand."
msgstr ""
"Assicurati che `adb sync` funzioni con il tuo emulatore o dispositivo reale "
"e precompila tutti\n"
"gli esempi di Android che utilizzano `src/android/build_all.sh`. Leggi lo script "
"per vedere i\n"
"comandi che esegue e assicurati che funzionino quando li esegui a mano."

#: src/running-the-course/course-structure.md:34
msgid "### Bare-Metal"
msgstr "### Bare-Metal"

#: src/running-the-course/course-structure.md:36
msgid ""
"The [Bare-Metal Deep Dive](../bare-metal.md): a full day class on using Rust "
"for\n"
"bare-metal (embedded) development. Both microcontrollers and application\n"
"processors are covered."
msgstr ""
"Il [Bare-Metal Deep Dive](../bare-metal.md): una lezione di un'intera "
"giornata sull'uso di Rust per\n"
"sviluppo bare metal (embedded). Sono coperti sia i microcontrollori che "
"i processori applicativi."

#: src/running-the-course/course-structure.md:40
msgid ""
"For the microcontroller part, you will need to buy the [BBC\n"
"micro:bit](https://microbit.org/) v2 development board ahead of time. "
"Everybody\n"
"will need to install a number of packages as described on the [welcome\n"
"page](../bare-metal.md)."
msgstr ""
"Per la parte del microcontrollore, dovrai acquistare la scheda di sviluppo [BBC "
"micro:bit v2](https://microbit.org/) in anticipo.\n"
"Si dovranno installare un certo numero di pacchetti come descritto nel file "
"[welcome\n"
"page](../bare-metal.md)."

#: src/running-the-course/course-structure.md:45
msgid "### Concurrency"
msgstr "### Concorrenza"

#: src/running-the-course/course-structure.md:47
msgid ""
"The [Concurrency Deep Dive](../concurrency.md) is a full day class on "
"classical\n"
"as well as `async`/`await` concurrency."
msgstr ""
"L'[approfondimento sulla concorrenza](../concurrency.md) è un corso di un'intera "
"giornata sulla concorrenza classica in Rust,\n"
"così come la concorrenza `async`/`await`."

#: src/running-the-course/course-structure.md:50
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to\n"
"go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with\n"
"them:"
msgstr ""
"Avrai bisogno di creare un nuovo progetto, con nuove dipendenze "
"scaricate e pronte per\n"
"l'utilizzo. Puoi quindi copiare/incollare gli esempi in `src/main.rs` per "
"sperimentare attraverso di\n"
"loro:"

#: src/running-the-course/course-structure.md:54
msgid ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio --features full\n"
"cargo run\n"
"```"
msgstr ""

#: src/running-the-course/course-structure.md:61
msgid "## Format"
msgstr "## Formato"

#: src/running-the-course/course-structure.md:63
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr ""
"Il corso è pensato per essere molto interattivo e si consiglia di lasciare\n"
"che siano le domande a guidare l'esplorazione di Rust!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# Tasti rapidi"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Ci sono diverse utili scorciatoie da tastiera in mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Freccia-sinistra</kbd>: passa alla pagina precedente.\n"
"* <kbd>Freccia-destra</kbd>: passa alla pagina successiva.\n"
"* <kbd>Ctrl + Invio</kbd>: esegue l'esempio di codice attivo.\n"
"* <kbd>s</kbd>: attiva la barra di ricerca."

#: src/running-the-course/translations.md:1
msgid "# Translations"
msgstr "# Traduzioni"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful\n"
"volunteers:"
msgstr ""
"Il corso è stato tradotto in altre lingue da una serie di meravigliosi\n"
"volontari:"

#: src/running-the-course/translations.md:6
msgid ""
"* [Brazilian Portuguese][pt-BR] by [@rastringer] and [@hugojacob].\n"
"* [Korean][ko] by [@keispace], [@jiyongp] and [@jooyunghan]."
msgstr ""
"* [Portoghese brasiliano][pt-BR] di [@rastringer] e [@hugojacob].\n"
"* [Coreano][ko] di [@keispace], [@jiyongp] e [@jooyunghan]."

#: src/running-the-course/translations.md:9
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"Usa il selettore di lingua nell'angolo in alto a destra per passare da una "
"lingua all'altra."

#: src/running-the-course/translations.md:11
msgid "## Incomplete Translations"
msgstr "# Traduzioni"

#: src/running-the-course/translations.md:13
msgid ""
"There is a large number of in-progress translations. We link to the most\n"
"recently updated translations:"
msgstr ""

#: src/running-the-course/translations.md:16
msgid ""
"* [Bengali][bn] by [@raselmandol].\n"
"* [French][fr] by [@KookaS] and [@vcaen].\n"
"* [German][de] by [@Throvn] and [@ronaldfw].\n"
"* [Japanese][ja] by [@CoinEZ-JPN] and [@momotaro1105]."
msgstr ""

#: src/running-the-course/translations.md:21
msgid ""
"If you want to help with this effort, please see [our instructions] for how "
"to\n"
"get going. Translations are coordinated on the [issue tracker]."
msgstr ""
"Se vuoi aiutare con questo sforzo, consulta [le nostre istruzioni] per "
"sapere come farlo\n"
"andare avanti. Le traduzioni sono coordinate su [issue tracker]."

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# Utilizzo di Cargo"

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want "
"to\n"
"give a brief overview of what Cargo is and how it fits into the wider "
"ecosystem\n"
"and how it fits into this training."
msgstr ""
"Quando inizi a leggere su Rust, incontrerai presto [Cargo](https://doc.rust-"
"lang.org/cargo/), lo strumento standard\n"
"utilizzato nell'ecosistema Rust per creare ed eseguire applicazioni Rust. "
"Qui vogliamo\n"
"fornire una breve panoramica di cos'è Cargo e di come si inserisce "
"nell'ecosistema\n"
"e in questa formazione."

#: src/cargo.md:8
msgid "## Installation"
msgstr "## Installazione"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "### Rustup (consigliato)"

#: src/cargo.md:12
msgid ""
"You can follow the instructions to install cargo and rust compiler, among "
"other standard ecosystem tools with the [rustup][3] tool, which is "
"maintained by the Rust Foundation."
msgstr ""
"Puoi seguire le istruzioni per installare il compilatore rust e cargo, tra "
"gli altri strumenti standard dell'ecosistema con lo strumento [rustup][3], "
"gestito dalla Rust Foundation."

#: src/cargo.md:14
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line "
"utility that you can use to install/switch toolchains, setup cross "
"compilation, etc."
msgstr ""
"Insieme a cargo e rustc, Rustup si installerà come un'utilità della riga di "
"comando che puoi utilizzare per installare/cambiare 'toolchain', configurare "
"la compilazione trasversale, ecc."

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### Gestori di pacchetti"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
msgid ""
"On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust "
"formatter][6] with"
msgstr ""
"Su Debian/Ubuntu, puoi installare Cargo, i sorgenti di Rust e [Rust "
"formatter][6] con"

#: src/cargo.md:22
msgid ""
"```shell\n"
"sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest "
"using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"Ciò consentirà a [rust-analyzer][1] di identificare le definizioni. Si "
"consiglia di utilizzare\n"
"[VS Code][2] per editare il codice sorgente (ma qualsiasi editor compatibile con "
"LSP funziona)."

#: src/cargo.md:29
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do "
"their own analysis but have their own tradeoffs. If you prefer them, you can "
"install the [Rust Plugin][5]. Please take note that as of January 2023 "
"debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"Ad alcune persone piace anche usare la famiglia di IDE [JetBrains][4], che "
"eseguono le proprie analisi ma hanno i propri compromessi. Se li preferisci, "
"puoi installare il [Rust Plugin][5]. Tieni presente che a partire da gennaio "
"2023 il debug funziona solo sulla versione CLion della suite JetBrains IDEA."

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# L'ecosistema di Rust"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"L'ecosistema Rust è costituito da una serie di strumenti, di cui i "
"principali sono:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and "
"other\n"
"  intermediate formats.\n"
"\n"
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them "
"to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests.\n"
"\n"
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is "
"released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and "
"`rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustc`: il compilatore Rust che trasforma i file `.rs` in binari e altri\n"
"  formati intermedi.\n"
"\n"
"* `cargo`: il gestore delle dipendenze di Rust e lo strumento di "
"compilazione. Cargo sa come\n"
"  scaricare le dipendenze ospitate su <https://crates.io> e le passerà a\n"
"  `rustc` quando costruisci il tuo progetto. Cargo include anche un"
" gestore di test integrato\n"
"  che viene utilizzato per eseguire i test predisposti per il progetto (_unit tests_).\n"
"\n"
"* `rustup`: il programma di installazione e aggiornamento della toolchain di "
"Rust. Questo strumento è utilizzato per\n"
"  installare e aggiornare `rustc` e `cargo` quando vengono rilasciate nuove "
"versioni di Rust.\n"
"  Inoltre, `rustup` può anche scaricare la documentazione per la libreria\n"
"  standard. Puoi avere più versioni di Rust installate contemporaneamente "
"e `rustup`\n"
"  ti permetterà di passare da una all'altra secondo le necessità."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/basic-syntax/references.md:23
#: src/pattern-matching/destructuring-enums.md:35
#: src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30 src/async/async-await.md:25
msgid "Key points:"
msgstr "Punti chiave:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality.\n"
"\n"
"* There are three release channels: \"stable\", \"beta\", and \"nightly\".\n"
"\n"
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks.\n"
"\n"
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018.\n"
"\n"
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language.\n"
"\n"
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file.\n"
"\n"
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions.\n"
"\n"
"  * Mention that it is quite rare to ever use the compiler directly not "
"through `cargo` (most users never do).\n"
"\n"
"  * It might be worth alluding that Cargo itself is an extremely powerful "
"and comprehensive tool.  It is capable of many advanced features including "
"but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as "
"[cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"* Rust ha un programma di rilascio rapido con una nuova versione in uscita\n"
"  ogni sei settimane. Le nuove versioni mantengono la retrocompatibilità "
"con\n"
"  vecchie versioni --- in più abilitano nuove funzionalità.\n"
"\n"
"* Esistono tre canali di rilascio: \"stable\", \"beta\" e \"nightly\".\n"
"\n"
"* Le nuove funzionalità vengono testate su \"nightly\", \"beta\" è ciò che "
"diventa\n"
"  \"stabile\" ogni sei settimane.\n"
"\n"
"* Rust ha anche le [edizioni]: l'edizione attuale è Rust 2021. Le precedenti\n"
"  edizioni erano Rust 2015 e Rust 2018.\n"
"\n"
"  * Le edizioni possono apportare modifiche incompatibili con le versioni "
"precedenti del linguaggio.\n"
"\n"
"  * Per evitare incompatibilità del codice, le edizioni sono opt-in: si può selezionare "
"l'edizione di riferimento'\n"
"  attraverso il file `Cargo.toml`.\n"
"\n"
"  * Per evitare di dividere l'ecosistema, i compilatori di Rust possono "
"mescolare il codice\n"
"    scritto per diverse edizioni.\n"
"\n"
"  * Nota che è abbastanza raro usare il compilatore direttamente non "
"attraverso `cargo` (la maggior parte degli utenti non lo fa mai).\n"
"\n"
"  * Potrebbe valere la pena accennare al fatto che Cargo stesso è uno "
"strumento estremamente potente e completo. È in grado di offrire molte "
"funzionalità avanzate, tra cui, a titolo esemplificativo ma non esaustivo:\n"
"      * Struttura del progetto/pacchetto\n"
"      * [aree di lavoro]\n"
"      * Dipendenze di sviluppo e gestione/memorizzazione nella cache delle "
"dipendenze di runtime\n"
"      * [costruzione script]\n"
"      * [installazione globale]\n"
"      * È anche estensibile con plug-in di comandi secondari (come "
"[cargo clippy]).\n"
"  * Leggi di più dall'[official Cargo Book]"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# Esempi di codice in questo Corso"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through "
"examples\n"
"which can be executed through your browser. This makes the setup much easier "
"and\n"
"ensures a consistent experience for everyone."
msgstr ""
"Per questa formazione, esploreremo principalmente il linguaggio Rust "
"attraverso esempi\n"
"che possono essere eseguiti tramite il tuo browser. Questo rende la "
"configurazione molto più semplice e\n"
"garantisce un'esperienza coerente per tutti."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the\n"
"exercises. On the last day, we will do a larger exercise which shows you how "
"to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"L'installazione di Cargo è ancora incoraggiata: ti renderà più facile fare "
"gli\n"
"esercizi. L'ultimo giorno faremo un esercizio più ampio che ti mostrerà come "
"lavorare\n"
"con le dipendenze e per questo hai bisogno di Cargo."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "I blocchi di codice in questo corso sono completamente interattivi:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""

#: src/cargo/code-samples.md:19
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in "
"the\n"
"text box."
msgstr ""
"Puoi usare <kbd>Ctrl + Invio</kbd> per eseguire il codice quando il focus è "
"sulla\n"
"casella di testo."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr ""
"La maggior parte degli esempi di codice sono modificabili come mostrato "
"sopra. Alcuni esempi di codice\n"
"non sono modificabili per vari motivi:"

#: src/cargo/code-samples.md:27
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests.\n"
"\n"
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* I playground incorporati non possono eseguire unit test. Copia e incolla "
"il codice\n"
"  e aprilo nel Playground reale per dimostrare le 'unit test'.\n"
"\n"
"* I playground incorporati perdono il loro stato nel momento in cui esci\n"
"  dalla pagina! Questo è il motivo per cui gli studenti dovrebbero\n"
"  risolvere gli esercizi utilizzando un'installazione locale di Rust o "
"tramite Playground."

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# Esecuzione del codice in locale con Cargo"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time "
"of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"Se vuoi sperimentare il codice sul tuo sistema, avrai bisogno di\n"
"per installare prima di tutto Rust. Fallo seguendo le [istruzioni nel 'Rust\n"
"Book][1]. Questo dovrebbe darti un `rustc` e un `cargo` funzionanti. Al "
"monento della scrittura,\n"
" l'ultima versione stabile di Rust ha questi numeri di versione:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.69.0 (84c898d65 2023-04-16)\n"
"% cargo --version\n"
"cargo 1.69.0 (6e9a83356 2023-04-12)\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:15
msgid ""
"With this in place, follow these steps to build a Rust binary from one\n"
"of the examples in this training:"
msgstr ""
"Con questo è a posto, segui questi passaggi per creare un 'binario Rust' da "
"uno\n"
"degli esempi in questo training:"

#: src/cargo/running-locally.md:18
msgid ""
"1. Click the \"Copy to clipboard\" button on the example you want to copy.\n"
"\n"
"2. Use `cargo new exercise` to create a new `exercise/` directory for your "
"code:\n"
"\n"
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```\n"
"\n"
"3. Navigate into `exercise/` and use `cargo run` to build and run your "
"binary:\n"
"\n"
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```\n"
"\n"
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look "
"like\n"
"\n"
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```\n"
"\n"
"5. Use `cargo run` to build and run your updated binary:\n"
"\n"
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```\n"
"\n"
"6. Use `cargo check` to quickly check your project for errors, use `cargo "
"build`\n"
"   to compile it without running it. You will find the output in `target/"
"debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an "
"optimized\n"
"   release build in `target/release/`.\n"
"\n"
"7. You can add dependencies for your project by editing `Cargo.toml`. When "
"you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""
"1. Click sul bottone \"Copy to clipboard\" nell'esempio che si vuole copiare'.\n"
"\n"
"2. Usa `cargo new exercise` per creare una nuova directory `exercise/` per il tuo "
"codice:\n"
"\n"
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```\n"
"\n"
"3. Naviga in `exercise/` e usa `cargo run` per compilare ed eseguire "
"l'esercizio:\n"
"\n"
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```\n"
"\n"
"4. Sostituisci il codice predefinito in `src/main.rs` con il tuo codice. Per\n"
"   esempio, usando l'esempio della pagina precedente, cambia `src/main.rs` in\n"
"\n"
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```\n"
"\n"
"5. Usa `cargo run` per compilare ed eseguire il codice aggiornato:\n"
"\n"
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```\n"
"\n"
"6. Usa `cargo check` per controllare rapidamente gli errori nel tuo progetto, usa `cargo "
"build`\n"
"   per compilare senza eseguire. Per una compilazione normale di debug l'output si trova in `target/"
"debug/`.\n"
" Usa `cargo build --release` per produrre una versione ottimizzata del codice, in questo caso l'output si trova in `target/release/`.\n"
"\n"
"7. Puoi aggiungere dipendenze al tuo progetto modificando il file `Cargo.toml`. Quando "
"si\n"
"   esegue il comando `cargo`, sono automaticamente scaricate e compilate le dipendenze mancanti."

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"Cerca di incoraggiare i partecipanti alla classe a installare Cargo e "
"utilizzare un\n"
"editore locale. Semplificherà la loro vita poiché avranno un\n"
"ambiente di sviluppo normale."

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# Benvenuto al primo giorno"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr ""
"Questo è il primo giorno di 'Comprehensive Rust'.\n"
"Oggi copriremo un sacco di strada:"

#: src/welcome-day-1.md:6
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods.\n"
"\n"
"* Memory management: stack vs heap, manual memory management, scope-based "
"memory\n"
"  management, and garbage collection.\n"
"\n"
"* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""
"* Sintassi di base di Rust: variabili, tipi scalari e composti, enum, "
"struct,\n"
"  riferimenti, funzioni e metodi.\n"
"\n"
"* Gestione della memoria: stack vs heap, gestione manuale della memoria, "
"memoria basata sull'ambito (scoped),\n"
" garbage collection.\n"
"\n"
"* Ownership: semantica di spostamento (move), copia e clonazione, prestito (borrowing) e durata (lifetimes)."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "Si prega di ricordare agli studenti che:"

#: src/welcome-day-1.md:18
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much "
"encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, i."
"e.,\n"
"    keep the discussions related to how Rust does things vs some other "
"language. \n"
"    It can be hard to find the right balance, but err on the side of "
"allowing \n"
"    discussions since they engage people much more than one-way "
"communication.\n"
"* The questions will likely mean that we talk about things ahead of the "
"slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. "
"Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* Dovrebbero fare domande quando ne sentono il bisogno, non trattenerle fino alla fine.\n"
"* La lezione è pensata per essere interattiva e le discussioni sono molto "
"incoraggiate!\n"
"  * In qualità di istruttore, dovresti cercare di mantenere le discussioni "
"pertinenti, ad es.\n"
"    mantieni la relazione con il modo in cui Rust fa le cose rispetto a "
"qualche altro linguaggio. Può essere\n"
"    difficile trovare il giusto equilibrio, ma è meglio permettere "
"discussioni che\n"
"    coinvolgono le persone piuttosto che una comunicazione "
"unidirezionale.\n"
"* Le domande probabilmente significheranno che parleremo di cose prima delle "
"diapositive.\n"
"  * Questo è perfettamente okay! La ripetizione è una parte importante "
"dell'apprendimento. Ricordare\n"
"    che le diapositive sono solo un supporto e sei libero di saltarle come "
"preferisci."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak\n"
"about the famous borrow checker. The way Rust handles memory is a major "
"feature\n"
"and we should show students this right away."
msgstr ""
"L'idea per il primo giorno è mostrare _quanto basta_ di Rust per poter "
"parlare\n"
"sul famoso _borrow checker_. Il modo in cui Rust gestisce la memoria è "
"una caratteristica importante\n"
"e dovremmo mostrarlo subito agli studenti."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Se stai insegnando in un'aula, questo è un buon posto per esaminare "
"il\n"
"programma. Suggeriamo di dividere la giornata in due parti (seguendo le "
"slide):"

#: src/welcome-day-1.md:36
msgid ""
"* Morning: 9:00 to 12:00,\n"
"* Afternoon: 13:00 to 16:00."
msgstr ""
"* Mattina: dalle 9:00 alle 12:00,\n"
"* Pomeriggio: dalle 13:00 alle 16:00."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks,\n"
"we recommend a break every hour!"
msgstr ""
"Ovviamente puoi regolarlo se necessario. Assicurati di includere pause,\n"
"consigliamo una pausa ogni ora!"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# Cos'è Rust?"

#: src/welcome-day-1/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr ""
"Rust è un nuovo linguaggio di programmazione che ha avuto la sua "
"[versione 1.0 nel 2015][1]:"

#: src/welcome-day-1/what-is-rust.md:5
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  architectures](https://doc.rust-lang.org/nightly/rustc/platform-support."
"html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust è un linguaggio compilato staticamente in modo simile a C++\n"
"  * `rustc` utilizza LLVM come backend.\n"
"* Rust supporta molte [piattaforme e\n"
"  architetture](https://doc.rust-lang.org/nightly/rustc/platform-support."
"html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust è utilizzato per un'ampia gamma di dispositivi:\n"
"  * firmware e _boot loaders_,\n"
"  * display 'smart',\n"
"  * cellulari,\n"
"  * desktop,\n"
"  * server."

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust è usato nelle stesse aree di C++:"

#: src/welcome-day-1/what-is-rust.md:23
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* Elevata flessibilità.\n"
"* Alto livello di controllo.\n"
"* Può essere adattato a dispositivi molto particolari come i telefoni "
"cellulari.\n"
"* Non ha runtime o garbage collection.\n"
"* Si concentra su affidabilità e sicurezza senza sacrificare le prestazioni."

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# Ciao mondo!"

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr ""
"Passiamo al programma Rust più semplice possibile,\n"
"un classico Hello World:"

#: src/hello-world.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hello 🌍!\");\n"
"}\n"
"```"
msgstr ""

#: src/hello-world.md:12
msgid "What you see:"
msgstr "Quello che si vede:"

#: src/hello-world.md:14
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* Le funzioni sono introdotte con `fn`.\n"
"* I blocchi sono delimitati da parentesi graffe come in C e C++.\n"
"* La funzione `main` è il punto di ingresso del programma.\n"
"* Rust ha macro definite come 'igieniche' (_hygienic macros_), `println!` ne è un esempio.\n"
"* Le stringhe Rust sono codificate in UTF-8 e possono contenere qualsiasi "
"carattere Unicode."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see\n"
"a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"Questa diapositiva cerca di mettere gli studenti a proprio agio con il "
"codice Rust. Vedranno\n"
"un sacco di Rust nei prossimi quattro giorni, quindi iniziamo in piccolo con "
"qualcosa di familiare."

#: src/hello-world.md:27
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary.\n"
"\n"
"* Rust is modern with full support for things like Unicode.\n"
"\n"
"* Rust uses macros for situations where you want to have a variable number "
"of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude."
"md)).\n"
"\n"
"* Macros being 'hygienic' means they don't accidentally capture identifiers "
"from\n"
"  the scope they are used in. Rust macros are actually only\n"
"  [partially hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/"
"hygiene.html)."
msgstr ""
"* Rust è molto simile ad altri linguaggi della tradizione C/C++/Java. È\n"
"  imperativo (non funzionale) e non cerca di reinventare le cose a meno che\n"
"  non sia assolutamente necessario.\n"
"\n"
"* Rust è moderno con pieno supporto per cose come Unicode.\n"
"\n"
"* Rust utilizza le macro per le situazioni in cui si desidera avere un "
"numero variabile di\n"
"  argomenti (nessun [overloading di funzione](basic-syntax/functions-"
"interlude.md)).\n"
"\n"
"* Le macro definite \"igieniche\" significa che non catturano accidentalmente "
"identificatori da\n"
"  l'ambito in cui vengono utilizzate. Le macro di Rust sono in realtà solo\n"
"  [parzialmente igieniche](https://veykril.github.io/tlborm/decl-macros/"
"minutiae/hygiene.html)."

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# Piccolo esempio"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "Ecco un piccolo programma di esempio in Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will\n"
"always end, but this is not yet proved. Edit the code and play with "
"different\n"
"inputs."
msgstr ""
"Il codice implementa la congettura di Collatz: si ritiene che il ciclo\n"
"finirà sempre, ma questo non è ancora provato. Modifica il codice e gioca "
"con diversi\n"
"ingressi."

#: src/hello-world/small-example.md:29
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to "
"trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer "
"overflow.\n"
"\n"
"* Change `let mut x` to `let x`, discuss the compiler error.\n"
"\n"
"* Show how `print!` gives a compilation error if the arguments don't match "
"the\n"
"  format string.\n"
"\n"
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable.\n"
"\n"
"* Show the students the standard library, show them how to search for `std::"
"fmt`\n"
"  which has the rules of the formatting mini-language. It's important that "
"the\n"
"  students become familiar with searching in the standard library.\n"
"    \n"
"    * In a shell `rustup doc std::fmt` will open a browser on the local std::"
"fmt documentation"
msgstr ""
"* Spiegare che tutte le variabili sono tipizzate staticamente. Prova a "
"rimuovere `i32` per attivare\n"
"  l'inferenza di tipo. Prova invece con `i8` e attiva un overflow di runtime "
"integer.\n"
"\n"
"* Modificare `let mut x` in `let x`, discutere l'errore del compilatore.\n"
"\n"
"* Mostra come `print!` restituisce un errore di compilazione se gli "
"argomenti non corrispondono al\n"
"  formato della stringa.\n"
"\n"
"* Mostra come devi usare `{}` come segnaposto se vuoi stampare un'\n"
"  espressione che è più complessa di una singola variabile.\n"
"\n"
"* Mostra agli studenti la libreria standard, mostra loro come cercare `std::"
"fmt`\n"
"  che ha le regole del mini-linguaggio di formattazione. È importante che "
"il\n"
"  gli studenti acquisiscono familiarità con la ricerca nella libreria "
"standard."

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# Perché Rust?"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Alcuni punti di forza unici di Rust:"

#: src/why-rust.md:5
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* Sicurezza della memoria al tempo di compilazione.\n"
"* Mancanza di comportamento runtime non definito.\n"
"* Funzionalità del linguaggio moderno."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr ""
"Assicurati di chiedere alla classe con quali linguaggi hanno esperienza. "
"In base alla\n"
"risposta puoi evidenziare diverse caratteristiche di Rust:"

#: src/why-rust.md:14
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime "
"errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you "
"don't\n"
"  have the memory unsafety issues. In addition, you get a modern language "
"with\n"
"  constructs like pattern matching and built-in dependency management.\n"
"\n"
"* Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety\n"
"  as in those languages, plus a similar high-level language feeling. In "
"addition\n"
"  you get fast and predictable performance like C and C++ (no garbage "
"collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* Esperienza con C o C++: Rust elimina un'intera classe di _errori di "
"runtime_\n"
"  tramite il _borrow checker_. Ottiene prestazioni come in C e C++, ma "
"non\n"
"  hai i problemi di sicurezza della memoria. Inoltre, si ha un "
"linguaggio moderno con\n"
"  costrutti come il pattern matching e la gestione delle dipendenze "
"incorporata.\n"
"\n"
"* Esperienza con Java, Go, Python, JavaScript...: Ottiene la stessa "
"sicurezza della memoria\n"
"  come in quei linguaggi, più una sensazione simile ad un linguaggio di alto "
"livello. Inoltre\n"
"  raggiunge prestazioni veloci e prevedibili come C e C++ (nessun Garbage "
"Collector)\n"
"  così come l'accesso all'hardware di basso livello (quando serve)"

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# Garanzie a Tempo di Compilazione"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "Gestione statica della memoria in fase di compilazione:"

#: src/why-rust/compile-time.md:5
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* Nessuna variabile non inizializzata.\n"
"* Nessun _memory leaks_ (_principalmente_, vedi note).\n"
"* Nessun _double-frees_.\n"
"* Nessun _use-after-free_.\n"
"* Nessun puntatore `NULL`.\n"
"* Nessun mutex dimenticato bloccato.\n"
"* Nessuna 'situazione di corsa' (_race condition_) di dati tra i thread.\n"
"* Nessuna invalidazione dell'iteratore."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr ""
"È possibile produrre perdite di memoria in Rust sicuro (Safe Rust). Qualche esempio\n"
"Sono:"

#: src/why-rust/compile-time.md:19
msgid ""
"* You can use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* Puoi usare [`Box::leak`] per far trapelare un puntatore. Un uso di questo "
"potrebbe\n"
"  essere quello di ottenere variabili statiche inizializzate/dimensionate in runtime\n"
"* Puoi usare [`std::mem::forget`] per fare in modo che il compilatore "
"\"dimentichi\"\n"
"  un valore (il che significa che il distruttore non viene mai eseguito).\n"
"* Puoi anche creare accidentalmente un _[reference cycle]_ con `Rc` o\n"
"  `Arc`.\n"
"* In effetti, alcuni considereranno il popolamento infinito di una raccolta "
"un _memory leak_\n"
"  e Rust non protegge da quello."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr ""
"Ai fini di questo corso, si dovrebbe intendere \"Nessuna perdita di "
"memoria\".\n"
"come \"Praticamente nessuna perdita di memoria *accidentale*\"."

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# Garanzie di autonomia"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "Nessun comportamento indefinito in fase di esecuzione:"

#: src/why-rust/runtime.md:5
msgid ""
"* Array access is bounds checked.\n"
"* Integer overflow is defined (panic or wrap-around)."
msgstr ""
"* L'accesso agli array è controllato dai loro limiti.\n"
"* L'overflow di numeri interi è definito (panic or wrap-around)."

#: src/why-rust/runtime.md:12
msgid ""
"* Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
"lang.org/rustc/codegen-options/index.html#overflow-checks)\n"
"  compile-time flag. If enabled, the program will panic (a controlled\n"
"  crash of the program), otherwise you get wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`).\n"
"\n"
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* L'overflow di numeri interi è definito tramite il flag [`overflow-checks`](https://doc.rust-"
"lang.org/rustc/codegen-options/index.html#overflow-checks) in fase di "
"compilazione. Se abilitato il programma _va in panico_ (crash controllato del programma),\n"
"  altrimenti si ha un _wrap-around_.\n"
"  Per impostazione predefinita, si ottiene il panico in modalità di "
"debug (`cargo build`)\n"
"  e wrap-around in modalità rilascio (`cargo build --release`).\n"
"\n"
"* Il controllo dei limiti non può essere disabilitato con un flag del "
"compilatore. Può anche\n"
"  non essere disabilitato direttamente con la parola chiave `unsafe`. "
"Tuttavia,\n"
"  `unsafe` ti permette di chiamare funzioni come `slice::get_unchecked`\n"
"  che non esegue il controllo dei limiti."

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# Funzionalità moderne"

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr "Rust è costruito con tutta l'esperienza maturata negli ultimi 40 anni."

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## Caratteristiche del linguaggio"

#: src/why-rust/modern.md:7
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* Enumerazioni (_Enums_) e pattern matching.\n"
"* Generici (_generic_).\n"
"* Nessun _overhead_ FFI.\n"
"* Astrazioni a costo zero (_Zero-cost abstractions_)."

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## Tooling"

#: src/why-rust/modern.md:14
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* Ottimi errori del compilatore.\n"
"* Gestore delle dipendenze integrato.\n"
"* Supporto integrato per i test.\n"
"* Eccellente supporto del protocollo Language Server."

#: src/why-rust/modern.md:23
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to "
"'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct.\n"
"\n"
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
"also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`.\n"
"\n"
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with "
"_actionable_\n"
"  feedback, ready to copy-paste into your code.\n"
"\n"
"* The Rust standard library is small compared to languages like Java, "
"Python,\n"
"  and Go. Rust does not come with several things you might consider standard "
"and\n"
"  essential:\n"
"\n"
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json].\n"
"\n"
"  The reasoning behind this is that functionality in the standard library "
"cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps "
"there\n"
"  isn't a single \"best solution\" for some of these things.\n"
"\n"
"  Rust comes with a built-in package manager in the form of Cargo and this "
"makes\n"
"  it trivial to download and compile third-party crates. A consequence of "
"this\n"
"  is that the standard library can be smaller.\n"
"\n"
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics "
"for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"* Astrazioni a costo zero, simili a C++, significa che non devi \"pagare\"\n"
"  per costrutti di programmazione di livello superiore con memoria o CPU. "
"Per esempio,\n"
"  scrivere un ciclo usando `for` dovrebbe comportare all'incirca lo stesso "
"livello di\n"
"  istruzioni come usare il costrutto `.iter().fold()`.\n"
"\n"
"* Potrebbe valere la pena ricordare che anche le enum di Rust sono \"tipi di "
"dati algebrici\"\n"
"  noti come \"tipi di somma\", che consentono al sistema di tipi di "
"esprimere cose come\n"
"  `Option<T>` e `Result<T, E>`.\n"
"\n"
"* Ricordare alle persone di leggere gli errori --- molti sviluppatori si "
"sono abituati a\n"
"  ignorare l'output del compilatore. Il compilatore Rust è molto "
"più\n"
"  \"loquace\" rispetto ad altri compilatori. Spesso fornirà feedback\n"
"  _pronti all'uso_, pronti per il copia-incolla nel tuo codice.\n"
"\n"
"* La libreria standard di Rust è piccola rispetto a linguaggi come Java, "
"Python,\n"
"  e Go. Rust non viene fornito con molte cose che potresti considerare "
"standard e\n"
"  essenziali:\n"
"\n"
"  * un generatore di numeri casuali, ma vedi [rand].\n"
"  * supporto per SSL o TLS, ma vedi [rusttls].\n"
"  * supporto per JSON, ma vedi [serde_json].\n"
"\n"
"  Il ragionamento alla base di ciò è che una funzionalità nella libreria "
"standard non può\n"
"  essere tolta, quindi deve essere molto stabile. Per gli esempi precedenti, "
"la comunità Rust\n"
"  sta ancora lavorando per trovare la soluzione migliore --- e "
"forse \n"
"  non c'è un'unica \"soluzione migliore\" per alcune di queste cose.\n"
"\n"
"  Rust viene fornito con un gestore di pacchetti integrato sotto forma di "
"Cargo e questo rende\n"
"  banale scaricare e compilare pacchetti di terze parti (_crates_). Una conseguenza di "
"ciò\n"
"  è che la libreria standard può essere più piccola.\n"
"\n"
"  La ricerca di buoni 'pacchetti' (_crates_) di terze parti può essere un problema. Siti "
"come\n"
"  <https://lib.rs/> aiutano in questo consentendo di confrontare le metriche "
"per specifiche\n"
"  _crate_ per trovarne uno buona e affidabile.\n"
"  \n"
"* [rust-analyzer] è un'implementazione LSP ben supportata utilizzata nei"
"maggiori\n"
"  IDE ed editor di testo."

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# Sintassi di base"

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Gran parte della sintassi di Rust ti sarà familiare da C, C++ o Java:"

#: src/basic-syntax.md:5
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/"
"* ...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* I blocchi e gli ambiti sono delimitati da parentesi graffe.\n"
"* I commenti di riga iniziano con `//`, i commenti di blocco sono delimitati "
"da `/* ...\n"
"  */'.\n"
"* Parole chiave come `if` e `while` funzionano allo stesso modo.\n"
"* L'assegnazione delle variabili viene eseguita con `=`, il confronto viene "
"eseguito con `==`."

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# Tipi scalari"

#: src/basic-syntax/scalar-types.md:3
msgid ""
"|                        | Types                                      | "
"Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | "
"`-10`, `0`, `1_000`, `123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, "
"`123`, `10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | "
"`3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                | `&str`                                     | "
"`\"foo\"`, `\"two\\nlines\"`       |\n"
"| Unicode scalar values  | `char`                                     | "
"`'a'`, `'α'`, `'∞'`           |\n"
"| Booleans               | `bool`                                     | "
"`true`, `false`               |"
msgstr ""
"| | Tipi | Letterali |\n"
"|------------------------|------------------------ "
"---------------------|---------------------------- --|\n"
"| Interi con segno | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, "
"`0`, `1_000`, `123i64` |\n"
"| Interi senza segno | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, "
"`123`, `10u16` |\n"
"| Numeri in virgola mobile | `f32`, `f64` | `3.14`, `-10.0e20`, `2f32` |\n"
"| Corde | `&str` | `\"pippo\"`, `\"due\\nrighe\"` |\n"
"| Valori scalari Unicode | `char` | `'a'`, `'α'`, `'∞'` |\n"
"| Booleani | `bool` | `vero`, `falso` |"

#: src/basic-syntax/scalar-types.md:12
msgid "The types have widths as follows:"
msgstr "I tipi hanno larghezze come segue:"

#: src/basic-syntax/scalar-types.md:14
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bits wide,\n"
"* `bool` is 8 bits wide."
msgstr ""
"* `iN`, `uN` e `fN` sono larghi _N_ bit,\n"
"* `isize` e `usize` sono la larghezza di un puntatore,\n"
"* `char` è largo 32 bit,\n"
"* `bool` è largo 8 bit."

#: src/basic-syntax/scalar-types.md:21
msgid "There are a few syntaxes which are not shown above:"
msgstr "Ci sono alcune sintassi che non sono mostrate sopra:"

#: src/basic-syntax/scalar-types.md:23
msgid ""
"- Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\"\n"
"  == \"\\\\\\\\n\"`. You can embed double-quotes by using an equal amount of "
"`#` on\n"
"  either side of the quotes:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"      println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"  }\n"
"  ```\n"
"\n"
"- Byte strings allow you to create a `&[u8]` value directly:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(\"{:?}\", b\"abc\");\n"
"      println!(\"{:?}\", &[97, 98, 99]);\n"
"  }\n"
"  ```"
msgstr ""
"- Le stringhe non elaborate (_raw_) consentono di creare un valore `&str` con i caratteri"
" di escape disabilitati: "
"`r\"\\n\"\n"
"  == \"\\\\\\\\n\"`. Puoi racchiudere le doppie virgolette usando una quantità uguale di "
"`#` su\n"
"  entrambi i lati delle virgolette:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"      println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"  }\n"
"  ```\n"
"\n"
"- Le stringhe di byte consentono di creare direttamente un valore `&[u8]`:\n"
"\n"
"  ```rust,editable\n"
"  fn main() {\n"
"      println!(\"{:?}\", b\"abc\");\n"
"      println!(\"{:?}\", &[97, 98, 99]);\n"
"  }\n"
"  ```"

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# Tipi Composti (Compound)"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          "
"|\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          "
"|\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... "
"|"
msgstr ""
"|        | Tipi                         | Letterali                          "
"|\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Array | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          "
"|\n"
"| Tuple | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... "
"|"

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "Assegnazione e accesso all’Array:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "Assegnazione e accesso alla Tupla:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "Array:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"* A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`.\n"
"  Note that the length of the array is *part of its type*, which means that "
"`[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types.\n"
"\n"
"* We can use literals to assign values to arrays.\n"
"\n"
"* In the main function, the print statement asks for the debug "
"implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after "
"the\n"
"  format string.\n"
"\n"
"* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can "
"be easier to read."
msgstr ""
"* Un valore di un array tipo `[T; N]` contiene `N` (una costante _compile-time_) "
"elementi dello stesso tipo `T`.\n"
"  Nota che la lunghezza dell'array è *parte del suo tipo*, il che significa che "
"`[u8; 3]` e\n"
"  `[u8; 4]` sono considerati due tipi diversi.\n"
"\n"
"* Si possono usare i letterali per assegnare i valori agli array.\n"
"\n"
"* Nalla funzione main, l'istruzione print richiede l'implementazione 'debug' "
"con il parametro `?`:\n"
"   `{}` da l'output predefinito (_default_), `{:?}` da l'output tipo debug. "
"Si sarebbe\n"
"  anche potuto usare `{a}` e `{a:?}` senza specificare il valore dopo la stringa formattata.\n"
"\n"
"* Aggiungendo `#`, eg `{a:#?}`, si invoca un formato \"pretty printing\", il quale può "
"essere più facile da leggere."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "Tuple:"

#: src/basic-syntax/compound-types.md:49
msgid ""
"* Like arrays, tuples have a fixed length.\n"
"\n"
"* Tuples group together values of different types into a compound type.\n"
"\n"
"* Fields of a tuple can be accessed by the period and the index of the "
"value, e.g. `t.0`, `t.1`.\n"
"\n"
"* The empty tuple `()` is also known as the \"unit type\". It is both a "
"type, and\n"
"  the only valid value of that type - that is to say both the type and its "
"value\n"
"  are expressed as `()`. It is used to indicate, for example, that a "
"function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* Come gli array, le tuple hanno una lunghezza fissa.\n"
"\n"
"* Le tuple raggruppano valori di tipi diversi in un tipo composto.\n"
"\n"
"* È possibile accedere ai campi di una tupla tramite il punto e l'indice del "
"valore, ad es. `t.0`, `t.1`.\n"
"\n"
"* La tupla vuota `()` è anche nota come \"tipo di unità\". È sia un tipo "
"che\n"
"  l'unico valore valido di quel tipo, vale a dire sia il tipo che il suo "
"valore\n"
"  sono espressi come `()`. Viene utilizzato per indicare, ad esempio, che "
"una funzione o\n"
"  espressione che non ha alcun valore di ritorno, come vedremo in una diapositiva "
"futura.\n"
"    * Puoi pensarlo come un \"vuoto\" che può esserti familiare da altri\n"
"      linguaggi di programmazione."

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# Riferimenti"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "Come C++, Rust ha riferimenti:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "Alcune note:"

#: src/basic-syntax/references.md:16
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values "
"over their lifetime."
msgstr ""
"* Dobbiamo dereferenziare `ref_x` quando lo assegni, in modo simile ai "
"puntatori C e C++.\n"
"* In alcuni casi Rust dereferenzia automaticamente, in particolare durante "
"l'invocazione\n"
"  di metodi (prova `ref_x.count_ones()`).\n"
"* I riferimenti dichiarati come `mut` possono essere associati a valori "
"diversi nel corso della loro durata."

#: src/basic-syntax/references.md:25
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let "
"ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound "
"to\n"
"  different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"* Assicurati di notare la differenza tra `let mut ref_x: &i32` e `let "
"ref_x:\n"
"  &mut i32`. Il primo rappresenta un riferimento mutevole a cui può essere "
"associato\n"
"  valori diversi, mentre il secondo rappresenta un riferimento a un valore "
"mutabile."

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# Riferimenti Penzolanti (Dangling References)"

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust proibirà staticamente i riferimenti penzolanti:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* Si dice che un riferimento \"prenda in prestito\" (_borrow_) il valore a cui si "
"riferisce.\n"
"* Rust tiene traccia delle vite di tutti i riferimenti per assicurarsi che "
"durino abbastanza a lungo.\n"
"* Parleremo di più del _borrowing_ quando arriveremo alla proprietà (_ownership_)."

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# Slices"

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "Una _slice_ ti offre una vista in una raccolta più ampia:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"\n"
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:15
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* Le sezioni prendono in prestito i dati dal tipo della raccolta.\n"
"* Domanda: Cosa succede se modifichi `a[3]`?"

#: src/basic-syntax/slices.md:20
msgid ""
"* We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets.\n"
"\n"
"* If the slice starts at index 0, Rust’s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical.\n"
"\n"
"* To easily create a slice of the full array, we can therefore use "
"`&a[..]`.\n"
"\n"
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to "
"remain 'alive' (in scope) for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, "
"but the answer is that for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read "
"the data from both `a` and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* Creiamo una sezione prendendo in prestito `a` e specificando gli indici "
"iniziale e finale tra parentesi.\n"
"\n"
"* Se la slice inizia all'indice 0, la sintassi dell'intervallo di Rust ci "
"consente di eliminare l'indice iniziale, il che significa che `&a[0..a."
"len()]` e `&a[..a.len()]` sono identici .\n"
"    \n"
"* Lo stesso vale per l'ultimo indice, quindi `&a[2..a.len()]` e `&a[2..]` "
"sono identici.\n"
"\n"
"* Per creare facilmente una porzione dell'array completo, possiamo quindi "
"utilizzare `&a[..]`.\n"
"\n"
"* `s` è un riferimento a una porzione di `i32`s. Si noti che il tipo di `s` "
"(`&[i32]`) non menziona più la lunghezza dell'array. Questo ci permette di "
"eseguire il calcolo su fette di diverse dimensioni.\n"
" \n"
"* Le fette prendono sempre in prestito da un altro oggetto. In questo "
"esempio, `a` deve rimanere 'vivo' (nello scope) almeno quanto la nostra "
"fetta.\n"
"    \n"
"* La domanda sulla modifica di `a[3]` può innescare una discussione "
"interessante, ma la risposta è che per motivi di sicurezza della memoria\n"
"  non puoi farlo tramite \"a\" dopo aver creato una sezione, ma puoi leggere "
"i dati sia da \"a\" che da \"s\" in modo sicuro.\n"
"  Maggiori dettagli saranno spiegati nella sezione controllo del prestito."

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String` vs `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "Ora possiamo comprendere i due tipi di stringhe in Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Terminologia di Rust:"

#: src/basic-syntax/string-slices.md:22
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` un riferimento immutabile a uno slice di stringa.\n"
"* `String` è un buffer di stringa mutabile."

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data \n"
"  stored in a block of memory. String literals (`”Hello”`), are stored in "
"the program’s binary.\n"
"\n"
"* Rust’s `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` \n"
"  creates a new empty string, to which string data can be added using the "
"`push()` and `push_str()` methods.\n"
"\n"
"* The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range "
"selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the "
"one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of `std::"
"string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never "
"use a small-string optimization).\n"
"    "
msgstr ""
"* `&str` introduce una _string slice_, che è un riferimento immutabile a una "
" stringa codificata UTF-8\n"
"  memorizzata in un blocco di memoria. Le Stringhe letterali (`”Hello”`), sono memorizzate "
"all'interno del programma binario.\n"
"\n"
"* Il tipo Rust `String` è costruito attorno a un vettore di bytes. Come con un "
"`Vec<T>`, possiede i dati.\n"
"    \n"
"* Come con molti altri tipi, `String::from()` crea una stringa da un "
"carattere letterale; `String::new()` \n"
"  crea una stringa vuota a cui è possibile aggiungere dati utilizzando i metodi "
"`push()` and `push_str()`.\n"
"\n"
"* La macro `format!()` è un modo conveniente per generare una "
"stringa da valori dinamici.\n"
"  Accetta la stessa specifica di formato di `println!()`.\n"
"    \n"
"* Puoi prendere in prestito le sezioni `&str` da `String` con `&` "
"e la selezione dell'intervallo opzionale.\n"
"    \n"
"* Per i programmatori C++: pensa a `&str` come a `const char*` da C++ "
"ma che punta sempre a una stringa valida in memoria. \n"
"  Rust `String` è approssimativamente equivalente a `std::string` da C++ \n"
"  (differenza principale: può contenere solo byte codificati UTF-8 "
"   e non utilizzerà mai l'ottimizzazione di stringhe piccole).\n"
"    "

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# Funzioni"

#: src/basic-syntax/functions.md:3
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz) interview question:"
msgstr ""
"Una versione Rust del famoso gioco [FizzBuzz](https://en."
"wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    print_fizzbuzz_to(20);\n"
"}\n"
"\n"
"fn is_divisible(n: u32, divisor: u32) -> bool {\n"
"    if divisor == 0 {\n"
"        return false;\n"
"    }\n"
"    n % divisor == 0\n"
"}\n"
"\n"
"fn fizzbuzz(n: u32) -> String {\n"
"    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
"    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
"    if fizz.is_empty() && buzz.is_empty() {\n"
"        return format!(\"{n}\");\n"
"    }\n"
"    format!(\"{fizz}{buzz}\")\n"
"}\n"
"\n"
"fn print_fizzbuzz_to(n: u32) {\n"
"    for i in 1..=n {\n"
"        println!(\"{}\", fizzbuzz(i));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward "
"declarations nor headers are necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type.\n"
"* The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
"`=n`, which causes it to include the upper bound."
msgstr ""
"* In `main` ci si riferisce a una funzione scritta di seguito. "
" Non sono necessarie né pre-dichiarazioni né intestazioni.\n"
"* I parametri di dichiarazione sono seguiti da un tipo "
"(il contrario di alcuni linguaggi di programmazione) e quindi da un tipo restituito.\n"
"* L'ultima espressione nel corpo di una funzione (o in qualsiasi blocco) "
"diventa il valore restituito. Basta omettere `;` alla fine dell'espressione.\n"
"* Alcune funzioni non hanno alcun valore di ritorno e restituiscono il 'tipo di unità', `()`."
" Il compilatore lo dedurrà se il tipo restituito `->()` viene omesso.\n"
"* L'espressione di intervallo nel ciclo `for` in `fizzbuzz to()` contiene `=n` "
"che include il limite superiore."

#: src/basic-syntax/rustdoc.md:1
msgid "# Rustdoc"
msgstr "# Rustdoc"

#: src/basic-syntax/rustdoc.md:3
msgid ""
"All language items in Rust can be documented using special `///` syntax."
msgstr ""
"Tutti gli elementi del linguaggio in Rust possono essere documentati usando "
"la sintassi speciale `///`."

#: src/basic-syntax/rustdoc.md:5
msgid ""
"```rust,editable\n"
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return "
"value\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/rustdoc.md:17
msgid ""
"The contents are treated as Markdown. All published Rust library crates are\n"
"automatically documented at [`docs.rs`](https://docs.rs) using the\n"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It "
"is\n"
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"I contenuti sono trattati come Markdown. Tutti i _crate_ pubblicati della libreria Rust "
"sono\n"
"automaticamente documentati in [`docs.rs`](https://docs.rs) utilizzando lo "
"strumento \n"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html). "
"È\n"
"idiomatico per documentare tutti gli elementi pubblici in un'API utilizzando "
"questo modello."

#: src/basic-syntax/rustdoc.md:24
msgid ""
"* Show students the generated docs for the `rand` crate at\n"
"  [`docs.rs/rand`](https://docs.rs/rand).\n"
"\n"
"* This course does not include rustdoc on slides, just to save space, but "
"in\n"
"  real code they should be present.\n"
"\n"
"* Inner doc comments are discussed later (in the page on modules) and need "
"not\n"
"  be addressed here."
msgstr ""
"* Mostra agli studenti i documenti generati per il _crate_ `rand` su\n"
"  [`docs.rs/rand`](https://docs.rs/rand).\n"
"\n"
"* Questo corso non include rustdoc sulle diapositive, solo per risparmiare "
"spazio, ma nel contesto\n"
"  reale dovrebbe essere presente.\n"
"\n"
"* I commenti interni al documento sono discussi più avanti (nella pagina sui "
"moduli) e non è necessario\n"
"  affrontarli qui."

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# Metodi"

#: src/basic-syntax/methods.md:3
msgid ""
"Methods are functions associated with a type. The `self` argument of a "
"method is\n"
"an instance of the type it is associated with:"
msgstr ""
"I metodi sono funzioni associate a un tipo. L'argomento `self` di un metodo "
"è\n"
"un'istanza del tipo a cui è associato:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:30
msgid ""
"* We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"* Approfondiremo maggiormente i metodi nell'esercizio di oggi e nella "
"lezione di domani."

#: src/basic-syntax/methods.md:34
msgid ""
"- Add a `Rectangle::new` constructor and call this from `main`:\n"
"\n"
"    ```rust,editable,compile_fail\n"
"    fn new(width: u32, height: u32) -> Rectangle {\n"
"        Rectangle { width, height }\n"
"    }\n"
"    ```\n"
"\n"
"- Add a `Rectangle::new_square(width: u32)` constructor to illustrate that\n"
"  constructors can take arbitrary parameters."
msgstr ""
"- Aggiungi un costruttore `Rectangle::new` e chiamalo da `main`:\n"
"\n"
"    ```rust,editable,compile_fail\n"
"    fn new(width: u32, height: u32) -> Rectangle {\n"
"        Rectangle { width, height }\n"
"    }\n"
"    ```\n"
"\n"
"- Aggiungi un costruttore `Rectangle::new_square(width: u32)` per illustrare\n"
"  che i costruttori possono accettare parametri arbitrari."

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# Overloading di Funzione"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "L'Overloading non è supportato:"

#: src/basic-syntax/functions-interlude.md:5
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* Ogni funzione ha una singola implementazione:\n"
"  * Accetta sempre un numero fisso di parametri.\n"
"  * Accetta sempre un singolo set di tipi di parametro.\n"
"* I valori predefiniti non sono supportati:\n"
"  * Tutti i siti di chiamata hanno lo stesso numero di argomenti.\n"
"  * Le macro sono talvolta utilizzate come alternativa."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "Tuttavia, i parametri delle funzioni possono essere generici:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind "
"of limited\n"
"  polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"* Quando si usano i generici, `Into<T>` della libreria standard può fornire "
"una sorta di\n"
"  polimorfismo limitato sui tipi dell'argomento. Vedremo maggiori dettagli in una "
"sezione successiva."

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# Giorno 1: Esercizi Mattutini"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "In questi esercizi esploreremo due parti di Rust:"

#: src/exercises/day-1/morning.md:5
msgid ""
"* Implicit conversions between types.\n"
"\n"
"* Arrays and `for` loops."
msgstr ""
"* Conversioni implicite tra tipi.\n"
"\n"
"* Array e cicli `for`."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr "Alcune cose da considerare durante la risoluzione degli esercizi:"

#: src/exercises/day-1/morning.md:13
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for "
"details\n"
"  on installing Rust.\n"
"\n"
"* Alternatively, use the Rust Playground."
msgstr ""
"* Utilizzare un'installazione locale di Rust, se possibile. In questo modo "
"puoi ottenere\n"
"  completamento automatico nel tuo editor. Vedi la pagina su [Using Cargo] per i dettagli\n"
"  sull'installazione di Rust.\n"
"\n"
"* In alternativa, usa Rust Playground."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets "
"lose\n"
"their state if you navigate away from the page."
msgstr ""
"Gli snippet di codice non sono modificabili di proposito: gli snippet di "
"codice in linea perdono\n"
"il loro stato se esci dalla pagina."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/bare-metal/morning.md:7
#: src/exercises/bare-metal/afternoon.md:7
#: src/exercises/concurrency/morning.md:12
#: src/exercises/concurrency/afternoon.md:13
msgid ""
"After looking at the exercises, you can look at the [solutions] provided."
msgstr ""
"Dopo aver esaminato gli esercizi, puoi esaminare le [solutions] fornite."

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# Conversioni Implicite"

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust non applicherà automaticamente le _conversioni implicite_ tra i tipi "
"([a differenza di\n"
"C++][3]). Puoi vederlo in un programma come questo:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"\n"
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;\n"
"\n"
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single "
"`from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted "
"into\n"
"another type."
msgstr ""
"Tutti i tipi interi in Rust implementano i _traits_ [`From<T>`][1] e [`Into<T>`][2]\n"
"consentendo la conversione tra di loro. Il _trait_ `From<T>` ha un singolo metodo "
"`from()`\n"
" e allo stesso modo, il _trait_ `Into<T>` ha un singolo metodo `into()`.\n"
"L'implementazione di questi _traits_ esprime il modo in cui un tipo consente "
" di essere convertito in\n"
" un altro tipo."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"La libreria standard ha un'implementazione di `From<i8> for i16`, che "
"significa\n"
"che possiamo convertire una variabile `x` di tipo `i8` in una `i16` "
"chiamando\n"
"`i16::from(x)`. O, più semplicemente, con `x.into()`, perché l'implementazione `From<i8> for "
"i16`\n"
" crea automaticamente un'implementazione di `Into<i16> per "
"i8`."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is\n"
"sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"Lo stesso vale per le tue implementazioni `From` per i tuoi tipi, così è\n"
"sufficiente implementare solo `From` per ottenere automaticamente una "
"rispettiva implementazione `Into`."

#: src/exercises/day-1/implicit-conversions.md:33
msgid ""
"1. Execute the above program and look at the compiler error.\n"
"\n"
"2. Update the code above to use `into()` to do the conversion.\n"
"\n"
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented "
"for\n"
"   the pairs you check."
msgstr ""
"1. Eseguire il programma precedente e osservare l'errore del compilatore.\n"
"\n"
"2. Aggiornare il codice per utilizzare `into()` per eseguire la "
"conversione.\n"
"\n"
"3. Cambiare i tipi di `x` e `y` in altre cose (come `f32`, `bool`,\n"
"   `i128`) per vedere quali tipi è possibile convertire in quali altri tipi. "
"Provare a\n"
"   convertire tipi \"piccoli\" in tipi \"grandi\" e viceversa. Controlla "
"la\n"
"   [documentazione della libreria standard][1] per vedere se `From<T>` è "
"implementato per\n"
"   le coppie che controlli."

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# Array e Cicli `for`"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "Abbiamo visto che un array può essere dichiarato in questo modo:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:9
msgid ""
"You can print such an array by asking for its debug representation with `{:?}"
"`:"
msgstr ""
"Puoi stampare un tale array chiedendo la sua rappresentazione di debug con "
"`{:?}`:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr ""
"Rust ti consente di iterare cose come array e intervalli usando la parola chiave `for`:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and\n"
"a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"Usa quanto sopra per scrivere una funzione `pretty_print` che stampa in modo "
"efficace una matrice e\n"
"una funzione `transpose` che traspone una matrice (trasforma le righe in "
"colonne):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           ⎛⎡1 2 3⎤⎞      ⎡1 4 7⎤\n"
"\"transpose\"⎜⎢4 5 6⎥⎟  \"==\"⎢2 5 8⎥\n"
"           ⎝⎣7 8 9⎦⎠      ⎣3 6 9⎦\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3 × 3 matrices."
msgstr "Implementa entrambe le funzioni per operare su matrici 3 × 3."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/> e implementa le "
"funzioni:"

#: src/exercises/day-1/for-loops.md:52
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## Domanda bonus"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 × 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"Potresti usare _slices_ `&[i32]` invece di matrici 3 × 3 codificate per il tuo\n"
"argomento e tipi restituiti? Qualcosa come `&[&[i32]]` per un oggetto "
"bidimensionale\n"
"_slice-di-slices_. Perché o perché no?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
"quality\n"
"implementation."
msgstr ""
"Guarda il _crate_ [`ndarray`](https://docs.rs/ndarray/) per una implementazione di livello "
"produzione (_production_)."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"La soluzione e la risposta alla sezione bonus sono disponibili nella\n"
"sezione [Soluzione](solutions-morning.md#arrays-and-for-loops)."

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "# Variabili"

#: src/basic-syntax/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by\n"
"default:"
msgstr ""
"Rust fornisce sicurezza di tipo tramite tipizzazione statica. Le "
"associazioni variabili sono immutabili da\n"
"predefinito:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
#, fuzzy
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the "
"function like syntax of `println!(\"x: {}\", x)`"
msgstr ""
"* A causa dell'inferenza del tipo, `i32` è facoltativo. Mostreremo "
"gradualmente i tipi sempre meno man mano che il corso procede.\n"
"* Nota che poiché `println!` è una macro, `x` non viene spostata, anche "
"usando la sintassi di funzione simile a `println!(\"x: {}\", x)`"

#: src/basic-syntax/type-inference.md:1
#, fuzzy
msgid "# Type Inference"
msgstr "# Digitare Inferenza"

#: src/basic-syntax/type-inference.md:3
#, fuzzy
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Rust esaminerà come la variabile viene _usata_ per determinare il tipo:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"\n"
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;\n"
"\n"
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:26
#, fuzzy
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"Questa diapositiva mostra come il compilatore Rust deduce i tipi in base ai "
"vincoli dati dalle dichiarazioni e dagli usi delle variabili."

#: src/basic-syntax/type-inference.md:28
#, fuzzy
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical "
"to the explicit declaration of a type.\n"
"The compiler does the job for us and helps us write more concise code."
msgstr ""
"È molto importante sottolineare che le variabili dichiarate in questo modo "
"non sono di una sorta di \"qualsiasi tipo\" dinamico che può\n"
"detenere alcun dato. Il codice macchina generato da tale dichiarazione è "
"identico alla dichiarazione esplicita di un tipo.\n"
"Il compilatore fa il lavoro per noi e ci aiuta a scrivere codice più conciso."

#: src/basic-syntax/type-inference.md:32
#, fuzzy
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"Il codice seguente indica al compilatore di copiare in un determinato "
"contenitore generico senza che il codice specifichi mai esplicitamente il "
"tipo contenuto, utilizzando `_` come segnaposto:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"\n"
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
#, fuzzy
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) relies on `FromIterator`, which [`HashSet`](https://doc."
"rust-lang.org/std/iter/trait.FromIterator.html) implements."
msgstr ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) si basa su `FromIterator`, che [`HashSet`](https:/ /doc."
"rust-lang.org/std/iter/trait.FromIterator.html) implementa."

#: src/basic-syntax/static-and-const.md:1
#, fuzzy
msgid "# Static and Constant Variables"
msgstr "# Variabili statiche e costanti"

#: src/basic-syntax/static-and-const.md:3
msgid ""
"Globally-scoped names for values can be given with static variables and "
"constant definitions."
msgstr ""

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr "## `const`"

#: src/basic-syntax/static-and-const.md:7
#, fuzzy
msgid "You can declare compile-time constants:"
msgstr "Puoi dichiarare costanti in fase di compilazione:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"\n"
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
"wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}\n"
"\n"
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:27
#, fuzzy
msgid "According to the [Rust RFC Book][1] these are inlined upon use."
msgstr "Secondo il [Rust RFC Book][1] questi sono incorporati dopo l'uso."

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr "## `static`"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "Puoi anche dichiarare variabili statiche:"

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:41
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have "
"an actual associated memory location.  This is useful for unsafe and "
"embedded code, and the variable lives through the entirety of the program "
"execution.\n"
"When a globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"Come notato nel [Rust RFC Book][1], questi non sono allineati durante l'uso "
"e hanno una posizione di memoria associata effettiva. Questo è utile per il "
"codice non sicuro e incorporato e la variabile vive per tutta l'esecuzione "
"del programma."

#: src/basic-syntax/static-and-const.md:45
msgid ""
"We will look at [mutating static data](../unsafe/mutable-static-variables."
"md) in the chapter on Unsafe Rust.\n"
"Because `static` variables are accessible from any thread, mutable static "
"variables require manual, unsafe, synchronization of accesses."
msgstr ""

#: src/basic-syntax/static-and-const.md:50
#, fuzzy
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++.\n"
"* `static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`.\n"
"* It isn't super common that one would need a runtime evaluated constant, "
"but it is helpful and safer than using a static."
msgstr ""
"* Menziona che `const` si comporta semanticamente in modo simile a "
"`constexpr` del C++.\n"
"* `static`, d'altra parte, è molto più simile a una `const` o variabile "
"globale mutabile in C++.\n"
"* Non è molto comune che si abbia bisogno di una costante valutata in fase "
"di esecuzione, ma è utile e più sicura rispetto all'utilizzo di una statica."

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# Scopes (Ambiti) e Shadowing"

#: src/basic-syntax/scopes-shadowing.md:3
#, fuzzy
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the\n"
"same scope:"
msgstr ""
"Puoi ombreggiare le variabili, sia quelle degli ambiti esterni che le "
"variabili del file\n"
"stessa portata:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"\n"
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }\n"
"\n"
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:25
#, fuzzy
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to "
"values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"* Definizione: l'ombreggiatura è diversa dalla mutazione, perché dopo "
"l'ombreggiatura le locazioni di memoria di entrambe le variabili esistono "
"contemporaneamente. Entrambi sono disponibili con lo stesso nome, a seconda "
"di dove lo usi nel codice.\n"
"* Una variabile di ombreggiatura può avere un tipo diverso.\n"
"* L'ombreggiatura all'inizio sembra oscura, ma è utile per conservare i "
"valori dopo `.unwrap()`.\n"
"* Il codice seguente dimostra perché il compilatore non può semplicemente "
"riutilizzare le posizioni di memoria durante lo shadowing di una variabile "
"immutabile in un ambito, anche se il tipo non cambia."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# Gestione della Memoria"

#: src/memory-management.md:3
#, fuzzy
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr ""
"Tradizionalmente, le lingue sono state suddivise in due grandi categorie:"

#: src/memory-management.md:5
#, fuzzy
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"* Controllo completo tramite gestione manuale della memoria: C, C++, "
"Pascal, ...\n"
"* Piena sicurezza tramite la gestione automatica della memoria in fase di "
"esecuzione: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust offre un nuovo mix:"

#: src/memory-management.md:10
#, fuzzy
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> Pieno controllo *e* sicurezza tramite applicazione in fase di compilazione "
"della memoria corretta\n"
"> gestione."

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "Lo fa con un concetto di ownership (proprietà) esplicito."

#: src/memory-management.md:15
#, fuzzy
msgid "First, let's refresh how memory management works."
msgstr ""
"Innanzitutto, aggiorniamo il funzionamento della gestione della memoria."

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# Lo Stack (Pila) vs l’Heap"

#: src/memory-management/stack-vs-heap.md:3
#, fuzzy
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality.\n"
"\n"
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* Stack: area continua di memoria per le variabili locali.\n"
"  * I valori hanno dimensioni fisse note al momento della compilazione.\n"
"  * Estremamente veloce: basta spostare un puntatore dello stack.\n"
"  * Facile da gestire: segue le chiamate alle funzioni.\n"
"  * Ottima località di memoria.\n"
"\n"
"* Heap: archiviazione di valori al di fuori delle chiamate di funzione.\n"
"  * I valori hanno dimensioni dinamiche determinate in fase di esecuzione.\n"
"  * Leggermente più lento della pila: è necessaria un po' di contabilità.\n"
"  * Nessuna garanzia di località di memoria."

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# Memoria sullo Stack"

#: src/memory-management/stack.md:3
#, fuzzy
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically "
"sized\n"
"data on the heap:"
msgstr ""
"La creazione di una `Stringa` mette i dati di dimensioni fisse nello stack e "
"dimensionati dinamicamente\n"
"dati sull'heap:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/memory-management/stack.md:28
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap.\n"
"\n"
"* If students ask about it, you can mention that the underlying memory is "
"heap allocated using the [System Allocator] and custom allocators can be "
"implemented using the [Allocator API]\n"
"\n"
"* We can inspect the memory layout with `unsafe` code. However, you should "
"point out that this is rightfully unsafe!\n"
"\n"
"    ```rust,editable\n"
"    fn main() {\n"
"        let mut s1 = String::from(\"Hello\");\n"
"        s1.push(' ');\n"
"        s1.push_str(\"world\");\n"
"        // DON'T DO THIS AT HOME! For educational purposes only.\n"
"        // String provides no guarantees about its layout, so this could "
"lead to\n"
"        // undefined behavior.\n"
"        unsafe {\n"
"            let (capacity, ptr, len): (usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"            println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
"{capacity}\");\n"
"        }\n"
"    }\n"
"    ```"
msgstr ""

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# Gestione manuale della Memoria"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "Allocate e de-allocate voi stessi la memoria dell'heap."

#: src/memory-management/manual.md:5
#, fuzzy
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Se non fatto con cura, ciò può portare a arresti anomali, bug, vulnerabilità "
"di sicurezza e perdite di memoria."

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## Esempio C"

#: src/memory-management/manual.md:9
#, fuzzy
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "Devi chiamare `free` su ogni puntatore allocato con `malloc`:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
#, fuzzy
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr ""
"La memoria viene persa se la funzione ritorna in anticipo tra `malloc` e "
"`free`: the\n"
"puntatore è perso e non possiamo deallocare la memoria."

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# Gestione della memoria basata sullo Scope (ambito)"

#: src/memory-management/scope-based.md:3
#, fuzzy
msgid ""
"Constructors and destructors let you hook into the lifetime of an object."
msgstr ""
"Costruttori e distruttori ti consentono di agganciarti alla vita di un "
"oggetto."

#: src/memory-management/scope-based.md:5
#, fuzzy
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception "
"is\n"
"raised."
msgstr ""
"Avvolgendo un puntatore in un oggetto, puoi liberare memoria quando "
"l'oggetto è\n"
"distrutto. Il compilatore garantisce che ciò accada, anche se lo è "
"un'eccezione\n"
"sollevato."

#: src/memory-management/scope-based.md:9
#, fuzzy
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives\n"
"you smart pointers."
msgstr ""
"Questo è spesso chiamato _l'acquisizione delle risorse è l'inizializzazione_ "
"(RAII) e dà\n"
"puntatori intelligenti."

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## Esempio C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/scope-based.md:20
#, fuzzy
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* L'oggetto `std::unique_ptr` è allocato nello stack e punta a\n"
"  memoria allocata nell'heap.\n"
"* Alla fine di `say_hello`, verrà eseguito il distruttore `std::"
"unique_ptr`.\n"
"* Il distruttore libera l'oggetto `Person` a cui punta."

#: src/memory-management/scope-based.md:25
#, fuzzy
msgid ""
"Special move constructors are used when passing ownership to a function:"
msgstr ""
"I costruttori di mosse speciali vengono utilizzati quando si passa la "
"proprietà a una funzione:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "# Gestione automatica della Memoria"

#: src/memory-management/garbage-collection.md:3
#, fuzzy
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory\n"
"management:"
msgstr ""
"Un'alternativa alla gestione della memoria manuale e basata sull'ambito è la "
"memoria automatica\n"
"gestione:"

#: src/memory-management/garbage-collection.md:6
#, fuzzy
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"* Il programmatore non alloca o dealloca mai la memoria in modo esplicito.\n"
"* Un Garbage Collector trova la memoria inutilizzata e la dealloca per il "
"programmatore."

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Esempio Java"

#: src/memory-management/garbage-collection.md:11
#, fuzzy
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr ""
"L'oggetto `person` non viene deallocato dopo che `sayHello` restituisce:"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# Gestione della Memoria in Rust"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "La gestione della memoria in Rust è un mix:"

#: src/memory-management/rust.md:5
#, fuzzy
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you "
"choose, can be a single unique pointer, reference counted, or atomically "
"reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"* Sicuro e corretto come Java, ma senza un garbage collector.\n"
"* A seconda dell'astrazione (o combinazione di astrazioni) scelta, può "
"trattarsi di un singolo puntatore univoco, del conteggio dei riferimenti o "
"del conteggio dei riferimenti atomici.\n"
"* Basato sull'ambito come C++, ma il compilatore applica la piena aderenza.\n"
"* Un utente Rust può scegliere l'astrazione giusta per la situazione, alcuni "
"addirittura non hanno alcun costo in fase di esecuzione come C."

#: src/memory-management/rust.md:10
#, fuzzy
msgid "Rust achieves this by modeling _ownership_ explicitly."
msgstr "Raggiunge questo modellando _ownership_ in modo esplicito."

#: src/memory-management/rust.md:14
#, fuzzy
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box], [Vec], [Rc], or [Arc]. These "
"encapsulate ownership and memory allocation via various means, and prevent "
"the potential errors in C.\n"
"\n"
"* You may be asked about destructors here, the [Drop] trait is the Rust "
"equivalent."
msgstr ""
"* Se ti viene chiesto come a questo punto, puoi menzionare che in Rust "
"questo è solitamente gestito da tipi di wrapper RAII come [Box], [Vec], [Rc] "
"o [Arc]. Questi incapsulano la proprietà e l'allocazione della memoria "
"tramite vari mezzi e prevengono i potenziali errori in C.\n"
"\n"
"* Qui ti potrebbe essere chiesto dei distruttori, il tratto [Drop] è "
"l'equivalente di Rust."

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# Confronto"

#: src/memory-management/comparison.md:3
#, fuzzy
msgid "Here is a rough comparison of the memory management techniques."
msgstr ""
"Ecco un confronto approssimativo delle tecniche di gestione della memoria."

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## Vantaggi di Tecniche differenti di gestione della Memoria"

#: src/memory-management/comparison.md:7
#, fuzzy
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Manuale come C:\n"
"  * Nessun sovraccarico di runtime.\n"
"* Automatico come Java:\n"
"  * Completamente automatico.\n"
"  * Sicuro e corretto.\n"
"* Basato sull'ambito come C++:\n"
"  * Parzialmente automatico.\n"
"  * Nessun sovraccarico di runtime.\n"
"* Basato sull'ambito imposto dal compilatore come Rust:\n"
"  * Applicato dal compilatore.\n"
"  * Nessun sovraccarico di runtime.\n"
"  * Sicuro e corretto."

#: src/memory-management/comparison.md:20
#, fuzzy
msgid "## Cons of Different Memory Management Techniques"
msgstr "## Contro di diverse tecniche di gestione della memoria"

#: src/memory-management/comparison.md:22
#, fuzzy
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Manuale come C:\n"
"  * Usa-dopo-gratis.\n"
"  * Doppia libera.\n"
"  * Perdite di memoria.\n"
"* Automatico come Java:\n"
"  * La raccolta dei rifiuti si interrompe.\n"
"  * Ritardi del distruttore.\n"
"* Basato sull'ambito come C++:\n"
"  * Complesso, opt-in dal programmatore.\n"
"  * Potenziale per uso dopo-gratis.\n"
"* Applicato al compilatore e basato sull'ambito come Rust:\n"
"  * Qualche complessità iniziale.\n"
"  * Può rifiutare programmi validi."

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# Ownership (Proprietà)"

#: src/ownership.md:3
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to\n"
"use a variable outside its scope:"
msgstr ""
"Tutte le associazioni di variabili hanno un _scope_ in cui sono valide ed è "
"un errore\n"
"usa una variabile al di fuori del suo ambito:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""

#: src/ownership.md:18
#, fuzzy
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* Alla fine dell'ambito, la variabile viene _eliminata_ ei dati vengono "
"liberati.\n"
"* Un distruttore può essere eseguito qui per liberare risorse.\n"
"* Diciamo che la variabile _possiede_ il valore."

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# Semantica di Move (Spostamento)"

#: src/ownership/move-semantics.md:3
#, fuzzy
msgid "An assignment will transfer ownership between variables:"
msgstr "Un'assegnazione trasferirà la proprietà tra le variabili:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/move-semantics.md:14
#, fuzzy
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* L'assegnazione di \"s1\" a \"s2\" trasferisce la proprietà.\n"
"* I dati sono stati _spostati_ da `s1` e `s1` non è più accessibile.\n"
"* Quando `s1` esce dall'ambito, non accade nulla: non ha proprietà.\n"
"* Quando `s2` esce dall'ambito, i dati della stringa vengono liberati.\n"
"* C'è sempre _esattamente_ un legame di variabile che possiede un valore."

#: src/ownership/move-semantics.md:22
#, fuzzy
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!).\n"
"\n"
"* In Rust, clones are explicit (by using `clone`)."
msgstr ""
"* Menziona che questo è l'opposto dei valori predefiniti in C++, che copia "
"per valore a meno che tu non usi `std::move` (e il costruttore di movimento "
"è definito!).\n"
"\n"
"* In Rust, i cloni sono espliciti (utilizzando `clone`)."

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# Stringhe mosse/spostate in Rust"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
#, fuzzy
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* I dati dell'heap da `s1` vengono riutilizzati per `s2`.\n"
"* Quando `s1` esce dall'ambito, non accade nulla (è stato spostato da)."

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "Prima di muovere a `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "Dopo il muovere a `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# Double Free in C++ moderno"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "C++ moderno risolve questo problema in modo diverso:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:10
#, fuzzy
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent "
"copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* I dati dell'heap da `s1` vengono duplicati e `s2` ottiene la propria copia "
"indipendente.\n"
"* Quando `s1` e `s2` escono dall'ambito, ciascuno libera la propria memoria."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "Prima dell'assegnazione di copia (copy-assignment):"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "Dopo l'assegnazione di copia (copy-assignment):"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:1
#, fuzzy
msgid "# Moves in Function Calls"
msgstr "# Sposta nelle chiamate di funzione"

#: src/ownership/moves-function-calls.md:3
#, fuzzy
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr ""
"Quando si passa un valore a una funzione, il valore viene assegnato alla "
"funzione\n"
"parametro. Questo trasferisce la proprietà:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:20
#, fuzzy
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) "
"and if `say_hello` accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making "
"move semantics the default, and by forcing programmers to make clones "
"explicit."
msgstr ""
"* Con la prima chiamata a `say_hello`, `main` rinuncia alla proprietà di "
"`name`. Successivamente, `name` non può più essere utilizzato all'interno di "
"`main`.\n"
"* La memoria heap allocata per `name` verrà liberata alla fine della "
"funzione `say_hello`.\n"
"* `main` può mantenere la proprietà se passa `name` come riferimento "
"(`&name`) e se `say_hello` accetta un riferimento come parametro.\n"
"* In alternativa, `main` può passare un clone di `name` nella prima chiamata "
"(`name.clone()`).\n"
"* Rust rende più difficile del C++ creare copie inavvertitamente rendendo la "
"semantica di spostamento l'impostazione predefinita e costringendo i "
"programmatori a rendere espliciti i cloni."

#: src/ownership/copy-clone.md:1
#, fuzzy
msgid "# Copying and Cloning"
msgstr "# Copia e clonazione"

#: src/ownership/copy-clone.md:3
#, fuzzy
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"Sebbene la semantica di spostamento sia l'impostazione predefinita, alcuni "
"tipi vengono copiati per impostazione predefinita:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:14
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Questi tipi implementano il tratto `Copy`."

#: src/ownership/copy-clone.md:16
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"Puoi acconsentire esplicitamente ai tuoi tipi per utilizzare la semantica "
"della copia:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:30
#, fuzzy
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* Dopo l'assegnazione, sia `p1` che `p2` possiedono i propri dati.\n"
"* Possiamo anche usare `p1.clone()` per copiare esplicitamente i dati."

#: src/ownership/copy-clone.md:35
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Copiare e clonare non sono la stessa cosa:"

#: src/ownership/copy-clone.md:37
#, fuzzy
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in C+"
"+).\n"
"* Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* La copia si riferisce a copie bit per bit di aree di memoria e non "
"funziona su oggetti arbitrari.\n"
"* La copia non consente la logica personalizzata (a differenza dei "
"costruttori di copia in C++).\n"
"* La clonazione è un'operazione più generale e consente anche un "
"comportamento personalizzato implementando il tratto `Clone`.\n"
"* La copia non funziona sui tipi che implementano il tratto `Drop`."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
#, fuzzy
msgid "In the above example, try the following:"
msgstr "Nell'esempio precedente, prova quanto segue:"

#: src/ownership/copy-clone.md:44
#, fuzzy
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because "
"`String` is not a `Copy` type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in "
"the `println!` for  `p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* Aggiungi un campo `String` a `struct Point`. Non verrà compilato perché "
"`String` non è un tipo `Copy`.\n"
"* Rimuovi `Copy` dall'attributo `derive`. L'errore del compilatore è ora in "
"`println!` per `p1`.\n"
"* Dimostra che funziona se invece cloni `p1`."

#: src/ownership/copy-clone.md:48
#, fuzzy
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust\n"
"at compile time. In this case the default implementations of `Copy` and "
"`Clone` traits are generated."
msgstr ""
"Se gli studenti chiedono informazioni su `derive`, è sufficiente dire che "
"questo è un modo per generare codice in Rust\n"
"in fase di compilazione. In questo caso vengono generate le implementazioni "
"predefinite dei tratti `Copy` e `Clone`."

#: src/ownership/borrowing.md:1
#, fuzzy
msgid "# Borrowing"
msgstr "# Prendere in prestito"

#: src/ownership/borrowing.md:3
#, fuzzy
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr ""
"Invece di trasferire la proprietà quando chiami una funzione, puoi lasciare "
"che a\n"
"funzione _prende in prestito_ il valore:"

#: src/ownership/borrowing.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:22
#, fuzzy
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* La funzione `add` _prende in prestito_ due punti e restituisce un nuovo "
"punto.\n"
"* Il chiamante mantiene la proprietà degli ingressi."

#: src/ownership/borrowing.md:27
#, fuzzy
msgid "Notes on stack returns:"
msgstr "Note sui resi dello stack:"

#: src/ownership/borrowing.md:28
msgid ""
"* Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground]. In the \"DEBUG\" optimization level, the "
"addresses should change, while they stay the same when changing to the "
"\"RELEASE\" setting:\n"
"\n"
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);\n"
"\n"
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification "
"because constructors can have side effects. In Rust, this is not an issue at "
"all. If RVO did not happen, Rust will always perform a simple and efficient "
"`memcpy` copy."
msgstr ""

#: src/ownership/shared-unique-borrows.md:1
#, fuzzy
msgid "# Shared and Unique Borrows"
msgstr "# Prestiti condivisi e unici"

#: src/ownership/shared-unique-borrows.md:3
#, fuzzy
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr ""
"Rust pone dei vincoli sui modi in cui puoi prendere in prestito i valori:"

#: src/ownership/shared-unique-borrows.md:5
#, fuzzy
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* Puoi avere uno o più valori `&T` in qualsiasi momento, _oppure_\n"
"* Puoi avere esattamente un valore `&mut T`."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"\n"
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/shared-unique-borrows.md:25
#, fuzzy
msgid ""
"* The above code does not compile because `a` is borrowed as mutable "
"(through `c`) and as immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"* Il codice precedente non viene compilato perché `a` è preso in prestito "
"come mutabile (attraverso `c`) e come immutabile (attraverso `b`) allo "
"stesso tempo.\n"
"* Sposta l'istruzione `println!` per `b` prima dell'ambito che introduce `c` "
"per far compilare il codice.\n"
"* Dopo tale modifica, il compilatore si rende conto che `b` è sempre e solo "
"usato prima del nuovo prestito mutabile da `a` a `c`. Questa è una "
"caratteristica del controllo del prestito chiamata \"vita non lessicale\"."

#: src/ownership/lifetimes.md:1
#, fuzzy
msgid "# Lifetimes"
msgstr "# Vite"

#: src/ownership/lifetimes.md:3
#, fuzzy
msgid "A borrowed value has a _lifetime_:"
msgstr "Un valore preso in prestito ha una _durata_:"

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a "
"lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that "
"there is\n"
"    a valid solution.\n"
"* Lifetimes for function arguments and return values must be fully "
"specified,\n"
"  but Rust allows lifetimes to be elided in most cases with [a few simple\n"
"  rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html)."
msgstr ""

#: src/ownership/lifetimes-function-calls.md:1
#, fuzzy
msgid "# Lifetimes in Function Calls"
msgstr "# Durata delle chiamate di funzione"

#: src/ownership/lifetimes-function-calls.md:3
#, fuzzy
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"Oltre a prendere in prestito i suoi argomenti, una funzione può restituire "
"un valore preso in prestito:"

#: src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:21
#, fuzzy
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` è un parametro generico, viene dedotto dal compilatore.\n"
"* Le durate iniziano con `'` e `'a` è un tipico nome predefinito.\n"
"* Leggi `&'a Point` come \"un `Punto` preso in prestito che è valido almeno "
"per il\n"
"  vita `a`\".\n"
"  * La parte _almeno_ è importante quando i parametri si trovano in ambiti "
"diversi."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
"resulting in the following code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);\n"
"\n"
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }\n"
"\n"
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`.\n"
"\n"
"* Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function "
"returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global "
"variable).\n"
"  * Which one is it? The compiler needs to know, so at the call site the "
"returned reference is not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""

#: src/ownership/lifetimes-data-structures.md:1
#, fuzzy
msgid "# Lifetimes in Data Structures"
msgstr "# Durata nelle strutture dati"

#: src/ownership/lifetimes-data-structures.md:3
#, fuzzy
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"Se un tipo di dati memorizza dati presi in prestito, deve essere annotato "
"con una durata:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog."
"\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:25
#, fuzzy
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one "
"lifetime annotation. This can be necessary if there is a need to describe "
"lifetime relationships between the references themselves, in addition to the "
"lifetime of the struct itself. Those are very advanced use cases."
msgstr ""
"* Nell'esempio precedente, l'annotazione su \"Highlight\" impone che i dati "
"sottostanti a \"&str\" contenuti durino almeno quanto qualsiasi istanza di "
"\"Highlight\" che utilizza quei dati.\n"
"* Se `text` viene consumato prima della fine della vita di `fox` (o `dog`), "
"il controllo del prestito genera un errore.\n"
"* I tipi con dati presi in prestito costringono gli utenti a conservare i "
"dati originali. Questo può essere utile per creare viste leggere, ma in "
"genere le rende un po' più difficili da usare.\n"
"* Quando possibile, fare in modo che le strutture dati possiedano "
"direttamente i propri dati.\n"
"* Alcune strutture con più riferimenti all'interno possono avere più di "
"un'annotazione di durata. Ciò può essere necessario se è necessario "
"descrivere le relazioni di durata tra i riferimenti stessi, oltre alla "
"durata della struttura stessa. Questi sono casi d'uso molto avanzati."

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "# Day 1: Afternoon Exercises"
msgstr "# Giorno 1: Esercizi pomeridiani"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Vedremo due cose:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid ""
"* A small book library,\n"
"\n"
"* Iterators and ownership (hard)."
msgstr ""
"* Una piccola biblioteca di libri,\n"
"\n"
"* Iteratori e proprietà (hard)."

#: src/exercises/day-1/book-library.md:1
#, fuzzy
msgid "# Storing Books"
msgstr "# Corda"

#: src/exercises/day-1/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now,\n"
"you just need to know part of its API:"
msgstr ""
"Impareremo molto di più sulle strutture e sul tipo `Vec<T>` domani. Per "
"adesso,\n"
"devi solo conoscere parte della sua API:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"middle value: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:18
#, fuzzy
msgid ""
"Use this to model a library's book collection. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Usalo per creare un'applicazione libreria. Copia il codice qui sotto per\n"
"<https://play.rust-lang.org/> e aggiorna i tipi per farlo compilare:"

#: src/exercises/day-1/book-library.md:21
msgid ""
"```rust,should_panic\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        todo!(\"Initialize and return a `Library` value\")\n"
"    }\n"
"\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"}\n"
"\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", library."
"is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:102
#, fuzzy
msgid "[Solution](solutions-afternoon.md#designing-a-library)"
msgstr "[Soluzione](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:1
#, fuzzy
msgid "# Iterators and Ownership"
msgstr "# Iteratori e proprietà"

#: src/exercises/day-1/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
"html)\n"
"traits."
msgstr ""
"Il modello di proprietà di Rust influisce su molte API. Un esempio di questo "
"è il\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) e\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
"html)\n"
"tratti."

#: src/exercises/day-1/iterators-and-ownership.md:8
#, fuzzy
msgid "## `Iterator`"
msgstr "## `Iteratore`"

#: src/exercises/day-1/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. "
"The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"I tratti sono come interfacce: descrivono il comportamento (metodi) per un "
"tipo. IL\n"
"Il tratto \"Iterator\" dice semplicemente che puoi chiamare \"next\" fino a "
"quando non ottieni \"Nessuno\":"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "Usi questo tratto in questo modo:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr ""
"Qual è il tipo restituito dall'iteratore? Metti alla prova la tua risposta "
"qui:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "Perché viene utilizzato questo tipo?"

#: src/exercises/day-1/iterators-and-ownership.md:48
#, fuzzy
msgid "## `IntoIterator`"
msgstr "## `IntoIterator`"

#: src/exercises/day-1/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"Il tratto `Iterator` ti dice come _iterare_ una volta che hai creato un "
"file\n"
"iteratore. Il tratto correlato `IntoIterator` ti dice come creare "
"l'iteratore:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"\n"
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr ""
"La sintassi qui significa che ogni implementazione di \"IntoIterator\" deve\n"
"dichiarare due tipi:"

#: src/exercises/day-1/iterators-and-ownership.md:65
#, fuzzy
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: il tipo su cui iteriamo, come `i8`,\n"
"* `IntoIter`: il tipo `Iterator` restituito dal metodo `into_iter`."

#: src/exercises/day-1/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Nota che \"IntoIter\" e \"Item\" sono collegati: l'iteratore deve avere lo "
"stesso\n"
"Tipo `Item`, che significa che restituisce `Option<Item>`"

#: src/exercises/day-1/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "Come prima, qual è il tipo restituito dall'iteratore?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:83
#, fuzzy
msgid "## `for` Loops"
msgstr "## cicli `for`"

#: src/exercises/day-1/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"Ora che conosciamo sia `Iterator` che `IntoIterator`, possiamo creare cicli "
"`for`.\n"
"Chiamano `into_iter()` su un'espressione e itera sul risultato\n"
"iteratore:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"\n"
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "Qual è il tipo di \"parola\" in ogni ciclo?"

#: src/exercises/day-1/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for "
"[`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-"
"IntoIterator-for-%26'a+Vec%3CT,+A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
"for-Vec%3CT,+A%3E)\n"
"to check your answers."
msgstr ""
"Sperimenta con il codice sopra e poi consulta la documentazione per [`impl\n"
"IntoIteratore per\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-"
"IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"e [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
"for-Vec%3CT%2C%20A%3E)\n"
"per controllare le tue risposte."

#: src/welcome-day-2.md:1
#, fuzzy
msgid "# Welcome to Day 2"
msgstr "# Benvenuto al giorno 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr ""
"Ora che abbiamo visto una discreta quantità di ruggine, continueremo con:"

#: src/welcome-day-2.md:5
#, fuzzy
msgid ""
"* Structs, enums, methods.\n"
"\n"
"* Pattern matching: destructuring enums, structs, and arrays.\n"
"\n"
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
"and\n"
"  `continue`.\n"
"\n"
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc`\n"
"  and `Arc`.\n"
"\n"
"* Modules: visibility, paths, and filesystem hierarchy."
msgstr ""
"* Struct, enum, metodi.\n"
"\n"
"* Pattern matching: destrutturazione di enum, struct e array.\n"
"\n"
"* Costrutti del flusso di controllo: `if`, `if let`, `while`, `while let`, "
"`break` e\n"
"  `continua`.\n"
"\n"
"* La libreria standard: `String`, `Option` e `Result`, `Vec`, `HashMap`, "
"`Rc`\n"
"  e \"Arco\".\n"
"\n"
"* Moduli: visibilità, percorsi e gerarchia del filesystem."

#: src/structs.md:1
#, fuzzy
msgid "# Structs"
msgstr "# Strutture"

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "Come C e C++, Rust supporta le strutture personalizzate:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""

#: src/structs.md:31 src/enums.md:34 src/enums/sizes.md:29 src/methods.md:30
#: src/methods/example.md:46 src/pattern-matching.md:25
#: src/pattern-matching/match-guards.md:22 src/control-flow/blocks.md:43
#, fuzzy
msgid "Key Points:"
msgstr "Punti chiave:"

#: src/structs.md:33
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following "
"slides.\n"
"* This may be a good time to let people know there are different types of "
"structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a "
"trait on some type but don’t have any data that you want to store in the "
"value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names "
"are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""

#: src/structs/tuple-structs.md:1
#, fuzzy
msgid "# Tuple Structs"
msgstr "# Strutture di tuple"

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"Se i nomi dei campi non sono importanti, puoi utilizzare una struttura di "
"tupla:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Questo è spesso usato per i wrapper a campo singolo (chiamati newtypes):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"* Newtypes are a great way to encode additional information about the value "
"in a primitive type, for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer "
"have to validate it again at every use: 'PhoneNumber(String)` or "
"`OddNumber(u32)`.\n"
"* Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype.\n"
"  *  Rust generally doesn’t like inexplicit things, like automatic "
"unwrapping or for instance using booleans as integers.\n"
"  *  Operator overloading is discussed on Day 3 (generics).\n"
"* The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"* I newtype sono un ottimo modo per codificare informazioni aggiuntive sul "
"valore in un tipo primitivo, ad esempio:\n"
"  * Il numero è misurato in alcune unità: `Newton` nell'esempio precedente.\n"
"  * Il valore ha superato una certa convalida quando è stato creato, quindi "
"non è più necessario convalidarlo nuovamente a ogni utilizzo: 'Numero di "
"telefono (Stringa)` o `Numero dispari (u32)`.\n"
"* Dimostra come aggiungere un valore `f64` a un tipo `Newtons` accedendo al "
"singolo campo nel newtype.\n"
"  * A Rust in genere non piacciono le cose inesplicite, come l'unwrapping "
"automatico o, ad esempio, l'uso di valori booleani come numeri interi.\n"
"  * Il sovraccarico degli operatori viene discusso il giorno 3 (generici)."

#: src/structs/field-shorthand.md:1
#, fuzzy
msgid "# Field Shorthand Syntax"
msgstr "# Sintassi abbreviata dei campi"

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr ""
"Se disponi già di variabili con i nomi corretti, puoi creare il file\n"
"struct usando una scorciatoia:"

#: src/structs/field-shorthand.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:27
msgid ""
"*  The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Person {\n"
"         name: String,\n"
"         age: u8,\n"
"     }\n"
"     impl Person {\n"
"         fn new(name: String, age: u8) -> Self {\n"
"             Self { name, age }\n"
"         }\n"
"     }\n"
"     ```    \n"
"* Implement the `Default` trait for the struct. Define some fields and use "
"the default values for the other fields.\n"
"\n"
"     ```rust,editable\n"
"     #[derive(Debug)]\n"
"     struct Person {\n"
"         name: String,\n"
"         age: u8,\n"
"     }\n"
"     impl Default for Person {\n"
"         fn default() -> Person {\n"
"             Person {\n"
"                 name: \"Bot\".to_string(),\n"
"                 age: 0,\n"
"             }\n"
"         }\n"
"     }\n"
"     fn create_default() {\n"
"         let tmp = Person {\n"
"             ..Default::default()\n"
"         };\n"
"         let tmp = Person {\n"
"             name: \"Sam\".to_string(),\n"
"             ..Default::default()\n"
"         };\n"
"     }\n"
"     ```\n"
"\n"
"* Methods are defined in the `impl` block.\n"
"* Use struct update syntax to define a new structure using `peter`. Note "
"that the variable `peter` will no longer be accessible afterwards.\n"
"* Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""

#: src/enums.md:1
#, fuzzy
msgid "# Enums"
msgstr "# Enum"

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr ""
"La parola chiave `enum` consente la creazione di un tipo che ne ha alcuni\n"
"diverse varianti:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementation based on https://xkcd.com/221/\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:36
#, fuzzy
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tails`. You might note the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or "
"one with different types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate "
"structs but then they wouldn’t be the same type as they would if they were "
"all defined in an enum. "
msgstr ""
"* Le enumerazioni consentono di raccogliere un insieme di valori in un unico "
"tipo\n"
"* Questa pagina offre un tipo di enum `CoinFlip` con due varianti `Heads` e "
"`Tail`. Potresti notare lo spazio dei nomi quando usi le varianti.\n"
"* Questo potrebbe essere un buon momento per confrontare Struct ed Enum:\n"
"  * In entrambi, puoi avere una versione semplice senza campi (unit struct) "
"o una con diversi tipi di campi (variant payload).\n"
"  * In entrambi, le funzioni associate sono definite all'interno di un "
"blocco `impl`.\n"
"  * Potresti persino implementare le diverse varianti di un'enumerazione con "
"strutture separate, ma non sarebbero dello stesso tipo che sarebbero se "
"fossero tutte definite in un'enumerazione."

#: src/enums/variant-payloads.md:1
#, fuzzy
msgid "# Variant Payloads"
msgstr "# Payload varianti"

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"È possibile definire enumerazioni più ricche in cui le varianti contengono "
"dati. È quindi possibile utilizzare il\n"
"istruzione `match` per estrarre i dati da ciascuna variante:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"* The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`.\n"
"  * The expression is matched against the patterns from top to bottom. There "
"is no fall-through like in C or C++.\n"
"  * The match expression has a value. The value is the last expression in "
"the match arm which was executed.\n"
"  * Starting from the top we look for what pattern matches the value then "
"run the code following the arrow. Once we find a match, we stop. \n"
"* Demonstrate what happens when the search is inexhaustive. Note the "
"advantage the Rust compiler provides by confirming when all cases are "
"handled. \n"
"* `match` inspects a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling `std::mem::"
"discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs "
"where comparing field values doesn't affect equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
"Click(Click)` with a top level `struct Click { ... }`. The inlined version "
"cannot implement traits, for example.  \n"
"  "
msgstr ""
"* È possibile accedere ai valori nelle varianti enum solo dopo essere stati "
"abbinati al modello. Il modello lega i riferimenti ai campi nel \"match "
"arm\" dopo il `=>`.\n"
"  * L'espressione viene confrontata con i modelli dall'alto verso il basso. "
"Non c'è fall-through come in C o C++.\n"
"  * L'espressione di corrispondenza ha un valore. Il valore è l'ultima "
"espressione nel braccio di corrispondenza che è stata eseguita.\n"
"  * Partendo dall'alto cerchiamo quale modello corrisponde al valore, quindi "
"eseguiamo il codice seguendo la freccia. Una volta trovata una "
"corrispondenza, ci fermiamo.\n"
"* Dimostrare cosa succede quando la ricerca è inesauribile. Nota il "
"vantaggio fornito dal compilatore Rust confermando quando tutti i casi "
"vengono gestiti.\n"
"* `match` ispeziona un campo discriminante nascosto in `enum`.\n"
"* È possibile recuperare il discriminante chiamando `std::mem::"
"discriminant()`\n"
"  * Ciò è utile, ad esempio, se si implementa `PartialEq` per strutture in "
"cui il confronto dei valori dei campi non influisce sull'uguaglianza.\n"
"* `WebEvent::Click { ... }` non è esattamente la stessa cosa di `WebEvent::"
"Click(Click)` con una `struct Click { ... }` di primo livello. La versione "
"inline non può implementare tratti, per esempio.\n"
"  "

#: src/enums/sizes.md:1
#, fuzzy
msgid "# Enum Sizes"
msgstr "# Enum Dimensioni"

#: src/enums/sizes.md:3
#, fuzzy
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"Gli enum di Rust sono imballati strettamente, tenendo conto dei vincoli "
"dovuti all'allineamento:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size!(Foo);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:25
#, fuzzy
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."
msgstr ""
"* Vedere il [riferimento Rust](https://doc.rust-lang.org/reference/type-"
"layout.html)."

#: src/enums/sizes.md:31
msgid ""
" * Internally Rust is using a field (discriminant) to keep track of the enum "
"variant.\n"
"\n"
" * You can control the discriminant if needed (e.g., for compatibility with "
"C):\n"
" \n"
"     ```rust,editable\n"
"     #[repr(u32)]\n"
"     enum Bar {\n"
"         A,  // 0\n"
"         B = 10000,\n"
"         C,  // 10001\n"
"     }\n"
"     \n"
"     fn main() {\n"
"         println!(\"A: {}\", Bar::A as u32);\n"
"         println!(\"B: {}\", Bar::B as u32);\n"
"         println!(\"C: {}\", Bar::C as u32);\n"
"     }\n"
"     ```\n"
"\n"
"    Without `repr`, the discriminant type takes 2 bytes, because 10001 fits "
"2\n"
"    bytes.\n"
"\n"
"\n"
" * Try out other types such as\n"
" \n"
"     * `dbg_size!(bool)`: size 1 bytes, align: 1 bytes,\n"
"     * `dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche "
"optimization, see below),\n"
"     * `dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit "
"machine),\n"
"     * `dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
"optimization, see below).\n"
"\n"
" * Niche optimization: Rust will merge unused bit patterns for the enum\n"
"   discriminant.\n"
"\n"
" * Null pointer optimization: For [some\n"
"   types](https://doc.rust-lang.org/std/option/#representation), Rust "
"guarantees\n"
"   that `size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
"\n"
"     Example code if you want to show how the bitwise representation *may* "
"look like in practice.\n"
"     It's important to note that the compiler provides no guarantees "
"regarding this representation, therefore this is totally unsafe.\n"
"\n"
"     ```rust,editable\n"
"     use std::mem::transmute;\n"
"\n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"         // representation of types.\n"
"         unsafe {\n"
"             println!(\"Bitwise representation of bool\");\n"
"             dbg_bits!(false, u8);\n"
"             dbg_bits!(true, u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<bool>\");\n"
"             dbg_bits!(None::<bool>, u8);\n"
"             dbg_bits!(Some(false), u8);\n"
"             dbg_bits!(Some(true), u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"             dbg_bits!(Some(Some(false)), u8);\n"
"             dbg_bits!(Some(Some(true)), u8);\n"
"             dbg_bits!(Some(None::<bool>), u8);\n"
"             dbg_bits!(None::<Option<bool>>, u8);\n"
"\n"
"             println!(\"Bitwise representation of Option<&i32>\");\n"
"             dbg_bits!(None::<&i32>, usize);\n"
"             dbg_bits!(Some(&0i32), usize);\n"
"         }\n"
"     }\n"
"     ```\n"
"\n"
"     More complex example if you want to discuss what happens when we chain "
"more than 256 `Option`s together.\n"
"\n"
"     ```rust,editable\n"
"     #![recursion_limit = \"1000\"]\n"
"\n"
"     use std::mem::transmute;\n"
"     \n"
"     macro_rules! dbg_bits {\n"
"         ($e:expr, $bit_type:ty) => {\n"
"             println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"         };\n"
"     }\n"
"\n"
"     // Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
"signs.\n"
"     // Increasing the recursion limit is required to evaluate this macro.\n"
"     macro_rules! many_options {\n"
"         ($value:expr) => { Some($value) };\n"
"         ($value:expr, @) => {\n"
"             Some(Some($value))\n"
"         };\n"
"         ($value:expr, @ $($more:tt)+) => {\n"
"             many_options!(many_options!($value, $($more)+), $($more)+)\n"
"         };\n"
"     }\n"
"\n"
"     fn main() {\n"
"         // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"         // representation of types.\n"
"         unsafe {\n"
"             assert_eq!(many_options!(false), Some(false));\n"
"             assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"             assert_eq!(many_options!(false, @@), "
"Some(Some(Some(Some(false)))));\n"
"\n"
"             println!(\"Bitwise representation of a chain of 128 Option's."
"\");\n"
"             dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"             dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"\n"
"             println!(\"Bitwise representation of a chain of 256 Option's."
"\");\n"
"             dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"\n"
"             println!(\"Bitwise representation of a chain of 257 Option's."
"\");\n"
"             dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"             dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"         }\n"
"     }\n"
"     ```"
msgstr ""

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an\n"
"`impl` block:"
msgstr ""
"Rust ti consente di associare funzioni ai tuoi nuovi tipi. Lo fai con un\n"
"Blocco `impl`:"

#: src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:31
#, fuzzy
msgid ""
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), "
"the first parameter represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method "
"receiver syntax and to help keep them more organized. By using methods we "
"can keep all the implementation code in one predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show "
"how the struct name could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in "
"and can be used elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used "
"to refer to individual fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from "
"`self` by modifying the code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   "
msgstr ""
"* Può essere utile introdurre metodi confrontandoli con funzioni.\n"
"  * I metodi vengono chiamati su un'istanza di un tipo (come struct o enum), "
"il primo parametro rappresenta l'istanza come `self`.\n"
"  * Gli sviluppatori possono scegliere di utilizzare i metodi per sfruttare "
"la sintassi del ricevitore del metodo e per mantenerli più organizzati. "
"Utilizzando i metodi possiamo mantenere tutto il codice di implementazione "
"in un posto prevedibile.\n"
"* Sottolinea l'uso della parola chiave `self`, un ricevitore di metodo.\n"
"  * Mostra che è un termine abbreviato per `self:&Self` e forse mostra come "
"potrebbe essere usato anche il nome struct.\n"
"  * Spiega che `Self` è un alias di tipo per il tipo in cui si trova il "
"blocco `impl` e può essere utilizzato altrove nel blocco.\n"
"  * Nota come `self` viene utilizzato come altre strutture e la notazione "
"con punto può essere utilizzata per fare riferimento a singoli campi.\n"
"  * Questo potrebbe essere un buon momento per dimostrare in che modo "
"`&self` differisce da `self` modificando il codice e provando a eseguire "
"say_hello due volte.\n"
"* Di seguito descriviamo la distinzione tra ricevitori di metodi.\n"
"   "

#: src/methods/receiver.md:1
#, fuzzy
msgid "# Method Receiver"
msgstr "# Ricevitore del metodo"

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There\n"
"are other possible receivers for a method:"
msgstr ""
"Il `&self` sopra indica che il metodo prende in prestito l'oggetto in modo "
"immutabile. Là\n"
"sono altri possibili ricevitori per un metodo:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and "
"mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. "
"The\n"
"  method becomes the owner of the object. The object will be dropped "
"(deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted. Complete ownership does not automatically mean mutability.\n"
"* `mut self`: same as above, but the method can mutate the object. \n"
"* No receiver: this becomes a static method on the struct. Typically used "
"to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: prende in prestito l'oggetto dal chiamante usando un oggetto "
"condiviso e immutabile\n"
"  riferimento. L'oggetto può essere riutilizzato in seguito.\n"
"* `&mut self`: prende in prestito l'oggetto dal chiamante usando un oggetto "
"unico e mutabile\n"
"  riferimento. L'oggetto può essere riutilizzato in seguito.\n"
"* `self`: assume la proprietà dell'oggetto e lo allontana dal chiamante. IL\n"
"  metodo diventa il proprietario dell'oggetto. L'oggetto verrà eliminato "
"(deallocato)\n"
"  quando il metodo ritorna, a meno che la sua proprietà non sia esplicita\n"
"  trasmesso.\n"
"* `mut self`: come sopra, ma mentre il metodo possiede l'oggetto, può farlo\n"
"  muta anche questo. Proprietà completa non significa automaticamente "
"mutabilità.\n"
"* Nessun ricevitore: questo diventa un metodo statico sulla struttura. "
"Tipicamente utilizzato per\n"
"  creare costruttori che sono chiamati \"nuovi\" per convenzione."

#: src/methods/receiver.md:18
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper types](https://doc.rust-lang.org/reference/special-types-"
"and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"Oltre alle varianti su \"self\", ci sono anche\n"
"[tipi di wrapper speciali](https://doc.rust-lang.org/reference/special-types-"
"and-traits.html)\n"
"possono essere tipi di ricevitore, come `Box<Self>`."

#: src/methods/receiver.md:24
#, fuzzy
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It "
"isn't possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) "
"method on it."
msgstr ""
"Prendi in considerazione l'enfasi su \"condiviso e immutabile\" e \"unico e "
"mutevole\". Questi vincoli arrivano sempre\n"
"insieme in Rust a causa delle regole del correttore in prestito, e \"self\" "
"non fa eccezione. Non è possibile\n"
"fare riferimento a una struttura da più posizioni e chiamare un metodo "
"mutante (`&mut self`) su di essa."

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
#, fuzzy
msgid "# Example"
msgstr "# Esempio"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
"access to self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:47
#, fuzzy
msgid ""
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` "
"twice.\n"
"* Note that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"* Tutti e quattro i metodi qui usano un ricevitore metodo diverso.\n"
"  * Puoi indicare come ciò cambia ciò che la funzione può fare con i valori "
"delle variabili e se/come può essere riutilizzata in `main`.\n"
"  * Puoi mostrare l'errore che appare quando provi a chiamare `finish` due "
"volte.\n"
"* Si noti che sebbene i destinatari del metodo siano diversi, le funzioni "
"non statiche sono chiamate allo stesso modo nel corpo principale. Rust "
"abilita la referenziazione e la dereferenziazione automatica quando si "
"chiamano i metodi. Rust aggiunge automaticamente `&`, `*`, `muts` in modo "
"che quell'oggetto corrisponda alla firma del metodo.\n"
"* Potresti sottolineare che `print_laps` sta usando un vettore che viene "
"iterato. Descriviamo i vettori in modo più dettagliato nel pomeriggio."

#: src/pattern-matching.md:1
#, fuzzy
msgid "# Pattern Matching"
msgstr "# Corrispondenza modello"

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. "
"The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"La parola chiave `match` ti consente di confrontare un valore con uno o più "
"_pattern_. IL\n"
"i confronti vengono effettuati dall'alto verso il basso e vince la prima "
"partita."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr ""
"I modelli possono essere valori semplici, in modo simile a `switch` in C e C+"
"+:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr ""
"Il modello `_` è un modello di caratteri jolly che corrisponde a qualsiasi "
"valore."

#: src/pattern-matching.md:26
#, fuzzy
msgid ""
"* You might point out how some specific characters are being used when in a "
"pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages.\n"
"   "
msgstr ""
"* Potresti sottolineare come vengono utilizzati alcuni caratteri specifici "
"quando in uno schema\n"
"  * `|` come `o`\n"
"  * `..` può espandersi quanto deve essere\n"
"  * `1..=5` rappresenta un intervallo inclusivo\n"
"  * `_` è un carattere jolly\n"
"* Può essere utile mostrare come funziona l'associazione, ad esempio "
"sostituendo un carattere jolly con una variabile o rimuovendo le virgolette "
"intorno a `q`.\n"
"* Puoi dimostrare la corrispondenza su un riferimento.\n"
"* Questo potrebbe essere un buon momento per far emergere il concetto di "
"modelli inconfutabili, poiché il termine può apparire nei messaggi di "
"errore.\n"
"   "

#: src/pattern-matching/destructuring-enums.md:1
#, fuzzy
msgid "# Destructuring Enums"
msgstr "# Destrutturazione delle enum"

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how\n"
"you inspect the structure of your types. Let us start with a simple `enum` "
"type:"
msgstr ""
"I modelli possono anche essere usati per associare variabili a parti dei "
"tuoi valori. Questo è come\n"
"ispezioni la struttura dei tuoi tipi. Iniziamo con un semplice tipo `enum`:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the "
"first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm,\n"
"`msg` is bound to the error message."
msgstr ""
"Qui abbiamo usato le braccia per _destrutturare_ il valore `Result`. Nel "
"primo\n"
"arm, \"half\" è legato al valore all'interno della variante \"Ok\". Nel "
"secondo braccio,\n"
"`msg` è associato al messaggio di errore."

#: src/pattern-matching/destructuring-enums.md:36
#, fuzzy
msgid ""
"* The `if`/`else` expression is returning an enum that is later unpacked "
"with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying "
"the errors when running the code. Point out the places where your code is "
"now inexhaustive and how the compiler tries to give you hints."
msgstr ""
"* L'espressione `if`/`else` restituisce un enum che viene successivamente "
"decompresso con un `match`.\n"
"* Puoi provare ad aggiungere una terza variante alla definizione enum e "
"visualizzare gli errori durante l'esecuzione del codice. Indica i punti in "
"cui il tuo codice è ora inesausto e come il compilatore cerca di darti "
"suggerimenti."

#: src/pattern-matching/destructuring-structs.md:1
#, fuzzy
msgid "# Destructuring Structs"
msgstr "# Strutture destrutturanti"

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "Puoi anche destrutturare `structs`:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were "
"ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
#, fuzzy
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"* The distinction between a capture and a constant expression can be hard "
"to\n"
"  spot. Try changing the `2` in the second arm to a variable, and see that "
"it subtly\n"
"  doesn't work. Change it to a `const` and see it working again."
msgstr ""
"* Cambia i valori letterali in `foo` in modo che corrispondano agli altri "
"modelli.\n"
"* Aggiungi un nuovo campo a \"Foo\" e apporta le modifiche al modello "
"secondo necessità.\n"
"* La distinzione tra una cattura e un'espressione costante può essere "
"difficile da fare\n"
"  macchiare. Prova a cambiare il \"2\" nel secondo braccio in una variabile "
"e osservalo sottilmente\n"
"  non funziona. Cambialo in un `const` e guardalo funzionare di nuovo."

#: src/pattern-matching/destructuring-arrays.md:1
#, fuzzy
msgid "# Destructuring Arrays"
msgstr "# Array destrutturanti"

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "Puoi destrutturare array, tuple e slice abbinando i loro elementi:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:21
msgid ""
"* Destructuring of slices of unknown length also works with patterns of "
"fixed length.\n"
"\n"
"\n"
"     ```rust,editable\n"
"     fn main() {\n"
"         inspect(&[0, -2, 3]);\n"
"         inspect(&[0, -2, 3, 4]);\n"
"     }\n"
"\n"
"     #[rustfmt::skip]\n"
"     fn inspect(slice: &[i32]) {\n"
"         println!(\"Tell me about {slice:?}\");\n"
"         match slice {\n"
"             &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"             &[1, ..]   => println!(\"First is 1 and the rest were "
"ignored\"),\n"
"             _          => println!(\"All elements were ignored\"),\n"
"         }\n"
"     }\n"
"     ```\n"
"  \n"
"* Create a new pattern using `_` to represent an element. \n"
"* Add more values to the array.\n"
"* Point out that how `..` will expand to account for different number of "
"elements.\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""

#: src/pattern-matching/match-guards.md:1
#, fuzzy
msgid "# Match Guards"
msgstr "# Partita Guardie"

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"Durante la corrispondenza, puoi aggiungere una _guard_ a un pattern. Questo "
"è un booleano arbitrario\n"
"espressione che verrà eseguita se il modello corrisponde:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:23
#, fuzzy
msgid ""
"* Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a "
"pattern with an `|`."
msgstr ""
"* Le guardie di corrispondenza come caratteristica di sintassi separata sono "
"importanti e necessarie quando desideriamo esprimere in modo conciso idee "
"più complesse di quanto i soli schemi consentirebbero.\n"
"* Non sono la stessa cosa dell'espressione `if` separata all'interno del "
"braccio della corrispondenza. Un'espressione `if` all'interno del blocco di "
"diramazione (dopo `=>`) si verifica dopo che è stato selezionato il braccio "
"di corrispondenza. Il fallimento della condizione \"if\" all'interno di quel "
"blocco non comporterà altre braccia\n"
"dell'espressione `match` originale considerata.\n"
"* È possibile utilizzare le variabili definite nel modello nell'espressione "
"if.\n"
"* La condizione definita nella guardia si applica a ogni espressione in un "
"modello con un `|`."

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "# Day 2: Morning Exercises"
msgstr "# Giorno 2: Esercizi mattutini"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Esamineremo i metodi di implementazione in due contesti:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid ""
"* Simple struct which tracks health statistics.\n"
"\n"
"* Multiple structs and enums for a drawing library."
msgstr ""
"* Struttura semplice che tiene traccia delle statistiche sulla salute.\n"
"\n"
"* Strutture multiple ed enum per una libreria di disegni."

#: src/exercises/day-2/health-statistics.md:1
#, fuzzy
msgid "# Health Statistics"
msgstr "# Statistiche sanitarie"

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you\n"
"need to keep track of users' health statistics."
msgstr ""
"Stai lavorando all'implementazione di un sistema di monitoraggio sanitario. "
"Come parte di questo, tu\n"
"necessità di tenere traccia delle statistiche sulla salute degli utenti."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"Inizierai con alcune funzioni stubbed in un blocco `impl` così come in un "
"`User`\n"
"definizione di struttura. Il tuo obiettivo è implementare i metodi eliminati "
"sul file\n"
"`User` `struct` definito nel blocco `impl`."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"methods:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/> e inserisci "
"quello mancante\n"
"metodi:"

#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    height: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn doctor_visits(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:1
#, fuzzy
msgid "# Polygon Struct"
msgstr "# Struttura poligonale"

#: src/exercises/day-2/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make "
"the\n"
"tests pass:"
msgstr ""
"Creeremo una struttura `Polygon` che contiene alcuni punti. Copia il codice "
"qui sotto\n"
"a <https://play.rust-lang.org/> e inserire i metodi mancanti per rendere il "
"file\n"
"i test superano:"

#: src/exercises/day-2/points-polygons.md:7
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Point {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Point {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Circle {\n"
"    // add methods\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part\n"
"of the exercise is to specify those correctly. You don't have to modify the "
"tests."
msgstr ""
"Poiché le firme del metodo mancano nelle dichiarazioni del problema, la "
"parte chiave\n"
"dell'esercizio è specificarli correttamente. Non è necessario modificare i "
"test."

#: src/exercises/day-2/points-polygons.md:120
#, fuzzy
msgid "Other interesting parts of the exercise:"
msgstr "Altre parti interessanti dell'esercizio:"

#: src/exercises/day-2/points-polygons.md:122
#, fuzzy
msgid ""
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be "
"addable via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"* Deriva un tratto `Copy` per alcune strutture, poiché nei test i metodi a "
"volte non prendono in prestito i loro argomenti.\n"
"* Scopri che il tratto `Add` deve essere implementato affinché due oggetti "
"possano essere aggiunti tramite \"+\". Si noti che non discuteremo di "
"farmaci generici fino al giorno 3."

#: src/control-flow.md:1
#, fuzzy
msgid "# Control Flow"
msgstr "# Flusso di controllo"

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes\n"
"the value of the `if` expression. Other control flow expressions work "
"similarly\n"
"in Rust."
msgstr ""
"Come abbiamo visto, \"if\" è un'espressione in Rust. È usato in modo "
"condizionale\n"
"valutare uno dei due blocchi, ma i blocchi possono avere un valore che poi "
"diventa\n"
"il valore dell'espressione \"if\". Altre espressioni del flusso di controllo "
"funzionano in modo simile\n"
"a Ruggine."

#: src/control-flow/blocks.md:1
#, fuzzy
msgid "# Blocks"
msgstr "# Blocchi"

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust contains a sequence of expressions.\n"
"Each block has a value and a type,\n"
"which are those of the last expression of the block:"
msgstr ""
"Un blocco in Rust ha un valore e un tipo: il valore è l'ultima espressione "
"del\n"
"bloccare:"

#: src/control-flow/blocks.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:26
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""

#: src/control-flow/blocks.md:28
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"La stessa regola viene utilizzata per le funzioni: il valore del corpo della "
"funzione è the\n"
"valore di ritorno:"

#: src/control-flow/blocks.md:31
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:44
#, fuzzy
msgid ""
"* The point of this slide is to show that blocks have a type and value in "
"Rust. \n"
"* You can show how the value of the block changes by changing the last line "
"in the block. For instance, adding/removing a semicolon or using a "
"`return`.\n"
"   "
msgstr ""
"* Lo scopo di questa diapositiva è mostrare che i blocchi hanno un tipo e un "
"valore in Rust.\n"
"* Puoi mostrare come cambia il valore del blocco cambiando l'ultima riga nel "
"blocco. Ad esempio, aggiungendo/rimuovendo un punto e virgola o utilizzando "
"un `return`.\n"
"   "

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "# `if` expressions"
msgstr "# Espressioni `if`"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid ""
"You use [`if`\n"
"expressions](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-"
"expressions)\n"
"exactly like `if` statements in other languages:"
msgstr ""
"Tu usi [`if`\n"
"espressioni](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-"
"expressions)\n"
"esattamente come le dichiarazioni `if` in altre lingue:"

#: src/control-flow/if-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:18
#, fuzzy
msgid ""
"In addition, you can use `if` as an expression. The last expression of each\n"
"block becomes the value of the `if` expression:"
msgstr ""
"Inoltre, puoi usare \"if\" come espressione. L'ultima espressione di "
"ciascuno\n"
"block diventa il valore dell'espressione `if`:"

#: src/control-flow/if-expressions.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:35
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example."
msgstr ""

#: src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "# `if let` expressions"
msgstr "# Espressioni `if let`"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid ""
"The [`if let`\n"
"expression](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-"
"let-expressions)\n"
"lets you execute different code depending on whether a value matches a "
"pattern:"
msgstr ""
"Il [`se lasciato`\n"
"espressione](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-"
"let-expressions)\n"
"ti consente di eseguire codice diverso a seconda che un valore corrisponda a "
"un modello:"

#: src/control-flow/if-let-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:18
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:23
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in\n"
"Rust."
msgstr ""
"Vedi [pattern matching](../pattern-matching.md) per maggiori dettagli sui "
"pattern in\n"
"Ruggine."

#: src/control-flow/if-let-expressions.md:23
msgid ""
"* Unlike `match`, `if let` does not have to cover all branches. This can "
"make it more concise than `match`.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern "
"matching.\n"
"* Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-example/"
"flow_control/let_else.html) construct allows to do a destructuring "
"assignment, or if it fails, execute a block which is required to abort "
"normal control flow (with `panic`/`return`/`break`/`continue`):\n"
"\n"
"   ```rust,editable\n"
"   fn main() {\n"
"       println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
"   }\n"
"    \n"
"   fn second_word_to_upper(s: &str) -> Option<String> {\n"
"       let mut it = s.split(' ');\n"
"       let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
"           return None;\n"
"       };\n"
"       Some(item.to_uppercase())\n"
"   }"
msgstr ""

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "# `while` loops"
msgstr "# `while` si ripete"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops)\n"
"works very similar to other languages:"
msgstr ""
"La [parola chiave `while`](https://doc.rust-lang.org/reference/expressions/"
"loop-expr.html#predicate-loops)\n"
"funziona in modo molto simile ad altre lingue:"

#: src/control-flow/while-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "# `while let` loops"
msgstr "# `while let` va in loop"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops)\n"
"variant which repeatedly tests a value against a pattern:"
msgstr ""
"Come con `if let`, c'è un [`while let`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#predicate-pattern-loops)\n"
"variante che verifica ripetutamente un valore rispetto a un modello:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on "
"every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it "
"will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"Qui l'iteratore restituito da `v.iter()` restituirà una `Option<i32>` su "
"ogni\n"
"chiamata a `next()`. Restituisce `Some(x)` finché non è finito, dopodiché lo "
"farà\n"
"restituire \"Nessuno\". Il `while let` ci consente di continuare a scorrere "
"tutti gli elementi."

#: src/control-flow/while-let-expressions.md:26
#, fuzzy
msgid ""
"* Point out that the `while let` loop will keep going as long as the value "
"matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario.\n"
"    "
msgstr ""
"* Fai notare che il ciclo `while let` continuerà finché il valore "
"corrisponde al modello.\n"
"* Potresti riscrivere il ciclo `while let` come un ciclo infinito con "
"un'istruzione if che si interrompe quando non c'è alcun valore da scartare "
"per `iter.next()`. Il `while let` fornisce lo zucchero sintattico per lo "
"scenario di cui sopra.\n"
"    "

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "# `for` loops"
msgstr "# Cicli `for`"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is closely\n"
"related to the [`while let` loop](while-let-expressions.md). It will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"Il [ciclo `for`](https://doc.rust-lang.org/std/keyword.for.html) è "
"strettamente\n"
"relativo al [ciclo `while let`](while-let-expression.md). Lo farà\n"
"chiama automaticamente `into_iter()` sull'espressione e quindi itera su di "
"essa:"

#: src/control-flow/for-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"\n"
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:21
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "Puoi usare `break` e `continue` qui come al solito."

#: src/control-flow/for-expressions.md:25
#, fuzzy
msgid ""
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every "
"other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change "
"vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"* L'iterazione dell'indice non è una sintassi speciale in Rust solo per quel "
"caso.\n"
"* `(0..10)` è un intervallo che implementa un tratto `Iterator`.\n"
"* `step_by` è un metodo che restituisce un altro `Iterator` che salta ogni "
"altro elemento.\n"
"* Modifica gli elementi nel vettore e spiega gli errori del compilatore. "
"Cambia il vettore `v` in modo che sia mutabile e il ciclo for in `for x in v."
"iter_mut()`."

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "# `loop` expressions"
msgstr "# Espressioni `loop`"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#infinite-loops)\n"
"which creates an endless loop."
msgstr ""
"Infine, c'è una [parola chiave `loop`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#infinite-loops)\n"
"che crea un loop infinito."

#: src/control-flow/loop-expressions.md:6
#, fuzzy
msgid "Here you must either `break` or `return` to stop the loop:"
msgstr "Qui devi \"break\" o \"return\" per interrompere il ciclo:"

#: src/control-flow/loop-expressions.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:27
#, fuzzy
msgid ""
"* Break the `loop` with a value (e.g. `break 8`) and print it out.\n"
"* Note that `loop` is the only looping construct which returns a non-"
"trivial\n"
"  value. This is because it's guaranteed to be entered at least once "
"(unlike\n"
"  `while` and `for` loops)."
msgstr ""
"* Interrompi il `loop` con un valore (ad es. `break 8`) e stampalo.\n"
"* Si noti che `loop` è l'unico costrutto di ciclo che restituisce un valore "
"non banale\n"
"  valore. Questo perché è garantito che venga inserito almeno una volta (a "
"differenza di\n"
"  cicli `while` e `for`)."

#: src/control-flow/match-expressions.md:1
#, fuzzy
msgid "# `match` expressions"
msgstr "# Espressioni `match`"

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The [`match` keyword](https://doc.rust-lang.org/reference/expressions/match-"
"expr.html)\n"
"is used to match a value against one or more patterns. In that sense, it "
"works\n"
"like a series of `if let` expressions:"
msgstr ""
"La [parola chiave `match`](https://doc.rust-lang.org/reference/expressions/"
"match-expr.html)\n"
"viene utilizzato per confrontare un valore con uno o più modelli. In questo "
"senso funziona\n"
"come una serie di espressioni `if let`:"

#: src/control-flow/match-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/match-expressions.md:20
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"Come `if let`, ogni braccio di corrispondenza deve avere lo stesso tipo. Il "
"tipo è l'ultimo\n"
"espressione del blocco, se esiste. Nell'esempio precedente, il tipo è `()`."

#: src/control-flow/match-expressions.md:28
#, fuzzy
msgid ""
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::args().next()` returns an `Option<String>`, but we cannot "
"match against `String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our "
"case, this turns `Option<String>` into `Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside "
"`Option`."
msgstr ""
"* Salva l'espressione di corrispondenza in una variabile e stampala.\n"
"* Rimuovi `.as_deref()` e spiega l'errore.\n"
"    * `std::env::args().next()` restituisce un `Option<String>`, ma non "
"possiamo confrontare `String`.\n"
"    * `as_deref()` trasforma una `Opzione<T>` in `Opzione<&T::Target>`. Nel "
"nostro caso, questo trasforma `Option<String>` in `Option<&str>`.\n"
"    * Ora possiamo usare il pattern matching per confrontare con `&str` "
"all'interno di `Option`."

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "# `break` and `continue`"
msgstr "# `interrompi` e `continua`"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"- If you want to exit a loop early, use [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions),\n"
"- If you want to immediately start\n"
"the next iteration use [`continue`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#continue-expressions)."
msgstr ""
"- Se vuoi uscire prima da un ciclo, usa [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions),\n"
"- Se vuoi iniziare subito\n"
"l'iterazione successiva usa [`continue`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#continue-expressions)."

#: src/control-flow/break-continue.md:7
#, fuzzy
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used\n"
"to break out of nested loops:"
msgstr ""
"Sia `continue` che `break` possono facoltativamente accettare un argomento "
"label che viene utilizzato\n"
"per uscire dai cicli nidificati:"

#: src/control-flow/break-continue.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:28
#, fuzzy
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"In questo caso interrompiamo il ciclo esterno dopo 3 iterazioni del ciclo "
"interno."

#: src/std.md:1
#, fuzzy
msgid "# Standard Library"
msgstr "# Libreria standard"

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types\n"
"used by Rust library and programs. This way, two libraries can work "
"together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust viene fornito con una libreria standard che aiuta a stabilire un "
"insieme di tipi comuni\n"
"utilizzato dalla libreria e dai programmi Rust. In questo modo, due librerie "
"possono lavorare insieme\n"
"senza problemi perché entrambi usano lo stesso tipo `Stringa`."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "I tipi di vocabolario comuni includono:"

#: src/std.md:9
#, fuzzy
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional "
"values\n"
"  and [error handling](error-handling.md).\n"
"\n"
"* [`String`](std/string.md): the default string type used for owned data.\n"
"\n"
"* [`Vec`](std/vec.md): a standard extensible vector.\n"
"\n"
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm.\n"
"\n"
"* [`Box`](std/box.md): an owned pointer for heap-allocated data.\n"
"\n"
"* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""
"* [Tipi `Option` e `Result`](std/option-result.md): usati per valori "
"facoltativi\n"
"  e [gestione degli errori](error-handling.md).\n"
"\n"
"* [`String`](std/string.md): il tipo di stringa predefinito utilizzato per i "
"dati di proprietà.\n"
"\n"
"* [`Vec`](std/vec.md): un vettore estensibile standard.\n"
"\n"
"* [`HashMap`](std/hashmap.md): un tipo di mappa hash con un hash "
"configurabile\n"
"  algoritmo.\n"
"\n"
"* [`Box`](std/box.md): un puntatore di proprietà per i dati allocati "
"nell'heap.\n"
"\n"
"* [`Rc`](std/rc.md): un puntatore con conteggio dei riferimenti condiviso "
"per i dati allocati nell'heap."

#: src/std.md:25
#, fuzzy
msgid ""
"  * In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as "
"`Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"  * Infatti, Rust contiene diversi strati della Libreria Standard: `core`, "
"`alloc` e `std`.\n"
"  * `core` include i tipi e le funzioni più basilari che non dipendono da "
"`libc`, allocator o\n"
"    anche la presenza di un sistema operativo.\n"
"  * `alloc` include tipi che richiedono un allocatore heap globale, come "
"`Vec`, `Box` e `Arc`.\n"
"  * Le applicazioni embedded di Rust spesso usano solo `core` e talvolta "
"`alloc`."

#: src/std/option-result.md:1
#, fuzzy
msgid "# `Option` and `Result`"
msgstr "# `Opzione` e `Risultato`"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "I tipi rappresentano dati facoltativi:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/option-result.md:18
#, fuzzy
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see "
"on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should "
"be inserted."
msgstr ""
"* `Option` e `Result` sono ampiamente usati non solo nella libreria "
"standard.\n"
"* `Option<&T>` ha un sovraccarico di spazio pari a zero rispetto a `&T`.\n"
"* `Result` è il tipo standard per implementare la gestione degli errori, "
"come vedremo il giorno 3.\n"
"* `binary_search` restituisce `Result<usize, usize>`.\n"
"  * Se trovato, `Result::Ok` contiene l'indice in cui si trova l'elemento.\n"
"  * Altrimenti, `Result::Err` contiene l'indice in cui tale elemento "
"dovrebbe essere inserito."

#: src/std/string.md:1
#, fuzzy
msgid "# String"
msgstr "# Corda"

#: src/std/string.md:3
#, fuzzy
msgid ""
"[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`][1] è il buffer di stringa UTF-8 espandibile allocato nell'heap "
"standard:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"🇨🇭\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can "
"call all\n"
"`str` methods on a `String`."
msgstr ""
"`String` implementa [`Deref<Target = str>`][2], il che significa che puoi "
"chiamare tutti\n"
"metodi `str` su una `stringa`."

#: src/std/string.md:30
msgid ""
"* `String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string.\n"
"* `String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters).\n"
"* `String::chars` returns an iterator over the actual characters. Note that "
"a `char` can be different from what a human will consider a \"character\" "
"due to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html).\n"
"*  When people refer to strings they could either be talking about `&str` or "
"`String`.  \n"
"* When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`.\n"
"    * `String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods.\n"
"    * Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;.\n"
"* `String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees.\n"
"* Compare the different ways to index a `String`:\n"
"    * To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-"
"bound, out-of-bounds.\n"
"    * To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""

#: src/std/vec.md:1
#, fuzzy
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
#, fuzzy
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[`Vec`][1] è il buffer ridimensionabile allocato nell'heap standard:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call "
"slice\n"
"methods on a `Vec`."
msgstr ""
"`Vec` implementa [`Deref<Target = [T]>`][2], il che significa che puoi "
"chiamare slice\n"
"metodi su un `Vec`."

#: src/std/vec.md:37
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at "
"compile time. It can grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify "
"`T` explicitly. As always\n"
"  with Rust type inference, the `T` was established during the first `push` "
"call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last "
"element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""

#: src/std/hashmap.md:1
#, fuzzy
msgid "# `HashMap`"
msgstr "# `Mappa hash`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Mappa hash standard con protezione dagli attacchi HashDoS:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les Misérables\") {\n"
"        println!(\"We know about {} books, but not Les Misérables.\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string())."
"or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
msgid ""
"* `HashMap` is not defined in the prelude and needs to be brought into "
"scope.\n"
"* Try the following lines of code. The first line will see if a book is in "
"the hashmap and if not return an alternative value. The second line will "
"insert the alternative value in the hashmap if the book is not found.\n"
"\n"
"     ```rust,ignore\n"
"       let pc1 = page_counts\n"
"           .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"           .unwrap_or(&336);\n"
"       let pc2 = page_counts\n"
"           .entry(\"The Hunger Games\".to_string())\n"
"           .or_insert(374);\n"
"       ```\n"
"* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.\n"
"  * Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1], "
"which allows us to easily initialize a hash map from a literal array:\n"
"\n"
"     ```rust,ignore\n"
"       let page_counts = HashMap::from([\n"
"         (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"         (\"The Hunger Games\".to_string(), 374),\n"
"       ]);\n"
"       ```\n"
"\n"
" * Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples.\n"
"* We are showing `HashMap<String, i32>`, and avoid using `&str` as key to "
"make examples easier. Using references in collections can, of course, be "
"done,\n"
"  but it can lead into complications with the borrow checker.\n"
"  * Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""

#: src/std/box.md:1
#, fuzzy
msgid "# `Box`"
msgstr "# `Scatola`"

#: src/std/box.md:3
#, fuzzy
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1] è un puntatore di proprietà ai dati sull'heap:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"`Box<T>` implementa `Deref<Target = T>`, il che significa che puoi [chiamare "
"metodi\n"
"da `T` direttamente su un `Box<T>`][2]."

#: src/std/box.md:34
#, fuzzy
msgid ""
"* `Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null. \n"
"* In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the "
"Rust compiler wants to know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying "
"large amounts of data on the stack, instead store the data on the heap in a "
"`Box` so only the pointer is moved."
msgstr ""
"* `Box` è come `std::unique_ptr` in C++, tranne per il fatto che è garantito "
"che non sia nullo.\n"
"* Nell'esempio sopra, puoi anche tralasciare `*` nell'istruzione `println!` "
"grazie a `Deref`.\n"
"* Una `Box` può essere utile quando:\n"
"   * hanno un tipo la cui dimensione non può essere conosciuta in fase di "
"compilazione, ma il compilatore Rust vuole conoscere una dimensione esatta.\n"
"   * desidera trasferire la proprietà di una grande quantità di dati. Per "
"evitare di copiare grandi quantità di dati nello stack, archivia invece i "
"dati nell'heap in un \"Box\" in modo che venga spostato solo il puntatore."

#: src/std/box-recursive.md:1
#, fuzzy
msgid "# Box with Recursive Data Structures"
msgstr "# Box con strutture dati ricorsive"

#: src/std/box-recursive.md:3
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"I tipi di dati ricorsivi o i tipi di dati con dimensioni dinamiche devono "
"utilizzare un `Box`:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
"new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"* If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`,\n"
"the compiler would not compute a fixed size of the struct in memory (`List` "
"would be of infinite size).\n"
"\n"
"* `Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next\n"
"element of the `List` in the heap.\n"
"\n"
"* Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly.   \n"
"    "
msgstr ""
"* Se la `Box` non è stata utilizzata qui e abbiamo tentato di incorporare "
"una `Lista` direttamente nella `Lista`,\n"
"il compilatore non calcolerebbe una dimensione fissa della struttura in "
"memoria, sembrerebbe infinita.\n"
"\n"
"* `Box` risolve questo problema poiché ha le stesse dimensioni di un normale "
"puntatore e punta solo al successivo\n"
"elemento della \"Lista\" nell'heap.\n"
"\n"
"* Rimuovi il `Box` nella definizione dell'elenco e mostra l'errore del "
"compilatore. \"Ricorsivo con indiretto\" è un suggerimento che potresti "
"voler utilizzare un Box o un riferimento di qualche tipo, invece di "
"memorizzare direttamente un valore.\n"
"    "

#: src/std/box-niche.md:1
#, fuzzy
msgid "# Niche Optimization"
msgstr "# Ottimizzazione di nicchia"

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. "
"This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"Un `Box` non può essere vuoto, quindi il puntatore è sempre valido e non "
"`null`. Questo\n"
"consente al compilatore di ottimizzare il layout della memoria:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""

#: src/std/rc.md:1
#, fuzzy
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to "
"refer\n"
"to the same data from multiple places:"
msgstr ""
"[`Rc`][1] è un puntatore condiviso con conteggio dei riferimenti. Usalo "
"quando hai bisogno di fare riferimento\n"
"agli stessi dati da più posizioni:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/rc.md:18
#, fuzzy
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the "
"data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create "
"cycles\n"
"  that will get dropped."
msgstr ""
"* Se hai bisogno di mutare i dati all'interno di un `Rc`, dovrai racchiudere "
"i dati\n"
"  un tipo come [`Cell` o `RefCell`][2].\n"
"* Vedere [`Arc`][3] se ci si trova in un contesto multi-thread.\n"
"* Puoi *declassare* un puntatore condiviso in un puntatore [`Weak`][4] per "
"creare cicli\n"
"  che verrà abbandonato."

#: src/std/rc.md:31
#, fuzzy
msgid ""
"* `Rc`'s count ensures that its contained value is valid for as long as "
"there are references.\n"
"* `Rc` in Rust is like `std::shared_ptr` in C++.\n"
"* `Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code.\n"
"* `make_mut` actually clones the inner value if necessary (\"clone-on-"
"write\") and returns a mutable reference.\n"
"* Use `Rc::strong_count` to check the reference count.\n"
"* Compare the different datatypes mentioned. `Box` enables (im)mutable "
"borrows that are enforced at compile time. `RefCell` enables (im)mutable "
"borrows that are enforced at run time and will panic if it fails at "
"runtime.\n"
"* `Rc::downgrade` gives you a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* Il conteggio di `Rc` assicura che il suo valore contenuto sia valido "
"finché ci sono riferimenti.\n"
"* Come `std::shared_ptr` di C++.\n"
"* `Rc::clone` è economico: crea un puntatore alla stessa allocazione e "
"aumenta il conteggio dei riferimenti. Non crea un clone profondo e "
"generalmente può essere ignorato quando si cercano problemi di prestazioni "
"nel codice.\n"
"* `make_mut` in realtà clona il valore interno se necessario (\"clone-on-"
"write\") e restituisce un riferimento mutabile.\n"
"* Usa `Rc::strong_count` per controllare il conteggio dei riferimenti.\n"
"* Confronta i diversi tipi di dati menzionati. `Box` abilita i prestiti "
"(im)mutabili che vengono applicati in fase di compilazione. `RefCell` "
"abilita i prestiti (im)mutabili che vengono applicati in fase di esecuzione "
"e andranno in panico se falliscono in fase di esecuzione.\n"
"* `Rc::downgrade` fornisce un oggetto *debolmente contato* a\n"
"  creare cicli che verranno eliminati correttamente (probabilmente in "
"combinazione con\n"
"  `RefCella`)."

#: src/std/rc.md:41
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;\n"
"\n"
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:1
#, fuzzy
msgid "# Modules"
msgstr "# Moduli"

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Abbiamo visto come i blocchi `impl` ci permettono di utilizzare lo spazio "
"dei nomi per un tipo."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"Allo stesso modo, `mod` ci consente tipi e funzioni dello spazio dei nomi:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:28
#, fuzzy
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable "
"and a library crate compiles to a library.\n"
"* Modules define organization, scope, and are the focus of this section."
msgstr ""
"* I pacchetti forniscono funzionalità e includono un file `Cargo.toml` che "
"descrive come costruire un pacchetto di 1+ casse.\n"
"* I crate sono un albero di moduli, in cui un crate binario crea un "
"eseguibile e un crate di libreria viene compilato in una libreria.\n"
"* I moduli definiscono l'organizzazione, l'ambito e sono il fulcro di questa "
"sezione."

#: src/modules/visibility.md:1
#, fuzzy
msgid "# Visibility"
msgstr "# Visibilità"

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "I moduli sono un limite di privacy:"

#: src/modules/visibility.md:5
#, fuzzy
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all "
"the\n"
"  descendants of `foo`."
msgstr ""
"* Gli elementi del modulo sono privati per impostazione predefinita "
"(nasconde i dettagli di implementazione).\n"
"* Gli elementi dei genitori e dei fratelli sono sempre visibili.\n"
"* In altre parole, se un elemento è visibile nel modulo `foo`, è visibile in "
"tutti i file\n"
"  discendenti di `foo`."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:39
#, fuzzy
msgid "* Use the `pub` keyword to make modules public."
msgstr "* Usa la parola chiave `pub` per rendere pubblici i moduli."

#: src/modules/visibility.md:41
#, fuzzy
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"Inoltre, ci sono specificatori avanzati `pub(...)` per restringere l'ambito "
"della visibilità pubblica."

#: src/modules/visibility.md:43
#, fuzzy
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-"
"and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"* Vedere il [riferimento Rust](https://doc.rust-lang.org/reference/"
"visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself).\n"
"* La configurazione della visibilità di `pub(crate)` è un modello comune.\n"
"* Meno comunemente, puoi dare visibilità a un percorso specifico.\n"
"* In ogni caso, la visibilità deve essere concessa a un modulo predecessore "
"(ea tutti i suoi discendenti)."

#: src/modules/paths.md:1
#, fuzzy
msgid "# Paths"
msgstr "# Percorsi"

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "I percorsi sono risolti come segue:"

#: src/modules/paths.md:5
#, fuzzy
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module.\n"
"\n"
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"1. Come percorso relativo:\n"
"   * `foo` o `self::foo` si riferisce a `foo` nel modulo corrente,\n"
"   * `super::foo` fa riferimento a `foo` nel modulo genitore.\n"
"\n"
"2. Come percorso assoluto:\n"
"   * `crate::foo` fa riferimento a `foo` nella radice del crate corrente,\n"
"   * `bar::foo` si riferisce a `foo` nella cassa `bar`."

#: src/modules/paths.md:13
#, fuzzy
msgid ""
"A module can bring symbols from another module into scope with `use`.\n"
"You will typically see something like this at the top of each module:"
msgstr ""
"Un modulo può portare i simboli di un altro modulo nell'ambito con `use`.\n"
"In genere vedrai qualcosa di simile nella parte superiore di ogni modulo:"

#: src/modules/paths.md:16
msgid ""
"```rust,editable\n"
"use std::collections::HashSet;\n"
"use std::mem::transmute;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:1
#, fuzzy
msgid "# Filesystem Hierarchy"
msgstr "# Gerarchia del file system"

#: src/modules/filesystem.md:3
#, fuzzy
msgid "The module content can be omitted:"
msgstr "Il contenuto del modulo può essere omesso:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
#, fuzzy
msgid "The `garden` module content is found at:"
msgstr "Il contenuto del modulo `garden` si trova in:"

#: src/modules/filesystem.md:11
#, fuzzy
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden.rs` (moderno stile Rust 2018)\n"
"* `src/garden/mod.rs` (vecchio stile Rust 2015)"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr ""
"Allo stesso modo, un modulo `garden::vegetables` può essere trovato in:"

#: src/modules/filesystem.md:16
#, fuzzy
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* `src/garden/vegetables.rs` (moderno stile Rust 2018)\n"
"* `src/garden/vegetables/mod.rs` (vecchio stile Rust 2015)"

#: src/modules/filesystem.md:19
#, fuzzy
msgid "The `crate` root is in:"
msgstr "La radice di `crate` è in:"

#: src/modules/filesystem.md:21
#, fuzzy
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* `src/lib.rs` (per un crate di libreria)\n"
"* `src/main.rs` (per una cassa binaria)"

#: src/modules/filesystem.md:24
#, fuzzy
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\".\n"
"These document the item that contains them -- in this case, a module."
msgstr ""
"Anche i moduli definiti nei file possono essere documentati utilizzando "
"\"commenti interni al documento\".\n"
"Questi documentano l'elemento che li contiene, in questo caso un modulo."

#: src/modules/filesystem.md:27
msgid ""
"```rust,editable,compile_fail\n"
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
"\n"
"// Re-export types from this module.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sow the given seed packets.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
"\n"
"/// Harvest the produce in the garden that is ready.\n"
"pub fn harvest(garden: &mut Garden) { todo!() }\n"
"```"
msgstr ""

#: src/modules/filesystem.md:44
msgid ""
"* The change from `module/mod.rs` to `module.rs` doesn't preclude the use of "
"submodules in Rust 2018.\n"
"  (It was mandatory in Rust 2015.)\n"
"\n"
"  The following is valid:\n"
"\n"
"  ```ignore\n"
"  src/\n"
"  ├── main.rs\n"
"  ├── top_module.rs\n"
"  └── top_module/\n"
"      └── sub_module.rs\n"
"  ```\n"
"\n"
"* The main reason for the change is to prevent many files named `mod.rs`, "
"which can be hard\n"
"  to distinguish in IDEs.\n"
"\n"
"* Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but "
"this can be changed\n"
"  with a compiler directive:\n"
"\n"
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```\n"
"\n"
"  This is useful, for example, if you would like to place tests for a module "
"in a file named\n"
"  `some_module_test.rs`, similar to the convention in Go."
msgstr ""

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "# Day 2: Afternoon Exercises"
msgstr "# Giorno 2: Esercizi pomeridiani"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr ""
"Gli esercizi di questo pomeriggio si concentreranno su stringhe e iteratori."

#: src/exercises/day-2/luhn.md:1
#, fuzzy
msgid "# Luhn Algorithm"
msgstr "# Algoritmo di Luhn"

#: src/exercises/day-2/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to\n"
"validate credit card numbers. The algorithm takes a string as input and does "
"the\n"
"following to validate the credit card number:"
msgstr ""
"L'[algoritmo di Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) viene "
"utilizzato per\n"
"convalidare i numeri di carta di credito. L'algoritmo prende una stringa "
"come input e fa il\n"
"seguente per convalidare il numero della carta di credito:"

#: src/exercises/day-2/luhn.md:7
#, fuzzy
msgid ""
"* Ignore all spaces. Reject number with less than two digits.\n"
"\n"
"* Moving from right to left, double every second digit: for the number "
"`1234`,\n"
"  we double `3` and `1`.\n"
"\n"
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` "
"which\n"
"  becomes `5`.\n"
"\n"
"* Sum all the undoubled and doubled digits.\n"
"\n"
"* The credit card number is valid if the sum ends with `0`."
msgstr ""
"* Ignora tutti gli spazi. Rifiuta il numero con meno di due cifre.\n"
"\n"
"* Spostandoti da destra a sinistra, raddoppia ogni seconda cifra: per il "
"numero `1234`,\n"
"  raddoppiamo \"3\" e \"1\".\n"
"\n"
"* Dopo aver raddoppiato una cifra, somma le cifre. Quindi raddoppiando \"7\" "
"diventa \"14\" which\n"
"  diventa \"5\".\n"
"\n"
"* Somma tutte le cifre non raddoppiate e raddoppiate.\n"
"\n"
"* Il numero della carta di credito è valido se la somma termina con `0`."

#: src/exercises/day-2/luhn.md:19
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"Copia il seguente codice in <https://play.rust-lang.org/> e implementa il "
"file\n"
"funzione:"

#: src/exercises/day-2/luhn.md:23
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:1
#, fuzzy
msgid "# Strings and Iterators"
msgstr "# Stringhe e iteratori"

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The\n"
"server is configured with a number of _path prefixes_ which are matched "
"against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"In questo esercizio, implementerai un componente di instradamento di un "
"server web. IL\n"
"il server è configurato con un numero di _prefissi di percorso_ che vengono "
"confrontati\n"
"_percorsi di richiesta_. I prefissi di percorso possono contenere un "
"carattere jolly che\n"
"corrisponde a un segmento completo. Vedere i test unitari di seguito."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Copia il seguente codice in <https://play.rust-lang.org/> ed esegui i test\n"
"passaggio. Prova a evitare di assegnare un `Vec` per i tuoi risultati "
"intermedi:"

#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-3.md:1
#, fuzzy
msgid "# Welcome to Day 3"
msgstr "# Benvenuto al giorno 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Oggi tratteremo alcuni argomenti più avanzati di Rust:"

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits.\n"
"\n"
"* Generics: generic data types, generic methods, monomorphization, and "
"trait\n"
"  objects.\n"
"\n"
"* Error handling: panics, `Result`, and the try operator `?`.\n"
"\n"
"* Testing: unit tests, documentation tests, and integration tests.\n"
"\n"
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""
"* Tratti: tratti derivati, metodi predefiniti e importante libreria "
"standard\n"
"  tratti.\n"
"\n"
"* Generici: tipi di dati generici, metodi generici, monomorfizzazione e "
"tratto\n"
"  oggetti.\n"
"\n"
"* Gestione degli errori: panic, `Result` e l'operatore try `?`.\n"
"\n"
"* Test: unit test, test di documentazione e test di integrazione.\n"
"\n"
"* Unsafe Rust: puntatori grezzi, variabili statiche, funzioni non sicure ed "
"extern\n"
"  funzioni."

#: src/generics.md:1
#, fuzzy
msgid "# Generics"
msgstr "# Generici"

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract algorithms or data "
"structures\n"
"(such as sorting or a binary tree)\n"
"over the types used or stored."
msgstr ""
"Rust supporta i generici, che ti consentono di astrarre un algoritmo (come "
"l'ordinamento)\n"
"sui tipi utilizzati nell'algoritmo."

#: src/generics/data-types.md:1
#, fuzzy
msgid "# Generic Data Types"
msgstr "# Tipi di dati generici"

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr "Puoi utilizzare i generici per astrarre sul tipo di campo concreto:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/data-types.md:21
msgid ""
"* Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`.\n"
"\n"
"* Fix the code to allow points that have elements of different types."
msgstr ""

#: src/generics/methods.md:1
#, fuzzy
msgid "# Generic Methods"
msgstr "# Metodi generici"

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "Puoi dichiarare un tipo generico sul tuo blocco `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?\n"
"    * This is because it is a generic implementation section for generic "
"type. They are independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods "
"in this block will only be available for `Point<u32>`."
msgstr ""
"* *D:* Perché `T` è specificato due volte in `impl<T> Point<T> {}`? Non è "
"ridondante?\n"
"    * Questo perché si tratta di una sezione di implementazione generica per "
"un tipo generico. Sono indipendentemente generici.\n"
"    * Significa che questi metodi sono definiti per qualsiasi `T`.\n"
"    * È possibile scrivere `impl Point<u32> { .. }`.\n"
"      * `Point` è ancora generico e puoi usare `Point<f64>`, ma i metodi in "
"questo blocco saranno disponibili solo per `Point<u32>`."

#: src/generics/monomorphization.md:1
#, fuzzy
msgid "# Monomorphization"
msgstr "# Monomorfizzazione"

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"Il codice generico viene trasformato in codice non generico in base ai siti "
"di chiamata:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "si comporta come se scrivessi"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"\n"
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"Questa è un'astrazione a costo zero: ottieni esattamente lo stesso risultato "
"che se avessi\n"
"codificato a mano le strutture dati senza l'astrazione."

#: src/traits.md:1
#, fuzzy
msgid "# Traits"
msgstr "# Tratti"

#: src/traits.md:3
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rust ti consente di astrarre sui tipi con tratti. Sono simili alle "
"interfacce:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it "
"anyway.\n"
"    }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &P) {\n"
"    println!(\"Who's a cutie? {} is!\", pet.name());\n"
"}\n"
"\n"
"fn main() {\n"
"    let fido = Dog { name: \"Fido\".into() };\n"
"    greet(&fido);\n"
"\n"
"    let captain_floof = Cat;\n"
"    greet(&captain_floof);\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:1
#, fuzzy
msgid "# Trait Objects"
msgstr "# Oggetti tratto"

#: src/traits/trait-objects.md:3
#, fuzzy
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"Gli oggetti tratto consentono valori di tipi diversi, ad esempio in una "
"raccolta:"

#: src/traits/trait-objects.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it "
"anyway.\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec<Box<dyn Pet>> = vec![\n"
"        Box::new(Cat),\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Hello {}!\", pet.name());\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:40
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Layout della memoria dopo l'allocazione di \"animali domestici\":"

#: src/traits/trait-objects.md:42
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    "
"pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------"
"+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  "
"|           :\n"
":                           :     :     | |   |     +---------------"
"+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                 :\n"
"                                  :     | |   |     +----------------------"
"+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    : \n"
"                                  :     | "
"|                                     : \n"
"                                  :     | |   +-"
"+                               :   \n"
"                                  :     | '-->|"
"\\|                               :     \n"
"                                  :     |     +-"
"+                               :    \n"
"                                  :     "
"|                                       : \n"
"                                  :     |     +----------------------"
"+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" "
"|          : \n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:72
msgid ""
"* Types that implement a given trait may be of different sizes. This makes "
"it impossible to have things like `Vec<Pet>` in the example above.\n"
"* `dyn Pet` is a way to tell the compiler about a dynamically sized type "
"that implements `Pet`.\n"
"* In the example, `pets` holds *fat pointers* to objects that implement "
"`Pet`. The fat pointer consists of two components, a pointer to the actual "
"object and a pointer to the virtual method table for the `Pet` "
"implementation of that particular object.\n"
"* Compare these outputs in the above example:\n"
"     ```rust,ignore\n"
"         println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
"<Cat>());\n"
"         println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
"<&Cat>());\n"
"         println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"         println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
"     ```"
msgstr ""

#: src/traits/deriving-traits.md:1
#, fuzzy
msgid "# Deriving Traits"
msgstr "# Tratti derivati"

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid "You can let the compiler derive a number of traits:"
msgstr "Puoi lasciare che il compilatore derivi una serie di tratti:"

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:1
#, fuzzy
msgid "# Default Methods"
msgstr "# Metodi predefiniti"

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr ""
"I tratti possono implementare il comportamento in termini di altri metodi di "
"tratto:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimeter(i16);\n"
"\n"
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:32
#, fuzzy
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that "
"users are required to\n"
"  implement themselves. Methods with default implementations can rely on "
"required methods.\n"
"\n"
"* Move method `not_equal` to a new trait `NotEqual`.\n"
"\n"
"* Make `Equals` a super trait for `NotEqual`.\n"
"    ```rust,editable,compile_fail\n"
"    trait NotEqual: Equals {\n"
"        fn not_equal(&self, other: &Self) -> bool {\n"
"            !self.equal(other)\n"
"        }\n"
"    }\n"
"    ```\n"
"\n"
"* Provide a blanket implementation of `NotEqual` for `Equal`.\n"
"    ```rust,editable,compile_fail\n"
"    trait NotEqual {\n"
"        fn not_equal(&self, other: &Self) -> bool;\n"
"    }\n"
"\n"
"    impl<T> NotEqual for T where T: Equals {\n"
"        fn not_equal(&self, other: &Self) -> bool {\n"
"            !self.equal(other)\n"
"        }\n"
"    }\n"
"    ```\n"
"  * With the blanket implementation, you no longer need `Equals` as a super "
"trait for `NotEqual`.\n"
"    "
msgstr ""
"* I tratti possono specificare metodi pre-implementati (predefiniti) e "
"metodi richiesti agli utenti\n"
"  implementare se stessi. I metodi con implementazioni predefinite possono "
"fare affidamento sui metodi richiesti.\n"
"\n"
"* Sposta il metodo `not_equal` in un nuovo tratto `NotEqual`.\n"
"\n"
"* Rendi `NotEqual` un super tratto per `Equal`.\n"
"\n"
"* Fornire un'implementazione globale di \"NotEqual\" per \"Equal\".\n"
"  * Con l'implementazione coperta, non hai più bisogno di \"NotEqual\" come "
"super tratto per \"Equal\"."

#: src/traits/trait-bounds.md:1
#, fuzzy
msgid "# Trait Bounds"
msgstr "# Limiti dei tratti"

#: src/traits/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to "
"implement\n"
"some trait, so that you can call this trait's methods."
msgstr ""
"Quando si lavora con i generici, spesso si desidera richiedere i tipi da "
"implementare\n"
"qualche tratto, in modo da poter chiamare i metodi di questo tratto."

#: src/traits/trait-bounds.md:6
#, fuzzy
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "Puoi farlo con `T: Trait` o `impl Trait`:"

#: src/traits/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:35
#, fuzzy
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"Mostra una clausola `where`, gli studenti la incontreranno durante la "
"lettura del codice."

#: src/traits/trait-bounds.md:37
msgid ""
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:46
#, fuzzy
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of \":"
"\" can be arbitrary, like `Option<T>`.\n"
"    "
msgstr ""
"* Riordina la firma della funzione se hai molti parametri.\n"
"* Ha funzionalità aggiuntive che lo rendono più potente.\n"
"    * Se qualcuno lo chiede, la caratteristica extra è che il tipo a "
"sinistra di \":\" può essere arbitrario, come `Option<T>`.\n"
"    "

#: src/traits/impl-trait.md:1
#, fuzzy
msgid "# `impl Trait`"
msgstr "# `Impl Tratto`"

#: src/traits/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"Simile ai limiti dei tratti, in funzione può essere utilizzata una sintassi "
"`impl Trait`\n"
"argomenti e valori restituiti:"

#: src/traits/impl-trait.md:6
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/impl-trait.md:19
#, fuzzy
msgid "* `impl Trait` allows you to work with types which you cannot name."
msgstr "* `impl Trait` ti permette di lavorare con tipi che non puoi nominare."

#: src/traits/impl-trait.md:23
#, fuzzy
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"Il significato di \"impl Trait\" è leggermente diverso nelle diverse "
"posizioni."

#: src/traits/impl-trait.md:25
#, fuzzy
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with "
"a trait bound.\n"
"\n"
"* For a return type, it means that the return type is some concrete type "
"that implements the trait,\n"
"  without naming the type. This can be useful when you don't want to expose "
"the concrete type in a\n"
"  public API.\n"
"\n"
"  Inference is hard in return position. A function returning `impl Foo` "
"picks\n"
"  the concrete type it returns, without writing it out in the source. A "
"function\n"
"  returning a generic type like `collect<B>() -> B` can return any type\n"
"  satisfying `B`, and the caller may need to choose one, such as with `let "
"x:\n"
"  Vec<_> = foo.collect()` or with the turbofish, `foo.collect::<Vec<_>>()`."
msgstr ""
"* Per un parametro, `impl Trait` è come un parametro generico anonimo con un "
"tratto associato.\n"
"\n"
"* Per un tipo restituito, significa che il tipo restituito è un tipo "
"concreto che implementa il tratto,\n"
"  senza nominare il tipo. Questo può essere utile quando non vuoi esporre il "
"tipo concreto in a\n"
"  API pubblica.\n"
"\n"
"  L'inferenza è difficile nella posizione di ritorno. Una funzione che "
"restituisce le scelte `impl Foo`\n"
"  il tipo concreto che restituisce, senza scriverlo nella fonte. Una "
"funzione\n"
"  restituire un tipo generico come `collect<B>() -> B` può restituire "
"qualsiasi tipo\n"
"  soddisfacente `B`, e il chiamante potrebbe aver bisogno di sceglierne uno, "
"come con `let x:\n"
"  Vec<_> = foo.collect()` o con il turbofish, `foo.collect::<Vec<_>>()`."

#: src/traits/impl-trait.md:37
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used "
"a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` "
"type are the same type.\n"
"It would not work for this particular function, as the type we expect as "
"input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, "
"we'd need two\n"
"independent generic parameters."
msgstr ""
"Questo esempio è fantastico, perché utilizza `impl Display` due volte. Aiuta "
"a spiegarlo\n"
"nulla qui impone che sia _lo stesso_ tipo `impl Display`. Se usiamo un "
"singolo\n"
"`T: Display`, imporrebbe il vincolo secondo cui l'input `T` e il tipo "
"restituito `T` sono dello stesso tipo.\n"
"Non funzionerebbe per questa particolare funzione, poiché probabilmente non "
"lo è il tipo che ci aspettiamo come input\n"
"quale `formato!` restituisce. Se volessimo fare lo stesso tramite la "
"sintassi `: Display`, ne avremmo bisogno di due\n"
"parametri generici indipendenti."

#: src/traits/important-traits.md:1
#, fuzzy
msgid "# Important Traits"
msgstr "# Tratti importanti"

#: src/traits/important-traits.md:3
#, fuzzy
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"Vedremo ora alcuni dei tratti più comuni della libreria standard di Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* [`Iterator`][1] e [`IntoIterator`][2] usati nei cicli `for`,\n"
"* [`From`][3] e [`Into`][4] utilizzati per convertire i valori,\n"
"* [`Read`][5] e [`Write`][6] usati per IO,\n"
"* [`Add`][7], [`Mul`][8], ... utilizzato per l'overload degli operatori e\n"
"* [`Drop`][9] usato per definire i distruttori.\n"
"* [`Default`][10] utilizzato per costruire un'istanza predefinita di un tipo."

#: src/traits/iterator.md:1
#, fuzzy
msgid "# Iterators"
msgstr "# Iteratori"

#: src/traits/iterator.md:3
#, fuzzy
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "Puoi implementare il tratto [`Iterator`][1] sui tuoi tipi:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator for Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"* The `Iterator` trait implements many common functional programming "
"operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can "
"find all the documentation\n"
"  about them. In Rust these functions should produce the code as efficient "
"as equivalent imperative\n"
"  implementations.\n"
"    \n"
"* `IntoIterator` is the trait that makes for loops work. It is implemented "
"by collection types such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also "
"implement it. This is why\n"
"  you can iterate over a vector with `for i in some_vec { .. }` but\n"
"  `some_vec.next()` doesn't exist."
msgstr ""
"* Il tratto `Iterator` implementa molte comuni operazioni di programmazione "
"funzionale sulle raccolte\n"
"  (ad es. `map`, `filter`, `reduce`, ecc.). Questo è il tratto in cui puoi "
"trovare tutta la documentazione\n"
"  su di loro. In Rust queste funzioni dovrebbero produrre il codice tanto "
"efficiente quanto imperativo equivalente\n"
"  implementazioni.\n"
"    \n"
"* `IntoIterator` è la caratteristica che fa funzionare i cicli for. È "
"implementato da tipi di raccolta come\n"
"  `Vec<T>` e riferimenti ad essi come `&Vec<T>` e `&[T]`. Anche le gamme lo "
"implementano. Ecco perché\n"
"  puoi iterare su un vettore con `for i in some_vec { .. }` ma\n"
"  `some_vec.next()` non esiste."

#: src/traits/from-iterator.md:1
#, fuzzy
msgid "# FromIterator"
msgstr "# FromIterator"

#: src/traits/from-iterator.md:3
#, fuzzy
msgid ""
"[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr ""
"[`FromIterator`][1] consente di creare una raccolta da un [`Iterator`][2]."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
#, fuzzy
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"Implementa `Iterator`\n"
"`fn collect<B>(self) -> B\n"
"Dove\n"
"    B: FromIterator<Self::Item>,\n"
"    Sé: dimensionato`"

#: src/traits/from-iterator.md:23
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Ci sono anche implementazioni che ti permettono di fare cose interessanti "
"come convertire un file\n"
"`Iterator<Item = Result<V, E>>` in un `Result<Vec<V>, E>`."

#: src/traits/from-into.md:1
#, fuzzy
msgid "# `From` and `Into`"
msgstr "# `Da` e `Into`"

#: src/traits/from-into.md:3
#, fuzzy
msgid ""
"Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr ""
"I tipi implementano [`From`][1] e [`Into`][2] per facilitare le conversioni "
"di tipo:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
#, fuzzy
msgid ""
"[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr ""
"[`Into`][2] viene implementato automaticamente quando [`From`][1] è "
"implementato:"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:29
#, fuzzy
msgid ""
"* That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too.\n"
"* When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that "
"_only_ implement `Into`.\n"
"    "
msgstr ""
"* Ecco perché è comune implementare solo `From`, poiché anche il tuo tipo "
"otterrà l'implementazione di `Into`.\n"
"* Quando si dichiara un tipo di input per l'argomento di una funzione come "
"\"qualsiasi cosa che può essere convertita in una `Stringa`\", la regola è "
"opposta, si dovrebbe usare `Into`.\n"
"  La tua funzione accetterà tipi che implementano `From` e quelli che _solo_ "
"implementano `Into`.\n"
"    "

#: src/traits/read-write.md:1
#, fuzzy
msgid "# `Read` and `Write`"
msgstr "# `Leggi` e `Scrivi`"

#: src/traits/read-write.md:3
#, fuzzy
msgid ""
"Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "Usando [`Read`][1] e [`BufRead`][2], puoi astrarre su fonti `u8`:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
#, fuzzy
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "Allo stesso modo, [`Write`][3] ti consente di astrarre sui sink `u8`:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:1
#, fuzzy
msgid "# The `Drop` Trait"
msgstr "# Il tratto `Drop`"

#: src/traits/drop.md:3
#, fuzzy
msgid ""
"Values which implement [`Drop`][1] can specify code to run when they go out "
"of scope:"
msgstr ""
"I valori che implementano [`Drop`][1] possono specificare il codice da "
"eseguire quando escono dall'ambito:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:34 src/traits/operators.md:26
#, fuzzy
msgid "Discussion points:"
msgstr "Punti di discussione:"

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"* Why doesn't `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end "
"of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* Perché `Drop::drop` non accetta `self`?\n"
"    * Risposta breve: se così fosse, `std::mem::drop` verrebbe chiamato alla "
"fine di\n"
"        il blocco, risultando in un'altra chiamata a `Drop::drop` e uno "
"stack\n"
"        traboccare!\n"
"* Prova a sostituire `drop(a)` con `a.drop()`."

#: src/traits/default.md:1
#, fuzzy
msgid "# The `Default` Trait"
msgstr "# Il tratto `Predefinito`"

#: src/traits/default.md:3
#, fuzzy
msgid "[`Default`][1] trait produces a default value for a type."
msgstr ""
"Il tratto [`Default`][1] fornisce un'implementazione predefinita di un "
"tratto."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/traits/default.md:40
#, fuzzy
msgid ""
"  * It can be implemented directly or it can be derived via "
"`#[derive(Default)]`.\n"
"  * A derived implementation will produce a value where all fields are set "
"to their default values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values (e."
"g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"  * Può essere implementato direttamente o può essere derivato tramite "
"`#[derive(Default)]`.\n"
"  * L'implementazione derivata produrrà un'istanza in cui tutti i campi sono "
"impostati sui valori predefiniti.\n"
"    * Ciò significa che anche tutti i tipi nella struttura devono "
"implementare `Default`.\n"
"  * I tipi Rust standard spesso implementano `Default` con valori "
"ragionevoli (ad esempio `0`, `\"\"`, ecc.).\n"
"  * La copia parziale della struttura funziona bene con default.\n"
"  * La libreria standard di Rust sa che i tipi possono implementare "
"`Default` e fornisce comodi metodi che lo utilizzano."

#: src/traits/operators.md:1
#, fuzzy
msgid "# `Add`, `Mul`, ..."
msgstr "# `Aggiungi`, `Mul`, ..."

#: src/traits/operators.md:3
#, fuzzy
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr ""
"L'overload degli operatori è implementato tramite i tratti in [`std::ops`]"
"[1]:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that "
"useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider "
"overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on "
"the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter of "
"the method?\n"
"    * Short answer: Function type parameters are controlled by the caller, "
"but\n"
"        associated types (like `Output`) are controlled by the implementor "
"of a\n"
"        trait.\n"
"* You could implement `Add` for two different types, e.g.\n"
"  `impl Add<(i32, i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"* Puoi implementare `Aggiungi` per `&Punto`. In quali situazioni è utile?\n"
"    * Risposta: `Add:add` consuma `self`. Se digita \"T\" per cui sei\n"
"        l'overloading dell'operatore non è `Copy`, dovresti considerare "
"l'overloading\n"
"        anche l'operatore per `&T`. Ciò evita inutili clonazioni sul file\n"
"        sito di chiamata.\n"
"* Perché `Output` è un tipo associato? Potrebbe essere reso un parametro di "
"tipo?\n"
"    * Risposta breve: i parametri di tipo sono controllati dal chiamante, "
"ma\n"
"        i tipi associati (come `Output`) sono controllati "
"dall'implementatore di a\n"
"        tratto."

#: src/traits/closures.md:1
#, fuzzy
msgid "# Closures"
msgstr "# Chiusure"

#: src/traits/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Le chiusure o le espressioni lambda hanno tipi che non possono essere "
"nominati. Tuttavia, loro\n"
"implementare speciali [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) e\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) "
"caratteristiche:"

#: src/traits/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
"\n"
"    let mut v = Vec::new();\n"
"    let mut accumulate = |x: i32| {\n"
"        v.push(x);\n"
"        v.iter().sum::<i32>()\n"
"    };\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
"\n"
"    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
"    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
"}\n"
"```"
msgstr ""

#: src/traits/closures.md:34
#, fuzzy
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures\n"
"nothing at all. It can be called multiple times concurrently."
msgstr ""
"Un \"Fn\" non consuma né muta i valori acquisiti, o forse non cattura nulla, "
"quindi può farlo\n"
"essere chiamato più volte contemporaneamente."

#: src/traits/closures.md:37
#, fuzzy
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times,\n"
"but not concurrently."
msgstr ""
"Un `FnMut` potrebbe mutare i valori catturati, quindi puoi chiamarlo più "
"volte ma non contemporaneamente."

#: src/traits/closures.md:40
#, fuzzy
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume\n"
"captured values."
msgstr ""
"Se hai un `FnOnce`, puoi chiamarlo solo una volta. Potrebbe consumare i "
"valori acquisiti."

#: src/traits/closures.md:43
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever "
"an `FnMut` or `FnOnce`\n"
"is called for."
msgstr ""
"\"FnMut\" è un sottotipo di \"FnOnce\". \"Fn\" è un sottotipo di \"FnMut\" e "
"\"FnOnce\". Cioè. puoi usare un\n"
"`FnMut` ovunque sia richiesto un `FnOnce` e puoi usare un `Fn` ovunque sia "
"`FnMut` o `FnOnce`\n"
"è richiesto."

#: src/traits/closures.md:47
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`),\n"
"depending on what the closure captures."
msgstr ""

#: src/traits/closures.md:50
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture\n"
"by value."
msgstr ""

#: src/traits/closures.md:52
msgid ""
"```rust,editable\n"
"fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
"    return move |name| println!(\"{} {}\", prefix, name)\n"
"}\n"
"\n"
"fn main() {\n"
"    let hi = make_greeter(\"Hi\".to_string());\n"
"    hi(\"there\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "# Day 3: Morning Exercises"
msgstr "# Giorno 3: Esercizi mattutini"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library traits and trait objects."
msgstr "Progetteremo una libreria GUI classica di tratti e oggetti di tratto."

#: src/exercises/day-3/simple-gui.md:1
#, fuzzy
msgid "# A Simple GUI Library"
msgstr "# Una semplice libreria GUI"

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"Progettiamo una libreria GUI classica utilizzando la nostra nuova conoscenza "
"dei tratti e\n"
"oggetti di tratto."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "Avremo una serie di widget nella nostra libreria:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Window`: ha un `title` e contiene altri widget.\n"
"* `Button`: ha una `label` e una funzione di callback che viene richiamata "
"quando il\n"
"  pulsante viene premuto.\n"
"* `Etichetta`: ha una `etichetta`."

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "I widget implementeranno un tratto `Widget`, vedi sotto."

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/>, inserisci i "
"campi mancanti\n"
"metodi `draw_into` in modo da implementare il tratto `Widget`:"

#: src/exercises/day-3/simple-gui.md:18
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr ""
"L'output del programma sopra può essere qualcosa di semplice come questo:"

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========\n"
"\n"
"This is a small text GUI demo.\n"
"\n"
"| Click me! |\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:142
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index."
"html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"Se vuoi disegnare un testo allineato, puoi usare il\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index."
"html#fillalignment)\n"
"operatori di formattazione. In particolare, nota come puoi riempire con "
"diversi\n"
"caratteri (qui un `'/'`) e come puoi controllare l'allineamento:"

#: src/exercises/day-3/simple-gui.md:147
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:156
#, fuzzy
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Usando tali trucchi di allineamento, puoi ad esempio produrre un output come "
"questo:"

#: src/exercises/day-3/simple-gui.md:158
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/error-handling.md:1
#, fuzzy
msgid "# Error Handling"
msgstr "# Gestione degli errori"

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"La gestione degli errori in Rust viene eseguita utilizzando un flusso di "
"controllo esplicito:"

#: src/error-handling.md:5
#, fuzzy
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* Le funzioni che possono avere errori lo elencano nel loro tipo di "
"ritorno,\n"
"* Non ci sono eccezioni."

#: src/error-handling/panics.md:1
#, fuzzy
msgid "# Panics"
msgstr "# Panico"

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr ""
"Rust attiverà un panico se si verifica un errore fatale in fase di "
"esecuzione:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panics.md:12
#, fuzzy
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* I panico sono per errori irrecuperabili e imprevisti.\n"
"  * I panici sono sintomi di bug nel programma.\n"
"* Usa API senza panico (come `Vec::get`) se il crash non è accettabile."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "# Catching the Stack Unwinding"
msgstr "# Catturare lo srotolamento della pila"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"Per impostazione predefinita, un panico causerà lo srotolamento dello stack. "
"Lo svolgimento può essere catturato:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {\n"
"        println!(\"hello!\");\n"
"    });\n"
"    assert!(result.is_ok());\n"
"    \n"
"    let result = panic::catch_unwind(|| {\n"
"        panic!(\"oh no!\");\n"
"    });\n"
"    assert!(result.is_err());\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:21
#, fuzzy
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* Questo può essere utile nei server che dovrebbero continuare a funzionare "
"anche se un singolo\n"
"  la richiesta va in crash.\n"
"* Questo non funziona se `panic = 'abort'` è impostato nel tuo `Cargo.toml`."

#: src/error-handling/result.md:1
#, fuzzy
msgid "# Structured Error Handling with `Result`"
msgstr "# Gestione strutturata degli errori con `Result`"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are\n"
"expected as part of normal operation:"
msgstr ""
"Abbiamo già visto l'enumerazione `Result`. Questo è usato in modo pervasivo "
"quando ci sono errori\n"
"previsto come parte del normale funzionamento:"

#: src/error-handling/result.md:6
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = fs::File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing "
"the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where "
"an error should never happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the "
"developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but "
"it is worth mentioning. \n"
"    It contains a lot of convenience methods and functions that help "
"functional-style programming. \n"
"    "
msgstr ""
"  * Come con `Option`, il valore riuscito si trova all'interno di `Result`, "
"costringendo lo sviluppatore a farlo\n"
"    estrarlo esplicitamente. Questo incoraggia il controllo degli errori. "
"Nel caso in cui non dovesse mai verificarsi un errore,\n"
"    È possibile chiamare `unwrap()` o `expect()`, e anche questo è un "
"segnale dell'intenzione dello sviluppatore.\n"
"  * La documentazione `Result` è una lettura consigliata. Non durante il "
"corso, ma vale la pena menzionarlo.\n"
"    Contiene molti metodi e funzioni utili che aiutano la programmazione in "
"stile funzionale.\n"
"    "

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "# Propagating Errors with `?`"
msgstr "# Propagazione degli errori con `?`"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn\n"
"the common"
msgstr ""
"L'operatore try `?` viene utilizzato per restituire errori al chiamante. Ti "
"fa girare\n"
"il comune"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "nel molto più semplice"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handling code:"
msgstr ""
"Possiamo usarlo per semplificare il nostro codice di gestione degli errori:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, "
"empty file, file with username."
msgstr ""
"* La variabile `username` può essere `Ok(string)` o `Err(error)`.\n"
"* Usa la chiamata `fs::write` per testare i diversi scenari: nessun file, "
"file vuoto, file con nome utente."

#: src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
#, fuzzy
msgid "# Converting Error Types"
msgstr "# Conversione dei tipi di errore"

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"L'effettiva espansione di `?` è un po' più complicata di quanto "
"precedentemente indicato:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "funziona allo stesso modo di"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to "
"the\n"
"type returned by the function:"
msgstr ""
"La chiamata `From::from` qui significa che tentiamo di convertire il tipo di "
"errore in\n"
"tipo restituito dalla funzione:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error for ReadUsernameError {}\n"
"\n"
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username "
"in {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types-example.md:55
#, fuzzy
msgid ""
"It is good practice for all error types to implement `std::error::Error`, "
"which requires `Debug` and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too "
"where possible, to make\n"
"life easier for tests and consumers of your library. In this case we can't "
"easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"È buona pratica per tutti i tipi di errore implementare `std::error::Error`, "
"che richiede `Debug` e\n"
"`Display`. In genere è utile per loro implementare anche `Clone` e `Eq`, ove "
"possibile, per fare\n"
"vita più facile per i test e i consumatori della tua libreria. In questo "
"caso non possiamo farlo facilmente, perché\n"
"`io::Error` non li implementa."

#: src/error-handling/deriving-error-enums.md:1
#, fuzzy
msgid "# Deriving Error Enums"
msgstr "# Derivazione delle enumerazioni degli errori"

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an\n"
"error enum like we did on the previous page:"
msgstr ""
"Il crate [thiserror](https://docs.rs/thiserror/) è un modo popolare per "
"creare un\n"
"error enum come abbiamo fatto nella pagina precedente:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the "
"`#[from]` attribute is added).\n"
"It also works for structs."
msgstr ""
"La macro deriva di `thiserror` implementa automaticamente `std::error::"
"Error` e facoltativamente `Display`\n"
"(se vengono forniti gli attributi `#[error(...)]`) e `From` (se viene "
"aggiunto l'attributo `#[from]`).\n"
"Funziona anche per le strutture."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr ""
"Non influisce sulla tua API pubblica, il che lo rende utile per le librerie."

#: src/error-handling/dynamic-errors.md:1
#, fuzzy
msgid "# Dynamic Error Types"
msgstr "# Tipi di errori dinamici"

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"A volte vogliamo consentire la restituzione di qualsiasi tipo di errore "
"senza scrivere la nostra copertura enum\n"
"tutte le diverse possibilità. `std::error::Error` lo rende facile."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` "
"in the public API of a\n"
"library, but it can be a good option in a program where you just want to "
"display the error message\n"
"somewhere."
msgstr ""
"Ciò consente di risparmiare sul codice, ma rinuncia alla possibilità di "
"gestire in modo pulito diversi casi di errore in modo diverso\n"
"il programma. Pertanto, generalmente non è una buona idea utilizzare "
"`Box<dyn Error>` nell'API pubblica di a\n"
"library, ma può essere una buona opzione in un programma in cui si desidera "
"solo visualizzare il messaggio di errore\n"
"in qualche luogo."

#: src/error-handling/error-contexts.md:1
#, fuzzy
msgid "# Adding Context to Errors"
msgstr "# Aggiunta di contesto agli errori"

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"La cassa ampiamente utilizzata [comunque](https://docs.rs/anyhow/) può "
"aiutarti ad aggiungere\n"
"informazioni contestuali ai tuoi errori e ti permette di averne meno\n"
"tipi di errore personalizzati:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not\n"
"  a good choice for the public API of a library, but is widely used in "
"applications.\n"
"* Actual error type inside of it can be extracted for examination if "
"necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* `comunque::Risultato<V>` è un alias di tipo per `Risultato<V, comunque::"
"Errore>`.\n"
"* `anyhow::Error` è essenzialmente un wrapper attorno a `Box<dyn Error>`. In "
"quanto tale, generalmente non lo è\n"
"  una buona scelta per l'API pubblica di una libreria, ma è ampiamente "
"utilizzata nelle applicazioni.\n"
"* Il tipo di errore effettivo all'interno di esso può essere estratto per "
"l'esame, se necessario.\n"
"* La funzionalità fornita da `anyhow::Result<T>` potrebbe essere familiare "
"agli sviluppatori Go, in quanto fornisce\n"
"  modelli di utilizzo ed ergonomia simili a `(T, errore)` di Go."

#: src/testing.md:1
#, fuzzy
msgid "# Testing"
msgstr "# Test"

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust e Cargo sono dotati di un semplice framework di unit test:"

#: src/testing.md:5
#, fuzzy
msgid ""
"* Unit tests are supported throughout your code.\n"
"\n"
"* Integration tests are supported via the `tests/` directory."
msgstr ""
"* I test unitari sono supportati in tutto il codice.\n"
"\n"
"* I test di integrazione sono supportati tramite la directory `tests/`."

#: src/testing/unit-tests.md:1
#, fuzzy
msgid "# Unit Tests"
msgstr "# Test unitari"

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Contrassegna i test unitari con `#[test]`:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "Usa `cargo test` per trovare ed eseguire i test unitari."

#: src/testing/test-modules.md:1
#, fuzzy
msgid "# Test Modules"
msgstr "# Moduli di prova"

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"I test unitari vengono spesso inseriti in un modulo nidificato (esegui test "
"sul file\n"
"[Parco giochi](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
#, fuzzy
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* Questo ti consente di testare unitamente gli aiutanti privati.\n"
"* L'attributo `#[cfg(test)]` è attivo solo quando esegui `cargo test`."

#: src/testing/doc-tests.md:1
#, fuzzy
msgid "# Documentation Tests"
msgstr "# Test di documentazione"

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust ha il supporto integrato per i test di documentazione:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
#, fuzzy
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* I blocchi di codice nei commenti `///` sono visti automaticamente come "
"codice Rust.\n"
"* Il codice verrà compilato ed eseguito come parte di `cargo test`.\n"
"* Prova il codice precedente su [Rust Playground](https://play.rust-lang."
"org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:1
#, fuzzy
msgid "# Integration Tests"
msgstr "# Test di integrazione"

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Se desideri testare la tua libreria come client, utilizza un test di "
"integrazione."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Crea un file `.rs` in `tests/`:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Questi test hanno accesso solo all'API pubblica del tuo crate."

#: src/testing/useful-crates.md:1
#, fuzzy
msgid "## Useful crates for writing tests"
msgstr "# Casse utili"

#: src/testing/useful-crates.md:3
#, fuzzy
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust ha il supporto integrato per i test di documentazione:"

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr ""

#: src/testing/useful-crates.md:7
msgid ""
"* [googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++.\n"
"* [proptest](https://docs.rs/proptest): Property-based testing for Rust.\n"
"* [rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""

#: src/unsafe.md:1
#, fuzzy
msgid "# Unsafe Rust"
msgstr "# Ruggine non sicura"

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Il linguaggio Rust ha due parti:"

#: src/unsafe.md:5
#, fuzzy
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"* **Safe Rust:** memoria sicura, nessun comportamento indefinito possibile.\n"
"* **Unsafe Rust:** può attivare un comportamento indefinito se vengono "
"violate le precondizioni."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know\n"
"what Unsafe Rust is."
msgstr ""
"Vedremo Rust per lo più sicuro in questo corso, ma è importante saperlo\n"
"cos'è Unsafe Rust."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"Il codice non sicuro è solitamente piccolo e isolato e la sua correttezza "
"dovrebbe essere attentamente\n"
"documentato. Di solito è racchiuso in uno strato di astrazione sicuro."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Unsafe Rust ti dà accesso a cinque nuove funzionalità:"

#: src/unsafe.md:16
#, fuzzy
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* Dereferenzia i puntatori grezzi.\n"
"* Accedi o modifica variabili statiche mutabili.\n"
"* Accedi ai campi `union`.\n"
"* Richiama funzioni `non sicure`, comprese le funzioni `extern`.\n"
"* Implementa i tratti \"non sicuri\"."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please "
"see\n"
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"Tratteremo brevemente le capacità non sicure in seguito. Per tutti i "
"dettagli, vedere\n"
"[Capitolo 19.1 nel Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html)\n"
"e il [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Unsafe Rust non significa che il codice non sia corretto. Significa che gli "
"sviluppatori hanno\n"
"ha disattivato le funzionalità di sicurezza del compilatore e deve scrivere "
"il codice corretto\n"
"loro stessi. Significa che il compilatore non applica più le regole di "
"sicurezza della memoria di Rust."

#: src/unsafe/raw-pointers.md:1
#, fuzzy
msgid "# Dereferencing Raw Pointers"
msgstr "# Dereferenziazione dei puntatori grezzi"

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"La creazione di puntatori è sicura, ma la loro dereferenziazione richiede "
"`unsafe`:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:27
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety "
"requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"È buona norma (e richiesto dalla guida allo stile di Android Rust) scrivere "
"un commento per ciascuno\n"
"Blocco `unsafe` che spiega come il codice al suo interno soddisfi i "
"requisiti di sicurezza dell'unsafe\n"
"operazioni che sta compiendo."

#: src/unsafe/raw-pointers.md:31
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"Nel caso di dereferenze puntatore, ciò significa che i puntatori devono "
"essere\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), ovvero:"

#: src/unsafe/raw-pointers.md:34
#, fuzzy
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object "
"must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * Il puntatore deve essere diverso da null.\n"
" * Il puntatore deve essere _dereferenceable_ (entro i limiti di un singolo "
"oggetto allocato).\n"
" * L'oggetto non deve essere stato deallocato.\n"
" * Non devono esserci accessi contemporanei alla stessa posizione.\n"
" * Se il puntatore è stato ottenuto lanciando un riferimento, l'oggetto "
"sottostante deve essere live e no\n"
"   riferimento può essere utilizzato per accedere alla memoria."

#: src/unsafe/raw-pointers.md:41
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"Nella maggior parte dei casi anche il puntatore deve essere correttamente "
"allineato."

#: src/unsafe/mutable-static-variables.md:1
#, fuzzy
msgid "# Mutable Static Variables"
msgstr "# Variabili statiche mutabili"

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "È sicuro leggere una variabile statica immutabile:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr ""
"Tuttavia, poiché possono verificarsi corse di dati, non è sicuro leggere e "
"scrivere mutabili\n"
"variabili statiche:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working "
"with some C APIs."
msgstr ""
"L'uso di una statica mutabile è generalmente una cattiva idea, ma ci sono "
"alcuni casi in cui potrebbe avere senso\n"
"nel codice `no_std` di basso livello, come implementare un allocatore di "
"heap o lavorare con alcune API C."

#: src/unsafe/unions.md:1
#, fuzzy
msgid "# Unions"
msgstr "# Sindacati"

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Le unioni sono come le enum, ma devi monitorare tu stesso il campo attivo:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed\n"
"for interacting with C library APIs."
msgstr ""
"Le unioni sono molto raramente necessarie in Rust poiché di solito puoi "
"usare un enum. Occasionalmente sono necessari\n"
"per interagire con le API della libreria C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably "
"want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"Se vuoi solo reinterpretare i byte come un tipo diverso, probabilmente lo "
"vuoi\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) o una cassaforte\n"
"wrapper come la cassa [`zerocopy`](https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:1
#, fuzzy
msgid "# Calling Unsafe Functions"
msgstr "# Chiamata di funzioni non sicure"

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"Una funzione o un metodo può essere contrassegnato come \"non sicuro\" se ha "
"precondizioni aggiuntive\n"
"deve sostenere per evitare comportamenti indefiniti:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"🗻∈🌏\";\n"
"\n"
"    // Safe because the indices are in the correct order, within the bounds "
"of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..7) }));\n"
"\n"
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:1
#, fuzzy
msgid "# Writing Unsafe Functions"
msgstr "# Scrittura di funzioni non sicure"

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined\n"
"behaviour."
msgstr ""
"Puoi contrassegnare le tue funzioni come \"non sicure\" se richiedono "
"condizioni particolari per evitare undefined\n"
"comportamento."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"In realtà non useremmo i puntatori per questo perché può essere fatto in "
"sicurezza con i riferimenti."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see "
"what happens."
msgstr ""
"Si noti che il codice non sicuro è consentito all'interno di una funzione "
"non sicura senza un blocco `unsafe`. Noi possiamo\n"
"proibiscilo con `#[deny(unsafe_op_in_unsafe_fn)]`. Prova ad aggiungerlo e "
"guarda cosa succede."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "# Calling External Code"
msgstr "# Chiamata codice esterno"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. "
"Calling\n"
"them is thus unsafe:"
msgstr ""
"Le funzioni di altri linguaggi potrebbero violare le garanzie di Rust. "
"Chiamata\n"
"loro è quindi pericoloso:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might\n"
"violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any\n"
"arbitrary circumstances."
msgstr ""
"Questo di solito è solo un problema per le funzioni esterne che fanno cose "
"con i puntatori che potrebbero\n"
"violare il modello di memoria di Rust, ma in generale qualsiasi funzione C "
"potrebbe avere un comportamento indefinito sotto qualsiasi\n"
"circostanze arbitrarie."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available too](https://doc.rust-lang.org/reference/items/"
"external-blocks.html)."
msgstr ""

#: src/unsafe/unsafe-traits.md:1
#, fuzzy
msgid "# Implementing Unsafe Traits"
msgstr "# Implementazione di tratti non sicuri"

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"Come con le funzioni, puoi contrassegnare un tratto come \"non sicuro\" se "
"l'implementazione deve garantire\n"
"condizioni particolari per evitare comportamenti indefiniti."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes."
"html):"
msgstr ""
"Ad esempio, la cassa \"zerocopy\" ha un tratto non sicuro che sembra\n"
"[qualcosa del genere](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes."
"html):"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Dovrebbe esserci una sezione `# Safety` su Rustdoc per il tratto che spiega "
"i requisiti per\n"
"il tratto da implementare in modo sicuro."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"L'attuale sezione sulla sicurezza per `AsBytes` è piuttosto lunga e "
"complicata."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "I tratti incorporati \"Invia\" e \"Sincronizza\" non sono sicuri."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "# Day 3: Afternoon Exercises"
msgstr "# Giorno 3: Esercizi pomeridiani"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "Costruiamo un wrapper sicuro per leggere il contenuto della directory!"

#: src/exercises/day-3/afternoon.md:5
msgid ""
"For this exercise, we suggest using a local dev environment instead\n"
"of the Playground. This will allow you to run your binary on your own "
"machine."
msgstr ""

#: src/exercises/day-3/afternoon.md:8
msgid "To get started, follow the [running locally] instructions."
msgstr ""

#: src/exercises/day-3/afternoon.md:14
#, fuzzy
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr ""
"Dopo aver esaminato l'esercizio, puoi esaminare la [soluzione] fornita."

#: src/exercises/day-3/safe-ffi-wrapper.md:1
#, fuzzy
msgid "# Safe FFI Wrapper"
msgstr "# Wrapper FFI sicuro"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust ha un ottimo supporto per le funzioni di chiamata attraverso una "
"funzione _foreign\n"
"interfaccia_ (FFI). Lo useremo per costruire un wrapper sicuro per `libc`\n"
"funzioni che useresti da C per leggere i nomi dei file di una directory."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Ti consigliamo di consultare le pagine di manuale:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
#, fuzzy
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`] module. There you find a "
"number of\n"
"string types which you need for the exercise:"
msgstr ""
"Dovrai anche sfogliare il modulo [`std::ffi`]. Lì trovi un numero di\n"
"tipi di stringa necessari per l'esercizio:"

#: src/exercises/day-3/safe-ffi-wrapper.md:16
#, fuzzy
msgid ""
"| Types                      | Encoding       | "
"Use                            |\n"
"|----------------------------|----------------|--------------------------------|\n"
"| [`str`] and [`String`]     | UTF-8          | Text processing in "
"Rust        |\n"
"| [`CStr`] and [`CString`]   | NUL-terminated | Communicating with C "
"functions |\n"
"| [`OsStr`] and [`OsString`] | OS-specific    | Communicating with the "
"OS      |"
msgstr ""
"| Tipi | Codifica | Usa |\n"
"|----------------------------|----------------|--- "
"-----------------------------|\n"
"| [`str`] e [`String`] | UTF-8 | Elaborazione del testo in Rust |\n"
"| [`CStr`] e [`CString`] | con terminazione NUL | Comunicare con le funzioni "
"C |\n"
"| [`OsStr`] e [`OsString`] | specifico del sistema operativo | Comunicazione "
"con il sistema operativo |"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid "You will convert between all these types:"
msgstr "Potrai convertire tra tutti questi tipi:"

#: src/exercises/day-3/safe-ffi-wrapper.md:24
#, fuzzy
msgid ""
"- `&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,\n"
"- `CString` to `*const i8`: you need a pointer to call C functions,\n"
"- `*const i8` to `&CStr`: you need something which can find the trailing "
"`\\0` character,\n"
"- `&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknow data\",\n"
"- `&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use\n"
"  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt."
"html)\n"
"  to create it,\n"
"- `&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able "
"to return it and call\n"
"  `readdir` again."
msgstr ""
"- Da `&str` a `CString`: è necessario allocare spazio per un carattere "
"finale `\\0`,\n"
"- Da `CString` a `*const i8`: è necessario un puntatore per chiamare le "
"funzioni C,\n"
"- Da `*const i8` a `&CStr`: hai bisogno di qualcosa che possa trovare il "
"carattere finale `\\0`,\n"
"- da `&CStr` a `&[u8]`: una fetta di byte è l'interfaccia universale per "
"\"alcuni dati sconosciuti\",\n"
"- Da `&[u8]` a `&OsStr`: `&OsStr` è un passo verso `OsString`, usa\n"
"  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt."
"html)\n"
"  per crearlo,\n"
"- `&OsStr` a `OsString`: è necessario clonare i dati in `&OsStr` per poterlo "
"restituire e chiamare\n"
"  `readdir` di nuovo."

#: src/exercises/day-3/safe-ffi-wrapper.md:34
#, fuzzy
msgid "The [Nomicon] also has a very useful chapter about FFI."
msgstr "Il [Nomicon] ha anche un capitolo molto utile su FFI."

#: src/exercises/day-3/safe-ffi-wrapper.md:45
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the "
"missing\n"
"functions and methods:"
msgstr ""
"Copia il codice qui sotto in <https://play.rust-lang.org/> e inserisci "
"quello mancante\n"
"funzioni e metodi:"

#: src/exercises/day-3/safe-ffi-wrapper.md:48
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android.md:1
#, fuzzy
msgid "# Welcome to Rust in Android"
msgstr "# Benvenuto in Rust su Android"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means "
"that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust è supportato per lo sviluppo della piattaforma nativa su Android. Ciò "
"significa che\n"
"puoi scrivere nuovi servizi del sistema operativo in Rust, oltre ad "
"estenderli\n"
"servizi esistenti."

#: src/android.md:7
#, fuzzy
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try "
"to\n"
"> find a little corner of your code base where we can move some lines of "
"code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> Oggi tenteremo di chiamare Rust da uno dei tuoi progetti. Quindi prova a\n"
"> trova un piccolo angolo della tua base di codice in cui possiamo spostare "
"alcune righe di codice\n"
"> Ruggine. Minori sono le dipendenze e i tipi \"esotici\", meglio è. "
"Qualcosa che\n"
"> analizza alcuni byte grezzi sarebbe l'ideale."

#: src/android/setup.md:1
#, fuzzy
msgid "# Setup"
msgstr "# Impostare"

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have\n"
"access to one or create a new one with:"
msgstr ""
"Useremo un dispositivo virtuale Android per testare il nostro codice. "
"Assicurati di avere\n"
"accedi a uno o creane uno nuovo con:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"source build/envsetup.sh\n"
"lunch aosp_cf_x86_64_phone-userdebug\n"
"acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"Si prega di consultare il [Sviluppatore Android\n"
"Codelab](https://source.android.com/docs/setup/start) per i dettagli."

#: src/android/build-rules.md:1
#, fuzzy
msgid "# Build Rules"
msgstr "# Crea regole"

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"Il sistema di compilazione Android (Soong) supporta Rust tramite una serie "
"di moduli:"

#: src/android/build-rules.md:5
#, fuzzy
msgid ""
"| Module Type       | "
"Description                                                                                        "
"|\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust "
"binary.                                                                            "
"|\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and "
"`dylib` variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and "
"provides both static and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are "
"analogous to compiler plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard "
"Rust test harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging "
"`libfuzzer`.                                                |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that "
"provides an interface for a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library "
"containing Rust bindings to C libraries.              |"
msgstr ""
"| Tipo di modulo | Descrizione |\n"
"|-------------------|-------------------------------------- "
"-------------------------------------------------- ---------------------|\n"
"| `binario_ruggine` | Produce un binario Rust. |\n"
"| `libreria_ruggine` | Produce una libreria Rust e fornisce entrambe le "
"varianti `rlib` e `dylib`. |\n"
"| `ruggine_ffi` | Produce una libreria Rust C utilizzabile dai moduli `cc` e "
"fornisce varianti sia statiche che condivise. |\n"
"| `rust_proc_macro` | Produce una libreria Rust `proc-macro`. Questi sono "
"analoghi ai plugin del compilatore. |\n"
"| `test_ruggine` | Produce un file binario di test Rust che utilizza il "
"cablaggio di test Rust standard. |\n"
"| `ruggine_fuzz` | Produce un binario fuzz di Rust sfruttando `libfuzzer`. "
"|\n"
"| `protobuf_ruggine` | Genera il codice sorgente e produce una libreria Rust "
"che fornisce un'interfaccia per un particolare protobuf. |\n"
"| `ruggine_bindgen` | Genera il codice sorgente e produce una libreria Rust "
"contenente collegamenti Rust alle librerie C. |"

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Vedremo successivamente `rust_binary` e `rust_library`."

#: src/android/build-rules/binary.md:1
#, fuzzy
msgid "# Rust Binaries"
msgstr "# Binari Rust"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create\n"
"the following files:"
msgstr ""
"Iniziamo con una semplice applicazione. Alla radice di un checkout AOSP, "
"create\n"
"i seguenti file:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "_ciao_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "_ciao_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo.\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr "Ora puoi creare, inviare ed eseguire il binario:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:35
msgid ""
"```text\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
#, fuzzy
msgid "# Rust Libraries"
msgstr "# Librerie ruggine"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "Usa `rust_library` per creare una nuova libreria Rust per Android."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Qui dichiariamo una dipendenza da due librerie:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* `libgreeting`, che definiamo di seguito,\n"
"* `libtextwrap`, che è una cassa già venduta\n"
"  [`external/rust/crates/`][crates]."

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "_ciao_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Costruisci, spingi ed esegui il binario come prima:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:67
msgid ""
"```text\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:1
#, fuzzy
msgid "# AIDL"
msgstr "#AIDL"

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in "
"Rust:"
msgstr ""
"Il [linguaggio di definizione dell'interfaccia Android\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) è supportato in "
"Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* Il codice Rust può chiamare i server AIDL esistenti,\n"
"* Puoi creare nuovi server AIDL in Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "# AIDL Interfaces"
msgstr "# Interfacce AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Dichiari l'API del tuo servizio utilizzando un'interfaccia AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid ""
"*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr ""
"*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"

#: src/android/aidl/interface.md:7
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "*birthday_service/aidl/Android.bp*:"
msgstr "*servizio_compleanno/aidl/Android.bp*:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor\n"
"partition."
msgstr ""
"Aggiungi \"vendor_available: true\" se il tuo file AIDL è utilizzato da un "
"file binario nel fornitore\n"
"partizione."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "# Service Implementation"
msgstr "# Implementazione del servizio"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "Ora possiamo implementare il servizio AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "*birthday_service/src/lib.rs*:"
msgstr "*servizio_compleanno/src/lib.rs*:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;\n"
"\n"
"impl binder::Interface for BirthdayService {}\n"
"\n"
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
"Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!"
"\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
#, fuzzy
msgid "*birthday_service/Android.bp*:"
msgstr "*servizio_compleanno/Android.bp*:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
#, fuzzy
msgid "# AIDL Server"
msgstr "# Server AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr "Infine, possiamo creare un server che espone il servizio:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "*birthday_service/src/server.rs*:"
msgstr "*servizio_compleanno/src/server.rs*:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
"as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:1
#, fuzzy
msgid "# Deploy"
msgstr "# Distribuisci"

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr "Ora possiamo creare, inviare e avviare il servizio:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "In un altro terminale, controlla che il servizio sia in esecuzione:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"adb shell service check birthdayservice\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:17
msgid ""
"```text\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:21
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "Puoi anche chiamare il servizio con `service call`:"

#: src/android/aidl/deploy.md:23
msgid ""
"```shell\n"
"adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:27
msgid ""
"```text\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
#, fuzzy
msgid "# AIDL Client"
msgstr "# Cliente AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr "Infine, possiamo creare un client Rust per il nostro nuovo servizio."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "*birthday_service/src/client.rs*:"
msgstr "*servizio_compleanno/src/client.rs*:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
"StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Si noti che il client non dipende da `libbirthdayservice`."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Crea, invia ed esegui il client sul tuo dispositivo:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""

#: src/android/aidl/client.md:62
msgid ""
"```text\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:1
#, fuzzy
msgid "# Changing API"
msgstr "# Modifica dell'API"

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a\n"
"list of lines for the birthday card:"
msgstr ""
"Estendiamo l'API con più funzionalità: vogliamo consentire ai client di "
"specificare a\n"
"elenco delle righe per il biglietto d'auguri:"

#: src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:1 src/bare-metal/aps/logging.md:1
#, fuzzy
msgid "# Logging"
msgstr "# Registrazione"

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or\n"
"`stdout` (on-host):"
msgstr ""
"Dovresti usare la cassa `log` per accedere automaticamente a `logcat` (sul "
"dispositivo) o\n"
"`stdout` (sull'host):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_ciao_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_ciao_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"\n"
"use log::{debug, error, info};\n"
"\n"
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr "Crea, invia ed esegui il file binario sul tuo dispositivo:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "I log vengono visualizzati in `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"adb logcat -s rust\n"
"```"
msgstr ""

#: src/android/logging.md:56
msgid ""
"```text\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
"fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
"wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:1
#, fuzzy
msgid "# Interoperability"
msgstr "# Interoperabilità"

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means\n"
"that you can:"
msgstr ""
"Rust ha un eccellente supporto per l'interoperabilità con altri linguaggi. "
"Questo significa\n"
"che tu puoi:"

#: src/android/interoperability.md:6
#, fuzzy
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* Richiama le funzioni di Rust da altre lingue.\n"
"* Funzioni di chiamata scritte in altri linguaggi da Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"Quando chiami funzioni in una lingua straniera diciamo che stai usando a\n"
"_interfaccia funzione straniera_, nota anche come FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "# Interoperability with C"
msgstr "# Interoperabilità con C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust ha il pieno supporto per il collegamento di file oggetto con una "
"convenzione di chiamata C.\n"
"Allo stesso modo, puoi esportare le funzioni di Rust e chiamarle da C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "Puoi farlo a mano se vuoi:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr ""
"Lo abbiamo già visto nel [Safe FFI Wrapper\n"
"esercizio](../../exercises/day-3/safe-ffi-wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr ""
"> Ciò presuppone la piena conoscenza della piattaforma di destinazione. Non "
"consigliato per\n"
"> produzione."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "Vedremo le opzioni migliori in seguito."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "# Using Bindgen"
msgstr "# Utilizzo di Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"Lo strumento [bindgen](https://rust-lang.github.io/rust-bindgen/introduction."
"html)\n"
"può generare automaticamente collegamenti da un file di intestazione C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Per prima cosa crea una piccola libreria C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperabilità/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;\n"
"\n"
"void print_card(const card* card);\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperabilità/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Aggiungi questo al tuo file `Android.bp`:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperabilità/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr ""
"Crea un file di intestazione wrapper per la libreria (non strettamente "
"necessario in questo\n"
"esempio):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperabilità/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Ora puoi generare automaticamente le associazioni:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Infine, possiamo usare i binding nel nostro programma Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperabilità/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Infine, possiamo eseguire test generati automaticamente per garantire che i "
"binding funzionino:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "# Calling Rust"
msgstr "# Calling Rust"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Esportare le funzioni e i tipi di Rust in C è facile:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperabilità/ruggine/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperabilità/ruggine/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperabilità/ruggine/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "Ora possiamo chiamarlo da un binario C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperabilità/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperabilità/ruggine/analisi/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify "
"whatever name you want."
msgstr ""
"`#[no_mangle]` disabilita la solita alterazione del nome di Rust, quindi il "
"simbolo esportato sarà solo il nome di\n"
"la funzione. Puoi anche usare `#[export_name = \"some_name\"]` per "
"specificare il nome che desideri."

#: src/android/interoperability/cpp.md:1
#, fuzzy
msgid "# With C++"
msgstr "# Con C++"

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between "
"Rust\n"
"and C++."
msgstr ""
"Il [CXX crate][1] rende possibile l'interoperabilità sicura tra Rust\n"
"e C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "L'approccio generale è simile al seguente:"

#: src/android/interoperability/cpp.md:8
#, fuzzy
msgid "<img src=\"cpp/overview.svg\">"
msgstr "<img src=\"cpp/overview.svg\">"

#: src/android/interoperability/cpp.md:10
#, fuzzy
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr ""
"Vedere il [tutorial CXX][2] per un esempio completo di utilizzo di questo."

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "# Interoperability with Java"
msgstr "# Interoperabilità con Java"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java può caricare oggetti condivisi tramite [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). Il [`jni`\n"
"crate](https://docs.rs/jni/) consente di creare una libreria compatibile."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Innanzitutto, creiamo una funzione Rust da esportare in Java:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperabilità/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperabilità/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "Infine, possiamo chiamare questa funzione da Java:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperabilità/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr "Infine, puoi creare, sincronizzare ed eseguire il binario:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"m helloworld_jni\n"
"adb sync  # requires adb root && adb remount\n"
"adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/android/morning.md:1 src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1
#: src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
#, fuzzy
msgid "# Exercises"
msgstr "# Esercizi"

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and\n"
"try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Questo è un esercizio di gruppo: esamineremo uno dei progetti con cui lavori "
"e\n"
"prova a integrarci un po' di ruggine. Alcuni suggerimenti:"

#: src/exercises/android/morning.md:6
#, fuzzy
msgid ""
"* Call your AIDL service with a client written in Rust.\n"
"\n"
"* Move a function from your project to Rust and call it."
msgstr ""
"* Chiama il tuo servizio AIDL con un client scritto in Rust.\n"
"\n"
"* Sposta una funzione dal tuo progetto a Rust e chiamala."

#: src/exercises/android/morning.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Nessuna soluzione viene fornita qui poiché questo è a tempo indeterminato: "
"si basa su qualcuno dentro\n"
"la classe ha un pezzo di codice che puoi consegnare a Rust al volo."

#: src/bare-metal.md:1
#, fuzzy
msgid "# Welcome to Bare Metal Rust"
msgstr "# Benvenuto in Bare Metal Rust"

#: src/bare-metal.md:3
#, fuzzy
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the\n"
"basics of Rust (perhaps from completing the Comprehensive Rust course), and "
"ideally also have some\n"
"experience with bare-metal programming in some other language such as C."
msgstr ""
"Questo è un corso autonomo di un giorno sul bare metal Rust, rivolto a "
"persone che hanno familiarità con il\n"
"nozioni di base di Rust (forse completando il corso completo di Rust), e "
"idealmente anche averne alcune\n"
"esperienza con la programmazione bare metal in qualche altro linguaggio come "
"C."

#: src/bare-metal.md:7
#, fuzzy
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will\n"
"be divided into several parts:"
msgstr ""
"Oggi parleremo di Rust 'bare-metal': eseguire il codice Rust senza un "
"sistema operativo sotto di noi. Questo sarà\n"
"essere suddiviso in più parti:"

#: src/bare-metal.md:10
#, fuzzy
msgid ""
"- What is `no_std` Rust?\n"
"- Writing firmware for microcontrollers.\n"
"- Writing bootloader / kernel code for application processors.\n"
"- Some useful crates for bare-metal Rust development."
msgstr ""
"- Cos'è \"no_std\" Rust?\n"
"- Scrittura firmware per microcontrollori.\n"
"- Scrittura del codice bootloader/kernel per i processori delle "
"applicazioni.\n"
"- Alcune casse utili per lo sviluppo di ruggine a metallo nudo."

#: src/bare-metal.md:15
#, fuzzy
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2\n"
"as an example. It's a [development board](https://tech.microbit.org/"
"hardware/) based on the Nordic\n"
"nRF51822 microcontroller with some LEDs and buttons, an I2C-connected "
"accelerometer and compass, and\n"
"an on-board SWD debugger."
msgstr ""
"Per la parte del corso sui microcontrollori utilizzeremo la [BBC micro:bit]"
"(https://microbit.org/) v2\n"
"come esempio. È una [scheda di sviluppo](https://tech.microbit.org/"
"hardware/) basata sul Nordic\n"
"microcontrollore nRF51822 con alcuni LED e pulsanti, un accelerometro e una "
"bussola collegati a I2C e\n"
"un debugger SWD integrato."

#: src/bare-metal.md:20
#, fuzzy
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"Per iniziare, installa alcuni strumenti che ci serviranno in seguito. Su "
"gLinux o Debian:"

#: src/bare-metal.md:22
msgid ""
"```bash\n"
"sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-"
"config qemu-system-arm\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal.md:30
#, fuzzy
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"E dai agli utenti del gruppo `plugdev` l'accesso al programmatore micro:bit:"

#: src/bare-metal.md:32
msgid ""
"```bash\n"
"echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
"GROUP=\"plugdev\"' |\\\n"
"  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
"sudo udevadm control --reload-rules\n"
"```"
msgstr ""

#: src/bare-metal.md:38
#, fuzzy
msgid "On MacOS:"
msgstr "Su macOS:"

#: src/bare-metal.md:40
msgid ""
"```bash\n"
"xcode-select --install\n"
"brew install gdb picocom qemu\n"
"brew install --cask gcc-aarch64-embedded\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal/no_std.md:1
#, fuzzy
msgid "# `no_std`"
msgstr "# `no_std`"

#: src/bare-metal/no_std.md:3
#, fuzzy
msgid ""
"<table>\n"
"<tr>\n"
"<th>"
msgstr ""
"<tabella>\n"
"<tr>\n"
"<th>"

#: src/bare-metal/no_std.md:7
#, fuzzy
msgid "`core`"
msgstr "`nucleo`"

#: src/bare-metal/no_std.md:9 src/bare-metal/no_std.md:14
#, fuzzy
msgid ""
"</th>\n"
"<th>"
msgstr ""
"</th>\n"
"<th>"

#: src/bare-metal/no_std.md:12
#, fuzzy
msgid "`alloc`"
msgstr "`alloc`"

#: src/bare-metal/no_std.md:17
#, fuzzy
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md:19
#, fuzzy
msgid ""
"</th>\n"
"</tr>\n"
"<tr valign=\"top\">\n"
"<td>"
msgstr ""
"</th>\n"
"</tr>\n"
"<tr valign=\"top\">\n"
"<td>"

#: src/bare-metal/no_std.md:24
#, fuzzy
msgid ""
"* Slices, `&str`, `CStr`\n"
"* `NonZeroU8`...\n"
"* `Option`, `Result`\n"
"* `Display`, `Debug`, `write!`...\n"
"* `Iterator`\n"
"* `panic!`, `assert_eq!`...\n"
"* `NonNull` and all the usual pointer-related functions\n"
"* `Future` and `async`/`await`\n"
"* `fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`...\n"
"* `Duration`"
msgstr ""
"* Fette, `&str`, `CStr`\n"
"* `NonZeroU8`...\n"
"* `Opzione`, `Risultato`\n"
"* `Display`, `Debug`, `write!`...\n"
"* `Iteratore`\n"
"* `panico!`, `assert_eq!`...\n"
"* `NonNull` e tutte le solite funzioni relative ai puntatori\n"
"* `Future` e `async`/`await`\n"
"* `fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`...\n"
"* `Durata`"

#: src/bare-metal/no_std.md:35 src/bare-metal/no_std.md:42
#, fuzzy
msgid ""
"</td>\n"
"<td>"
msgstr ""
"</td>\n"
"<td>"

#: src/bare-metal/no_std.md:38
#, fuzzy
msgid ""
"* `Box`, `Cow`, `Arc`, `Rc`\n"
"* `Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`\n"
"* `String`, `CString`, `format!`"
msgstr ""
"* `Scatola`, `Mucca`, `Arco`, `Rc`\n"
"* `Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`\n"
"* `Stringa`, `CStringa`, `formato!`"

#: src/bare-metal/no_std.md:45
#, fuzzy
msgid ""
"* `Error`\n"
"* `HashMap`\n"
"* `Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`\n"
"* `File` and the rest of `fs`\n"
"* `println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`\n"
"* `Path`, `OsString`\n"
"* `net`\n"
"* `Command`, `Child`, `ExitCode`\n"
"* `spawn`, `sleep` and the rest of `thread`\n"
"* `SystemTime`, `Instant`"
msgstr ""
"* `Errore`\n"
"* `Mappa hash`\n"
"* `Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`\n"
"* `File` e il resto di `fs`\n"
"* `println!`, `Read`, `Write`, `Stdin`, `Stdout` e il resto di `io`\n"
"* `Percorso`, `OsString`\n"
"* `rete`\n"
"* `Comando`, `Figlio`, `CodiceUscita`\n"
"* `spawn`, `sleep` e il resto di `thread`\n"
"* `SystemTime`, `Instant`"

#: src/bare-metal/no_std.md:56
#, fuzzy
msgid ""
"</td>\n"
"</tr>\n"
"</table>\n"
"\n"
"<details>"
msgstr ""
"</td>\n"
"</tr>\n"
"</table>\n"
"\n"
"<dettagli>"

#: src/bare-metal/no_std.md:62
#, fuzzy
msgid ""
"* `HashMap` depends on RNG.\n"
"* `std` re-exports the contents of both `core` and `alloc`."
msgstr ""
"* `HashMap` dipende da RNG.\n"
"* `std` riesporta il contenuto sia di `core` che di `alloc`."

#: src/bare-metal/minimal.md:1
#, fuzzy
msgid "# A minimal `no_std` program"
msgstr "# Un programma `no_std` minimo"

#: src/bare-metal/minimal.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::panic::PanicInfo;\n"
"\n"
"#[panic_handler]\n"
"fn panic(_panic: &PanicInfo) -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/minimal.md:17
msgid ""
"* This will compile to an empty binary.\n"
"* `std` provides a panic handler; without it we must provide our own.\n"
"* It can also be provided by another crate, such as `panic-halt`.\n"
"* Depending on the target, you may need to compile with `panic = \"abort\"` "
"to avoid an error about\n"
"  `eh_personality`.\n"
"* Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry\n"
"  point. This will typically involve a linker script and some assembly code "
"to set things up ready\n"
"  for Rust code to run."
msgstr ""

#: src/bare-metal/alloc.md:1
#, fuzzy
msgid "# `alloc`"
msgstr "# `alloc`"

#: src/bare-metal/alloc.md:3
#, fuzzy
msgid ""
"To use `alloc` you must implement a\n"
"[global (heap) allocator](https://doc.rust-lang.org/stable/std/alloc/trait."
"GlobalAlloc.html)."
msgstr ""
"Per usare `alloc` devi implementare a\n"
"[allocatore globale (heap)](https://doc.rust-lang.org/stable/std/alloc/trait."
"GlobalAlloc.html)."

#: src/bare-metal/alloc.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called "
"once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Now we can do things that require heap allocation.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/alloc.md:39
msgid ""
"* `buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other\n"
"  crates are available, or you can write your own or hook into your existing "
"allocator.\n"
"* The const parameter of `LockedHeap` is the max order of the allocator; i."
"e. in this case it can\n"
"  allocate regions of up to 2**32 bytes.\n"
"* If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global\n"
"  allocator defined in your binary. Usually this is done in the top-level "
"binary crate.\n"
"* `extern crate panic_halt as _` is necessary to ensure that the "
"`panic_halt` crate is linked in so\n"
"  we get its panic handler.\n"
"* This example will build but not run, as it doesn't have an entry point."
msgstr ""

#: src/bare-metal/microcontrollers.md:1
#, fuzzy
msgid "# Microcontrollers"
msgstr "# Microcontrollori"

#: src/bare-metal/microcontrollers.md:3
#, fuzzy
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"Il crate `cortex_m_rt` fornisce (tra le altre cose) un gestore di reset per "
"i microcontrollori Cortex M."

#: src/bare-metal/microcontrollers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use cortex_m_rt::entry;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers.md:21
#, fuzzy
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"Successivamente vedremo come accedere alle periferiche, con livelli "
"crescenti di astrazione."

#: src/bare-metal/microcontrollers.md:25
#, fuzzy
msgid ""
"* The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning\n"
"  to the reset handler doesn't make sense.\n"
"* Run the example with `cargo embed --bin minimal`"
msgstr ""
"* La macro `cortex_m_rt::entry` richiede che la funzione abbia il tipo `fn() "
"-> !`, perché restituisce\n"
"  al gestore di ripristino non ha senso.\n"
"* Esegui l'esempio con `cargo embed --bin minimal`"

#: src/bare-metal/microcontrollers/mmio.md:1
#, fuzzy
msgid "# Raw MMIO"
msgstr "# MMIO grezzo"

#: src/bare-metal/microcontrollers/mmio.md:3
#, fuzzy
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our\n"
"micro:bit:"
msgstr ""
"La maggior parte dei microcontrollori accede alle periferiche tramite IO "
"mappato in memoria. Proviamo ad accendere un LED sul nostro\n"
"micro:bit:"

#: src/bare-metal/microcontrollers/mmio.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// GPIO port 0 peripheral address\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// GPIO peripheral offsets\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// PIN_CNF fields\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
"const PULL_DISABLED: u32 = 0x0 << 2;\n"
"const DRIVE_S0S1: u32 = 0x0 << 8;\n"
"const SENSE_DISABLED: u32 = 0x0 << 16;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
"u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
"u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 << 28);\n"
"        gpio0_outset.write_volatile(1 << 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:64
#, fuzzy
msgid ""
"* GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin "
"28 to the first row."
msgstr ""
"* Il pin 21 di GPIO 0 è collegato alla prima colonna della matrice LED e il "
"pin 28 alla prima riga."

#: src/bare-metal/microcontrollers/mmio.md:66
#: src/bare-metal/microcontrollers/pacs.md:59
#: src/bare-metal/microcontrollers/hals.md:43
#: src/bare-metal/microcontrollers/board-support.md:34
#, fuzzy
msgid "Run the example with:"
msgstr "Esegui l'esempio con:"

#: src/bare-metal/microcontrollers/mmio.md:68
msgid ""
"```sh\n"
"cargo embed --bin mmio\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:1
#, fuzzy
msgid "# Peripheral Access Crates"
msgstr "# Casse di accesso periferico"

#: src/bare-metal/microcontrollers/pacs.md:3
#, fuzzy
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for\n"
"memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/pack/doc/"
"CMSIS/SVD/html/index.html)\n"
"files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) genera wrapper Rust per lo "
"più sicuri per\n"
"periferiche mappate in memoria da [CMSIS-SVD](https://www.keil.com/pack/doc/"
"CMSIS/SVD/html/index.html)\n"
"File."

#: src/bare-metal/microcontrollers/pacs.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:49
#, fuzzy
msgid ""
"* SVD (System View Description) files are XML files typically provided by "
"silicon vendors which\n"
"  describe the memory map of the device.\n"
"  * They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses\n"
"    and so on.\n"
"  * SVD files are often buggy and incomplete, so there are various projects "
"which patch the\n"
"    mistakes, add missing details, and publish the generated crates.\n"
"* `cortex-m-rt` provides the vector table, among other things.\n"
"* If you `cargo install cargo-binutils` then you can run\n"
"  `cargo objdump --bin pac -- -d --no-show-raw-insn` to see the resulting "
"binary."
msgstr ""
"* I file SVD (System View Description) sono file XML generalmente forniti da "
"fornitori di silicio che\n"
"  descrivere la mappa di memoria del dispositivo.\n"
"  * Sono organizzati per periferica, registro, campo e valore, con nomi, "
"descrizioni, indirizzi\n"
"    e così via.\n"
"  * I file SVD sono spesso difettosi e incompleti, quindi ci sono vari "
"progetti che correggono il file\n"
"    errori, aggiungere i dettagli mancanti e pubblicare le casse generate.\n"
"* `cortex-m-rt` fornisce la tabella dei vettori, tra le altre cose.\n"
"* Se `cargo installi cargo-binutils` allora puoi eseguire\n"
"  `cargo objdump --bin pac -- -d --no-show-raw-insn` per vedere il binario "
"risultante."

#: src/bare-metal/microcontrollers/pacs.md:61
msgid ""
"```sh\n"
"cargo embed --bin pac\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:1
#, fuzzy
msgid "# HAL crates"
msgstr "# casse HAL"

#: src/bare-metal/microcontrollers/hals.md:3
#, fuzzy
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for\n"
"many microcontrollers provide wrappers around various peripherals. These "
"generally implement traits\n"
"from [`embedded-hal`](https://crates.io/crates/embedded-hal)."
msgstr ""
"[Casse HAL](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) per\n"
"molti microcontrollori forniscono wrapper attorno a varie periferiche. "
"Questi generalmente implementano i tratti\n"
"da [`embedded-hal`](https://crates.io/crates/embedded-hal)."

#: src/bare-metal/microcontrollers/hals.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Create HAL wrapper for GPIO port 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:39
#, fuzzy
msgid ""
" * `set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` "
"trait.\n"
" * HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP,\n"
"   MSP430, AVR and PIC microcontrollers."
msgstr ""
" * `set_low` e `set_high` sono metodi sul tratto `embedded_hal` "
"`OutputPin`.\n"
" * Esistono casse HAL per molti dispositivi Cortex-M e RISC-V, inclusi vari "
"STM32, GD32, nRF, NXP,\n"
"   Microcontrollori MSP430, AVR e PIC."

#: src/bare-metal/microcontrollers/hals.md:45
msgid ""
"```sh\n"
"cargo embed --bin hal\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:1
#, fuzzy
msgid "# Board support crates"
msgstr "# Casse di supporto della scheda"

#: src/bare-metal/microcontrollers/board-support.md:3
#, fuzzy
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"Le casse di supporto della tavola forniscono un ulteriore livello di "
"avvolgimento per una tavola specifica per comodità."

#: src/bare-metal/microcontrollers/board-support.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::Board;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let mut board = Board::take().unwrap();\n"
"\n"
"    board.display_pins.col1.set_low().unwrap();\n"
"    board.display_pins.row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:28
#, fuzzy
msgid ""
" * In this case the board support crate is just providing more useful names, "
"and a bit of\n"
"   initialisation.\n"
" * The crate may also include drivers for some on-board devices outside of "
"the microcontroller\n"
"   itself.\n"
"   * `microbit-v2` includes a simple driver for the LED matrix."
msgstr ""
" * In questo caso la cassa di supporto della scheda fornisce solo nomi più "
"utili e un po' di\n"
"   inizializzazione.\n"
" * Il crate può anche includere driver per alcuni dispositivi integrati al "
"di fuori del microcontrollore\n"
"   si.\n"
"   * `microbit-v2` include un semplice driver per la matrice LED."

#: src/bare-metal/microcontrollers/board-support.md:36
msgid ""
"```sh\n"
"cargo embed --bin board_support\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:1
#, fuzzy
msgid "# The type state pattern"
msgstr "# Il modello di stato del tipo"

#: src/bare-metal/microcontrollers/type-state.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Error, moved.\n"
"\n"
"    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
"into_push_pull_output(Level::Low);\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:32
#, fuzzy
msgid ""
" * Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is\n"
"   moved out of the port struct nobody else can take it.\n"
" * Changing the configuration of a pin consumes the old pin instance, so you "
"can’t keep use the old\n"
"   instance afterwards.\n"
" * The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state\n"
"   of a GPIO pin. This encodes the state machine into the type system, and "
"ensures that you don't\n"
"   try to use a pin in a certain way without properly configuring it first. "
"Illegal state\n"
"   transitions are caught at compile time.\n"
" * You can call `is_high` on an input pin and `set_high` on an output pin, "
"but not vice-versa.\n"
" * Many HAL crates follow this pattern."
msgstr ""
" * I pin non implementano `Copy` o `Clone`, quindi può esistere solo "
"un'istanza di ciascuno. Una volta che uno spillo è\n"
"   spostato fuori dalla struttura portuale nessun altro può prenderlo.\n"
" * La modifica della configurazione di un pin consuma la vecchia istanza del "
"pin, quindi non puoi continuare a utilizzare il vecchio\n"
"   esempio dopo.\n"
" * Il tipo di un valore indica lo stato in cui si trova: ad es. in questo "
"caso, lo stato di configurazione\n"
"   di un pin GPIO. Questo codifica la macchina a stati nel sistema di tipi e "
"garantisce che non lo fai\n"
"   provare a utilizzare un pin in un certo modo senza prima configurarlo "
"correttamente. Stato illegale\n"
"   le transizioni vengono rilevate in fase di compilazione.\n"
" * Puoi chiamare `is_high` su un pin di input e `set_high` su un pin di "
"output, ma non viceversa.\n"
" * Molte casse HAL seguono questo schema."

#: src/bare-metal/microcontrollers/embedded-hal.md:1
#, fuzzy
msgid "# `embedded-hal`"
msgstr "# `hal incorporato`"

#: src/bare-metal/microcontrollers/embedded-hal.md:3
#, fuzzy
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits\n"
"covering common microcontroller peripherals."
msgstr ""
"Il crate [`embedded-hal`](https://crates.io/crates/embedded-hal) fornisce "
"una serie di caratteristiche\n"
"che copre le comuni periferiche del microcontrollore."

#: src/bare-metal/microcontrollers/embedded-hal.md:6
#, fuzzy
msgid ""
" * GPIO\n"
" * ADC\n"
" * I2C, SPI, UART, CAN\n"
" * RNG\n"
" * Timers\n"
" * Watchdogs"
msgstr ""
" * GPIO\n"
" *ADC\n"
" * I2C, SPI, UART, PUÒ\n"
" * RNG\n"
" * Timer\n"
" * Cani da guardia"

#: src/bare-metal/microcontrollers/embedded-hal.md:13
#, fuzzy
msgid ""
"Other crates then implement\n"
"[drivers](https://github.com/rust-embedded/awesome-embedded-rust#driver-"
"crates) in terms of these\n"
"traits, e.g. an accelerometer driver might need an I2C or SPI bus "
"implementation."
msgstr ""
"Altre casse quindi implementano\n"
"[driver](https://github.com/rust-embedded/awesome-embedded-rust#driver-"
"crates) in termini di questi\n"
"tratti, ad es. un driver dell'accelerometro potrebbe richiedere "
"un'implementazione del bus I2C o SPI."

#: src/bare-metal/microcontrollers/embedded-hal.md:19
#, fuzzy
msgid ""
" * There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on\n"
"Raspberry Pi.\n"
" * There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""
" * Ci sono implementazioni per molti microcontrollori, così come altre "
"piattaforme come Linux su\n"
"Lampone Pi.\n"
" * C'è lavoro in corso su una versione `async` di `embedded-hal`, ma non è "
"ancora stabile."

#: src/bare-metal/microcontrollers/probe-rs.md:1
#, fuzzy
msgid "# `probe-rs`, `cargo-embed`"
msgstr "# `probe-rs`, `cargo-embed`"

#: src/bare-metal/microcontrollers/probe-rs.md:3
#, fuzzy
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better\n"
"integrated."
msgstr ""
"[probe-rs](https://probe.rs/) è un utile set di strumenti per il debug "
"integrato, come OpenOCD ma migliore\n"
"integrato."

#: src/bare-metal/microcontrollers/probe-rs.md:6
#, fuzzy
msgid ""
"* <abbr title=\"Serial Wire Debug\">SWD</abbr> and JTAG via CMSIS-DAP, ST-"
"Link and J-Link probes\n"
"* GDB stub and Microsoft <abbr title=\"Debug Adapter Protocol\">DAP</abbr> "
"server\n"
"* Cargo integration"
msgstr ""
"* <abbr title=\"Serial Wire Debug\">SWD</abbr> e JTAG tramite sonde CMSIS-"
"DAP, ST-Link e J-Link\n"
"* GDB stub e server Microsoft <abbr title=\"Debug Adapter Protocol\">DAP</"
"abbr>\n"
"* Integrazione del carico"

#: src/bare-metal/microcontrollers/probe-rs.md:10
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log\n"
"<abbr title=\"Real Time Transfers\">RTT</abbr> output and connect GDB. It's "
"configured by an\n"
"`Embed.toml` file in your project directory."
msgstr ""
"`cargo-embed` è un sottocomando cargo per compilare e aggiornare binari, "
"log\n"
"<abbr title=\"Real Time Transfers\">RTT</abbr> emette e collega GDB. È "
"configurato da un\n"
"\"Embed.toml\" nella directory del progetto."

#: src/bare-metal/microcontrollers/probe-rs.md:16
#, fuzzy
msgid ""
"* [CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard\n"
"  protocol over USB for an in-circuit debugger to access the CoreSight Debug "
"Access Port of various\n"
"  Arm Cortex processors. It's what the on-board debugger on the BBC micro:"
"bit uses.\n"
"* ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-"
"Link is a range from\n"
"  SEGGER.\n"
"* The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug.\n"
"* probe-rs is a library which you can integrate into your own tools if you "
"want to.\n"
"* The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets\n"
"  VSCode and other IDEs debug code running on any supported "
"microcontroller.\n"
"* cargo-embed is a binary built using the probe-rs library.\n"
"* RTT (Real Time Transfers) is a mechanism to transfer data between the "
"debug host and the target\n"
"  through a number of ringbuffers."
msgstr ""
"* [CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) è "
"uno standard Arm\n"
"  protocollo su USB per un debugger in-circuit per accedere alla porta di "
"accesso di debug CoreSight di vari\n"
"  Processori Arm Cortex. È ciò che utilizza il debugger integrato sul micro: "
"bit della BBC.\n"
"* ST-Link è una gamma di debugger in-circuit di ST Microelectronics, J-Link "
"è una gamma di\n"
"  SEGGER.\n"
"* La porta di accesso al debug è in genere un'interfaccia JTAG a 5 pin o un "
"cavo di debug seriale a 2 pin.\n"
"* probe-rs è una libreria che puoi integrare nei tuoi strumenti se lo "
"desideri.\n"
"* Il [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) consente\n"
"  VSCode e altri IDE eseguono il debug del codice in esecuzione su qualsiasi "
"microcontrollore supportato.\n"
"* cargo-embed è un binario creato utilizzando la libreria probe-rs.\n"
"* RTT (Real Time Transfers) è un meccanismo per trasferire i dati tra l'host "
"di debug e il target\n"
"  attraverso una serie di ringbuffer."

#: src/bare-metal/microcontrollers/debugging.md:1
#, fuzzy
msgid "# Debugging"
msgstr "# Debug"

#: src/bare-metal/microcontrollers/debugging.md:3
#, fuzzy
msgid "Embed.toml:"
msgstr "Incorpora.toml:"

#: src/bare-metal/microcontrollers/debugging.md:5
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:13
#, fuzzy
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "In un terminale sotto `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md:15
msgid ""
"```sh\n"
"cargo embed --bin board_support debug\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:19
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "In un altro terminale nella stessa directory:"

#: src/bare-metal/microcontrollers/debugging.md:21
msgid ""
"```sh\n"
"gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
"command=\"target remote :1337\"\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:27
#, fuzzy
msgid "In GDB, try running:"
msgstr "In GDB, prova a eseguire:"

#: src/bare-metal/microcontrollers/debugging.md:29
msgid ""
"```gdb\n"
"b src/bin/board_support.rs:29\n"
"b src/bin/board_support.rs:30\n"
"b src/bin/board_support.rs:32\n"
"c\n"
"c\n"
"c\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:1
#: src/bare-metal/aps/other-projects.md:1
#, fuzzy
msgid "# Other projects"
msgstr "# Altri progetti"

#: src/bare-metal/microcontrollers/other-projects.md:3
#, fuzzy
msgid ""
" * [RTIC](https://rtic.rs/)\n"
"   * \"Real-Time Interrupt-driven Concurrency\"\n"
"   * Shared resource management, message passing, task scheduling, timer "
"queue\n"
" * [Embassy](https://embassy.dev/)\n"
"   * `async` executors with priorities, timers, networking, USB\n"
" * [TockOS](https://www.tockos.org/documentation/getting-started)\n"
"   * Security-focused RTOS with preemptive scheduling and Memory Protection "
"Unit support\n"
" * [Hubris](https://hubris.oxide.computer/)\n"
"   * Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC\n"
" * [Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)\n"
" * Some platforms have `std` implementations, e.g.\n"
"   [esp-idf](https://esp-rs.github.io/book/overview/using-the-standard-"
"library.html)."
msgstr ""
" * [RTIC](https://rtic.rs/)\n"
"   * \"Concorrenza basata su interrupt in tempo reale\"\n"
"   * Gestione delle risorse condivise, passaggio di messaggi, pianificazione "
"delle attività, coda del timer\n"
" * [Ambasciata](https://embassy.dev/)\n"
"   * Esecutori `async` con priorità, timer, networking, USB\n"
" * [TockOS](https://www.tockos.org/documentation/getting-started)\n"
"   * RTOS incentrato sulla sicurezza con pianificazione preventiva e "
"supporto dell'unità di protezione della memoria\n"
" * [Hubris](https://hubris.oxide.computer/)\n"
"   * Microkernel RTOS di Oxide Computer Company con protezione della "
"memoria, driver non privilegiati, IPC\n"
" * [Binding per FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)\n"
" * Alcune piattaforme hanno implementazioni `std`, ad es.\n"
"   [esp-idf](https://esp-rs.github.io/book/overview/using-the-standard-"
"library.html)."

#: src/bare-metal/microcontrollers/other-projects.md:18
#, fuzzy
msgid ""
" * RTIC can be considered either an RTOS or a concurrency framework.\n"
"   * It doesn't include any HALs.\n"
"   * It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a\n"
"     proper kernel.\n"
"   * Cortex-M only.\n"
" * Google uses TockOS on the Haven microcontroller for Titan security keys.\n"
" * FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
" * RTIC può essere considerato un RTOS o un framework di concorrenza.\n"
"   * Non include nessun HAL.\n"
"   * Utilizza Cortex-M NVIC (Nested Virtual Interrupt Controller) per la "
"pianificazione piuttosto che un\n"
"     kernel corretto.\n"
"   * Solo Cortex-M.\n"
" * Google utilizza TockOS sul microcontrollore Haven per le chiavi di "
"sicurezza Titan.\n"
" * FreeRTOS è principalmente scritto in C, ma ci sono collegamenti Rust per "
"la scrittura di applicazioni."

#: src/exercises/bare-metal/morning.md:3
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"Leggeremo la direzione da una bussola I2C e registreremo le letture su una "
"porta seriale."

#: src/exercises/bare-metal/compass.md:1
#, fuzzy
msgid "# Compass"
msgstr "# Bussola"

#: src/exercises/bare-metal/compass.md:3
#, fuzzy
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have\n"
"time, try displaying it on the LEDs somehow too, or use the buttons somehow."
msgstr ""
"Leggeremo la direzione da una bussola I2C e registreremo le letture su una "
"porta seriale. Se hai\n"
"tempo, prova a visualizzarlo in qualche modo anche sui LED o usa i pulsanti "
"in qualche modo."

#: src/exercises/bare-metal/compass.md:6
#, fuzzy
msgid "Hints:"
msgstr "Suggerimenti:"

#: src/exercises/bare-metal/compass.md:8
#, fuzzy
msgid ""
"- Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and\n"
"  [`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) crates, as "
"well as the\n"
"  [micro:bit hardware](https://tech.microbit.org/hardware/).\n"
"- The LSM303AGR Inertial Measurement Unit is connected to the internal I2C "
"bus.\n"
"- TWI is another name for I2C, so the I2C master peripheral is called TWIM.\n"
"- The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead`\n"
"  trait. The\n"
"  [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/"
"struct.Twim.html) struct\n"
"  implements this.\n"
"- You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html)\n"
"  struct with fields for the various pins and peripherals.\n"
"- You can also look at the\n"
"  [nRF52833 datasheet](https://infocenter.nordicsemi.com/pdf/"
"nRF52833_PS_v1.5.pdf) if you want, but\n"
"  it shouldn't be necessary for this exercise."
msgstr ""
"- Controlla la documentazione per [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) e\n"
"  [`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) e le\n"
"  [micro:bit hardware](https://tech.microbit.org/hardware/).\n"
"- L'unità di misura inerziale LSM303AGR è collegata al bus I2C interno.\n"
"- TWI è un altro nome per I2C, quindi la periferica master I2C si chiama "
"TWIM.\n"
"- Il driver LSM303AGR necessita di qualcosa che implementi `embedded_hal::"
"blocking::i2c::WriteRead`\n"
"  tratto. IL\n"
"  [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/"
"struct.Twim.html) struttura\n"
"  implementa questo.\n"
"- Hai un [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html)\n"
"  struct con campi per i vari pin e periferiche.\n"
"- Puoi anche guardare il\n"
"  [scheda tecnica nRF52833](https://infocenter.nordicsemi.com/pdf/"
"nRF52833_PS_v1.5.pdf) se vuoi, ma\n"
"  non dovrebbe essere necessario per questo esercizio."

#: src/exercises/bare-metal/compass.md:23
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass`\n"
"directory for the following files."
msgstr ""
"Scarica il [modello di esercizio](../../comprehensive-rust-exercises.zip) e "
"guarda nella `bussola`\n"
"directory per i seguenti file."

#: src/exercises/bare-metal/compass.md:26 src/exercises/bare-metal/rtc.md:19
#, fuzzy
msgid "`src/main.rs`:"
msgstr "`src/principale.rs`:"

#: src/exercises/bare-metal/compass.md:28 src/exercises/bare-metal/rtc.md:21
#: src/exercises/concurrency/dining-philosophers.md:17
#: src/exercises/concurrency/link-checker.md:55
#: src/exercises/concurrency/dining-philosophers-async.md:11
#, fuzzy
msgid "<!-- File src/main.rs -->"
msgstr "<!-- File src/main.rs -->"

#: src/exercises/bare-metal/compass.md:30
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:64 src/exercises/bare-metal/rtc.md:385
#, fuzzy
msgid "`Cargo.toml` (you shouldn't need to change this):"
msgstr "`Cargo.toml` (non dovrebbe essere necessario modificarlo):"

#: src/exercises/bare-metal/compass.md:66 src/exercises/bare-metal/rtc.md:387
#: src/exercises/concurrency/dining-philosophers.md:63
#: src/exercises/concurrency/link-checker.md:35
#: src/exercises/concurrency/dining-philosophers-async.md:60
#: src/exercises/concurrency/chat-app.md:17
#, fuzzy
msgid "<!-- File Cargo.toml -->"
msgstr "<!-- File Cargo.toml -->"

#: src/exercises/bare-metal/compass.md:68
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"compass\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"cortex-m-rt = \"0.7.3\"\n"
"embedded-hal = \"0.2.6\"\n"
"lsm303agr = \"0.2.2\"\n"
"microbit-v2 = \"0.13.0\"\n"
"panic-halt = \"0.2.0\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:85
#, fuzzy
msgid "`Embed.toml` (you shouldn't need to change this):"
msgstr "`Embed.toml` (non dovrebbe essere necessario modificarlo):"

#: src/exercises/bare-metal/compass.md:87
#, fuzzy
msgid "<!-- File Embed.toml -->"
msgstr "<!-- File Incorpora.toml -->"

#: src/exercises/bare-metal/compass.md:89
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"\n"
"[debug.reset]\n"
"halt_afterwards = true\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:100 src/exercises/bare-metal/rtc.md:985
#, fuzzy
msgid "`.cargo/config.toml` (you shouldn't need to change this):"
msgstr "`.cargo/config.toml` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/compass.md:102 src/exercises/bare-metal/rtc.md:987
#, fuzzy
msgid "<!-- File .cargo/config.toml -->"
msgstr "<!-- File .cargo/config.toml -->"

#: src/exercises/bare-metal/compass.md:104
msgid ""
"```toml\n"
"[build]\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\"-C\", \"link-arg=-Tlink.x\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:112
#, fuzzy
msgid "See the serial output on Linux with:"
msgstr "Guarda l'output seriale su Linux con:"

#: src/exercises/bare-metal/compass.md:114
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/ttyACM0\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
#, fuzzy
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"O su Mac OS qualcosa di simile (il nome del dispositivo potrebbe essere "
"leggermente diverso):"

#: src/exercises/bare-metal/compass.md:120
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:124
#, fuzzy
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Usa Ctrl+A Ctrl+Q per uscire da picocom."

#: src/bare-metal/aps.md:1
#, fuzzy
msgid "# Application processors"
msgstr "# Processori di applicazioni"

#: src/bare-metal/aps.md:3
#, fuzzy
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing\n"
"something for Cortex-A. For simplicity we'll just work with QEMU's aarch64\n"
"['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) board."
msgstr ""
"Finora abbiamo parlato di microcontrollori, come la serie Arm Cortex-M. Ora "
"proviamo a scrivere\n"
"qualcosa per Cortex-A. Per semplicità lavoreremo solo con aarch64 di QEMU\n"
"['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) scheda."

#: src/bare-metal/aps.md:9
#, fuzzy
msgid ""
"* Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception\n"
"  levels on Arm CPUs, rings on x86), while application processors do.\n"
"* QEMU supports emulating various different machines or board models for "
"each architecture. The\n"
"  'virt' board doesn't correspond to any particular real hardware, but is "
"designed purely for\n"
"  virtual machines."
msgstr ""
"* In generale, i microcontrollori non hanno una MMU o più livelli di "
"privilegio (eccezione\n"
"  livelli su CPU Arm, anelli su x86), mentre i processori delle applicazioni "
"lo fanno.\n"
"* QEMU supporta l'emulazione di diverse macchine o modelli di scheda per "
"ciascuna architettura. IL\n"
"  La scheda 'virt' non corrisponde a nessun particolare hardware reale, ma è "
"progettata esclusivamente per\n"
"  macchine virtuali."

#: src/bare-metal/aps/entry-point.md:1
msgid "# Getting Ready to Rust"
msgstr ""

#: src/bare-metal/aps/entry-point.md:3
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""

#: src/bare-metal/aps/entry-point.md:5
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md:77
msgid ""
"* This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and\n"
"  setting up the stack pointer.\n"
"  * The BSS (block starting symbol, for historical reasons) is the part of "
"the object file which\n"
"    containing statically allocated variables which are initialised to zero. "
"They are omitted from\n"
"    the image, to avoid wasting space on zeroes. The compiler assumes that "
"the loader will take care\n"
"    of zeroing them.\n"
"* The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but\n"
"  we zero it to be sure.\n"
"* We need to enable the MMU and cache before reading or writing any memory. "
"If we don't:\n"
"  * Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target\n"
"    which sets `+strict-align` to prevent the compiler generating unaligned "
"accesses, so it should\n"
"    be fine in this case, but this is not necessarily the case in general.\n"
"  * If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM\n"
"    is accessing memory directly with the cache disabled, while the host has "
"cachable aliases to the\n"
"    same memory. Even if the host doesn't explicitly access the memory, "
"speculative accesses can\n"
"    lead to cache fills, and then changes from one or the other will get "
"lost when the cache is\n"
"    cleaned or the VM enables the cache. (Cache is keyed by physical "
"address, not VA or IPA.)\n"
"* For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1\n"
"  GiB of address space for devices, the next 1 GiB for DRAM, and another 1 "
"GiB higher up for more\n"
"  devices. This matches the memory layout that QEMU uses.\n"
"* We also set up the exception vector (`vbar_el1`), which we'll see more "
"about later.\n"
"* All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to\n"
"  run at a different exception level you'll need to modify `entry.S` "
"accordingly."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:1
#, fuzzy
msgid "# Inline assembly"
msgstr "# Assemblaggio in linea"

#: src/bare-metal/aps/inline-assembly.md:3
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example,\n"
"to make an <abbr title=\"hypervisor call\">HVC</abbr> to tell the firmware "
"to power off the system:"
msgstr ""
"A volte abbiamo bisogno di usare l'assembly per fare cose che non sono "
"possibili con il codice Rust. Per esempio,\n"
"per effettuare un <abbr title=\"hypervisor call\">HVC</abbr> per dire al "
"firmware di spegnere il sistema:"

#: src/bare-metal/aps/inline-assembly.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
"    unsafe {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            options(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:39
#, fuzzy
msgid ""
"(If you actually want to do this, use the [`smccc`][1] crate which has "
"wrappers for all these functions.)"
msgstr ""
"(Se vuoi davvero farlo, usa la cassa [`smccc`][1] che ha wrapper per tutte "
"queste funzioni.)"

#: src/bare-metal/aps/inline-assembly.md:43
#, fuzzy
msgid ""
"* PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system\n"
"  and CPU power states, among other things. It is implemented by EL3 "
"firmware and hypervisors on\n"
"  many systems.\n"
"* The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code,\n"
"  and ignore its contents afterwards. We need to use `inout` rather than "
"`in` because the call could\n"
"  potentially clobber the contents of the registers.\n"
"* This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our\n"
"  entry point in `entry.S`.\n"
"* `_x0`–`_x3` are the values of registers `x0`–`x3`, which are "
"conventionally used by the bootloader\n"
"  to pass things like a pointer to the device tree. According to the "
"standard aarch64 calling\n"
"  convention (which is what `extern \"C\"` specifies to use), registers `x0`–"
"`x7` are used for the\n"
"  first 8 arguments passed to a function, so `entry.S` doesn't need to do "
"anything special except\n"
"  make sure it doesn't change these registers.\n"
"* Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"* PSCI è l'Arm Power State Coordination Interface, un insieme standard di "
"funzioni per gestire il sistema\n"
"  e gli stati di alimentazione della CPU, tra le altre cose. È implementato "
"dal firmware EL3 e dagli hypervisor su\n"
"  molti sistemi.\n"
"* La sintassi `0 => _` significa inizializzare il registro a 0 prima di "
"eseguire il codice assembly inline,\n"
"  e ignorarne il contenuto in seguito. Dobbiamo usare \"inout\" piuttosto "
"che \"in\" perché la chiamata potrebbe\n"
"  potenzialmente intasare il contenuto dei registri.\n"
"* Questa funzione `main` deve essere `#[no_mangle]` e `extern \"C\"` perché "
"viene chiamata dal nostro\n"
"  punto di ingresso in \"entry.S\".\n"
"* `_x0`–`_x3` sono i valori dei registri `x0`–`x3`, che sono "
"convenzionalmente utilizzati dal bootloader\n"
"  per passare cose come un puntatore all'albero dei dispositivi. Secondo la "
"chiamata standard aarch64\n"
"  convenzione (che è ciò che `extern \"C\"` specifica di usare), i registri "
"`x0`–`x7` sono usati per\n"
"  primi 8 argomenti passati a una funzione, quindi `entry.S` non ha bisogno "
"di fare niente di speciale tranne\n"
"  assicurati che non modifichi questi registri.\n"
"* Eseguire l'esempio in QEMU con `make qemu_psci` in `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/mmio.md:1
#, fuzzy
msgid "# Volatile memory access for MMIO"
msgstr "# Accesso alla memoria volatile per MMIO"

#: src/bare-metal/aps/mmio.md:3
#, fuzzy
msgid ""
" * Use `pointer::read_volatile` and `pointer::write_volatile`.\n"
" * Never hold a reference.\n"
" * `addr_of!` lets you get fields of structs without creating an "
"intermediate reference."
msgstr ""
" * Usa `pointer::read_volatile` e `pointer::write_volatile`.\n"
" * Non tenere mai un riferimento.\n"
" * `addr_of!` consente di ottenere campi di struct senza creare un "
"riferimento intermedio."

#: src/bare-metal/aps/mmio.md:9
#, fuzzy
msgid ""
" * Volatile access: read or write operations may have side-effects, so "
"prevent the compiler or\n"
"   hardware from reordering, duplicating or eliding them.\n"
"   * Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that\n"
"     the value read is the same as the value just written, and not bother "
"actually reading memory.\n"
" * Some existing crates for volatile access to hardware do hold references, "
"but this is unsound.\n"
"   Whenever a reference exist, the compiler may choose to dereference it.\n"
" * Use the `addr_of!` macro to get struct field pointers from a pointer to "
"the struct."
msgstr ""
" * Accesso volatile: le operazioni di lettura o scrittura possono avere "
"effetti collaterali, quindi impedisci al compilatore o\n"
"   hardware dal riordinarli, duplicarli o eliminarli.\n"
"   * Di solito se scrivi e poi leggi, ad es. tramite un riferimento "
"mutabile, il compilatore può assumerlo\n"
"     il valore letto è uguale al valore appena scritto, e non disturba "
"effettivamente la lettura della memoria.\n"
" * Alcuni crate esistenti per l'accesso volatile all'hardware contengono "
"riferimenti, ma questo non è corretto.\n"
"   Ogni volta che esiste un riferimento, il compilatore può scegliere di "
"dereferenziarlo.\n"
" * Usa la macro `addr_of!` per ottenere i puntatori di campo struct da un "
"puntatore alla struct."

#: src/bare-metal/aps/uart.md:1
#, fuzzy
msgid "# Let's write a UART driver"
msgstr "# Scriviamo un driver UART"

#: src/bare-metal/aps/uart.md:3
#, fuzzy
msgid ""
"The QEMU 'virt' machine has a [PL011][1] UART, so let's write a driver for "
"that."
msgstr ""
"La macchina QEMU 'virt' ha un [PL011][1] UART, quindi scriviamo un driver "
"per quello."

#: src/bare-metal/aps/uart.md:5
msgid ""
"```rust,editable\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Minimal driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
"read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart.md:55
#, fuzzy
msgid ""
"* Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the\n"
"  caller of `Uart::new` guarantees that its safety requirements are met (i."
"e. that there is only\n"
"  ever one instance of the driver for a given UART, and nothing else "
"aliasing its address space),\n"
"  then it is always safe to call `write_byte` later because we can assume "
"the necessary\n"
"  preconditions.\n"
"* We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that\n"
"  would be much less convenient to use as every place that calls "
"`write_byte` would need to reason\n"
"  about the safety\n"
"* This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for\n"
"  soundness from a large number of places to a smaller number of places."
msgstr ""
"* Nota che `Uart::new` non è sicuro mentre gli altri metodi sono sicuri. "
"Questo perché finché il\n"
"  chiamante di `Uart::new` garantisce che i suoi requisiti di sicurezza "
"siano soddisfatti (cioè che ci sia solo\n"
"  mai un'istanza del driver per un dato UART, e nient'altro che alias il suo "
"spazio degli indirizzi),\n"
"  quindi è sempre sicuro chiamare `write_byte` in seguito perché possiamo "
"assumere il necessario\n"
"  precondizioni.\n"
"* Avremmo potuto fare il contrario (rendere `new` sicuro ma `write_byte` non "
"sicuro), ma quello\n"
"  sarebbe molto meno conveniente da usare poiché ogni posto che chiama "
"`write_byte` dovrebbe ragionare\n"
"  sulla sicurezza\n"
"* Questo è un modello comune per scrivere wrapper sicuri di codice non "
"sicuro: spostare l'onere della prova per\n"
"  solidità da un gran numero di posti a un numero minore di posti."

#: src/bare-metal/aps/uart.md:66
#, fuzzy
msgid "</detais>"
msgstr "</detais>"

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "# More traits"
msgstr "# Altri tratti"

#: src/bare-metal/aps/uart/traits.md:3
#, fuzzy
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"Abbiamo derivato il tratto `Debug`. Sarebbe utile implementare anche qualche "
"altro tratto."

#: src/bare-metal/aps/uart/traits.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:24
#, fuzzy
msgid ""
"* Implementing `Write` lets us use the `write!` and `writeln!` macros with "
"our `Uart` type.\n"
"* Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"* L'implementazione di `Write` ci permette di usare le macro `write!` e "
"`writeln!` con il nostro tipo `Uart`.\n"
"* Esegui l'esempio in QEMU con `make qemu_minimal` sotto `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/better-uart.md:1
#, fuzzy
msgid "# A better UART driver"
msgstr "# Un driver UART migliore"

#: src/bare-metal/aps/better-uart.md:3
#, fuzzy
msgid ""
"The PL011 actually has [a bunch more registers][1], and adding offsets to "
"construct pointers to access\n"
"them is error-prone and hard to read. Plus, some of them are bit fields "
"which would be nice to\n"
"access in a structured way."
msgstr ""
"Il PL011 in realtà ha [un mucchio di registri in più][1] e aggiunge offset "
"per costruire puntatori a cui accedere\n"
"è soggetto a errori e difficile da leggere. Inoltre, alcuni di loro sono "
"campi di bit che sarebbero carini\n"
"accedere in modo strutturato."

#: src/bare-metal/aps/better-uart.md:7
#, fuzzy
msgid ""
"| Offset | Register name | Width |\n"
"| ------ | ------------- | ----- |\n"
"| 0x00   | DR            | 12    |\n"
"| 0x04   | RSR           | 4     |\n"
"| 0x18   | FR            | 9     |\n"
"| 0x20   | ILPR          | 8     |\n"
"| 0x24   | IBRD          | 16    |\n"
"| 0x28   | FBRD          | 6     |\n"
"| 0x2c   | LCR_H         | 8     |\n"
"| 0x30   | CR            | 16    |\n"
"| 0x34   | IFLS          | 6     |\n"
"| 0x38   | IMSC          | 11    |\n"
"| 0x3c   | RIS           | 11    |\n"
"| 0x40   | MIS           | 11    |\n"
"| 0x44   | ICR           | 11    |\n"
"| 0x48   | DMACR         | 3     |"
msgstr ""
"| Compensazione | Registra nome | Larghezza |\n"
"| ------ | ------------- | ----- |\n"
"| 0x00 | DR | 12 |\n"
"| 0x04 | RSR | 4 |\n"
"| 0x18 | FR | 9 |\n"
"| 0x20 | ILPR | 8 |\n"
"| 0x24 | BIRS | 16 |\n"
"| 0x28 | FBRD | 6 |\n"
"| 0x2c | LCR_H | 8 |\n"
"| 0x30 | CR | 16 |\n"
"| 0x34 | IFL | 6 |\n"
"| 0x38 | IMSC | 11 |\n"
"| 0x3c | RIS| 11 |\n"
"| 0x40 | MIS | 11 |\n"
"| 0x44 | CRI | 11 |\n"
"| 0x48 | DMACR | 3 |"

#: src/bare-metal/aps/better-uart.md:26
#, fuzzy
msgid "- There are also some ID registers which have been omitted for brevity."
msgstr ""
"- Sono inoltre presenti alcuni registri identificativi che per brevità sono "
"stati omessi."

#: src/bare-metal/aps/better-uart/bitflags.md:1
#, fuzzy
msgid "# Bitflags"
msgstr "# Bitflag"

#: src/bare-metal/aps/better-uart/bitflags.md:3
#, fuzzy
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"Il crate [`bitflags`](https://crates.io/crates/bitflags) è utile per "
"lavorare con i bitflags."

#: src/bare-metal/aps/better-uart/bitflags.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:37
#, fuzzy
msgid ""
"* The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method\n"
"  implementations to get and set flags."
msgstr ""
"* La macro `bitflags!` crea un nuovo tipo qualcosa come `Flags(u16)`, "
"insieme a una serie di metodi\n"
"  implementazioni per ottenere e impostare flag."

#: src/bare-metal/aps/better-uart/registers.md:1
#, fuzzy
msgid "# Multiple registers"
msgstr "# Più registri"

#: src/bare-metal/aps/better-uart/registers.md:3
#, fuzzy
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"Possiamo usare una struct per rappresentare il layout di memoria dei "
"registri dell'UART."

#: src/bare-metal/aps/better-uart/registers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:41
#, fuzzy
msgid ""
"* [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells\n"
"  the compiler to lay the struct fields out in order, following the same "
"rules as C. This is\n"
"  necessary for our struct to have a predictable layout, as default Rust "
"representation allows the\n"
"  compiler to (among other things) reorder fields however it sees fit."
msgstr ""
"* [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) indica\n"
"  il compilatore per disporre i campi struct in ordine, seguendo le stesse "
"regole di C. Questo è\n"
"  necessario affinché la nostra struttura abbia un layout prevedibile, "
"poiché la rappresentazione predefinita di Rust lo consente\n"
"  compilatore per (tra le altre cose) riordinare i campi come meglio crede."

#: src/bare-metal/aps/better-uart/driver.md:1
#, fuzzy
msgid "# Driver"
msgstr "# Autista"

#: src/bare-metal/aps/better-uart/driver.md:3
#, fuzzy
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "Ora usiamo la nuova struttura `Registers` nel nostro driver."

#: src/bare-metal/aps/better-uart/driver.md:5
msgid ""
"```rust,editable,compile_fail\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:64
#, fuzzy
msgid ""
"* Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating\n"
"  an intermediate reference, which would be unsound."
msgstr ""
"* Notare l'uso di `addr_of!` / `addr_of_mut!` per ottenere puntatori a "
"singoli campi senza creare\n"
"  un riferimento intermedio, che sarebbe errato."

#: src/bare-metal/aps/better-uart/using.md:1
#: src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "# Using it"
msgstr "# Usandolo"

#: src/bare-metal/aps/better-uart/using.md:3
#, fuzzy
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming\n"
"bytes."
msgstr ""
"Scriviamo un piccolo programma usando il nostro driver per scrivere sulla "
"console seriale ed echo in entrata\n"
"byte."

#: src/bare-metal/aps/better-uart/using.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(b) = uart.read_byte() {\n"
"            uart.write_byte(b);\n"
"            match b {\n"
"                b'\\r' => {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' => break,\n"
"                _ => {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
#, fuzzy
msgid ""
"* As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our\n"
"  entry point code in `entry.S`. See the speaker notes there for details.\n"
"* Run the example in QEMU with `make qemu` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"* Come nell'esempio [inline assembly](../inline-assembly.md), questa "
"funzione `main` è chiamata dal nostro\n"
"  codice del punto di ingresso in \"entry.S\". Vedi le note del relatore lì "
"per i dettagli.\n"
"* Esegui l'esempio in QEMU con `make qemu` sotto `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/logging.md:3
#, fuzzy
msgid ""
"It would be nice to be able to use the logging macros from the [`log`][1] "
"crate. We can do this by\n"
"implementing the `Log` trait."
msgstr ""
"Sarebbe bello poter usare le macro di registrazione dalla cassa [`log`][1]. "
"Possiamo farlo con\n"
"implementando il tratto `Log`."

#: src/bare-metal/aps/logging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging.md:50
#, fuzzy
msgid ""
"* The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"* L'unwrap in `log` è sicuro perché inizializziamo `LOGGER` prima di "
"chiamare `set_logger`."

#: src/bare-metal/aps/logging/using.md:3
#, fuzzy
msgid "We need to initialise the logger before we use it."
msgstr "Dobbiamo inizializzare il logger prima di usarlo."

#: src/bare-metal/aps/logging/using.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
#, fuzzy
msgid ""
"* Note that our panic handler can now log details of panics.\n"
"* Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"* Nota che il nostro gestore del panico ora può registrare i dettagli dei "
"panico.\n"
"* Eseguire l'esempio in QEMU con `make qemu_logger` in `src/bare-metal/aps/"
"examples`."

#: src/bare-metal/aps/exceptions.md:1
#, fuzzy
msgid "# Exceptions"
msgstr "# Funzioni"

#: src/bare-metal/aps/exceptions.md:3
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous,\n"
"IRQ, FIQ, SError) from 4 states (current EL with SP0, current EL with SPx, "
"lower EL using AArch64,\n"
"lower EL using AArch32). We implement this in assembly to save volatile "
"registers to the stack\n"
"before calling into Rust code:"
msgstr ""

#: src/bare-metal/aps/exceptions.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/exceptions.md:64
msgid ""
"* EL is exception level; all our examples this afternoon run in EL1.\n"
"* For simplicity we aren't distinguishing between SP0 and SPx for the "
"current EL exceptions, or\n"
"  between AArch32 and AArch64 for the lower EL exceptions.\n"
"* For this example we just log the exception and power down, as we don't "
"expect any of them to\n"
"  actually happen.\n"
"* We can think of exception handlers and our main execution context more or "
"less like different\n"
"  threads. [`Send` and `Sync`][1] will control what we can share between "
"them, just like with threads.\n"
"  For example, if we want to share some value between exception handlers and "
"the rest of the\n"
"  program, and it's `Send` but not `Sync`, then we'll need to wrap it in "
"something like a `Mutex`\n"
"  and put it in a static."
msgstr ""

#: src/bare-metal/aps/other-projects.md:3
#, fuzzy
msgid ""
" * [oreboot](https://github.com/oreboot/oreboot)\n"
"   * \"coreboot without the C\"\n"
"   * Supports x86, aarch64 and RISC-V.\n"
"   * Relies on LinuxBoot rather than having many drivers itself.\n"
" * [Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)\n"
"   * Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling,\n"
"     page tables\n"
"   * Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good\n"
"     example to copy for production code.\n"
" * [`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)\n"
"   * Static analysis to determine maximum stack usage."
msgstr ""
" * [oreboot](https://github.com/oreboot/oreboot)\n"
"   * \"coreboot senza la C\"\n"
"   * Supporta x86, aarch64 e RISC-V.\n"
"   * Si basa su LinuxBoot piuttosto che avere molti driver.\n"
" * [Tutorial sul sistema operativo Rust RaspberryPi](https://github.com/rust-"
"embedded/rust-raspberrypi-OS-tutorials)\n"
"   * Inizializzazione, driver UART, bootloader semplice, JTAG, livelli di "
"eccezione, gestione delle eccezioni, tabelle delle pagine\n"
"   * Non tutto molto ben scritto, quindi attenzione.\n"
" * [`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)\n"
"   * Analisi statica per determinare l'utilizzo massimo dello stack."

#: src/bare-metal/aps/other-projects.md:17
msgid ""
"* The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read\n"
"  and write memory (e.g. the stack). However:\n"
"  * Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none`\n"
"    which sets `+strict-align` to prevent the compiler generating unaligned "
"accesses so it should be\n"
"    alright, but this is not necessarily the case in general.\n"
"  * If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM\n"
"    is accessing memory directly with the cache disabled, while the host has "
"cachable aliases to the\n"
"    same memory. Even if the host doesn't explicitly access the memory, "
"speculative accesses can\n"
"    lead to cache fills, and then changes from one or the other will get "
"lost. Again this is alright\n"
"    in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good\n"
"    pattern in general."
msgstr ""

#: src/bare-metal/useful-crates.md:1
#, fuzzy
msgid "# Useful crates"
msgstr "# Casse utili"

#: src/bare-metal/useful-crates.md:3
#, fuzzy
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"Esamineremo alcune casse che risolvono alcuni problemi comuni nella "
"programmazione bare-metal."

#: src/bare-metal/useful-crates/zerocopy.md:1
#, fuzzy
msgid "# `zerocopy`"
msgstr "# `zerocopia`"

#: src/bare-metal/useful-crates/zerocopy.md:3
#, fuzzy
msgid ""
"The [`zerocopy`][1] crate (from Fuchsia) provides traits and macros for "
"safely converting between\n"
"byte sequences and other types."
msgstr ""
"La cassa [`zerocopy`][1] (da Fuchsia) fornisce tratti e macro per la "
"conversione sicura tra\n"
"sequenze di byte e altri tipi."

#: src/bare-metal/useful-crates/zerocopy.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use zerocopy::AsBytes;\n"
"\n"
"#[repr(u32)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"enum RequestType {\n"
"    #[default]\n"
"    In = 0,\n"
"    Out = 1,\n"
"    Flush = 4,\n"
"}\n"
"\n"
"#[repr(C)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"struct VirtioBlockRequest {\n"
"    request_type: RequestType,\n"
"    reserved: u32,\n"
"    sector: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let request = VirtioBlockRequest {\n"
"        request_type: RequestType::Flush,\n"
"        sector: 42,\n"
"        ..Default::default()\n"
"    };\n"
"\n"
"    assert_eq!(\n"
"        request.as_bytes(),\n"
"        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:40
#, fuzzy
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for\n"
"working with structures shared with hardware e.g. by DMA, or sent over some "
"external interface."
msgstr ""
"Questo non è adatto per MMIO (poiché non utilizza letture e scritture "
"volatili), ma può essere utile per\n"
"lavorare con strutture condivise con l'hardware, ad es. tramite DMA o "
"inviato tramite un'interfaccia esterna."

#: src/bare-metal/useful-crates/zerocopy.md:45
#, fuzzy
msgid ""
"* `FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be\n"
"  converted from an untrusted sequence of bytes.\n"
"* Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all\n"
"  possible u32 values as discriminants, so not all byte patterns are valid.\n"
"* `zerocopy::byteorder` has types for byte-order aware numeric primitives.\n"
"* Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't\n"
"  run in the Playground because of the crate dependency.)"
msgstr ""
"* `FromBytes` può essere implementato per i tipi per i quali qualsiasi "
"modello di byte è valido, e quindi può tranquillamente esserlo\n"
"  convertito da una sequenza di byte non attendibile.\n"
"* Il tentativo di derivare `FromBytes` per questi tipi fallirebbe, perché "
"`RequestType` non usa tutti\n"
"  possibili valori u32 come discriminanti, quindi non tutti i modelli di "
"byte sono validi.\n"
"* `zerocopy::byteorder` ha tipi per primitive numeriche che riconoscono "
"l'ordine dei byte.\n"
"* Esegui l'esempio con `cargo run` sotto `src/bare-metal/useful-crates/"
"zerocopy-example/`. (Non lo farà\n"
"  eseguito nel Parco giochi a causa della dipendenza dalla cassa.)"

#: src/bare-metal/useful-crates/aarch64-paging.md:1
#, fuzzy
msgid "# `aarch64-paging`"
msgstr "# `aarch64-paging`"

#: src/bare-metal/useful-crates/aarch64-paging.md:3
#, fuzzy
msgid ""
"The [`aarch64-paging`][1] crate lets you create page tables according to the "
"AArch64 Virtual Memory\n"
"System Architecture."
msgstr ""
"Il crate [`aarch64-paging`][1] consente di creare tabelle di pagine in base "
"alla memoria virtuale AArch64\n"
"Architettura di sistema."

#: src/bare-metal/useful-crates/aarch64-paging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paging::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Create a new page table with identity mapping.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map a 2 MiB region of memory as read-only.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Set `TTBR0_EL1` to activate the page table.\n"
"idmap.activate();\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
#, fuzzy
msgid ""
"* For now it only supports EL1, but support for other exception levels "
"should be straightforward to\n"
"  add.\n"
"* This is used in Android for the [Protected VM Firmware][2].\n"
"* There's no easy way to run this example, as it needs to run on real "
"hardware or under QEMU."
msgstr ""
"* Per ora supporta solo EL1, ma il supporto per altri livelli di eccezione "
"dovrebbe essere semplice\n"
"  aggiungere.\n"
"* Viene utilizzato in Android per il [Firmware VM protetto][2].\n"
"* Non esiste un modo semplice per eseguire questo esempio, poiché deve "
"essere eseguito su hardware reale o sotto QEMU."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:1
#, fuzzy
msgid "# `buddy_system_allocator`"
msgstr "# `buddy_system_allocator`"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
#, fuzzy
msgid ""
"[`buddy_system_allocator`][1] is a third-party crate implementing a basic "
"buddy system allocator.\n"
"It can be used both for [`LockedHeap`][2] implementing [`GlobalAlloc`][3] so "
"you can use the\n"
"standard `alloc` crate (as we saw [before][4]), or for allocating other "
"address space. For example,\n"
"we might want to allocate MMIO space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`][1] è un crate di terze parti che implementa un "
"allocatore di sistema buddy di base.\n"
"Può essere utilizzato sia per [`LockedHeap`][2] che implementa "
"[`GlobalAlloc`][3] in modo da poter utilizzare il\n"
"crate standard `alloc` (come abbiamo visto [prima][4]), o per allocare altro "
"spazio di indirizzi. Per esempio,\n"
"potremmo voler allocare spazio MMIO per PCI BAR:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use buddy_system_allocator::FrameAllocator;\n"
"use core::alloc::Layout;\n"
"\n"
"fn main() {\n"
"    let mut allocator = FrameAllocator::<32>::new();\n"
"    allocator.add_frame(0x200_0000, 0x400_0000);\n"
"\n"
"    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
"    let bar = allocator\n"
"        .alloc_aligned(layout)\n"
"        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
"    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:26
#, fuzzy
msgid ""
"* PCI BARs always have alignment equal to their size.\n"
"* Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't\n"
"  run in the Playground because of the crate dependency.)"
msgstr ""
"* Le barre PCI hanno sempre un allineamento uguale alla loro dimensione.\n"
"* Esegui l'esempio con `cargo run` sotto `src/bare-metal/useful-crates/"
"allocator-example/`. (Non lo farà\n"
"  eseguito nel Parco giochi a causa della dipendenza dalla cassa.)"

#: src/bare-metal/useful-crates/tinyvec.md:1
#, fuzzy
msgid "# `tinyvec`"
msgstr "# `tinyvec`"

#: src/bare-metal/useful-crates/tinyvec.md:3
#, fuzzy
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation.\n"
"[`tinyvec`][1] provides this: a vector backed by an array or slice, which "
"could be statically\n"
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to\n"
"use more than are allocated."
msgstr ""
"A volte vuoi qualcosa che possa essere ridimensionato come un `Vec`, ma "
"senza allocazione dell'heap.\n"
"[`tinyvec`][1] fornisce questo: un vettore supportato da un array o da una "
"slice, che potrebbe essere staticamente\n"
"allocato o in pila, che tiene traccia di quanti elementi vengono utilizzati "
"e va in panico se ci provi\n"
"utilizzare più di quanto assegnato."

#: src/bare-metal/useful-crates/tinyvec.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use tinyvec::{array_vec, ArrayVec};\n"
"\n"
"fn main() {\n"
"    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.push(7);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.remove(1);\n"
"    println!(\"{numbers:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:23
#, fuzzy
msgid ""
"* `tinyvec` requires that the element type implement `Default` for "
"initialisation.\n"
"* The Rust Playground includes `tinyvec`, so this example will run fine "
"inline."
msgstr ""
"* `tinyvec` richiede che il tipo di elemento implementi `Default` per "
"l'inizializzazione.\n"
"* Rust Playground include `tinyvec`, quindi questo esempio funzionerà "
"correttamente in linea."

#: src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "# `spin`"
msgstr "# `gira`"

#: src/bare-metal/useful-crates/spin.md:3
#, fuzzy
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in\n"
"`core` or `alloc`. How can we manage synchronisation or interior mutability, "
"such as for sharing\n"
"state between different CPUs?"
msgstr ""
"`std::sync::Mutex` e le altre primitive di sincronizzazione da `std::sync` "
"non sono disponibili in\n"
"`core` o `alloc`. Come gestire la sincronizzazione o la mutevolezza "
"interiore, ad esempio per la condivisione\n"
"stato tra diverse CPU?"

#: src/bare-metal/useful-crates/spin.md:7
#, fuzzy
msgid ""
"The [`spin`][1] crate provides spinlock-based equivalents of many of these "
"primitives."
msgstr ""
"La cassa [`spin`][1] fornisce equivalenti basati su spinlock di molte di "
"queste primitive."

#: src/bare-metal/useful-crates/spin.md:9
msgid ""
"```rust,editable,compile_fail\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
"\n"
"fn main() {\n"
"    println!(\"count: {}\", counter.lock());\n"
"    *counter.lock() += 2;\n"
"    println!(\"count: {}\", counter.lock());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:23
msgid ""
"* Be careful to avoid deadlock if you take locks in interrupt handlers.\n"
"* `spin` also has a ticket lock mutex implementation; equivalents of "
"`RwLock`, `Barrier` and `Once`\n"
"  from `std::sync`;  and `Lazy` for lazy initialisation.\n"
"* The [`once_cell`][2] crate also has some useful types for late "
"initialisation with a slightly\n"
"  different approach to `spin::once::Once`.\n"
"* The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""

#: src/bare-metal/android.md:1
#, fuzzy
msgid "# Android"
msgstr "#Androide"

#: src/bare-metal/android.md:3
#, fuzzy
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build\n"
"your Rust code, then a `cc_binary` with a linker script to produce the "
"binary itself, and then a\n"
"`raw_binary` to convert the ELF to a raw binary ready to be run."
msgstr ""
"Per costruire un binario Rust bare-metal in AOSP, devi usare una regola "
"`rust_ffi_static` Soong per costruire\n"
"il tuo codice Rust, poi un `cc_binary` con uno script linker per produrre il "
"binario stesso, e poi a\n"
"`raw_binary` per convertire l'ELF in un binario grezzo pronto per essere "
"eseguito."

#: src/bare-metal/android.md:7
msgid ""
"```soong\n"
"rust_ffi_static {\n"
"    name: \"libvmbase_example\",\n"
"    defaults: [\"vmbase_ffi_defaults\"],\n"
"    crate_name: \"vmbase_example\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libvmbase\",\n"
"    ],\n"
"}\n"
"\n"
"cc_binary {\n"
"    name: \"vmbase_example\",\n"
"    defaults: [\"vmbase_elf_defaults\"],\n"
"    srcs: [\n"
"        \"idmap.S\",\n"
"    ],\n"
"    static_libs: [\n"
"        \"libvmbase_example\",\n"
"    ],\n"
"    linker_scripts: [\n"
"        \"image.ld\",\n"
"        \":vmbase_sections\",\n"
"    ],\n"
"}\n"
"\n"
"raw_binary {\n"
"    name: \"vmbase_example_bin\",\n"
"    stem: \"vmbase_example.bin\",\n"
"    src: \":vmbase_example\",\n"
"    enabled: false,\n"
"    target: {\n"
"        android_arm64: {\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:1
#, fuzzy
msgid "# vmbase"
msgstr "# vbase"

#: src/bare-metal/android/vmbase.md:3
#, fuzzy
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase][1] library provides a "
"linker script and useful\n"
"defaults for the build rules, along with an entry point, UART console "
"logging and more."
msgstr ""
"Per le VM in esecuzione in crosvm su aarch64, la libreria [vmbase][1] "
"fornisce uno script linker e utili\n"
"impostazioni predefinite per le regole di compilazione, insieme a un punto "
"di ingresso, la registrazione della console UART e altro ancora."

#: src/bare-metal/android/vmbase.md:6
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use vmbase::{main, println};\n"
"\n"
"main!(main);\n"
"\n"
"pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
"    println!(\"Hello world\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:21
#, fuzzy
msgid ""
"* The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point.\n"
"* The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown\n"
"  the VM if your main function returns."
msgstr ""
"* La macro `main!` contrassegna la tua funzione principale, da chiamare dal "
"punto di ingresso `vmbase`.\n"
"* Il punto di ingresso `vmbase` gestisce l'inizializzazione della console ed "
"emette un PSCI_SYSTEM_OFF per l'arresto\n"
"  la VM se la tua funzione principale ritorna."

#: src/exercises/bare-metal/afternoon.md:3
#, fuzzy
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "Scriveremo un driver per il dispositivo orologio in tempo reale PL031."

#: src/exercises/bare-metal/rtc.md:1
#, fuzzy
msgid "# RTC driver"
msgstr "# Driver RTC"

#: src/exercises/bare-metal/rtc.md:3
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031][1] real-time clock at 0x9010000. "
"For this exercise, you\n"
"should write a driver for it."
msgstr ""
"La macchina QEMU aarch64 virt ha un orologio in tempo reale [PL031][1] a "
"0x9010000. Per questo esercizio, tu\n"
"dovrebbe scrivere un driver per esso."

#: src/exercises/bare-metal/rtc.md:6
#, fuzzy
msgid ""
"1. Use it to print the current time to the serial console. You can use the "
"[`chrono`][2] crate for\n"
"   date/time formatting.\n"
"2. Use the match register and raw interrupt status to busy-wait until a "
"given time, e.g. 3 seconds\n"
"   in the future. (Call [`core::hint::spin_loop`][3] inside the loop.)\n"
"3. _Extension if you have time:_ Enable and handle the interrupt generated "
"by the RTC match. You can\n"
"   use the driver provided in the [`arm-gic`][4] crate to configure the Arm "
"Generic Interrupt Controller.\n"
"   - Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`.\n"
"   - Once the interrupt is enabled, you can put the core to sleep via "
"`arm_gic::wfi()`, which will cause the core to sleep until it receives an "
"interrupt.\n"
"   "
msgstr ""
"1. Usalo per stampare l'ora corrente sulla console seriale. Puoi usare la "
"cassa [`chrono`][2] per\n"
"   formattazione data/ora.\n"
"2. Utilizzare il registro delle corrispondenze e lo stato di interrupt non "
"elaborato per attendere occupato fino a un determinato momento, ad es. 3 "
"secondi\n"
"   in futuro. (Chiama [`core::hint::spin_loop`][3] all'interno del ciclo.)\n"
"3. _Estensione se hai tempo:_ Abilita e gestisci l'interrupt generato dalla "
"corrispondenza RTC. Puoi\n"
"   utilizzare il driver fornito nella cassa [`arm-gic`][4] per configurare "
"Arm Generic Interrupt Controller.\n"
"   - Usa l'interrupt RTC, che è cablato al GIC come `IntId::spi(2)`.\n"
"   - Una volta abilitato l'interrupt, puoi mettere il core in sleep tramite "
"`arm_gic::wfi()`, che farà dormire il core finché non riceve un interrupt.\n"
"   "

#: src/exercises/bare-metal/rtc.md:16
#, fuzzy
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc`\n"
"directory for the following files."
msgstr ""
"Scarica il [modello di esercizio](../../comprehensive-rust-exercises.zip) e "
"cerca in `rtc`\n"
"directory per i seguenti file."

#: src/exercises/bare-metal/rtc.md:23
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Create instance of RTC driver and print current time.\n"
"\n"
"    // TODO: Wait for 3 seconds.\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:75
#, fuzzy
msgid ""
"`src/exceptions.rs` (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""
"`src/exceptions.rs` (dovresti solo cambiarlo per la terza parte "
"dell'esercizio):"

#: src/exercises/bare-metal/rtc.md:77
#, fuzzy
msgid "<!-- File src/exceptions.rs -->"
msgstr "<!-- File src/exception.rs -->"

#: src/exercises/bare-metal/rtc.md:79
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending "
"interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
#, fuzzy
msgid "`src/logger.rs` (you shouldn't need to change this):"
msgstr "`src/logger.rs` (non dovrebbe essere necessario modificarlo):"

#: src/exercises/bare-metal/rtc.md:151
#, fuzzy
msgid "<!-- File src/logger.rs -->"
msgstr "<!-- File src/logger.rs -->"

#: src/exercises/bare-metal/rtc.md:153
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: main\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:210
#, fuzzy
msgid "`src/pl011.rs` (you shouldn't need to change this):"
msgstr "`src/pl011.rs` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:212
#, fuzzy
msgid "<!-- File src/pl011.rs -->"
msgstr "<!-- File src/pl011.rs -->"

#: src/exercises/bare-metal/rtc.md:214
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Flags\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART Receive Status Register / Error Clear Register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 << 0;\n"
"        /// Parity error.\n"
"        const PE = 1 << 1;\n"
"        /// Break error.\n"
"        const BE = 1 << 2;\n"
"        /// Overrun error.\n"
"        const OE = 1 << 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Registers\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registers\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:389
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"rtc\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"arm-gic = \"0.1.0\"\n"
"bitflags = \"2.0.0\"\n"
"chrono = { version = \"0.4.24\", default-features = false }\n"
"log = \"0.4.17\"\n"
"smccc = \"0.1.1\"\n"
"spin = \"0.9.8\"\n"
"\n"
"[build-dependencies]\n"
"cc = \"1.0.73\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:410
#, fuzzy
msgid "`build.rs` (you shouldn't need to change this):"
msgstr "`build.rs` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:412
#, fuzzy
msgid "<!-- File build.rs -->"
msgstr "<!-- File build.rs -->"

#: src/exercises/bare-metal/rtc.md:414
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:446
#, fuzzy
msgid "`entry.S` (you shouldn't need to change this):"
msgstr "`entry.S` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:448
#, fuzzy
msgid "<!-- File entry.S -->"
msgstr "<!-- Voce file.S -->"

#: src/exercises/bare-metal/rtc.md:450
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:595
#, fuzzy
msgid "`exceptions.S` (you shouldn't need to change this):"
msgstr "`eccezioni.S` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:597
#, fuzzy
msgid "<!-- File exceptions.S -->"
msgstr "<!-- File eccezioni.S -->"

#: src/exercises/bare-metal/rtc.md:599
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:780
#, fuzzy
msgid "`idmap.S` (you shouldn't need to change this):"
msgstr "`idmap.S` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:782
#, fuzzy
msgid "<!-- File idmap.S -->"
msgstr "<!-- File idmap.S -->"

#: src/exercises/bare-metal/rtc.md:784
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:829
#, fuzzy
msgid "`image.ld` (you shouldn't need to change this):"
msgstr "`image.ld` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:831
#, fuzzy
msgid "<!-- File image.ld -->"
msgstr "<!-- File image.ld -->"

#: src/exercises/bare-metal/rtc.md:833
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:940
#, fuzzy
msgid "`Makefile` (you shouldn't need to change this):"
msgstr "`Makefile` (non dovresti aver bisogno di cambiarlo):"

#: src/exercises/bare-metal/rtc.md:942
#, fuzzy
msgid "<!-- File Makefile -->"
msgstr "<!-- File Makefile -->"

#: src/exercises/bare-metal/rtc.md:944
msgid ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"# you may not use this file except in compliance with the License.\n"
"# You may obtain a copy of the License at\n"
"#\n"
"#      http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Unless required by applicable law or agreed to in writing, software\n"
"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"# See the License for the specific language governing permissions and\n"
"# limitations under the License.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio "
"-display none -kernel $< -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:989
msgid ""
"```toml\n"
"[build]\n"
"target = \"aarch64-unknown-none\"\n"
"rustflags = [\"-C\", \"link-arg=-Timage.ld\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:995
#, fuzzy
msgid "Run the code in QEMU with `make qemu`."
msgstr "Esegui il codice in QEMU con `make qemu`."

#: src/concurrency.md:1
#, fuzzy
msgid "# Welcome to Concurrency in Rust"
msgstr "Benvenuti a Comprehensive Rust 🦀"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust ha il pieno supporto per la concorrenza utilizzando i thread del "
"sistema operativo con mutex e\n"
"canali."

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency "
"bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Il sistema di tipo Rust gioca un ruolo importante nella creazione di molti "
"bug di concorrenza\n"
"bug in fase di compilazione. Questo è spesso indicato come _concorrenza "
"senza paura_ da quando tu\n"
"può fare affidamento sul compilatore per garantire la correttezza in fase di "
"esecuzione."

#: src/concurrency/threads.md:1
#, fuzzy
msgid "# Threads"
msgstr "# Discussioni"

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr "I thread Rust funzionano in modo simile ai thread in altre lingue:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
#, fuzzy
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* I thread sono tutti thread demoni, il thread principale non li aspetta.\n"
"* I thread panic sono indipendenti l'uno dall'altro.\n"
"  * Panics può trasportare un payload, che può essere decompresso con "
"`downcast_ref`."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"* Notice that the thread is stopped before it reaches 10 — the main thread "
"is\n"
"  not waiting.\n"
"\n"
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait "
"for\n"
"  the thread to finish.\n"
"\n"
"* Trigger a panic in the thread, notice how this doesn't affect `main`.\n"
"\n"
"* Use the `Result` return value from `handle.join()` to get access to the "
"panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""
"* Si noti che il thread viene interrotto prima che raggiunga 10 — il thread "
"principale lo è\n"
"  non aspettare.\n"
"\n"
"* Usa `let handle = thread::spawn(...)` e successivamente `handle.join()` "
"per aspettare\n"
"  il filo per finire.\n"
"\n"
"* Attivare un panico nel thread, notare come questo non influisca su "
"`main`.\n"
"\n"
"* Usa il valore di ritorno `Result` da `handle.join()` per ottenere "
"l'accesso al panico\n"
"  carico utile. Questo è un buon momento per parlare di [`Any`]."

#: src/concurrency/scoped-threads.md:1
#, fuzzy
msgid "# Scoped Threads"
msgstr "# Thread con ambito"

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "I thread normali non possono prendere in prestito dal loro ambiente:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:17
#, fuzzy
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "Tuttavia, puoi utilizzare un [thread con ambito][1] per questo:"

#: src/concurrency/scoped-threads.md:19
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:37
#, fuzzy
msgid ""
"* The reason for that is that when the `thread::scope` function completes, "
"all the threads are guaranteed to be joined, so they can return borrowed "
"data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads.\n"
"    "
msgstr ""
"* La ragione di ciò è che quando la funzione `thread::scope` viene "
"completata, è garantito che tutti i thread vengano uniti, in modo che "
"possano restituire dati presi in prestito.\n"
"* Si applicano le normali regole di prestito di Rust: puoi prendere in "
"prestito in modo mutabile da un thread o immutabile da un numero qualsiasi "
"di thread.\n"
"    "

#: src/concurrency/channels.md:1
#, fuzzy
msgid "# Channels"
msgstr "# Canali"

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"I canali Rust hanno due parti: un `Sender<T>` e un `Receiver<T>`. Le due "
"parti\n"
"sono collegati tramite il canale, ma vedi solo i punti finali."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
#, fuzzy
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and "
"`SyncSender` implement `Clone` (so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` sta per Multi-Producer, Single-Consumer. `Sender` e `SyncSender` "
"implementano `Clone` (quindi\n"
"  puoi creare più produttori) ma `Receiver` no.\n"
"* `send()` e `recv()` restituiscono `Risultato`. Se restituiscono \"Err\", "
"significa che la controparte \"Mittente\" o\n"
"  `Receiver` viene eliminato e il canale viene chiuso."

#: src/concurrency/channels/unbounded.md:1
#, fuzzy
msgid "# Unbounded Channels"
msgstr "# Canali illimitati"

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Ottieni un canale illimitato e asincrono con `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:1
#, fuzzy
msgid "# Bounded Channels"
msgstr "# Canali delimitati"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr ""
"I canali limitati e sincroni fanno in modo che `send` blocchi il thread "
"corrente:"

#: src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:31
msgid ""
"* Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel.\n"
"* A call to `send` will abort with an error (that is why it returns "
"`Result`) if the channel is closed. A channel is closed when the receiver is "
"dropped.\n"
"* A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`.\n"
"    "
msgstr ""

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "# `Send` and `Sync`"
msgstr "# `Invia` e `Sincronizza`"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across thread? The answer is in "
"two traits:"
msgstr ""
"Come fa Rust a sapere di vietare l'accesso condiviso attraverso il thread? "
"La risposta è in due tratti:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a "
"thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a "
"thread\n"
"  boundary."
msgstr ""
"* [`Send`][1]: un tipo `T` è `Send` se è sicuro spostare una `T` attraverso "
"un thread\n"
"  confine.\n"
"* [`Sync`][2]: un tipo `T` è `Sync` se è sicuro spostare una `&T` attraverso "
"un thread\n"
"  confine."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically "
"derive them for your types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement "
"them manually when you\n"
"know it is valid."
msgstr ""
"\"Send\" e \"Sync\" sono [tratti non sicuri][3]. Il compilatore li deriverà "
"automaticamente per i tuoi tipi\n"
"purché contengano solo i tipi \"Send\" e \"Sync\". Puoi anche implementarli "
"manualmente quando tu\n"
"sapere che è valido."

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"* One can think of these traits as markers that the type has certain thread-"
"safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  "
msgstr ""
"* Si può pensare a questi tratti come indicatori che il tipo ha determinate "
"proprietà di sicurezza del thread.\n"
"* Possono essere usati nei vincoli generici come tratti normali.\n"
"  "

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "# `Send`"
msgstr "# `Invia`"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Send`][1] if it is safe to move a `T` value to another "
"thread."
msgstr ""
"> Un tipo `T` è [`Send`][1] se è sicuro spostare un valore `T` in un altro "
"thread."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run\n"
"in that thread. So the question is when you can allocate a value in one "
"thread\n"
"and deallocate it in another."
msgstr ""
"L'effetto dello spostamento della proprietà su un altro thread è che i "
"_destructors_ verranno eseguiti\n"
"in quel filo. Quindi la domanda è quando puoi allocare un valore in un "
"thread\n"
"e deallocarlo in un altro."

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a\n"
"single thread."
msgstr ""

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "# `Sync`"
msgstr "# `Sincronizza`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from "
"multiple\n"
"> threads at the same time."
msgstr ""
"> Un tipo `T` è [`Sync`][1] se è sicuro accedere a un valore `T` da più\n"
"> thread contemporaneamente."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Più precisamente la definizione è:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> `T` è `Sync` se e solo se `&T` è `Send`"

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Questa affermazione è essenzialmente un modo abbreviato per dire che se un "
"tipo è thread-safe per l'uso condiviso, è anche thread-safe per passarne i "
"riferimenti attraverso i thread."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Questo perché se un tipo è Sync significa che può essere condiviso tra più "
"thread senza il rischio di corse di dati o altri problemi di "
"sincronizzazione, quindi è sicuro spostarlo su un altro thread. Un "
"riferimento al tipo è anche sicuro da spostare in un altro thread, perché è "
"possibile accedere ai dati a cui fa riferimento da qualsiasi thread in modo "
"sicuro."

#: src/concurrency/send-sync/examples.md:1
#, fuzzy
msgid "# Examples"
msgstr "# Esempi"

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "## `Send + Sync`"
msgstr "## \"Invia + Sincronizza\"."

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr ""
"La maggior parte dei tipi che incontri sono \"Invia + sincronizzazione\":"

#: src/concurrency/send-sync/examples.md:7
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"I tipi generici sono in genere \"Send + Sync\" quando i parametri di tipo lo "
"sono\n"
"\"Invia + Sincronizza\"."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "## `Send + !Sync`"
msgstr "## \"Invia + !Sincronizza\"."

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"Questi tipi possono essere spostati in altri thread, ma non sono thread-"
"safe.\n"
"Tipicamente a causa della mutevolezza interna:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Ricevitore<T>`\n"
"* `Cella<T>`\n"
"* `RefCella<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "## `!Send + Sync`"
msgstr "## `!Invia + Sincronizza`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Questi tipi sono thread-safe, ma non possono essere spostati in un altro "
"thread:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on "
"the\n"
"  thread which created them."
msgstr ""
"* `MutexGuard<T>`: utilizza primitive a livello di sistema operativo che "
"devono essere deallocate su\n"
"  thread che li ha creati."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "## `!Send + !Sync`"
msgstr "## `!Invia + !Sync`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Questi tipi non sono thread-safe e non possono essere spostati in altri "
"thread:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: ogni `Rc<T>` ha un riferimento a un `RcBox<T>`, che contiene un\n"
"  conteggio dei riferimenti non atomici.\n"
"* `*const T`, `*mut T`: Rust presuppone che i puntatori grezzi possano avere "
"caratteri speciali\n"
"  considerazioni sulla concorrenza"

#: src/concurrency/shared_state.md:1
#, fuzzy
msgid "# Shared State"
msgstr "# Stato condiviso"

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This "
"is\n"
"primarily done via two types:"
msgstr ""
"Rust utilizza il sistema dei tipi per imporre la sincronizzazione dei dati "
"condivisi. Questo è\n"
"fatto principalmente tramite due tipi:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between "
"threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], riferimento atomico contato `T`: gestisce la condivisione "
"tra thread e\n"
"  si occupa di deallocare `T` quando viene eliminato l'ultimo riferimento,\n"
"* [`Mutex<T>`][2]: garantisce l'accesso mutuamente esclusivo al valore `T`."

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "# `Arc`"
msgstr "# `Arco`"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid "[`Arc<T>`][1] allows shared read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`][1] consente l'accesso condiviso in sola lettura tramite `Arc::"
"clone`:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of "
"`Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to "
"detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc` sta per \"Atomic Reference Counted\", una versione thread-safe di "
"`Rc` che usa atomic\n"
"  operazioni.\n"
"* `Arc<T>` implementa `Clone` indipendentemente dal fatto che `T` lo faccia. "
"Implementa `Send` e `Sync` se e solo `T`\n"
"  li implementa entrambi.\n"
"* `Arc::clone()` ha il costo delle operazioni atomiche che vengono eseguite, "
"ma dopo ciò l'uso di\n"
"  `T` è gratuito.\n"
"* Attenzione ai cicli di riferimento, `Arc` non usa un garbage collector per "
"rilevarli.\n"
"    * `std::sync::Weak` può aiutare."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"[`Mutex<T>`][1] garantisce l'esclusione reciproca _e_ consente l'accesso "
"mutabile a `T`\n"
"dietro un'interfaccia di sola lettura:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr ""
"Nota come abbiamo una coperta [`impl<T: Send> Sync per Mutex<T>`][2].\n"
"implementazione."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"* `Mutex` in Rust looks like a collection with just one element - the "
"protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the "
"protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that\n"
"      the data it protected might be in an inconsistent state. Calling "
"`lock()` on a poisoned mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error "
"to recover the data\n"
"      regardless."
msgstr ""
"* `Mutex` in Rust sembra una raccolta con un solo elemento: i dati "
"protetti.\n"
"    * Non è possibile dimenticare di acquisire il mutex prima di accedere ai "
"dati protetti.\n"
"* Puoi ottenere un `&mut T` da un `&Mutex<T>` prendendo il lock. Il "
"`MutexGuard` assicura che il file\n"
"  `&mut T` non sopravvive al blocco mantenuto.\n"
"* `Mutex<T>` implementa sia `Send` che `Sync` se `T` implementa `Send`.\n"
"* Una controparte del blocco lettura-scrittura - `RwLock`.\n"
"* Perché `lock()` restituisce un `Risultato`?\n"
"    * Se il thread che conteneva il `Mutex` va nel panico, il `Mutex` "
"diventa \"avvelenato\" per segnalare che\n"
"      i dati protetti potrebbero trovarsi in uno stato incoerente. Chiamare "
"`lock()` su un mutex avvelenato\n"
"      fallisce con un [`PoisonError`]. Puoi chiamare `into_inner()` "
"sull'errore per recuperare i dati\n"
"      indipendentemente."

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Vediamo `Arc` e `Mutex` in azione:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
#, fuzzy
msgid "Possible solution:"
msgstr "Possibile soluzione:"

#: src/concurrency/shared_state/example.md:25
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:49
#, fuzzy
msgid "Notable parts:"
msgstr "Parti notevoli:"

#: src/concurrency/shared_state/example.md:51
#, fuzzy
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable "
"state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"* `v` è racchiuso sia in `Arc` che in `Mutex`, perché i loro interessi sono "
"ortogonali.\n"
"  * Avvolgere un `Mutex` in un `Arc` è un modello comune per condividere lo "
"stato mutabile tra i thread.\n"
"* `v: Arc<_>` deve essere clonato come `v2` prima di poter essere spostato "
"in un altro thread. Nota che \"move\" è stato aggiunto alla firma lambda.\n"
"* I blocchi vengono introdotti per restringere il più possibile l'ambito di "
"`LockGuard`."

#: src/exercises/concurrency/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "Mettiamo in pratica le nostre nuove abilità di concorrenza con"

#: src/exercises/concurrency/morning.md:5
#, fuzzy
msgid ""
"* Dining philosophers: a classic problem in concurrency.\n"
"\n"
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"* Filosofi a tavola: un classico problema in concorrenza.\n"
"\n"
"* Verifica link multi-thread: un progetto più ampio in cui utilizzerai "
"Cargo\n"
"  scaricare le dipendenze e quindi controllare i collegamenti in parallelo."

#: src/exercises/concurrency/dining-philosophers.md:1
#, fuzzy
msgid "# Dining Philosophers"
msgstr "# Filosofi da pranzo"

#: src/exercises/concurrency/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"Il problema dei filosofi da pranzo è un classico problema in concorrenza:"

#: src/exercises/concurrency/dining-philosophers.md:5
#, fuzzy
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has "
"their\n"
"> own place at the table. There is a fork between each plate. The dish "
"served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher "
"can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat "
"their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will "
"only\n"
"> be available when their two nearest neighbors are thinking, not eating. "
"After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> Cinque filosofi cenano insieme alla stessa tavola. Ogni filosofo ha il "
"suo\n"
"> proprio posto a tavola. C'è una forchetta tra ogni piatto. Il piatto "
"servito è\n"
"> una specie di spaghetto che si mangia con due forchette. Ogni filosofo "
"può\n"
"> solo alternativamente pensa e mangia. Inoltre, un filosofo può solo "
"mangiare il loro\n"
"> gli spaghetti quando hanno sia la forchetta destra che quella sinistra. "
"Quindi solo due forchette\n"
"> essere disponibile quando i loro due vicini più vicini stanno pensando, "
"non mangiando. Dopo\n"
"> un singolo filosofo finisce di mangiare, metteranno giù entrambe le "
"forchette."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for\n"
"this exercise. Copy the code below to a file called `src/main.rs`, fill out "
"the\n"
"blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Avrai bisogno di un'[installazione Cargo](../../cargo/running-locally.md) "
"locale per\n"
"questo esercizio. Copia il codice qui sotto in un file chiamato `src/main."
"rs`, compila il file\n"
"spazi vuoti e verificare che `cargo run` non vada in stallo:"

#: src/exercises/concurrency/dining-philosophers.md:19
msgid ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make each of them think and eat 100 times\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
#, fuzzy
msgid "You can use the following `Cargo.toml`:"
msgstr "Puoi usare il seguente `Cargo.toml`:"

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:1
#, fuzzy
msgid "# Multi-threaded Link Checker"
msgstr "# Verifica link multi-thread"

#: src/exercises/concurrency/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until "
"all\n"
"pages have been validated."
msgstr ""
"Usiamo le nostre nuove conoscenze per creare un verificatore di collegamenti "
"multi-thread. Dovrebbe\n"
"iniziare da una pagina Web e verificare che i collegamenti sulla pagina "
"siano validi. Dovrebbe\n"
"controlla ricorsivamente altre pagine sullo stesso dominio e continua a "
"farlo fino a quando all\n"
"le pagine sono state convalidate."

#: src/exercises/concurrency/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Per questo, avrai bisogno di un client HTTP come [`reqwest`][1]. Crea un "
"nuovo\n"
"Progetto Cargo e `richiedilo` come dipendenza con:"

#: src/exercises/concurrency/link-checker.md:11
msgid ""
"```shell\n"
"cargo new link-checker\n"
"cd link-checker\n"
"cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:17
#, fuzzy
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit "
"the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> Se `cargo add` fallisce con `error: no such subcommand`, modifica il file\n"
"> File `Cargo.toml` a mano. Aggiungere le dipendenze elencate di seguito."

#: src/exercises/concurrency/link-checker.md:20
#, fuzzy
msgid ""
"You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr ""
"Avrai anche bisogno di un modo per trovare i link. Possiamo usare [`scraper`]"
"[2] per questo:"

#: src/exercises/concurrency/link-checker.md:22
msgid ""
"```shell\n"
"cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] "
"for\n"
"that:"
msgstr ""
"Infine, avremo bisogno di un modo per gestire gli errori. Usiamo "
"[`thiserror`][3] per\n"
"Quello:"

#: src/exercises/concurrency/link-checker.md:29
msgid ""
"```shell\n"
"cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:33
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"Le chiamate `cargo add` aggiorneranno il file `Cargo.toml` in questo modo:"

#: src/exercises/concurrency/link-checker.md:37
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:50
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"Ora puoi scaricare la pagina iniziale. Prova con un piccolo sito come\n"
"`https://www.google.org/`."

#: src/exercises/concurrency/link-checker.md:53
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Il tuo file `src/main.rs` dovrebbe assomigliare a questo:"

#: src/exercises/concurrency/link-checker.md:57
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}\n"
"\n"
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"\n"
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: "
"{err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Ok(valid_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:100
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Esegui il codice in `src/main.rs` con"

#: src/exercises/concurrency/link-checker.md:102
msgid ""
"```shell\n"
"cargo run\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:106
#: src/exercises/concurrency/chat-app.md:140
#, fuzzy
msgid "## Tasks"
msgstr "## Compiti"

#: src/exercises/concurrency/link-checker.md:108
#, fuzzy
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to "
"a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that "
"you\n"
"  don't end up being blocked by the site."
msgstr ""
"* Usa i thread per controllare i collegamenti in parallelo: invia gli URL da "
"controllare a a\n"
"  channel e lasciare che alcuni thread controllino gli URL in parallelo.\n"
"* Estendilo per estrarre in modo ricorsivo i collegamenti da tutte le pagine "
"del file\n"
"  dominio \"www.google.org\". Metti un limite massimo di 100 pagine o giù di "
"lì in modo che tu\n"
"  non finire per essere bloccato dal sito."

#: src/async.md:1
#, fuzzy
msgid "# Async Rust"
msgstr "# Ruggine asincrona"

#: src/async.md:3
#, fuzzy
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by\n"
"executing each task until it would block, then switching to another task "
"that is\n"
"ready to make progress. The model allows running a larger number of tasks on "
"a\n"
"limited number of threads. This is because the per-task overhead is "
"typically\n"
"very low and operating systems provide primitives for efficiently "
"identifying\n"
"I/O that is able to proceed."
msgstr ""
"\"Async\" è un modello di concorrenza in cui più attività vengono eseguite "
"contemporaneamente da\n"
"eseguire ogni attività fino a quando non si bloccherebbe, quindi passare a "
"un'altra attività che è\n"
"pronto a fare progressi. Il modello consente di eseguire un numero maggiore "
"di attività su a\n"
"numero limitato di thread. Questo perché il sovraccarico per attività è in "
"genere\n"
"molto basso e i sistemi operativi forniscono primitive per l'identificazione "
"efficiente\n"
"I/O che è in grado di procedere."

#: src/async.md:10
#, fuzzy
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that\n"
"may be completed in the future. Futures are \"polled\" until they signal "
"that\n"
"they are complete."
msgstr ""
"L'operazione asincrona di Rust si basa sui \"futuri\", che rappresentano il "
"lavoro che\n"
"potrebbe essere completata in futuro. I futures vengono \"interrogati\" fino "
"a quando non lo segnalano\n"
"sono completi."

#: src/async.md:14
#, fuzzy
msgid ""
"Futures are polled by an async runtime, and several different runtimes are\n"
"available."
msgstr ""
"I futures vengono interrogati da un runtime asincrono e diversi runtime lo "
"sono\n"
"disponibile."

#: src/async.md:17
#, fuzzy
msgid "## Comparisons"
msgstr "Comparazione"

#: src/async.md:19
#, fuzzy
msgid ""
" * Python has a similar model in its `asyncio`. However, its `Future` type "
"is\n"
"   callback-based, and not polled. Async Python programs require a "
"\"loop\",\n"
"   similar to a runtime in Rust.\n"
"\n"
" * JavaScript's `Promise` is similar, but again callback-based. The "
"language\n"
"   runtime implements the event loop, so many of the details of Promise\n"
"   resolution are hidden."
msgstr ""
" * Python ha un modello simile nel suo `asyncio`. Tuttavia, il suo tipo "
"\"Futuro\" è\n"
"   basato su callback e non su polling. I programmi Python asincroni "
"richiedono un \"loop\",\n"
"   simile a un runtime in Rust.\n"
"\n"
" * La \"promessa\" di JavaScript è simile, ma ancora una volta basata su "
"callback. La lingua\n"
"   runtime implementa il ciclo di eventi, tanti dei dettagli di Promise\n"
"   risoluzione sono nascosti."

#: src/async/async-await.md:1
#, fuzzy
msgid "# `async`/`await`"
msgstr "# `asincrono`/`aspetta`"

#: src/async/async-await.md:3
#, fuzzy
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"Ad alto livello, il codice asincrono di Rust assomiglia molto al codice "
"sequenziale \"normale\":"

#: src/async/async-await.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"
msgstr ""

#: src/async/async-await.md:27
msgid ""
"* Note that this is a simplified example to show the syntax. There is no "
"long\n"
"  running operation or any real concurrency in it!\n"
"\n"
"* What is the return type of an async call?\n"
"  * Use `let future: () = async_main(10);` in `main` to see the type.\n"
"\n"
"* The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type\n"
"  with a future. \n"
"\n"
"* You cannot make `main` async, without additional instructions to the "
"compiler\n"
"  on how to use the returned future.\n"
"\n"
"* You need an executor to run async code. `block_on` blocks the current "
"thread\n"
"  until the provided future has run to completion. \n"
"\n"
"* `.await` asynchronously waits for the completion of another operation. "
"Unlike\n"
"  `block_on`, `.await` doesn't block the current thread.\n"
"\n"
"* `.await` can only be used inside an `async` function (or block; these are\n"
"  introduced later). "
msgstr ""

#: src/async/futures.md:1
#, fuzzy
msgid "# Futures"
msgstr "# Futuri"

#: src/async/futures.md:3
#, fuzzy
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)\n"
"is a trait, implemented by objects that represent an operation that may not "
"be\n"
"complete yet. A future can be polled, and `poll` returns a\n"
"[`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Futuro`](https://doc.rust-lang.org/std/future/trait.Future.html)\n"
"è un tratto, implementato da oggetti che rappresentano un'operazione che "
"potrebbe non essere\n"
"ancora completo. È possibile eseguire il polling di un futuro e `poll` "
"restituisce a\n"
"[`Sondaggio`](https://doc.rust-lang.org/std/task/enum.Poll.html)."

#: src/async/futures.md:8
msgid ""
"```rust\n"
"use std::pin::Pin;\n"
"use std::task::Context;\n"
"\n"
"pub trait Future {\n"
"    type Output;\n"
"    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
"Output>;\n"
"}\n"
"\n"
"pub enum Poll<T> {\n"
"    Ready(T),\n"
"    Pending,\n"
"}\n"
"```"
msgstr ""

#: src/async/futures.md:23
#, fuzzy
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to\n"
"implement `Future` for your own types. For example, the `JoinHandle` "
"returned\n"
"from `tokio::spawn` implements `Future` to allow joining to it."
msgstr ""
"Una funzione asincrona restituisce un `impl Future`. È anche possibile (ma "
"non comune).\n"
"implementa `Future` per i tuoi tipi. Ad esempio, è stato restituito "
"\"JoinHandle\".\n"
"da `tokio::spawn` implementa `Future` per consentire l'unione ad esso."

#: src/async/futures.md:27
#, fuzzy
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to\n"
"pause until that Future is ready, and then evaluates to its output."
msgstr ""
"La parola chiave `.await`, applicata a un Future, fa sì che la funzione "
"async corrente si attivi\n"
"mettere in pausa fino a quando Future non è pronto, quindi valuta il suo "
"output."

#: src/async/futures.md:32
msgid ""
"* The `Future` and `Poll` types are implemented exactly as shown; click the\n"
"  links to show the implementations in the docs.\n"
"\n"
"* We will not get to `Pin` and `Context`, as we will focus on writing async\n"
"  code, rather than building new async primitives. Briefly:\n"
"\n"
"  * `Context` allows a Future to schedule itself to be polled again when an\n"
"    event occurs.\n"
"\n"
"  * `Pin` ensures that the Future isn't moved in memory, so that pointers "
"into\n"
"    that future remain valid. This is required to allow references to "
"remain\n"
"    valid after an `.await`."
msgstr ""

#: src/async/runtimes.md:1
#, fuzzy
msgid "# Runtimes"
msgstr "# Runtime"

#: src/async/runtimes.md:3
#, fuzzy
msgid ""
"A *runtime* provides support for performing operations asynchronously (a\n"
"*reactor*) and is responsible for executing futures (an *executor*). Rust "
"does not have a\n"
"\"built-in\" runtime, but several options are available:"
msgstr ""
"Un *runtime* fornisce supporto per l'esecuzione di operazioni in modo "
"asincrono (a\n"
"*reattore*) ed è responsabile dell'esecuzione dei futures (un *esecutore*). "
"La ruggine non ha un\n"
"runtime \"incorporato\", ma sono disponibili diverse opzioni:"

#: src/async/runtimes.md:7
#, fuzzy
msgid ""
" * [Tokio](https://tokio.rs/) - performant, with a well-developed ecosystem "
"of\n"
"   functionality like [Hyper](https://hyper.rs/) for HTTP or\n"
"   [Tonic](https://github.com/hyperium/tonic) for gRPC.\n"
" * [async-std](https://async.rs/) - aims to be a \"std for async\", and "
"includes a\n"
"   basic runtime in `async::task`.\n"
" * [smol](https://docs.rs/smol/latest/smol/) - simple and lightweight"
msgstr ""
" * [Tokio](https://tokio.rs/) - performante, con un ecosistema ben "
"sviluppato di\n"
"   funzionalità come [Hyper](https://hyper.rs/) per HTTP o\n"
"   [Tonic](https://github.com/hyperium/tonic) per gRPC.\n"
" * [async-std](https://async.rs/) - mira a essere uno \"std per async\" e "
"include un\n"
"   runtime di base in `async::task`.\n"
" * [smol](https://docs.rs/smol/latest/smol/) - semplice e leggero"

#: src/async/runtimes.md:14
#, fuzzy
msgid ""
"Several larger applications have their own runtimes. For example,\n"
"[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/"
"fuchsia-async/src/lib.rs)\n"
"already has one."
msgstr ""
"Diverse applicazioni più grandi hanno i propri tempi di esecuzione. Per "
"esempio,\n"
"[Fucsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/"
"fuchsia-async/src/lib.rs)\n"
"ne ha già uno."

#: src/async/runtimes.md:20
#, fuzzy
msgid ""
"* Note that of the listed runtimes, only Tokio is supported in the Rust\n"
"  playground. The playground also does not permit any I/O, so most "
"interesting\n"
"  async things can't run in the playground.\n"
"\n"
"* Futures are \"inert\" in that they do not do anything (not even start an I/"
"O\n"
"  operation) unless there is an executor polling them. This differs from JS\n"
"  Promises, for example, which will run to completion even if they are "
"never\n"
"  used."
msgstr ""
"* Si noti che dei runtime elencati, solo Tokio è supportato in Rust\n"
"  terreno di gioco. Anche il parco giochi non consente alcun I/O, quindi "
"molto interessante\n"
"  le cose asincrone non possono essere eseguite nel parco giochi.\n"
"\n"
"* I futures sono \"inerti\" in quanto non fanno nulla (nemmeno avviano un I/"
"O\n"
"  operazione) a meno che non ci sia un esecutore che li interroga. Questo "
"differisce da JS\n"
"  Promesse, ad esempio, che andranno a buon fine anche se non lo saranno "
"mai\n"
"  usato."

#: src/async/runtimes/tokio.md:1
#, fuzzy
msgid "# Tokio"
msgstr "# Tokyo"

#: src/async/runtimes/tokio.md:4
#, fuzzy
msgid "Tokio provides: "
msgstr "Tokyo fornisce:"

#: src/async/runtimes/tokio.md:6
#, fuzzy
msgid ""
"* A multi-threaded runtime for executing asynchronous code.\n"
"* An asynchronous version of the standard library.\n"
"* A large ecosystem of libraries."
msgstr ""
"* Un runtime multithread per l'esecuzione di codice asincrono.\n"
"* Una versione asincrona della libreria standard.\n"
"* Un grande ecosistema di biblioteche."

#: src/async/runtimes/tokio.md:10
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main task: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/runtimes/tokio.md:33
#, fuzzy
msgid ""
"* With the `tokio::main` macro we can now make `main` async.\n"
"\n"
"* The `spawn` function creates a new, concurrent \"task\".\n"
"\n"
"* Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"* Con la macro `tokio::main` ora possiamo rendere `main` asincrono.\n"
"\n"
"* La funzione `spawn` crea un nuovo \"task\" simultaneo.\n"
"\n"
"* Nota: `spawn` prende un `Future`, non devi chiamare `.await` su `count_to`."

#: src/async/runtimes/tokio.md:39
#, fuzzy
msgid "**Further exploration:**"
msgstr "**Ulteriori esplorazioni:**"

#: src/async/runtimes/tokio.md:41
#, fuzzy
msgid ""
"* Why does `count_to` not (usually) get to 10? This is an example of async\n"
"  cancellation. `tokio::spawn` returns a handle which can be awaited to "
"wait\n"
"  until it finishes.\n"
"\n"
"* Try `count_to(10).await` instead of spawning.\n"
"\n"
"* Try awaiting the task returned from `tokio::spawn`."
msgstr ""
"* Perché `count_to` non arriva (di solito) a 10? Questo è un esempio di "
"async\n"
"  cancellazione. `tokio::spawn` restituisce un handle che può essere atteso "
"per attendere\n"
"  finché non finisce.\n"
"\n"
"* Prova `count_to(10).await` invece di spawnare.\n"
"\n"
"* Prova ad attendere il task restituito da `tokio::spawn`."

#: src/async/tasks.md:1
#, fuzzy
msgid "# Tasks"
msgstr "# Compiti"

#: src/async/tasks.md:3
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr ""

#: src/async/tasks.md:5
#, fuzzy
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress.\n"
"That future may have one or more nested futures that its `poll` method "
"polls,\n"
"corresponding loosely to a call stack. Concurrency within a task is possible "
"by\n"
"polling multiple child futures, such as racing a timer and an I/O operation."
msgstr ""
"Un'attività ha un singolo futuro di primo livello che l'esecutore interroga "
"per fare progressi.\n"
"Quel futuro può avere uno o più futuri nidificati che il suo metodo \"poll\" "
"esegue il polling,\n"
"corrispondente vagamente a uno stack di chiamate. La concorrenza all'interno "
"di un'attività è possibile tramite\n"
"polling di più futuri figli, come correre un timer e un'operazione di I/O."

#: src/async/tasks.md:10
msgid ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"connection from {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await {\n"
"                println!(\"socket error: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
"trim();\n"
"                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"socket error: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"socket error: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/tasks.md:52 src/async/control-flow/join.md:36
#, fuzzy
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"Copia questo esempio nel tuo `src/main.rs` preparato ed eseguilo da lì."

#: src/async/tasks.md:54
#, fuzzy
msgid ""
"* Ask students to visualize what the state of the example server would be "
"with a\n"
"  few connected clients. What tasks exist? What are their Futures?\n"
"\n"
"* This is the first time we've seen an `async` block. This is similar to a\n"
"  closure, but does not take any arguments. Its return value is a Future,\n"
"  similar to an `async fn`. \n"
"\n"
"* Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"* Chiedi agli studenti di visualizzare quale sarebbe lo stato del server di "
"esempio con a\n"
"  pochi client connessi. Quali compiti esistono? Quali sono i loro futuri?\n"
"\n"
"* Questa è la prima volta che vediamo un blocco `async`. Questo è simile a "
"a\n"
"  chiusura, ma non accetta argomenti. Il suo valore di ritorno è un Futuro,\n"
"  simile a un `async fn`.\n"
"\n"
"* Rifattorizzare il blocco asincrono in una funzione e migliorare la "
"gestione degli errori utilizzando `?`."

#: src/async/channels.md:1
#, fuzzy
msgid "# Async Channels"
msgstr "# Canali asincroni"

#: src/async/channels.md:3
#, fuzzy
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"Diversi crate hanno il supporto per `async`/`await`. Ad esempio i canali "
"`tokio`:"

#: src/async/channels.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    std::mem::drop(sender);\n"
"    ping_handler_task.await.expect(\"Something went wrong in ping handler "
"task.\");\n"
"}\n"
"```"
msgstr ""

#: src/async/channels.md:35
#, fuzzy
msgid ""
"* Change the channel size to `3` and see how it affects the execution.\n"
"\n"
"* Overall, the interface is similar to the `sync` channels as seen in the\n"
"  [morning class](concurrency/channels.md).\n"
"\n"
"* Try removing the `std::mem::drop` call. What happens? Why?\n"
"\n"
"* The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that\n"
"  implement both `sync` and `async` `send` and `recv`. This can be "
"convenient\n"
"  for complex applications with both IO and heavy CPU processing tasks.\n"
"\n"
"* What makes working with `async` channels preferable is the ability to "
"combine\n"
"  them with other `future`s to combine them and create complex control flow."
msgstr ""
"* Cambia la dimensione del canale in \"3\" e guarda come influisce "
"sull'esecuzione.\n"
"\n"
"* Nel complesso, l'interfaccia è simile ai canali `sync` come si vede nel "
"file\n"
"  [lezione mattutina](concurrency/channels.md).\n"
"\n"
"* Prova a rimuovere la chiamata `std::mem::drop`. Che succede? Perché?\n"
"\n"
"* La cassa [Flume](https://docs.rs/flume/latest/flume/) ha canali che\n"
"  implementa sia `sync` che `async` `send` e `recv`. Questo può essere "
"conveniente\n"
"  per applicazioni complesse con attività di elaborazione di CPU e IO "
"pesanti.\n"
"\n"
"* Ciò che rende preferibile lavorare con i canali `async` è la capacità di "
"combinare\n"
"  loro con altri `futuri` per combinarli e creare un flusso di controllo "
"complesso."

#: src/async/control-flow.md:1
#, fuzzy
msgid "# Futures Control Flow"
msgstr "# Flusso di controllo dei futures"

#: src/async/control-flow.md:3
#, fuzzy
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We\n"
"have already seen tasks, that function as independent threads of execution."
msgstr ""
"I futures possono essere combinati insieme per produrre grafici di flusso di "
"calcolo simultanei. Noi\n"
"ho già visto le attività, che funzionano come thread di esecuzione "
"indipendenti."

#: src/async/control-flow.md:6
#, fuzzy
msgid ""
"- [Join](control-flow/join.md)\n"
"- [Select](control-flow/select.md)"
msgstr ""
"- [Partecipa](control-flow/join.md)\n"
"- [Seleziona](control-flow/select.md)"

#: src/async/control-flow/join.md:1
#, fuzzy
msgid "# Join"
msgstr "# Giuntura"

#: src/async/control-flow/join.md:3
#, fuzzy
msgid ""
"A join operation waits until all of a set of futures are ready, and\n"
"returns a collection of their results. This is similar to `Promise.all` in\n"
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"Un'operazione di join attende fino a quando tutti i futures sono pronti e\n"
"restituisce una raccolta dei loro risultati. Questo è simile a \"Promise."
"all\" in\n"
"JavaScript o `asyncio.gather` in Python."

#: src/async/control-flow/join.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &str) -> Result<usize> {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/join.md:38
#, fuzzy
msgid ""
"* For multiple futures of disjoint types, you can use `std::future::join!` "
"but\n"
"  you must know how many futures you will have at compile time. This is\n"
"  currently in the `futures` crate, soon to be stabilised in `std::future`.\n"
"\n"
"* The risk of `join` is that one of the futures may never resolve, this "
"would\n"
"  cause your program to stall. \n"
"\n"
"* You can also combine `join_all` with `join!` for instance to join all "
"requests\n"
"  to an http service as well as a database query. Try adding a\n"
"  `tokio::time::sleep` to the future, using `futures::join!`. This is not a\n"
"  timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"* Per future multiple di tipi disgiunti, puoi usare `std::future::join!` ma\n"
"  devi sapere quanti futuri avrai al momento della compilazione. Questo è\n"
"  attualmente nella cassa `futures`, presto sarà stabilizzata in `std::"
"future`.\n"
"\n"
"* Il rischio di \"unirsi\" è che uno dei futuri potrebbe non risolversi mai, "
"questo sì\n"
"  causare l'arresto del programma.\n"
"\n"
"* Puoi anche combinare `join_all` con `join!`, ad esempio per unire tutte le "
"richieste\n"
"  a un servizio http così come una query di database. Prova ad aggiungere "
"un\n"
"  `tokio::time::sleep` nel futuro, usando `futures::join!`. Questo non è un\n"
"  timeout (che richiede `select!`, spiegato nel prossimo capitolo), ma "
"dimostra `join!`."

#: src/async/control-flow/select.md:1
#, fuzzy
msgid "# Select"
msgstr "# Selezionare"

#: src/async/control-flow/select.md:3
#, fuzzy
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to\n"
"that future's result. In JavaScript, this is similar to `Promise.race`. In\n"
"Python, it compares to `asyncio.wait(task_set,\n"
"return_when=asyncio.FIRST_COMPLETED)`."
msgstr ""
"Un'operazione di selezione attende fino a quando uno qualsiasi di un insieme "
"di futures è pronto e risponde a\n"
"il risultato di quel futuro. In JavaScript, è simile a `Promise.race`. In\n"
"Python, confronta con `asyncio.wait(task_set,\n"
"return_when=asyncio.FIRST_COMPLETED)`."

#: src/async/control-flow/select.md:8
#, fuzzy
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each\n"
"of the form `pattern = future => statement`. When the `future` is ready, "
"the\n"
"`statement` is executed with the variables in `pattern` bound to the "
"`future`'s\n"
"result."
msgstr ""
"Di solito è una macro, simile a match, con ogni braccio della forma `pattern "
"=\n"
"futuro => istruzione`. Quando il futuro è pronto, l'istruzione viene "
"eseguita con il\n"
"variabile legata al risultato del futuro."

#: src/async/control-flow/select.md:13
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receiver<String>,\n"
"    mut dog_rcv: Receiver<String>,\n"
") -> Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: cat_name? }),\n"
"        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Failed to send cat.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Failed to send dog.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"Winner is {winner:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/select.md:62
#, fuzzy
msgid ""
"* In this example, we have a race between a cat and a dog.\n"
"  `first_animal_to_finish_race` listens to both channels and will pick "
"whichever\n"
"  arrives first. Since the dog takes 50ms, it wins against the cat that\n"
"  take 500ms seconds.\n"
"\n"
"* You can use `oneshot` channels in this example as the channels are "
"supposed to\n"
"  receive only one `send`.\n"
"\n"
"* Try adding a deadline to the race, demonstrating selecting different sorts "
"of\n"
"  futures.\n"
"\n"
"* Note that `select!` drops unmatched branches, which cancels their "
"futures.\n"
"  It is easiest to use when every execution of `select!` creates new "
"futures.\n"
"\n"
"    * An alternative is to pass `&mut future` instead of the future itself, "
"but\n"
"      this can lead to issues, further discussed in the pinning slide."
msgstr ""
"* In questo esempio, abbiamo una gara tra un gatto e un cane.\n"
"  `first_animal_to_finish_race` ascolta entrambi i canali e sceglierà quello "
"che preferisci\n"
"  arriva prima. Poiché il cane impiega 50 ms, vince contro il gatto\n"
"  prendere 500 ms secondi.\n"
"\n"
"* In questo esempio puoi usare i canali `oneshot` come dovrebbero\n"
"  ricevere un solo \"invio\".\n"
"\n"
"* Prova ad aggiungere una scadenza alla gara, dimostrando la selezione di "
"diversi tipi di\n"
"  futuri.\n"
"\n"
"* Nota che `select!` sposta i valori che gli vengono dati. È più facile da "
"usare\n"
"  quando ogni esecuzione di `select!` crea nuovi futuri. Un'alternativa è\n"
"  passa `&mut future` invece del futuro stesso, ma questo può portare a\n"
"  problemi, ulteriormente discussi nella diapositiva di blocco."

#: src/async/pitfalls.md:1
#, fuzzy
msgid "# Pitfalls of async/await"
msgstr "# Insidie di async/await"

#: src/async/pitfalls.md:3
#, fuzzy
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"Async / await fornisce un'astrazione comoda ed efficiente per la "
"programmazione asincrona simultanea. Tuttavia, anche il modello async/await "
"in Rust ha la sua parte di insidie e pistole. Ne illustriamo alcuni in "
"questo capitolo:"

#: src/async/pitfalls.md:5
#, fuzzy
msgid ""
"- [Blocking the Executor](pitfalls/blocking-executor.md)\n"
"- [Pin](pitfalls/pin.md)\n"
"- [Async Traits](pitfalls/async-traits.md)\n"
"- [Cancellation](pitfalls/cancellation.md)"
msgstr ""
"- [Blocco dell'esecutore](trappole/blocking-executor.md)\n"
"- [Pin](trappole/pin.md)\n"
"- [Tratti asincroni](trapano/async-traits.md)"

#: src/async/pitfalls/blocking-executor.md:1
#, fuzzy
msgid "# Blocking the executor"
msgstr "# Blocco dell'esecutore"

#: src/async/pitfalls/blocking-executor.md:3
#, fuzzy
msgid ""
"Most async runtimes only allow IO tasks to run concurrently.\n"
"This means that CPU blocking tasks will block the executor and prevent other "
"tasks from being executed.\n"
"An easy workaround is to use async equivalent methods where possible."
msgstr ""
"La maggior parte dei runtime asincroni consente solo l'esecuzione simultanea "
"delle attività di I/O.\n"
"Ciò significa che le attività di blocco della CPU bloccheranno l'esecutore e "
"impediranno l'esecuzione di altre attività.\n"
"Una soluzione semplice consiste nell'usare metodi equivalenti asincroni ove "
"possibile."

#: src/async/pitfalls/blocking-executor.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
#, fuzzy
msgid ""
"* Run the code and see that the sleeps happen consecutively rather than\n"
"  concurrently.\n"
"\n"
"* The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the\n"
"  effect more obvious, but the bug is still present in the multi-threaded\n"
"  flavor.\n"
"\n"
"* Switch the `std::thread::sleep` to `tokio::time::sleep` and await its "
"result.\n"
"\n"
"* Another fix would be to `tokio::task::spawn_blocking` which spawns an "
"actual\n"
"  thread and transforms its handle into a future without blocking the "
"executor.\n"
"\n"
"* You should not think of tasks as OS threads. They do not map 1 to 1 and "
"most\n"
"  executors will allow many tasks to run on a single OS thread. This is\n"
"  particularly problematic when interacting with other libraries via FFI, "
"where\n"
"  that library might depend on thread-local storage or map to specific OS\n"
"  threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations.\n"
"\n"
"* Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another\n"
"  task to block, and that task may be running on the same thread."
msgstr ""
"* Esegui il codice e verifica che le interruzioni avvengano consecutivamente "
"anziché\n"
"  in concomitanza.\n"
"\n"
"* Il profilo `\"current_thread\"` pone tutte le attività su un singolo "
"thread. Questo rende il\n"
"  effetto più evidente, ma il bug è ancora presente nel multithread\n"
"  gusto.\n"
"\n"
"* Passa da `std::thread::sleep` a `tokio::time::sleep` e attendi il "
"risultato.\n"
"\n"
"* Un'altra soluzione potrebbe essere `tokio::task::spawn_blocking` che "
"genera un file effettivo\n"
"  thread e trasforma il suo handle in un futuro senza bloccare l'esecutore.\n"
"\n"
"* Non dovresti pensare alle attività come thread del sistema operativo. Non "
"mappano 1 a 1 e la maggior parte\n"
"  gli esecutori consentiranno l'esecuzione di molte attività su un singolo "
"thread del sistema operativo. Questo è\n"
"  particolarmente problematico quando si interagisce con altre biblioteche "
"tramite FFI, dove\n"
"  quella libreria potrebbe dipendere dall'archiviazione locale del thread o "
"essere mappata su un sistema operativo specifico\n"
"  thread (ad esempio, CUDA). Preferisci `tokio::task::spawn_blocking` in "
"tali situazioni.\n"
"\n"
"* Usa i mutex di sincronizzazione con attenzione. Mantenere un mutex sopra "
"un `.await` può causarne un altro\n"
"  attività da bloccare e tale attività potrebbe essere in esecuzione sullo "
"stesso thread."

#: src/async/pitfalls/pin.md:1
#, fuzzy
msgid "# Pin"
msgstr "# Spillo"

#: src/async/pitfalls/pin.md:3
#, fuzzy
msgid ""
"When you await a future, all local variables (that would ordinarily be "
"stored on\n"
"a stack frame) are instead stored in the Future for the current async block. "
"If your\n"
"future has pointers to data on the stack, those pointers might get "
"invalidated.\n"
"This is unsafe."
msgstr ""
"Quando aspetti un futuro, tutte le variabili locali (che normalmente "
"sarebbero memorizzate su\n"
"uno stack frame) vengono invece archiviati in Future per il blocco asincrono "
"corrente. Se tuo\n"
"future ha puntatori ai dati nello stack, quei puntatori potrebbero essere "
"invalidati.\n"
"Questo non è sicuro."

#: src/async/pitfalls/pin.md:8
#, fuzzy
msgid ""
"Therefore, you must guarantee that the addresses your future points to "
"don't\n"
"change. That is why we need to `pin` futures. Using the same future "
"repeatedly\n"
"in a `select!` often leads to issues with pinned values."
msgstr ""
"Pertanto, è necessario garantire che gli indirizzi futuri puntino a non "
"farlo\n"
"modifica. Ecco perché dobbiamo \"bloccare\" i futuri. Usando ripetutamente "
"lo stesso futuro\n"
"in un `select!` spesso porta a problemi con i valori bloccati."

#: src/async/pitfalls/pin.md:12
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// A worker which listens for work on a queue and performs it.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() => {\n"
"                sleep(Duration::from_millis(10)).await; // Pretend to work.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"failed to send response\");\n"
"                iterations += 1;\n"
"            }\n"
"            // TODO: report number of iterations every 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// A requester which requests work and waits for it to complete.\n"
"async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"failed to send on work queue\");\n"
"    rx.await.expect(\"failed waiting for response\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:68
msgid ""
"* You may recognize this as an example of the actor pattern. Actors\n"
"  typically call `select!` in a loop.\n"
"\n"
"* This serves as a summation of a few of the previous lessons, so take your "
"time\n"
"  with it.\n"
"\n"
"    * Naively add a `_ = sleep(Duration::from_millis(100)) => { println!"
"(..) }`\n"
"      to the `select!`. This will never execute. Why?\n"
"\n"
"    * Instead, add a `timeout_fut` containing that future outside of the "
"`loop`:\n"
"\n"
"        ```rust,compile_fail\n"
"        let mut timeout_fut = sleep(Duration::from_millis(100));\n"
"        loop {\n"
"            select! {\n"
"                ..,\n"
"                _ = timeout_fut => { println!(..); },\n"
"            }\n"
"        }\n"
"        ```\n"
"    * This still doesn't work. Follow the compiler errors, adding `&mut` to "
"the\n"
"      `timeout_fut` in the `select!` to work around the move, then using\n"
"      `Box::pin`:\n"
"\n"
"        ```rust,compile_fail\n"
"        let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
"        loop {\n"
"            select! {\n"
"                ..,\n"
"                _ = &mut timeout_fut => { println!(..); },\n"
"            }\n"
"        }\n"
"        ```\n"
"\n"
"    * This compiles, but once the timeout expires it is `Poll::Ready` on "
"every\n"
"      iteration (a fused future would help with this). Update to reset\n"
"      `timeout_fut` every time it expires.\n"
"\n"
"* Box allocates on the heap. In some cases, `std::pin::pin!` (only recently\n"
"  stabilized, with older code often using `tokio::pin!`) is also an option, "
"but\n"
"  that is difficult to use for a future that is reassigned.\n"
"\n"
"* Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""

#: src/async/pitfalls/async-traits.md:1
#, fuzzy
msgid "# Async Traits"
msgstr "# Tratti asincroni"

#: src/async/pitfalls/async-traits.md:3
#, fuzzy
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"I metodi asincroni nei tratti non sono ancora supportati nel canale stabile "
"([Esiste una funzionalità sperimentale in nightly e dovrebbe essere "
"stabilizzata a medio termine.](https://blog.rust-lang.org/inside-"
"rust/2022/11 /17/async-fn-in-trait-nightly.html))"

#: src/async/pitfalls/async-traits.md:5
#, fuzzy
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"Il crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"fornisce una soluzione tramite una macro:"

#: src/async/pitfalls/async-traits.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper for FixedSleeper {\n"
"    async fn sleep(&self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
"n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"running all sleepers..\");\n"
"        for sleeper in &sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/async-traits.md:49
#, fuzzy
msgid "<details>  "
msgstr "<dettagli>"

#: src/async/pitfalls/async-traits.md:51
#, fuzzy
msgid ""
"* `async_trait` is easy to use, but note that it's using heap allocations "
"to\n"
"  achieve this. This heap allocation has performance overhead.\n"
"\n"
"* The challenges in language support for `async trait` are deep Rust and\n"
"  probably not worth describing in-depth. Niko Matsakis did a good job of\n"
"  explaining them in [this\n"
"  post](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-"
"traits-are-hard/)\n"
"  if you are interested in digging deeper.\n"
"\n"
"* Try creating a new sleeper struct that will sleep for a random amount of "
"time\n"
"  and adding it to the Vec."
msgstr ""
"* `async_trait` è facile da usare, ma si noti che utilizza allocazioni di "
"heap per\n"
"  raggiungere questo obiettivo. Questa allocazione dell'heap comporta un "
"sovraccarico delle prestazioni.\n"
"\n"
"* Le sfide nel supporto del linguaggio per `async trait` sono il profondo "
"Rust e\n"
"  probabilmente non vale la pena descriverlo in modo approfondito. Niko "
"Matsakis ha fatto un buon lavoro\n"
"  spiegandoli in [questo\n"
"  post](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-"
"traits-are-hard/)\n"
"  se sei interessato a scavare più a fondo.\n"
"\n"
"* Prova a creare una nuova struttura dormiente che dormirà per un periodo di "
"tempo casuale\n"
"  e aggiungendolo al Vec."

#: src/async/pitfalls/cancellation.md:1
#, fuzzy
msgid "# Cancellation"
msgstr "# Traduzioni"

#: src/async/pitfalls/cancellation.md:3
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"*cancellation*\n"
"and it can occur at any `await` point. Care is needed to ensure the system "
"works\n"
"correctly even when futures are cancelled. For example, it shouldn't "
"deadlock or\n"
"lose data."
msgstr ""

#: src/async/pitfalls/cancellation.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use std::io::{self, ErrorKind};\n"
"use std::time::Duration;\n"
"use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};\n"
"\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream }\n"
"    }\n"
"\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        let mut bytes = Vec::new();\n"
"        let mut buf = [0];\n"
"        while self.stream.read(&mut buf[..]).await? != 0 {\n"
"            bytes.push(buf[0]);\n"
"            if buf[0] == b'\\n' {\n"
"                break;\n"
"            }\n"
"        }\n"
"        if bytes.is_empty() {\n"
"            return Ok(None)\n"
"        }\n"
"        let s = String::from_utf8(bytes)\n"
"            .map_err(|_| io::Error::new(ErrorKind::InvalidData, \"not "
"UTF-8\"))?;\n"
"        Ok(Some(s))\n"
"    }\n"
"}\n"
"\n"
"async fn slow_copy(source: String, mut dest: DuplexStream) -> std::io::"
"Result<()> {\n"
"    for b in source.bytes() {\n"
"        dest.write_u8(b).await?;\n"
"        tokio::time::sleep(Duration::from_millis(10)).await\n"
"    }\n"
"    Ok(())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> std::io::Result<()> {\n"
"    let (client, server) = tokio::io::duplex(5);\n"
"    let handle = tokio::spawn(slow_copy(\"hi\\nthere\\n\".to_owned(), "
"client));\n"
"\n"
"    let mut lines = LinesReader::new(server);\n"
"    let mut interval = tokio::time::interval(Duration::from_millis(60));\n"
"    loop {\n"
"        tokio::select! {\n"
"            _ = interval.tick() => println!(\"tick!\"),\n"
"            line = lines.next() => if let Some(l) = line? {\n"
"                print!(\"{}\", l)\n"
"            } else {\n"
"                break\n"
"            },\n"
"        }\n"
"    }\n"
"    handle.await.unwrap()?;\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/cancellation.md:72
msgid ""
"* The compiler doesn't help with cancellation-safety. You need to read API\n"
"  documentation and consider what state your `async fn` holds.\n"
"\n"
"* Unlike `panic` and `?`, cancellation is part of normal control flow\n"
"  (vs error-handling).\n"
"\n"
"* The example loses parts of the string.\n"
"\n"
"    * Whenever the `tick()` branch finishes first, `next()` and its `buf` "
"are dropped.\n"
"\n"
"    * `LinesReader` can be made cancellation-safe by makeing `buf` part of "
"the struct:\n"
"        ```rust,compile_fail\n"
"        struct LinesReader {\n"
"            stream: DuplexStream,\n"
"            bytes: Vec<u8>,\n"
"            buf: [u8; 1],\n"
"        }\n"
"\n"
"        impl LinesReader {\n"
"            fn new(stream: DuplexStream) -> Self {\n"
"                Self { stream, bytes: Vec::new(), buf: [0] }\n"
"            }\n"
"            async fn next(&mut self) -> io::Result<Option<String>> {\n"
"                // prefix buf and bytes with self.\n"
"                // ...\n"
"                let raw = std::mem::take(&mut self.bytes);\n"
"                let s = String::from_utf8(raw)\n"
"                // ...\n"
"            }\n"
"        }\n"
"        ```\n"
"\n"
"* [`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick)\n"
"  is cancellation-safe because it keeps track of whether a tick has been "
"'delivered'.\n"
"\n"
"* [`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read)\n"
"  is cancellation-safe because it either returns or doesn't read data.\n"
"\n"
"* [`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line)\n"
"  is similar to the example and *isn't* cancellation-safe. See its "
"documentation\n"
"  for details and alternatives."
msgstr ""

#: src/exercises/concurrency/afternoon.md:3
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"* Dining philosophers: we already saw this problem in the morning. This "
"time\n"
"  you are going to implement it with Async Rust.\n"
"\n"
"* A Broadcast Chat Application: this is a larger project that allows you\n"
"  experiment with more advanced Async Rust features."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:1
#, fuzzy
msgid "# Dining Philosophers - Async"
msgstr "# Filosofi da pranzo"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the\n"
"problem."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local\n"
"[Cargo installation](../../cargo/running-locally.md) for this exercise. "
"Copy\n"
"the code below to a file called `src/main.rs`, fill out the blanks, and "
"test\n"
"that `cargo run` does not deadlock:"
msgstr ""
"Avrai bisogno di un'[installazione Cargo](../../cargo/running-locally.md) "
"locale per\n"
"questo esercizio. Copia il codice qui sotto in un file chiamato `src/main."
"rs`, compila il file\n"
"spazi vuoti e verificare che `cargo run` non vada in stallo:"

#: src/exercises/concurrency/dining-philosophers-async.md:13
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:57
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency.\n"
"You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:62
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:72
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module\n"
"from the `tokio` crate."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:77
msgid "* Can you make your implementation single-threaded? "
msgstr ""

#: src/exercises/concurrency/chat-app.md:1
msgid "# Broadcast Chat Application"
msgstr ""

#: src/exercises/concurrency/chat-app.md:3
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast\n"
"chat application. We have a chat server that the clients connect to and "
"publish\n"
"their messages. The client reads user messages from the standard input, and\n"
"sends them to the server. The chat server broadcasts each message that it\n"
"receives to all the clients."
msgstr ""

#: src/exercises/concurrency/chat-app.md:9
msgid ""
"For this, we use [a broadcast channel][1] on the server, and\n"
"[`tokio_websockets`][2] for the communication between the client and the\n"
"server."
msgstr ""

#: src/exercises/concurrency/chat-app.md:13
msgid "Create a new Cargo project and add the following dependencies:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:15
msgid "`Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = \"0.3.28\"\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = \"0.3.2\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:32
msgid "## The required APIs"
msgstr ""

#: src/exercises/concurrency/chat-app.md:33
msgid ""
"You are going to need the following functions from `tokio` and\n"
"[`tokio_websockets`][2]. Spend a few minutes to familiarize yourself with "
"the\n"
"API. "
msgstr ""

#: src/exercises/concurrency/chat-app.md:37
msgid ""
"- [WebsocketStream::next()][3]: for asynchronously reading messages from a\n"
"  Websocket Stream.\n"
"- [SinkExt::send()][4] implemented by `WebsocketStream`: for asynchronously\n"
"  sending messages on a Websocket Stream.\n"
"- [Lines::next_line()][5]: for asynchronously reading user messages\n"
"  from the standard input.\n"
"- [Sender::subscribe()][6]: for subscribing to a broadcast channel."
msgstr ""

#: src/exercises/concurrency/chat-app.md:46
#, fuzzy
msgid "## Two binaries"
msgstr "# Binari Rust"

#: src/exercises/concurrency/chat-app.md:48
msgid ""
"Normally in a Cargo project, you can have only one binary, and one\n"
"`src/main.rs` file. In this project, we need two binaries. One for the "
"client,\n"
"and one for the server. You could potentially make them two separate Cargo\n"
"projects, but we are going to put them in a single Cargo project with two\n"
"binaries. For this to work, the client and the server code should go under\n"
"`src/bin` (see the [documentation][7]). "
msgstr ""

#: src/exercises/concurrency/chat-app.md:55
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and\n"
"`src/bin/client.rs`, respectively. Your task is to complete these files as\n"
"described below. "
msgstr ""

#: src/exercises/concurrency/chat-app.md:59
#: src/exercises/concurrency/solutions-afternoon.md:117
#, fuzzy
msgid "`src/bin/server.rs`:"
msgstr "`src/driver.rs`:"

#: src/exercises/concurrency/chat-app.md:61
#, fuzzy
msgid "<!-- File src/bin/server.rs -->"
msgstr "<!-- File src/driver.rs -->"

#: src/exercises/concurrency/chat-app.md:63
msgid ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:102
#: src/exercises/concurrency/solutions-afternoon.md:202
#, fuzzy
msgid "`src/bin/client.rs`:"
msgstr "`src/edificio.rs`:"

#: src/exercises/concurrency/chat-app.md:104
#, fuzzy
msgid "<!-- File src/bin/client.rs -->"
msgstr "<!-- File src/building.rs -->"

#: src/exercises/concurrency/chat-app.md:106
msgid ""
"```rust,compile_fail\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let mut ws_stream = ClientBuilder::from_uri(Uri::"
"from_static(\"ws://127.0.0.1:2000\"))\n"
"        .connect()\n"
"        .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:127
#, fuzzy
msgid "## Running the binaries"
msgstr "# Esecuzione del corso"

#: src/exercises/concurrency/chat-app.md:128
#, fuzzy
msgid "Run the server with:"
msgstr "Esegui l'esempio con:"

#: src/exercises/concurrency/chat-app.md:130
msgid ""
"```shell\n"
"cargo run --bin server\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:134
#, fuzzy
msgid "and the client with:"
msgstr "Esegui l'esempio con:"

#: src/exercises/concurrency/chat-app.md:136
msgid ""
"```shell\n"
"cargo run --bin client\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:142
msgid ""
"* Implement the `handle_connection` function in `src/bin/server.rs`.\n"
"  * Hint: Use `tokio::select!` for concurrently performing two tasks in a\n"
"    continuous loop. One task receives messages from the client and "
"broadcasts\n"
"    them. The other sends messages received by the server to the client.\n"
"* Complete the main function in `src/bin/client.rs`.\n"
"  * Hint: As before, use `tokio::select!` in a continuous loop for "
"concurrently\n"
"    performing two tasks: (1) reading user messages from standard input and\n"
"    sending them to the server, and (2) receiving messages from the server, "
"and\n"
"    displaying them for the user.\n"
"* Optional: Once you are done, change the code to broadcast messages to all\n"
"  clients, but the sender of the message."
msgstr ""

#: src/thanks.md:1
#, fuzzy
msgid "# Thanks!"
msgstr "# Grazie!"

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and "
"that it\n"
"was useful."
msgstr ""
"_Grazie per aver preso Comprehensive Rust 🦀!_ Ci auguriamo che ti sia "
"piaciuto e che sia così\n"
"è stato utile."

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get "
"in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would "
"love\n"
"to hear from you."
msgstr ""
"Ci siamo divertiti molto a mettere insieme il corso. Il corso non è "
"perfetto,\n"
"quindi se hai individuato errori o hai idee per miglioramenti, entra\n"
"[contattaci su\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Ci "
"piacerebbe\n"
"avere tue notizie."

#: src/other-resources.md:1
#, fuzzy
msgid "# Other Rust Resources"
msgstr "# Altre risorse di ruggine"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr ""
"La community di Rust ha creato una vasta gamma di risorse gratuite e di alta "
"qualità\n"
"in linea."

#: src/other-resources.md:6
#, fuzzy
msgid "## Official Documentation"
msgstr "## Documentazione ufficiale"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"Il progetto Rust ospita molte risorse. Questi coprono Rust in generale:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes "
"a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust\n"
"  syntax via a series of examples which showcase different constructs. "
"Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full "
"documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [Il linguaggio di programmazione Rust](https://doc.rust-lang.org/book/): "
"the\n"
"  canonico libro gratuito su Rust. Copre la lingua in dettaglio e include a\n"
"  pochi progetti da costruire per le persone.\n"
"* [Ruggine per esempio](https://doc.rust-lang.org/rust-by-example/): copre "
"la Ruggine\n"
"  sintassi attraverso una serie di esempi che mostrano diversi costrutti. A "
"volte\n"
"  include piccoli esercizi in cui ti viene chiesto di espandere il codice "
"nel file\n"
"  esempi.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): documentazione "
"completa di\n"
"  la libreria standard per Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): un libro "
"incompleto\n"
"  che descrive la grammatica e il modello di memoria di Rust."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Guide più specializzate ospitate sul sito ufficiale di Rust:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe "
"Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-"
"book/):\n"
"  covers the new asynchronous programming model which was introduced after "
"the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): copre Rust non "
"sicuro,\n"
"  compreso il lavoro con puntatori grezzi e l'interfacciamento con altre "
"lingue\n"
"  (FFI).\n"
"* [Programmazione asincrona in Rust](https://rust-lang.github.io/async-"
"book/):\n"
"  copre il nuovo modello di programmazione asincrona che è stato introdotto "
"dopo il\n"
"  Rust Book è stato scritto.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an\n"
"  introduzione all'utilizzo di Rust su dispositivi embedded senza sistema "
"operativo."

#: src/other-resources.md:33
#, fuzzy
msgid "## Unofficial Learning Material"
msgstr "## Materiale didattico non ufficiale"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Una piccola selezione di altre guide e tutorial per Rust:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers "
"Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust "
"from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other "
"languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to "
"help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): "
"a\n"
"  series of small presentations covering both basic and advanced part of "
"the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) "
"and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): "
"two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and "
"the\n"
"  second is a set of 11 modules which covers Rust syntax and basic "
"constructs.\n"
"* [Learn Rust With Entirely Too Many Linked\n"
"  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth\n"
"  exploration of Rust's memory management rules, through implementing a few\n"
"  different types of list structures."
msgstr ""
"* [Impara la ruggine in modo pericoloso](http://cliffle.com/p/dangerust/): "
"copre Rust\n"
"  dal punto di vista dei programmatori C di basso livello.\n"
"* [Ruggine per Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): copre Rust "
"da\n"
"  la prospettiva degli sviluppatori che scrivono firmware in C.\n"
"* [Ruggine per professionisti](https://overexact.com/rust-for-"
"professionals/):\n"
"  copre la sintassi di Rust usando confronti fianco a fianco con altri "
"linguaggi\n"
"  come C, C++, Java, JavaScript e Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): oltre 100 esercizi "
"per aiutarti\n"
"  impari Ruggine.\n"
"* [Insegnamento ferroso\n"
"  Materiale](https://ferrous-systems.github.io/teaching-material/index."
"html): a\n"
"  serie di piccole presentazioni che coprono sia la parte di base che quella "
"avanzata del\n"
"  Linguaggio ruggine. Sono disponibili anche altri argomenti come "
"WebAssembly e async/await\n"
"  coperto.\n"
"* [Serie per principianti a\n"
"  Ruggine](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) "
"e\n"
"  [Fai i tuoi primi passi con\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): "
"due\n"
"  Guide Rust rivolte ai nuovi sviluppatori. Il primo è un set di 35 video e "
"il\n"
"  il secondo è un set di 11 moduli che copre la sintassi di Rust ei "
"costrutti di base.\n"
"* [Impara la ruggine con troppi collegamenti\n"
"  Liste](https://rust-unofficial.github.io/too-many-lists/): "
"approfondimento\n"
"  esplorazione delle regole di gestione della memoria di Rust, "
"implementandone alcune\n"
"  diversi tipi di strutture di elenchi."

#: src/other-resources.md:63
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for\n"
"even more Rust books."
msgstr ""
"Si prega di consultare il [Little Book of Rust Books](https://lborb.github."
"io/book/) per\n"
"ancora più libri di Rust."

#: src/credits.md:1
#, fuzzy
msgid "# Credits"
msgstr "# Crediti"

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of "
"useful\n"
"resources."
msgstr ""
"Il materiale qui si basa sulle molte grandi fonti di documentazione di "
"Rust.\n"
"Vedere la pagina su [altre risorse](other-resources.md) per un elenco "
"completo di utili\n"
"risorse."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0\n"
"license, please see\n"
"[`LICENSE`](https://github.com/google/comprehensive-rust/blob/main/LICENSE) "
"for\n"
"details."
msgstr ""
"Il materiale di Comprehensive Rust è concesso in licenza secondo i termini "
"di Apache 2.0\n"
"licenza, vedere [`LICENSE`](../LICENSE) per i dettagli."

#: src/credits.md:12
#, fuzzy
msgid "## Rust by Example"
msgstr "## Ruggine con l'esempio"

#: src/credits.md:14
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"Alcuni esempi ed esercizi sono stati copiati e adattati da [Rust by\n"
"Esempio](https://doc.rust-lang.org/rust-by-example/). Si prega di consultare "
"il\n"
"directory `Third_party/rust-by-example/` per i dettagli, inclusa la licenza\n"
"termini."

#: src/credits.md:19
#, fuzzy
msgid "## Rust on Exercism"
msgstr "## Ruggine sull'esercizio"

#: src/credits.md:21
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the "
"license\n"
"terms."
msgstr ""
"Alcuni esercizi sono stati copiati e adattati da [Rust on\n"
"Esercizio fisico](https://exercism.org/tracks/rust). Si prega di consultare "
"il\n"
"directory `Third_party/rust-on-exercism/` per i dettagli, inclusa la "
"licenza\n"
"termini."

#: src/credits.md:26
#, fuzzy
msgid "## CXX"
msgstr "##CXX"

#: src/credits.md:28
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory\n"
"for details, including the license terms."
msgstr ""
"La sezione [Interoperabilità con C++](android/interoperabilità/cpp.md) "
"utilizza un file\n"
"immagine da [CXX](https://cxx.rs/). Si prega di consultare la directory "
"`Third_party/cxx/`\n"
"per i dettagli, inclusi i termini di licenza."

#: src/exercises/solutions.md:1
#, fuzzy
msgid "# Solutions"
msgstr "# Soluzioni"

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Troverai le soluzioni degli esercizi nelle pagine seguenti."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us "
"know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"Sentiti libero di fare domande sulle soluzioni [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Facci "
"sapere\n"
"se hai una soluzione diversa o migliore di quella presentata qui."

#: src/exercises/solutions.md:10
#, fuzzy
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **Nota:** Si prega di ignorare `// ANCHOR: etichetta` e `// ANCHOR_END: "
"etichetta`\n"
"> commenti che vedi nelle soluzioni. Sono lì per renderlo possibile\n"
"> riutilizzare parti delle soluzioni come esercizi."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "# Day 1 Morning Exercises"
msgstr "# Giorno 1 Esercizi mattutini"

#: src/exercises/day-1/solutions-morning.md:3
#, fuzzy
msgid "## Arrays and `for` Loops"
msgstr "## Array e cicli `for`"

#: src/exercises/day-1/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](for-loops.md))"
msgstr "([torna all'esercizio](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:78
#, fuzzy
msgid "### Bonus question"
msgstr "### Domanda bonus"

#: src/exercises/day-1/solutions-morning.md:80
#, fuzzy
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-"
"of-slices (`&[&[i32]]`) as the input type to transpose and thus make our "
"function handle any size of matrix. However, this quickly breaks down: the "
"return type cannot be `&[&[i32]]` since it needs to own the data you return."
msgstr ""
"Richiede concetti più avanzati. Potrebbe sembrare che potremmo usare uno "
"slice-of-slice (`&[&[i32]]`) come tipo di input da trasporre e quindi fare "
"in modo che la nostra funzione gestisca qualsiasi dimensione di matrice. "
"Tuttavia, questo si interrompe rapidamente: il tipo restituito non può "
"essere `&[&[i32]]` poiché deve essere proprietario dei dati restituiti."

#: src/exercises/day-1/solutions-morning.md:82
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
"`&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"Puoi provare a usare qualcosa come `Vec<Vec<i32>>`, ma neanche questo "
"funziona immediatamente: è difficile convertire da `Vec<Vec<i32>>` a "
"`&[ &[i32]]` quindi ora non puoi nemmeno usare facilmente `pretty_print`."

#: src/exercises/day-1/solutions-morning.md:84
#, fuzzy
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::"
"AsRef`][1] trait to abstract over anything that can be referenced as a slice."
msgstr ""
"Una volta arrivati ai tratti e ai generici, saremo in grado di usare il "
"tratto [`std::convert::AsRef`][1] per astrarre su tutto ciò che può essere "
"referenziato come slice."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"Inoltre, il tipo stesso non imporrebbe che le sezioni figlie abbiano la "
"stessa lunghezza, quindi tale variabile potrebbe contenere una matrice non "
"valida."

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 1 Afternoon Exercises"
msgstr "# Giorno 1 Esercizi pomeridiani"

#: src/exercises/day-1/solutions-afternoon.md:3
#, fuzzy
msgid "## Designing a Library"
msgstr "## Progettare una libreria"

#: src/exercises/day-1/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](book-library.md))"
msgstr "([torna all'esercizio](book-library.md))"

#: src/exercises/day-1/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    // ANCHOR_END: setup\n"
"\n"
"    // ANCHOR: Library_new\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}, published in {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        // Using a closure and a built-in method:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Longer hand-written solution:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", library."
"is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "# Day 2 Morning Exercises"
msgstr "# Giorno 2 Esercizi mattutini"

#: src/exercises/day-2/solutions-morning.md:3
#, fuzzy
msgid "## Points and Polygons"
msgstr "## Punti e poligoni"

#: src/exercises/day-2/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](points-polygons.md))"
msgstr "([torna all'esercizio](points-polygons.md))"

#: src/exercises/day-2/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}\n"
"\n"
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"        // Alternatively, Iterator::zip() lets us iterate over the points as "
"pairs\n"
"        // but we need to pair each point with the next one, and the last "
"point\n"
"        // with the first point. The zip() iterator is finished as soon as "
"one of \n"
"        // the source iterators is finished, a neat trick is to combine "
"Iterator::cycle\n"
"        // with Iterator::skip to create the second iterator for the zip and "
"using map \n"
"        // and sum to calculate the total length.\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}\n"
"\n"
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 2 Afternoon Exercises"
msgstr "# Giorno 2 Esercizi pomeridiani"

#: src/exercises/day-2/solutions-afternoon.md:3
#, fuzzy
msgid "## Luhn Algorithm"
msgstr "## Algoritmo di Luhn"

#: src/exercises/day-2/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](luhn.md))"
msgstr "([torna all'esercizio](luhn.md))"

#: src/exercises/day-2/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ')."
"enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {cc_number} a valid credit card number? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:97
#, fuzzy
msgid "## Strings and Iterators"
msgstr "## Stringhe e iteratori"

#: src/exercises/day-2/solutions-afternoon.md:99
#, fuzzy
msgid "([back to exercise](strings-iterators.md))"
msgstr "([torna all'esercizio](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:101
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"\n"
"    let mut request_segments = request_path.split('/');\n"
"\n"
"    for prefix_segment in prefix.split('/') {\n"
"        let Some(request_segment) = request_segments.next() else {\n"
"            return false;\n"
"        };\n"
"        if request_segment != prefix_segment && prefix_segment != \"*\" {\n"
"            return false;\n"
"        }\n"
"    }\n"
"    true\n"
"\n"
"    // Alternatively, Iterator::zip() lets us iterate simultaneously over "
"prefix\n"
"    // and request segments. The zip() iterator is finished as soon as one "
"of\n"
"    // the source iterators is finished, but we need to iterate over all "
"request\n"
"    // segments. A neat trick that makes zip() work is to use map() and "
"chain()\n"
"    // to produce an iterator that returns Some(str) for each pattern "
"segments,\n"
"    // and then returns None indefinitely.\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "# Day 3 Morning Exercise"
msgstr "# Giorno 3 Esercizio mattutino"

#: src/exercises/day-3/solutions-morning.md:3
#, fuzzy
msgid "## A Simple GUI Library"
msgstr "## Una semplice libreria GUI"

#: src/exercises/day-3/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](simple-gui.md))"
msgstr "([torna all'esercizio](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }\n"
"\n"
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "# Day 3 Afternoon Exercises"
msgstr "# Giorno 3 Esercizi pomeridiani"

#: src/exercises/day-3/solutions-afternoon.md:3
#, fuzzy
msgid "## Safe FFI Wrapper"
msgstr "## Involucro FFI sicuro"

#: src/exercises/day-3/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([torna all'esercizio](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi\n"
"\n"
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"no-such-directory\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_empty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\"]);\n"
"        Ok(())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo "
"Diaries\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\", \"bar.png\", \"crab.rs\", \"foo."
"txt\"]);\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "# Bare Metal Rust Morning Exercise"
msgstr "# Esercizio mattutino ruggine metallo nudo"

#: src/exercises/bare-metal/solutions-morning.md:3
#, fuzzy
msgid "## Compass"
msgstr "## Bussola"

#: src/exercises/bare-metal/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([torna all'esercizio](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"// ANCHOR_END: top\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"// ANCHOR: main\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // ANCHOR_END: main\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::"
"K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Set up display and timer.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    // ANCHOR: loop\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // ANCHOR_END: loop\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, image, 100);\n"
"\n"
"        // If button A is pressed, switch to the next mode and briefly blink "
"all LEDs on.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometer,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        match self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -"
"> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (value - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_value, min(value, max_value))\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:1
#, fuzzy
msgid "# Bare Metal Rust Afternoon"
msgstr "# Bare Metal Ruggine Pomeriggio"

#: src/exercises/bare-metal/solutions-afternoon.md:3
#, fuzzy
msgid "## RTC driver"
msgstr "## Driver RTC"

#: src/exercises/bare-metal/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([torna all'esercizio](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md:7
#, fuzzy
msgid "`main.rs`:"
msgstr "`principale.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md:9
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"// ANCHOR_END: top\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"// ANCHOR: imports\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"// ANCHOR_END: imports\n"
"\n"
"/// Base address of the PL031 RTC.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// The IRQ used by the PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"// ANCHOR: main\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"    // ANCHOR_END: main\n"
"\n"
"    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // Wait for 3 seconds, without interrupts.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // Wait another 3 seconds for an interrupt.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // ANCHOR: main_end\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"// ANCHOR_END: main_end\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:149
#, fuzzy
msgid "`pl031.rs`:"
msgstr "`pl031.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md:151
msgid ""
"```rust\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Data register\n"
"    dr: u32,\n"
"    /// Match register\n"
"    mr: u32,\n"
"    /// Load register\n"
"    lr: u32,\n"
"    /// Control register\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Interrupt Mask Set or Clear register\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Raw Interrupt Status\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Masked Interrupt Status\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Interrupt Clear Register\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver for a PL031 real-time clock.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Constructs a new instance of the RTC driver for a PL031 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Reads the current RTC value.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() }\n"
"    }\n"
"\n"
"    /// Writes a match value. When the RTC value matches this then an "
"interrupt\n"
"    /// will be generated (if it is enabled).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }\n"
"    }\n"
"\n"
"    /// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true iff `matched` returns true and the interrupt is\n"
"    /// masked.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc)."
"write_volatile(imsc) }\n"
"    }\n"
"\n"
"    /// Clears a pending interrupt, if any.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Rtc {}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "# Concurrency Morning Exercise"
msgstr "# Esercizio mattutino in concorrenza"

#: src/exercises/concurrency/solutions-morning.md:3
#, fuzzy
msgid "## Dining Philosophers"
msgstr "## Filosofi a tavola"

#: src/exercises/concurrency/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([torna all'esercizio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();\n"
"\n"
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "# Concurrency Afternoon Exercise"
msgstr "# Esercizio mattutino in concorrenza"

#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "## Dining Philosophers - Async"
msgstr "## Filosofi a tavola"

#: src/exercises/concurrency/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([torna all'esercizio](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-afternoon.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: Sender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Add a delay before picking the second fork to allow the "
"execution\n"
"        // to transfer to another task\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        // ANCHOR: Philosopher-eat-body\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"        // ANCHOR_END: Philosopher-eat-body\n"
"\n"
"        // The locks are dropped here\n"
"        // ANCHOR: Philosopher-eat-end\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    // Create forks\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::"
"new(Fork))));\n"
"\n"
"    // Create philosophers\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = forks[i].clone();\n"
"            let right_fork = forks[(i + 1) % PHILOSOPHERS.len()].clone();\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork: if i % 2 == 0 { left_fork.clone() } else "
"{ right_fork.clone() },\n"
"                right_fork: if i % 2 == 0 { right_fork } else "
"{ left_fork },\n"
"                thoughts: tx.clone(),\n"
"            });\n"
"        }\n"
"        (philosophers, rx)\n"
"        // tx is dropped here, so we don't need to explicitly drop it later\n"
"    };\n"
"\n"
"    // Make them think and eat\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Output their thoughts\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Here is a thought: {thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:113
msgid "## Broadcast Chat Application"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:115
#, fuzzy
msgid "([back to exercise](chat-app.md))"
msgstr "([torna all'esercizio](rtc.md))"

#: src/exercises/concurrency/solutions-afternoon.md:119
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::sink::SinkExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: handle_connection\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    // ANCHOR_END: handle_connection\n"
"\n"
"    ws_stream\n"
"        .send(Message::text(\"Welcome to chat! Type a message\".into()))\n"
"        .await?;\n"
"    let mut bcast_rx = bcast_tx.subscribe();\n"
"\n"
"    // A continuous loop for concurrently performing two tasks: (1) "
"receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        let msg = msg.as_text()?;\n"
"                        println!(\"From client {addr:?} {msg:?}\");\n"
"                        bcast_tx.send(msg.into())?;\n"
"                    }\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            msg = bcast_rx.recv() => {\n"
"                ws_stream.send(Message::text(msg?)).await?;\n"
"            }\n"
"        }\n"
"    }\n"
"    // ANCHOR: main\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:204
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let mut ws_stream = ClientBuilder::from_uri(Uri::"
"from_static(\"ws://127.0.0.1:2000\"))\n"
"        .connect()\n"
"        .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"    // ANCHOR_END: setup\n"
"    // Continuous loop for concurrently sending and receiving messages.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => println!(\"From server: {}\", msg."
"as_text()?),\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            res = stdin.next_line() => {\n"
"                match res {\n"
"                    Ok(None) => return Ok(()),\n"
"                    Ok(Some(line)) => ws_stream.send(Message::text(line."
"to_string())).await?,\n"
"                    Err(err) => return Err(err.into()),\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#~ msgid "Designing a Library"
#~ msgstr "Progettare una Libreria"

#~ msgid "Elevator Operations"
#~ msgstr "# Operazioni dell’Ascensore"

#~ msgid ""
#~ "<details>\n"
#~ "Key points:"
#~ msgstr ""
#~ "<details>\n"
#~ "Punti chiave:"

#, fuzzy
#~ msgid "Global state is managed with static and constant variables."
#~ msgstr "Lo stato globale è gestito con variabili statiche e costanti."

#, fuzzy
#~ msgid ""
#~ "We will look at mutating static data in the [chapter on Unsafe Rust](../"
#~ "unsafe.md)."
#~ msgstr ""
#~ "Esamineremo la modifica dei dati statici nel [capitolo su Unsafe Rust](../"
#~ "unsafe.md)."

#, fuzzy
#~ msgid "# Designing a Library"
#~ msgstr "# Progettare una libreria"

#, fuzzy
#~ msgid ""
#~ "<details>\n"
#~ "Key Points: "
#~ msgstr ""
#~ "<dettagli>\n"
#~ "Punti chiave:"

#, fuzzy
#~ msgid "`move` closures only implement `FnOnce`."
#~ msgstr "Le chiusure `move` implementano solo `FnOnce`."

#, fuzzy
#~ msgid ""
#~ "Runtimes have the concept of a \"task\", similar to a thread but much\n"
#~ "less resource-intensive."
#~ msgstr ""
#~ "I runtime hanno il concetto di \"attività\", simile a un thread ma molto\n"
#~ "meno dispendioso in termini di risorse."

#, fuzzy
#~ msgid "# Elevator Operation"
#~ msgstr "# Funzionamento dell'ascensore"

#, fuzzy
#~ msgid ""
#~ "Elevators seem simple. You press a button, doors open, you wait, and "
#~ "you're at\n"
#~ "the floor you requested. But implementing an elevator controller is "
#~ "surprisingly\n"
#~ "difficult! This exercise involves building a simple elevator control "
#~ "that\n"
#~ "operates in a simple simulator."
#~ msgstr ""
#~ "Gli ascensori sembrano semplici. Premi un pulsante, le porte si aprono, "
#~ "aspetti e sei a\n"
#~ "il pavimento che hai richiesto. Ma l'implementazione di un controller per "
#~ "ascensori è sorprendente\n"
#~ "difficile! Questo esercizio prevede la costruzione di un semplice "
#~ "controllo dell'ascensore\n"
#~ "opera in un semplice simulatore."

#, fuzzy
#~ msgid ""
#~ "The overall design of this elevator uses the actor pattern: you will "
#~ "implement a\n"
#~ "controller task that communicates with other components of the elevator "
#~ "system\n"
#~ "by sending and receiving messages."
#~ msgstr ""
#~ "Il progetto complessivo di questo ascensore utilizza il modello "
#~ "dell'attore: implementerai a\n"
#~ "attività del controller che comunica con altri componenti del sistema di "
#~ "ascensori\n"
#~ "inviando e ricevendo messaggi."

#, fuzzy
#~ msgid "## Getting Started"
#~ msgstr "## Iniziare"

#, fuzzy
#~ msgid ""
#~ "Download the [exercise template](../../comprehensive-rust-exercises.zip) "
#~ "and look in the `elevator`\n"
#~ "directory for the following files."
#~ msgstr ""
#~ "Scarica il [modello di esercizio](../../comprehensive-rust-exercises.zip) "
#~ "e guarda nell'\"ascensore\"\n"
#~ "directory per i seguenti file."

#, fuzzy
#~ msgid "`src/controller.rs`:"
#~ msgstr "`src/controllore.rs`:"

#, fuzzy
#~ msgid "<!-- File src/controller.rs -->"
#~ msgstr "<!-- File src/controller.rs -->"

#, fuzzy
#~ msgid "Use `cargo run` to run the elevator simulation."
#~ msgstr "Usa `cargo run` per eseguire la simulazione dell'ascensore."

#, fuzzy
#~ msgid "## Exercises"
#~ msgstr "Esercizi"

#, fuzzy
#~ msgid ""
#~ "Begin by implementing a controller that can transport the passengers "
#~ "provided by\n"
#~ "the simple driver. There is only one elevator, and passengers always go "
#~ "from\n"
#~ "floor 0 to floor 2, one-by-one."
#~ msgstr ""
#~ "Inizia implementando un controller in grado di trasportare i passeggeri "
#~ "forniti da\n"
#~ "il semplice conducente. C'è solo un ascensore e i passeggeri vanno sempre "
#~ "da\n"
#~ "piano 0 al piano 2, uno per uno."

#, fuzzy
#~ msgid ""
#~ "Once you have this done, make the problem more complex. Suggested tasks:"
#~ msgstr ""
#~ "Una volta fatto ciò, rendi il problema più complesso. Compiti suggeriti:"

#, fuzzy
#~ msgid ""
#~ " * Make the driver more complex, with passengers arriving at random "
#~ "floors with\n"
#~ "   random destinations at random times.\n"
#~ "\n"
#~ " * Create a building with more than one elevator, and adjust the "
#~ "controller to\n"
#~ "   handle this efficiently.\n"
#~ "\n"
#~ " * Add additional events and metadata to analyze your controller's "
#~ "efficiency.\n"
#~ "   What is the distribution of wait time for passengers? Is the result "
#~ "fair?\n"
#~ "\n"
#~ " * Modify the building to support a maximum passenger capacity for each\n"
#~ "   elevator, and modify the controller to take this information into "
#~ "account.\n"
#~ "\n"
#~ " * Update the driver to simulate business traffic, with lots of "
#~ "passengers going\n"
#~ "   up from the ground floor at the same time, and those passengers "
#~ "returning to\n"
#~ "   the ground floor some time later. Can your controller adjust to these\n"
#~ "   circumstances?\n"
#~ "\n"
#~ " * Modify the building to support \"destination dispatch\", where "
#~ "passengers\n"
#~ "   signal their destination floor in the elevator lobby, before boarding "
#~ "the\n"
#~ "   elevator.\n"
#~ "\n"
#~ " * If you are taking the course with other students, trade controllers "
#~ "or\n"
#~ "   drivers with another student to see how robust your design is.\n"
#~ "\n"
#~ " * Build a textual or graphical display of the elevators as they run."
#~ msgstr ""
#~ " * Rendi il conducente più complesso, con i passeggeri che arrivano a "
#~ "piani casuali\n"
#~ "   destinazioni casuali in orari casuali.\n"
#~ "\n"
#~ " * Crea un edificio con più di un ascensore e regola il controller su\n"
#~ "   gestirlo in modo efficiente.\n"
#~ "\n"
#~ " * Aggiungi ulteriori eventi e metadati per analizzare l'efficienza del "
#~ "tuo controller.\n"
#~ "   Qual è la distribuzione del tempo di attesa per i passeggeri? Il "
#~ "risultato è giusto?\n"
#~ "\n"
#~ " * Modificare l'edificio per supportare una capacità massima di "
#~ "passeggeri per ciascuno\n"
#~ "   elevatore e modificare il controller per tenere conto di queste "
#~ "informazioni.\n"
#~ "\n"
#~ " * Aggiorna il conducente per simulare il traffico aziendale, con molti "
#~ "passeggeri in viaggio\n"
#~ "   dal piano terra allo stesso tempo, e quei passeggeri che tornano a\n"
#~ "   il piano terra qualche tempo dopo. Il tuo controller può adattarsi a "
#~ "questi\n"
#~ "   circostanze?\n"
#~ "\n"
#~ " * Modificare l'edificio per supportare la \"spedizione di "
#~ "destinazione\", dove i passeggeri\n"
#~ "   segnala il piano di destinazione nella hall dell'ascensore, prima di "
#~ "salire a bordo\n"
#~ "   ascensore.\n"
#~ "\n"
#~ " * Se stai frequentando il corso con altri studenti, controllori "
#~ "commerciali o\n"
#~ "   driver con un altro studente per vedere quanto è robusto il tuo "
#~ "progetto.\n"
#~ "\n"
#~ " * Costruisci una visualizzazione testuale o grafica degli ascensori "
#~ "mentre corrono."

#, fuzzy
#~ msgid "</defails>"
#~ msgstr "</defail>"
