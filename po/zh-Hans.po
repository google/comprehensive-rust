msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 🦀\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-02-19 22:10+0800\n"
"Last-Translator: taotieren <admin@taotieren.com>\n"
"Language-Team: Chinese\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "欢迎来到“综合 Rust” 🦀"

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "运行课程"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "课程结构"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "键盘快捷键"

#: src/SUMMARY.md:7
msgid "Translations"
msgstr "翻译"

#: src/SUMMARY.md:8
msgid "Using Cargo"
msgstr "使用 Cargo"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "Rust 生态系统"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "代码示例"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "本地运行 Cargo"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "第 1 天：上午"

#: src/SUMMARY.md:18 src/SUMMARY.md:74 src/SUMMARY.md:127 src/SUMMARY.md:183
msgid "Welcome"
msgstr "欢迎"

#: src/SUMMARY.md:19
msgid "What is Rust?"
msgstr "什么是 Rust？"

#: src/SUMMARY.md:20
msgid "Hello World!"
msgstr "世界你好！"

#: src/SUMMARY.md:21
msgid "Small Example"
msgstr "小例子"

#: src/SUMMARY.md:22
msgid "Why Rust?"
msgstr "为什么 Rust？"

#: src/SUMMARY.md:23
msgid "Compile Time Guarantees"
msgstr "编译时保证"

#: src/SUMMARY.md:24
msgid "Runtime Guarantees"
msgstr "运行时保证"

#: src/SUMMARY.md:25
msgid "Modern Features"
msgstr "现代功能"

#: src/SUMMARY.md:26
msgid "Basic Syntax"
msgstr "基本语法"

#: src/SUMMARY.md:27
msgid "Scalar Types"
msgstr "标量类型"

#: src/SUMMARY.md:28
msgid "Compound Types"
msgstr "复合类型"

#: src/SUMMARY.md:29
msgid "References"
msgstr "引用"

#: src/SUMMARY.md:30
msgid "Dangling References"
msgstr "悬垂引用"

#: src/SUMMARY.md:31
msgid "Slices"
msgstr "切片"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "字符串与字符"

#: src/SUMMARY.md:33
msgid "Functions"
msgstr "功能"

#: src/SUMMARY.md:34 src/SUMMARY.md:81
msgid "Methods"
msgstr "方法"

#: src/SUMMARY.md:35
msgid "Overloading"
msgstr "重载"

#: src/SUMMARY.md:36 src/SUMMARY.md:65 src/SUMMARY.md:89 src/SUMMARY.md:118 src/SUMMARY.md:147
#: src/SUMMARY.md:175 src/SUMMARY.md:198 src/SUMMARY.md:225
msgid "Exercises"
msgstr "习题"

#: src/SUMMARY.md:37
msgid "Implicit Conversions"
msgstr "隐式转换"

#: src/SUMMARY.md:38
msgid "Arrays and for Loops"
msgstr "数组和 for 循环"

#: src/SUMMARY.md:40
msgid "Day 1: Afternoon"
msgstr "第 1 天：下午"

#: src/SUMMARY.md:42
msgid "Variables"
msgstr "变量"

#: src/SUMMARY.md:43
msgid "Type Inference"
msgstr "类型推断"

#: src/SUMMARY.md:44
msgid "static & const"
msgstr "静态 & 常量"

#: src/SUMMARY.md:45
msgid "Scopes and Shadowing"
msgstr "作用域和影射"

#: src/SUMMARY.md:46
msgid "Memory Management"
msgstr "内存管理"

#: src/SUMMARY.md:47
msgid "Stack vs Heap"
msgstr "堆与栈"

#: src/SUMMARY.md:48
msgid "Stack Memory"
msgstr "堆内存"

#: src/SUMMARY.md:49
msgid "Manual Memory Management"
msgstr "手动内存管理"

#: src/SUMMARY.md:50
msgid "Scope-Based Memory Management"
msgstr "基于范围的内存管理"

#: src/SUMMARY.md:51
msgid "Garbage Collection"
msgstr "垃圾回收"

#: src/SUMMARY.md:52
msgid "Rust Memory Management"
msgstr "Rust 内存管理"

#: src/SUMMARY.md:53
msgid "Comparison"
msgstr "比较"

#: src/SUMMARY.md:54
msgid "Ownership"
msgstr "所有权"

#: src/SUMMARY.md:55
msgid "Move Semantics"
msgstr "移动语义"

#: src/SUMMARY.md:56
msgid "Moved Strings in Rust"
msgstr "在 Rust 中移动的字符串"

#: src/SUMMARY.md:57
msgid "Double Frees in Modern C++"
msgstr "现代 C++ 中的重释放"

#: src/SUMMARY.md:58
msgid "Moves in Function Calls"
msgstr "函数调用中的移动"

#: src/SUMMARY.md:59
msgid "Copying and Cloning"
msgstr "复制和克隆"

#: src/SUMMARY.md:60
msgid "Borrowing"
msgstr "借用"

#: src/SUMMARY.md:61
msgid "Shared and Unique Borrows"
msgstr "共享和唯一的借用"

#: src/SUMMARY.md:62
msgid "Lifetimes"
msgstr "生命周期"

#: src/SUMMARY.md:63
msgid "Lifetimes in Function Calls"
msgstr "函数调用中的生命周期"

#: src/SUMMARY.md:64
msgid "Lifetimes in Data Structures"
msgstr "数据结构中的生命周期"

#: src/SUMMARY.md:66
msgid "Designing a Library"
msgstr "设计库"

#: src/SUMMARY.md:67
msgid "Iterators and Ownership"
msgstr "迭代器和所有权"

#: src/SUMMARY.md:70
msgid "Day 2: Morning"
msgstr "第 2 天：上午"

#: src/SUMMARY.md:75
msgid "Structs"
msgstr "结构体"

#: src/SUMMARY.md:76
msgid "Tuple Structs"
msgstr "元组结构"

#: src/SUMMARY.md:77
msgid "Field Shorthand Syntax"
msgstr "字段速记语法"

#: src/SUMMARY.md:78
msgid "Enums"
msgstr "枚举"

#: src/SUMMARY.md:79
msgid "Variant Payloads"
msgstr "变量有效载荷"

#: src/SUMMARY.md:80
msgid "Enum Sizes"
msgstr "枚举大小"

#: src/SUMMARY.md:82
msgid "Method Receiver"
msgstr "方法接收器"

#: src/SUMMARY.md:83 src/SUMMARY.md:158 src/SUMMARY.md:193
msgid "Example"
msgstr "例子"

#: src/SUMMARY.md:84
msgid "Pattern Matching"
msgstr "模式匹配"

#: src/SUMMARY.md:85
msgid "Destructuring Enums"
msgstr "解构枚举"

#: src/SUMMARY.md:86
msgid "Destructuring Structs"
msgstr "解构结构"

#: src/SUMMARY.md:87
msgid "Destructuring Arrays"
msgstr "解构数组"

#: src/SUMMARY.md:88
msgid "Match Guards"
msgstr "匹配防护"

#: src/SUMMARY.md:90
msgid "Health Statistics"
msgstr "健康统计"

#: src/SUMMARY.md:91
msgid "Points and Polygons"
msgstr "点和多边形"

#: src/SUMMARY.md:93
msgid "Day 2: Afternoon"
msgstr "第 2 天：下午"

#: src/SUMMARY.md:95
msgid "Control Flow"
msgstr "控制流程"

#: src/SUMMARY.md:96
msgid "Blocks"
msgstr "区块"

#: src/SUMMARY.md:97
msgid "if expressions"
msgstr "if 表达式"

#: src/SUMMARY.md:98
msgid "if let expressions"
msgstr "if let 表达式"

#: src/SUMMARY.md:99
msgid "while expressions"
msgstr "while 表达式"

#: src/SUMMARY.md:100
msgid "while let expressions"
msgstr "while let 表达式"

#: src/SUMMARY.md:101
msgid "for expressions"
msgstr "for 表达式"

#: src/SUMMARY.md:102
msgid "loop expressions"
msgstr "loop 表达式"

#: src/SUMMARY.md:103
msgid "match expressions"
msgstr "match 表达式"

#: src/SUMMARY.md:104
msgid "break & continue"
msgstr "休息并继续"

#: src/SUMMARY.md:105
msgid "Standard Library"
msgstr "标准库"

#: src/SUMMARY.md:106
msgid "Option and Result"
msgstr "选项和结果"

#: src/SUMMARY.md:107
msgid "String"
msgstr "字符串"

#: src/SUMMARY.md:108
msgid "Vec"
msgstr ""

#: src/SUMMARY.md:109
msgid "HashMap"
msgstr ""

#: src/SUMMARY.md:110
msgid "Box"
msgstr ""

#: src/SUMMARY.md:111
msgid "Recursive Data Types"
msgstr "递归数据类型"

#: src/SUMMARY.md:112
msgid "Niche Optimization"
msgstr "Niche (利基) 优化"

#: src/SUMMARY.md:113
msgid "Rc"
msgstr ""

#: src/SUMMARY.md:114
msgid "Modules"
msgstr "模块"

#: src/SUMMARY.md:115
msgid "Visibility"
msgstr "可见性"

#: src/SUMMARY.md:116
msgid "Paths"
msgstr "路径"

#: src/SUMMARY.md:117
msgid "Filesystem Hierarchy"
msgstr "文件系统层次结构"

#: src/SUMMARY.md:119
msgid "Luhn Algorithm"
msgstr "卢恩 (Luhn) 算法"

#: src/SUMMARY.md:120
msgid "Strings and Iterators"
msgstr "字符串和迭代器"

#: src/SUMMARY.md:123
msgid "Day 3: Morning"
msgstr "第 3 天：上午"

#: src/SUMMARY.md:128
msgid "Traits"
msgstr "特质"

#: src/SUMMARY.md:129
msgid "Deriving Traits"
msgstr "派生特质"

#: src/SUMMARY.md:130
msgid "Default Methods"
msgstr "默认方法"

#: src/SUMMARY.md:131
msgid "Important Traits"
msgstr "重要特质 (Traits)"

#: src/SUMMARY.md:132
msgid "Iterator"
msgstr "迭代器（Iterator）"

#: src/SUMMARY.md:133
msgid "FromIterator"
msgstr "迭代器（FromIterator）"

#: src/SUMMARY.md:134
msgid "From and Into"
msgstr ""

#: src/SUMMARY.md:135
msgid "Read and Write"
msgstr "读和写"

#: src/SUMMARY.md:136
msgid "Add, Mul, ..."
msgstr ""

#: src/SUMMARY.md:137
msgid "Drop"
msgstr ""

#: src/SUMMARY.md:138
msgid "Default"
msgstr "默认"

#: src/SUMMARY.md:139
msgid "Generics"
msgstr "泛型"

#: src/SUMMARY.md:140
msgid "Generic Data Types"
msgstr "泛型数据类型"

#: src/SUMMARY.md:141
msgid "Generic Methods"
msgstr "泛型方法"

#: src/SUMMARY.md:142
msgid "Trait Bounds"
msgstr ""

#: src/SUMMARY.md:143
msgid "impl Trait"
msgstr ""

#: src/SUMMARY.md:144
msgid "Closures"
msgstr "闭包"

#: src/SUMMARY.md:145
msgid "Monomorphization"
msgstr "单一化"

#: src/SUMMARY.md:146
msgid "Trait Objects"
msgstr ""

#: src/SUMMARY.md:148
msgid "A Simple GUI Library"
msgstr "一个简单的图形用户界面库"

#: src/SUMMARY.md:150
msgid "Day 3: Afternoon"
msgstr "第 3 天：下午"

#: src/SUMMARY.md:152
msgid "Error Handling"
msgstr "错误处理"

#: src/SUMMARY.md:153
msgid "Panics"
msgstr ""

#: src/SUMMARY.md:154
msgid "Catching Stack Unwinding"
msgstr "捕捉堆栈展开"

#: src/SUMMARY.md:155
msgid "Structured Error Handling"
msgstr "结构化错误处理"

#: src/SUMMARY.md:156
msgid "Propagating Errors with ?"
msgstr "传播错误用 ?"

#: src/SUMMARY.md:157
msgid "Converting Error Types"
msgstr "转换错误类型"

#: src/SUMMARY.md:159
msgid "Deriving Error Enums"
msgstr "派生错误枚举"

#: src/SUMMARY.md:160
msgid "Dynamic Error Types"
msgstr "动态错误类型"

#: src/SUMMARY.md:161
msgid "Adding Context to Errors"
msgstr "为错误添加上下文"

#: src/SUMMARY.md:162
msgid "Testing"
msgstr "测试"

#: src/SUMMARY.md:163
msgid "Unit Tests"
msgstr "单元测试"

#: src/SUMMARY.md:164
msgid "Test Modules"
msgstr "测试模块"

#: src/SUMMARY.md:165
msgid "Documentation Tests"
msgstr "文档测试"

#: src/SUMMARY.md:166
msgid "Integration Tests"
msgstr "集成测试"

#: src/SUMMARY.md:167
msgid "Unsafe Rust"
msgstr "非安全 Rust"

#: src/SUMMARY.md:168
msgid "Dereferencing Raw Pointers"
msgstr "取消引用原始指针"

#: src/SUMMARY.md:169
msgid "Mutable Static Variables"
msgstr "可变静态变量"

#: src/SUMMARY.md:170
msgid "Unions"
msgstr "联合"

#: src/SUMMARY.md:171
msgid "Calling Unsafe Functions"
msgstr "调用不安全函数"

#: src/SUMMARY.md:172
msgid "Writing Unsafe Functions"
msgstr "编写不安全的函数"

#: src/SUMMARY.md:173
msgid "Extern Functions"
msgstr "外部函数"

#: src/SUMMARY.md:174
msgid "Implementing Unsafe Traits"
msgstr "实现不安全的特征"

#: src/SUMMARY.md:176
msgid "Safe FFI Wrapper"
msgstr "安全 FFI 包装"

#: src/SUMMARY.md:179
msgid "Day 4: Morning"
msgstr "第 4 天：上午"

#: src/SUMMARY.md:184
msgid "Concurrency"
msgstr "并发"

#: src/SUMMARY.md:185
msgid "Threads"
msgstr "线程"

#: src/SUMMARY.md:186
msgid "Scoped Threads"
msgstr "作用域内线程"

#: src/SUMMARY.md:187
msgid "Channels"
msgstr "信道"

#: src/SUMMARY.md:188
msgid "Unbounded Channels"
msgstr "无界通道"

#: src/SUMMARY.md:189
msgid "Bounded Channels"
msgstr "有界通道"

#: src/SUMMARY.md:190
msgid "Shared State"
msgstr "共享状态"

#: src/SUMMARY.md:191
msgid "Arc"
msgstr "弧形"

#: src/SUMMARY.md:192
msgid "Mutex"
msgstr "互斥"

#: src/SUMMARY.md:194
msgid "Send and Sync"
msgstr "发送和同步"

#: src/SUMMARY.md:194
msgid "Send"
msgstr "发送"

#: src/SUMMARY.md:194
msgid "Sync"
msgstr "同步"

#: src/SUMMARY.md:197
msgid "Examples"
msgstr "示例"

#: src/SUMMARY.md:199
msgid "Dining Philosophers"
msgstr ""

#: src/SUMMARY.md:200
msgid "Multi-threaded Link Checker"
msgstr "多线程链接检查器"

#: src/SUMMARY.md:202
msgid "Day 4: Afternoon"
msgstr "第 4 天：下午"

#: src/SUMMARY.md:206
msgid "Android"
msgstr "安卓"

#: src/SUMMARY.md:207
msgid "Setup"
msgstr "设置"

#: src/SUMMARY.md:208
msgid "Build Rules"
msgstr "构建规则"

#: src/SUMMARY.md:209
msgid "Binary"
msgstr "二进制"

#: src/SUMMARY.md:210
msgid "Library"
msgstr "库"

#: src/SUMMARY.md:211
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:212
msgid "Interface"
msgstr "接口"

#: src/SUMMARY.md:213
msgid "Implementation"
msgstr "实现"

#: src/SUMMARY.md:214
msgid "Server"
msgstr "服务端"

#: src/SUMMARY.md:215
msgid "Deploy"
msgstr "部署"

#: src/SUMMARY.md:216
msgid "Client"
msgstr "客户端"

#: src/SUMMARY.md:217
msgid "Changing API"
msgstr "更改 API"

#: src/SUMMARY.md:218
msgid "Logging"
msgstr "记录"

#: src/SUMMARY.md:219
msgid "Interoperability"
msgstr "互操作性"

#: src/SUMMARY.md:220
msgid "With C"
msgstr "用 C"

#: src/SUMMARY.md:221
msgid "Calling C with Bindgen"
msgstr "使用 Bindgen 调用 C"

#: src/SUMMARY.md:222
msgid "Calling Rust from C"
msgstr "从 C 调用 Rust"

#: src/SUMMARY.md:223
msgid "With C++"
msgstr "与 C++"

#: src/SUMMARY.md:224
msgid "With Java"
msgstr "用 Java"

#: src/SUMMARY.md:227
msgid "Final Words"
msgstr "结语"

#: src/SUMMARY.md:229
msgid "Thanks!"
msgstr "谢谢！"

#: src/SUMMARY.md:230
msgid "Other Resources"
msgstr "其他资源"

#: src/SUMMARY.md:231
msgid "Credits"
msgstr "信用"

#: src/SUMMARY.md:235
msgid "Solutions"
msgstr "解决方案"

#: src/SUMMARY.md:240
msgid "Day 1 Morning"
msgstr "第 1 天上午"

#: src/SUMMARY.md:241
msgid "Day 1 Afternoon"
msgstr "第 1 天下午"

#: src/SUMMARY.md:242
msgid "Day 2 Morning"
msgstr "第 2 天上午"

#: src/SUMMARY.md:243
msgid "Day 2 Afternoon"
msgstr "第 2 天下午"

#: src/SUMMARY.md:244
msgid "Day 3 Morning"
msgstr "第 3 天上午"

#: src/SUMMARY.md:245
msgid "Day 3 Afternoon"
msgstr "第 3 天下午"

#: src/SUMMARY.md:246
msgid "Day 4 Morning"
msgstr "第 4 天上午"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust 🦀"
msgstr "# 欢迎来到“综合 Rust” 🦀"

#: src/welcome.md:3
msgid ""
"This is a four day Rust course developed by the Android team. The course covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like generics\n"
"and error handling. It also includes Android-specific content on the last day."
msgstr ""
"这是一个为期 4 天的 Rust 课程，由 Android 团队开发。该课程涵盖了 Rust 的全部内容，从基本语法到高级"
"主题，如泛型和错误处理。它还包括最后一天的 Android 特定内容。"

#: src/welcome.md:7
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know anything\n"
"about Rust and hope to:"
msgstr "该课程的目标是教给你 Rust。我们假设你对 Rust 一无所知，并希望能够："

#: src/welcome.md:10
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* 让你全面了解 Rust 的语法和语言。\n"
"* 让你能够用 Rust 修改现有程序和编写新程序。\n"
"* 向你展示常见的 Rust 习语。"

#: src/welcome.md:14
msgid "On Day 4, we will cover Android-specific things such as:"
msgstr "第 4 天，我们将介绍安卓系统特有的东西，如："

#: src/welcome.md:16
msgid ""
"* Building Android components in Rust.\n"
"* AIDL servers and clients.\n"
"* Interoperability with C, C++, and Java."
msgstr ""
"* 用 Rust 构建 Android 组件。\n"
"* AIDL 服务器和客户端。\n"
"* 与 C、C++ 和 Java 的互操作性。"

#: src/welcome.md:20
msgid ""
"It is important to note that this course does not cover Android **application** \n"
"development in Rust, and that the Android-specific parts are specifically about\n"
"writing code for Android itself, the operating system. "
msgstr ""
"需要注意的是，本课程并不包括 Rust 中的安卓 **应用** 开发，安卓特有的部分是专门为安卓本身、操作系统"
"编写代码。 "

#: src/welcome.md:24
msgid "## Non-Goals"
msgstr "## 非目标"

#: src/welcome.md:26
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few days.\n"
"Some non-goals of this course are:"
msgstr "Rust 是一门很大的语言，我们不可能在几天内把它全部讲完。 本课程的一些非目标是："

#: src/welcome.md:29
msgid ""
"* Learn how to use async Rust --- we'll only mention async Rust when\n"
"  covering traditional concurrency primitives. Please see [Asynchronous\n"
"  Programming in Rust](https://rust-lang.github.io/async-book/) instead for\n"
"  details on this topic.\n"
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* 学习如何使用 async Rust ----- 我们只在涉及传统的并发原语时提到 async Rust。关于这一主题的细节，请"
"参见 [Rust 中的异步编程](https://rust-lang.github.io/async-book/)。\n"
"* 学习如何开发宏，请参见 [Rust 书中的第 19.5 章](https://doc.rust-lang.org/book/ch19-06-macros."
"html)和 [通过例子学 Rust](https://doc.rust-lang.org/rust-by-example/macros.html)。"

#: src/welcome.md:37
msgid "## Assumptions"
msgstr "## 假设"

#: src/welcome.md:39
msgid ""
"The course assumes that you already know how to program. Rust is a statically\n"
"typed language and we will sometimes make comparisons with C and C++ to better\n"
"explain or contrast the Rust approach."
msgstr ""
"该课程假定你已经知道如何编程。Rust 是一种静态类型的语言，我们有时会与 C 和 C++ 进行比较，以更好地解"
"释或对比 Rust 的方法。"

#: src/welcome.md:43
msgid ""
"If you know how to program in a dynamically typed language such as Python or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr "如果你知道如何用动态类型语言（如 Python 或 JavaScript）编程，那么你也能很好地跟着学。"

#: src/welcome.md:46 src/cargo/rust-ecosystem.md:19 src/cargo/code-samples.md:22
#: src/cargo/running-locally.md:68 src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8 src/why-rust/modern.md:19
#: src/basic-syntax/compound-types.md:28 src/basic-syntax/slices.md:18
#: src/basic-syntax/string-slices.md:25 src/basic-syntax/functions.md:33
#: src/basic-syntax/functions-interlude.md:25 src/exercises/day-1/morning.md:9
#: src/exercises/day-1/for-loops.md:90 src/basic-syntax/variables.md:15
#: src/basic-syntax/type-inference.md:24 src/basic-syntax/static-and-const.md:46
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27 src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/structs/tuple-structs.md:35
#: src/structs/field-shorthand.md:25 src/enums/variant-payloads.md:33 src/methods.md:28
#: src/pattern-matching/destructuring-enums.md:33 src/pattern-matching/destructuring-arrays.md:18
#: src/pattern-matching/match-guards.md:20 src/exercises/day-2/morning.md:9
#: src/exercises/day-2/points-polygons.md:115 src/control-flow/blocks.md:40
#: src/control-flow/if-expressions.md:29 src/control-flow/if-let-expressions.md:19
#: src/control-flow/while-let-expressions.md:25 src/control-flow/match-expressions.md:25
#: src/std/option-result.md:16 src/std/string.md:28 src/std/vec.md:35 src/std/hashmap.md:36
#: src/std/box.md:32 src/std/box-recursive.md:31 src/std/rc.md:29 src/modules.md:26
#: src/modules/visibility.md:37 src/modules/filesystem.md:24 src/exercises/day-2/afternoon.md:5
#: src/traits.md:39 src/traits/iterator.md:30 src/traits/from-iterator.md:15
#: src/traits/operators.md:24 src/traits/drop.md:32 src/traits/default.md:38
#: src/generics/methods.md:23 src/generics/trait-bounds.md:33 src/generics/impl-trait.md:22
#: src/generics/closures.md:23 src/exercises/day-3/morning.md:5 src/error-handling/result.md:25
#: src/error-handling/try-operator.md:48 src/error-handling/converting-error-types-example.md:48
#: src/error-handling/deriving-error-enums.md:37 src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26 src/unsafe/raw-pointers.md:24
#: src/unsafe/mutable-static-variables.md:30 src/unsafe/unions.md:19
#: src/unsafe/writing-unsafe-functions.md:31 src/unsafe/extern-functions.md:19
#: src/unsafe/unsafe-traits.md:28 src/exercises/day-3/afternoon.md:5 src/concurrency/threads.md:28
#: src/concurrency/channels.md:25 src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/example.md:21 src/concurrency/send-sync.md:18
#: src/concurrency/send-sync/sync.md:12 src/exercises/day-4/morning.md:10
#: src/android/interoperability/with-c/rust.md:81 src/exercises/day-4/afternoon.md:10
msgid "<details>"
msgstr ""

#: src/welcome.md:48
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor should\n"
"cover as well as answers to typical questions which come up in class."
msgstr ""
"这是一个 _演讲者笔记_ 的例子。我们将使用这些注释来为幻灯片添加额外的信息。这可能是教师应该涉及的关"
"键点，以及对课堂上出现的典型问题的回答。"

#: src/welcome.md:52 src/cargo/rust-ecosystem.md:67 src/cargo/code-samples.md:35
#: src/cargo/running-locally.md:74 src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:36 src/hello-world/small-example.md:44 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22 src/why-rust/modern.md:66
#: src/basic-syntax/compound-types.md:62 src/basic-syntax/references.md:28
#: src/basic-syntax/slices.md:36 src/basic-syntax/functions.md:54 src/exercises/day-1/morning.md:28
#: src/exercises/day-1/for-loops.md:95 src/basic-syntax/variables.md:20
#: src/basic-syntax/type-inference.md:48 src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/borrowing.md:51
#: src/ownership/shared-unique-borrows.md:29 src/ownership/lifetimes-function-calls.md:60
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:103 src/structs.md:41
#: src/enums/variant-payloads.md:41 src/enums/sizes.md:136 src/methods/example.md:53
#: src/pattern-matching/destructuring-enums.md:39 src/exercises/day-2/morning.md:15
#: src/exercises/day-2/points-polygons.md:125 src/control-flow/if-let-expressions.md:26
#: src/control-flow/for-expressions.md:29 src/control-flow/loop-expressions.md:27 src/std.md:31
#: src/std/option-result.md:25 src/std/string.md:33 src/std/vec.md:49 src/std/hashmap.md:66
#: src/std/rc.md:66 src/modules.md:32 src/modules/visibility.md:48 src/modules/filesystem.md:53
#: src/exercises/day-2/afternoon.md:11 src/traits.md:54 src/traits/from-iterator.md:26
#: src/traits/operators.md:38 src/traits/drop.md:42 src/traits/default.md:47
#: src/generics/methods.md:31 src/generics/closures.md:38 src/exercises/day-3/morning.md:11
#: src/error-handling/try-operator.md:55 src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45 src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32 src/unsafe/raw-pointers.md:42
#: src/unsafe/mutable-static-variables.md:35 src/unsafe/unions.md:28
#: src/unsafe/writing-unsafe-functions.md:38 src/unsafe/extern-functions.md:28
#: src/unsafe/unsafe-traits.md:37 src/exercises/day-3/afternoon.md:11 src/concurrency/threads.md:45
#: src/concurrency/channels.md:32 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/example.md:60 src/concurrency/send-sync/sync.md:18
#: src/exercises/day-4/morning.md:16 src/android/interoperability/with-c/rust.md:86
#: src/exercises/day-4/afternoon.md:15
msgid "</details>"
msgstr ""

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# 运行课程"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "> This page is for the course instructor."
msgstr "> 此页面适用于课程讲师。"

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the course\n"
"internally at Google."
msgstr "以下是关于我们在谷歌内部如何运行该课程的一些背景信息。"

#: src/running-the-course.md:8
msgid "To run the course, you need to:"
msgstr "要运行该课程，您需要："

#: src/running-the-course.md:10
msgid ""
"1. Make yourself familiar with the course material. We've included speaker notes\n"
"   on some of the pages to help highlight the key points (please help us by\n"
"   contributing more speaker notes!). You should make sure to open the speaker\n"
"   notes in a popup (click the link with a little arrow next to \"Speaker\n"
"   Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"1. 让自己熟悉课程材料。我们在一些页面上加入了演讲者注释，以帮助突出关键点（请帮助我们贡献更多的演讲"
"者注释！）。你应该确保在弹出式窗口中打开演讲者注释（点击 \"演讲者注释\" 旁边有小箭头的链接）。这样"
"你就有一个干净的屏幕来向全班介绍。"

#: src/running-the-course.md:16
msgid ""
"2. Decide on the dates. Since the course is large, we recommend that you\n"
"   schedule the four days over two weeks. Course participants have said that\n"
"   they find it helpful to have a gap in the course since it helps them process\n"
"   all the information we give them."
msgstr ""
"2. 决定日期。由于课程规模较大，我们建议你将 4 天的课程安排在两周内。课程参与者说，他们发现在课程中"
"有一个间隙是很有帮助的，因为这有助于他们处理我们给他们的所有信息。"

#: src/running-the-course.md:21
msgid ""
"3. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-20 people. That's small enough that people are comfortable\n"
"   asking questions --- it's also small enough that one instructor will have\n"
"   time to answer the questions."
msgstr ""
"3. 找一个足够大的房间给你的亲身参与者。我们建议班级规模为 15-20 人。这个人数足够小，人们可以自如地"
"提出问题---也足够小，以便一位教师有时间回答问题。"

#: src/running-the-course.md:26
msgid ""
"4. On the day of your course, show up to the room a little early to set things\n"
"   up. We recommend presenting directly using `mdbook serve` running on your\n"
"   laptop (see the [installation instructions][5]). This ensures optimal performance with no lag "
"as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them."
msgstr ""
"4. 在你的课程当天，提前一点出现在房间里，把事情安排好。我们建议直接使用笔记本电脑上运行的 `mdbook "
"serve` 进行演示（见 [安装说明][5]）。这可以确保最佳的性能，在你更换页面时没有滞后。 使用你的笔记本"
"电脑也可以让你在你或课程参与者发现错别字时进行修改。"

#: src/running-the-course.md:32
msgid ""
"5. Let people solve the exercises by themselves or in small groups. Make sure to\n"
"   ask people if they're stuck or if there is anything you can help with. When\n"
"   you see that several people have the same problem, call it out to the class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr ""
"5. 让人们自己或在小组中解决这些练习。确保询问人们是否被卡住了，或者是否有你能帮助的地方。当你看到几"
"个人有同样的问题时，向全班喊出，并提供一个解决方案，例如，告诉大家在哪里可以找到标准库中的相关信"
"息。"

#: src/running-the-course.md:38
msgid ""
"6. If you don't skip the Android specific parts on Day 4, you will need an [AOSP\n"
"   checkout][1]. Make a checkout of the [course repository][2] on the same\n"
"   machine and move the `src/android/` directory into the root of your AOSP\n"
"   checkout. This will ensure that the Android build system sees the\n"
"   `Android.bp` files in `src/android/`."
msgstr ""
"6. 如果你不跳过第 4 天的 Android 特定部分，你将需要一个 [AOSP检出][1]。在同一台机器上对 [课程库]"
"[2] 进行签出，将 `src/android/` 目录移到你的 AOSP 签出的根目录下。这将确保 Android 构建系统看到 "
"`src/android/` 中的 `Android.bp` 文件。"

#: src/running-the-course.md:44
msgid ""
"   Ensure that `adb sync` works with your emulator or real device and pre-build\n"
"   all Android examples using `src/android/build_all.sh`. Read the script to see\n"
"   the commands it runs and make sure they work when you run them by hand."
msgstr ""
"   确保 `adb sync` 在你的模拟器或真实设备上工作，并使用 `src/android/build_all.sh` 预先构建所有的 "
"Android 例子。阅读该脚本，看看它所运行的命令，并确保在你手动运行这些命令时它们能正常工作。"

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun for\n"
"you as it has been for us!"
msgstr "就这样了，祝你跑出好成绩! 我们希望它对你来说会像对我们一样有趣！"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback][3] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][4]!"
msgstr ""
"事后请 [提供反馈][3]，以便我们能够继续改进课程。我们很想听听哪些地方对你来说很有效，哪些地方可以做"
"得更好。我们也非常欢迎你的学生 [向我们发送反馈][4]!"

#: src/running-the-course.md:55
msgid ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100\n"
"[5]: https://github.com/google/comprehensive-rust#building"
msgstr ""

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# 课程结构"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "该课程节奏很快，涵盖了很多内容："

#: src/running-the-course/course-structure.md:7
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust.\n"
"* Day 4: Concurrency in Rust and interoperability with other languages"
msgstr ""
"* 第 1 天：基本的 Rust，所有权和借贷检查器。\n"
"* 第 2 天：复合数据类型，模式匹配，标准库。\n"
"* 第 3 天：属性和泛型，错误处理，测试，不安全的 Rust。\n"
"* 第 4 天：Rust 的并发性以及与其他语言的互操作性"

#: src/running-the-course/course-structure.md:12
msgid ""
"> **Exercise for Day 4:** Do you interface with some C/C++ code in your project\n"
"> which we could attempt to move to Rust? The fewer dependencies the better.\n"
"> Parsing code would be ideal."
msgstr ""
"> **第 4 天的练习：** 你的项目中是否有一些 C/C++ 代码的接口？\n"
"> 我们可以尝试将其转移到 Rust？依赖关系越少越好。\n"
"> 解析代码将是最理想的。"

#: src/running-the-course/course-structure.md:16
msgid "## Format"
msgstr "## 格式"

#: src/running-the-course/course-structure.md:18
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr "这门课程的目的是要有很强的互动性，我们建议让问题来推动对 Rust 的探索!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# 键盘快捷键"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "在 mdBook 中，有几个有用的键盘快捷方式："

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>Arrow-Left</kbd>： 导航到上一页。\n"
"* <kbd>Arrow-Right</kbd>： 导航到下一页。\n"
"* <kbd>Ctrl + Enter</kbd>：执行具有焦点的代码示例。\n"
"* <kbd>s</kbd>： 激活搜索栏。"

#: src/running-the-course/translations.md:1
msgid "# Translations"
msgstr "# 翻译"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful\n"
"volunteers:"
msgstr "该课程已被一组优秀的志愿者翻译成其他语言："

#: src/running-the-course/translations.md:6
msgid ""
"* [Brazilian Portuguese][pt-BR] by [@rastringer] and [@hugojacob].\n"
"* [Korean][ko] by [@keispace], [@jiyongp] and [@jooyunghan].\n"
"* [简体中文][zh-Hans] by [@taotieren]"
msgstr ""

#: src/running-the-course/translations.md:10
msgid "Use the language picker in the top-right corner to switch between languages."
msgstr "使用右上角的语言选择器来切换语言。"

#: src/running-the-course/translations.md:12
msgid ""
"If you want to help with this effort, please see [our instructions] for how to\n"
"get going. Translations are coordinated on the [issue tracker]."
msgstr "如果你想帮助这项工作，请参见[我们的说明]了解如何进行。翻译工作在[问题跟踪器]上进行协调。"

#: src/running-the-course/translations.md:15
msgid ""
"[pt-BR]: https://google.github.io/comprehensive-rust/pt-BR/\n"
"[ko]: https://google.github.io/comprehensive-rust/ko/\n"
"[zh-Hans]: https://google.github.io/comprehensive-rust/zh-Hans/\n"
"[@rastringer]: https://github.com/rastringer\n"
"[@hugojacob]: https://github.com/hugojacob\n"
"[@keispace]: https://github.com/keispace\n"
"[@jiyongp]: https://github.com/jiyongp\n"
"[@jooyunghan]: https://github.com/jooyunghan\n"
"[@taotieren]: https://github.com/taotieren\n"
"[our instructions]: https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md\n"
"[issue tracker]: https://github.com/google/comprehensive-rust/issues/282"
msgstr ""

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# 使用 Cargo"

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc.rust-lang.org/cargo/), "
"the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want to\n"
"give a brief overview of what Cargo is and how it fits into the wider ecosystem\n"
"and how it fits into this training."
msgstr ""
"当你开始阅读 Rust 的时候，你很快就会见到 [Cargo](https://doc.rust-lang.org/cargo/)，这是 Rust 生态"
"系统中用来构建和运行 Rust 应用程序的标准工具。在这里，我们想简单介绍一下什么是 Cargo，它是如何融入"
"更广泛的生态系统的，以及它是如何融入这个培训的。"

#: src/cargo.md:8
msgid "## Installation"
msgstr "## 安装"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "### Rustup（推荐）"

#: src/cargo.md:12
msgid ""
"You can follow the instructions to install cargo and rust compiler, among other standard ecosystem "
"tools with the [rustup][3] tool, which is maintained by the Rust Foundation."
msgstr ""
"你可以按照说明，用 [rustup][3] 工具安装 cargo 和 rust 编译器，以及其他标准的生态系统工具，该工具由 "
"Rust 基金会维护。"

#: src/cargo.md:14
msgid ""
"Along with cargo and rustc, Rustup will install itself as a command line utility that you can use "
"to install/switch toolchains, setup cross compilation, etc."
msgstr ""
"与 cargo 和 rustc 一起，Rustup 将自己安装成一个命令行工具，你可以用它来安装/切换工具链，设置交叉编"
"译等。"

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### 包管理器"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### Debian"

#: src/cargo.md:20
msgid "On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust formatter][6] with"
msgstr "在 Debian/Ubuntu 上，你可以用以下方法安装 Cargo、Rust 源代码和 [Rust格式化器][6]"

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr ""
"这将允许 [rust-analyzer][1] 跳到定义。我们建议使用 [VS Code][2] 来编辑代码（但任何 LSP 兼容的编辑器"
"都可以）。"

#: src/cargo.md:29
msgid ""
"Some folks also like to use the [JetBrains][4] family of IDEs, which do their own analysis but "
"have their own tradeoffs. If you prefer them, you can install the [Rust Plugin][5]. Please take "
"note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"有些人也喜欢使用 [JetBrains][4] 系列的 IDE，它们会做自己的分析，但有自己的取舍。如果你喜欢他们，你"
"可以安装 [Rust Plugin][5]。请注意，从 2023 年 1 月起，调试只在 JetBrains IDEA 套件的 CLion 版本上运"
"行。"

#: src/cargo.md:31
msgid ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/\n"
"[6]: https://github.com/rust-lang/rustfmt"
msgstr ""

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# Rust 生态系统"

#: src/cargo/rust-ecosystem.md:3
msgid "The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "Rust 生态系统由许多工具组成，其中主要的工具有："

#: src/cargo/rust-ecosystem.md:5
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and other\n"
"  intermediate formats."
msgstr "* `rustc`：Rust 编译器，将 `.rs` 文件变成二进制文件和其他中间格式。"

#: src/cargo/rust-ecosystem.md:8
msgid ""
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests."
msgstr ""
"* `cargo`：Rust 的依赖性管理和构建工具。Cargo 知道如何下载托管在 <https://crates.io> 上的依赖项，并"
"在构建项目时将它们传递给 `rustc`。Cargo 也有一个内置的测试运行器，用来执行单元测试。"

#: src/cargo/rust-ecosystem.md:13
msgid ""
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and `rustup`\n"
"  will let you switch between them as needed."
msgstr ""
"* `rustup`：Rust 工具链的安装和更新程序。当新版本的 Rust 发布时，这个工具被用来安装和更新 `rustc` "
"和 `cargo`。 此外，`rustup` 还可以下载标准库的文档。你可以同时安装多个版本的 Rust，`rustup` 会让你"
"根据需要在它们之间切换。"

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25 src/hello-world/small-example.md:27
#: src/why-rust/runtime.md:10 src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/error-handling/try-operator.md:50 src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30
msgid "Key points:"
msgstr "要点："

#: src/cargo/rust-ecosystem.md:23
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality."
msgstr ""
"* Rust 有一个快速的发布时间表，每 6 个星期就会有一个新的版本。新版本保持了与旧版本的向后兼容"
"性------而且还能实现新功能。"

#: src/cargo/rust-ecosystem.md:27
msgid "* There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "* 有 3 个发布渠道。\"stable\"、\"beta \"和 \"nightly\"。"

#: src/cargo/rust-ecosystem.md:29
msgid ""
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks."
msgstr "* 新的功能正在进行 \"nightly\" 测试，\"beta\" 是每 6 周变成 \"stable\" 的。"

#: src/cargo/rust-ecosystem.md:32
msgid ""
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018."
msgstr "* Rust 也有[版本]：当前版本是 Rust 2021。以前的版本是 Rust 2015 和 Rust 2018。"

#: src/cargo/rust-ecosystem.md:35
msgid ""
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language."
msgstr "  * 版本允许对语言进行向后不兼容的修改。"

#: src/cargo/rust-ecosystem.md:38
msgid ""
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file."
msgstr "  * 为了防止破坏代码，版本是选择进入的：你通过 `Cargo.toml` 文件为你的板块选择版本。"

#: src/cargo/rust-ecosystem.md:41
msgid ""
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions."
msgstr "  * 为了避免分裂生态系统，Rust 编译器可以混合为不同版本编写的代码。"

#: src/cargo/rust-ecosystem.md:44
msgid ""
"  * Mention that it is quite rare to ever use the compiler directly not through `cargo` (most "
"users never do)."
msgstr "  * 提到不通过 `cargo` 而直接使用编译器的情况相当罕见（大多数用户从未这样做）。"

#: src/cargo/rust-ecosystem.md:46
msgid ""
"  * It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  "
"It is capable of many advanced features including but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as [cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"  * 也许值得一提的是，Cargo 本身是一个极其强大和全面的工具。 它能够实现许多高级功能，包括但不限"
"于：\n"
"      * 项目/包结构\n"
"      * [工作区]\n"
"      * 开发依赖和运行时依赖的管理/缓存\n"
"      * [构建脚本]\n"
"      * [全局安装]\n"
"      * 它也可以用子命令插件进行扩展（如[cargo clippy]）\n"
"  * 从 [官方 Cargo 书籍] 中阅读更多内容"

#: src/cargo/rust-ecosystem.md:55
msgid "[editions]: https://doc.rust-lang.org/edition-guide/"
msgstr "[版本]: https://doc.rust-lang.org/edition-guide/"

#: src/cargo/rust-ecosystem.md:57
msgid "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"
msgstr "[工作空间]: https://doc.rust-lang.org/cargo/reference/workspaces.html"

#: src/cargo/rust-ecosystem.md:59
msgid "[build scripting]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"
msgstr "[构建脚本]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"

#: src/cargo/rust-ecosystem.md:61
msgid "[global installation]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"
msgstr "[全局安装]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"

#: src/cargo/rust-ecosystem.md:63
msgid "[cargo clippy]: https://github.com/rust-lang/rust-clippy"
msgstr ""

#: src/cargo/rust-ecosystem.md:65
msgid "[official Cargo Book]: https://doc.rust-lang.org/cargo/"
msgstr "[官方 Cargo 书籍]: https://doc.rust-lang.org/cargo/"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# 本培训中的代码样例"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples\n"
"which can be executed through your browser. This makes the setup much easier and\n"
"ensures a consistent experience for everyone."
msgstr ""
"在这次培训中，我们将主要通过可以通过浏览器执行的例子来探索 Rust 语言。这使得设置更加容易，并确保每"
"个人都有一致的体验。"

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do the\n"
"exercises. On the last day, we will do a larger exercise which shows you how to\n"
"work with dependencies and for that you need Cargo."
msgstr ""
"我们仍然鼓励你安装 Cargo：这将使你更容易做练习。在最后一天，我们将做一个更大的练习，告诉你如何处理"
"依赖关系，为此你需要 Cargo。"

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "本课程中的代码块是完全交互式的："

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""

#: src/cargo/code-samples.md:19
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the\n"
"text box."
msgstr "你可以使用 <kbd>Ctrl + Enter</kbd> 在焦点在文本框中时执行代码。"

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr "大多数代码样本是可编辑的，如上图所示。少数代码样本由于各种原因不能被编辑："

#: src/cargo/code-samples.md:27
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests."
msgstr "* 嵌入的游乐场不能执行单元测试。复制粘贴代码并在真正的 Playground 中打开它，以演示单元测试。"

#: src/cargo/code-samples.md:30
msgid ""
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr ""
"* 嵌入的操场在你离开页面的那一刻会失去它们的状态! 这就是学生应该使用本地 Rust 安装或通过 "
"Playground 解决练习的原因。"

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# 使用 cargo 在本地运行代码"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr ""
"如果你想在自己的系统上试验这些代码，那么你需要首先安装 Rust。按照 [Rust书中的说明][1] 来做。这应该"
"会给你一个可以工作的 `rustc` 和 `cargo`。在写这篇文章的时候，最新的稳定版 Rust 有这些版本号："

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:15
msgid ""
"With this is in place, then follow these steps to build a Rust binary from one\n"
"of the examples in this training:"
msgstr "有了这些，然后按照这些步骤，从本培训中的一个例子中建立一个 Rust 二进制："

#: src/cargo/running-locally.md:18
msgid "1. Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "1. 点击你想复制的例子上的 \"复制到剪贴板\" 按钮。"

#: src/cargo/running-locally.md:20
msgid "2. Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr "2. 使用 `cargo new exercise` 为你的代码创建一个新的 `exercise/` 目录:"

#: src/cargo/running-locally.md:22
msgid ""
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:27
msgid "3. Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr "3. 导航到 `exercise/` 并使用 `cargo run` 来构建和运行你的二进制文件:"

#: src/cargo/running-locally.md:29
msgid ""
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:38
msgid ""
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"4. 用你自己的代码替换 `src/main.rs` 中的锅炉模板代码。例如，使用上一页的例子，使 `src/main.rs` 看起"
"来像"

#: src/cargo/running-locally.md:41
msgid ""
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:47
msgid "5. Use `cargo run` to build and run your updated binary:"
msgstr "5. 使用 `cargo run` 来构建和运行你的更新二进制："

#: src/cargo/running-locally.md:49
msgid ""
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:57
msgid ""
"6. Use `cargo check` to quickly check your project for errors, use `cargo build`\n"
"   to compile it without running it. You will find the output in `target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an optimized\n"
"   release build in `target/release/`."
msgstr ""
"6. 使用 `cargo check` 来快速检查你的项目是否有错误，使用 `cargo build` 来编译它而不运行它。你可以"
"在 `target/debug/` 中找到正常调试构建的输出。使用 `cargo build --release` 在 `target/release/` 中产"
"生一个优化的发布版本。"

#: src/cargo/running-locally.md:62
msgid ""
"7. You can add dependencies for your project by editing `Cargo.toml`. When you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr ""
"7. 你可以通过编辑 `Cargo.toml` 为你的项目添加依赖性。当你运行 `cargo` 命令时，它将自动为你下载和编"
"译缺失的依赖项。"

#: src/cargo/running-locally.md:66
msgid "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"
msgstr ""

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr ""
"尽量鼓励学员们安装 Cargo 并使用本地编辑器。这将使他们的生活更轻松，因为他们将有一个正常的开发环境。"

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# 欢迎来到第 1 天"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr "这是综合 Rust 的第一天。今天我们将覆盖很多领域："

#: src/welcome-day-1.md:6
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods."
msgstr "* 基本的 Rust 语法：变量、标量和复合类型、枚举、结构、引用、函数和方法。"

#: src/welcome-day-1.md:9
msgid ""
"* Memory management: stack vs heap, manual memory management, scope-based memory\n"
"  management, and garbage collection."
msgstr "* 内存管理：栈与堆，手动内存管理，基于范围的内存管理和垃圾回收。"

#: src/welcome-day-1.md:12
msgid "* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr "* 所有权：移动语义、复制和克隆、借用和生存期。"

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "请提醒学生："

#: src/welcome-day-1.md:18
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, i.e.,\n"
"    keep the related to how Rust does things vs some other language. It can be\n"
"    hard to find the right balance, but err on the side of allowing discussions\n"
"    since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we talk about things ahead of the slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* 他们应该在得到问题时提出，不要把问题留到最后。\n"
"* 课堂是要互动的，非常鼓励讨论\n"
"  * 作为讲师，你应该尽量保持讨论的相关性，也就是说，保持与 Rust 如何做事情和其他语言相关。要找到正"
"确的平衡点是很难的，但要注意允许讨论，因为讨论比单向交流更能吸引人。\n"
"* 问题可能意味着我们会在幻灯片之前谈论一些事情。\n"
"  * 这是很正常的。重复是学习的一个重要部分。请记住，幻灯片只是一种支持，你可以自由地跳过它们。"

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to speak\n"
"about the famous borrow checker. The way Rust handles memory is a major feature\n"
"and we should show students this right away."
msgstr ""
"第 1 天的想法是展示 _足够多_ 的 Rust，以便能够讲到著名的借用检查器。Rust 处理内存的方式是一个重要的"
"特征，我们应该立即向学生展示这一点。"

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"如果你在教室里教这个，这是一个很好的地方，可以复习一下时间表。我们建议将这一天分成两部分（按照幻灯"
"片的内容）。："

#: src/welcome-day-1.md:36
msgid ""
"* Morning: 9:00 to 12:00,\n"
"* Afternoon: 13:00 to 16:00."
msgstr ""
"* 上午：9：00 至 12：00，\n"
"* 下午：13：00 至 16：00。"

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include breaks,\n"
"we recommend a break every hour!"
msgstr "您当然可以根据需要进行调整。请确保包括休息时间，我们建议每小时休息一次！"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# 什么是 Rust？"

#: src/welcome-day-1/what-is-rust.md:3
msgid "Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr "Rust 是一种新的编程语言，[在 2015 年发布了 1.0][1]："

#: src/welcome-day-1/what-is-rust.md:5
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* Rust 是一种静态编译语言，其角色与 C++ 类似\n"
"  * `rustc` 使用 LLVM 作为其后端。\n"
"* Rust 支持许多 [平台和体系结构](https://doc.rust-lang.org/nightly/rustc/platform-support.html)：\n"
"  * x86， ARM， WebAssembly， ...\n"
"  * Linux， Mac， Windows， ...\n"
"* Rust 用于各种设备：\n"
"  * 固件和引导加载程序，\n"
"  * 智能显示器，\n"
"  * 手机\n"
"  * 桌面\n"
"  * 服务器。"

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "Rust 适合与 C++ 相同的区域："

#: src/welcome-day-1/what-is-rust.md:23
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* 灵活性高。\n"
"* 高水平的控制。\n"
"* 可以缩小到非常受限的设备，如手机。\n"
"* 没有运行时或垃圾回收。\n"
"* 注重可靠性和安全性，而不牺牲性能。"

#: src/welcome-day-1/what-is-rust.md:31
msgid "[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html"
msgstr ""

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# 你好世界！"

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr "让我们跳入最简单的 Rust 程序，一个经典的 Hello World 程序："

#: src/hello-world.md:6
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello 🌍!\");\n"
"}\n"
"```"
msgstr ""

#: src/hello-world.md:12
msgid "What you see:"
msgstr "你看到的："

#: src/hello-world.md:14
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* 函数以 `fn` 引入。\n"
"* 块由大括号分隔，如 C 和 C++。\n"
"* `main` 功能是程序的入口点。\n"
"* Rust 有卫生宏，`println!` 就是一个例子。\n"
"* Rust 字符串采用 UTF-8 编码，可以包含任何 Unicode 字符。"

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will see\n"
"a ton of it over the next four days so we start small with something familiar."
msgstr "这张幻灯片试图让学生熟悉 Rust 代码。在接下来的 4 天里他们会看到，我们从熟悉的东西开始。"

#: src/hello-world.md:27
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary."
msgstr ""
"* Rust 非常像 C/C++/Java 传统中的其他语言。它是强制性的（而不是功能性的），除非绝对必要，否则它不会"
"试图重新发明东西。"

#: src/hello-world.md:31
msgid "* Rust is modern with full support for things like Unicode."
msgstr "* Rust 是现代的，完全支持 Unicode 之类的东西。"

#: src/hello-world.md:33
msgid ""
"* Rust uses macros for situations where you want to have a variable number of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr "* Rust 在您希望拥有可变数量的参数（没有函数 [重载](basic-syntax/functions-interlude.md))。"

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# 小例子"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "下面是 Rust 中的一个小示例程序："

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop will\n"
"always end, but this is not yet proved. Edit the code and play with different\n"
"inputs."
msgstr ""
"这段代码实现了科拉茨（ Collatz）猜想：人们认为循环总会结束，但这一点还没有得到证明。编辑代码，玩玩"
"不同的输入。"

#: src/hello-world/small-example.md:29
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer overflow."
msgstr ""
"* 解释一下所有的变量都是静态类型的。尝试删除 `i32` 以触发类型推理。试着用 `i8` 代替，触发运行时整数"
"溢出。"

#: src/hello-world/small-example.md:32
msgid "* Change `let mut x` to `let x`, discuss the compiler error."
msgstr "* 将 `let mut x` 改为 `let x`，讨论编译器错误。"

#: src/hello-world/small-example.md:34
msgid ""
"* Show how `print!` gives a compilation error if the arguments don't match the\n"
"  format string."
msgstr "* 显示 `print!` 如何在参数不符合格式字符串的情况下给出一个编译错误。"

#: src/hello-world/small-example.md:37
msgid ""
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable."
msgstr "* 显示如果你想打印一个比单个变量更复杂的表达式，你需要使用 `{}` 作为占位符。"

#: src/hello-world/small-example.md:40
msgid ""
"* Show the students the standard library, show them how to search for `std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that the\n"
"  students become familiar with searching in the standard library."
msgstr ""
"* 向学生展示标准库，告诉他们如何搜索 `std::fmt`，其中有格式化小语言的规则。让学生熟悉在标准库中的搜"
"索，这一点很重要。"

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# 为什么 Rust？"

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "Rust 的一些独特卖点："

#: src/why-rust.md:5
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* 编译时内存安全。\n"
"* 缺少未定义的运行时行为。\n"
"* 现代语言功能。"

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr "一定要问全班同学他们对哪些语言有经验。根据答案，你可以强调 Rust 的不同特点："

#: src/why-rust.md:14
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you don't\n"
"  have the memory unsafety issues. In addition, you get a modern language with\n"
"  constructs like pattern matching and built-in dependency management."
msgstr ""
"* 有 C 或 C++ 的经验。Rust 通过借用检查器消除了一大类 _运行时_ 错误。你可以得到像 C 和 C++ 那样的性"
"能，但你没有内存不安全的问题。此外，你还会得到一种现代语言，其中有模式匹配和内置的依赖管理等结构。"

#: src/why-rust.md:19
msgid ""
"* Experience with Java, Go, Python, JavaScript...: You get the same memory safety\n"
"  as in those languages, plus a similar high-level language feeling. In addition\n"
"  you get fast and predictable performance like C and C++ (no garbage collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr ""
"* 拥有 Java、Go、Python、JavaScript......的经验：你可以得到与这些语言相同的内存安全，外加类似的高级"
"语言感觉。此外，你还可以得到像 C 和 C++ 那样的快速和可预测的性能（没有垃圾收集器），以及对低级硬件"
"的访问（如果你需要）。"

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# 编译时保证"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "编译时的静态内存管理："

#: src/why-rust/compile-time.md:5
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* 没有未初始化的变量。\n"
"* 没有内存泄漏(_大部分_，请参阅注释)。\n"
"* 没有双重释放。\n"
"* 没有使用后的释放。\n"
"* 没有 `NULL` 指针。\n"
"* 没有忘记锁定的互斥锁。\n"
"* 没有线程间的数据竞争。\n"
"* 没有迭代器失效。"

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr "在（安全）Rust中，有可能产生内存泄漏。一些例子是："

#: src/why-rust/compile-time.md:19
msgid ""
"* You can for use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* 你可以使用 [`Box::leak`] 来泄露一个指针。这可以用来获取运行时初始化的和运行时大小的静态变量。\n"
"* 你可以使用 [`std::mem::forget`] 来使编译器 \"忘记\" 一个值（意味着永远不会运行析构器）。\n"
"* 你也可以用 `Rc` 或 `Arc` 意外地创建一个 [引用循环]。\n"
"* 事实上，有些人会认为无限填充一个集合是内存泄漏，而 Rust 并不保护这些。"

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr "在本课程中，\"没有内存泄漏\" 应该被理解为 \"几乎没有\" *意外的内存泄漏\"。"

#: src/why-rust/compile-time.md:31
msgid ""
"[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[reference cycle]: https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"
msgstr ""

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# 运行时保证"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "运行时没有未定义的行为："

#: src/why-rust/runtime.md:5
msgid ""
"* Array access is bounds checked.\n"
"* Integer overflow is defined."
msgstr ""
"* 数组访问是有边界检查。\n"
"* 定义了整数溢出。"

#: src/why-rust/runtime.md:12
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`)."
msgstr ""
"* 整数溢出是通过一个编译时标志来定义的。选项是恐慌（程序的控制性崩溃）或包裹式语义。默认情况下，你"
"在调试模式（`cargo build`）下得到恐慌，在发布模式（`cargo build --release`）下得到包裹式。"

#: src/why-rust/runtime.md:17
msgid ""
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr ""
"* 界限检查不能用编译器标志来禁用。它也不能直接用 `unsafe` 关键字来禁用。然而，`unsafe` 允许你调用诸"
"如 `slice::get_unchecked` 等函数，这些函数不做边界检查。"

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# 现代功能"

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr "Rust 是在过去 40 年中获得的所有经验基础上建立的。"

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## 语言功能"

#: src/why-rust/modern.md:7
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* 枚举和模式匹配。\n"
"* 泛型。\n"
"* 无开销的 FFI。\n"
"* 零成本的抽象。"

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## 工具"

#: src/why-rust/modern.md:14
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* 伟大的编译器错误。\n"
"* 内置的依赖性管理器。\n"
"* 内置的测试支持。\n"
"* 优秀的语言服务器协议支持。"

#: src/why-rust/modern.md:23
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to 'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct."
msgstr ""
"* 零成本抽象，类似于 C++，意味着你不需要用内存或 CPU 来 \"支付\" 高级编程结构。例如，使用 `for` 编"
"写一个循环，其结果与使用 `.iter().fold()` 结构的低级指令大致相同。"

#: src/why-rust/modern.md:28
msgid ""
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`."
msgstr ""
"* 可能值得一提的是，Rust 枚举是 \"代数数据类型\"，也被称为 \"总和类型\"，它允许类型系统表达诸如 "
"`Option<T>` 和 `Result<T, E>`。"

#: src/why-rust/modern.md:32
msgid ""
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with _actionable_\n"
"  feedback, ready to copy-paste into your code."
msgstr ""
"* 提醒人们阅读错误 --- 许多开发人员已经习惯于忽略冗长的编译器输出。Rust 编译器明显比其他编译器更健"
"谈。它经常会给你提供可操作的反馈，可以随时复制粘贴到你的代码中。"

#: src/why-rust/modern.md:37
msgid ""
"* The Rust standard library is small compared to languages like Java, Python,\n"
"  and Go. Rust does not come with several things you might consider standard and\n"
"  essential:"
msgstr ""
"* 与 Java、Python 和 Go 等语言相比，Rust 的标准库很小。Rust 没有配备一些你可能认为是标准和必要的东"
"西："

#: src/why-rust/modern.md:41
msgid ""
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json]."
msgstr ""
"  * 一个随机数生成器，但见 [rand]。\n"
"  * 支持 SSL 或 TLS，但见 [rusttls]。\n"
"  * 支持 JSON，但见 [serde_json]。"

#: src/why-rust/modern.md:45
msgid ""
"  The reasoning behind this is that functionality in the standard library cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps there\n"
"  isn't a single \"best solution\" for some of these things."
msgstr ""
"  这背后的原因是，标准库中的功能不能消失，所以它必须非常稳定。对于上面的例子，Rust 社区仍在努力寻找"
"最佳的解决方案 --- 也许对于其中的一些事情并没有一个 \"最佳解决方案\"。"

#: src/why-rust/modern.md:50
msgid ""
"  Rust comes with a built-in package manager in the form of Cargo and this makes\n"
"  it trivial to download and compile third-party crates. A consequence of this\n"
"  is that the standard library can be smaller."
msgstr ""
"  Rust 以 Cargo 的形式提供了一个内置的包管理器，这使得下载和编译第三方程序包变得非常简单。这样做的"
"一个结果是，标准库可以更小。"

#: src/why-rust/modern.md:54
msgid ""
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"  发现好的第三方笼子可能是一个问题。像 <https://lib.rs/> 这样的网站可以帮助解决这个问题，让你比较 "
"crates 的健康指标，找到一个好的、值得信赖的 crates。 \n"
"* [rust-analyzer] 是一个受到良好支持的 LSP 实现，在主要的 IDE 和文本编辑器中使用。"

#: src/why-rust/modern.md:61
msgid ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"
msgstr ""

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# 基本语法"

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Rust 的大部分语法都是你在 C、C++ 或 Java 中熟悉的："

#: src/basic-syntax.md:5
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* ...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* 块和作用域用大括号划定。\n"
"* 行注释以 `//` 开始，块注释以 `/* ... */` 为界。\n"
"* 像 `if` 和 `while` 这样的关键词的作用是一样的。\n"
"* 变量赋值用 `=` 完成，比较用 `==` 完成。"

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# 标量类型"

#: src/basic-syntax/scalar-types.md:3
msgid ""
"|                        | Types                                      | "
"Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, "
"`123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, "
"`10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | `3.14`, `-10.0e20`, "
"`2f32`    |\n"
"| Strings                | `&str`                                     | `\"foo\"`, `r#\"\\\\"
"\"#`            |\n"
"| Unicode scalar values  | `char`                                     | `'a'`, `'α'`, "
"`'∞'`           |\n"
"| Byte strings           | `&[u8]`                                    | `b\"abc\"`, `br#\" \" "
"\"#`         |\n"
"| Booleans               | `bool`                                     | `true`, "
"`false`               |"
msgstr ""
"|                        | 类型                                        | 字面意"
"义                       |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| 有符号整数               | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, "
"`123i64` |\n"
"| 无符号整数               | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, "
"`10u16`           |\n"
"| 浮点数                  | `f32`, `f64`                               | `3.14`, `-10.0e20`, "
"`2f32`    |\n"
"| 字符串                  | `&str`                                     | `\"foo\"`, `r#\"\\\\"
"\"#`            |\n"
"| Unicode 标量值          | `char`                                     | `'a'`, `'α'`, "
"`'∞'`           |\n"
"| 字节串                  | `&[u8]`                                    | `b\"abc\"`, `br#\" \" "
"\"#`         |\n"
"| 布尔                    | `bool`                                     | `true`, "
"`false`               |"

#: src/basic-syntax/scalar-types.md:13
msgid "The types have widths as follows:"
msgstr "这些类型的宽度如下："

#: src/basic-syntax/scalar-types.md:15
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* `iN`, `uN`, 和 `fN` 是 _N_ 位宽。\n"
"* `isize` 和 `usize` 是一个指针的宽度。\n"
"* `char` 是 32 位的宽度。\n"
"* `bool` 是 8 位宽。"

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# 复合类型"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"
msgstr ""
"|        | 类型                           | 字面意义                           |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| 数组    | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| 元组    | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "数组分配和访问："

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "元组分配和访问："

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "数组："

#: src/basic-syntax/compound-types.md:34
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that `[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types."
msgstr ""
"* 数组有相同类型的元素，`T`，和长度，`N`，这是一个编译时常数。注意，数组的长度是其类型 * 部分，这意"
"味着 `[u8; 3]` 和 `[u8; 4]` 被视为两种不同的类型。"

#: src/basic-syntax/compound-types.md:38
msgid "* We can use literals to assign values to arrays."
msgstr "* 我们可以使用字面意义来给数组赋值。"

#: src/basic-syntax/compound-types.md:40
msgid ""
"* In the main function, the print statement asks for the debug implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after the\n"
"  format string."
msgstr ""
"* 在 main 函数中，打印语句要求用 `?` 格式参数来实现调试：`{}` 给出默认输出，`{:?}` 给出调试输出。我"
"们也可以使用 `{a}` 和 `{a:?}` 而不在格式字符串后面指定数值。"

#: src/basic-syntax/compound-types.md:45
msgid "* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be easier to read."
msgstr "* 添加 `#`，例如 `{a:#?}`，会调用一个 \"漂亮的打印\" 格式，这可能更容易阅读。"

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "元组："

#: src/basic-syntax/compound-types.md:49
msgid "* Like arrays, tuples have a fixed length."
msgstr "* 与数组一样，元组具有固定长度。"

#: src/basic-syntax/compound-types.md:51
msgid "* Tuples group together values of different types into a compound type."
msgstr "* 元组将不同类型的值组合成复合类型。"

#: src/basic-syntax/compound-types.md:53
msgid ""
"* Fields of a tuple can be accessed by the period and the index of the value, e.g. `t.0`, `t.1`."
msgstr "* 元组的字段可以通过句点和值的索引访问，例如 `t.0`、`t.1`。"

#: src/basic-syntax/compound-types.md:55
msgid ""
"* The empty tuple `()` is also known as the \"unit type\". It is both a type, and\n"
"  the only valid value of that type - that is to say both the type and its value\n"
"  are expressed as `()`. It is used to indicate, for example, that a function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* 空元组 `()` 也被称为 \"单位类型\"。它既是一个类型，也是该类型的唯一有效值 -- 也就是说，类型和它的"
"值都被表达为 `()`。它被用来表示，例如，一个函数或表达式没有返回值，我们将在未来的幻灯片中看到。\n"
"* 你可以把它看作是 `void`，它可以是你在其他编程语言中熟悉的。"

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# 引用"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "和 C++ 一样，Rust 也有引用："

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "一些注意事项："

#: src/basic-syntax/references.md:16
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values over their lifetime."
msgstr ""
"* 我们必须在赋值给 `ref_x` 时取消引用，类似于 C 和 C++ 的指针。\n"
"* Rust 在某些情况下会自动解除引用，特别是在调用方法时（尝试 `ref_x.count_ones()`）。\n"
"* 被声明为 `mut` 的引用可以在其生命周期内被绑定到不同的值。"

#: src/basic-syntax/references.md:21
msgid ""
"<details>\n"
"Key points:"
msgstr ""
"<details>\n"
"要点："

#: src/basic-syntax/references.md:24
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound to\n"
"  different values, while the second represents a reference to a mutable value."
msgstr ""
"* 一定要注意 `let mut ref_x: &i32` 和 `let ref_x: &mut i32` 之间的区别。前者表示一个可变的引用，可"
"以绑定到不同的值，而后者表示对一个可变值的引用。"

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# 垂直引用"

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "Rust 将静态地禁止垂直引用："

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* 一个引用被说成是 \"借用\" 它所指的值。\n"
"* Rust 正在跟踪所有引用的生命周期，以确保它们的生命周期足够长。\n"
"* 当我们谈到所有权时，我们将更多地讨论借用问题。"

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# 切片"

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "一个切片让你看到一个更大的集合："

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"
msgstr ""

#: src/basic-syntax/slices.md:10
msgid ""
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:15
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* 切片借用被切片类型的数据。\n"
"* 问题：如果你修改 `a[3]` 会怎么样？"

#: src/basic-syntax/slices.md:20
msgid ""
"* We create a slice by borrowing `a` and specifying the starting and ending indexes in brackets."
msgstr "* 我们通过借用 `a` 并在括号中指定开始和结束索引来创建一个切片。"

#: src/basic-syntax/slices.md:22
msgid ""
"* If the slice starts at index 0, Rust’s range syntax allows us to drop the starting index, "
"meaning that `&a[0..a.len()]` and `&a[..a.len()]` are identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are identical."
msgstr ""
"* 如果切片从索引 0 开始，Rust 的范围语法允许我们丢弃起始索引，这意味着 `&a[0...a.len()]` 和 `&a[..."
"a.len()]` 是相同的。\n"
"    \n"
"* 最后一个索引也是如此，所以 `&a[2...a.len()]` 和 `&a[2..]` 是相同的。"

#: src/basic-syntax/slices.md:26
msgid "* To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "* 为了轻松创建一个完整数组的切片，我们可以使用 `&a[...]`。"

#: src/basic-syntax/slices.md:28
msgid ""
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` (`&[i32]`) no longer "
"mentions the array length. This allows us to perform computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to remain 'alive' (in scope) "
"for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, but the answer is that "
"for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read the data from both `a` "
"and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* `s` 是对一个 `i32` 切片的引用。注意 `s` 的类型（`&[i32]`）不再提及数组的长度。这使得我们可以对不"
"同大小的切片进行计算。\n"
" \n"
"* 切片总是借用另一个对象。在这个例子中，`a` 必须至少在我们的切片中保持 \"活着\"（在范围内）的时"
"间。\n"
"    \n"
"* 关于修改 `a[3]` 的问题可以引发有趣的讨论，但答案是，出于内存安全的考虑，在你创建了一个切片后，你"
"不能通过 `a` 来做，但你可以安全地从 `a` 和 `s` 中读取数据。更多细节将在借用检查器部分解释。"

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String` 与 `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "现在我们可以理解 Rust 中的两种字符串类型："

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");"
msgstr ""

#: src/basic-syntax/string-slices.md:10
msgid ""
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "Rust 术语："

#: src/basic-syntax/string-slices.md:22
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str` 一个对字符串切片的不可变的引用。\n"
"* `String` 一个可变的字符串缓冲区。"

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 encoded string data \n"
"  stored in a block of memory. String literals (`”Hello”`), are stored in the program’s binary."
msgstr ""
"* `&str` 引入了一个字符串切片，它是对存储在一个内存块中的 UTF-8 编码的字符串数据的不可改变的引用。"
"字符串字元（`\"Hello\"`），存储在程序的二进制中。"

#: src/basic-syntax/string-slices.md:30
msgid ""
"* Rust’s `String` type is a wrapper around a vector of bytes. As with a `Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string literal; `String::"
"new()` \n"
"  creates a new empty string, to which string data can be added using the `push()` and "
"`push_str()` methods."
msgstr ""
"* Rust 的 `String` 类型是对字节向量的包装。就像 `Vec<T>` 一样，它是自有的。\n"
"    \n"
"* 与其他类型一样，`String::from()` 从一个字符串字面创建一个字符串；`String::new()` 创建一个新的空字"
"符串，可以使用 `push()` 和 `push_str()` 方法向其添加字符串数据。"

#: src/basic-syntax/string-slices.md:35
msgid ""
"* The `format!()` macro is a convenient way to generate an owned string from dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of `std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string "
"optimization).\n"
"    \n"
"</details>"
msgstr ""
"* `format!()` 宏是一个方便的方法，可以从动态值生成一个自有的字符串。它接受与 `println!()` 相同的格"
"式规范。\n"
"    \n"
"* 你可以通过 `&` 和可选的范围选择，从 `String` 中借用 `&str` 切片。\n"
"    \n"
"* 对于 C++ 程序员来说：把 `&str` 看作是 C++ 中的 `const char*`，但它总是指向内存中的一个有效字符"
"串。Rust `String` 大致相当于 C++ 中的 `std::string`（主要区别：它只能包含 UTF-8 编码的字节，并且永"
"远不会使用小字符串优化）。\n"
"    \n"
"</details>"

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# 函数"

#: src/basic-syntax/functions.md:3
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview "
"question:"
msgstr "著名的 [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) 面试问题的 Rust 版本："

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
"}"
msgstr ""

#: src/basic-syntax/functions.md:10
msgid ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return value\n"
"}"
msgstr ""

#: src/basic-syntax/functions.md:17
msgid ""
"fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit type `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"
msgstr ""

#: src/basic-syntax/functions.md:26
msgid ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward declarations nor headers are "
"necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some programming languages), then "
"a return type.\n"
"* The last expression in a function body (or any block) becomes the return value. Simply omit the "
"`;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The compiler will infer "
"this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `fizzbuzz_to()` contains `=n`, which causes it to "
"include the upper bound.\n"
"* The `match` expression in `fizzbuzz()` is doing a lot of work. It is expanded below to show what "
"is happening."
msgstr ""
"* 我们在 `main` 中指的是下面写的一个函数。正向声明和头文件都是不必要的。\n"
"* 声明参数后面是一个类型（与一些编程语言相反），然后是一个返回类型。\n"
"* 函数主体（或任何块）中的最后一个表达式成为返回值。只要省略表达式末尾的 `;` 即可。\n"
"* 有些函数没有返回值，而是返回 \"单位类型\"，`()`。如果省略了 `-> ()` 返回类型，编译器将推断出这一"
"点。\n"
"* `fizzbuzz_to()` 中的 `for` 循环中的范围表达式包含 `=n`，这导致它包括上限。\n"
"* `fizzbuzz()` 中的 `match` 表达式正在做大量的工作。下面对它进行了扩展，以显示正在发生的事情。"

#: src/basic-syntax/functions.md:42
msgid "  (Type annotations added for clarity, but they can be elided.)"
msgstr "  (为清晰起见，添加了类型注释，但可以省略。)"

#: src/basic-syntax/functions.md:44
msgid ""
"  ```rust,ignore\n"
"  let by_3: bool = is_divisible_by(n, 3);\n"
"  let by_5: bool = is_divisible_by(n, 5);\n"
"  let by_35: (bool, bool) = (by_3, by_5);\n"
"  match by_35 {\n"
"    // ...\n"
"  ```"
msgstr ""

#: src/basic-syntax/functions.md:52
msgid "  "
msgstr "  "

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# 方法"

#: src/basic-syntax/methods.md:3
msgid ""
"Rust has methods, they are simply functions that are associated with a particular type. The\n"
"first argument of a method is an instance of the type it is associated with:"
msgstr "Rust 有方法，它们只是与某个特定类型相关的函数。方法的第一个参数是它所关联的类型的一个实例："

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}"
msgstr ""

#: src/basic-syntax/methods.md:12
msgid ""
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }"
msgstr ""

#: src/basic-syntax/methods.md:17
msgid ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}"
msgstr ""

#: src/basic-syntax/methods.md:22
msgid ""
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:30
msgid "* We will look much more at methods in today's exercise and in tomorrow's class."
msgstr "* 我们将在今天的练习和明天的课程中更多地研究方法。"

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# 函数重载"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "不支持重载："

#: src/basic-syntax/functions-interlude.md:5
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* 每个函数都有一个单一的实现。\n"
"  * 总是需要一个固定数量的参数。\n"
"  * 总是需要一组单一的参数类型。\n"
"* 不支持默认值。\n"
"  * 所有的调用站点都有相同数量的参数。\n"
"  * 有时使用宏作为替代。"

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "但是，函数参数可以是泛型的："

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"
msgstr ""

#: src/basic-syntax/functions-interlude.md:19
msgid ""
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind of limited\n"
"  polymorphism on argument types. We will see more details in a later section."
msgstr ""
"* 当使用泛型时，标准库的 `Into<T>` 可以在参数类型上提供一种有限的多态性。我们将在后面的章节中看到更"
"多细节。"

#: src/basic-syntax/functions-interlude.md:30
msgid "</defails>"
msgstr ""

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# 第 1 天：上午的练习"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "在这些练习中，我们将探索 Rust 的两个部分:"

#: src/exercises/day-1/morning.md:5
msgid "* Implicit conversions between types."
msgstr "* 类型之间的隐式转换。"

#: src/exercises/day-1/morning.md:7
msgid "* Arrays and `for` loops."
msgstr "* 数组和 `for` 循环。"

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr "在解决练习时要考虑的几件事："

#: src/exercises/day-1/morning.md:13
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for details\n"
"  on installing Rust."
msgstr ""
"* 如果可能的话，使用本地的 Rust 安装。这样你就可以在你的编辑器中获得自动补全。关于安装 Rust 的细"
"节，请看关于 [使用 Cargo] 的页面。"

#: src/exercises/day-1/morning.md:17
msgid "* Alternatively, use the Rust Playground."
msgstr "* 或者，使用 Rust Playground。"

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose\n"
"their state if you navigate away from the page."
msgstr "这些代码片段是故意不可编辑的：如果你离开页面，内联代码片段会失去其状态。"

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/day-4/morning.md:12
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "看完练习后，你可以看看提供的 [解决方案]。"

#: src/exercises/day-1/morning.md:24 src/exercises/day-2/morning.md:13
#: src/exercises/day-3/morning.md:9 src/exercises/day-4/morning.md:14
msgid "[solutions]: solutions-morning.md"
msgstr "[解决方案]: solutions-morning.md"

#: src/exercises/day-1/morning.md:26
msgid "[Using Cargo]: ../../cargo.md"
msgstr "[使用 Cargo]: ../../cargo.md"

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# 隐式转换"

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types ([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr ""
"Rust 不会自动应用类型之间的 _隐式转换_（[与 C++ 不同][3]）。你可以在这样的一个程序中看到这一点:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:11
msgid ""
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:15
msgid ""
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single `from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted into\n"
"another type."
msgstr ""
"Rust 的整数类型都实现了 [`From<T>`][1] 和 [`Into<T>`][2] 特质，让我们在它们之间进行转换。`From<T>` "
"特质有一个 `from()` 方法，同样，`Into<T>`特质有一个 `into()` 方法。实现这些特质是一个类型如何表达它"
"可以被转换为另一个类型。"

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr ""
"标准库有一个 `From<i8> for i16` 的实现，这意味着我们可以通过调用 `i16::from(x)` 将一个 `i8` 类型的"
"变量 `x` 转换成 `i16`。或者，更简单，用 `x.into()`，因为 `From<i8> for i16` 的实现会自动创建 "
"`Into<i16> for i8` 的实现。"

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so it is\n"
"sufficient to only implement `From` to get a respective `Into` implementation automatically."
msgstr ""
"这同样适用于你自己的类型的 `From` 实现，所以只需要实现 `From` 就可以自动得到各自的 `Into` 实现。"

#: src/exercises/day-1/implicit-conversions.md:33
msgid "1. Execute the above program and look at the compiler error."
msgstr "1. 执行上述程序并查看编译器错误。"

#: src/exercises/day-1/implicit-conversions.md:35
msgid "2. Update the code above to use `into()` to do the conversion."
msgstr "2. 更新上面的代码，使用 `into()` 来做转换。"

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented for\n"
"   the pairs you check."
msgstr ""
"3. 将 `x` 和 `y` 的类型改为其他东西（如 `f32`、`bool`、`i128`），看看哪些类型可以转换为其他类型。尝"
"试将小类型转换为大类型，反之亦然。检查 [标准库文档][1]，看 `From<T>` 是否为你检查的对实现。"

#: src/exercises/day-1/implicit-conversions.md:43
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"
msgstr ""

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# 数组和 `for` 循环"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "我们看到一个数组可以这样声明:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:9
msgid "You can print such an array by asking for its debug representation with `{:?}`:"
msgstr "你可以用 `{:?}` 询问其调试表示法来打印这样一个数组："

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr "Rust 允许你使用 `for` 关键字对数组和范围等事物进行迭代："

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"
msgstr ""

#: src/exercises/day-1/for-loops.md:30
msgid ""
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix and\n"
"a function `transpose` which will transpose a matrix (turn rows into columns):"
msgstr ""
"用上述方法编写一个函数 `pretty_print`，它可以漂亮地打印矩阵，还有一个函数 `transpose`，它可以对矩阵"
"进行转置（将行变成列）："

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           ⎛⎡1 2 3⎤⎞      ⎡1 4 7⎤\n"
"\"transpose\"⎜⎢4 5 6⎥⎟  \"==\"⎢2 5 8⎥\n"
"           ⎝⎣7 8 9⎦⎠      ⎣3 6 9⎦\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3 × 3 matrices."
msgstr "对这两个函数进行硬编码，对 3 × 3 矩阵进行操作。"

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr "将下面的代码复制到 <https://play.rust-lang.org/> 并实现这些功能："

#: src/exercises/day-1/for-loops.md:52 src/exercises/day-1/book-library.md:20
#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""

#: src/exercises/day-1/for-loops.md:56
msgid ""
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-1/for-loops.md:60
msgid ""
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-1/for-loops.md:64
msgid ""
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""

#: src/exercises/day-1/for-loops.md:71 src/exercises/day-1/solutions-morning.md:70
msgid ""
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);"
msgstr ""

#: src/exercises/day-1/for-loops.md:74
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## 奖金问题"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 × 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr ""
"你能不能用 `&[i32]` 切片来代替硬编码的 3 × 3 矩阵作为你的参数和返回类型？像 `&[&[i32]]` 这样的二维"
"片断的东西。为什么能或为什么不能呢？"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality\n"
"implementation."
msgstr "参见 [`ndarray` crate](https://docs.rs/ndarray/) 的生产质量实现。"

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr "解决方案和奖励部分的答案可在 [解决方案](solutions-morning.md#数组和 for 循环)部分找到。"

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "变量"

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable by\n"
"default:"
msgstr "Rust 通过静态类型化提供类型安全。变量绑定在默认情况下是不可变的："

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the types less and less as "
"the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the function like syntax of "
"`println!(\"x: {}\", x)`"
msgstr ""
"* 由于类型推理，`i32` 是可选的。随着课程的进行，我们将逐渐减少显示类型。\n"
"* 注意，由于 `println!` 是一个宏，`x` 不会被移动，即使使用 `println!(\"x: {}\", x)` 的类似于函数的"
"语法也不会被移动"

#: src/basic-syntax/type-inference.md:1
msgid "# Type Inference"
msgstr "# 类型推断"

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust 会查看变量是如何被 _使用_ 的，以确定其类型："

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"
msgstr ""

#: src/basic-syntax/type-inference.md:10
msgid ""
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"
msgstr ""

#: src/basic-syntax/type-inference.md:14
msgid ""
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;"
msgstr ""

#: src/basic-syntax/type-inference.md:18
msgid ""
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on constraints given by variable "
"declarations and usages.\n"
"    \n"
"It is very important to emphasize that variables declared like this are not of some sort of "
"dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical to the explicit "
"declaration of a type.\n"
"The compiler does the job for us and helps us to write a more concise code."
msgstr ""
"这张幻灯片演示了 Rust 编译器是如何根据变量声明和使用的约束条件来推断类型的。\n"
"    \n"
"需要强调的是，像这样声明的变量并不属于某种可以容纳任何数据的动态 \"任何类型\"。这种声明所产生的机器"
"代码与类型的明确声明是相同的。\n"
"编译器为我们做了这项工作，帮助我们写出了更简洁的代码。"

#: src/basic-syntax/type-inference.md:32
msgid ""
"The following code tells the compiler to copy into a certain generic container without the code "
"ever explicitly specifying the contained type, using `_` as a placeholder:"
msgstr ""
"下面的代码告诉编译器复制到某个通用容器中，而代码中没有明确指定包含的类型，使用 `_` 作为占位符："

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");"
msgstr ""

#: src/basic-syntax/type-inference.md:41
msgid ""
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) relies "
"on `FromIterator`, which [`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"implements."
msgstr ""

#: src/basic-syntax/static-and-const.md:1
msgid "# Static and Constant Variables"
msgstr "# 静态变量和常量变量"

#: src/basic-syntax/static-and-const.md:3
msgid "Global state is managed with static and constant variables."
msgstr "全局状态用静态和常量变量来管理。"

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr ""

#: src/basic-syntax/static-and-const.md:7
msgid "You can declare compile-time constants:"
msgstr "你可以声明编译时的常量："

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);"
msgstr ""

#: src/basic-syntax/static-and-const.md:13
msgid ""
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}"
msgstr ""

#: src/basic-syntax/static-and-const.md:21
msgid ""
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:27
msgid "According the the [Rust RFC Book][1] these are inlined upon use."
msgstr "根据 [Rust RFC Book][1]，这些东西在使用时是内联的。"

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr ""

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "你也可以声明静态变量："

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";"
msgstr ""

#: src/basic-syntax/static-and-const.md:36
msgid ""
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:41
msgid ""
"As noted in the [Rust RFC Book][1], these are not inlined upon use and have an actual associated "
"memory location.  This is useful for unsafe and embedded code, and the variable lives through the "
"entirety of the program execution."
msgstr ""
"正如 [RFC书][1] 中所指出的，这些变量在使用时不会被内联，而是有一个实际的相关内存位置。 这对于不安全"
"的和嵌入式的代码来说是很有用的，而且该变量在整个程序执行过程中一直存在。"

#: src/basic-syntax/static-and-const.md:44
msgid "We will look at mutating static data in the [chapter on Unsafe Rust](../unsafe.md)."
msgstr "我们将在 [不安全的 Rust 章节](.../unsafe.md) 中研究可变静态数据的问题。"

#: src/basic-syntax/static-and-const.md:48
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable global variable in C+"
"+.\n"
"* It isn't super common that one would need a runtime evaluated constant, but it is helpful and "
"safer than using a static."
msgstr ""
"* 提到 `const` 的行为在语义上类似于 C++ 的 `constexpr`。\n"
"* `static`，另一方面，更类似于 C++ 中的 `const` 或可变全局变量。\n"
"* 需要运行时评估常量的情况并不常见，但它比使用静态有帮助，也更安全。"

#: src/basic-syntax/static-and-const.md:54
msgid "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# 作用域和影射"

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from the\n"
"same scope:"
msgstr "你可以影射变量，包括来自外部作用域的变量和同一作用域的变量："

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:11
msgid ""
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:15
msgid ""
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:19
msgid ""
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing both variable's memory "
"locations exist at the same time. Both are available under the same name, depending where you use "
"it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory locations when "
"shadowing an immutable variable in a scope, even if the type does not change."
msgstr ""
"* 定义：影射与可变不同，因为在影射之后，两个变量的内存位置同时存在。两者都可以用同一个名字，取决于"
"你在代码中使用它的地方。\n"
"* 一个影射变量可以有不同的类型。\n"
"* 影射一开始看起来很模糊，但对于在 `.unwrap()` 之后保持数值来说是很方便的。\n"
"* 下面的代码演示了为什么编译器在作用域中影射一个不可变的变量时不能简单地重复使用内存位置，即使类型"
"没有改变。"

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# 内存管理"

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "传统上，语言分为两大类："

#: src/memory-management.md:5
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ..."
msgstr ""
"* 通过手动内存管理进行全面控制：C, C++, Pascal, ...\n"
"* 通过运行时的自动内存管理实现完全安全：Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "Rust 提供了一个新的组合："

#: src/memory-management.md:10
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr ""
"> 完全控制 *和* 安全，通过编译时间执行正确的内存\n"
"> 管理。"

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "它通过一个明确的所有权概念做到这一点。"

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "首先，让我们回顾一下内存管理的工作原理。"

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# 栈与堆"

#: src/memory-management/stack-vs-heap.md:3
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality."
msgstr ""
"* 栈：用于局部变量的连续内存区域。\n"
"  * 值有固定的大小，在编译时已知。\n"
"  * 极其快速：只需移动堆栈指针。\n"
"  * 易于管理：跟随函数调用。\n"
"  * 伟大的内存定位。"

#: src/memory-management/stack-vs-heap.md:9
msgid ""
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* 堆：函数调用之外的值的存储。\n"
"  * 值在运行时有动态的大小决定。\n"
"  * 比栈稍慢：需要一些簿记。\n"
"  * 不保证内存的位置性。"

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# 栈内存"

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically sized\n"
"data on the heap:"
msgstr "创建 `String` 时，将固定大小的数据放在栈上，动态大小的数据放在堆上："

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/memory-management/stack.md:28
msgid ""
"* Mention that a `String` is backed by a `Vec`, so it has a capacity and length and can grow if "
"mutable via reallocation on the heap."
msgstr ""
"* 提到 `String` 是由 `Vec` 支持的，所以它有一个容量和长度，如果可以通过在堆上重新分配而可变，则可以"
"增长。"

#: src/memory-management/stack.md:30
msgid ""
"* If students ask about it, you can mention that the underlying memory is heap allocated using the "
"[System Allocator] and custom allocators can be implemented using the [Allocator API]"
msgstr ""
"* 如果学生问起，你可以提到底层内存是使用 [系统分配器] 进行堆分配的，可以使用 [分配器 API] 实现自定"
"义分配器。"

#: src/memory-management/stack.md:32
msgid ""
"* We can inspect the memory layout with `unsafe` code. However, you should point out that this is "
"rightfully unsafe!"
msgstr "* 我们可以用 `unsafe` 的代码检查内存布局。然而，你应该指出，这理所当然是不安全的!"

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:51
msgid ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"
msgstr ""
"[系统分配器]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[分配器 API]: https://doc.rust-lang.org/std/alloc/index.html"

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# 手动内存管理"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "你自己分配和删除堆内存。"

#: src/memory-management/manual.md:5
msgid ""
"If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks."
msgstr "如果不小心，这可能会导致崩溃、bug、安全漏洞和内存泄漏。"

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## C 示例"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "你必须对你用 `malloc` 分配的每个指针调用 `free`："

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr "如果函数在 `malloc` 和 `free` 之间提前返回，内存就会被泄露：指针丢失，我们无法再分配内存。"

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# 基于范围的内存管理"

#: src/memory-management/scope-based.md:3
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr "构造函数和析构函数让你可以钩住一个对象的生命周期。"

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception is\n"
"raised."
msgstr ""
"通过将指针包裹在一个对象中，你可以在对象被销毁时释放内存。编译器保证这种情况发生，即使有异常发生。"

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and gives\n"
"you smart pointers."
msgstr "这通常被称为 _资源获取是初始化_（RAII），并为你提供了智能指针。"

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## C++示例"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/scope-based.md:20
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* `std::unique_ptr` 对象被分配在栈中，并指向堆上分配的内存。\n"
"* 在 `say_hello` 结束时，`std::unique_ptr` 的析构器将运行。\n"
"* 该析构器释放了它所指向的 `Person` 对象。"

#: src/memory-management/scope-based.md:25
msgid "Special move constructors are used when passing ownership to a function:"
msgstr "当把所有权传递给一个函数时，会使用特殊的移动构造函数："

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "# 自动内存管理"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic memory\n"
"management:"
msgstr "替代手动和基于范围的内存管理的方法是自动内存管理："

#: src/memory-management/garbage-collection.md:6
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the programmer."
msgstr ""
"* 程序员从不明确地分配或删除内存。\n"
"* 垃圾收集器会发现未使用的内存，并为程序员去分配它。"

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Java 示例"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "在 `sayHello` 返回后，`person` 对象不会被重新分配："

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# Rust 中的内存管理"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "Rust 中的内存管理是混合的："

#: src/memory-management/rust.md:5
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you choose, can be a single "
"unique pointer, reference counted, or atomically reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even have no cost at "
"runtime like C."
msgstr ""
"* 像 Java 一样安全和正确，但没有垃圾收集器。\n"
"* 取决于你选择的抽象（或抽象的组合），可以是一个唯一的指针，引用计数，或原子引用计数。\n"
"* 像 C++ 一样基于范围，但编译器会强制要求完全遵守。\n"
"* Rust 用户可以根据情况选择合适的抽象，有些甚至像 C 一样在运行时没有成本。"

#: src/memory-management/rust.md:10
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "它通过明确地模拟 _所有权_ 来实现这一目标。"

#: src/memory-management/rust.md:14
msgid ""
"* If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper "
"types such as [Box], [Vec], [Rc], or [Arc]. These encapsulate ownership and memory allocation via "
"various means, and prevent the potential errors in C."
msgstr ""
"* 如果这时被问及如何处理，你可以提到在 Rust 中，这通常是由 RAII 包装类型处理的，如 [Box]、[Vec]、"
"[Rc] 或 [Arc]。这些通过各种方式封装了所有权和内存分配，并防止了 C 语言中的潜在错误。"

#: src/memory-management/rust.md:16
msgid "* You may be asked about destructors here, the [Drop] trait is the Rust equivalent."
msgstr "* 你可能会被问到这里的析构器，[Drop] 特性是 Rust 的等同物。"

#: src/memory-management/rust.md:20
msgid ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# 比较"

#: src/memory-management/comparison.md:3
msgid "Here is a rough comparison of the memory management techniques."
msgstr "下面是对内存管理技术的粗略比较。"

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## 不同内存管理技术的优点"

#: src/memory-management/comparison.md:7
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* 像 C 一样手动。\n"
"  * 没有运行时的开销。\n"
"* 像 Java 一样自动。\n"
"  * 完全自动。\n"
"  * 安全和正确。\n"
"* 像 C++ 一样基于范围。\n"
"  * 部分自动。\n"
"  * 没有运行时开销。\n"
"* 基于编译器的范围，如 Rust。\n"
"  * 由编译器强制执行。\n"
"  * 没有运行时的开销。\n"
"  * 安全和正确。"

#: src/memory-management/comparison.md:20
msgid "## Cons of Different Memory Management Techniques"
msgstr "## 不同内存管理技术的缺点"

#: src/memory-management/comparison.md:22
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* 像 C 一样手动。\n"
"  * 使用后的自由。\n"
"  * 双重释放。\n"
"  * 内存泄漏。\n"
"* 像 Java 一样自动。\n"
"  * 垃圾收集暂停。\n"
"  * 解构器延迟。\n"
"* 像 C++ 一样基于范围。\n"
"  * 复杂的，由程序员选择的。\n"
"  * 潜在的 \"使用后\"（use-after-free）。\n"
"* 像 Rust 一样由编译器强制执行并基于范围。\n"
"  * 一些前期的复杂性。\n"
"  * 可以拒绝有效的程序。"

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# 所有权"

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error to\n"
"use a variable outside its scope:"
msgstr "所有的变量绑定都有一个有效的 _scope_，在其作用域之外使用一个变量是一个错误："

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);"
msgstr ""

#: src/ownership.md:9
msgid ""
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""

#: src/ownership.md:18
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* 在作用域的末尾，变量被 _dropped_，数据被释放。\n"
"* 一个析构器可以在这里运行以释放资源。\n"
"* 我们说，这个变量 _owns_ 这个值。"

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# 移动语义"

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer ownership between variables:"
msgstr "转让将在变量之间转移所有权："

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/move-semantics.md:14
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* `s1` 的转让到 `s2` 的所有权转移。\n"
"* 数据被从 `s1` 中 _移动_，`s1` 不再被访问。\n"
"* 当 `s1` 超出范围时，什么也不会发生：它没有所有权。\n"
"* 当 `s2` 超出范围时，字符串数据被释放。\n"
"* 总是 _正好_ 有一个拥有数值的变量绑定。"

#: src/ownership/move-semantics.md:22
msgid ""
"* Mention that this is the opposite of the defaults in C++, which copies by value unless you use "
"`std::move` (and the move constructor is defined!)."
msgstr ""
"* 提到这与 C++ 中的默认值相反，除非你使用 `std::move`，否则它是按值复制的（而且 move 构造函数已定"
"义！）。"

#: src/ownership/move-semantics.md:24
msgid "* In Rust, you clones are explicit (by using `clone`)."
msgstr "* 在 Rust 中，你的克隆是显性的（通过使用 `clone`）。"

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# 在 Rust 中移动字符串"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* `s1` 的堆数据被重新用于 `s2`。\n"
"* 当 `s1` 超出范围时，什么也不会发生（它已经被移出）。"

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "在移动到 `s2` 之前："

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "移动到 `s2` 之后："

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# 现代 C++ 中的重释放"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "现代 C++ 以不同的方式来解决这个问题："

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* `s1` 的堆数据被复制，`s2` 得到它自己的独立副本。\n"
"* 当 `s1` 和 `s2` 超出范围时，它们各自释放自己的内存。"

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "复制分配之前："

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "复制分配之后："

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:1
msgid "# Moves in Function Calls"
msgstr "# 函数调用中的移动"

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr "当你把一个值传递给一个函数时，这个值被分配给了函数参数。这就转移了所有权："

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}"
msgstr ""

#: src/ownership/moves-function-calls.md:11
msgid ""
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:20
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. Afterwards, `name` "
"cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the `say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) and if `say_hello` "
"accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call (`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making move semantics the "
"default, and by forcing programmers to make clones explicit."
msgstr ""
"* 在第一次调用 `say_hello` 时，`main` 放弃了对 `name` 的所有权。此后，`name` 不能再在 `main` 中使"
"用。\n"
"* 为 `name` 分配的堆内存将在 `say_hello` 函数结束时被释放。\n"
"* `main` 可以保留所有权，如果它把 `name` 作为一个引用（`&name`），并且 `say_hello` 接受一个引用作为"
"参数。\n"
"* 或者，`main` 可以在第一次调用时传递一个 `name` 的克隆（`name.clone()`）。\n"
"* Rust 通过将移动语义作为默认值，并迫使程序员明确提出克隆，使其比 C++ 更难无意中创建副本。"

#: src/ownership/copy-clone.md:1
msgid "# Copying and Cloning"
msgstr "# 复制和克隆"

#: src/ownership/copy-clone.md:3
msgid "While move semantics are the default, certain types are copied by default:"
msgstr "虽然移动语义是默认的，但某些类型是默认复制的："

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "这些类型实现了 `Copy` 的特性。"

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr "你可以选择加入你自己的类型来使用复制语义："

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);"
msgstr ""

#: src/ownership/copy-clone.md:22
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:30
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* 赋值后，`p1` 和 `p2` 都拥有自己的数据。\n"
"* 我们也可以使用 `p1.clone()` 来明确地复制数据。"

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "复制和克隆并不是一回事："

#: src/ownership/copy-clone.md:37
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by implementing the "
"`Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* 复制指的是内存区域的比特拷贝，对任意对象不起作用。\n"
"* 复制不允许自定义逻辑（不像 C++ 中的复制构造函数）。\n"
"* 克隆是一个更通用的操作，也允许通过实现 `Clone` 特质来实现自定义行为。\n"
"* 复制不在实现 `Drop` 特质的类型上工作。"

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "在上述例子中，请尝试以下方法："

#: src/ownership/copy-clone.md:44
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because `String` is not a `Copy` "
"type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in the `println!` for  "
"`p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* 在 `struct Point` 中添加一个 `String` 字段。因为 `String` 不是 `Copy` 类型，所以不能编译。\n"
"* 从 `derive` 属性中删除 `Copy`。现在编译器错误在 `p1` 的 `println!` 中。\n"
"* 表明如果用克隆 `p1` 来代替它，它也能工作。"

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way to generate code in "
"Rust\n"
"at compile time. In this case the default implementations of `Copy` and `Clone` traits are "
"generated.\n"
"    \n"
"</details>"
msgstr ""
"如果学生问起 `derive`，只需说这是一种在编译时生成 Rust 代码的方法。在这种情况下，会生成 `Copy` 和 "
"`Clone` 特质的默认实现。\n"
"    \n"
"</details>"

#: src/ownership/borrowing.md:1
msgid "# Borrowing"
msgstr "# 借用"

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr "在调用一个函数时，你可以让一个函数 _borrow_ 值，而不是转移所有权："

#: src/ownership/borrowing.md:6 src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);"
msgstr ""

#: src/ownership/borrowing.md:10
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"
msgstr ""

#: src/ownership/borrowing.md:14
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:22
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* `add` 函数 _borrows_ 两个点并返回一个新的点。\n"
"* 调用者保留对输入的所有权。"

#: src/ownership/borrowing.md:27
msgid ""
"Notes on stack returns:\n"
"* Demonstrate that the return from `add` is cheap because the compiler can eliminate the copy "
"operation. Change the above code to print stack addresses and run it on the [Playground]. In the "
"\"DEBUG\" optimization level, the addresses should change, while the stay the same when changing "
"to the \"RELEASE\" setting:"
msgstr ""
"关于栈返回的说明。\n"
"* 证明 `add` 的返回很方便，因为编译器可以消除复制操作。改变上述代码以打印栈地址，并在 [Playground] "
"上运行它。在 \"DEBUG\" 优化级别中，地址应该改变，而在改变为 \"RELEASE\" 设置时，地址保持不变："

#: src/ownership/borrowing.md:30
msgid ""
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""

#: src/ownership/borrowing.md:34
msgid ""
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"
msgstr ""

#: src/ownership/borrowing.md:40
msgid ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification because constructors can "
"have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always "
"performs a simple and efficient `memcpy` copy."
msgstr ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* Rust 编译器可以进行返回值优化（RVO）。\n"
"* 在 C++ 中，拷贝消除必须在语言规范中定义，因为构造函数可能有副作用。在 Rust 中，这根本就不是一个问"
"题。如果 RVO 没有发生，Rust 将总是执行一个简单而有效的 `memcpy` 拷贝。"

#: src/ownership/borrowing.md:53
msgid "[Playground]: https://play.rust-lang.org/"
msgstr ""

#: src/ownership/shared-unique-borrows.md:1
msgid "# Shared and Unique Borrows"
msgstr "# 共享和唯一借用"

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "Rust 对借用值的方式施加了约束："

#: src/ownership/shared-unique-borrows.md:5
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* 你可以在任何时候有一个或多个 `&T` 值，_or_。\n"
"* 你可以正好有一个 `&mut T` 值。"

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"
msgstr ""

#: src/ownership/shared-unique-borrows.md:13
msgid ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"
msgstr ""

#: src/ownership/shared-unique-borrows.md:18 src/std/rc.md:13
msgid ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"* The above code does not compile because `a` is borrowed as mutable (through `c`) and as "
"immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` to make the code "
"compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before the new mutable "
"borrow of `a` through `c`. This is a feature of the borrow checker called \"non-lexical "
"lifetimes\"."
msgstr ""
"* 上面的代码不能编译，因为 `a` 同时被借为可变的（通过 `c`）和不可变的（通过 `b`）。\n"
"* 将 `b` 的 `println!` 语句移到引入 `c` 的作用域之前，使代码可以编译。\n"
"* 在这一改变之后，编译器意识到 `b` 只在 `a` 通过 `c` 的新可变借用之前使用。这是借用检查器的一个特"
"点，叫做 \"非词汇性的生命周期\"。"

#: src/ownership/lifetimes.md:1
msgid "# Lifetimes"
msgstr "# 生命周期"

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "借用的值具有 _生命周期_："

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that there is\n"
"    a valid solution."
msgstr ""
"* 生命周期可以被省略：`add(p1: &Point, p2: &Point) -> Point`.\n"
"* 生命周期也可以是明确的：`&'a Point`, `&'document str`.\n"
"* 把 `&'a Point` 读作 \"一个借用的 `Point`，它至少在生命周期 `a` 内有效\"。\n"
"* 生命周期总是由编译器推断出来的：你不能自己指定一个生命周期。\n"
"  * 生命周期注解会产生约束；编译器会验证是否有一个有效的解决方案。"

#: src/ownership/lifetimes-function-calls.md:1
msgid "# Lifetimes in Function Calls"
msgstr "# 函数调用中的生命周期"

#: src/ownership/lifetimes-function-calls.md:3
msgid "In addition to borrowing its arguments, a function can return a borrowed value:"
msgstr "除了借用其参数外，一个函数还可以返回一个借用的值："

#: src/ownership/lifetimes-function-calls.md:9
msgid ""
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:13
msgid ""
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:21
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a` 是一个通用参数，它是由编译器推断出来的。\n"
"* 生命周期以 `'` 开始，`'a` 是一个典型的默认名称。\n"
"* 把 `&'a Point` 读作 \"一个借用的 `Point`，它至少在生命周期 `a` 中有效\"。\n"
"  * 当参数处于不同的作用域时，_at least_ 部分很重要。"

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), resulting in the following "
"code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"* 将 `p2` 和 `p3` 的声明移到一个新的作用域中（`{ ... }`），从而得到以下代码：\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"

#: src/ownership/lifetimes-function-calls.md:36
msgid ""
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:40
msgid ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  请注意，由于 `p3` 比 `p2` 长，所以不能编译。"

#: src/ownership/lifetimes-function-calls.md:52
msgid ""
"* Reset the workspace and change the function signature to `fn left_most<'a, 'b>(p1: &'a Point, "
"p2: &'a Point) -> &'b Point`. This will not compile because the relationship between the lifetimes "
"`'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global variable).\n"
"  * Which one is it? The compiler needs to to know, so at the call site the returned reference is "
"not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""
"* 重置工作区，将函数签名改为 `fn left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`。这"
"将不会被编译，因为生命期 `'a` 和 `'b` 之间的关系不清楚。\n"
"* 另一种解释方式。\n"
"  * 两个值的引用被一个函数借用，该函数返回另一个引用。\n"
"  * 它一定是来自这两个输入中的一个（或来自一个全局变量）。\n"
"  * 是哪一个呢？编译器需要知道，所以在调用现场，返回的引用不会比引用来自的变量使用的时间更长。"

#: src/ownership/lifetimes-data-structures.md:1
msgid "# Lifetimes in Data Structures"
msgstr "# 数据结构中的生命周期"

#: src/ownership/lifetimes-data-structures.md:3
msgid "If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr "如果一个数据类型存储了借用的数据，它必须被注解为一个生命周期："

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:9
msgid ""
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:13
msgid ""
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data underlying the "
"contained `&str` lives at least as long as any instance of `Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), the borrow checker "
"throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This can be useful for "
"creating lightweight views, but it generally makes them somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one lifetime annotation. This "
"can be necessary if there is a need to describe lifetime relationships between the references "
"themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases.\n"
"</details>"
msgstr ""
"* 在上面的例子中，`Highlight` 的注解强制要求所包含的 `&str` 的基础数据的寿命至少与使用该数据的任何 "
"`Highlight` 实例的寿命一样长。\n"
"* 如果 `text` 在 `fox`（或 `dog`）的寿命结束前被消耗，借贷检查器会抛出一个错误。\n"
"* 带有借用数据的类型迫使用户保留原始数据。这对于创建轻量级的视图是很有用的，但通常会使它们更难使"
"用。\n"
"* 如果可能的话，让数据结构直接拥有它们的数据。\n"
"* 一些内部有多个引用的结构可以有一个以上的生命周期注释。如果需要描述引用本身的生命周期关系，以及结"
"构本身的生命周期，这可能是必要的。这些是非常高级的用例。\n"
"</details>"

#: src/exercises/day-1/afternoon.md:1
msgid "# Day 1: Afternoon Exercises"
msgstr "# 第 1 天：下午练习"

#: src/exercises/day-1/afternoon.md:3
msgid "We will look at two things:"
msgstr "我们将关注两件事："

#: src/exercises/day-1/afternoon.md:5
msgid "* A small book library,"
msgstr "* 一个小书库,"

#: src/exercises/day-1/afternoon.md:7
msgid "* Iterators and ownership (hard)."
msgstr "* 迭代器和所有权（难）。"

#: src/exercises/day-1/afternoon.md:13 src/exercises/day-2/afternoon.md:9
msgid "[solutions]: solutions-afternoon.md"
msgstr "[解决方案]: solutions-afternoon.md"

#: src/exercises/day-1/book-library.md:1
msgid "# Designing a Library"
msgstr "# 设计库"

#: src/exercises/day-1/book-library.md:3
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For now,\n"
"you just need to know part of its API:"
msgstr "明天我们将学习更多关于结构和 `Vec<T>` 类型的知识。现在，你只需要知道它的部分 API："

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:17
msgid ""
"Use this to create a library application. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"用这个来创建一个库应用程序。将下面的代码复制到 <https://play.rust-lang.org/>，并更新类型以使其编"
"译："

#: src/exercises/day-1/book-library.md:24
msgid ""
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:28 src/exercises/day-1/solutions-afternoon.md:27
msgid ""
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:33 src/exercises/day-1/solutions-afternoon.md:32
msgid ""
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:43
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:50
msgid ""
"impl Library {\n"
"    fn new() -> Library {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-1/book-library.md:55
msgid ""
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:59
msgid ""
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:63
msgid ""
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:67
msgid ""
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:71
msgid ""
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:76
msgid ""
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""

#: src/exercises/day-1/book-library.md:83
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:99
msgid ""
"<details>\n"
"    \n"
"[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"<details>\n"
"    \n"
"[解决方案](solutions-afternoon.md#设计一个库)"

#: src/exercises/day-1/iterators-and-ownership.md:1
msgid "# Iterators and Ownership"
msgstr "# 迭代器和所有权"

#: src/exercises/day-1/iterators-and-ownership.md:3
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr ""
"Rust 的所有权模型影响了许多 API。这方面的一个例子是 [`Iterator`](https://doc.rust-lang.org/std/"
"iter/trait.Iterator.html) 和 [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait."
"IntoIterator.html) 特质。"

#: src/exercises/day-1/iterators-and-ownership.md:8
msgid "## `Iterator`"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:10
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` back:"
msgstr ""
"特质就像接口：它们描述一个类型的行为（方法）。`Iterator` 特质简单地说，你可以调用 `next`，直到你得"
"到 `None` 的返回："

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:20
msgid "You use this trait like this:"
msgstr "你这样使用这个特质："

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:27
msgid ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:34
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "迭代器返回的类型是什么？在此检验你的答案："

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:41
#: src/exercises/day-1/iterators-and-ownership.md:78
msgid ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:46
msgid "Why is this type used?"
msgstr "为什么使用这种类型？"

#: src/exercises/day-1/iterators-and-ownership.md:48
msgid "## `IntoIterator`"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:50
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the iterator:"
msgstr ""
"`Iterator` 特质告诉你，一旦你创建了一个迭代器，如何进行 _iterate_。相关的特质 `IntoIterator`："

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:58
msgid ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:62
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr "这里的语法意味着每个 `IntoIterator` 的实现都必须声明两种类型。"

#: src/exercises/day-1/iterators-and-ownership.md:65
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: 我们迭代的类型，如 `i8`。\n"
"* `IntoIter`: 由 `into_iter` 方法返回的 `Iterator` 类型。"

#: src/exercises/day-1/iterators-and-ownership.md:68
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"注意 `IntoIter` 和 `Item` 是有联系的：迭代器必须有相同的 `Item` 类型，这意味着它返回 "
"`Option<Item>`。"

#: src/exercises/day-1/iterators-and-ownership.md:71
msgid "Like before, what  is the type returned by the iterator?"
msgstr "像以前一样，迭代器返回的类型是什么？"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:83
msgid "## `for` Loops"
msgstr "## `for` 循环"

#: src/exercises/day-1/iterators-and-ownership.md:85
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr ""
"现在我们知道了 `Iterator` 和 `IntoIterator`，我们可以建立 `for` 循环。它们在表达式上调用 "
"`into_iter()`，并对产生的迭代器进行迭代。"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:93
msgid ""
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:97
msgid ""
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:103
msgid "What is the type of `word` in each loop?"
msgstr "每个循环中的 `word` 的类型是什么？"

#: src/exercises/day-1/iterators-and-ownership.md:105
msgid ""
"Experiment with the code above and then consult the documentation for [`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"%26%27a%20Vec%3CT%2C%20A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"Vec%3CT%2C%20A%3E)\n"
"to check your answers."
msgstr ""
"实验一下上面的代码，然后查阅 [`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E) 和 [`impl IntoIterator for "
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-"
"Vec%3CT%2C%20A%3E) 的文档，检查你的答案。"

#: src/welcome-day-2.md:1
msgid "# Welcome to Day 2"
msgstr "# 欢迎来到第 2 天"

#: src/welcome-day-2.md:3
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "现在我们已经看到了相当数量的 Rust，我们将继续进行："

#: src/welcome-day-2.md:5
msgid "* Structs, enums, methods."
msgstr "* 结构体、枚举、方法。"

#: src/welcome-day-2.md:7
msgid "* Pattern matching: destructuring enums, structs, and arrays."
msgstr "* 模式匹配：对枚举、结构和数组进行解构。"

#: src/welcome-day-2.md:9
msgid ""
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and\n"
"  `continue`."
msgstr "* 控制流结构： `if`, `if let`, `while`, `while let`, `break`, 和 `continue`."

#: src/welcome-day-2.md:12
msgid ""
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`\n"
"  and `Arc`."
msgstr "* 标准库：`String`, `Option` 和 `Result`, `Vec`, `HashMap`, `Rc` 和 `Arc`."

#: src/welcome-day-2.md:15
msgid "* Modules: visibility, paths, and filesystem hierarchy."
msgstr "* 模块：可见性、路径和文件系统的层次结构。"

#: src/structs.md:1
msgid "# Structs"
msgstr "# 结构体"

#: src/structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "像 C 和 C++ 一样，Rust 也支持自定义结构体："

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""

#: src/structs.md:11
msgid ""
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""

#: src/structs.md:29
msgid ""
"<details>\n"
"Key Points: "
msgstr ""
"<details>\n"
"要点： "

#: src/structs.md:32
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following slides.\n"
"* This may be a good time to let people know there are different types of structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a trait on some type "
"but don’t have any data that you want to store in the value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the old struct without "
"having to explicitly type it all out. It must always be the last element."
msgstr ""
"* 结构的工作方式就像在 C 或 C++ 中一样。\n"
"  * 和 C++ 一样，也不像 C，不需要类型定义来定义一个类型。\n"
"  * 与 C++ 不同的是，结构之间没有继承性。\n"
"* 方法是在 `impl` 块中定义的，我们将在下面的幻灯片中看到。\n"
"* 这可能是让人们知道有不同类型的结构的一个好时机。\n"
"  * 零大小的结构 `例如，struct Foo;` 可能用于实现某种类型的特质，但没有任何数据需要存储在值本身。\n"
"  * 下一张幻灯片将介绍元组结构，在字段名不重要时使用。\n"
"* 语法 `..peter` 允许我们从旧结构中复制大部分字段，而不需要明确地将其全部打出来。它必须始终是最后一"
"个元素。"

#: src/structs/tuple-structs.md:1
msgid "# Tuple Structs"
msgstr "# 元组结构"

#: src/structs/tuple-structs.md:3
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "如果字段名不重要，你可以使用一个元组结构："

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);"
msgstr ""

#: src/structs/tuple-structs.md:8
msgid ""
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:14
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr "这通常用于单字段包装器（称为新类型）："

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"
msgstr ""

#: src/structs/tuple-structs.md:20
msgid ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}"
msgstr ""

#: src/structs/tuple-structs.md:24
msgid ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"
msgstr ""

#: src/structs/tuple-structs.md:28
msgid ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"
msgstr ""

#: src/structs/tuple-structs.md:33 src/traits/default.md:36 src/generics/trait-objects.md:86
msgid "```"
msgstr ""

#: src/structs/tuple-structs.md:37
msgid ""
"* Newtypes are a great way to encode additional information about the value in a primitive type, "
"for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer have to validate it "
"again at every use: 'PhoneNumber(String)` or `OddNumber(u32)`.\n"
"* Demonstrate how to add a `f64` value to a `Newtons` type by accessing the single field in the "
"newtype.\n"
"  *  Rust generally doesn’t like inexplicit things, like automatic unwrapping or for instance "
"using booleans as integers.\n"
"  *  Operator overloading is discussed on Day 3 (generics). \n"
"</details>"
msgstr ""
"* 新类型是一种很好的方式，可以对原始类型中的值的额外信息进行编码，比如说：\n"
"  * 这个数字是以某些单位衡量的：上面的例子中的 `Newtons`。\n"
"  * 该值在创建时通过了一些验证，所以你不再需要在每次使用时再次验证它。`PhoneNumber(String)` 或 "
"`OddNumber(u32)`.\n"
"* 演示如何通过访问新类型中的单个字段来给 `Newtons` 类型添加 `f64` 值。\n"
"  * Rust 通常不喜欢不明确的东西，比如自动解包或例如将布尔作为整数使用。\n"
"  * 操作符重载将在第 3 天（泛型）讨论。\n"
"</details>"

#: src/structs/field-shorthand.md:1
msgid "# Field Shorthand Syntax"
msgstr "# 字段速记语法"

#: src/structs/field-shorthand.md:3
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr "如果你已经有了具有正确名称的变量，那么你可以使用速记法创建结构："

#: src/structs/field-shorthand.md:6 src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""

#: src/structs/field-shorthand.md:13
msgid ""
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}"
msgstr ""

#: src/structs/field-shorthand.md:19
msgid ""
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:27
msgid ""
"The `new` function could be written using `Self` as a type, as it is interchangeable with the "
"struct type name"
msgstr "`new` 函数可以使用 `Self` 作为类型来编写，因为它可以与结构类型名称互换"

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"</details>"
msgstr ""

#: src/enums.md:1
msgid "# Enums"
msgstr "# 枚举"

#: src/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr "`enum` 关键字允许创建一个有几个不同变体的类型："

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}"
msgstr ""

#: src/enums.md:11
msgid ""
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}"
msgstr ""

#: src/enums.md:17
msgid ""
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}"
msgstr ""

#: src/enums.md:26
msgid ""
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:31
msgid ""
"<details>\n"
"    \n"
"Key Points:"
msgstr ""
"<details>\n"
"    \n"
"要点："

#: src/enums.md:35
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and `Tail`. You might note "
"the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or one with different "
"types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate structs but then they "
"wouldn’t be the same type as they would if they were all defined in an enum. \n"
"</details>"
msgstr ""
"* 枚举允许你收集一个类型下的一组值\n"
"* 本页提供了一个枚举类型 `CoinFlip`，有两个变体 `Heads` 和 `Tail`。在使用变体时，你可能会注意到命名"
"空间。\n"
"* 这可能是一个比较 `Structs` 和 `Enums` 的好时机。\n"
"  * 在这两者中，你可以有一个没有字段的简单版本（单元结构）或一个有不同类型字段的版本（变体载"
"荷）。\n"
"  * 在两者中，相关的函数都是在 `impl` 块中定义的。\n"
"  * 你甚至可以用独立的结构体来实现枚举的不同变体，但那样的话，它们的类型就不像在一个枚举中定义的那"
"样了。\n"
"</details>"

#: src/enums/variant-payloads.md:1
msgid "# Variant Payloads"
msgstr "# 变体载荷"

#: src/enums/variant-payloads.md:3
msgid ""
"You can define richer enums where the variants carry data. You can then use the\n"
"`match` statement to extract the data from each variant:"
msgstr ""
"你可以定义更丰富的枚举，其中的变体携带数据。然后你可以使用 `match` 语句从每个变体中提取数据："

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}"
msgstr ""

#: src/enums/variant-payloads.md:13
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}"
msgstr ""

#: src/enums/variant-payloads.md:22
msgid ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"
msgstr ""

#: src/enums/variant-payloads.md:27
msgid ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:35
msgid ""
"* In the above example, accessing the `char` in `KeyPress`, or `x` and `y` in `Click` only works "
"within a `match` or an `if let` statement.\n"
"* `match` and `if let` inspect a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling `std::mem::discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs where comparing field "
"values doesn't affect equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level "
"`struct Click { ... }`. The inlined version cannot implement traits, for example."
msgstr ""
"* 在上面的例子中，访问 `KeyPress` 中的 `char`，或者 `Click` 中的 `x` 和 `y` 只在 `match` 或 `if "
"let` 语句中有效。\n"
"* `match` 和 `if let` 检查 `enum` 中的隐藏判别字段。\n"
"* 可以通过调用 `std::mem::discriminant()` 来检索判别符。\n"
"  * 这很有用，例如，如果对结构实施 `PartialEq`，比较字段值不会影响平等。\n"
"* `WebEvent::Click { ... }` 与 `WebEvent::Click(Click)` 的顶层 `struct Click { ...}` 并不完全相"
"同。 例如，内联版本不能实现特质。"

#: src/enums/sizes.md:1
msgid "# Enum Sizes"
msgstr "# 枚举大小"

#: src/enums/sizes.md:3
msgid "Rust enums are packed tightly, taking constraints due to alignment into account:"
msgstr "Rust 枚举紧密包装，考虑了对齐引起的约束："

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};"
msgstr ""

#: src/enums/sizes.md:8
msgid ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:15
msgid ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"
msgstr ""

#: src/enums/sizes.md:20
msgid ""
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}"
msgstr ""

#: src/enums/sizes.md:27
msgid ""
"fn main() {\n"
"    dbg_size!(Foo);\n"
"    dbg_size!(Bar);\n"
"    dbg_size!(bool);\n"
"    dbg_size!(Option<bool>);\n"
"    dbg_size!(&i32);\n"
"    dbg_size!(Option<&i32>);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:37
msgid "* See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr "* 见 [Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)。"

#: src/enums/sizes.md:39
msgid ""
"<details>\n"
"    \n"
"Key Points: \n"
" * Internally Rust is using a field (discriminant) to keep track of the enum variant.\n"
" * `Bar` enum demonstrates that there is a way to control the discriminant value and type. If "
"`repr` is removed, the discriminant type takes 2 bytes, becuase 10001 fits 2 bytes.\n"
" * As a niche optimization an enum discriminant is merged with the pointer so that `Option<&Foo>` "
"is the same size as `&Foo`.\n"
" * `Option<bool>` is another example of tight packing.\n"
" * For [some types](https://doc.rust-lang.org/std/option/#representation), Rust guarantees that "
"`size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
" * Zero-sized types allow for efficient implementation of `HashSet` using `HashMap` with `()` as "
"the value."
msgstr ""
"<details>\n"
"    \n"
"要点：\n"
" * 在内部，Rust 使用一个字段（discriminant）来跟踪枚举的变体。\n"
" * `Bar` 枚举表明，有一种方法可以控制判别值和类型。如果 `repr` 被删除，判别类型需要 2 个字节，因为 "
"10001 适合 2 个字节。\n"
" * 作为一个小众的优化，一个枚举判别符与指针合并，这样 `Option<&Foo>` 就与 `&Foo` 的大小相同。\n"
" * `Option<bool>` 是另一个紧密包装的例子。\n"
" * 对于 [某些类型](https://doc.rust-lang.org/std/option/#representation)，Rust 保证 `size_of::"
"<T>()` 等同于 `size_of::<Option<T>>()`。\n"
" * 零大小的类型允许使用 `HashMap` 高效地实现 `HashSet`，并以 `()` 为值。"

#: src/enums/sizes.md:49
msgid ""
"Example code if you want to show how the bitwise representation *may* look like in practice.\n"
"It's important to note that the compiler provides no guarantees regarding this representation, "
"therefore this is totally unsafe."
msgstr ""
"如果你想展示比特表示法在实践中 *可能* 的样子，可以用示例代码。\n"
"需要注意的是，编译器对这种表示法没有提供任何保证，因此这完全不安全。"

#: src/enums/sizes.md:52
msgid ""
"```rust,editable\n"
"use std::mem::transmute;"
msgstr ""

#: src/enums/sizes.md:55 src/enums/sizes.md:94
msgid ""
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:61
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        println!(\"Bitwise representation of bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);"
msgstr ""

#: src/enums/sizes.md:69
msgid ""
"        println!(\"Bitwise representation of Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);"
msgstr ""

#: src/enums/sizes.md:74
msgid ""
"        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);"
msgstr ""

#: src/enums/sizes.md:80
msgid ""
"        println!(\"Bitwise representation of Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:87
msgid ""
"More complex example if you want to discuss what happens when we chain more than 256 `Option`s "
"together."
msgstr "如果你想讨论当我们把 256 个以上的 `Option` 连在一起时会发生什么，可以举一个更复杂的例子。"

#: src/enums/sizes.md:89
msgid ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]"
msgstr ""

#: src/enums/sizes.md:92
msgid "use std::mem::transmute;"
msgstr ""

#: src/enums/sizes.md:100
msgid ""
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" signs.\n"
"// Increasing the recursion limit is required to evaluate this macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:112
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"
msgstr ""

#: src/enums/sizes.md:120
msgid ""
"        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);"
msgstr ""

#: src/enums/sizes.md:124
msgid ""
"        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);"
msgstr ""

#: src/enums/sizes.md:128
msgid ""
"        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with an\n"
"`impl` block:"
msgstr "Rust 允许你将函数与你的新类型联系起来。你可以用 `impl` 块来做这个："

#: src/methods.md:13
msgid ""
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/methods.md:19
msgid ""
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:30
msgid ""
"Key Points:\n"
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), the first parameter "
"represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method receiver syntax and to help "
"keep them more organized. By using methods we can keep all the implementation code in one "
"predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name "
"could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in and can be used "
"elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used to refer to individual "
"fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from `self` by modifying the "
"code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   \n"
"</details>"
msgstr ""
"要点：\n"
"* 通过将方法与函数相比较来介绍方法可能会有帮助。\n"
"  * 方法是在一个类型（如结构体或枚举）的实例上调用的，第一个参数代表实例为 `self`。\n"
"  * 开发人员可能会选择使用方法来利用方法接收器的语法，并帮助他们保持更多的组织。通过使用方法，我们"
"可以把所有的实现代码放在一个可预测的地方。\n"
"* 指出关键字 `self` 的使用，一个方法接收器。\n"
"  * 显示它是 `self:&Self` 的缩写，也许还可以显示如何使用结构名称。\n"
"  * 解释一下 `Self` 是 `impl` 块所在类型的别名，可以在块的其他地方使用。\n"
"  * 注意 `self` 是如何像其他结构一样使用的，点符号可以用来指代各个字段。\n"
"  * 这可能是一个很好的时机，通过修改代码并尝试运行 say_hello 两次来演示 `&self` 与 `self` 的区"
"别。 \n"
"* 接下来我们将描述方法接收者之间的区别。\n"
"   \n"
"</details>"

#: src/methods/receiver.md:1
msgid "# Method Receiver"
msgstr "# 方法接收器"

#: src/methods/receiver.md:3
msgid ""
"The `&self` above indicates that the method borrows the object immutably. There\n"
"are other possible receivers for a method:"
msgstr "上面的 `&self` 表示该方法不可更改地借用了对象。一个方法还有其他可能的接收器："

#: src/methods/receiver.md:6
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. The\n"
"  method becomes the owner of the object. The object will be dropped (deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted.\n"
"* `mut self`: same as above, but while the method owns the object, it can\n"
"  mutate it too. Complete ownership does not automatically mean mutability.\n"
"* No receiver: this becomes a static method on the struct. Typically used to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: 使用一个共享的、不可改变的引用从调用者那里借来对象。该对象之后可以再次使用。\n"
"* `&mut self`: 使用一个唯一的和可变的引用从调用者那里借用对象。之后可以再次使用该对象。\n"
"* `self`: 取得对象的所有权，并将其从调用者处移开。该方法成为该对象的所有者。当方法返回时，该对象将"
"被丢弃（deallocated），除非它的所有权被明确传送。\n"
"* `mut self`：与上述相同，但是当方法拥有对象时，它也可以对其进行变异。完整的所有权并不自动意味着可"
"变性。\n"
"* 无接收器：这成为结构上的一个静态方法。通常用于创建构造函数，按惯例称为 `new`。"

#: src/methods/receiver.md:19
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr ""
"除了 `self` 的变体，还有 [特殊包装类型](https://doc.rust-lang.org/reference/special-types-and-"
"traits.html) 允许成为接收者类型，如 `Box<Self>`。"

#: src/methods/receiver.md:23
msgid ""
"<details>\n"
"  \n"
"Consider emphasizing on \"shared and immutable\" and \"unique and mutable\". These constraints "
"always come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It won't be possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) method on it.\n"
"  \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
"考虑强调 \"共享和不可变\" 以及 \"唯一和可变\"。在 Rust 中，由于借用检查器的规则，这些约束总是结合在"
"一起的，`self` 也不例外。不可能从多个地方引用一个结构，并对其调用一个变异的（`&mut self`）方法。\n"
"  \n"
"</details>"

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "# Example"
msgstr "# 示例"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}"
msgstr ""

#: src/methods/example.md:10
msgid ""
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }"
msgstr ""

#: src/methods/example.md:15
msgid ""
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access to self\n"
"        self.laps.push(lap);\n"
"    }"
msgstr ""

#: src/methods/example.md:19
msgid ""
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }"
msgstr ""

#: src/methods/example.md:26
msgid ""
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
"    }\n"
"}"
msgstr ""

#: src/methods/example.md:32
msgid ""
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:44
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the variable values and if/"
"how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` twice.\n"
"* Note, that although the method receivers are different, the non-static functions are called the "
"same way in the main body. Rust enables automatic referencing and dereferencing when calling "
"methods. Rust automatically adds in the `&`, `*`, `muts` so that that object matches the method "
"signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated over. We describe "
"vectors in more detail in the afternoon. "
msgstr ""
"<details>\n"
"    \n"
"要点：\n"
"* 这里的四个方法都使用了一个不同的方法接收器。\n"
"  * 你可以指出这如何改变函数对变量值的处理，以及是否/如何在 `main` 中再次使用。\n"
"  * 你可以展示当试图调用 `finish` 两次时出现的错误。\n"
"* 注意，虽然方法的接收者不同，但非静态函数在主体中的调用方式是一样的。Rust 在调用方法时能够自动引用"
"和取消引用。Rust 会自动加入 `&`、`*`、`muts`，以便该对象与方法签名相匹配。\n"
"* 你可能会指出，`print_laps` 使用的是一个被迭代的向量。我们在下午会更详细地描述向量。"

#: src/pattern-matching.md:1
msgid "# Pattern Matching"
msgstr "# 模式匹配"

#: src/pattern-matching.md:3
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr ""
"`match` 关键字让你将一个值与一个或多个 _patterns_ 匹配。比较是从上到下进行的，第一个匹配者获胜。"

#: src/pattern-matching.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "模式可以是简单的值，类似于 C 和 C++ 中的 `switch`："

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';"
msgstr ""

#: src/pattern-matching.md:12
msgid ""
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "`_` 模式是一个通配符模式，可以匹配任何数值。"

#: src/pattern-matching.md:23
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* You might point out how some specific characters are being used when in a pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a wildcard character with "
"a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, as the term can show "
"up in error messages.\n"
"   \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"要点：\n"
"* 你可能会指出一些特定的字符在模式中是如何被使用的\n"
"  * `|` 作为 `or` 的意思\n"
"  * `..` 可以根据需要进行扩展\n"
"  * `1..=5` 代表一个包容性的范围\n"
"  * `_` 是一个通配符\n"
"* 展示绑定的工作原理可能很有用，例如用一个变量替换通配符，或者去掉 `q` 周围的引号。\n"
"* 你可以演示在一个引用上的匹配。\n"
"* 这可能是一个提出不可反驳模式概念的好时机，因为这个词可能会出现在错误信息中。\n"
"   \n"
"<details>"

#: src/pattern-matching/destructuring-enums.md:1
msgid "# Destructuring Enums"
msgstr "# 解构枚举结构"

#: src/pattern-matching/destructuring-enums.md:3
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is how\n"
"you inspect the structure of your types. Let us start with a simple `enum` type:"
msgstr ""
"模式也可以用来将变量与你的值的一部分绑定。这就是你如何检查你的类型的结构。让我们从一个简单的 "
"`enum` 类型开始："

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:12
msgid ""
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:20
msgid ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second arm,\n"
"`msg` is bound to the error message."
msgstr ""
"在这里，我们使用了臂来对 `Result` 值进行 _解构_。在第一个臂中，`half` 被绑定到 `Ok` 变量内的值。在"
"第二个臂中，`msg` 被绑定到错误信息。"

#: src/pattern-matching/destructuring-enums.md:35
msgid ""
"Key points:\n"
"* The `if`/`else` expression is returning an enum that is later unpacked with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying the errors when running "
"the code. Point out the places where your code is now inexhaustive and how the compiler tries to "
"give you hints."
msgstr ""
"要点：\n"
"* `if`/`else` 表达式正在返回一个枚举，后来用 `match` 解包。\n"
"* 你可以尝试在枚举定义中加入第三个变体，并在运行代码时显示错误。指出你的代码现在不详尽的地方，以及"
"编译器如何试图给你提示。"

#: src/pattern-matching/destructuring-structs.md:1
msgid "# Destructuring Structs"
msgstr "# 解构结构体"

#: src/pattern-matching/destructuring-structs.md:3
msgid "You can also destructure `structs`:"
msgstr "你也可以解构 `structs`："

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:11
msgid ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"<details>"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"</details>"
msgstr ""
"* 改变 `foo` 中的字面价值，以便与其他模式相匹配。\n"
"* 为 `Foo` 添加一个新的字段，并根据需要对模式进行修改。\n"
"</details>"

#: src/pattern-matching/destructuring-arrays.md:1
msgid "# Destructuring Arrays"
msgstr "# 解构数组"

#: src/pattern-matching/destructuring-arrays.md:3
msgid "You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "您可以通过匹配数组、元组和切片的元素来解构它们："

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:20
msgid "* Destructuring of slices of unknown length also works with patterns of fixed length."
msgstr "* 对未知长度的切片进行解构，也适用于固定长度的匹配。"

#: src/pattern-matching/destructuring-arrays.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:28
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`\n"
"</details>"
msgstr ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"* 显示与尾巴匹配的模式 `[.., b]` 和 `[a@..,b]`。\n"
"</details>"

#: src/pattern-matching/match-guards.md:1
msgid "# Match Guards"
msgstr "# 匹配防护"

#: src/pattern-matching/match-guards.md:3
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr ""
"在匹配时，你可以在模式中添加一个 _guard_。这是一个任意的布尔表达式，如果该模式匹配，将被执行："

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:22
msgid ""
"Key Points:\n"
"* Match guards as a separate syntax feature are important and necessary when we wish to concisely "
"express more complex ideas than patterns alone would allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. An `if` expression "
"inside of the branch block (after `=>`) happens after the match arm is selected. Failing the `if` "
"condition inside of that block won't result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a pattern with an `|`.\n"
"</details>"
msgstr ""
"要点：\n"
"* 当我们希望简洁地表达比单独的模式更复杂的想法时，匹配防护作为一个单独的语法特征是非常重要和必要"
"的。\n"
"* 它们与匹配臂内的独立 `if` 表达式不同。分支块内的 `if` 表达式（在 `=>` 之后）发生在匹配臂被选中之"
"后。该块内的 `if` 条件失败不会导致原始 `match` 表达式的其他臂被考虑。 \n"
"* 你可以在你的 if 表达式中使用模式中定义的变量。\n"
"* 在防护中定义的条件适用于模式中带有 `|` 的每个表达式。\n"
"</details>"

#: src/exercises/day-2/morning.md:1
msgid "# Day 2: Morning Exercises"
msgstr "# 第 2 天：上午的练习"

#: src/exercises/day-2/morning.md:3
msgid "We will look at implementing methods in two contexts:"
msgstr "我们将研究在两种情况下实现方法："

#: src/exercises/day-2/morning.md:5
msgid "* Simple struct which tracks health statistics."
msgstr "* 跟踪健康统计数据的简单结构。"

#: src/exercises/day-2/morning.md:7
msgid "* Multiple structs and enums for a drawing library."
msgstr "* 绘图库的多个结构和枚举。"

#: src/exercises/day-2/health-statistics.md:1
msgid "# Health Statistics"
msgstr "# 健康统计"

#: src/exercises/day-2/health-statistics.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, you\n"
"need to keep track of users' health statistics."
msgstr "你正在努力实施一个健康监测系统。作为其中的一部分，你需要跟踪用户的健康统计数据。"

#: src/exercises/day-2/health-statistics.md:6
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a `User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr ""
"你将从 `impl` 块中的一些存根函数和 `User` 结构定义开始。你的目标是在 `imipl` 块中定义的 `User` 结构"
"上实现存根的方法。"

#: src/exercises/day-2/health-statistics.md:10
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"methods:"
msgstr "将下面的代码复制到 <https://play.rust-lang.org/>，并填入缺少的方法："

#: src/exercises/day-2/health-statistics.md:17
msgid ""
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:23
msgid ""
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:28
msgid ""
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:32
msgid ""
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:36
msgid ""
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:40
msgid ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:44
msgid ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:49
msgid ""
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:54
msgid ""
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:60
msgid ""
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:1
msgid "# Polygon Struct"
msgstr "# 多边形结构体"

#: src/exercises/day-2/points-polygons.md:3
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make the\n"
"tests pass:"
msgstr ""
"我们将创建一个包含一些点的 `Polygon` 结构。将下面的代码复制到 <https://play.rust-lang.org/>，并填写"
"缺少的方法以使测试通过："

#: src/exercises/day-2/points-polygons.md:7 src/exercises/day-2/luhn.md:23
#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""

#: src/exercises/day-2/points-polygons.md:11
msgid ""
"pub struct Point {\n"
"    // add fields\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:15
msgid ""
"impl Point {\n"
"    // add methods\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:19
msgid ""
"pub struct Polygon {\n"
"    // add fields\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:23
msgid ""
"impl Polygon {\n"
"    // add methods\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:27
msgid ""
"pub struct Circle {\n"
"    // add fields\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:31
msgid ""
"impl Circle {\n"
"    // add methods\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:35
msgid ""
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:40 src/testing/test-modules.md:15
msgid ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""

#: src/exercises/day-2/points-polygons.md:44 src/exercises/day-2/solutions-morning.md:165
msgid ""
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:48 src/exercises/day-2/solutions-morning.md:169
msgid ""
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:54 src/exercises/day-2/solutions-morning.md:175
msgid ""
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:61 src/exercises/day-2/solutions-morning.md:182
msgid ""
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:68 src/exercises/day-2/solutions-morning.md:189
msgid ""
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""

#: src/exercises/day-2/points-polygons.md:73 src/exercises/day-2/solutions-morning.md:194
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:79 src/exercises/day-2/solutions-morning.md:200
msgid ""
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""

#: src/exercises/day-2/points-polygons.md:84 src/exercises/day-2/solutions-morning.md:205
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);"
msgstr ""

#: src/exercises/day-2/points-polygons.md:88 src/exercises/day-2/solutions-morning.md:209
msgid ""
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:92
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:111 src/exercises/day-2/luhn.md:68
msgid ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:117
msgid ""
"Since the method signatures are missing from the problem statements, the key part\n"
"of the exercise is to specify those correctly. You don't have to modify the tests."
msgstr "由于问题陈述中缺少方法签名，练习的关键部分是正确指定这些签名。你不需要修改测试。"

#: src/exercises/day-2/points-polygons.md:120
msgid ""
"Other interesting parts of the exercise:\n"
"    \n"
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes don't borrow their "
"arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be addable via \"+\". Note that "
"we do not discuss generics until Day 3."
msgstr ""
"这个练习的其他有趣部分：\n"
"    \n"
"* 为一些结构派生出一个 `Copy` 特质，因为在测试中，方法有时不会借用它们的参数。\n"
"* 发现必须实现 `Add` 特质才能使两个对象通过 \"+\" 进行添加。请注意，我们在第 3 天才会讨论泛型。"

#: src/control-flow.md:1
msgid "# Control Flow"
msgstr "# 控制流程"

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then becomes\n"
"the value of the `if` expression. Other control flow expressions work similarly\n"
"in Rust."
msgstr ""
"正如我们所看到的，'if' 是 Rust 中的一个表达式。它用于有条件地\n"
"评估两个块中的一个，但这些块可以有一个值，然后变成\n"
"“if”表达式的值。其他控制流表达式的工作方式类似\n"
"在鲁斯特。"

#: src/control-flow/blocks.md:1
#, fuzzy
msgid "# Blocks"
msgstr "# 区块"

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust has a value and a type: the value is the last expression of the\n"
"block:"
msgstr ""
"Rust 中的块有一个值和一个类型：值是\n"
"块："

#: src/control-flow/blocks.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    设 x = {\n"
"        设 y = 10;\n"
"        println！（“y： {y}”）;\n"
"        设 z = {\n"
"            设 w = {\n"
"                3 + 4\n"
"            };\n"
"            println！（“w： {w}”）;\n"
"            y * w\n"
"        };\n"
"        println！（“z： {z}”）;\n"
"        Z - Y\n"
"    };\n"
"    println！（“x： {x}”）;\n"
"}\n"
"```"

#: src/control-flow/blocks.md:25
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr ""
"函数使用相同的规则：函数体的值为\n"
"返回值："

#: src/control-flow/blocks.md:28
#, fuzzy
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}"
msgstr ""
"'''生锈，可编辑\n"
"fn double（x： i32） -> i32 {\n"
"    x + x\n"
"}"

#: src/control-flow/blocks.md:33
#, fuzzy
msgid ""
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""
"fn main（） {\n"
"    println！（“双倍：{}”，双倍（7））;\n"
"}\n"
"```"

#: src/control-flow/blocks.md:38
#, fuzzy
msgid "However if the last expression ends with `;`, then the resulting value and type is `()`."
msgstr "但是，如果最后一个表达式以“;”结尾，则结果值和类型为“（）”。"

#: src/control-flow/blocks.md:42
#, fuzzy
msgid ""
"Key Points:\n"
"* The point of this slide is to show that blocks have a type and value in Rust. \n"
"* You can show how the value of the block changes by changing the last line in the block. For "
"instance, adding/removing a semicolon or using a `return`.\n"
"   \n"
"</details>"
msgstr ""
"要点：\n"
"* 这张幻灯片的重点是展示块在 Rust 中具有类型和值。\n"
"* 您可以通过更改块中的最后一行来显示块的值如何变化。例如，添加/删除分号或使用“返回”。"

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "# `if` expressions"
msgstr "# “如果”表达式"

#: src/control-flow/if-expressions.md:3
#, fuzzy
msgid "You use `if` very similarly to how you would in other languages:"
msgstr "你使用“if”的方式与其他语言非常相似："

#: src/control-flow/if-expressions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    设 mut x = 10;\n"
"    如果 x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:16
#, fuzzy
msgid "In addition, you can use it as an expression. This does the same as above:"
msgstr "此外，您可以将其用作表达式。其操作与上述相同："

#: src/control-flow/if-expressions.md:18
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    设 mut x = 10;\n"
"    x = 如果 x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"

#: src/control-flow/if-expressions.md:31
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its branch blocks must have "
"the same type. Consider showing what happens if you add `;` after `x / 2` in the second example.\n"
"    \n"
"</details>"
msgstr ""
"由于“if”是一个表达式，并且必须具有特定类型，因此其两个分支块必须具有相同的类型。考虑显示如果在第二"
"个示例中的“x / 2”之后添加“;”会发生什么情况。"

#: src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "# `if let` expressions"
msgstr "# 'if let' 表达式"

#: src/control-flow/if-let-expressions.md:3
#, fuzzy
msgid "If you want to match a value against a pattern, you can use `if let`:"
msgstr "如果要将值与模式匹配，可以使用“if let”："

#: src/control-flow/if-let-expressions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    let arg = std：：env：：args（）.next（）;\n"
"    如果让 Some（值） = arg {\n"
"        println！（“程序名称：{value}”）;\n"
"    } else {\n"
"        println！（“缺少名字？\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/if-let-expressions.md:16 src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:22
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns in\n"
"Rust."
msgstr ""
"参见 [模式匹配]（../pattern-matching.md） 有关模式的更多详细信息，请参见\n"
"锈。"

#: src/control-flow/if-let-expressions.md:21
#, fuzzy
msgid ""
"* `if let` can be more concise than `match`, e.g., when only one case is interesting. In contrast, "
"`match` requires all branches to be covered.\n"
"    * For the similar use case consider demonstrating a newly stabilized [`let else`](https://"
"github.com/rust-lang/rust/pull/93628) feature.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"* “if let”可以比“match”更简洁，例如，当只有一个情况很有趣时。相比之下，“匹配”要求覆盖所有分支。\n"
"    * 对于类似的用例，请考虑演示新稳定的 ['let else']（https://github.com/rust-lang/rust/"
"pull/93628） 功能。\n"
"* 常见的用法是在使用“选项”时处理“一些”值。\n"
"* 与“match”不同，“if let”不支持用于模式匹配的保护子句。"

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "# `while` expressions"
msgstr "# “while”表达式"

#: src/control-flow/while-expressions.md:3
#, fuzzy
msgid "The `while` keyword works very similar to other languages:"
msgstr "“while”关键字的工作方式与其他语言非常相似："

#: src/control-flow/while-expressions.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    设 mut x = 10;\n"
"    而 x ！= 1 {\n"
"        x = 如果 x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println！（“最终x：{x}”）;\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "# `while let` expressions"
msgstr "# 'while let' 表达式"

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if`, there is a `while let` variant which repeatedly tests a value\n"
"against a pattern:"
msgstr ""
"与“if”一样，有一个“while let”变体，它重复测试一个值\n"
"针对模式："

#: src/control-flow/while-let-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    让 V = VEC！[10, 20, 30];\n"
"    设 mut iter = v.into_iter（）;"

#: src/control-flow/while-let-expressions.md:11
#, fuzzy
msgid ""
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"而 let Some（x） = iter.next（） {\n"
"        println！（“x： {x}”）;\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr ""
"在这里，由 'v.iter（）' 返回的迭代器将在<i32>每个\n"
"调用“next（）”。它返回“Some（x）”，直到完成，之后它将\n"
"返回“无”。“while let”让我们继续遍历所有项目。</i32>"

#: src/control-flow/while-let-expressions.md:27
#, fuzzy
msgid ""
"* Point out that the `while let` loop will keep going as long as the value matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if statement that breaks when "
"there is no value to unwrap for `iter.next()`. The `while let` provides syntactic sugar for the "
"above scenario.\n"
"    \n"
"</details>"
msgstr ""
"* 指出只要值与模式匹配，“while let”循环就会继续。\n"
"* 您可以将“while let”循环重写为无限循环，并使用if语句在“iter.next（）”没有要解包的值时中断。“while "
"let”为上述场景提供了语法糖。"

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "# `for` expressions"
msgstr "# 'for' 表达式"

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The `for` expression is closely related to the `while let` expression. It will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"“for”表达式与“while let”表达式密切相关。它将\n"
"在表达式上自动调用“into_iter（）”，然后迭代它："

#: src/control-flow/for-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    让 V = VEC！[10, 20, 30];"

#: src/control-flow/for-expressions.md:10
#, fuzzy
msgid ""
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"对于 v 中的 x {\n"
"        println！（“x： {x}”）;\n"
"    }\n"
"    \n"
"对于 i in （0..10）.step_by（2） {\n"
"        println！（“i： {i}”）;\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/for-expressions.md:20
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr "您可以像往常一样在此处使用“休息”和“继续”。"

#: src/control-flow/for-expressions.md:22
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change vector `v` to be "
"mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"<details>* 在这种情况下，索引迭代并不是 Rust 中的特殊语法。\n"
"* “（0..10）”是实现“迭代器”特征的范围。\n"
"* 'step_by' 是一个返回另一个跳过所有其他元素的“迭代器”的方法。\n"
"* 修改向量中的元素并解释编译器错误。将向量“v”更改为可变，将 for 循环更改为“在 v.iter_mut（）” 中为 "
"x”。</details>"

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "# `loop` expressions"
msgstr "# “循环”表达式"

#: src/control-flow/loop-expressions.md:3
#, fuzzy
msgid ""
"Finally, there is a `loop` keyword which creates an endless loop. Here you must\n"
"either `break` or `return` to stop the loop:"
msgstr ""
"最后，还有一个“循环”关键字，它创建了一个无限循环。在这里你必须\n"
"“中断”或“返回”以停止循环："

#: src/control-flow/loop-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    设 mut x = 10;\n"
"    循环 {\n"
"        x = 如果 x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        如果 x == 1 {\n"
"            破;\n"
"        }\n"
"    }\n"
"    println！（“最终x：{x}”）;\n"
"}\n"
"```"

#: src/control-flow/loop-expressions.md:23
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr "<details>* 用一个值打破“循环”（例如“中断 8”）并将其打印出来。</details>"

#: src/control-flow/match-expressions.md:1
#, fuzzy
msgid "# `match` expressions"
msgstr "# “匹配”表达式"

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The `match` keyword is used to match a value against one or more patterns. In\n"
"that sense, it works like a series of `if let` expressions:"
msgstr ""
"“match”关键字用于将值与一个或多个模式进行匹配。在\n"
"从这个意义上说，它就像一系列“if Let”表达式："

#: src/control-flow/match-expressions.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    match std：：env：：args（）.next（）.as_deref（） {\n"
"        一些（“猫”） => println！（“会做猫的事”），\n"
"        一些（“ls”） => println！（“将一些文件”），\n"
"        一些（“mv”） => println！（“让我们移动一些文件”），\n"
"        一些（“rm”） => println！（“呃，危险！\n"
"        无 => 打印ln！（“嗯，没有程序名称？\n"
"        _ => println！（“未知程序名称！\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:19
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"与“if let”一样，每个火柴臂必须具有相同的类型。类型是最后一个\n"
"块的表达式（如果有）。在上面的示例中，类型为“（）”。"

#: src/control-flow/match-expressions.md:27
#, fuzzy
msgid ""
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::args().next()` returns an `Option<String>`, but we cannot match against "
"`String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, this turns "
"`Option<String>` into `Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside `Option`.\n"
"</details>"
msgstr ""
"<details>* 将匹配表达式保存到变量并打印出来。\n"
"* 删除“.as_deref（）”并解释错误。\n"
"    * 'std：：env：：Agrs（）.next' 返回一个 '<&String>Option'，但我们不能与 'String' 匹配。\n"
"    * “as_deref（）”将“选项<T>”转换为<T::Target>“选项”。在我们的例子中，这会将“选项<&String>”变为"
"<&str>“选项”。\n"
"    * 我们现在可以使用模式匹配来匹配“选项”中的“&str”。\n"
"</&str></&String></T::Target></T></&String></details>"

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "# `break` and `continue`"
msgstr "# “休息”和“继续”"

#: src/control-flow/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit a loop early, use `break`, if you want to immediately start\n"
"the next iteration use `continue`. Both `continue` and `break` can optionally\n"
"take a label argument which is used to break out of nested loops:"
msgstr ""
"如果您想提前退出循环，请使用“break”，如果您想立即开始\n"
"下一次迭代使用“继续”。“继续”和“中断”都可以选择。\n"
"取一个用于打破嵌套循环的标签参数："

#: src/control-flow/break-continue.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    让 V = VEC！[10, 20, 30];\n"
"    设 mut iter = v.into_iter（）;\n"
"    'outer： while let Some（x） = iter.next（） {\n"
"        println！（“x： {x}”）;\n"
"        设 mut i = 0;\n"
"        虽然我< x {\n"
"            println！（“x： {x}， i： {i}”）;\n"
"            i += 1;\n"
"            如果 i == 3 {\n"
"                打破'外层;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/break-continue.md:25
#, fuzzy
msgid "In this case we break the outer loop after 3 iterations of the inner loop."
msgstr "在这种情况下，我们在内循环的 3 次迭代后中断外循环。"

#: src/std.md:1
#, fuzzy
msgid "# Standard Library"
msgstr "# 标准库"

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common types\n"
"used by Rust library and programs. This way, two libraries can work together\n"
"smoothly because they both use the same `String` type."
msgstr ""
"Rust 附带了一个标准库，有助于建立一组通用类型\n"
"由 Rust 库和程序使用。这样，两个库可以一起工作\n"
"平滑，因为它们都使用相同的“字符串”类型。"

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "常见的词汇类型包括："

#: src/std.md:9
#, fuzzy
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional values\n"
"  and [error handling](error-handling.md)."
msgstr ""
"* [“选项”和“结果”]（标准/选项 result.md）类型：用于可选值\n"
"  和 [错误处理]（错误 handling.md）。"

#: src/std.md:12
#, fuzzy
msgid "* [`String`](std/string.md): the default string type used for owned data."
msgstr "* ['String']（std/string.md）：用于拥有数据的默认字符串类型。"

#: src/std.md:14
#, fuzzy
msgid "* [`Vec`](std/vec.md): a standard extensible vector."
msgstr "* ['Vec']（std/vec.md）：一个标准的可扩展向量。"

#: src/std.md:16
#, fuzzy
msgid ""
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm."
msgstr ""
"* ['HashMap']（std/hashmap.md）：具有可配置哈希的哈希映射类型\n"
"  算法。"

#: src/std.md:19
#, fuzzy
msgid "* [`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr "* ['Box']（std/box.md）：堆分配数据的自有指针。"

#: src/std.md:21
#, fuzzy
msgid "* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated data."
msgstr "* ['Rc']（std/rc.md）：堆分配数据的共享引用计数指针。"

#: src/std.md:23
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"  * In fact, Rust contains several layers of the Standard Library: `core`, `alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on `libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as `Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"<details>* 事实上，Rust 包含标准库的几层：“core”、“alloc”和“std”。\n"
"  *“核心”包括最基本的类型和功能，不依赖于“libc”，分配器或\n"
"    甚至操作系统的存在。\n"
"  * “alloc”包括需要全局堆分配器的类型，例如“Vec”，“Box”和“Arc”。\n"
"  嵌入式 Rust 应用程序通常只使用“core”，有时使用“alloc”。</details>"

#: src/std/option-result.md:1
#, fuzzy
msgid "# `Option` and `Result`"
msgstr "# “选项”和“结果”"

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "这些类型表示可选数据："

#: src/std/option-result.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    让数字 = VEC！[10, 20, 30];\n"
"    let first： Option<&i8> = numbers.first（）;\n"
"    println！（“第一：{first:?}”）;"

#: src/std/option-result.md:11
#, fuzzy
msgid ""
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""
"let idx： Result<usize， usize> = numbers.binary_search（&10）;\n"
"    println！（“IDX： {idx:?}”）;\n"
"}\n"
"```"

#: src/std/option-result.md:18
#, fuzzy
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should be inserted."
msgstr ""
"* “选项”和“结果”不仅在标准库中被广泛使用。\n"
"* 与“&T”相比，“选项<&T>”的空间开销为零。\n"
"* “结果”是实现错误处理的标准类型，我们将在第 3 天看到。\n"
"* 'binary_search' 返回 'Result<usize， usize>'。\n"
"  * 如果找到，“结果：：Ok”保存找到元素的索引。\n"
"  * 否则，“结果：：Err”包含应插入此类元素的索引。"

#: src/std/string.md:1
#, fuzzy
msgid "# String"
msgstr "# 字符串"

#: src/std/string.md:3
#, fuzzy
msgid "[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr "[“字符串”][1] 是标准堆分配的可增长 UTF-8 字符串缓冲区："

#: src/std/string.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    让 mut s1 = 字符串：：new（）;\n"
"    s1.push_str（“你好”）;\n"
"    println！（“s1： len = {}， capacity = {}”， s1.len（）， s1.capacity（））;"

#: src/std/string.md:11
#, fuzzy
msgid ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());"
msgstr ""
"让 mut s2 = 字符串：：with_capacity（s1.len（） + 1）;\n"
"    s2.push_str（&s1）;\n"
"    s2.push（'！'）;\n"
"    println！（“s2： len = {}， capacity = {}”， s2.len（）， s2.capacity（））;"

#: src/std/string.md:16
#, fuzzy
msgid ""
"    let s3 = String::from(\"🇨🇭\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""
"let s3 = 字符串：：from（“🇨🇭”）;\n"
"    println！（“s3： len = {}， 字符数 = {}”， s3.len（），\n"
"             s3.chars（）.count（））;\n"
"}\n"
"```"

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can call all\n"
"`str` methods on a `String`."
msgstr ""
"“字符串”实现 ['Deref<Target = str>'][2]，这意味着你可以调用所有\n"
"“字符串”上的“str”方法。"

#: src/std/string.md:25
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"
msgstr ""
"[1]： https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]： https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"

#: src/std/string.md:30
#, fuzzy
msgid ""
"* `len()` returns the size of the `String` in bytes, not its length in characters.\n"
"* `chars()` returns an iterator over the actual characters."
msgstr ""
"* 'len' 返回 'String' 的大小（以字节为单位），而不是其长度（以字符为单位）。\n"
"* 'chars' 返回实际字符的迭代器。\n"
"* “String”实现了“Deref<Target = str>”，它透明地允许它访问“str”的方法。"

#: src/std/vec.md:1
#, fuzzy
msgid "# `Vec`"
msgstr "# 'Vec'"

#: src/std/vec.md:3
#, fuzzy
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[“Vec”][1] 是标准的可调整大小的堆分配缓冲区："

#: src/std/vec.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    let mut v1 = Vec：：new（）;\n"
"    v1.推送（42）;\n"
"    println！（“v1： len = {}， capacity = {}”， v1.len（）， v1.capacity（））;"

#: src/std/vec.md:11
#, fuzzy
msgid ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());"
msgstr ""
"let mut v2 = Vec：：with_capacity（v1.len（） + 1）;\n"
"    v2.extend（v1.iter（））;\n"
"    v2.push（9999）;\n"
"    println！（“v2： len = {}， capacity = {}”， v2.len（）， v2.capacity（））;"

#: src/std/vec.md:16
#, fuzzy
msgid ""
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];"
msgstr ""
"规范宏，用于初始化带有元素的向量。\n"
"    让 mut v3 = vec！[0, 0, 1, 2, 3, 4];"

#: src/std/vec.md:19
#, fuzzy
msgid ""
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");"
msgstr ""
"仅保留偶数元素。\n"
"    v3.保留（|x| x % 2 == 0）;\n"
"    println！(\"{v3:?}\");"

#: src/std/vec.md:23
#, fuzzy
msgid ""
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""
"删除连续的重复项。\n"
"    v3.dedup（）;\n"
"    println！(\"{v3:?}\");\n"
"}\n"
"```"

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call slice\n"
"methods on a `Vec`."
msgstr ""
"'Vec' 实现 ['Deref<Target = [T]>'][2]，这意味着你可以调用 slice\n"
"“Vec”上的方法。"

#: src/std/vec.md:32
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"
msgstr ""
"[1]： https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]： https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-方法-[T]"

#: src/std/vec.md:37
#, fuzzy
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data it contains is "
"stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at compile time. It can "
"grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` explicitly. As "
"always\n"
"  with Rust type inference, the `T` was established during the first `push` call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""
"* “Vec”是一种集合类型，还有“String”和“HashMap”。它包含的数据被存储\n"
"  在堆上。这意味着在编译时不需要知道数据量。它可以成长\n"
"  或在运行时收缩。\n"
"* 请注意，“Vec<T>”也是一个泛型类型，但您不必显式指定“T”。一如既往\n"
"  通过 Rust 类型推理，“T”是在第一次“推送”调用期间建立的。\n"
"* 'vec！[...]' 是一个规范的宏，而不是 'Vec：：new（）' 并且它支持添加初始\n"
"  元素。\n"
"* 要索引向量，您使用“[”]“，但如果超出界限，它们会惊慌失措。或者，使用\n"
"  “get”将返回“选项”。“pop”函数将删除最后一个元素。\n"
"* 显示迭代向量并改变值：\n"
"  'for e in &mut v { *e += 50; }`</T>"

#: src/std/hashmap.md:1
#, fuzzy
msgid "# `HashMap`"
msgstr "# '哈希图'"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "具有针对 HashDoS 攻击的保护的标准哈希映射："

#: src/std/hashmap.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;"
msgstr ""
"'''生锈，可编辑\n"
"使用 std：：collections：：HashMap;"

#: src/std/hashmap.md:8
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);"
msgstr ""
"fn main（） {\n"
"    let mut page_counts = HashMap：：new（）;\n"
"    page_counts.insert（“哈克贝利·费恩历险记”.to_string（）， 207）;\n"
"    page_counts.插入（“格林童话”.to_string（）， 751）;\n"
"    page_counts.插入（“傲慢与偏见”.to_string（）， 303）;"

#: src/std/hashmap.md:14
#, fuzzy
msgid ""
"    if !page_counts.contains_key(\"Les Misérables\") {\n"
"        println!(\"We know about {} books, but not Les Misérables.\",\n"
"                 page_counts.len());\n"
"    }"
msgstr ""
"if ！page_counts.contains_key（“Les Misérables”） {\n"
"        println！（“我们知道{}书，但不知道《悲惨世界》。\n"
"                 page_counts.len（））;\n"
"    }"

#: src/std/hashmap.md:19
#, fuzzy
msgid ""
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }"
msgstr ""
"为书在[《傲慢与偏见》、《爱丽丝梦游仙境》]{\n"
"        匹配page_counts.get（book） {\n"
"            一些（计数）=>打印ln！（“{book}：{count}页”），\n"
"            无 => 打印ln！（“{book}未知。\n"
"        }\n"
"    }"

#: src/std/hashmap.md:26
#, fuzzy
msgid ""
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string()).or_insert(0);\n"
"        *page_count += 1;\n"
"    }"
msgstr ""
"如果未找到任何内容，请使用 .entry（） 方法插入值。\n"
"    为书在[《傲慢与偏见》、《爱丽丝梦游仙境》]{\n"
"        设page_count： &mut i32 = page_counts.entry（book.to_string（））.or_insert（0）;\n"
"        *page_count += 1;\n"
"    }"

#: src/std/hashmap.md:32
#, fuzzy
msgid ""
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""
"println！(\"{page_counts:#?}\");\n"
"}\n"
"```"

#: src/std/hashmap.md:38
msgid ""
"* `HashMap` is not defined in the prelude and needs to be brought into scope.\n"
"* Try the following lines of code. The first line will see if a book is in the hashmap and if not "
"return an alternative value. The second line will insert the alternative value in the hashmap if "
"the book is not found."
msgstr ""

#: src/std/hashmap.md:41
msgid ""
"  ```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"  ```\n"
"* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.\n"
"  * Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1], which allows us to "
"easily initialize a hash map from a literal array:"
msgstr ""

#: src/std/hashmap.md:52
msgid ""
"  ```rust,ignore\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"    (\"The Hunger Games\".to_string(), 374),\n"
"  ]);\n"
"  ```"
msgstr ""

#: src/std/hashmap.md:59
msgid ""
" * Alternatively HashMap can be built from any `Iterator` which yields key-value tuples.\n"
"* We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make examples easier. "
"Using references in collections can, of course, be done,\n"
"  but it can lead into complications with the borrow checker.\n"
"  * Try removing `to_string()` from the example above and see if it still compiles. Where do you "
"think we might run into issues?"
msgstr ""

#: src/std/hashmap.md:64
msgid ""
"[1]: https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K%2C%20V)%3B%20N%5D%3E-for-HashMap%3CK%2C%20V%2C%20RandomState%3E"
msgstr ""

#: src/std/box.md:1
#, fuzzy
msgid "# `Box`"
msgstr "# “盒子”"

#: src/std/box.md:3
#, fuzzy
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[“盒子”][1] 是指向堆上数据的自有指针："

#: src/std/box.md:5
#, fuzzy
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""
"'''生锈，可编辑\n"
"fn main（） {\n"
"    设五 = 框：：新（5）;\n"
"    println！（“五：{}”，*五）;\n"
"}\n"
"```"

#: src/std/box.md:13
#, fuzzy
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""
"'''鲍勃\n"
" 堆栈堆\n"
".- - - - - - -.    .- - - - - - -.\n"
":             :     :             :\n"
"：五：：：\n"
":   +-----+   :     :   +-----+   :\n"
":   |o---|---+-----+-->| 5 |  :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr ""
"“Box”<T>实现“Deref<Target ==\"\" t=\"\">”，这意味着您可以[调用方法\n"
"从“T”直接在“盒子”上]<T>[2]。</T></Target></T>"

#: src/std/box.md:29
msgid ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"
msgstr ""

#: src/std/box.md:34
#, fuzzy
msgid ""
"* `Box` is like `std::unique_ptr` in C++. \n"
"* In the above example, you can even leave out the `*` in the `println!` statement thanks to "
"`Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the Rust compiler wants to "
"know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying large amounts of data "
"on the stack, instead store the data on the heap in a `Box` so only the pointer is moved.\n"
"</details>"
msgstr ""
"* “Box”在C++中类似于“std：：unique_ptr”。\n"
"* 在上面的例子中，你甚至可以省略'println！'语句中的'*'，这要归功于'Deref'。\n"
"* 当您执行以下操作时，“盒子”可能很有用：\n"
"   * 有一个类型，其大小在编译时无法知道，但 Rust 编译器想知道确切的大小。\n"
"   * 想要转让大量数据的所有权。为避免在堆栈上复制大量数据，请将堆上的数据存储在“Box”中，以便仅移动"
"指针。"

#: src/std/box-recursive.md:1
#, fuzzy
msgid "# Box with Recursive Data Structures"
msgstr "# 带有递归数据结构的框"

#: src/std/box-recursive.md:3
#, fuzzy
msgid "Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "递归数据类型或具有动态大小的数据类型需要使用“Box”："

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}"
msgstr ""
"'''生锈，可编辑\n"
"#[派生（调试）]\n"
"枚举列表<T> {\n"
"    缺点（T，盒子<List<T>>），\n"
"    零\n"
"}</T></T>"

#: src/std/box-recursive.md:12 src/std/box-niche.md:10
#, fuzzy
msgid ""
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""
"fn main（） {\n"
"    let list： list = list：：Cons（1， Box：：new（List：：<i32> Cons（2， Box：：new（List：："
"Nil））））;\n"
"    println！(\"{list:?}\");\n"
"}\n"
"```</i32>"

#: src/std/box-recursive.md:18
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // |   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"'''鲍勃\n"
" 堆栈堆\n"
".- - - - - - - - - - - - -.    .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
"：列表：：：\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":   |0 |1 |   :     : .->|0 | 2 | .->|////// |//// |  :\n"
":   |“1/标签”|o-----+----+-----+-' |“1/标签”| o-----+-' |“1/标签”|空|  :\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/box-recursive.md:33
#, fuzzy
msgid ""
"* If the `Box` was not used here and we attempted to embed a `List` directly into the `List`,\n"
"the compiler would not compute a fixed size of the struct in memory, it would look infinite."
msgstr ""
"<details>* 如果此处未使用“框”，并且我们尝试将“列表”直接嵌入到“列表”中，\n"
"编译器不会计算内存中结构的固定大小，它看起来是无限的。\n"
"    \n"
"* 'Box' 解决了这个问题，因为它与常规指针具有相同的大小，并且只指向下一个指针\n"
"元素中的“列表”。    </details>"

#: src/std/box-recursive.md:36
msgid ""
"* `Box` solves this problem as it has the same size as a regular pointer and just points at the "
"next\n"
"element of the `List` in the heap."
msgstr "* `Box` 解决了这个问题，因为它的大小与普通指针相同，只是指向堆中 `List` 的下一个元素。"

#: src/std/box-recursive.md:39
#, fuzzy
msgid ""
"* Remove the `Box` in the List definition and show the compiler error. \"Recursive with "
"indirection\" is a hint you might want to use a Box or reference of some kind, instead of storing "
"a value directly.   \n"
"    \n"
"</details>"
msgstr ""
"* 删除列表定义中的“框”并显示编译器错误。“间接递归”是您可能希望使用 Box 或某种引用的提示，而不是直接"
"存储值。"

#: src/std/box-niche.md:1
#, fuzzy
msgid "# Niche Optimization"
msgstr "# 利基优化"

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This\n"
"allows the compiler to optimize the memory layout:"
msgstr ""
"“Box”不能为空，因此指针始终有效且非“null”。这\n"
"允许编译器优化内存布局："

#: src/std/box-niche.md:19
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                             :\n"
":    list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null |             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"'''鲍勃\n"
" 堆栈堆\n"
".- - - - - - - - - - - - -.    .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
"：列表：：：\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":   |0 |1 |   :     : .->|0 | 2 | .->|////// |//// |  :\n"
":   |“1/标签”|o-----+----+-----+-' |“1/标签”| o-----+-' |“1/标签”|空|  :\n"
":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"

#: src/std/rc.md:1
#, fuzzy
msgid "# `Rc`"
msgstr "# 'Rc'"

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to refer\n"
"to the same data from multiple places:"
msgstr ""
"[“RC”][1] 是一个引用计数的共享指针。当您需要参考时，请使用此选项\n"
"来自多个位置的相同数据："

#: src/std/rc.md:6
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::rc::Rc;"
msgstr ""
"'''生锈，可编辑\n"
"使用 std：：rc：：Rc;"

#: src/std/rc.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"
msgstr ""
"fn main（） {\n"
"    设 mut a = Rc：：new（10）;\n"
"    设 mut b = a.clone（）;"

#: src/std/rc.md:18
#, fuzzy
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create cycles\n"
"  that will get dropped."
msgstr ""
"* 如果您需要改变“Rc”中的数据，则需要将数据包装在\n"
"  诸如 ['Cell' 或 'RefCell'][2] 之类的类型。\n"
"* 如果您在多线程上下文中，请参阅 ['Arc'][3]。\n"
"* 您可以将共享指针降级为 ['弱'][4] 指针以创建循环\n"
"  那将被丢弃。"

#: src/std/rc.md:24
#, fuzzy
msgid ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"
msgstr ""
"[1]： https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]： https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]： https://doc.rust-lang.org/std/rc/struct.Weak.html"

#: src/std/rc.md:31
#, fuzzy
msgid ""
"* Like C++'s `std::shared_ptr`.\n"
"* `clone` is cheap: creates a pointer to the same allocation and increases the reference count.\n"
"* `make_mut` actually clones the inner value if necessary (\"clone-on-write\") and returns a "
"mutable reference.\n"
"* You can `downgrade()` a `Rc` into a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* 喜欢C++的“std：：shared_ptr”。\n"
"* “clone”很便宜：创建一个指向相同分配的指针并增加引用计数。\n"
"* 'make_mut' 实际上在必要时克隆内部值（“写入时克隆”）并返回可变引用。\n"
"* 您可以将“Rc”降级（）“为*弱引用计数*对象\n"
"  创建将正确删除的循环（可能与\n"
"  “参考细胞”）。"

#: src/std/rc.md:38
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;"
msgstr ""
"'''生锈，可编辑\n"
"使用 std：：rc：：{Rc， Weak};\n"
"使用 std：：cell：：RefCell;"

#: src/std/rc.md:42
#, fuzzy
msgid ""
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}"
msgstr ""
"#[派生（调试）]\n"
"结构节点 {\n"
"    值：i64，\n"
"    父项：选项<Weak<RefCell<Node>>>，\n"
"    儿童：Vec<Rc<RefCell<Node>>>，\n"
"}</Node></Node>"

#: src/std/rc.md:49
#, fuzzy
msgid ""
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);"
msgstr ""
"fn main（） {\n"
"    let mut root = Rc：：new（RefCell：：new（Node {\n"
"        值：42，\n"
"        父母：无，\n"
"        孩子们：维克！[],\n"
"    }));\n"
"    let child = Rc：：new（RefCell：：new（Node {\n"
"        值： 43，\n"
"        孩子们：维克！[],\n"
"        父级：一些（Rc：:d owngrade（&root））\n"
"    }));\n"
"    root.borrow_mut（）.儿童.推送（儿童）;"

#: src/std/rc.md:62
#, fuzzy
msgid ""
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""
"println！（“图表：{root:#?}”）;\n"
"}\n"
"```"

#: src/modules.md:1
#, fuzzy
msgid "# Modules"
msgstr "# 模块"

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr "我们已经看到了“impl”块如何让我们将函数命名为类型。"

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "同样，“mod”让我们可以命名空间类型和函数："

#: src/modules.md:7
#, fuzzy
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}"
msgstr ""
"'''生锈，可编辑\n"
"mod foo {\n"
"    Pub FN do_something（） {\n"
"        println！（“在 foo 模块中”）;\n"
"    }\n"
"}"

#: src/modules.md:14
#, fuzzy
msgid ""
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}"
msgstr ""
"模组栏 {\n"
"    Pub FN do_something（） {\n"
"        println！（“在条形模块中”）;\n"
"    }\n"
"}"

#: src/modules.md:20
#, fuzzy
msgid ""
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""
"fn main（） {\n"
"    foo：:d o_something（）;\n"
"    bar：:d o_something（）;\n"
"}\n"
"```"

#: src/modules.md:28
#, fuzzy
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that describes how to build a "
"bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable and a library crate "
"compiles to a library.\n"
"* Modules define organization, scope, and are the focus of this section."
msgstr ""
"* 软件包提供功能，并包含一个“Cargo.toml”文件，该文件描述了如何构建 1+ 板条箱的捆绑包。\n"
"* Crate 是一个模块树，其中二进制 crate 创建一个可执行文件，一个库 crate 编译到一个库。\n"
"* 模块定义组织、范围，是本节的重点。"

#: src/modules/visibility.md:1
#, fuzzy
msgid "# Visibility"
msgstr ""
"|缩小 | 缩小活动图。\n"
"|适合屏幕 | 调整缩放设置以显示所有绘图。\n"
"|显示网格 | 切换网格可见性。\n"
"|显示长度 | 切换图表图例可见性。\n"

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "模块是一个隐私边界："

#: src/modules/visibility.md:5
#, fuzzy
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all the\n"
"  descendants of `foo`."
msgstr ""
"* 模块项默认是私有的（隐藏实现详细信息）。\n"
"* 父项和同级项目始终可见。"

#: src/modules/visibility.md:10
#, fuzzy
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }"
msgstr ""
"'''生锈，可编辑\n"
"模组外{\n"
"    fn private（） {\n"
"        println！（“外部：:p rivate”）;\n"
"    }"

#: src/modules/visibility.md:16
#, fuzzy
msgid ""
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }"
msgstr ""
"Pub FN public（） {\n"
"        println！（“外部：:p ublic”）;\n"
"    }"

#: src/modules/visibility.md:20
#, fuzzy
msgid ""
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }"
msgstr ""
"模组内 {\n"
"        fn private（） {\n"
"            println！（“外部：：内部：:p rivate”）;\n"
"        }"

#: src/modules/visibility.md:25
#, fuzzy
msgid ""
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"Pub FN public（） {\n"
"            println！（“外部：：内部：:p ublic”）;\n"
"            super：:p rivate（）;\n"
"        }\n"
"    }\n"
"}"

#: src/modules/visibility.md:32
#, fuzzy
msgid ""
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""
"fn main（） {\n"
"    println！（“双倍：{}”，双倍（7））;\n"
"}\n"
"```"

#: src/modules/visibility.md:39
msgid "* Use the `pub` keyword to make modules public."
msgstr "* 使用 `pub` 关键字，使模块公开。"

#: src/modules/visibility.md:41
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope of public visibility."
msgstr "此外，还有一些高级的 `pub(...)` 指定器来限制公共可见性的范围。"

#: src/modules/visibility.md:43
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-"
"path-pubcrate-pubsuper-and-pubself)).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of its descendants)."
msgstr ""
"* 见[Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-"
"pubcrate-pubsuper-and-pubself))。\n"
"* 配置 `pub(crate)` 可见性是一种常见的模式。\n"
"* 不太常见的是，你可以给一个特定的路径以可见性。\n"
"* 在任何情况下，都必须对原始模块（以及它的所有后代）授予可见性。"

#: src/modules/paths.md:1
#, fuzzy
msgid "# Paths"
msgstr "# 路径"

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "路径解析方式如下："

#: src/modules/paths.md:5
#, fuzzy
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module."
msgstr ""
"1. 作为相对路径：\n"
"   * “foo”或“self：：foo”是指当前模块中的“foo”，\n"
"   * “super：：foo”是指父模块中的“foo”。"

#: src/modules/paths.md:9
#, fuzzy
msgid ""
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"2. 作为绝对路径：\n"
"   * “crate：：foo”是指当前板条箱根中的“foo”，\n"
"   * “bar：：foo”是指“bar”板条箱中的“foo”。"

#: src/modules/filesystem.md:1
#, fuzzy
msgid "# Filesystem Hierarchy"
msgstr "# 文件系统层次结构"

#: src/modules/filesystem.md:3
#, fuzzy
msgid "The module content can be omitted:"
msgstr "模块内容可以省略："

#: src/modules/filesystem.md:5
#, fuzzy
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""
"'''生锈，可编辑，compile_fail\n"
"模组花园;\n"
"```"

#: src/modules/filesystem.md:9
#, fuzzy
msgid "The `garden` module content is found at:"
msgstr "“花园”模块内容位于："

#: src/modules/filesystem.md:11
#, fuzzy
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""
"* 'src/garden.rs' （现代 Rust 2018 风格）\n"
"* 'src/garden/mod.rs' （较旧的 Rust 2015 风格）"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "类似地，可以在以下位置找到“花园：：蔬菜”模块："

#: src/modules/filesystem.md:16
#, fuzzy
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""
"* 'src/garden/vegetables.rs' （Modern Rust 2018 風格）\n"
"* 'src/garden/vegetables/mod.rs' （Old Rust 2015 风格）"

#: src/modules/filesystem.md:19
#, fuzzy
msgid "The `crate` root is in:"
msgstr "“板条箱”根位于："

#: src/modules/filesystem.md:21
#, fuzzy
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""
"* “src/lib.rs”（用于图书馆板条箱）\n"
"* 'src/main.rs' （用于二进制板条箱）"

#: src/modules/filesystem.md:26
msgid ""
"* The change from `module/mod.rs` to `module.rs` doesn't preclude the use of submodules in Rust "
"2018.\n"
"  (It was mandatory in Rust 2015.)"
msgstr ""
"* 从 `module/mod.rs` 到 `module.rs` 的变化并不排除在 Rust 2018 中使用子模块。  (它在 Rust 2015 中是"
"强制性的）。"

#: src/modules/filesystem.md:29
msgid "  The following is valid:"
msgstr "  以下是有效的："

#: src/modules/filesystem.md:31
msgid ""
"  ```ignore\n"
"  src/\n"
"  ├── main.rs\n"
"  ├── top_module.rs\n"
"  └── top_module/\n"
"      └── sub_module.rs\n"
"  ```"
msgstr ""

#: src/modules/filesystem.md:39
msgid ""
"* The main reason for the change is to prevent many files named `mod.rs`, which can be hard\n"
"  to distinguish in IDEs."
msgstr "* 改变的主要原因是为了防止许多名为 `mod.rs` 的文件，这在 IDE 中很难区分。"

#: src/modules/filesystem.md:42
msgid ""
"* Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but this can be changed\n"
"  with a compiler directive:"
msgstr ""
"* Rust 会在 `modulename/mod.rs` 和 `modulename.rs` 中寻找模块，但这可以通过编译器指令来改变："

#: src/modules/filesystem.md:45
msgid ""
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```"
msgstr ""

#: src/modules/filesystem.md:50
msgid ""
"  This is useful, for example, if you would like to place tests for a module in a file named\n"
"  `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"  这很有用，例如，如果你想把一个模块的测试放在一个名为 `some_module_test.rs` 的文件中，类似于 Go 的"
"惯例。"

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "# Day 2: Afternoon Exercises"
msgstr "# 第二天：下午练习"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "今天下午的练习将集中在字符串和迭代器上。"

#: src/exercises/day-2/luhn.md:1
#, fuzzy
msgid "# Luhn Algorithm"
msgstr "# 卢恩算法"

#: src/exercises/day-2/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to\n"
"validate credit card numbers. The algorithm takes a string as input and does the\n"
"following to validate the credit card number:"
msgstr ""
"[Luhn算法]（https://en.wikipedia.org/wiki/Luhn_algorithm）用于\n"
"验证信用卡号。该算法将字符串作为输入并执行\n"
"以下验证信用卡号："

#: src/exercises/day-2/luhn.md:7
#, fuzzy
msgid "* Ignore all spaces. Reject number with less than two digits."
msgstr "* 忽略所有空格。拒绝少于两位数字的数字。"

#: src/exercises/day-2/luhn.md:9
#, fuzzy
msgid ""
"* Moving from right to left, double every second digit: for the number `1234`,\n"
"  we double `3` and `1`."
msgstr ""
"*从右到左移动，每两位数字双倍：对于数字“1234”，\n"
"  我们将“3”和“1”加倍。"

#: src/exercises/day-2/luhn.md:12
#, fuzzy
msgid ""
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` which\n"
"  becomes `5`."
msgstr ""
"* 将数字加倍后，对数字求和。因此，将“7”加倍变为“14”，\n"
"  变为“5”。"

#: src/exercises/day-2/luhn.md:15
#, fuzzy
msgid "* Sum all the undoubled and doubled digits."
msgstr "* 将所有未加倍和双倍数相加。"

#: src/exercises/day-2/luhn.md:17
#, fuzzy
msgid "* The credit card number is valid if the sum ends with `0`."
msgstr "* 如果总和以“0”结尾，则信用卡号有效。"

#: src/exercises/day-2/luhn.md:19
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr ""
"复制以下代码以<https://play.rust-lang.org/>并实现\n"
"功能："

#: src/exercises/day-2/luhn.md:27
msgid ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:31
msgid ""
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:36 src/exercises/day-2/solutions-afternoon.md:64
msgid ""
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:44 src/exercises/day-2/solutions-afternoon.md:72
msgid ""
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:49 src/exercises/day-2/solutions-afternoon.md:77
msgid ""
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:54 src/exercises/day-2/solutions-afternoon.md:82
msgid ""
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:61
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:1
msgid "# Strings and Iterators"
msgstr "# 字符串和迭代器"

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. The\n"
"server is configured with a number of _path prefixes_ which are matched against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr ""
"在本练习中，您将实现 Web 服务器的路由组件。这\n"
"服务器配置了许多_path prefixes_与\n"
"_request paths_。路径前缀可以包含通配符，该\n"
"匹配整个细分。请参阅下面的单元测试。"

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"将以下代码复制到<https://play.rust-lang.org/>并进行测试\n"
"通过。尽量避免为中间结果分配“Vec”："

#: src/exercises/day-2/strings-iterators.md:16
msgid ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:20
msgid ""
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:26 src/exercises/day-2/solutions-afternoon.md:146
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:31 src/exercises/day-2/solutions-afternoon.md:151
msgid ""
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:46
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-3.md:1
#, fuzzy
msgid "# Welcome to Day 3"
msgstr "# 欢迎来到第三天"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "今天，我们将介绍一些更高级的 Rust 主题："

#: src/welcome-day-3.md:5
#, fuzzy
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits."
msgstr ""
"* 特征：派生特征、默认方法和重要的标准库\n"
"  性状。"

#: src/welcome-day-3.md:8
#, fuzzy
msgid ""
"* Generics: generic data types, generic methods, monomorphization, and trait\n"
"  objects."
msgstr ""
"泛型：泛型数据类型、泛型方法、单态化和特征\n"
"  对象。"

#: src/welcome-day-3.md:11
#, fuzzy
msgid "* Error handling: panics, `Result`, and the try operator `?`."
msgstr "* 错误处理：崩溃、“结果”和 try 运算符“？”。"

#: src/welcome-day-3.md:13
#, fuzzy
msgid "* Testing: unit tests, documentation tests, and integration tests."
msgstr "* 测试：单元测试、文档测试和集成测试。"

#: src/welcome-day-3.md:15
#, fuzzy
msgid ""
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr ""
"* 不安全的 Rust：原始指针、静态变量、不安全函数和外部函数\n"
"  功能。"

#: src/traits.md:1
msgid "# Traits"
msgstr "# 特质"

#: src/traits.md:3
#, fuzzy
msgid "Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "Rust 允许您抽象具有特征的类型。它们类似于接口："

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Greet {\n"
"    fn say_hello(&self);\n"
"}"
msgstr ""

#: src/traits.md:10
msgid ""
"struct Dog {\n"
"    name: String,\n"
"}"
msgstr ""

#: src/traits.md:14
msgid "struct Cat;  // No name, cats won't respond to it anyway."
msgstr ""

#: src/traits.md:16
msgid ""
"impl Greet for Dog {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Wuf, my name is {}!\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/traits.md:22
msgid ""
"impl Greet for Cat {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Miau!\");\n"
"    }\n"
"}"
msgstr ""

#: src/traits.md:28
msgid ""
"fn main() {\n"
"    let pets: Vec<Box<dyn Greet>> = vec![\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"        Box::new(Cat),\n"
"    ];\n"
"    for pet in pets {\n"
"        pet.say_hello();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits.md:41
#, fuzzy
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that users are required to "
"implement themselves. Methods with default implementations can rely on required methods.\n"
"* Types that implement a given trait may be of different sizes. This makes it impossible to have "
"things like `Vec<Greet>` in the example above.\n"
"* `dyn Greet` is a way to tell the compiler about a dynamically sized type that implements "
"`Greet`.\n"
"* In the example, `pets` holds Fat Pointers to objects that implement `Greet`. The Fat Pointer "
"consists of two components, a pointer to the actual object and a pointer to the virtual method "
"table for the `Greet` implementation of that particular object."
msgstr ""
"* 特征可以指定预先实现的（默认）方法和用户需要自己实现的方法。具有默认实现的方法可以依赖于所需的方"
"法。\n"
"* 实现给定特征的类型可能具有不同的大小。这使得在上面的示例中不可能有“Vec”之类的东西<Greet>。\n"
"* “dyn Greet”是一种告诉编译器实现“Greet”的动态大小类型的方法。\n"
"* 在示例中，“pets”持有指向实现“Greet”的对象的胖指针。胖指针由两个组件组成，一个指向实际对象的指针和"
"一个指向该特定对象的“Greet”实现的虚拟方法表的指针。</Greet>"

#: src/traits.md:46
#, fuzzy
msgid ""
"Compare these outputs in the above example:\n"
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"
msgstr ""
"在上面的示例中比较这些输出：\n"
"'''生锈，忽略\n"
"    println！（“{} {}”， std：：mem：：size_of：：（<Dog>）， std：：mem：：size_of：：<Cat>"
"（））;\n"
"    println！（“{} {}”， std：：mem：：size_of：：（<&Dog>）， std：：mem：：size_of：：<&Cat>"
"（））;\n"
"    println！（“{}”， std：：mem：：size_of：：<&dyn greet=\"\">（））;\n"
"    println！（“{}”， std：：mem：：size_of：：<Box<dyn Greet>>（））;\n"
"```</dyn></&dyn></&Cat></&Dog></Cat></Dog>"

#: src/traits/deriving-traits.md:1
msgid "# Deriving Traits"
msgstr "# 派生特质"

#: src/traits/deriving-traits.md:3
#, fuzzy
msgid "You can let the compiler derive a number of traits:"
msgstr "您可以让编译器派生许多特征："

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}"
msgstr ""

#: src/traits/deriving-traits.md:13
msgid ""
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:1
#, fuzzy
msgid "# Default Methods"
msgstr "# 默认方法"

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "特征可以根据其他特征方法实现行为："

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/default-methods.md:13
msgid ""
"#[derive(Debug)]\n"
"struct Centimeter(i16);"
msgstr ""

#: src/traits/default-methods.md:16
msgid ""
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}"
msgstr ""

#: src/traits/default-methods.md:22
msgid ""
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/important-traits.md:1
msgid "# Important Traits"
msgstr "# 重要特质"

#: src/traits/important-traits.md:3
#, fuzzy
msgid "We will now look at some of the most common traits of the Rust standard library:"
msgstr "现在我们将看看 Rust 标准库的一些最常见的特征："

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* ['Iterator'][1] 和 ['IntoIterator'][2] 用于 'for' 循环，\n"
"* ['From'][3] 和 ['Into'][4] 用于转换值，\n"
"* [“读取”][5] 和 [“写入”][6] 用于 IO，\n"
"* [“添加”][7]， [“穆尔”][8]， ...用于操作员重载，以及\n"
"* ['Drop'][9] 用于定义析构函数。\n"
"* ['Default'][10] 用于构造类型的默认实例。"

#: src/traits/important-traits.md:12
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\n"
"[3]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[4]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[5]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[6]: https://doc.rust-lang.org/std/io/trait.Write.html\n"
"[7]: https://doc.rust-lang.org/std/ops/trait.Add.html\n"
"[8]: https://doc.rust-lang.org/std/ops/trait.Mul.html\n"
"[9]: https://doc.rust-lang.org/std/ops/trait.Drop.html\n"
"[10]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr ""

#: src/traits/iterator.md:1
#, fuzzy
msgid "# Iterators"
msgstr "# 迭代器"

#: src/traits/iterator.md:3
#, fuzzy
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "你可以在自己的类型上实现 ['迭代器'][1] 特征："

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}"
msgstr ""

#: src/traits/iterator.md:11
msgid ""
"impl Iterator for Fibonacci {\n"
"    type Item = u32;"
msgstr ""

#: src/traits/iterator.md:14
msgid ""
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/iterator.md:22
msgid ""
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
#, fuzzy
msgid ""
"* `IntoIterator` is the trait that makes for loops work. It is implemented by collection types "
"such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also implement it.\n"
"* The `Iterator` trait implements many common functional programming operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can find all the "
"documentation\n"
"  about them. In Rust these functions should produce the code as efficient as equivalent "
"imperative\n"
"  implementations.\n"
"    \n"
"</details>"
msgstr ""
"* “IntoIterator”是使循环起作用的特征。它由集合类型实现，例如\n"
"  “Vec”和<T>对它们的引用，例如“&Vec<T>”和“&[T]”。范围也实现它。\n"
"* “迭代器”特征在集合上实现了许多常见的函数式编程操作\n"
"  （例如“映射”、“过滤器”、“减少”等）。这是您可以找到所有文档的特征\n"
"  关于他们。在 Rust 中，这些函数应该产生与等效命令一样高效的代码。\n"
"  实现。\n"
"    \n"
"</T></T>"

#: src/traits/iterator.md:41
msgid "[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr ""

#: src/traits/from-iterator.md:1
#, fuzzy
msgid "# FromIterator"
msgstr "# 从迭代器"

#: src/traits/from-iterator.md:3
#, fuzzy
msgid "[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr "[“来自迭代器”][1] 允许您从 ['迭代器'][2] 构建集合。"

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""

#: src/traits/from-iterator.md:23
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"还有一些实现可以让您做很酷的事情，例如转换\n"
"“迭代器<Item = Result<V, e=\"\">>”变为“结果<Vec<V>，E>”。</V></V,>"

#: src/traits/from-iterator.md:28
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr ""

#: src/traits/from-into.md:1
#, fuzzy
msgid "# `From` and `Into`"
msgstr ""
"`exclude_from_board`: 符号的 \"排除在 PCB 之外\" 设置。此处命名的列必须是数字类型，并将被当作布尔值"
"（`0` 代表假，`1` 代表真）。"

#: src/traits/from-into.md:3
#, fuzzy
msgid "Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr "类型实现 ['From'][1] 和 ['Into'][2] 以促进类型转换："

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
#, fuzzy
msgid "[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr "[“进入”][2] 在实现 ['From'][1] 时自动实现："

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:27
#, fuzzy
msgid ""
"<details>\n"
"  \n"
"* That's why it is common to only implement `From`, as your type will get `Into` implementation "
"too.\n"
"* When declaring a function argument input type like \"anything that can be converted into a "
"`String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that _only_ implement `Into`.\n"
"    \n"
"</details>"
msgstr ""
"<details>* 这就是为什么通常只实现“From”，因为你的类型也会得到“Into”实现。\n"
"* 当声明函数参数输入类型时，例如“任何可以转换为'字符串'的东西”，规则是相反的，你应该使用'Into'。\n"
"  您的函数将接受实现“From”的类型以及_仅_实现“Into”的类型。</details>"

#: src/traits/from-into.md:35
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"
msgstr ""

#: src/traits/read-write.md:1
#, fuzzy
msgid "# `Read` and `Write`"
msgstr "# “读”和“写”"

#: src/traits/read-write.md:3
#, fuzzy
msgid "Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "使用 ['Read'][1] 和 ['BufRead'][2]，你可以抽象出 'u8' 源："

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};"
msgstr ""

#: src/traits/read-write.md:8
msgid ""
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}"
msgstr ""

#: src/traits/read-write.md:13
msgid ""
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));"
msgstr ""

#: src/traits/read-write.md:17
msgid ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
#, fuzzy
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "类似地，['Write'][3] 让你抽象化 'u8' 接收器："

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};"
msgstr ""

#: src/traits/read-write.md:28
msgid ""
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}"
msgstr ""

#: src/traits/read-write.md:33
msgid ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:42
msgid ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"
msgstr ""

#: src/traits/operators.md:1
#, fuzzy
msgid "# `Add`, `Mul`, ..."
msgstr "# “添加”、“穆尔”、..."

#: src/traits/operators.md:3
#, fuzzy
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr "运算符重载是通过 ['std：：ops'][1] 中的特征实现的："

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }"
msgstr ""

#: src/traits/operators.md:9 src/exercises/day-2/solutions-morning.md:46
msgid ""
"impl std::ops::Add for Point {\n"
"    type Output = Self;"
msgstr ""

#: src/traits/operators.md:12
msgid ""
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}"
msgstr ""

#: src/traits/operators.md:17
msgid ""
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:26 src/traits/drop.md:34
#, fuzzy
msgid "Discussion points:"
msgstr "讨论要点："

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter?\n"
"    * Short answer: Type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor of a\n"
"        trait."
msgstr ""
"* 您可以为“&Point”实现“添加”。这在哪些情况下有用？\n"
"    * 答案：“添加：添加”消耗“自我”。如果您键入“T”\n"
"        重载运算符不是“Copy”，你应该考虑重载\n"
"        “&T”的运算符也是如此。这避免了在\n"
"        呼叫站点。\n"
"* 为什么“输出”是关联类型？可以将其作为类型参数吗？\n"
"    * 简答：类型参数由调用方控制，但\n"
"        相关类型（如“输出”）由\n"
"        特性。"

#: src/traits/operators.md:40
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/ops/index.html"
msgstr "[1]： https://doc.rust-lang.org/std/ops/index.html"

#: src/traits/drop.md:1
msgid "# The `Drop` Trait"
msgstr "# `Drop` 特质"

#: src/traits/drop.md:3
#, fuzzy
msgid "Values which implement [`Drop`][1] can specify code to run when they go out of scope:"
msgstr "实现 ['Drop'][1] 的值可以指定超出范围时要运行的代码："

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}"
msgstr ""

#: src/traits/drop.md:10
msgid ""
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/traits/drop.md:16
msgid ""
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:36
#, fuzzy
msgid ""
"* Why does not `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* 为什么“Drop：:d rop”不取“自我”？\n"
"    *简答：如果是这样，“std：：mem：:d rop”将在末尾调用\n"
"        块，导致对“Drop：:d rop”的另一个调用，以及一个堆栈\n"
"        溢出！\n"
"* 尝试将“drop（a）”替换为“a.drop（）”。"

#: src/traits/drop.md:44
msgid "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""

#: src/traits/default.md:1
msgid "# The `Default` Trait"
msgstr "# `Default` 特质"

#: src/traits/default.md:3
#, fuzzy
msgid "[`Default`][1] trait provides a default implementation of a trait."
msgstr "[“默认”][1] 特质提供了特质的默认实现。"

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}"
msgstr ""

#: src/traits/default.md:13
msgid ""
"#[derive(Debug)]\n"
"struct Implemented(String);"
msgstr ""

#: src/traits/default.md:16
msgid ""
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}"
msgstr ""

#: src/traits/default.md:22
msgid ""
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");"
msgstr ""

#: src/traits/default.md:26
msgid ""
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");"
msgstr ""

#: src/traits/default.md:32
msgid ""
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}"
msgstr ""

#: src/traits/default.md:40
#, fuzzy
msgid ""
"  * It can be implemented directly or it can be derived via `#[derive(Default)]`.\n"
"  * Derived implementation will produce an instance where all fields are set to their default "
"values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values (e.g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and provides convenience "
"methods that use it."
msgstr ""
"* 它可以直接实现，也可以通过“#[derive（Default）]”派生。\n"
"  * 派生实现将生成一个实例，其中所有字段都设置为其默认值。\n"
"    * 这意味着结构中的所有类型也必须实现“默认”。\n"
"  * 标准 Rust 类型通常使用合理的值实现“默认”（例如“0”、“”“等）。\n"
"  * 部分结构副本在默认情况下工作得很好。\n"
"  * Rust 标准库知道类型可以实现“默认”，并提供使用它的便捷方法。"

#: src/traits/default.md:49
msgid "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr ""

#: src/generics.md:1
#, fuzzy
msgid "# Generics"
msgstr "# 泛型"

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as sorting)\n"
"over the types used in the algorithm."
msgstr ""
"Rust 支持泛型，可以让你抽象算法（比如排序）\n"
"超过算法中使用的类型。"

#: src/generics/data-types.md:1
#, fuzzy
msgid "# Generic Data Types"
msgstr "# 通用数据类型"

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr "您可以使用泛型对具体字段类型进行抽象："

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"
msgstr ""

#: src/generics/data-types.md:12
msgid ""
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:1
#, fuzzy
msgid "# Generic Methods"
msgstr "# 泛型方法"

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "您可以在“impl”块上声明泛型类型："

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);"
msgstr ""

#: src/generics/methods.md:9
msgid ""
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }"
msgstr ""

#: src/generics/methods.md:14
msgid ""
"    // fn set_x(&mut self, x: T)\n"
"}"
msgstr ""

#: src/generics/methods.md:17
msgid ""
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that redundant?\n"
"    * This is because it is a generic implementation section for generic type. They are "
"independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods in this block will only "
"be available for `Point<u32>`."
msgstr ""
"* *Q：* 为什么在“impl<T> Point<T>{}”中指定两次“T”？这不是多余的吗？\n"
"    * 这是因为它是泛型类型的泛型实现部分。它们是独立的通用的。\n"
"    * 这意味着这些方法是为任何“T”定义的。\n"
"    * 可以写 'impl Point<u32> { .. }`.\n"
"      * “Point”仍然是通用的，您可以使用“Point<f64>”，但此块中的方法仅适用于“Point<u32>”。</u32></"
"f64></u32></T></T>"

#: src/generics/trait-bounds.md:1
msgid "# Trait Bounds"
msgstr "# 特质边界"

#: src/generics/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to implement\n"
"some trait, so that you can call this trait's methods."
msgstr ""
"使用泛型时，通常需要实现的类型\n"
"一些特征，所以你可以称之为这个特征的方法。"

#: src/generics/trait-bounds.md:6
#, fuzzy
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "您可以使用“T：特征”或“impl Trait”来执行此操作："

#: src/generics/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"
msgstr ""

#: src/generics/trait-bounds.md:13
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}"
msgstr ""

#: src/generics/trait-bounds.md:19
msgid "// struct NotClonable;"
msgstr ""

#: src/generics/trait-bounds.md:21
msgid ""
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");"
msgstr ""

#: src/generics/trait-bounds.md:26
msgid ""
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:35
#, fuzzy
msgid ""
"Show a `where` clause, students will encounter it when reading code.\n"
"    \n"
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""
"显示一个“where”子句，学生在阅读代码时会遇到它。\n"
"    \n"
"'''生锈，忽略\n"
"fn duplicate（<T>a： T） -> （T， T）\n"
"哪里\n"
"    T：克隆，\n"
"{\n"
"    （a.clone（）， a.clone（））\n"
"}\n"
"```</T>"

#: src/generics/trait-bounds.md:46
#, fuzzy
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of \":\" can be arbitrary, "
"like `Option<T>`.\n"
"    \n"
"</details>"
msgstr ""
"* 如果你有很多参数，它会整理函数签名。\n"
"*它具有其他功能，使其功能更强大。\n"
"    * 如果有人问，额外的功能是“：”左侧的类型可以是任意的，例如“选项<T>”。\n"
"    \n"
"</T>"

#: src/generics/impl-trait.md:1
msgid "# `impl Trait`"
msgstr ""

#: src/generics/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr ""
"与 trait bounds 类似，“impl Trait”语法可以在函数中使用\n"
"参数和返回值："

#: src/generics/impl-trait.md:6 src/generics/trait-objects.md:5 src/generics/trait-objects.md:28
msgid ""
"```rust,editable\n"
"use std::fmt::Display;"
msgstr ""

#: src/generics/impl-trait.md:9
msgid ""
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}"
msgstr ""

#: src/generics/impl-trait.md:13
msgid ""
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/impl-trait.md:19
msgid ""
"* `impl Trait` cannot be used with the `::<>` turbo fish syntax.\n"
"* `impl Trait` allows you to work with types which you cannot name."
msgstr ""

#: src/generics/impl-trait.md:24
#, fuzzy
msgid "The meaning of `impl Trait` is a bit different in the different positions."
msgstr "“impl Trait”的含义在不同的位置上略有不同。"

#: src/generics/impl-trait.md:26
#, fuzzy
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with a trait bound.\n"
"* For a return type, it means that the return type is some concrete type that implements the "
"trait,\n"
"  without naming the type. This can be useful when you don't want to expose the concrete type in "
"a\n"
"  public API."
msgstr ""
"* 对于参数，“impl Trait”就像一个带有特征绑定的匿名泛型参数。\n"
"* 对于返回类型，这意味着返回类型是实现特征的某种具体类型，\n"
"  不命名类型。当您不想在\n"
"  公共 API。"

#: src/generics/impl-trait.md:31
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` type are the same "
"type.\n"
"It would not work for this particular function, as the type we expect as input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, we'd need two\n"
"independent generic parameters.\n"
"    \n"
"</details>"
msgstr ""
"这个例子很棒，因为它使用了两次“impl Display”。它有助于解释\n"
"这里没有任何内容强制它_the same_“impl Display”类型。如果我们使用单个\n"
"“T：显示”，它将强制执行输入“T”和返回“T”类型是同一类型的约束。\n"
"它不适用于此特定函数，因为我们期望作为输入的类型可能不是\n"
"什么“格式！”返回。如果我们想通过“：显示”语法做同样的事情，我们需要两个\n"
"独立的泛型参数。"

#: src/generics/closures.md:1
#, fuzzy
msgid "# Closures"
msgstr "# 闭包"

#: src/generics/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"闭包或 lambda 表达式具有无法命名的类型。然而，他们\n"
"实现特殊['Fn']（https://doc.rust-lang.org/std/ops/trait.Fn.html），\n"
"[“FnMut”]（https://doc.rust-lang.org/std/ops/trait.FnMut.html），以及\n"
"[“FnOnce”]（https://doc.rust-lang.org/std/ops/trait.FnOnce.html）性状："

#: src/generics/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}"
msgstr ""

#: src/generics/closures.md:14
msgid ""
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;"
msgstr ""

#: src/generics/closures.md:18
msgid ""
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""

#: src/generics/closures.md:25
#, fuzzy
msgid "If you have an `FnOnce`, you may only call it once. It might consume captured values."
msgstr "如果您有“FnOnce”，则只能调用一次。它可能会消耗捕获的值。"

#: src/generics/closures.md:27
#, fuzzy
msgid ""
"An `FnMut` might mutate captured values, so you can call it multiple times but not concurrently."
msgstr "“FnMut”可能会改变捕获的值，因此您可以多次调用它，但不能同时调用。"

#: src/generics/closures.md:29
#, fuzzy
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures nothing at all, so it "
"can\n"
"be called multiple times concurrently."
msgstr ""
"“Fn”既不消耗也不改变捕获的值，或者可能根本不捕获任何内容，因此它可以\n"
"同时调用多次。"

#: src/generics/closures.md:32
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever an `FnMut` or "
"`FnOnce`\n"
"is called for."
msgstr ""
"“FnMut”是“FnOnce”的一个子类型。“Fn”是“FnMut”和“FnOnce”的子类型。即您可以使用\n"
"“FnMut”，只要需要“FnOnce”，你可以在任何需要“FnMut”或“FnOnce”的地方使用“Fn”。\n"
"是需要的。"

#: src/generics/closures.md:36
#, fuzzy
msgid "`move` closures only implement `FnOnce`."
msgstr "“移动”闭包仅实现“FnOnce”。"

#: src/generics/monomorphization.md:1
#, fuzzy
msgid "# Monomorphization"
msgstr "# 单态化"

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr "泛型代码根据调用站点转换为非泛型代码："

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "表现得好像你写的一样"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}"
msgstr ""

#: src/generics/monomorphization.md:20
msgid ""
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}"
msgstr ""

#: src/generics/monomorphization.md:25
msgid ""
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you had\n"
"hand-coded the data structures without the abstraction."
msgstr ""
"这是一个零成本的抽象：你得到的结果与你有完全相同的结果\n"
"手动编码数据结构，无需抽象。"

#: src/generics/trait-objects.md:1
msgid "# Trait Objects"
msgstr "# 特质对象"

#: src/generics/trait-objects.md:3
msgid "We've seen how a function can take arguments which implement a trait:"
msgstr "我们已经看到了函数如何接受实现特质的参数："

#: src/generics/trait-objects.md:8
msgid ""
"fn print<T: Display>(x: T) {\n"
"    println!(\"Your value: {x}\");\n"
"}"
msgstr ""

#: src/generics/trait-objects.md:12
msgid ""
"fn main() {\n"
"    print(123);\n"
"    print(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:18
#, fuzzy
msgid "However, how can we store a collection of mixed types which implement `Display`?"
msgstr "但是，我们如何存储实现“显示”的混合类型的集合？"

#: src/generics/trait-objects.md:20
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Hello\"];\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:26
msgid "For this, we need _trait objects_:"
msgstr "为此，我们需要 _特质 objects_："

#: src/generics/trait-objects.md:31
msgid ""
"fn main() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), Box::new(\"Hello\")];\n"
"    for x in xs {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:39
#, fuzzy
msgid "Memory layout after allocating `xs`:"
msgstr "分配“xs”后的内存布局："

#: src/generics/trait-objects.md:41
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                               :\n"
":    xs                     :     :                                               :\n"
":   +-----------+-------+   :     :   +-----+-----+                               :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                               :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                               :\n"
":   | capacity  |     2 |   :     :     | |   | |   +----+----+----+----+----+    :\n"
":   +-----------+-------+   :     :     | |   | '-->| H  | e  | l  | l  | o  |    :\n"
":                           :     :     | |   |     +----+----+----+----+----+    :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                   :\n"
"                                  :     | |   |     +-------------------------+   :\n"
"                                  :     | |   '---->| \"<str as Display>::fmt\" |   :\n"
"                                  :     | |         +-------------------------+   :\n"
"                                  :     | |                                       :\n"
"                                  :     | |   +----+----+----+----+               :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |               :\n"
"                                  :     |     +----+----+----+----+               :\n"
"                                  :     |                                         :\n"
"                                  :     |     +-------------------------+         :\n"
"                                  :     '---->| \"<i32 as Display>::fmt\" |         :\n"
"                                  :           +-------------------------+         :\n"
"                                  :                                               :\n"
"                                  :                                               :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:69
msgid ""
"Similarly, you need a trait object if you want to return different types\n"
"implementing a trait:"
msgstr "同样地，如果你想返回实现一个特质的不同类型，你需要一个特质对象："

#: src/generics/trait-objects.md:72
msgid ""
"```rust,editable\n"
"fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}"
msgstr ""

#: src/generics/trait-objects.md:81
msgid ""
"fn main() {\n"
"    println!(\"{:?}\", numbers(-5).collect::<Vec<_>>());\n"
"    println!(\"{:?}\", numbers(5).collect::<Vec<_>>());\n"
"}"
msgstr ""

#: src/exercises/day-3/morning.md:1
msgid "# Day 3: Morning Exercises"
msgstr "# 第 3 天上午的练习"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library traits and trait objects."
msgstr "我们将设计一个经典的 GUI 库特征和特征对象。"

#: src/exercises/day-3/simple-gui.md:1
msgid "# A Simple GUI Library"
msgstr "# 一个简单的 GUI 库"

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr ""
"让我们使用我们对特征和\n"
"特征对象。"

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "我们的库中将有许多小部件："

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"*“窗口”：有一个“标题”并包含其他小部件。\n"
"* “按钮”：有一个“标签”和一个回调函数，当\n"
"  按钮被按下。\n"
"* “标签”：有一个“标签”。"

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "小部件将实现“小部件”特征，见下文。"

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"复制下面的代码<https://play.rust-lang.org/>，填写缺失的\n"
"“draw_into”方法，以便实现“小部件”特征："

#: src/exercises/day-3/simple-gui.md:18 src/exercises/day-3/safe-ffi-wrapper.md:25
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"
msgstr ""

#: src/exercises/day-3/simple-gui.md:22
msgid ""
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""

#: src/exercises/day-3/simple-gui.md:26 src/exercises/day-3/solutions-morning.md:27
msgid ""
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"
msgstr ""

#: src/exercises/day-3/simple-gui.md:29 src/exercises/day-3/solutions-morning.md:30
msgid ""
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:37 src/exercises/day-3/solutions-morning.md:38
msgid ""
"pub struct Label {\n"
"    label: String,\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:41 src/exercises/day-3/solutions-morning.md:42
msgid ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:49 src/exercises/day-3/solutions-morning.md:50
msgid ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:54 src/exercises/day-3/solutions-morning.md:55
msgid ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:63 src/exercises/day-3/solutions-morning.md:64
msgid ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:68 src/exercises/day-3/solutions-morning.md:69
msgid ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:76 src/exercises/day-3/solutions-morning.md:77
msgid ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:82
msgid ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:87 src/exercises/day-3/simple-gui.md:97
#: src/exercises/day-3/simple-gui.md:107
msgid ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:92
msgid ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:102
msgid ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:112
msgid ""
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:123
msgid "The output of the above program can be something simple like this:"
msgstr "上述程序的输出可以像这样简单："

#: src/exercises/day-3/simple-gui.md:125
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========"
msgstr ""
"```text\n"
"========\n"
"Rust GUI 演示 1.23\n"
"========"

#: src/exercises/day-3/simple-gui.md:130
msgid "This is a small text GUI demo."
msgstr "这是一个小型文本 GUI 演示。"

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"| Click me! |\n"
"```"
msgstr ""
"| 点击我! |\n"
"```"

#: src/exercises/day-3/simple-gui.md:135
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr ""
"如果要绘制对齐的文本，可以使用\n"
"[填充/对齐]（https://doc.rust-lang.org/std/fmt/index.html#fillalignment）\n"
"格式化运算符。特别是，请注意如何用不同的填充\n"
"字符（此处为“/”）以及如何控制对齐方式："

#: src/exercises/day-3/simple-gui.md:140
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:149
msgid "Using such alignment tricks, you can for example produce output like this:"
msgstr "例如，使用这样的对齐技巧，您可以生成如下输出："

#: src/exercises/day-3/simple-gui.md:151
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/error-handling.md:1
msgid "# Error Handling"
msgstr "# 错误处理"

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr "Rust 中的错误处理是使用显式控制流完成的："

#: src/error-handling.md:5
#, fuzzy
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* 可能有错误的函数在其返回类型中列出这一点，\n"
"* 没有例外。"

#: src/error-handling/panics.md:1
#, fuzzy
msgid "# Panics"
msgstr "# 恐慌"

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "如果在运行时发生致命错误，Rust 将触发恐慌："

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panics.md:12
#, fuzzy
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* 死机适用于不可恢复和意外的错误。\n"
"  *恐慌是程序中错误的症状。\n"
"* 如果崩溃不可接受，请使用非恐慌 API（例如“Vec：：get”）。"

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "# Catching the Stack Unwinding"
msgstr "# 捕捉堆栈展开"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid "By default, a panic will cause the stack to unwind. The unwinding can be caught:"
msgstr "默认情况下，恐慌将导致堆栈展开。可以抓住放卷："

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust\n"
"use std::panic;"
msgstr ""

#: src/error-handling/panic-unwind.md:8
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hello!\");\n"
"});\n"
"assert!(result.is_ok());"
msgstr ""

#: src/error-handling/panic-unwind.md:13
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh no!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:19
#, fuzzy
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* 这在服务器中很有用，即使单个服务器也应该继续运行\n"
"  请求崩溃。\n"
"* 如果在“Cargo.toml”中设置了“panic = '中止'”，则这不起作用。"

#: src/error-handling/result.md:1
#, fuzzy
msgid "# Structured Error Handling with `Result`"
msgstr "# 使用“结果”进行结构化错误处理"

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors are\n"
"expected as part of normal operation:"
msgstr ""
"我们已经看到了“结果”枚举。当错误\n"
"预期作为正常运行的一部分："

#: src/error-handling/result.md:6
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"
msgstr ""

#: src/error-handling/result.md:10
msgid ""
"fn main() {\n"
"    let file = File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where an error should never "
"happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but it is worth "
"mentioning. \n"
"    It contains a lot of convenience methods and functions that help functional-style "
"programming. \n"
"    \n"
"</details>"
msgstr ""
"  * 与“选项”一样，成功值位于“结果”中，迫使开发人员\n"
"    显式提取它。这鼓励错误检查。在不应该发生错误的情况下，\n"
"    可以调用“unwrap（）”或“expect（）”，这也是开发人员意图的信号。 \n"
"  * 建议阅读“结果”文档。不是在课程期间，但值得一提。\n"
"    它包含许多方便的方法和函数，有助于函数式编程。"

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "# Propagating Errors with `?`"
msgstr "# 使用“？”传播错误"

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you turn\n"
"the common"
msgstr ""
"try-运算符“？”用于将错误返回给调用方。它让你转弯\n"
"共同点"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "进入更简单"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handing code:"
msgstr "我们可以使用它来简化我们的错误处理代码："

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"
msgstr ""

#: src/error-handling/try-operator.md:25
msgid ""
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);"
msgstr ""

#: src/error-handling/try-operator.md:28
msgid ""
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };"
msgstr ""

#: src/error-handling/try-operator.md:33
msgid "    let mut username = String::new();"
msgstr ""

#: src/error-handling/try-operator.md:35
msgid ""
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"
msgstr ""

#: src/error-handling/try-operator.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:52 src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, empty file, file with "
"username."
msgstr ""
"* “用户名”变量可以是“Ok（字符串）”或“Err（error）”。\n"
"* 使用“fs：：write”调用来测试不同的场景：无文件、空文件、带用户名的文件。"

#: src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
#, fuzzy
msgid "# Converting Error Types"
msgstr "# 转换错误类型"

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid "The effective expansion of `?` is a little more complicated than previously indicated:"
msgstr "“？”的有效扩展比前面指出的要复杂一些："

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "工作原理与"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the\n"
"type returned by the function:"
msgstr ""
"此处的“From：：from”调用表示我们尝试将错误类型转换为\n"
"函数返回的类型："

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};"
msgstr ""

#: src/error-handling/converting-error-types-example.md:9
msgid ""
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:15
msgid "impl Error for ReadUsernameError {}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:17
msgid ""
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {}\", e),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username in {}\", filename),\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:26
msgid ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:32
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types-example.md:55
#, fuzzy
msgid ""
"It is good practice for all error types to implement `std::error::Error`, which requires `Debug` "
"and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too where possible, to "
"make\n"
"life easier for tests and consumers of your library. In this case we can't easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr ""
"所有错误类型最好实现“std：：error：：Error”，这需要“调试”和\n"
"“显示”。在可能的情况下，实现“克隆”和“Eq”通常对他们很有帮助，使\n"
"库的测试和使用者的生活更轻松。在这种情况下，我们不能轻易这样做，因为\n"
"“io：：Error”没有实现它们。"

#: src/error-handling/deriving-error-enums.md:1
msgid "# Deriving Error Enums"
msgstr "# 派生错误枚举"

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create an\n"
"error enum like we did on the previous page:"
msgstr ""
"[thiserror]（https://docs.rs/thiserror/） 板条箱是创建\n"
"错误枚举，就像我们在上一页所做的那样："

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;"
msgstr ""

#: src/error-handling/deriving-error-enums.md:11
msgid ""
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""

#: src/error-handling/deriving-error-enums.md:19
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/deriving-error-enums.md:28 src/error-handling/dynamic-errors.md:25
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the `#[from]` attribute is "
"added).\n"
"It also works for structs."
msgstr ""
"“thiserror”的派生宏自动实现“std：：error：：Error”，并可选择“显示”\n"
"（如果 '#[错误（...）]“属性）和”发件人“（如果添加了”#[from]“属性）。\n"
"它也适用于结构。"

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "它不会影响您的公共 API，这使其对库有好处。"

#: src/error-handling/dynamic-errors.md:1
msgid "# Dynamic Error Types"
msgstr "# 动态错误类型"

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr ""
"有时我们希望允许返回任何类型的错误，而无需编写我们自己的枚举覆盖\n"
"所有不同的可能性。“std：：error：：Error”使这变得容易。"

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;"
msgstr ""

#: src/error-handling/dynamic-errors.md:12
msgid ""
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);"
msgstr ""

#: src/error-handling/dynamic-errors.md:16
msgid ""
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different error cases differently "
"in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` in the public API of "
"a\n"
"library, but it can be a good option in a program where you just want to display the error "
"message\n"
"somewhere."
msgstr ""
"这节省了代码，但放弃了以不同的方式干净地处理不同错误情况的能力\n"
"程序。因此，在公共 API 中使用“Box”通常不是一个好主意<dyn Error>\n"
"库，但在您只想显示错误消息的程序中，它可能是一个不错的选择\n"
"地方。</dyn>"

#: src/error-handling/error-contexts.md:1
msgid "# Adding Context to Errors"
msgstr "# 为错误添加上下文"

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr ""
"广泛使用的[无论如何]（https://docs.rs/anyhow/）板条箱可以帮助您添加\n"
"错误上下文信息，并允许您减少错误\n"
"自定义错误类型："

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"
msgstr ""

#: src/error-handling/error-contexts.md:12
msgid ""
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .context(format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/error-contexts.md:24
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such it's again generally "
"not\n"
"  a good choice for the public API of a library, but is widely used in applications.\n"
"* Actual error type inside of it can be extracted for examination if necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""
"* 'anyhow：：Result' <V>是 'Result' 的类型别名<V, anyhow::error=\"\">。\n"
"* 'anyhow：：Error' 本质上是 'Box' 的包装<dyn Error>器。因此，它通常不是\n"
"  对于库的公共 API 来说是一个不错的选择，但在应用程序中被广泛使用。\n"
"* 如有必要，可以提取其中的实际错误类型进行检查。\n"
"* Go 开发人员可能熟悉 'anyhow：：Result' 提供的功能<T>，因为它提供了\n"
"  与Go中的“（T，错误）”相似的使用模式和人体工程学。</T></dyn></V,></V>"

#: src/testing.md:1
msgid "# Testing"
msgstr "# 测试"

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust 和 Cargo 带有一个简单的单元测试框架："

#: src/testing.md:5
#, fuzzy
msgid "* Unit tests are supported throughout your code."
msgstr "* 整个代码都支持单元测试。"

#: src/testing.md:7
#, fuzzy
msgid "* Integration tests are supported via the `tests/` directory."
msgstr "* 通过“tests/”目录支持集成测试。"

#: src/testing/unit-tests.md:1
msgid "# Unit Tests"
msgstr "# 单元测试"

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "用“#[test]”标记单元测试："

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:13
msgid ""
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:18
msgid ""
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:23
msgid ""
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr "使用“货物测试”查找并运行单元测试。"

#: src/testing/test-modules.md:1
msgid "# Test Modules"
msgstr "# 测试模块"

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr ""
"单元测试通常放在嵌套模块中（在\n"
"[游乐场]（https://play.rust-lang.org/））："

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}"
msgstr ""

#: src/testing/test-modules.md:11
msgid ""
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}"
msgstr ""

#: src/testing/test-modules.md:19
msgid ""
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
#, fuzzy
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* 这使您可以对私人助手进行单元测试。\n"
"* '#[cfg（test）]' 属性仅在您运行 'cargo test' 时才有效。"

#: src/testing/doc-tests.md:1
msgid "# Documentation Tests"
msgstr "# 文档测试"

#: src/testing/doc-tests.md:3
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust 内置了对文档测试的支持："

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
#, fuzzy
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* “///”注释中的代码块会自动被视为 Rust 代码。\n"
"* 该代码将作为“货物测试”的一部分进行编译和执行。\n"
"* 在 [Rust Playground]（https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0） 上测试上面的代码。"

#: src/testing/integration-tests.md:1
msgid "# Integration Tests"
msgstr "# 集成测试"

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr "如果要以客户端身份测试库，请使用集成测试。"

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "在“tests/”下创建一个“.rs”文件："

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;"
msgstr ""

#: src/testing/integration-tests.md:10
msgid ""
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "这些测试只能访问板条箱的公共 API。"

#: src/unsafe.md:1
#, fuzzy
msgid "# Unsafe Rust"
msgstr "# 不安全生锈"

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Rust 语言分为两部分："

#: src/unsafe.md:5
#, fuzzy
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are violated."
msgstr ""
"* **安全锈蚀：**内存安全，没有未定义的行为。\n"
"* **不安全的 Rust：** 如果违反前提条件，可能会触发未定义的行为。"

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to know\n"
"what Unsafe Rust is."
msgstr ""
"在本课程中，我们将看到大部分安全的 Rust，但重要的是要知道\n"
"什么是不安全的锈迹。"

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"不安全代码通常很小且孤立，应谨慎其正确性\n"
"记录。它通常包装在一个安全的抽象层中。"

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "不安全的 Rust 为您提供了五项新功能："

#: src/unsafe.md:16
#, fuzzy
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* 取消引用原始指针。\n"
"* 访问或修改可变静态变量。\n"
"* 访问“联合”字段。\n"
"* 调用“不安全”函数，包括“外部”函数。\n"
"* 实施“不安全”特征。"

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see\n"
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"接下来，我们将简要介绍不安全的功能。有关完整详细信息，请参阅\n"
"[锈书中的第 19.1 章]（https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html）\n"
"和[Rustonomicon]（https://doc.rust-lang.org/nomicon/）。"

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety rules."
msgstr ""
"不安全的 Rust 并不意味着代码不正确。这意味着开发人员有\n"
"关闭编译器安全功能，必须通过以下方式编写正确的代码\n"
"他们自己。这意味着编译器不再执行 Rust 的内存安全规则。"

#: src/unsafe/raw-pointers.md:1
#, fuzzy
msgid "# Dereferencing Raw Pointers"
msgstr "# 取消引用原始指针"

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "创建指针是安全的，但取消引用它们需要“不安全”："

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;"
msgstr ""

#: src/unsafe/raw-pointers.md:9
msgid ""
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = &num as *const i32;"
msgstr ""

#: src/unsafe/raw-pointers.md:12
msgid ""
"    // Safe because r1 and r2 were obtained from references and so are guaranteed to be non-null "
"and\n"
"    // properly aligned, the objects underlying the references from which they were obtained are\n"
"    // live throughout the whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:26
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety requirements of the unsafe\n"
"operations it is doing."
msgstr ""
"最好（也是 Android Rust 风格指南所要求的）为每个角色写一条评论。\n"
"“不安全”块，解释其中的代码如何满足不安全的安全要求\n"
"它正在做的操作。"

#: src/unsafe/raw-pointers.md:30
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"在指针取消引用的情况下，这意味着指针必须是\n"
"[_有效_]（https://doc.rust-lang.org/std/ptr/index.html#safety），即："

#: src/unsafe/raw-pointers.md:33
#, fuzzy
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
"* 指针必须为非空。\n"
" * 指针必须是 _dereferenceable_（在单个已分配对象的边界内）。\n"
" * 对象必须未解除分配。\n"
" * 不得同时访问同一位置。\n"
" * 如果指针是通过强制转换引用获得的，则基础对象必须是活动的，并且没有\n"
"   可以使用基准来访问存储器。"

#: src/unsafe/raw-pointers.md:40
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr "在大多数情况下，指针也必须正确对齐。"

#: src/unsafe/mutable-static-variables.md:1
msgid "# Mutable Static Variables"
msgstr "# 可变静态变量"

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "读取不可变的静态变量是安全的："

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";"
msgstr ""

#: src/unsafe/mutable-static-variables.md:8
msgid ""
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr "然而，由于数据竞争可能发生，读写可变静态变量是不安全的："

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;"
msgstr ""

#: src/unsafe/mutable-static-variables.md:19
msgid ""
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}"
msgstr ""

#: src/unsafe/mutable-static-variables.md:23
msgid ""
"fn main() {\n"
"    add_to_counter(42);"
msgstr ""

#: src/unsafe/mutable-static-variables.md:26
msgid ""
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases where it might make "
"sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working with some C APIs."
msgstr ""
"使用可变静态通常是一个坏主意，但在某些情况下它可能有意义\n"
"在低级“no_std”代码中，例如实现堆分配器或使用某些 C API。"

#: src/unsafe/unions.md:1
#, fuzzy
msgid "# Unions"
msgstr "# 工会"

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "联合就像枚举，但您需要自己跟踪活动字段："

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}"
msgstr ""

#: src/unsafe/unions.md:12
msgid ""
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally "
"needed\n"
"for interacting with C library APIs."
msgstr ""
"在 Rust 中很少需要联合，因为您通常可以使用枚举。偶尔需要它们\n"
"用于与 C 库 API 交互。"

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr ""
"如果您只想将字节重新解释为不同的类型，您可能需要\n"
"['std：：mem：：transmute']（https://doc.rust-lang.org/stable/std/mem/fn.transmute.html）或保险箱\n"
"包装器，例如 ['zerocopy']（https://crates.io/crates/zerocopy） 板条箱。"

#: src/unsafe/calling-unsafe-functions.md:1
msgid "# Calling Unsafe Functions"
msgstr "调用不安全函数"

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions you\n"
"must uphold to avoid undefined behaviour:"
msgstr ""
"如果函数或方法具有额外的前提条件，则可以将其标记为“不安全”\n"
"必须坚持以避免未定义的行为："

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"🗻∈🌏\";"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:10
msgid ""
"    // Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:18
msgid "    println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..7) }));"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:20
msgid ""
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..3) }));\n"
"}"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:25
msgid ""
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:1
msgid "# Writing Unsafe Functions"
msgstr "# 编写不安全函数"

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular conditions to avoid "
"undefined\n"
"behaviour."
msgstr ""
"如果自己的函数需要特定条件以避免未定义，则可以将它们标记为“不安全”\n"
"行为。"

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:18
msgid ""
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:22
msgid ""
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:27
msgid ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid "We wouldn't actually use pointers for this because it can be done safely with references."
msgstr "我们实际上不会为此使用指针，因为它可以通过引用安全地完成。"

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an `unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see what happens."
msgstr ""
"请注意，在没有“不安全”块的不安全函数中允许使用不安全代码。我们可以\n"
"使用“#[拒绝（unsafe_op_in_unsafe_fn）]”禁止此操作。尝试添加它，看看会发生什么。"

#: src/unsafe/extern-functions.md:1
msgid "# Calling External Code"
msgstr "# 调用外部代码"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling\n"
"them is thus unsafe:"
msgstr ""
"来自其他语言的函数可能会违反 Rust 的保证。叫\n"
"因此，它们是不安全的："

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}"
msgstr ""

#: src/unsafe/extern-functions.md:11
msgid ""
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with pointers which might\n"
"violate Rust's memory model, but in general any C function might have undefined behaviour under "
"any\n"
"arbitrary circumstances."
msgstr ""
"这通常只是 extern 函数的问题，这些函数使用指针执行操作，这些指针可能会\n"
"违反了 Rust 的内存模型，但一般来说，任何 C 函数都可能在任何\n"
"任意情况。"

#: src/unsafe/extern-functions.md:25
#, fuzzy
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"此示例中的“C”是 ABI;\n"
"[其他 ABI 也可用]（https://doc.rust-lang.org/reference/items/external-blocks.html）。"

#: src/unsafe/unsafe-traits.md:1
#, fuzzy
msgid "# Implementing Unsafe Traits"
msgstr "# 实现不安全的特征"

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr ""
"与函数一样，如果实现必须保证，您可以将特征标记为“不安全”\n"
"避免未定义行为的特定条件。"

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"例如，“零拷贝”板条箱具有不安全的特征，看起来\n"
"[类似的东西]（https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html）："

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;"
msgstr ""

#: src/unsafe/unsafe-traits.md:13
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/unsafe/unsafe-traits.md:24
msgid ""
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining the requirements for\n"
"the trait to be safely implemented."
msgstr ""
"Rustdoc 上应该有一个“#安全”部分，用于解释特征的要求\n"
"要安全实施的特征。"

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid "The actual safety section for `AsBytes` is rather longer and more complicated."
msgstr "“AsBytes”的实际安全部分相当长，更复杂。"

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "内置的“发送”和“同步”特征不安全。"

#: src/exercises/day-3/afternoon.md:1
msgid "# Day 3: Afternoon Exercises"
msgstr "# 第 3 天：下午练习"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "让我们构建一个用于读取目录内容的安全包装器！"

#: src/exercises/day-3/afternoon.md:7
#, fuzzy
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "看完练习后，可以看看提供的【解决方案】。"

#: src/exercises/day-3/afternoon.md:9
#, fuzzy
msgid "[solution]: solutions-afternoon.md"
msgstr "[解决方案]：solutions-afternoon.md"

#: src/exercises/day-3/safe-ffi-wrapper.md:1
msgid "# Safe FFI Wrapper"
msgstr "# 安全 FFI 包装器"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Rust 非常支持通过_foreign函数调用函数\n"
"interface_（FFI）。我们将使用它来为“libc”构建一个安全的包装器\n"
"您将从 C 语言中用于读取目录文件名的函数。"

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "您需要查阅手册页："

#: src/exercises/day-3/safe-ffi-wrapper.md:9
#, fuzzy
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* ['opendir（3）']（https://man7.org/linux/man-pages/man3/opendir.3.html）\n"
"* ['readdir（3）']（https://man7.org/linux/man-pages/man3/readdir.3.html）\n"
"* ['封闭IR（3）']（https://man7.org/linux/man-pages/man3/closedir.3.html）"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
#, fuzzy
msgid ""
"You will also want to browse the [`std::ffi`] module, particular for [`CStr`]\n"
"and [`CString`] types which are used to hold NUL-terminated strings coming from\n"
"C. The [Nomicon] also has a very useful chapter about FFI."
msgstr ""
"您还需要浏览 ['std：：ffi'] 模块，特别是 ['CStr']\n"
"和 ['CString'] 类型，用于保存来自 NUL 的终止字符串\n"
"C. [Nomicon] 也有关于 FFI 的非常有用的章节。"

#: src/exercises/day-3/safe-ffi-wrapper.md:17
msgid ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:22
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"functions and methods:"
msgstr ""
"复制下面的代码进行<https://play.rust-lang.org/>并填写缺失的内容\n"
"函数和方法："

#: src/exercises/day-3/safe-ffi-wrapper.md:29
msgid ""
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:32 src/exercises/day-3/solutions-afternoon.md:26
#, fuzzy
msgid ""
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }"
msgstr ""
"不透明类型。请参阅 https://doc.rust-lang.org/nomicon/ffi.html。\n"
"    #[repr（C）]\n"
"    pub struct dir {\n"
"        _data： [u8; 0]，\n"
"        _marker： core：：marker：:P hantomData<（*mut u8， core：：marker：:P hantomPinned）>，\n"
"    }"

#: src/exercises/day-3/safe-ffi-wrapper.md:39 src/exercises/day-3/solutions-afternoon.md:33
#, fuzzy
msgid ""
"    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }"
msgstr ""
"按照 readdir（3） 和 /usr/include/x86_64-linux-gnu 中的定义进行布局。\n"
"    #[repr（C）]\n"
"    pub struct dirent {\n"
"        酒吧d_ino： c_long，\n"
"        酒吧d_off： c_ulong，\n"
"        酒吧d_reclen： c_ushort，\n"
"        酒吧d_type： c_char，\n"
"        出版d_name： [c_char; 256]，\n"
"    }"

#: src/exercises/day-3/safe-ffi-wrapper.md:49 src/exercises/day-3/solutions-afternoon.md:43
msgid ""
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:56 src/exercises/day-3/solutions-afternoon.md:50
msgid ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:59
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:65
msgid ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:73
msgid ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:81
msgid ""
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:88
msgid ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-4.md:1
msgid "# Welcome to Day 4"
msgstr "# 欢迎来到第四天"

#: src/welcome-day-4.md:3
msgid "Today we will look at two main topics:"
msgstr "今天我们将看看两个主要主题："

#: src/welcome-day-4.md:5
msgid "* Concurrency: threads, channels, shared state, `Send` and `Sync`."
msgstr "* 并发：线程、通道、共享状态、`发送` 和 `同步`。"

#: src/welcome-day-4.md:7
#, fuzzy
msgid ""
"* Android: building binaries and libraries, using AIDL, logging, and\n"
"  interoperability with C, C++, and Java."
msgstr ""
"* Android：构建二进制文件和库，使用AIDL，日志记录和\n"
"  与 C、C++ 和 Java 的互操作性。"

#: src/welcome-day-4.md:10
#, fuzzy
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try to\n"
"> find a little corner of your code base where we can move some lines of code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something that\n"
"> parses some raw bytes would be ideal."
msgstr ""
"> 我们今天将尝试从您自己的一个项目中调用 Rust。所以尽量\n"
">找到代码库的一个小角落，我们可以在其中移动一些代码行\n"
">锈。依赖项和“异国情调”类型越少越好。的东西\n"
">解析一些原始字节将是理想的。"

#: src/concurrency.md:1
#, fuzzy
msgid "# Fearless Concurrency"
msgstr "# 无畏并发"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr ""
"Rust 完全支持使用带有互斥锁的操作系统线程的并发性和\n"
"渠道。"

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Rust 类型系统在制造许多并发错误中起着重要作用\n"
"编译时错误。这通常被称为_fearless concurrency_，因为\n"
"可以依靠编译器来确保运行时的正确性。"

#: src/concurrency/threads.md:1
msgid "# Threads"
msgstr "# 线程"

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Rust 线程的工作方式类似于其他语言中的线程："

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/concurrency/threads.md:9
msgid ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"
msgstr ""

#: src/concurrency/threads.md:17
msgid ""
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
#, fuzzy
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* 线程都是守护线程，主线程不等待它们。\n"
"* 线程恐慌是相互独立的。\n"
"  * 恐慌可以携带有效载荷，可以用“downcast_ref”解开。"

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"* Notice that the thread is stopped before it reaches 10 — the main thread is\n"
"  not waiting."
msgstr ""
"* 请注意，线程在达到 10 之前停止 — 主线程是\n"
"  不等。"

#: src/concurrency/threads.md:35
#, fuzzy
msgid ""
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for\n"
"  the thread to finish."
msgstr ""
"* 使用 'let handle = thread：：spawn（...）' 和后来的 'handle.join（）' 等待\n"
"  要完成的线程。"

#: src/concurrency/threads.md:38
#, fuzzy
msgid "* Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "* 在线程中触发恐慌，请注意这不会影响“main”。"

#: src/concurrency/threads.md:40
#, fuzzy
msgid ""
"* Use the `Result` return value from `handle.join()` to get access to the panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr ""
"* 使用来自 'handle.join（）' 的 'Result' 返回值来访问恐慌\n"
"  有效载荷。这是谈论[“任何”的好时机。"

#: src/concurrency/threads.md:43
#, fuzzy
msgid "[`Any`]: https://doc.rust-lang.org/std/any/index.html"
msgstr "[“任意”]：https://doc.rust-lang.org/std/any/index.html"

#: src/concurrency/scoped-threads.md:1
msgid "# Scoped Threads"
msgstr "# 作用域线程"

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "普通线程不能从其环境中借用："

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;"
msgstr ""

#: src/concurrency/scoped-threads.md:8 src/concurrency/scoped-threads.md:22
msgid ""
"fn main() {\n"
"    let s = String::from(\"Hello\");"
msgstr ""

#: src/concurrency/scoped-threads.md:11
msgid ""
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:17
#, fuzzy
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "但是，您可以使用 [作用域线程][1] 来实现此目的："

#: src/concurrency/scoped-threads.md:19
msgid ""
"```rust,editable\n"
"use std::thread;"
msgstr ""

#: src/concurrency/scoped-threads.md:25
msgid ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:33
msgid "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"
msgstr ""

#: src/concurrency/scoped-threads.md:35
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* The reason for that is that when the `thread::scope` function completes, all the threads are "
"guaranteed to be joined, so they can return borrowed data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by "
"any number of threads.\n"
"    \n"
"</details>"
msgstr ""
"<details>* 这样做的原因是，当 'thread：：scope' 函数完成时，保证所有线程都连接起来，这样它们就可以"
"返回借用的数据。\n"
"* 正常的 Rust 借用规则适用：您可以按一个线程可变借用，也可以按任意数量的线程不可更改借用。</"
"details>"

#: src/concurrency/channels.md:1
msgid "# Channels"
msgstr "# 信道"

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two parts\n"
"are connected via the channel, but you only see the end-points."
msgstr ""
"Rust 通道由两部分组成：“发送方<T>”和“接收方<T>”。两部分\n"
"通过通道连接，但您只能看到端点。</T></T>"

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;"
msgstr ""

#: src/concurrency/channels.md:10 src/concurrency/channels/unbounded.md:10
msgid ""
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();"
msgstr ""

#: src/concurrency/channels.md:13
msgid ""
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();"
msgstr ""

#: src/concurrency/channels.md:16
msgid ""
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());"
msgstr ""

#: src/concurrency/channels.md:19
msgid ""
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` implement `Clone` "
"(so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the counterpart `Sender` "
"or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc` 代表多生产者，单消费者。`Sender` 和 `SyncSender` 实现了 `Clone`（所以你可以做多个生产"
"者），但 `Receiver` 没有。\n"
"* `send()` 和 `recv()` 返回` Result`。如果它们返回 `Err`，意味着对应的 `Sender` 或 `Receiver` 被放"
"弃，通道被关闭。"

#: src/concurrency/channels/unbounded.md:1
msgid "# Unbounded Channels"
msgstr "# 无界的通道"

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "你可以用 `mpsc::channel()` 得到一个无界的、异步的通道："

#: src/concurrency/channels/unbounded.md:5 src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/concurrency/channels/unbounded.md:13 src/concurrency/channels/bounded.md:13
msgid ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"
msgstr ""

#: src/concurrency/channels/unbounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {}\", msg);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:1
#, fuzzy
msgid "# Bounded Channels"
msgstr "# 有界通道"

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr "有界和同步通道使“发送”阻塞当前线程："

#: src/concurrency/channels/bounded.md:10
msgid ""
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);"
msgstr ""

#: src/concurrency/channels/bounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state.md:1
#, fuzzy
msgid "# Shared State"
msgstr "# 共享状态"

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is\n"
"primarily done via two types:"
msgstr ""
"Rust 使用类型系统来强制共享数据的同步。这是\n"
"主要通过两种类型完成："

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* ['Arc<T>'][1]，原子引用计数为“T”：处理线程和\n"
"  注意在删除最后一个引用时释放“T”，\n"
"* ['互斥<T>'][2]：确保互斥访问“T”值。</T></T>"

#: src/concurrency/shared_state.md:10
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"
msgstr ""

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "# `Arc`"
msgstr "# “弧”"

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid "[`Arc<T>`][1] allows shared read-only access via its `clone` method:"
msgstr "['Arc<T>'][1] 允许通过其“克隆”方法进行共享只读访问：</T>"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;"
msgstr ""

#: src/concurrency/shared_state/arc.md:9
msgid ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/arc.md:20
msgid ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:25
#, fuzzy
msgid "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr "[1]： https://doc.rust-lang.org/std/sync/struct.Arc.html"

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but after that the use of "
"the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* “Arc”代表“Atomic Reference Counted”，是使用原子的“Rc”的线程安全版本\n"
"  操作。\n"
"* “Arc”<T>实现“克隆”，无论“T”是否实现。它实现了“发送”和“同步”iff “T”\n"
"  同时实现它们。\n"
"* 'Arc：：clone（）' 具有执行原子操作的成本，但之后使用\n"
"  “T”是免费的。\n"
"*当心参考周期，“Arc”不使用垃圾回收器来检测它们。\n"
"    * “std：：sync：：Weak”可以提供帮助。</T>"

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "# `Mutex`"
msgstr "# “互斥体”"

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr ""
"['互斥<T>'][1] 确保互斥 _and_ 允许对 'T' 的可变访问\n"
"在只读界面后面：</T>"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;"
msgstr ""

#: src/concurrency/shared_state/mutex.md:9
#, fuzzy
msgid ""
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());"
msgstr ""
"fn main（） {\n"
"    设 p = 点（5， 10）;\n"
"    println！（“p.x = {}”， p.x（））;\n"
"}\n"
"```"

#: src/concurrency/shared_state/mutex.md:13
msgid ""
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/mutex.md:18
msgid ""
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr ""
"注意我们有一个['impl<T: Send> Sync for Mutex<T>'][2]毯子\n"
"实现。</T></T:>"

#: src/concurrency/shared_state/mutex.md:25
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr ""

#: src/concurrency/shared_state/mutex.md:29
#, fuzzy
msgid ""
"<details>\n"
"    \n"
"* `Mutex` in Rust looks like a collection with just one element - the protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The `MutexGuard` ensures that "
"the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes \"poisoned\" to signal "
"that\n"
"      the data it protected might be in an inconsistent state. Calling `lock()` on a poisoned "
"mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error to recover the data\n"
"      regardless."
msgstr ""
"<details>* Rust 中的“互斥”看起来像一个只有一个元素的集合 - 受保护的数据。\n"
"    * 在访问受保护的数据之前，不可能忘记获取互斥锁。\n"
"*您可以通过锁定从“&Mutex”获得“&mut T”。<T>“互斥卫士”确保\n"
"  “&mut T”不会超过所持有的锁。\n"
"* “Mutex”同时实现“发送”<T>和“同步”，因为“T”实现“发送”。\n"
"* 读写锁定对应物 - “RwLock”。\n"
"* 为什么 'lock（）' 返回 'Result'？\n"
"    * 如果持有“互斥体”的线程惊慌失措，则“互斥体”会“中毒”以发出信号\n"
"      它保护的数据可能处于不一致状态。在中毒互斥锁上调用“lock（）”\n"
"      失败并显示 [“中毒错误”]。您可以在错误上调用“into_inner（）”来恢复数据\n"
"      无论。</T></T></details>"

#: src/concurrency/shared_state/mutex.md:43
#, fuzzy
msgid ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html  \n"
"    \n"
"</details>"
msgstr "[“毒药错误”]：https://doc.rust-lang.org/std/sync/struct.PoisonError.html"

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "让我们看看“Arc”和“Mutex”的实际效果："

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};"
msgstr ""

#: src/concurrency/shared_state/example.md:9
msgid ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"
msgstr ""

#: src/concurrency/shared_state/example.md:16
msgid ""
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid ""
"Possible solution:\n"
"    \n"
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"
msgstr ""

#: src/concurrency/shared_state/example.md:29
msgid ""
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"
msgstr ""

#: src/concurrency/shared_state/example.md:32
msgid ""
"    let v2 = v.clone();\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"
msgstr ""

#: src/concurrency/shared_state/example.md:38
msgid ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/example.md:43
msgid "    handle.join().unwrap();"
msgstr ""

#: src/concurrency/shared_state/example.md:45
msgid ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Notable parts:"
msgstr ""

#: src/concurrency/shared_state/example.md:54
#, fuzzy
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another thread. Note `move` "
"was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as possible.\n"
"* We still need to acquire the `Mutex` to print our `Vec`."
msgstr ""
"* “v”被包裹在“Arc”和“Mutex”中，因为它们的关注点是正交的。\n"
"  * 将“互斥体”包装在“Arc”中是在线程之间共享可变状态的常见模式。\n"
"* “v： Arc<_>”需要克隆为“v2”，然后才能移动到另一个线程中。注意 “移动”已添加到 lambda 签名中。\n"
"*引入块以尽可能缩小“锁卫”的范围。\n"
"* 我们仍然需要获取“互斥体”来打印我们的“Vec”。"

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "# `Send` and `Sync`"
msgstr "# “发送”和“同步”"

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid "How does Rust know to forbid shared access across thread? The answer is in two traits:"
msgstr "Rust 如何知道禁止跨线程共享访问？答案有两个特征："

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a thread\n"
"  boundary."
msgstr ""
"* [“发送”][1]：如果可以安全地在线程上移动“T”，则类型“T”为“发送”\n"
"  边界。\n"
"* [“同步”][2]：如果可以安全地在线程中移动“&T”，则类型“T”为“同步”\n"
"  边界。"

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically derive them for your "
"types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement them manually when "
"you\n"
"know it is valid."
msgstr ""
"“发送”和“同步”是[不安全的特征][3]。编译器将自动为您的类型派生它们\n"
"只要它们只包含“发送”和“同步”类型。您也可以在以下情况下手动实现它们：\n"
"知道它是有效的。"

#: src/concurrency/send-sync.md:14
msgid ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"
msgstr ""

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"* One can think of these traits as markers that the type has certain thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  \n"
"</details>"
msgstr ""
"* 可以将这些特征视为类型具有某些线程安全属性的标记。\n"
"* 它们可以作为正常特征在通用约束中使用。"

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "# `Send`"
msgstr "# “发送”"

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid "> A type `T` is [`Send`][1] if it is safe to move a `T` value to another thread."
msgstr "> 如果将“T”值移动到另一个线程是安全的，则类型“T”是[“发送”][1]。"

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will run\n"
"in that thread. So the question is when you can allocate a value in one thread\n"
"and deallocate it in another."
msgstr ""
"将所有权移动到另一个线程的效果是 _destructors_ 将运行\n"
"在该线程中。所以问题是什么时候可以在一个线程中分配一个值\n"
"并将其释放到另一个中。"

#: src/concurrency/send-sync/send.md:9
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"
msgstr ""

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "# `Sync`"
msgstr "# “同步”"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from multiple\n"
"> threads at the same time."
msgstr ""
"> 如果从多个“T”值访问“T”值是安全的，则类型“T”为[“同步”][1]\n"
"同时>线程。"

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "更准确地说，定义是："

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "> “T”是“同步”当且仅当“&T”是“发送”"

#: src/concurrency/send-sync/sync.md:10
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"
msgstr ""

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is thread-safe for shared "
"use, it is also thread-safe to pass references of it across threads."
msgstr ""
"此语句本质上是一种简写方式，表示如果一个类型对于共享使用是线程安全的，那么跨线程传递它的引用也是线"
"程安全的。"

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across multiple threads without "
"the risk of data races or other synchronization issues, so it is safe to move it to another "
"thread. A reference to the type is also safe to move to another thread, because the data it "
"references can be accessed from any thread safely."
msgstr ""
"这是因为如果类型为 Sync，则意味着它可以在多个线程之间共享，而不会有数据争用或其他同步问题的风险，因"
"此可以安全地将其移动到另一个线程。对该类型的引用也可以安全地移动到另一个线程，因为它引用的数据可以"
"从任何线程安全地访问。"

#: src/concurrency/send-sync/examples.md:1
msgid "# Examples"
msgstr "# 示例"

#: src/concurrency/send-sync/examples.md:3
msgid "## `Send + Sync`"
msgstr "## `发送 + 同步`"

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "您遇到的大多数类型都是“发送+同步”："

#: src/concurrency/send-sync/examples.md:7
#, fuzzy
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"* “i8”、“f32”、“布尔”、“字符”、“&str”，...\n"
"* “（T1， T2）”， “[T;N]'， '&[T]'， 'struct { x： T }'， ...\n"
"* “字符串”、“选项”、“<T>Vec<T>”、“盒子<T>”...\n"
"* “Arc<T>”：通过原子引用计数显式线程安全。\n"
"* “互斥<T>”：通过内部锁定显式线程安全。\n"
"* 'AtomicBool'， 'AtomicU8'， ...：使用特殊的原子指令。</T></T></T></T></T>"

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr ""
"当类型参数为\n"
"“发送 + 同步”。"

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "## `Send + !Sync`"
msgstr "## '发送 + ！同步'"

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr ""
"这些类型可以移动到其他线程，但它们不是线程安全的。\n"
"通常是因为内部可变性："

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""
"* 'mpsc：：发件人<T>'\n"
"* 'mpsc：：接收器<T>'\n"
"* “单元格<T>”\n"
"* “参考单元格<T>”</T></T></T></T>"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "## `!Send + Sync`"
msgstr "## `!发送 + 同步'"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr "这些类型是线程安全的，但不能移动到另一个线程："

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on the\n"
"  thread which created them."
msgstr ""
"* “MutexGuard<T>”：使用必须在\n"
"  创建它们的线程。</T>"

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "## `!Send + !Sync`"
msgstr "## `!发送 + ！同步'"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr "这些类型不是线程安全的，不能移动到其他线程："

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* “Rc”<T>：每个“Rc”<T>都有一个对“RcBox”的引用<T>，其中包含一个\n"
"  非原子引用计数。\n"
"* '*const T'， '*mut T'：Rust 假设原始指针可能有特殊的\n"
"  并发注意事项。</T></T></T>"

#: src/exercises/day-4/morning.md:1 src/exercises/day-4/afternoon.md:1
#, fuzzy
msgid "# Exercises"
msgstr "# 练习"

#: src/exercises/day-4/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "让我们练习新的并发技能"

#: src/exercises/day-4/morning.md:5
#, fuzzy
msgid "* Dining philosophers: a classic problem in concurrency."
msgstr "* 餐饮哲学家：并发的经典问题。"

#: src/exercises/day-4/morning.md:7
#, fuzzy
msgid ""
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr ""
"*多线程链接检查器：一个更大的项目，您将使用Cargo来\n"
"  下载依赖项，然后并行检查链接。"

#: src/exercises/day-4/dining-philosophers.md:1
#, fuzzy
msgid "# Dining Philosophers"
msgstr "# 餐饮哲学家"

#: src/exercises/day-4/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "餐饮哲学家问题是并发中的经典问题："

#: src/exercises/day-4/dining-philosophers.md:5
#, fuzzy
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has their\n"
"> own place at the table. There is a fork between each plate. The dish served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will only\n"
"> be available when their two nearest neighbors are thinking, not eating. After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> 五位哲学家同桌用餐。每个哲学家都有自己的\n"
">在餐桌上占有一席之地。每个盘子之间都有一个叉子。供应的菜肴是\n"
">一种意大利面，必须用两把叉子吃。每个哲学家都可以\n"
">只能交替思考和吃饭。而且，哲学家只能吃他们的\n"
">意大利面，当他们有左叉和右叉时。因此，两个分叉只会\n"
">当他们的两个最近的邻居在思考而不是吃饭时，他们有空。后\n"
">个别哲学家吃完饭，他们就会放下两把叉子。"

#: src/exercises/day-4/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) for\n"
"this exercise. Copy the code below to `src/main.rs` file, fill out the blanks,\n"
"and test that `cargo run` does not deadlock:"
msgstr ""
"您将需要一个本地[货物安装]（../../cargo/running-locally.md） for\n"
"这个练习。将下面的代码复制到“src/main.rs”文件，填写空白，\n"
"并测试“货物运行”不会死锁："

#: src/exercises/day-4/dining-philosophers.md:17
msgid ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:23 src/exercises/day-4/solutions-morning.md:28
msgid "struct Fork;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:25
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:32
msgid ""
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:39
msgid ""
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:46 src/exercises/day-4/solutions-morning.md:60
msgid ""
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:49
msgid ""
"fn main() {\n"
"    // Create forks"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:52
msgid "    // Create philosophers"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:54
msgid "    // Make them think and eat"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:56
msgid ""
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:1
msgid "# Multi-threaded Link Checker"
msgstr "# 多线程链接检查器"

#: src/exercises/day-4/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until all\n"
"pages have been validated."
msgstr ""
"让我们利用我们的新知识创建一个多线程链接检查器。它应该\n"
"从网页开始，检查页面上的链接是否有效。它应该\n"
"递归检查同一域上的其他页面并继续执行此操作，直到所有\n"
"页面已经过验证。"

#: src/exercises/day-4/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"为此，您需要一个 HTTP 客户端，例如 ['reqwest'][1]。创建一个新的\n"
"货运项目并将其“要求”为依赖项："

#: src/exercises/day-4/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:17
#, fuzzy
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"> 如果“货物添加”失败并显示“错误：没有这样的子命令”，那么请编辑\n"
"手动>“Cargo.toml”文件。添加下面列出的依赖项。"

#: src/exercises/day-4/link-checker.md:20
#, fuzzy
msgid "You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr "您还需要一种查找链接的方法。为此，我们可以使用['刮刀'][2]："

#: src/exercises/day-4/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] for\n"
"that:"
msgstr ""
"最后，我们需要一些处理错误的方法。我们使用 ['thiserror'][3] 表示\n"
"那："

#: src/exercises/day-4/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:33
#, fuzzy
msgid "The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "“cargo add”调用将更新“Cargo.toml”文件，如下所示："

#: src/exercises/day-4/link-checker.md:35
msgid ""
"```toml\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:42
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr ""
"您现在可以下载起始页。尝试使用小型网站，例如\n"
"“https://www.google.org/”。"

#: src/exercises/day-4/link-checker.md:45
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "你的“src/main.rs”文件应该看起来像这样："

#: src/exercises/day-4/link-checker.md:47
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;"
msgstr ""

#: src/exercises/day-4/link-checker.md:53
msgid ""
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"
msgstr ""

#: src/exercises/day-4/link-checker.md:59
msgid ""
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"
msgstr ""

#: src/exercises/day-4/link-checker.md:65
msgid ""
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: {err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-4/link-checker.md:77
msgid ""
"    Ok(valid_urls)\n"
"}"
msgstr ""

#: src/exercises/day-4/link-checker.md:80
msgid ""
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:90
msgid "Run the code in `src/main.rs` with"
msgstr "运行 `src/main.rs` 中的代码"

#: src/exercises/day-4/link-checker.md:92
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:96
#, fuzzy
msgid "## Tasks"
msgstr "## 任务"

#: src/exercises/day-4/link-checker.md:98
#, fuzzy
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that you\n"
"  don't end up being blocked by the site."
msgstr ""
"* 使用线程并行检查链接：将要检查的 URL 发送到\n"
"  通道，让几个线程并行检查 URL。\n"
"* 扩展它以递归方式从\n"
"  “www.google.org”域。设置100页左右的上限，以便您\n"
"  不要最终被网站阻止。"

#: src/exercises/day-4/link-checker.md:104
msgid ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"
msgstr ""

#: src/android.md:1
msgid "# Android"
msgstr "# 安卓"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr ""
"Rust 支持 Android 上的原生平台开发。这意味着\n"
"你可以在 Rust 中编写新的操作系统服务，以及扩展\n"
"现有服务。"

#: src/android/setup.md:1
msgid "# Setup"
msgstr "# 设置"

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you have\n"
"access to one or create a new one with:"
msgstr ""
"我们将使用Android虚拟设备来测试我们的代码。确保你有\n"
"访问一个或创建一个新的："

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr ""
"请参阅[安卓开发者\n"
"Codelab]（https://source.android.com/docs/setup/start）了解详情。"

#: src/android/build-rules.md:1
msgid "# Build Rules"
msgstr "# 构建规则"

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr "Android 构建系统（Soong）通过许多模块支持 Rust："

#: src/android/build-rules.md:5
msgid ""
"| Module Type       | "
"Description                                                                                        "
"|\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust "
"binary.                                                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and `dylib` "
"variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard Rust test "
"harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging "
"`libfuzzer`.                                                |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that provides an interface for "
"a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library containing Rust bindings to C "
"libraries.              |"
msgstr ""
"| 模块类型           | 描述 |\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | 生成一个 Rust 二进"
"制。                                                                           |\n"
"| `rust_library`    | 产生一个 Rust 库，并提供 `rlib` 和 `dylib` 变体。                           "
"|\n"
"| `rust_ffi`        | 产生一个可由 `cc` 模块使用的 Rust C 库，并提供静态和共享变体。   |\n"
"| `rust_proc_macro` | 产生一个 `proc-macro` 的 Rust 库。这些类似于编译器插件。                    "
"|\n"
"| `rust_test`       | 生成一个 Rust 测试二进制文件，使用标准的 Rust 测试线"
"束。                             |\n"
"| `rust_fuzz`       | 利用 `libfuzzer` 产生一个 Rust fuzz 二进制文"
"件。                                               |\n"
"| `rust_protobuf`   | 生成源代码并产生一个 Rust 库，为特定的 protobuf 提供一个接口。|\n"
"| `rust_bindgen`    | 生成源代码并生成一个 Rust 库，其中包含 Rust 与 C 库的绑定。             |"

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "接下来我们将看看 `rust_binary` 和 `rust_library`。"

#: src/android/build-rules/binary.md:1
msgid "# Rust Binaries"
msgstr "# Rust 二进制文件"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, create\n"
"the following files:"
msgstr ""
"让我们从一个简单的应用程序开始。在 AOSP 签出的根目录中，创建\n"
"以下文件："

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr ""

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr ""

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo."
msgstr ""

#: src/android/build-rules/binary.md:21
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "现在可以生成、推送和运行二进制文件："

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
msgid "# Rust Libraries"
msgstr "# Rust 库"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "您可以使用“rust_library”为 Android 创建一个新的 Rust 库。"

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "在这里，我们声明了对两个库的依赖关系："

#: src/android/build-rules/library.md:7
#, fuzzy
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* “libgreeting”，我们在下面定义，\n"
"* “libtextwrap”，这是一个已经出售的板条箱\n"
"  [“外部/锈蚀/板条箱/”][板条箱]。"

#: src/android/build-rules/library.md:11
#, fuzzy
msgid "[crates]: https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"
msgstr ""
"[板条箱]：https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"
msgstr ""

#: src/android/build-rules/library.md:27
msgid ""
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo."
msgstr ""

#: src/android/build-rules/library.md:39
msgid ""
"use greetings::greeting;\n"
"use textwrap::fill;"
msgstr ""

#: src/android/build-rules/library.md:42
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr ""

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library."
msgstr ""

#: src/android/build-rules/library.md:53
msgid ""
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "您可以像以前一样构建、推送和运行二进制文件："

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:1
msgid "# AIDL"
msgstr "# AIDL"

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in Rust:"
msgstr ""
"[安卓界面定义语言\n"
"（AIDL）]（https://developer.android.com/guide/components/aidl） 在 Rust 中受支持："

#: src/android/aidl.md:6
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* Rust 代码可以调用现有的 AIDL 服务器，\n"
"* 你可以在 Rust 中创建新的 AIDL 服务器。"

#: src/android/aidl/interface.md:1
msgid "# AIDL Interfaces"
msgstr "# AIDL 接口"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "您可以使用 AIDL 接口声明服务的 API："

#: src/android/aidl/interface.md:5
msgid "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr ""

#: src/android/aidl/interface.md:7 src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;"
msgstr ""

#: src/android/aidl/interface.md:10
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:17
msgid "*birthday_service/aidl/Android.bp*:"
msgstr ""

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the vendor\n"
"partition."
msgstr ""
"添加“vendor_available：true”，如果您的 AIDL 文件由供应商中的二进制文件使用\n"
"分区。"

#: src/android/aidl/implementation.md:1
msgid "# Service Implementation"
msgstr "# 服务实现"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "我们现在可以实现 AIDL 服务："

#: src/android/aidl/implementation.md:5
msgid "*birthday_service/src/lib.rs*:"
msgstr ""

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/implementation.md:12
msgid ""
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;"
msgstr ""

#: src/android/aidl/implementation.md:15
msgid "impl binder::Interface for BirthdayService {}"
msgstr ""

#: src/android/aidl/implementation.md:17
msgid ""
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28 src/android/aidl/client.md:37
msgid "*birthday_service/Android.bp*:"
msgstr ""

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
msgid "# AIDL Server"
msgstr "# AIDL 服务"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "最后，我们可以创建一个公开服务的服务器："

#: src/android/aidl/server.md:5
msgid "*birthday_service/src/server.rs*:"
msgstr ""

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"BnBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/server.md:13 src/android/aidl/client.md:12
msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
msgstr ""

#: src/android/aidl/server.md:15
msgid ""
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:1
msgid "# Deploy"
msgstr "# 部署"

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "现在，我们可以构建、推送和启动服务："

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
msgid "In another terminal, check that the service runs:"
msgstr "在另一个终端中，检查服务是否运行："

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:18
msgid "You can also call the service with `service call`:"
msgstr "您也可以使用 `service call` 来调用服务："

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
msgid "# AIDL Client"
msgstr "# AIDL 客户端"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr "最后，我们可以为我们的新服务创建一个 Rust 客户端。"

#: src/android/aidl/client.md:5
msgid "*birthday_service/src/client.rs*:"
msgstr ""

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::"
"IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/client.md:14
msgid ""
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"
msgstr ""

#: src/android/aidl/client.md:19
msgid ""
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"
msgstr ""

#: src/android/aidl/client.md:29
msgid ""
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "请注意，客户端不依赖于“libbirthdayservice”。"

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "在设备上构建、推送和运行客户端："

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:1
msgid "# Changing API"
msgstr "# 更改 API"

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients specify a\n"
"list of lines for the birthday card:"
msgstr ""
"让我们用更多功能扩展 API：我们希望让客户端指定一个\n"
"生日贺卡的行列表："

#: src/android/aidl/changing.md:9
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:1
msgid "# Logging"
msgstr "# 日志"

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) or\n"
"`stdout` (on-host):"
msgstr ""
"您应该使用“日志”板条箱自动记录到“logcat”（在设备上）或\n"
"“标准输出”（在主机上）："

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr ""

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
msgid "_hello_rust_logs/src/main.rs_:"
msgstr ""

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo."
msgstr ""

#: src/android/logging.md:27
msgid "use log::{debug, error, info};"
msgstr ""

#: src/android/logging.md:29
msgid ""
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
msgid "Build, push, and run the binary on your device:"
msgstr "在设备上构建、推送和运行二进制文件："

#: src/android/logging.md:44
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
msgid "The logs show up in `adb logcat`:"
msgstr "日志显示在 `adb logcat` 中："

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:1
msgid "# Interoperability"
msgstr "# 互操作性"

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This means\n"
"that you can:"
msgstr ""
"Rust 对与其他语言的互操作性提供了出色的支持。这意味着\n"
"您可以："

#: src/android/interoperability.md:6
#, fuzzy
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* 从其他语言调用 Rust 函数。\n"
"* 从 Rust 调用用其他语言编写的函数。"

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr ""
"当您用外语调用函数时，我们说您正在使用\n"
"_foreign函数interface_，也称为 FFI。"

#: src/android/interoperability/with-c.md:1
msgid "# Interoperability with C"
msgstr "# 与 C 语言的互操作性"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust 完全支持用 C 语言的调用惯例来链接对象文件。同样地，你可以导出 Rust 函数并从 C 语言中调用它们。"

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "如果你愿意，你可以用手来做："

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"
msgstr ""

#: src/android/interoperability/with-c.md:13
msgid ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr "我们已经在 [安全 FFI 包装器练习](.../.../exercises/day-3/safe-ffi-wrapper.md) 中看到了这个。"

#: src/android/interoperability/with-c.md:23
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr "> 这假定了对目标平台的充分了解。不建议用于生产。"

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "我们接下来将研究更好的选择。"

#: src/android/interoperability/with-c/bindgen.md:1
msgid "# Using Bindgen"
msgstr "# 使用 Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) tool\n"
"can auto-generate bindings from a C header file."
msgstr ""
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) 工具可以从 C 头文件中自动生成"
"绑定关系。"

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "首先创建一个小型 C 库："

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:16
msgid ""
"void print_card(const card* card);\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:25
msgid ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
msgid "_interoperability/bindgen/Android.bp_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr "为该库创建一个封装头文件（在本例中不严格需要）："

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "现在可以自动生成绑定："

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "最后，我们可以在 Rust 程序中使用这些绑定："

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo."
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:84
msgid "use birthday_bindgen::{card, print_card};"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:86
msgid ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr "最后，我们可以运行自动生成的测试来确保绑定正常工作："

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
msgid "# Calling Rust"
msgstr "# 调用 Rust"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "将 Rust 函数和类型导出为 C 很容易："

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]"
msgstr ""

#: src/android/interoperability/with-c/rust.md:11
msgid "use std::os::raw::c_int;"
msgstr ""

#: src/android/interoperability/with-c/rust.md:13
msgid ""
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H"
msgstr ""

#: src/android/interoperability/with-c/rust.md:30
msgid ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"
msgstr ""

#: src/android/interoperability/with-c/rust.md:34
msgid ""
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "我们现在可以从 C 二进制文件中调用它："

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:55
msgid ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol will just be the name "
"of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` 禁用了 Rust 通常的名称处理，所以导出的符号将只是函数的名称。你也可以使用 "
"`#[export_name = \"some_name\"]` 来指定你想要的任何名字。"

#: src/android/interoperability/cpp.md:1
msgid "# With C++"
msgstr "# 用 C++"

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between Rust\n"
"and C++."
msgstr "[CXX crate][1] 使 Rust 和 C++ 之间的安全互操作成为可能。"

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "整体方法如下所示："

#: src/android/interoperability/cpp.md:8
msgid "<img src=\"cpp/overview.svg\">"
msgstr ""

#: src/android/interoperability/cpp.md:10
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr "有关使用它的完整示例，请参阅 [CXX 教程][2]。"

#: src/android/interoperability/cpp.md:12
msgid ""
"[1]: https://cxx.rs/\n"
"[2]: https://cxx.rs/tutorial.html"
msgstr ""

#: src/android/interoperability/java.md:1
msgid "# Interoperability with Java"
msgstr "# 与 Java 的互操作性"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr ""
"Java 可以通过 [Java Native Interface (JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface) 加"
"载共享对象。[`jni` crate](https://docs.rs/jni/) 允许你创建一个兼容的库。"

#: src/android/interoperability/java.md:7
msgid "First, we create a Rust function to export to Java:"
msgstr "首先，我们创建一个 Rust 函数导出到 Java："

#: src/android/interoperability/java.md:9
msgid "_interoperability/java/src/lib.rs_:"
msgstr ""

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo."
msgstr ""

#: src/android/interoperability/java.md:14
msgid ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"
msgstr ""

#: src/android/interoperability/java.md:18
msgid ""
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32 src/android/interoperability/java.md:62
msgid "_interoperability/java/Android.bp_:"
msgstr ""

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
msgid "Finally, we can call this function from Java:"
msgstr "最后，我们可以从 Java 调用这个函数："

#: src/android/interoperability/java.md:45
msgid "_interoperability/java/HelloWorld.java_:"
msgstr ""

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);"
msgstr ""

#: src/android/interoperability/java.md:51
msgid ""
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }"
msgstr ""

#: src/android/interoperability/java.md:55
msgid ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
msgid "Finally, you can build, sync, and run the binary:"
msgstr "最后，您可以构建、同步和运行二进制文件："

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/day-4/afternoon.md:3
msgid ""
"For the last exercise, we will look at one of the projects you work with. Let us\n"
"group up and do this together. Some suggestions:"
msgstr "在最后一个练习中，我们将看一下你工作的一个项目。让我们分组，一起做这个。一些建议："

#: src/exercises/day-4/afternoon.md:6
msgid "* Call your AIDL service with a client written in Rust."
msgstr "* 使用用 Rust 编写的客户端调用您的 AIDL 服务。"

#: src/exercises/day-4/afternoon.md:8
msgid "* Move a function from your project to Rust and call it."
msgstr "* 将一个函数从你的项目移动到 Rust 并调用它。"

#: src/exercises/day-4/afternoon.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"这里没有提供解决方案，因为这是开放式的：它依赖于班上的某个人有一段代码，你可以临时把它变成 Rust。"

#: src/thanks.md:1
msgid "# Thanks!"
msgstr "# 谢谢！"

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and that it\n"
"was useful."
msgstr "_谢谢你阅读综合锈蚀剂🦀！_ 我们希望你喜欢它，并且它是有用的。"

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would love\n"
"to hear from you."
msgstr ""
"我们在制作这个课程的过程中获得了很多乐趣。该课程并不完美，所以如果你发现了任何错误或有改进的想法，"
"请与我们联系 [在 GitHub 上与我们联系](https://github.com/google/comprehensive-rust/discussions)。我"
"们很愿意听到你的意见。"

#: src/other-resources.md:1
msgid "# Other Rust Resources"
msgstr "# 其他 Rust 资源"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr "Rust 社区在网上创造了大量的高质量和免费的资源。"

#: src/other-resources.md:6
msgid "## Official Documentation"
msgstr "## 官方文档"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "Rust 项目提供了许多资源。这些资源涵盖了 Rust 的总体情况："

#: src/other-resources.md:10
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the Rust\n"
"  syntax via a series of examples which showcase different constructs. Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/)：关于 Rust 的经典免费书籍。详细"
"介绍了该语言，并包括一些供人们建立的项目。\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/)：通过一系列展示不同结构的例子，涵盖"
"了 Rust 的语法。有时还包括一些小练习，要求你对例子中的代码进行扩展。\n"
"* [Rust标准库](https://doc.rust-lang.org/std/)：Rust 的标准库的完整文档。\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/)：一本不完整的书，描述了 Rust 的语法和"
"内存模型。"

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "更多的专业指南托管在 Rust 官方网站："

#: src/other-resources.md:24
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/)：包括不安全的 Rust，包括与原始指针和与其他"
"语言的接口（FFI）工作。\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): 涵盖了新的异步编程模"
"型，该模型是在 Rust Book 编写完成后推出的。\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/)：介绍如何在没有操作系统"
"的嵌入式设备上使用 Rust。"

#: src/other-resources.md:33
msgid "## Unofficial Learning Material"
msgstr "## 非官方学习材料"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "一小部分关于 Rust 的其他指南和教程："

#: src/other-resources.md:37
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): a\n"
"  series of small presentations covering both basic and advanced part of the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and the\n"
"  second is a set of 11 modules which covers Rust syntax and basic constructs.\n"
"* [Learn Rust With Entirely Too Many Linked\n"
"  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth\n"
"  exploration of Rust's memory management rules, through implementing a few\n"
"  different types of list structures."
msgstr ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/)：从低级 C 程序员的角度介绍 "
"Rust。\n"
"* [Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/)：从用 C 语言编写"
"固件的开发者的角度介绍 Rust。\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/)：通过与其他语言（如 C、C+"
"+、Java、JavaScript 和 Python）的并列比较，介绍 了Rust 的语法。\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust)：100 多个练习，帮助你学习 Rust。\n"
"* [Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-material/index.html): 一系"
"列的小型演讲，涵盖了 Rust 语言的基础和高级部分。还包括其他主题，如 WebAssembly，以及 async/"
"await。\n"
"* [Rust 初学者系列](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) 和 [迈出 "
"Rust 的第一步](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/)：两个针对新开发者的 "
"Rust 指南。前者是一套 35 个视频，后者是一套 11 个模块，涵盖了 Rust 的语法和基本结构。\n"
"* [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-"
"lists/)：通过实现一些不同类型的列表结构，深入探讨了 Rust 的内存管理规则。"

#: src/other-resources.md:63
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) for\n"
"even more Rust books."
msgstr "更多的 Rust 书籍请见 [Little Book of Rust Books](https://lborb.github.io/book/)。"

#: src/credits.md:1
msgid "# Credits"
msgstr "# 信用"

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of useful\n"
"resources."
msgstr ""
"这里的材料是建立在许多伟大的 Rust 文档资源之上的。请参阅 [其他资源](other-resources.md) 页面，了解"
"有用资源的完整列表。"

#: src/credits.md:7
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache 2.0\n"
"license, please see [`LICENSE`](../LICENSE) for details."
msgstr ""
"Comprehensive Rust 的材料是根据 Apache 2.0 许可证的条款授权的，详情请见 [`LICENSE`](./LICENSE)。"

#: src/credits.md:10
msgid "## Rust by Example"
msgstr ""

#: src/credits.md:12
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr ""
"一些例子和练习是从 [Rust by Example](https://doc.rust-lang.org/rust-by-example/) 复制和改编的。请参"
"阅 `third_party/rust-by-example/` 目录了解详情，包括许可条款。"

#: src/credits.md:17
msgid "## Rust on Exercism"
msgstr ""

#: src/credits.md:19
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the license\n"
"terms."
msgstr ""
"有些练习是从 [Rust on Exercism](https://exercism.org/tracks/rust) 复制和改编的。请参阅 "
"`third_party/rust-on-exercism/` 目录了解详情，包括许可条款。"

#: src/credits.md:24
msgid "## CXX"
msgstr ""

#: src/credits.md:26
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` directory\n"
"for details, including the license terms."
msgstr ""
"与 [C++ 的互操作性](android/interoperability/cpp.md) 部分使用了一个来自 [CXX](https://cxx.rs/) 的图"
"像。请参阅 `third_party/cxx/` 目录了解详情，包括许可条款。"

#: src/exercises/solutions.md:1
msgid "# Solutions"
msgstr "# 解决方案"

#: src/exercises/solutions.md:3
msgid "You will find solutions to the exercises on the following pages."
msgstr "你将在以下几页中找到练习的解决方案。"

#: src/exercises/solutions.md:5
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us know\n"
"if you have a different or better solution than what is presented here."
msgstr ""
"欢迎提出有关解决方案的问题 [在 GitHub 上](https://github.com/google/comprehensive-rust/"
"discussions)。如果你有比这里介绍的不同或更好的解决方案，请告诉我们。"

#: src/exercises/solutions.md:10
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr ""
"> **注意：** 请忽略解决方案中的 `// ANCHOR: label` 和 `// ANCHOR_END: label` 注释。它们的存在是为了"
"让你能够重新使用部分的解决方案作为练习。"

#: src/exercises/day-1/solutions-morning.md:1
msgid "# Day 1 Morning Exercises"
msgstr "# Day 1 Morning Exercises"

#: src/exercises/day-1/solutions-morning.md:3
msgid "## Arrays and `for` Loops"
msgstr "## 数组和 `for` 循环"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "（[回到练习](loops.md)）"

#: src/exercises/day-1/solutions-morning.md:7 src/exercises/day-1/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-morning.md:7 src/exercises/day-2/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-afternoon.md:102 src/exercises/day-3/solutions-morning.md:7
#: src/exercises/day-3/solutions-afternoon.md:7 src/exercises/day-4/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."
msgstr ""

#: src/exercises/day-1/solutions-morning.md:22
msgid ""
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:34
msgid ""
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:42
msgid ""
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:62
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:73
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```\n"
"### Bonus question"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:80
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-of-slices "
"(`&[&[i32]]`) as the input type to transpose and thus make our function handle any size of matrix. "
"However, this quickly breaks down: the return type cannot be `&[&[i32]]` since it needs to own the "
"data you return."
msgstr ""
"这需要更高级的概念。我们似乎可以使用切片（`&[&[i32]]）作为转置的输入类型，从而使我们的函数处理任何"
"大小的矩阵。然而，这很快就失效了：返回类型不能是 `&[&[i32]]`，因为它需要拥有你返回的数据。"

#: src/exercises/day-1/solutions-morning.md:82
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work out-of-the-box "
"either: it's hard to convert from `Vec<Vec<i32>>` to `&[&[i32]]` so now you cannot easily use "
"`pretty_print` either."
msgstr ""
"你可以尝试使用像 `Vec<Vec<i32>>` 这样的东西，但这也不能开箱即用：很难从 `Vec<Vec<i32>>` 转换到 "
"`&[&[i32]]`，所以现在你也不能轻易使用 `pretty_print`。"

#: src/exercises/day-1/solutions-morning.md:84
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::AsRef`][1] trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""
"一旦我们进入特质和泛型，我们就可以使用 [`std::convert::AsRef`][1] 特质来抽象出任何可以作为片断引用"
"的东西。"

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:90
msgid ""
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:103
msgid ""
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
msgid ""
"In addition, the type itself would not enforce that the child slices are of the same length, so "
"such variable could contain an invalid matrix."
msgstr "此外，该类型本身不会强制要求子片的长度相同，所以这种变量可能包含一个无效的矩阵。"

#: src/exercises/day-1/solutions-morning.md:115
msgid "[1]: https://doc.rust-lang.org/std/convert/trait.AsRef.html"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:1
msgid "# Day 1 Afternoon Exercises"
msgstr "# 第 1 天下午的练习"

#: src/exercises/day-1/solutions-afternoon.md:3
msgid "## Designing a Library"
msgstr "## 设计一个库"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](book-library.md))"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:22
msgid ""
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:42
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}\n"
"// ANCHOR_END: setup"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:50
msgid ""
"// ANCHOR: Library_new\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:57
msgid ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:66
msgid ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:75
msgid ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:84
msgid ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}\", book);\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:95
msgid ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        self.books.iter().min_by_key(|book| book.year)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:105
msgid ""
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:113
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"// ANCHOR_END: main"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:129
msgid ""
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:135
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:141
msgid ""
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:146
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:150
msgid ""
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:160
msgid ""
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:165
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:171
msgid ""
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
msgid "# Day 2 Morning Exercises"
msgstr "# 第 2 天上午的练习"

#: src/exercises/day-2/solutions-morning.md:3
msgid "## Points and Polygons"
msgstr "## 点和多边形"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](points-polygons.md))"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:22
msgid ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:30
msgid ""
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:37
msgid ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:41
msgid ""
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:49
msgid ""
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:57
msgid ""
"impl std::ops::Sub for Point {\n"
"    type Output = Self;"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:60
msgid ""
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:68
msgid ""
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:74
msgid ""
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:81
msgid ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:85
msgid ""
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:89
msgid ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:93
msgid ""
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:98
msgid ""
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:109
msgid ""
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:116
msgid ""
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:123
msgid ""
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:127
msgid ""
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:132
msgid ""
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:139
msgid ""
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:145
msgid ""
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:151
msgid ""
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:160
msgid ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:213
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:233 src/exercises/day-2/solutions-afternoon.md:174
msgid ""
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
msgid "# Day 2 Afternoon Exercises"
msgstr "# 第 2 天下午的练习"

#: src/exercises/day-2/solutions-afternoon.md:3
msgid "## Luhn Algorithm"
msgstr "## 卢恩算法"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:22
msgid ""
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:42
msgid ""
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:46
msgid ""
"    sum % 10 == 0\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:49
msgid ""
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {} a valid credit card number? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:58
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:89
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:98
msgid "## Strings and Iterators"
msgstr "## 字符串和迭代器"

#: src/exercises/day-2/solutions-afternoon.md:100
msgid "([back to exercise](strings-iterators.md))"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:117
msgid ""
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:126
msgid ""
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:139
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:166
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
msgid "# Day 3 Morning Exercise"
msgstr "# 第 3 天上午的练习"

#: src/exercises/day-3/solutions-morning.md:3
msgid "## A Simple GUI Library"
msgstr "## 一个简单的 GUI 库"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:22
msgid ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:82
msgid "// ANCHOR_END: setup"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:84
msgid ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:94
msgid ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:102
msgid "        let window_width = self.width();"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:104
msgid ""
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:117
msgid ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:124
msgid ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:131
msgid ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:139
msgid ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:150
msgid ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:157
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
msgid "# Day 3 Afternoon Exercises"
msgstr "# 第 3 天下午的练习"

#: src/exercises/day-3/solutions-afternoon.md:3
msgid "## Safe FFI Wrapper"
msgstr "## 安全的 FFI 封装器"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:22
msgid ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:53
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:60
msgid ""
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: {err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:77
msgid ""
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:97
msgid ""
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:111
msgid ""
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:1
msgid "# Day 4 Morning Exercise"
msgstr "# 第 4 天上午的练习"

#: src/exercises/day-4/solutions-morning.md:3
msgid "## Dining Philosophers"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:22
msgid ""
"// ANCHOR: Philosopher\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:30
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:38
msgid ""
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:47
msgid ""
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:54
msgid ""
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:63
msgid ""
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:67
msgid ""
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:71
msgid ""
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:76
msgid ""
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:83
msgid ""
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:90
msgid ""
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:98
msgid ""
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#, fuzzy
#~ msgid "* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
#~ msgstr "* 与“vec！”不同，不幸的是没有标准的“hashmap！”宏。"

#, fuzzy
#~ msgid ""
#~ "```bob\n"
#~ " Stack                           Heap\n"
#~ ".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
#~ ":                         :     :                                               :\n"
#~ ":    list                 :     :                                               :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":   | Tag    | Cons  |    :     : .->| Tag    | Cons   | .->| Tag    | Nil  |   :\n"
#~ ":   | 0      | 1     |    :     : |  | 0      | 2      | |  | ////// | //// |   :\n"
#~ ":   | 1      | o-----+----+-----+-'  | 1      | o------+-'  | ////// | //// |   :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":                         :     :                                               :\n"
#~ ":                         :     :                                               :\n"
#~ "`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "'''鲍勃\n"
#~ " 堆栈堆\n"
#~ ".- - - - - - - - - - - - -.    .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
#~ ":                         :     :                                               :\n"
#~ "：列表：：：\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":   |标记|缺点|   :     : .->|标记|缺点 | .->|标记|无|  :\n"
#~ ":   |0 |1 |   :     : | |0 |2 | | |////// |//// |  :\n"
#~ ":   |1 |o-----+----+-----+-' |1 |o------+-' |////// |//// |  :\n"
#~ ":   +--------+-------+    :     :    +--------+--------+    +--------+------+   :\n"
#~ ":                         :     :                                               :\n"
#~ ":                         :     :                                               :\n"
#~ "`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "fn main() {\n"
#~ "    outer::public();\n"
#~ "}\n"
#~ "```\n"
#~ "<details>\n"
#~ "    \n"
#~ "* Use the `pub` keyword to make mods public.   \n"
#~ "    \n"
#~ "</details>"
#~ msgstr ""
#~ "fn main（） {\n"
#~ "    outer：:p ublic（）;\n"
#~ "}\n"
#~ "```\n"
#~ "<details>\n"
#~ "    \n"
#~ "* 使用“pub”关键字公开模组。  \n"
#~ "    \n"
#~ "</details>"
