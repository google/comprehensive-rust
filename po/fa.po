msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 🦀\n"
"POT-Creation-Date: 2024-09-11T22:10:46Z\n"
"PO-Revision-Date: 2024-10-17 00:33+0330\n"
"Last-Translator: alix1383 <dev.alix13@gmail.com>\n"
"Language-Team: Persian\n"
"Language: fa\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#: src/SUMMARY.md src/index.md
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "به Comprehensive Rust خوش آمدید 🦀"

#: src/SUMMARY.md src/running-the-course.md
msgid "Running the Course"
msgstr "اجرای دوره"

#: src/SUMMARY.md src/running-the-course/course-structure.md
msgid "Course Structure"
msgstr "مباحث دوره"

#: src/SUMMARY.md src/running-the-course/keyboard-shortcuts.md
msgid "Keyboard Shortcuts"
msgstr "میان‌برهای صفحه کلید"

#: src/SUMMARY.md src/running-the-course/translations.md
msgid "Translations"
msgstr "ترجمه"

#: src/SUMMARY.md src/cargo.md
msgid "Using Cargo"
msgstr "استفاده از cargo"

#: src/SUMMARY.md
msgid "Rust Ecosystem"
msgstr "اکوسیستم Rust"

#: src/SUMMARY.md
msgid "Code Samples"
msgstr "نمونه کد"

#: src/SUMMARY.md
msgid "Running Cargo Locally"
msgstr "اجرای کد به صورت لوکال با cargo"

#: src/SUMMARY.md
msgid "Day 1: Morning"
msgstr "روز ۱: صبح"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1.md src/welcome-day-2.md src/welcome-day-3.md
#: src/welcome-day-4.md src/concurrency/welcome-async.md
msgid "Welcome"
msgstr "خوش آمدید"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1.md src/hello-world.md src/types-and-values.md
#: src/types-and-values/hello-world.md
msgid "Hello, World"
msgstr "سلام, دنیا"

#: src/SUMMARY.md src/hello-world.md src/hello-world/what-is-rust.md
msgid "What is Rust?"
msgstr "زبان Rust چیست؟"

#: src/SUMMARY.md src/hello-world.md src/hello-world/benefits.md
msgid "Benefits of Rust"
msgstr "مزیت‌های زبان Rust"

#: src/SUMMARY.md src/hello-world.md src/hello-world/playground.md
msgid "Playground"
msgstr "Playground"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1.md src/types-and-values.md
msgid "Types and Values"
msgstr "تایپ‌ها و مقادیر"

#: src/SUMMARY.md src/types-and-values.md src/types-and-values/variables.md
msgid "Variables"
msgstr "متغیرها"

#: src/SUMMARY.md src/types-and-values.md src/types-and-values/values.md
msgid "Values"
msgstr "مقادیر"

#: src/SUMMARY.md src/types-and-values.md src/types-and-values/arithmetic.md
msgid "Arithmetic"
msgstr "عملگرهای ریاضی"

#: src/SUMMARY.md src/types-and-values.md src/types-and-values/inference.md
msgid "Type Inference"
msgstr "تعیین تایپ ضمنی"

#: src/SUMMARY.md src/types-and-values.md src/types-and-values/exercise.md
msgid "Exercise: Fibonacci"
msgstr "تمرین: دنباله فیبوناچی"

#: src/SUMMARY.md src/types-and-values/solution.md
#: src/control-flow-basics/solution.md src/tuples-and-arrays/solution.md
#: src/references/solution.md src/user-defined-types/solution.md
#: src/pattern-matching/solution.md src/methods-and-traits/solution.md
#: src/generics/solution.md src/std-types/solution.md
#: src/std-traits/solution.md src/memory-management/solution.md
#: src/smart-pointers/solution.md src/borrowing/solution.md
#: src/lifetimes/solution.md src/iterators/solution.md src/modules/solution.md
#: src/testing/solution.md src/error-handling/solution.md
#: src/unsafe-rust/solution.md
msgid "Solution"
msgstr "راه‌حل"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1.md src/control-flow-basics.md
msgid "Control Flow Basics"
msgstr "مبانی پایه کنترل جریان"

#: src/SUMMARY.md
msgid "`if` Expressions"
msgstr "عبارات `if`"

#: src/SUMMARY.md src/control-flow-basics.md src/control-flow-basics/loops.md
msgid "Loops"
msgstr "حلقه‌ها"

#: src/SUMMARY.md src/control-flow-basics/loops/for.md
msgid "`for`"
msgstr "`for`"

#: src/SUMMARY.md src/control-flow-basics/loops/loop.md
msgid "`loop`"
msgstr "`loop`"

#: src/SUMMARY.md src/control-flow-basics/break-continue.md
msgid "`break` and `continue`"
msgstr "`break` و `continue`"

#: src/SUMMARY.md src/control-flow-basics/break-continue/labels.md
msgid "Labels"
msgstr "برچسب‌ها"

#: src/SUMMARY.md src/control-flow-basics.md
#: src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks and Scopes"
msgstr "بلوک‌ها و محدوده‌ها"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "Scopes and Shadowing"
msgstr "محدوده‌ها و سایه‌گذاری"

#: src/SUMMARY.md src/control-flow-basics.md
#: src/control-flow-basics/functions.md
msgid "Functions"
msgstr "توابع"

#: src/SUMMARY.md src/control-flow-basics.md src/control-flow-basics/macros.md
msgid "Macros"
msgstr "ماکروها"

#: src/SUMMARY.md src/control-flow-basics.md
#: src/control-flow-basics/exercise.md
msgid "Exercise: Collatz Sequence"
msgstr "تمرین: دنباله Collatz"

#: src/SUMMARY.md
msgid "Day 1: Afternoon"
msgstr "روز ۱: بعد از ظهر"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1-afternoon.md src/tuples-and-arrays.md
msgid "Tuples and Arrays"
msgstr "تاپل ها و آرایه ها"

#: src/SUMMARY.md src/tuples-and-arrays.md src/tuples-and-arrays/arrays.md
msgid "Arrays"
msgstr "آرایه‌ها"

#: src/SUMMARY.md src/tuples-and-arrays.md src/tuples-and-arrays/tuples.md
msgid "Tuples"
msgstr "تاپل‌ها"

#: src/SUMMARY.md src/tuples-and-arrays.md src/tuples-and-arrays/iteration.md
msgid "Array Iteration"
msgstr "تکرار ارایه"

#: src/SUMMARY.md src/tuples-and-arrays.md
#: src/tuples-and-arrays/destructuring.md
msgid "Patterns and Destructuring"
msgstr "الگو‌ها و ضدِ ساختارها"

#: src/SUMMARY.md src/tuples-and-arrays.md src/tuples-and-arrays/exercise.md
msgid "Exercise: Nested Arrays"
msgstr "تمرین: آرایه‌های تو در تو"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1-afternoon.md src/references.md
msgid "References"
msgstr "مراجع"

#: src/SUMMARY.md src/references.md src/references/shared.md
msgid "Shared References"
msgstr "مراجع اشتراکی"

#: src/SUMMARY.md src/references.md src/references/exclusive.md
msgid "Exclusive References"
msgstr "مراجع انحصاری"

#: src/SUMMARY.md src/references.md src/references/slices.md
msgid "Slices"
msgstr "برش‌ها"

#: src/SUMMARY.md src/references.md src/references/strings.md
msgid "Strings"
msgstr "رشته‌ها"

#: src/SUMMARY.md src/references.md src/references/exercise.md
msgid "Exercise: Geometry"
msgstr "تمرین: هندسه"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-1-afternoon.md src/user-defined-types.md
msgid "User-Defined Types"
msgstr "تایپ‌های تعریف شده توسط کاربر"

#: src/SUMMARY.md src/user-defined-types.md
#: src/user-defined-types/named-structs.md
msgid "Named Structs"
msgstr "ساختارهای نام‌دار"

#: src/SUMMARY.md src/user-defined-types.md
#: src/user-defined-types/tuple-structs.md
msgid "Tuple Structs"
msgstr "ساختار‌ تاپل‌ها"

#: src/SUMMARY.md src/user-defined-types.md src/user-defined-types/enums.md
#: src/pattern-matching/destructuring-enums.md
msgid "Enums"
msgstr "Enums"

#: src/SUMMARY.md
msgid "Const"
msgstr "Const"

#: src/SUMMARY.md src/user-defined-types.md
msgid "Static"
msgstr "Static"

#: src/SUMMARY.md src/user-defined-types.md src/user-defined-types/aliases.md
msgid "Type Aliases"
msgstr "نام‌های مستعار تایپ"

#: src/SUMMARY.md src/user-defined-types.md src/user-defined-types/exercise.md
msgid "Exercise: Elevator Events"
msgstr "تمرین: رویدادهای آسانسور"

#: src/SUMMARY.md
msgid "Day 2: Morning"
msgstr "روز ۲: صبح"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-2.md src/pattern-matching.md
msgid "Pattern Matching"
msgstr "تطبیق"

#: src/SUMMARY.md src/pattern-matching.md src/pattern-matching/match.md
msgid "Matching Values"
msgstr "تطابق مقادیر"

#: src/SUMMARY.md src/pattern-matching.md
msgid "Destructuring Structs"
msgstr "تخریب ساختارها"

#: src/SUMMARY.md src/pattern-matching.md
msgid "Destructuring Enums"
msgstr "تخریب ساختار Enums"

#: src/SUMMARY.md src/pattern-matching.md
#: src/pattern-matching/let-control-flow.md
msgid "Let Control Flow"
msgstr "کنترل جریان Let"

#: src/SUMMARY.md src/pattern-matching.md src/pattern-matching/exercise.md
msgid "Exercise: Expression Evaluation"
msgstr "تمرین: ارزیابی عبارت"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-2.md src/methods-and-traits.md
msgid "Methods and Traits"
msgstr "متدها و تریت‌ها"

#: src/SUMMARY.md src/methods-and-traits.md src/methods-and-traits/methods.md
msgid "Methods"
msgstr "متدها"

#: src/SUMMARY.md src/methods-and-traits.md src/methods-and-traits/traits.md
msgid "Traits"
msgstr "Traits"

#: src/SUMMARY.md src/methods-and-traits/traits/implementing.md
msgid "Implementing Traits"
msgstr "پیاده سازی Traits"

#: src/SUMMARY.md src/methods-and-traits/traits/supertraits.md
msgid "Supertraits"
msgstr "Supertraits"

#: src/SUMMARY.md src/methods-and-traits/traits/associated-types.md
msgid "Associated Types"
msgstr "تایپ‌های وابسته"

#: src/SUMMARY.md src/methods-and-traits.md src/methods-and-traits/deriving.md
msgid "Deriving"
msgstr "Deriving"

#: src/SUMMARY.md src/methods-and-traits.md
msgid "Exercise: Generic Logger"
msgstr "تمرین: توابع Generic"

#: src/SUMMARY.md
msgid "Day 2: Afternoon"
msgstr "روز دوم: عصر"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-2-afternoon.md src/generics.md
msgid "Generics"
msgstr "Generics"

#: src/SUMMARY.md src/generics.md src/generics/generic-functions.md
msgid "Generic Functions"
msgstr "توابع Generic"

#: src/SUMMARY.md src/generics.md src/generics/generic-data.md
msgid "Generic Data Types"
msgstr "دیتا تایپ‌های Generic"

#: src/SUMMARY.md src/generics/generic-traits.md
msgid "Generic Traits"
msgstr "Generic Traits"

#: src/SUMMARY.md src/generics.md src/generics/trait-bounds.md
msgid "Trait Bounds"
msgstr "Trait Bounds"

#: src/SUMMARY.md src/generics/impl-trait.md
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md src/generics/dyn-trait.md
msgid "`dyn Trait`"
msgstr "`dyn Trait`"

#: src/SUMMARY.md src/generics/exercise.md
msgid "Exercise: Generic `min`"
msgstr "تمرین: Generic `min`"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-2-afternoon.md src/std-types.md
msgid "Standard Library Types"
msgstr "کتابخانه‌ استاندارد تایپ‌ها"

#: src/SUMMARY.md src/std-types.md src/std-types/std.md
msgid "Standard Library"
msgstr "کتابخانه‌ استاندارد"

#: src/SUMMARY.md src/std-types.md src/std-types/docs.md
msgid "Documentation"
msgstr "مستندات"

#: src/SUMMARY.md
msgid "`Option`"
msgstr "`Option`"

#: src/SUMMARY.md src/error-handling/result.md
msgid "`Result`"
msgstr "`Result`"

#: src/SUMMARY.md src/android/aidl/types/primitives.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`String`"
msgstr "`String`"

#: src/SUMMARY.md src/std-types/vec.md
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md src/std-types/hashmap.md src/bare-metal/no_std.md
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md src/std-types.md src/std-types/exercise.md
msgid "Exercise: Counter"
msgstr "تمرین: شمارنده"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-2-afternoon.md src/std-traits.md
msgid "Standard Library Traits"
msgstr "کتابخانه استاندارد Traits"

#: src/SUMMARY.md src/std-traits.md src/std-traits/comparisons.md
#: src/concurrency/welcome-async.md
msgid "Comparisons"
msgstr "مقایسه"

#: src/SUMMARY.md src/std-traits.md src/std-traits/operators.md
msgid "Operators"
msgstr "اپراتورها"

#: src/SUMMARY.md src/std-traits/from-and-into.md
msgid "`From` and `Into`"
msgstr "`From` and `Into`"

#: src/SUMMARY.md src/std-traits.md src/std-traits/casting.md
msgid "Casting"
msgstr "Casting"

#: src/SUMMARY.md src/std-traits/read-and-write.md
msgid "`Read` and `Write`"
msgstr "`Read` and `Write`"

#: src/SUMMARY.md
msgid "`Default`, struct update syntax"
msgstr "`Default`, struct update syntax"

#: src/SUMMARY.md src/std-traits.md src/std-traits/closures.md
msgid "Closures"
msgstr "Closures"

#: src/SUMMARY.md src/std-traits.md src/std-traits/exercise.md
msgid "Exercise: ROT13"
msgstr "تمرین: ROT13"

#: src/SUMMARY.md
msgid "Day 3: Morning"
msgstr "روز ۳: صبح"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-3.md src/memory-management.md
msgid "Memory Management"
msgstr "مدیریت حافظه"

#: src/SUMMARY.md src/memory-management.md src/memory-management/review.md
msgid "Review of Program Memory"
msgstr "بررسی حافظه برنامه"

#: src/SUMMARY.md src/memory-management.md src/memory-management/approaches.md
msgid "Approaches to Memory Management"
msgstr "رویکردهای مدیریت حافظه"

#: src/SUMMARY.md src/memory-management.md src/memory-management/ownership.md
msgid "Ownership"
msgstr "مالکیت"

#: src/SUMMARY.md src/memory-management.md src/memory-management/move.md
msgid "Move Semantics"
msgstr "مفاهیم جابه‌جایی"

#: src/SUMMARY.md
msgid "`Clone`"
msgstr "`Clone`"

#: src/SUMMARY.md src/memory-management.md src/memory-management/copy-types.md
msgid "Copy Types"
msgstr "کپی کردن تایپ‌ها"

#: src/SUMMARY.md
msgid "`Drop`"
msgstr "`Drop`"

#: src/SUMMARY.md src/memory-management.md src/memory-management/exercise.md
msgid "Exercise: Builder Type"
msgstr "تمرین: تایپ‌های سازنده"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-3.md src/smart-pointers.md
msgid "Smart Pointers"
msgstr "اشاره‌گرهای هوشمند"

#: src/SUMMARY.md src/smart-pointers/box.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`Box<T>`"
msgstr "`<Box<T`"

#: src/SUMMARY.md src/smart-pointers/rc.md
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md src/smart-pointers.md src/smart-pointers/trait-objects.md
msgid "Owned Trait Objects"
msgstr "Owned Trait Objects"

#: src/SUMMARY.md src/smart-pointers.md src/smart-pointers/exercise.md
msgid "Exercise: Binary Tree"
msgstr "تمرین: درخت باینری"

#: src/SUMMARY.md
msgid "Day 3: Afternoon"
msgstr "روز ۳: بعد از ظهر"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-3-afternoon.md src/borrowing.md
msgid "Borrowing"
msgstr "قرض‌گیری (Borrowing)"

#: src/SUMMARY.md src/borrowing.md src/borrowing/shared.md
msgid "Borrowing a Value"
msgstr "قرض‌گیری یک مقدار"

#: src/SUMMARY.md src/borrowing.md src/borrowing/borrowck.md
msgid "Borrow Checking"
msgstr "چک کردن قرض"

#: src/SUMMARY.md src/borrowing.md src/borrowing/examples.md
msgid "Borrow Errors"
msgstr "خطاهای قرض‌گیری"

#: src/SUMMARY.md src/borrowing.md src/borrowing/interior-mutability.md
msgid "Interior Mutability"
msgstr "تغییرپذیری داخلی"

#: src/SUMMARY.md src/borrowing.md src/borrowing/exercise.md
msgid "Exercise: Health Statistics"
msgstr "تمرین: آمار سلامتی"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-3-afternoon.md src/lifetimes.md
msgid "Lifetimes"
msgstr "طول‌عمر"

#: src/SUMMARY.md src/lifetimes.md src/lifetimes/lifetime-annotations.md
msgid "Lifetime Annotations"
msgstr "تفسیر‌های طول عمر"

#: src/SUMMARY.md src/lifetimes.md
msgid "Lifetime Elision"
msgstr "حذف طول عمر"

#: src/SUMMARY.md src/lifetimes.md
msgid "Struct Lifetimes"
msgstr "طول عمر ساختارها"

#: src/SUMMARY.md src/lifetimes.md src/lifetimes/exercise.md
msgid "Exercise: Protobuf Parsing"
msgstr "تمرین: تجزیه Protobuf"

#: src/SUMMARY.md
msgid "Day 4: Morning"
msgstr "روز چهارم: صبح"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-4.md src/iterators.md
msgid "Iterators"
msgstr "Iterators"

#: src/SUMMARY.md src/iterators/iterator.md src/bare-metal/no_std.md
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md src/iterators/intoiterator.md
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md
msgid "`FromIterator`"
msgstr "`FromIterator`"

#: src/SUMMARY.md src/iterators.md src/iterators/exercise.md
msgid "Exercise: Iterator Method Chaining"
msgstr "تمرین: روش Iterator Chaining"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-4.md src/modules.md src/modules/modules.md
msgid "Modules"
msgstr "ماژول‌ها"

#: src/SUMMARY.md src/modules.md src/modules/filesystem.md
msgid "Filesystem Hierarchy"
msgstr "سلسله‌ مراتب فایل‌سیستم"

#: src/SUMMARY.md src/modules.md src/modules/visibility.md
msgid "Visibility"
msgstr "قابلیت دید"

#: src/SUMMARY.md
msgid "`use`, `super`, `self`"
msgstr "`use`, `super`, `self`"

#: src/SUMMARY.md src/modules.md src/modules/exercise.md
msgid "Exercise: Modules for a GUI Library"
msgstr "تمرین: ماژولهایی برای کتابخانه رابط کاربری گرافیکی"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-4.md src/testing.md src/chromium/testing.md
msgid "Testing"
msgstr "تست‌کردن"

#: src/SUMMARY.md src/testing.md
msgid "Test Modules"
msgstr "تست‌ ماژول‌ها"

#: src/SUMMARY.md src/testing.md src/testing/other.md
msgid "Other Types of Tests"
msgstr "انواع دیگر تست‌ها"

#: src/SUMMARY.md src/testing.md src/testing/lints.md
msgid "Compiler Lints and Clippy"
msgstr "کامپایلر Lints و Clippy"

#: src/SUMMARY.md src/testing.md src/testing/exercise.md
msgid "Exercise: Luhn Algorithm"
msgstr "تمرین: الگوریتم Luhn"

#: src/SUMMARY.md
msgid "Day 4: Afternoon"
msgstr "روز چهارم: بعد از ظهر"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-4-afternoon.md src/error-handling.md
msgid "Error Handling"
msgstr "مدیریت خطا"

#: src/SUMMARY.md src/error-handling.md src/error-handling/panics.md
msgid "Panics"
msgstr "در مورد Panicها"

#: src/SUMMARY.md src/error-handling.md src/error-handling/try.md
msgid "Try Operator"
msgstr "عملگرد Try"

#: src/SUMMARY.md src/error-handling.md src/error-handling/try-conversions.md
msgid "Try Conversions"
msgstr "این تبدیل‌ها (Conversions) را امتحان کنید"

#: src/SUMMARY.md
msgid "`Error` Trait"
msgstr "`Error` Trait"

#: src/SUMMARY.md src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror` and `anyhow`"
msgstr "`thiserror` و `anyhow`"

#: src/SUMMARY.md
msgid "Exercise: Rewriting with `Result`"
msgstr "تمرین: بازنویسی با `Result`"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/welcome-day-4-afternoon.md src/unsafe-rust.md src/unsafe-rust/unsafe.md
msgid "Unsafe Rust"
msgstr "Rust ناایمن"

#: src/SUMMARY.md src/unsafe-rust.md
msgid "Unsafe"
msgstr "ناایمن"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/dereferencing.md
msgid "Dereferencing Raw Pointers"
msgstr "عدم ارجاع به اشاره‌گرهای خام"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/mutable-static.md
msgid "Mutable Static Variables"
msgstr "متغیرهای ثابت قابل تغییر"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/unions.md
msgid "Unions"
msgstr "نوع داده چندگانه"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/unsafe-functions.md
msgid "Unsafe Functions"
msgstr "توابع ناامن"

#: src/SUMMARY.md src/unsafe-rust.md
msgid "Unsafe Traits"
msgstr "صفات (Traits) ناامن"

#: src/SUMMARY.md src/unsafe-rust.md
msgid "Exercise: FFI Wrapper"
msgstr "تمرین: FFI Wrapper"

#: src/SUMMARY.md src/bare-metal/android.md
msgid "Android"
msgstr "اندروید"

#: src/SUMMARY.md src/android/setup.md src/chromium/setup.md
msgid "Setup"
msgstr "تنظیم"

#: src/SUMMARY.md src/android/build-rules.md
msgid "Build Rules"
msgstr "قوانین ساخت"

#: src/SUMMARY.md
msgid "Binary"
msgstr "باینری"

#: src/SUMMARY.md
msgid "Library"
msgstr "کتابخانه"

#: src/SUMMARY.md src/android/aidl.md
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md src/android/aidl/birthday-service.md
msgid "Birthday Service Tutorial"
msgstr "آموزش سرویس Birthday"

#: src/SUMMARY.md
msgid "Interface"
msgstr "رابط (Interface)"

#: src/SUMMARY.md
msgid "Service API"
msgstr "Service API"

#: src/SUMMARY.md
msgid "Service"
msgstr "سرویس"

#: src/SUMMARY.md
msgid "Server"
msgstr "سرور"

#: src/SUMMARY.md src/android/aidl/example-service/deploy.md
msgid "Deploy"
msgstr "استقرار"

#: src/SUMMARY.md
msgid "Client"
msgstr "کاربر"

#: src/SUMMARY.md src/android/aidl/example-service/changing-definition.md
msgid "Changing API"
msgstr "تغییر دادن API"

#: src/SUMMARY.md
#, fuzzy
msgid "Updating Implementations"
msgstr "پیاده سازی"

#: src/SUMMARY.md
msgid "AIDL Types"
msgstr "AIDL Types"

#: src/SUMMARY.md src/android/aidl/types/primitives.md
msgid "Primitive Types"
msgstr "انواع اولیه"

#: src/SUMMARY.md src/android/aidl/types/arrays.md
msgid "Array Types"
msgstr "تایپ‌های اٰرایه‌ای"

#: src/SUMMARY.md src/android/aidl/types/objects.md
msgid "Sending Objects"
msgstr "Sending Objects"

#: src/SUMMARY.md src/android/aidl/types/parcelables.md
msgid "Parcelables"
msgstr "بسته‌بندی‌ها"

#: src/SUMMARY.md src/android/aidl/types/file-descriptor.md
msgid "Sending Files"
msgstr "ارسال فایل‌ها"

#: src/SUMMARY.md src/android/testing/googletest.md
msgid "GoogleTest"
msgstr "GoogleTest"

#: src/SUMMARY.md src/android/testing/mocking.md
msgid "Mocking"
msgstr "Mocking"

#: src/SUMMARY.md src/android/logging.md src/bare-metal/aps/logging.md
msgid "Logging"
msgstr "لاگ"

#: src/SUMMARY.md src/android/interoperability.md
msgid "Interoperability"
msgstr "قابلیت همکاری"

#: src/SUMMARY.md
msgid "With C"
msgstr "با C"

#: src/SUMMARY.md
msgid "Calling C with Bindgen"
msgstr "فراخوانی C با Bindgen"

#: src/SUMMARY.md
msgid "Calling Rust from C"
msgstr "فراخوانی Rust از C"

#: src/SUMMARY.md src/android/interoperability/cpp.md
msgid "With C++"
msgstr "با <span dir=ltr>C++</span>"

#: src/SUMMARY.md src/android/interoperability/cpp/bridge.md
msgid "The Bridge Module"
msgstr "ماژول پل"

#: src/SUMMARY.md
msgid "Rust Bridge"
msgstr "Rust Bridge"

#: src/SUMMARY.md src/android/interoperability/cpp/generated-cpp.md
msgid "Generated C++"
msgstr "Generated C++"

#: src/SUMMARY.md
msgid "C++ Bridge"
msgstr "پل ++C"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-types.md
msgid "Shared Types"
msgstr "انواع مشترک"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-enums.md
msgid "Shared Enums"
msgstr "Shared Enums"

#: src/SUMMARY.md src/android/interoperability/cpp/rust-result.md
msgid "Rust Error Handling"
msgstr "مدیریت خطا Rust"

#: src/SUMMARY.md src/android/interoperability/cpp/cpp-exception.md
msgid "C++ Error Handling"
msgstr "مدیریت خطا ++C"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "Additional Types"
msgstr "تایپ‌های اضافی"

#: src/SUMMARY.md
msgid "Building for Android: C++"
msgstr "روش Build برای اندروید: ++C"

#: src/SUMMARY.md
msgid "Building for Android: Genrules"
msgstr "روش Build برای اندروید: ژانرها"

#: src/SUMMARY.md
msgid "Building for Android: Rust"
msgstr "روش Build برای اندروید: Rust"

#: src/SUMMARY.md
msgid "With Java"
msgstr "با جاوا"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/exercises/android/morning.md src/exercises/bare-metal/morning.md
#: src/exercises/bare-metal/afternoon.md src/concurrency/welcome.md
#: src/concurrency/sync-exercises.md src/concurrency/welcome-async.md
#: src/concurrency/async-exercises.md
msgid "Exercises"
msgstr "تمرین‌ها"

#: src/SUMMARY.md
msgid "Chromium"
msgstr "Chromium"

#: src/SUMMARY.md src/chromium/cargo.md
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr "مقایسه Chromium و اکوسیستم Cargo"

#: src/SUMMARY.md
msgid "Policy"
msgstr "قواعد"

#: src/SUMMARY.md
#, fuzzy
msgid "Unsafe Code"
msgstr "Rust ناایمن"

#: src/SUMMARY.md src/chromium/build-rules/depending.md
msgid "Depending on Rust Code from Chromium C++"
msgstr "بسته به Rust Code از ++Chromium C"

#: src/SUMMARY.md src/chromium/build-rules/vscode.md
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: src/SUMMARY.md src/exercises/chromium/third-party.md
msgid "Exercise"
msgstr "تمرین‌ها"

#: src/SUMMARY.md src/chromium/testing/rust-gtest-interop.md
msgid "`rust_gtest_interop` Library"
msgstr "`rust_gtest_interop` Library"

#: src/SUMMARY.md src/chromium/testing/build-gn.md
msgid "GN Rules for Rust Tests"
msgstr "قواعد GN برای تست‌های Rust"

#: src/SUMMARY.md src/chromium/testing/chromium-import-macro.md
msgid "`chromium::import!` Macro"
msgstr "`chromium::import!` Macro"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp.md
msgid "Interoperability with C++"
msgstr "قابلیت همکاری با ++C"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Example Bindings"
msgstr "نمونه اتصال‌ها (Bindingها)"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Limitations of CXX"
msgstr "محدودیت‌های CXX"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/error-handling.md
msgid "CXX Error Handling"
msgstr "مدیریت خطا CXX"

#: src/SUMMARY.md
msgid "Error Handling: QR Example"
msgstr "مدیریت خطا: مثال QR"

#: src/SUMMARY.md
msgid "Error Handling: PNG Example"
msgstr "مدیریت خطا: مثال PNG"

#: src/SUMMARY.md
msgid "Using CXX in Chromium"
msgstr "استفاده از CXX در Chromium"

#: src/SUMMARY.md src/chromium/adding-third-party-crates.md
msgid "Adding Third Party Crates"
msgstr "اضافه‌کردن Crateهای شخص ثالث"

#: src/SUMMARY.md
msgid "Configuring Cargo.toml"
msgstr "پیکربندی Cargo.toml"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid "Configuring `gnrt_config.toml`"
msgstr "تنظیمات `gnrt_config.toml`"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Downloading Crates"
msgstr "دانلود کردن Crateها"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Generating `gn` Build Rules"
msgstr "ایجاد قواعد `gn` Build"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Resolving Problems"
msgstr "حل مشکلات"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid "Build Scripts Which Generate Code"
msgstr "ساخت اسکریپت‌هایی که کد را تولید می‌کنند"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr "ساخت اسکریپت‌هایی که ++C را Build می‌کند یا اقدامات دلخواه انجام می‌دهند"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Depending on a Crate"
msgstr "وابسته به یک Crate"

#: src/SUMMARY.md
msgid "Reviews and Audits"
msgstr "بررسی‌ها و ممیزی‌ها"

#: src/SUMMARY.md
msgid "Checking into Chromium Source Code"
msgstr "کد‌های Chromium را بررسی کنید"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid "Keeping Crates Up to Date"
msgstr "به روز نگه داشتن Crateها"

#: src/SUMMARY.md
msgid "Bringing It Together - Exercise"
msgstr "دور همی  تمرین کنید"

#: src/SUMMARY.md src/exercises/chromium/solutions.md
msgid "Exercise Solutions"
msgstr "راه‌حل‌های تمرین"

#: src/SUMMARY.md
msgid "Bare Metal: Morning"
msgstr "با Bare Metal: صبح"

#: src/SUMMARY.md src/bare-metal/no_std.md
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md
msgid "A Minimal Example"
msgstr "یک مثال ساده"

#: src/SUMMARY.md src/bare-metal/no_std.md src/bare-metal/alloc.md
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md src/bare-metal/microcontrollers.md
msgid "Microcontrollers"
msgstr "میکروکنترلرها"

#: src/SUMMARY.md src/bare-metal/microcontrollers/mmio.md
msgid "Raw MMIO"
msgstr "MMIO خام"

#: src/SUMMARY.md
msgid "PACs"
msgstr "PACs"

#: src/SUMMARY.md
msgid "HAL Crates"
msgstr "HAL Crates"

#: src/SUMMARY.md
msgid "Board Support Crates"
msgstr "Board Support Crates"

#: src/SUMMARY.md
msgid "The Type State Pattern"
msgstr "انواع State Pattern"

#: src/SUMMARY.md src/bare-metal/microcontrollers/embedded-hal.md
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "`probe-rs` and `cargo-embed`"
msgstr "probe-rs, cargo-embed"

#: src/SUMMARY.md src/bare-metal/microcontrollers/debugging.md
msgid "Debugging"
msgstr "اشکال یابی (Debugging)"

#: src/SUMMARY.md
msgid "Other Projects"
msgstr "باقی پروژه‌ها"

#: src/SUMMARY.md src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "Compass"
msgstr "قطب‌نما"

#: src/SUMMARY.md src/concurrency/sync-exercises.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises.md
#: src/concurrency/async-exercises/solutions.md
msgid "Solutions"
msgstr "راه حل‌ها"

#: src/SUMMARY.md
msgid "Bare Metal: Afternoon"
msgstr "با Bare Metal:  عصر"

#: src/SUMMARY.md
msgid "Application Processors"
msgstr "پردازنده‌های برنامه"

#: src/SUMMARY.md src/bare-metal/aps/entry-point.md
msgid "Getting Ready to Rust"
msgstr "آماده شدن برای Rust"

#: src/SUMMARY.md
msgid "Inline Assembly"
msgstr "اسمبلی درونی"

#: src/SUMMARY.md
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md
msgid "Let's Write a UART Driver"
msgstr "بریم یک درایور UART بنویسیم"

#: src/SUMMARY.md
msgid "More Traits"
msgstr "صفت‌های بیشتر"

#: src/SUMMARY.md
msgid "A Better UART Driver"
msgstr "یک درایور بهتر UART"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/bitflags.md
msgid "Bitflags"
msgstr "پرچم‌های بیتی (Bitflags)"

#: src/SUMMARY.md
msgid "Multiple Registers"
msgstr "رجیستر‌های چندگانه"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/driver.md
msgid "Driver"
msgstr "درایور"

#: src/SUMMARY.md
msgid "Using It"
msgstr "استفاده از آن"

#: src/SUMMARY.md src/error-handling/result.md src/bare-metal/aps/exceptions.md
msgid "Exceptions"
msgstr "استثناها"

#: src/SUMMARY.md
msgid "Useful Crates"
msgstr "جعبه‌های (Crates) کاربردی"

#: src/SUMMARY.md src/bare-metal/useful-crates/zerocopy.md
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md src/bare-metal/useful-crates/aarch64-paging.md
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/SUMMARY.md src/bare-metal/useful-crates/tinyvec.md
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md src/bare-metal/useful-crates/spin.md
msgid "`spin`"
msgstr "`spin`"

#: src/SUMMARY.md
msgid "`vmbase`"
msgstr "`vmbase`"

#: src/SUMMARY.md
msgid "RTC Driver"
msgstr "درایور RTC"

#: src/SUMMARY.md
msgid "Concurrency: Morning"
msgstr "همزمانی: صبح"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/concurrency/welcome.md src/concurrency/threads.md
msgid "Threads"
msgstr "تردها"

#: src/SUMMARY.md src/concurrency/threads.md src/concurrency/threads/plain.md
msgid "Plain Threads"
msgstr "تردهای ساده"

#: src/SUMMARY.md src/concurrency/threads.md src/concurrency/threads/scoped.md
msgid "Scoped Threads"
msgstr "محدوده تردها"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/concurrency/welcome.md src/concurrency/channels.md
msgid "Channels"
msgstr "کانال‌ها"

#: src/SUMMARY.md src/concurrency/channels.md
#: src/concurrency/channels/senders-receivers.md
msgid "Senders and Receivers"
msgstr "Senders و Receivers"

#: src/SUMMARY.md src/concurrency/channels.md
#: src/concurrency/channels/unbounded.md
msgid "Unbounded Channels"
msgstr "کانال‌های نامحدود"

#: src/SUMMARY.md src/concurrency/channels.md
#: src/concurrency/channels/bounded.md
msgid "Bounded Channels"
msgstr "کانال‌های محدود"

#: src/SUMMARY.md src/concurrency/send-sync.md
msgid "`Send` and `Sync`"
msgstr "`Send` و `Sync`"

#: src/SUMMARY.md src/concurrency/send-sync.md
#: src/concurrency/send-sync/marker-traits.md
msgid "Marker Traits"
msgstr "ویژگی‌های نشانگر"

#: src/SUMMARY.md src/concurrency/send-sync/send.md
msgid "`Send`"
msgstr "`Send`"

#: src/SUMMARY.md src/concurrency/send-sync/sync.md
msgid "`Sync`"
msgstr "`Sync`"

#: src/SUMMARY.md src/concurrency/send-sync.md
#: src/concurrency/send-sync/examples.md
msgid "Examples"
msgstr "مثال‌ها"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/concurrency/welcome.md src/concurrency/shared-state.md
msgid "Shared State"
msgstr "ناحیه‌های مشترک"

#: src/SUMMARY.md src/concurrency/shared-state/arc.md
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md src/concurrency/shared-state/mutex.md
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/SUMMARY.md src/memory-management/review.md
#: src/error-handling/try-conversions.md src/concurrency/shared-state.md
#: src/concurrency/shared-state/example.md
msgid "Example"
msgstr "مثال"

#: src/SUMMARY.md src/concurrency/sync-exercises.md
#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises.md
msgid "Dining Philosophers"
msgstr "فلسفه Dining"

#: src/SUMMARY.md src/concurrency/sync-exercises.md
#: src/concurrency/sync-exercises/link-checker.md
msgid "Multi-threaded Link Checker"
msgstr "جستجوگر پیوند چند تِردی"

#: src/SUMMARY.md
msgid "Concurrency: Afternoon"
msgstr "همزمانی: عصر"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/concurrency/welcome-async.md src/concurrency/async.md
msgid "Async Basics"
msgstr "مبانی Async"

#: src/SUMMARY.md src/concurrency/async/async-await.md
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/SUMMARY.md src/concurrency/async.md src/concurrency/async/futures.md
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md src/concurrency/async.md src/concurrency/async/runtimes.md
msgid "Runtimes"
msgstr "Runtimes"

#: src/SUMMARY.md src/concurrency/async/runtimes/tokio.md
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/async.md src/concurrency/async/tasks.md
#: src/concurrency/async-exercises/chat-app.md
msgid "Tasks"
msgstr "Task"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/concurrency/welcome-async.md src/concurrency/async-control-flow.md
msgid "Channels and Control Flow"
msgstr "کانال‌ها و Control Flow"

#: src/SUMMARY.md src/concurrency/async-control-flow.md
#: src/concurrency/async-control-flow/channels.md
msgid "Async Channels"
msgstr "کانال‌های Async"

#: src/SUMMARY.md src/concurrency/async-control-flow.md
#: src/concurrency/async-control-flow/join.md
msgid "Join"
msgstr "Join"

#: src/SUMMARY.md src/concurrency/async-control-flow.md
#: src/concurrency/async-control-flow/select.md
msgid "Select"
msgstr "Select"

#: src/SUMMARY.md src/running-the-course/course-structure.md
#: src/concurrency/welcome-async.md src/concurrency/async-pitfalls.md
msgid "Pitfalls"
msgstr "Pitfallها"

#: src/SUMMARY.md src/concurrency/async-pitfalls.md
msgid "Blocking the Executor"
msgstr "مسدود کردن Executor"

#: src/SUMMARY.md src/concurrency/async-pitfalls/pin.md
msgid "`Pin`"
msgstr "`Pin`"

#: src/SUMMARY.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-pitfalls/async-traits.md
msgid "Async Traits"
msgstr "صفات Async"

#: src/SUMMARY.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "Cancellation"
msgstr "لغو"

#: src/SUMMARY.md src/concurrency/async-exercises.md
#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "Broadcast Chat Application"
msgstr "پخش برنامه چت"

#: src/SUMMARY.md
msgid "Final Words"
msgstr "کلمات آخر"

#: src/SUMMARY.md src/thanks.md
msgid "Thanks!"
msgstr "سپاس!"

#. Please keep { #glossary } untranslated.
#: src/SUMMARY.md src/glossary.md
msgid "Glossary"
msgstr "واژه‌نامه"

#: src/SUMMARY.md
msgid "Other Resources"
msgstr "منابع دیگر"

#: src/SUMMARY.md src/credits.md
msgid "Credits"
msgstr "اعتبارها"

#: src/index.md
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"

#: src/index.md
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"این یک دوره رایگان Rust است که توسط تیم اندروید در گوگل توسعه یافته است. این "
"این دوره طیف کامل‌ای از Rust را پوشش میدهد, از مباحث پایه تا مباحث  پیشرفته  "
"مانند جنریک و مدیریت خطاها."

#: src/index.md
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"آخرین نسخه از دوره را میتوان در <https://google.github.io/comprehensive-rust/"
"> پیدا کنید. اگر از جای دیگری میخوانید, لطفا برای بروز رسانی‌ها منبع اصلی را "
"نیز بررسی کنید."

#: src/index.md
msgid ""
"The course is available in other languages. Select your preferred language "
"in the top right corner of the page or check the [Translations](running-the-"
"course/translations.md) page for a list of all available translations."
msgstr ""
"این دوره به زبان های دیگر موجود است. زبان مورد نظر خود را در گوشه سمت راست "
"بالای صفحه انتخاب کنید یا صفحه [ترجمه‌ها](running-the-course/translations.md) "
"را برای فهرستی از تمام ترجمه‌های موجود را بررسی کنید."

#: src/index.md
msgid "The course is also available [as a PDF](comprehensive-rust.pdf)."
msgstr "این دوره نیز  [به عنوان یک PDF](comprehensive-rust.pdf)  در دسترس است."

#: src/index.md
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"هدف از این دوره آموزش Rust به شماست. ما فرض می کنیم شما چیزی از درباره Rust "
"نمی دانید :"

#: src/index.md
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "درک جامعی از syntax و زبان Rust به شما می دهد."

#: src/index.md
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr ""
"شما را قادر می سازد تا برنامه های موجود را تغییر دهید و برنامه های جدید را "
"در Rust بنویسید."

#: src/index.md
msgid "Show you common Rust idioms."
msgstr "اصطلاحات رایج Rust را به شما یاد می دهد."

#: src/index.md
msgid "We call the first four course days Rust Fundamentals."
msgstr "ما چهار روز اول دوره را اصول Rust  می نامیم."

#: src/index.md
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""
"با تکیه بر این، از شما دعوت می شود تا به یک یا چند موضوع تخصصی بپردازید:"

#: src/index.md
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md):  یک دوره نیم روزه  استفاده از Rust برای توسعه پلت فرم "
"اندروید (AOSP). این شامل قابلیت همکاری با C، C ++و Java است."

#: src/index.md
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[Chromium](chromium.md):  یک دوره نیم روزه در مورد استفاده از Rust در "
"مرورگرهای مبتنی بر Chromium. این شامل قابلیت همکاری با C ++ و نحوه قرار دادن "
"جعبه های(crates) شخص ثالث در کروم است."

#: src/index.md
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md): یک کلاس تمام روز در مورد استفاده از Rust برای "
"توسعهbare-metal (تعریف شده). هم میکروکنترلرها و هم پردازنده های برنامه پوشش "
"داده شده اند."

#: src/index.md
msgid ""
"[Concurrency](concurrency/welcome.md): a whole-day class on concurrency in "
"Rust. We cover both classical concurrency (preemptively scheduling using "
"threads and mutexes) and async/await concurrency (cooperative multitasking "
"using futures)."
msgstr ""
"[همروندی](concurrency/welcome.md): یک کلاس یک روزه در مورد concurrency در "
"زبان Rust است. ما هر دو مورد concurrency کلاسیک (زمانبندی preemptively با "
"استفاده از threadها و mutexها ) و async/await concurrency (multitasking "
"مشارکتی) با استفاده از futures را پوشش خواهیم داد."

#: src/index.md
msgid "Non-Goals"
msgstr "اهداف خارج از این دوره"

#: src/index.md
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"زبان Rust, یک زبان بزرگ است و ما نمی‌توانیم طی چند روز همه موارد را پوشش دهیم."
"چندتا از اهداف خارج از این دوره عبارتند از:"

#: src/index.md
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"برای آموزش چگونه‌گی توسعه Macro ها: لطفا [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) و [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) را برسی کنید."

#: src/index.md
msgid "Assumptions"
msgstr "فرض می‌شود"

#: src/index.md
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"این دوره فرض می‌کند که شما دانش برنامه‌نویسی دارید. Rust یک زبان استاتیک تایپ "
"است و ما گاهی اوقات زبان Rust را با C و <span dir=ltr>C++</span> مقایسه می "
"کنیم تا رویکرد‌های Rust را بهتر توضیح دهیم."

#: src/index.md
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"اگر می‌دانید چگونه به زبانی با دینامیک تایپ مانند پایتون یا جاوا اسکریپت "
"برنامه‌نویسی کنید می‌توانید به خوبی این روش را دنبال کنید."

#: src/index.md
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"این یک نمونه از _speaker note_ هست. ما از این‌ها استفاده خواهیم کرد تا تا "
"اطلاعات بیشتری را ارائه دهیم.. این مورد می‌تواند شامل نکات کلیدی باشد که مدرس "
"باید آن را پوشش دهد و همچنین پاسخ به سوالات رایجی که در کلاس مطرح می شود."

#: src/running-the-course.md src/running-the-course/course-structure.md
msgid "This page is for the course instructor."
msgstr "این صفحه برای مدرس دوره است."

#: src/running-the-course.md
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"اینجا بخشی از پیشینه نحوه برگزاری دوره توسط گوگل به صورت درون سازمانی است."

#: src/running-the-course.md
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""
"ما معمولا کلاس‌ها را از ساعت ۱۰:۰۰ تا ۱۶:۰۰ برگزار می کنیم، با یک ساعت "
"استراحت ناهار در میانه روز با این رویه ۲.۵ ساعت برای کلاس صبح و ۲.۵ ساعت "
"برای کلاس بعدازظهر باقی می‌گذارد. توجه داشته باشید که این فقط یک توصیه است: "
"شما می‌توانید ۳ ساعت از جلسه صبح را صرف تمرین بیشتر برای افراد کنید. نکته "
"منفی این کار این است که با جلسه طولانی تر افراد بعد از ۶ ساعت کلاس در بعد از "
"ظهر خیلی خسته میشوند."

#: src/running-the-course.md
msgid "Before you run the course, you will want to:"
msgstr "قبل از اجرای دوره، شما می‌خواهید:"

#: src/running-the-course.md
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"با مطالب دوره آشنا شوید. ما یادداشت های سخنرانی را برای کمک به برجسته کردن "
"نکات کلیدی گنجانده‌ایم (لطفا با مشارکت بیشتر در یادداشت‌های سخنران به ما کمک "
"کنید!). هنگام ارائه، باید مطمئن شوید که یادداشت‌های سخنران را در یک پنجره "
"پاپ‌آپ باز کنید (روی پیوند با یک فلش کوچک در کنار «یادداشت‌های سخنران» کلیک "
"کنید). به این ترتیب یک صفحه نمایش تمیز برای ارائه به کلاس خواهید داشت."

#: src/running-the-course.md
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"در مورد زمان‌بندی دوره تصمیم بگیرید. از آنجایی که دوره حداقل سه روز کامل طول "
"می‌کشد، توصیه می‌کنیم که دوره را در دو هفته برنامه‌ریزی کنید. شرکت کنندگان در "
"دوره گفته‌اند که داشتن فاصله‌ای در دوره مفید است، زیرا به آنها کمک می‌کند تا "
"تمام اطلاعاتی را که به آنها می‌دهیم پردازش کنند."

#: src/running-the-course.md
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"یک اتاق بزرگ برای حضور شرکت کنندگان پیدا کنید. ما کلاسی با گنجایش ۱۵ الی ۲۵ "
"نفر را پیشنهاد می‌کنیم. افراد در این تعداد می‌توانند به راحتی سوال بپرسند --- "
"همچنین مدرس وقت کافی برای پاسخ‌ دادن به سوالات را نیز دارد. مطمئن شوید که "
"اتاق مورد نظر  _میز_ برای شما و دانشجویان دارد: شما همگی نیاز دارید که "
"بتونید بشنید و با لپتاپ های خود کار کنید. به خصوص شما به عنوان مدرس کلی live-"
"coding انجام خواهید داد پس صرفا یک میز بدون جا برای لپتاپ برای شما مناسب "
"نخواهد بود."

#: src/running-the-course.md
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"در روز برگزاری دوره، کمی زودتر به کلاس بیایید تا همه چیز را آماده کنید. ما "
"توصیه می کنیم مستقیماً با استفاده از `mdbook serve`را در لپتاپ خود اجرا کنید. "
"([راهنمای نصب](https://github.com/google/comprehensive-rust#building) را "
"ببنیید). با این کار عملکرد بدون تاخیر در هنگام تغییر صفحات تضمین می شود. "
"استفاده از لپ تاپ همچنین به شما امکان می دهد اشتباهات تایپی ا در صورت مشاهده "
"شما یا شرکت کنندگان در دوره اصلاح کنید."

#: src/running-the-course.md
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"بگذارید افراد خودشان یا در گروه های کوچک تمرینات را حل کنند. مابه طور معمول "
"۳۰ الی ۴۵ دقیقه را برای تمرینات در صبح و بعد‌از‌ظهر (از جمله زمان بررسی راه حل "
"ها ) صرف می‌کنیم. حتما از افراد بخواهید که اگر گیر کرده‌اند یا چیزی وجود دارد "
"که می‌توانید به آنها کمک کنید. وقتی که می‌بینید چندین نفر مشکل یکسانی دارند, "
"خطاب به کلاس راه‌حل را پیشنهاد دهید؛ به عنوان مثال، با نشان دادن جایی که "
"می‌توانند اطلاعات مربوطه را در کتابخانه استاندارد (standard library) پیدا "
"کنند."

#: src/running-the-course.md
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"همش همین بود! در تدریس دوره موفق باشید! امیدواریم که برای شما هم به همان "
"اندازه که برای ما لذت‌بخش بوده، لذت‌بخش باشد!"

#: src/running-the-course.md
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"لطفاً [بازخورد خود را ارائه دهید](https://github.com/google/comprehensive-"
"rust/discussions/86) تا در آینده بتوانیم به بهبود دوره ادامه دهیم. ما دوست "
"داریم بشنویم چه چیزی برای شما خوب بوده و چه چیزی می تواند بهتر شود. همینطور "
"شما دانش‌آموزان نیز بسیار خوش آمدید  [برای ما بازخورد ارسال کنید](https://"
"github.com/google/comprehensive-rust/discussions/100) !"

#: src/running-the-course/course-structure.md
msgid "Rust Fundamentals"
msgstr "مبانی Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""
"سه روز اول دوره را [مبانی Rust ](../welcome-day-1.md)تشکیل میدهند. این این "
"سه روز با سرعت بالایی پیش می‌روند و ما موارد زیادی را پوشش می‌دهیم!"

#: src/running-the-course/course-structure.md
msgid "Course schedule:"
msgstr "مباحث دوره:"

#: src/running-the-course/course-structure.md
msgid "Day 1 Morning (2 hours and 5 minutes, including breaks)"
msgstr "روز ۱ صبح (۲ ساعت و ۵ دقیقه با احتساب استراحت)"

#: src/running-the-course/course-structure.md src/welcome-day-1.md
#: src/welcome-day-1-afternoon.md src/welcome-day-2.md
#: src/welcome-day-2-afternoon.md src/welcome-day-3.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4.md
#: src/welcome-day-4-afternoon.md src/concurrency/welcome.md
#: src/concurrency/welcome-async.md
msgid "Segment"
msgstr "بخش"

#: src/running-the-course/course-structure.md src/welcome-day-1.md
#: src/hello-world.md src/types-and-values.md src/control-flow-basics.md
#: src/welcome-day-1-afternoon.md src/tuples-and-arrays.md src/references.md
#: src/user-defined-types.md src/welcome-day-2.md src/pattern-matching.md
#: src/methods-and-traits.md src/welcome-day-2-afternoon.md src/generics.md
#: src/std-types.md src/std-traits.md src/welcome-day-3.md
#: src/memory-management.md src/smart-pointers.md
#: src/welcome-day-3-afternoon.md src/borrowing.md src/lifetimes.md
#: src/welcome-day-4.md src/iterators.md src/modules.md src/testing.md
#: src/welcome-day-4-afternoon.md src/error-handling.md src/unsafe-rust.md
#: src/concurrency/welcome.md src/concurrency/threads.md
#: src/concurrency/channels.md src/concurrency/send-sync.md
#: src/concurrency/shared-state.md src/concurrency/sync-exercises.md
#: src/concurrency/welcome-async.md src/concurrency/async.md
#: src/concurrency/async-control-flow.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-exercises.md
msgid "Duration"
msgstr "مدت زمان"

#: src/running-the-course/course-structure.md src/welcome-day-1.md
#: src/types-and-values.md src/control-flow-basics.md src/tuples-and-arrays.md
#: src/user-defined-types.md src/generics.md src/std-types.md src/std-traits.md
#: src/memory-management.md src/smart-pointers.md src/lifetimes.md
#: src/iterators.md src/modules.md src/testing.md src/error-handling.md
#: src/unsafe-rust.md src/concurrency/shared-state.md
#: src/concurrency/async-control-flow.md src/concurrency/async-pitfalls.md
msgid "5 minutes"
msgstr "۵ دقیقه"

#: src/running-the-course/course-structure.md src/welcome-day-1.md
#: src/types-and-values.md src/control-flow-basics.md src/tuples-and-arrays.md
#: src/references.md src/user-defined-types.md src/methods-and-traits.md
#: src/modules.md src/concurrency/welcome.md src/concurrency/threads.md
#: src/concurrency/shared-state.md
msgid "15 minutes"
msgstr "۱۵ دقیقه"

#: src/running-the-course/course-structure.md src/welcome-day-1.md
#: src/welcome-day-4.md
msgid "40 minutes"
msgstr "۴۰ دقیقه"

#: src/running-the-course/course-structure.md
msgid "Day 1 Afternoon (2 hours and 35 minutes, including breaks)"
msgstr "روز ۱ بعد از ظهر (۲ ساعت و ۳۵ دقیقه،شامل وقت استراحت)"

#: src/running-the-course/course-structure.md src/welcome-day-1-afternoon.md
msgid "35 minutes"
msgstr "۳۵ دقیقه"

#: src/running-the-course/course-structure.md src/welcome-day-1-afternoon.md
#: src/welcome-day-3.md src/welcome-day-3-afternoon.md
#: src/concurrency/welcome-async.md
msgid "55 minutes"
msgstr "۵۵ دقیقه"

#: src/running-the-course/course-structure.md src/welcome-day-1-afternoon.md
#: src/welcome-day-2.md src/welcome-day-3-afternoon.md
msgid "50 minutes"
msgstr "۵۰ دقیقه"

#: src/running-the-course/course-structure.md
msgid "Day 2 Morning (2 hours and 10 minutes, including breaks)"
msgstr "روز ۲ صبح (۲ ساعت و ۱۰ دقیقه، شامل وقت استراحت)"

#: src/running-the-course/course-structure.md src/hello-world.md
#: src/types-and-values.md src/control-flow-basics.md src/tuples-and-arrays.md
#: src/welcome-day-2.md src/methods-and-traits.md src/std-types.md
#: src/welcome-day-3.md src/borrowing.md src/welcome-day-4.md src/modules.md
#: src/testing.md src/error-handling.md
msgid "3 minutes"
msgstr "۳ دقیقه"

#: src/running-the-course/course-structure.md src/welcome-day-2.md
#: src/welcome-day-2-afternoon.md src/welcome-day-3.md
#: src/welcome-day-4-afternoon.md
msgid "1 hour"
msgstr "۱ ساعت"

#: src/running-the-course/course-structure.md
msgid "Day 2 Afternoon (3 hours and 15 minutes, including breaks)"
msgstr "روز ۲ بعد از ظهر (۴ ساعت و ۵ دقیقه، شامل وقت استراحت)"

#: src/running-the-course/course-structure.md src/welcome-day-2-afternoon.md
#: src/welcome-day-4.md
msgid "45 minutes"
msgstr "۴۵ دقیقه"

#: src/running-the-course/course-structure.md src/welcome-day-2-afternoon.md
#: src/concurrency/welcome.md src/concurrency/welcome-async.md
msgid "1 hour and 10 minutes"
msgstr "۱ ساعت و ۱۰ دقیفه"

#: src/running-the-course/course-structure.md
msgid "Day 3 Morning (2 hours and 20 minutes, including breaks)"
msgstr "روز ۳ صبح (۲ ساعت و ۲۰ دقیقه، شامل وقت استراحت)"

#: src/running-the-course/course-structure.md
msgid "Day 3 Afternoon (1 hour and 55 minutes, including breaks)"
msgstr "روز ۳ بعدازظهر(۱ ساعت و ۵۵ دقیقه، شامل وقت اسراحت)"

#: src/running-the-course/course-structure.md
msgid "Day 4 Morning (2 hours and 40 minutes, including breaks)"
msgstr "روز ۴ صبح (۲ ساعت و ۴۰ دقیقه، شامل وقت استراحت)"

#: src/running-the-course/course-structure.md
msgid "Day 4 Afternoon (2 hours and 15 minutes, including breaks)"
msgstr "روز ۴ بعدازظهر (۲ ساعت و ۱۰ دقیقه، شامل وقت استراحت)"

#: src/running-the-course/course-structure.md src/welcome-day-4-afternoon.md
msgid "1 hour and 5 minutes"
msgstr "ساعت و ۵ دقیقه"

#: src/running-the-course/course-structure.md
msgid "Deep Dives"
msgstr "عمیق تر شدن"

#: src/running-the-course/course-structure.md
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""
"علاوه بر کلاس 4 روزه Rust Fundamentals، موضوعات تخصصی تری را نیز پوشش می "
"دهیم:"

#: src/running-the-course/course-structure.md
msgid "Rust in Android"
msgstr "Rust در اندروید"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"در [Rust در اندروید](../android.md) توی دوره  یک دوره نیم روزه در مورد "
"استفاده از  Rust برای توسعه پلتفرم اندروید عمیق می‌شیم. این شامل قابلیت تعامل "
"با C، <span dir=ltr>C++</span> و جاوا می‌شود."

#: src/running-the-course/course-structure.md
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"شما نیاز دارید که یک نسخه از [مخزن ASOP](https://source.android.com/docs/"
"setup/download/downloading) بگیرید, همچنین یک نسخه از [مخزن دوره](https://"
"github.com/google/comprehensive-rust) بگیرید و روی همون ماشین در مسیر `src/"
"android/`مخزن ASOP قرار دهید. با این کار طمینان حاصل می‌کنید که سیستم build "
"اندروید فایل های `Android.bp` را در `src/android/` می‌بینید."

#: src/running-the-course/course-structure.md
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"اطمینان حاصل کنید که `adb sync` با شبیه‌ساز یا دستگاه واقعی شما کار می‌کند  و "
"همه نمونه‌های Android را با استفاده از `src/android/build_all.sh` از قبل "
"بسازید.  اسکریپت را بخوانید تا دستوراتی را که اجرا می‌کند ببینید و مطمئن شوید "
"که وقتی آنها را  اجرا می‌کنید به درستی کار می‌کنند."

#: src/running-the-course/course-structure.md
msgid "Rust in Chromium"
msgstr "Rust در اندروید"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""
"عمیق [Rust in Chromium](../chromium.md) یک دوره نیم روزه برای استفاده از "
"Rust به عنوان بخشی از مرورگر Chromium است. این شامل استفاده از Rust در سیستم "
"ساخت `gn‍` Chromium، آوردن کتابخانه‌های شخص ثالث (\"crates\") و قابلیت همکاری +"
"+C است."

#: src/running-the-course/course-structure.md
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""
"شما باید بتوانید Chromium را بسازید --- یک اشکال زدایی، ساخت کامپوننت برای "
"سرعت [توصیه می شود] (../chromium/setup.md) است، اما هر ساختی کار می کند. "
"مطمئن شوید که می‌توانید مرورگر Chromium را که ساخته‌اید اجرا کنید."

#: src/running-the-course/course-structure.md
msgid "Bare-Metal Rust"
msgstr "Rust بر روی سخت افزار بدون سیستم عامل"

#: src/running-the-course/course-structure.md
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"دوره آموزشی [Rust بر روی سخت افزار بدون سیستم عامل](../bare-metal.md) یک "
"دوره یک روزه با تمرکز بر استفاده ازRust برای توسعه بر روی سخت افزار بدون "
"سیستم عامل (embedded) است.  این دوره هم میکروکنترلرها و هم پردازشگر هایی با "
"کارایی خاص را پوشش می دهد."

#: src/running-the-course/course-structure.md
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"برای قسمت میکروکنترلر، باید برد توسعه [BBCmicro:bit](https://microbit.org/)  "
"v2 را   خریداری کنید. همه باید تعدادی بسته را همانطور که در [welcome page]"
"(../bare-metal.md) توضیح داده شده نصب کنند."

#: src/running-the-course/course-structure.md
msgid "Concurrency in Rust"
msgstr "همزمانی در Rust"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"The [Concurrency in Rust](../concurrency/welcome.md) deep dive is a full day "
"class on classical as well as `async`/`await` concurrency."
msgstr ""
"دوره [همزمانی در Rust ](../concurrency.md) یک روزه با تمرکز بر همزمانی   که "
"شامل همزمانی کلاسیک و   `async`/`await` است."

#: src/running-the-course/course-structure.md
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"شما به یک crate جدید نیاز خواهید داشت و وابستگی ها دانلود و آماده استفاده "
"باشند. سپس می‌توانید نمونه‌ها را در `src/main.rs‍` کپی/پیست کنید تا با آنها "
"آزمایش کنید:"

#: src/running-the-course/course-structure.md
msgid "Morning (3 hours and 20 minutes, including breaks)"
msgstr "صبح (۳ ساعت و ۲۰ دقیقه، شامل وقت اسراحت)"

#: src/running-the-course/course-structure.md src/pattern-matching.md
#: src/std-traits.md src/smart-pointers.md src/lifetimes.md src/iterators.md
#: src/testing.md src/error-handling.md src/unsafe-rust.md
#: src/concurrency/welcome.md src/concurrency/sync-exercises.md
#: src/concurrency/welcome-async.md src/concurrency/async-exercises.md
msgid "30 minutes"
msgstr "۳۰ دقیقه"

#: src/running-the-course/course-structure.md src/methods-and-traits.md
#: src/std-types.md src/memory-management.md src/borrowing.md
#: src/concurrency/welcome.md src/concurrency/sync-exercises.md
#: src/concurrency/welcome-async.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-exercises.md
msgid "20 minutes"
msgstr "۲۰ دقیقه"

#: src/running-the-course/course-structure.md src/concurrency/welcome.md
msgid "Send and Sync"
msgstr "ارسال و همگام‌سازی"

#: src/running-the-course/course-structure.md
msgid "Afternoon (3 hours and 20 minutes, including breaks)"
msgstr "بعدازظهر (۳ ساعت و ۲۰ دقیقه، شامل وقت استراحت)"

#: src/running-the-course/course-structure.md
msgid "Format"
msgstr "فرمت"

#: src/running-the-course/course-structure.md
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"این دوره قرار است بسیار تعاملی باشد و توصیه می کنیم اجازه دهید حس کنجکاوی "
"Rust را هدایت کنند!"

#: src/running-the-course/keyboard-shortcuts.md
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "چندین میانبر صفحه کلید مفید در mdBook وجود دارد:"

#: src/running-the-course/keyboard-shortcuts.md
msgid "<kbd>Arrow-Left</kbd>: Navigate to the previous page."
msgstr "<kbd>Arrow-Left</kbd>: به صفحه قبلی هدایت می‌کند."

#: src/running-the-course/keyboard-shortcuts.md
msgid "<kbd>Arrow-Right</kbd>: Navigate to the next page."
msgstr "<kbd>Arrow-Right</kbd>: به صفحه بعدی هدایت می‌کند."

#: src/running-the-course/keyboard-shortcuts.md
#, fuzzy
msgid "<kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus."
msgstr "<kbd>Ctrl + Enter</kbd>: اجرای نمونه کدی که بر روی آن تمرکز شده است."

#: src/running-the-course/keyboard-shortcuts.md
msgid "<kbd>s</kbd>: Activate the search bar."
msgstr "<kbd>s</kbd>: نوار جستجو را فعال می‌کند."

#: src/running-the-course/translations.md
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"این دوره توسط مجموعه ای از داوطلبان فوق العاده به زبان های دیگر ترجمه شده "
"است:"

#: src/running-the-course/translations.md
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[پرتغالی برزیلی](https://google.github.io/comprehensive-rust/pt-BR/) توسط "
"[@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) و  "
"[@henrif75](https://github.com/henrif75)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), @SketchK, and [@nodmp](https://github.com/nodmp)."
msgstr ""
"[چینی (ساده‌شده)](https://google.github.io/comprehensive-rust/zh-CN/) توسط "
"[@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/wnghl), "
"[@anlunx](https://github.com/anlunx), [@kongy](https://github.com/kongy), "
"[@noahdragon](https://github.com/noahdragon), [@superwhd](https://github.com/"
"superwhd), [@SketchK](https://github.com/SketchK) و [@nodmp](https://github."
"com/nodmp)."

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[چینی (سنتی)](https://google.github.io/comprehensive-rust/zh-TW/) توسط "
"[@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen) و [@johnathan79717](https://github.com/"
"johnathan79717)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ), [@momotaro1105](https://github.com/"
"momotaro1105), [@HidenoriKobayashi](https://github.com/HidenoriKobayashi) "
"and [@kantasv](https://github.com/kantasv)."
msgstr ""
"[ژاپنی](https://google.github.io/comprehensive-rust/ja/) توسط [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) و [@momotaro1105](https://github.com/"
"momotaro1105)."

#: src/running-the-course/translations.md
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), "
"[@jooyunghan](https://github.com/jooyunghan), and [@namhyung](https://github."
"com/namhyung)."
msgstr ""
"[کره ای](https://google.github.io/comprehensive-rust/ko/) توسط [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) و "
"[@jooyunghan](https://github.com/jooyunghan)."

#: src/running-the-course/translations.md
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[اسپانیایی](https://google.github.io/comprehensive-rust/es/) توسط [@deavid]"
"(https://github.com/deavid)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Ukrainian](https://google.github.io/comprehensive-rust/uk/) by [@git-user-"
"cpp](https://github.com/git-user-cpp), [@yaremam](https://github.com/"
"yaremam) and [@reta](https://github.com/reta)."
msgstr ""
"[فرانسویی](https://google.github.io/comprehensive-rust/fr/) توسط [@KookaS]"
"(https://github.com/KookaS) و [@vcaen](https://github.com/vcaen)."

#: src/running-the-course/translations.md
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"از انتخابگر زبان در گوشه بالا سمت راست برای جابه‌جایی بین زبان‌ها استفاده کنید."

#: src/running-the-course/translations.md
msgid "Incomplete Translations"
msgstr "ترجمه‌های ناقص"

#: src/running-the-course/translations.md
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"تعداد زیادی ترجمه در حال انجام وجود دارد. ما به آخرین ترجمه های به روز شده "
"پیوند می دهیم:"

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Arabic](https://google.github.io/comprehensive-rust/ar/) by [@younies]"
"(https://github.com/younies)"
msgstr ""
"[اسپانیایی](https://google.github.io/comprehensive-rust/es/) توسط [@deavid]"
"(https://github.com/deavid)."

#: src/running-the-course/translations.md
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[بنگالی](https://google.github.io/comprehensive-rust/bn/) توسط [@raselmandol]"
"(https://github.com/raselmandol)."

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Farsi](https://google.github.io/comprehensive-rust/fa/) by [@Alix1383]"
"(https://github.com/alix1383), [@DannyRavi](https://github.com/DannyRavi), "
"[@hamidrezakp](https://github.com/hamidrezakp), [@javad-jafari](https://"
"github.com/javad-jafari) and [@moaminsharifi](https://github.com/"
"moaminsharifi)."
msgstr ""
"[چینی (سنتی)](https://google.github.io/comprehensive-rust/zh-TW/) توسط "
"[@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen) و [@johnathan79717](https://github.com/"
"johnathan79717)."

#: src/running-the-course/translations.md
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS), [@vcaen](https://github.com/vcaen) and "
"[@AdrienBaudemont](https://github.com/AdrienBaudemont)."
msgstr ""
"[فرانسویی](https://google.github.io/comprehensive-rust/fr/) توسط [@KookaS]"
"(https://github.com/KookaS) و [@vcaen](https://github.com/vcaen)."

#: src/running-the-course/translations.md
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[آلمانی](https://google.github.io/comprehensive-rust/de/) توسط [@Throvn]"
"(https://github.com/Throvn) و [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md
msgid ""
"[Italian](https://google.github.io/comprehensive-rust/it/) by "
"[@henrythebuilder](https://github.com/henrythebuilder) and [@detro](https://"
"github.com/detro)."
msgstr ""
"[ایتالیایی](https://google.github.io/comprehensive-rust/de/) توسط [@Throvn]"
"(https://github.com/Throvn) و [@ronaldfw](https://github.com/ronaldfw)."

#: src/running-the-course/translations.md
msgid ""
"The full list of translations with their current status is also available "
"either [as of their last update](https://google.github.io/comprehensive-rust/"
"translation-report.html) or [synced to the latest version of the course]"
"(https://google.github.io/comprehensive-rust/synced-translation-report.html)."
msgstr ""
"فهرست کامل ترجمه‌ها با وضعیت فعلی‌شان نیز [در آخرین به‌روزرسانی](https://google."
"github.io/comprehensive-rust/translation-report.html) یا [همگام‌سازی شده با "
"آخرین نسخه دوره](https://google.github.io/comprehensive-rust/synced-"
"translation-report.html)."

#: src/running-the-course/translations.md
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"اگر می‌خواهید به این کار کمک کنید، لطفاً [دستورالعمل‌های ما](https://github.com/"
"google/comprehensive-rust/blob/main/TRANSLATIONS.md) را برای چگونگی ادامه "
"کار ببینید. ترجمه ها در [issue tracker](https://github.com/google/"
"comprehensive-rust/issues/282) هماهنگ و کنترل می شوند."

#: src/cargo.md
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"وقتی شروع به خواندن درباره Rust می کنید، خیلی سریع با [Cargo](https://doc."
"rust-lang.org/cargo/) ، ابزار استانداردی که در اکوسیستم Rust برای ساخت و "
"اجرای برنامه های Rust استفاده می شود، آشنا خواهید شد. در اینجا می‌خواهیم یک "
"مرور مختصر از در مورد کارگو و نحوه انطباق آن با اکوسیستم Rust و برنامه‌های آن "
"را در این آموزش ارائه دهیم."

#: src/cargo.md
msgid "Installation"
msgstr "راهنمای نصب"

#: src/cargo.md
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**لطفا دستورالعمل را دنبال کنید <https://rustup.rs>.**"

#: src/cargo.md
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"این کار به شما امکان استفاده از ابزار ساخت Cargo (`cargo`) و  کامپایلر Rust "
"(`rustc`) را می دهد. شما همچنین `rustup` را دریافت خواهید کرد، یک ابزار خط "
"فرمان(CLI) که می توانید از آن برای نصب نسخه های مختلف کامپایلر استفاده کنید."

#: src/cargo.md
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""
"پس از نصب Rust، باید ویرایشگر یا IDE خود را برای کار با Rust پیکربندی کنید. "
"اکثر ویرایشگرها این کار را با ارتباط گرفتن با [rust-analyzer](https://rust-"
"analyzer.github.io/) انجام می‌دهند، که قابلیت تکمیل خودکار و پرش به تعریف را "
"برای [VS Code](https://code.visualstudio.com/)، [Emacs](https://rust-"
"analyzer.github.io/manual.html#emacs)، [Vim/Neovim](https://rust-analyzer."
"github.io/manual.html#vimneovim)  و بسیاری دیگر فراهم می کند. همچنین یک IDE "
"متفاوت به نام [RustRover](https://www.jetbrains.com/rust/) در دسترس است."

#: src/cargo.md
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"در دبیان/اوبونتو، می‌توانید Cargo و  Rust و [Rust formatter](https://github."
"com/rust-lang/rustfmt) را نیز از طریق `apt` نصب کنید. با این حال، این به شما "
"یک نسخه   قدیمی Rust  را جهت نصب می دهد و ممکن است منجر به رفتار غیرمنتظره "
"برنامه شود. command مورد نظر این خواهد بود:"

#: src/cargo.md
msgid ""
"On macOS, you can use [Homebrew](https://brew.sh/) to install Rust, but this "
"may provide an outdated version. Therefore, it is recommended to install "
"Rust from the official site."
msgstr ""
"در macOS، می‌توانید از [Homebrew](https://brew.sh/) برای نصب Rust استفاده "
"کنید، اما ممکن است یک نسخه قدیمی باشد. بنابراین توصیه می شود Rust را از سایت "
"رسمی نصب کنید."

#: src/cargo/rust-ecosystem.md
msgid "The Rust Ecosystem"
msgstr "اکوسیستم Rust"

#: src/cargo/rust-ecosystem.md
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"اکوسیستم Rust از تعدادی ابزار تشکیل شده است که مهمترین آنها عبارتند از:"

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: کامپایلر Rust که فایل‌های `.rs` را به باینری و سایر فرمت‌های میانی "
"تبدیل می‌کند."

#: src/cargo/rust-ecosystem.md
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: مدیر وابستگی Rust و build tool آن است. Cargo می داند که چگونه "
"وابستگی ها را که معمولاً در <https://crates.io> میزبانی می شوند دانلود کند و "
"هنگام ساخت پروژه آنها را به `rustc` منتقل می‌کند. Cargo همچنین دارای یک "
"دستگاه تست داخلی است که برای اجرای unit test استفاده می شود."

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"'rustup': نصب کننده و به روز رسانی rustchain ابزار. این ابزار برای نصب و به "
"روز رسانی \"rustc\" و \"cargo\" در هنگام انتشار نسخه های جدید Rust استفاده "
"می شود. علاوه بر این، \"rustup\" همچنین می تواند اسناد را برای کتابخانه "
"استاندارد دانلود کند. شما می توانید چندین نسخه از Rust را در یک زمان نصب "
"کنید و \"rustup\" به شما اجازه می دهد تا در صورت نیاز بین انها تغییر دهید."

#: src/cargo/rust-ecosystem.md src/types-and-values/hello-world.md
#: src/references/exclusive.md src/memory-management/move.md
#: src/error-handling/try.md src/android/setup.md
#: src/concurrency/async/async-await.md
msgid "Key points:"
msgstr "نکات کلیدی:"

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust یک برنامه سریع برای انتشار نسخه‌های جدید دارد و هر شش هفته یک نسخه جدید "
"منتشر می شود. نسخه‌های جدید سازگاری با نسخه‌های قدیمی را حفظ می‌کنند --- به "
"علاوه قابلیت‌های جدید را فعال می‌کنند."

#: src/cargo/rust-ecosystem.md
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "سه کانال انتشار وجود دارد: \"stable\"، \"beta\"، و \"nightly\"."

#: src/cargo/rust-ecosystem.md
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"ویژگی های جدید در \"nightly\" آزمایش می شوند ، \"beta\" چیزی است که هر شش "
"هفته \"stable\" می شود."

#: src/cargo/rust-ecosystem.md
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"همچنین می‌توان وابستگی‌ها را از  [registries](https://doc.rust-lang.org/cargo/"
"reference/registries.html)،  پوشه‌ها و git و موارد دیگر برطرف کرد."

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust همچنین نسخه [editions](https://doc.rust-lang.org/edition-guide/) دارد: "
"نسخه فعلی Rust 2021 است. نسخه های قبلی Rust 2015 و Rust 2018 بودند."

#: src/cargo/rust-ecosystem.md
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr "نسخه ها مجاز به ایجاد تغییرات backwards incompatible  در زبان هستند."

#: src/cargo/rust-ecosystem.md
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"برای جلوگیری از breaking code، نسخه‌ها اختیاری انتخاب می‌شوند که: شما نسخه‌ "
"مورد نظر  برای crate خود از طریق فایل `Cargo.toml` انتخاب می‌کنید."

#: src/cargo/rust-ecosystem.md
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"برای جلوگیری از شکاف در اکوسیستم، کامپایلرهای Rust می توانند کدهای نوشته شده "
"برای نسخه های مختلف را ترکیب کنند."

#: src/cargo/rust-ecosystem.md
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"لازم به ذکر است که استفاده از کامپایلر به طور مستقیم(rustc) و نه از طریق "
"`cargo` بسیار غیرمعمول است (اکثر کاربران هرگز این کار را نمی کنند)."

#: src/cargo/rust-ecosystem.md
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr ""
"ممکن است لازم به ذکر باشد که Cargo خود یک ابزار بسیار قدرتمند و جامع است. "
"این است که قادر به بسیاری از ویژگی های پیشرفته از جمله اما نه محدود به:"

#: src/cargo/rust-ecosystem.md
msgid "Project/package structure"
msgstr "ساختار پروژه/بسته"

#: src/cargo/rust-ecosystem.md
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "وابستگی های Dev و وابستگی‌های   Runtime  Management/Caching"

#: src/cargo/rust-ecosystem.md
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"همچنین با command plugin فرعی (مانند [cargo clippy](https://github.com/rust-"
"lang/rust-clippy)) قابل توسعه است."

#: src/cargo/rust-ecosystem.md
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"در [official Cargo Book](https://doc.rust-lang.org/cargo/) بیشتر بخوانید."

#: src/cargo/code-samples.md
msgid "Code Samples in This Training"
msgstr "نمونه کد در این آموزش"

#: src/cargo/code-samples.md
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"برای این آموزش، بیشتر زبان Rust را از طریق مثال هایی که می توان از طریق "
"مرورگر شما اجرا کرد، بررسی می کنیم. این کار راه اندازی را بسیار ساده تر می "
"کند و تجربه ای ثابت را برای همه تضمین می کند."

#: src/cargo/code-samples.md
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"نصب Cargo همچنان پیشنهاد می شود:  چونکه انجام تمرینات را برای شما آسان تر می "
"کند. در روز آخر، تمرین بزرگتری را انجام خواهیم داد که به شما نشان می دهد "
"چگونه با وابستگی ها کار کنید و برای این کار شما به Cargo نیاز دارید."

#: src/cargo/code-samples.md
msgid "The code blocks in this course are fully interactive:"
msgstr "بلوک های کد در این دوره کاملاً تعاملی(interactive) هستند:"

#: src/cargo/code-samples.md src/cargo/running-locally.md
msgid "\"Edit me!\""
msgstr "\"Edit me!\""

#: src/cargo/code-samples.md
#, fuzzy
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the "
"text box."
msgstr "برای اجرای کد زمانی که focus در text box است."

#: src/cargo/code-samples.md
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"اکثر نمونه های کد مانند نشان داده شده در بالا قابل ویرایش هستند. چند نمونه "
"کد به دلایل مختلف قابل ویرایش نیستند:"

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"همینطورembedded playground نمی توانند unit tests را اجرا کنند. کد را کپی "
"کنید و آن را در Playground واقعی باز کنید تا unit tests د را نشان دهید."

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"در واقع embedded playgrounds در لحظه ای که از صفحه دور می شوید حالت پایدار "
"خود را از دست می دهند! به همین دلیل است که دانش آموزان باید تمرینات را با "
"استفاده از local Rust installation یا از طریق Playground حل کنند."

#: src/cargo/running-locally.md
msgid "Running Code Locally with Cargo"
msgstr "اجرای کد به صورت لوکال با Cargo"

#: src/cargo/running-locally.md
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"اگر می خواهید کد را روی سیستم خود آزمایش کنید، ابتدا باید Rust را نصب کنید. "
"این کار را با دنبال کردن [instructions in the Rust Book](https://doc.rust-"
"lang.org/book/ch01-01-installation.html) انجام دهید. این باید به شما یک "
"`rustc` و `cargo` کاربردی بدهد. در زمان نگارش، آخرین نسخه پایدار Rust دارای "
"این version numberها است:"

#: src/cargo/running-locally.md
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"شما همچنین می توانید از هر نسخه بعدی استفاده کنید، زیرا Rust سازگاری با نسخه "
"های قبلی را حفظ می‌کند."

#: src/cargo/running-locally.md
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"با این کار، این مراحل را دنبال کنید تا از یکی از مثال‌های این آموزش، یک "
"باینری Rust بسازید:"

#: src/cargo/running-locally.md
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""
"روی دکمه \"کپی در کلیپ بورد\" در نمونه ای که می خواهید کپی کنید؛ کلیک کنید."

#: src/cargo/running-locally.md
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"از `cargo new exercise` برای ایجاد دایرکتوری `excerise/` جدید برای کد خود "
"استفاده کنید:"

#: src/cargo/running-locally.md
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"به `exercise/` بروید و از `cargo run` برای ساخت و اجرای باینری خود استفاده "
"کنید:"

#: src/cargo/running-locally.md
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"کد صفحه دیگر را در `src/main.rs` با کد خود جایگزین کنید. برای مثال، با "
"استفاده از مثال در صفحه قبل، `src/main.rs` را شبیه به آن کنید."

#: src/cargo/running-locally.md
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "برای ساختن و اجرای باینری به روز شده خود از `cargo run` استفاده کنید:"

#: src/cargo/running-locally.md
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"از `cargo check` برای بررسی سریع پروژه خود برای خطاها استفاده کنید، از "
"`cargo build` برای کامپایل، بدون اجرای آن استفاده کنید. خروجی را در `target/"
"debug/` برای ساخت اشکال زدایی معمولی خواهید یافت. برای تولید نسخه بهینه سازی "
"شده در `target/release/` از `cargo build --release` استفاده کنید."

#: src/cargo/running-locally.md
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"با ویرایش `Cargo.toml` می‌توانید وابستگی‌هایی برای پروژه خود اضافه کنید. "
"هنگامی که دستورات `cargo` را اجرا می کنید، به طور خودکار وابستگی های مورد "
"نیاز را برای شما دانلود و کامپایل می‌کند."

#: src/cargo/running-locally.md
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"سعی کنید شرکت کنندگان کلاس را تشویق کنید تا Cargo را نصب کنند و از یک "
"ویرایشگر محلی استفاده کنند. این زندگی آنها را آسان تر می کند زیرا آنها یک "
"محیط توسعه عادی خواهند داشت."

#: src/welcome-day-1.md
msgid "Welcome to Day 1"
msgstr "به روز اول خوش آمدید"

#: src/welcome-day-1.md
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"این اولین روز از مبانی Rust است. ما امروز بخش‌های فابل توجه‌ای را پوشش خواهیم "
"داد:"

#: src/welcome-day-1.md
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"سینتکس‌های مقدماتی: متغیرها, تایپ‌های عددی و تایپ‌های مرکب, enums, structs, "
"مراجع, توابع, و متدها."

#: src/welcome-day-1.md
msgid "Types and type inference."
msgstr "Types and type inference."

#: src/welcome-day-1.md
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr "ساختارهای جریان کنترل: حلقه ها، شرط ها و غیره."

#: src/welcome-day-1.md
msgid "User-defined types: structs and enums."
msgstr "تایپ های تعریف شده توسط کاربر: ساختارها و enums."

#: src/welcome-day-1.md
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr "تطابق الگو: تجزیه و تحلیل enums, structs و آرایه‌ها."

#: src/welcome-day-1.md src/welcome-day-2.md src/welcome-day-3.md
#: src/welcome-day-4.md src/concurrency/welcome.md
#: src/concurrency/welcome-async.md
msgid "Schedule"
msgstr "برنامه زمانی"

#: src/welcome-day-1.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 5 "
"minutes. It contains:"
msgstr ""
"با احتساب 10 دقیقه استراحت، این جلسه باید حدود 2 ساعت و 5 دقیقه طول بکشد. آن "
"شامل:"

#: src/welcome-day-1.md
msgid "Please remind the students that:"
msgstr "لطفا به دانشجویان یادآوری کنید:"

#: src/welcome-day-1.md
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"آنها باید سؤالاتی را که به دست آوردند بپرسند، آنها را تا انتها ذخیره نکنید."

#: src/welcome-day-1.md
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr "کلاس قرار است تعاملی باشد و بحث‌ها بسیار مورد تشویق قرار می گیرند!"

#: src/welcome-day-1.md
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"به‌عنوان یک مربی، باید سعی کنید بحث‌ها را مرتبط نگه دارید، به عنوان مثال، "
"بحث‌های مرتبط با نحوه انجام کارها توسط Rust در مقابل برخی زبان‌های دیگر را حفظ "
"کنید. پیدا کردن تعادل مناسب می تواند سخت باشد، اما در مورد اجازه دادن به بحث "
"اشتباه کنید، زیرا آنها بیشتر از ارتباط یک طرفه افراد را درگیر می کنند."

#: src/welcome-day-1.md
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"احتمالاً سؤالات به این معنی است که ما در مورد چیزهایی قبل از اسلاید صحبت می "
"کنیم."

#: src/welcome-day-1.md
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"این اصلاً اشکالی ندارد! تکرار بخش مهمی از یادگیری است. به یاد داشته باشید که "
"اسلایدها فقط یک پشتیبان هستند و شما می توانید هر طور که دوست دارید از آنها "
"صرف نظر کنید."

#: src/welcome-day-1.md
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""
"ایده روز اول نشان دادن چیزهای \"پایه\" در Rust است که باید در زبان های دیگر "
"مشابهت های فوری داشته باشند. قسمت های پیشرفته تر Rust در روزهای بعد عرضه می "
"شوند."

#: src/welcome-day-1.md
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""
"اگر این را در کلاس درس تدریس می کنید، اینجا مکان خوبی برای مرور برنامه است. "
"توجه داشته باشید که در پایان هر بخش یک تمرین و سپس یک استراحت وجود دارد. "
"برای پوشاندن محلول تمرین بعد از استراحت برنامه ریزی کنید. زمان های ذکر شده "
"در اینجا یک پیشنهاد برای حفظ دوره در برنامه است. با خیال راحت انعطاف پذیر "
"باشید و در صورت لزوم تنظیم کنید!"

#: src/hello-world.md src/concurrency/send-sync.md
msgid "This segment should take about 15 minutes. It contains:"
msgstr "این بخش ۱۵ دقیقه زمان می برد. این بخش شامل:"

#: src/hello-world.md src/types-and-values.md src/control-flow-basics.md
#: src/tuples-and-arrays.md src/references.md src/user-defined-types.md
#: src/pattern-matching.md src/methods-and-traits.md src/generics.md
#: src/std-types.md src/std-traits.md src/memory-management.md
#: src/smart-pointers.md src/borrowing.md src/lifetimes.md src/iterators.md
#: src/modules.md src/testing.md src/error-handling.md src/unsafe-rust.md
#: src/concurrency/threads.md src/concurrency/channels.md
#: src/concurrency/send-sync.md src/concurrency/shared-state.md
#: src/concurrency/sync-exercises.md src/concurrency/async.md
#: src/concurrency/async-control-flow.md src/concurrency/async-pitfalls.md
#: src/concurrency/async-exercises.md
msgid "Slide"
msgstr "اسلاید"

#: src/hello-world.md src/references.md src/user-defined-types.md
#: src/pattern-matching.md src/methods-and-traits.md src/generics.md
#: src/std-types.md src/std-traits.md src/memory-management.md
#: src/smart-pointers.md src/borrowing.md src/lifetimes.md src/modules.md
#: src/unsafe-rust.md src/concurrency/channels.md src/concurrency/send-sync.md
#: src/concurrency/shared-state.md src/concurrency/async.md
#: src/concurrency/async-control-flow.md src/concurrency/async-pitfalls.md
msgid "10 minutes"
msgstr "۱۰ دقیقه"

#: src/hello-world.md src/control-flow-basics.md src/user-defined-types.md
#: src/memory-management.md src/concurrency/channels.md
#: src/concurrency/send-sync.md
msgid "2 minutes"
msgstr "۲ دقیقه"

#: src/hello-world/what-is-rust.md
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"‏Rust یک زبان برنامه‌نویسی جدید است که [نسخه 1.0 آن در سال 2015 منتشر شد]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"

#: src/hello-world/what-is-rust.md
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr ""
"زبان Rust, یک زبان کامپایل شده ایستا است که نقشی مشابه <span dir=ltr>C++</"
"span> دارد"

#: src/hello-world/what-is-rust.md
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` از `LLVM` به عنوان بک‌اند خود استفاده می‌کند."

#: src/hello-world/what-is-rust.md
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
" راست از بسیاری از [بسترها و معماری‌ها](https://doc.rust-lang.org/nightly/"
"rustc/platform-support.html) پشتیبانی می کند :"

#: src/hello-world/what-is-rust.md
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/hello-world/what-is-rust.md
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/hello-world/what-is-rust.md
msgid "Rust is used for a wide range of devices:"
msgstr "زبان Rust برای طیف گسترده‌ای از دستگاه‌ها استفاده می‌شود:"

#: src/hello-world/what-is-rust.md
msgid "firmware and boot loaders,"
msgstr "میان‌افزار (firmware) و بوت‌لودرها (boot loaders)"

#: src/hello-world/what-is-rust.md
msgid "smart displays,"
msgstr "نمایشگر‌های هوشمند,"

#: src/hello-world/what-is-rust.md
msgid "mobile phones,"
msgstr "تلفن‌های همراه,"

#: src/hello-world/what-is-rust.md
msgid "desktops,"
msgstr "رایانه‌های رومیزی,"

#: src/hello-world/what-is-rust.md
msgid "servers."
msgstr "سرورها."

#: src/hello-world/what-is-rust.md
msgid "Rust fits in the same area as C++:"
msgstr "Rust در همان حوزه <span dir=ltr>C++</span> قرار می‌گیرد:"

#: src/hello-world/what-is-rust.md
msgid "High flexibility."
msgstr "انعطاف پذیری بالا."

#: src/hello-world/what-is-rust.md
msgid "High level of control."
msgstr "سطح کنترل بالا."

#: src/hello-world/what-is-rust.md
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr "می‌تواند به دستگاه‌های بسیار محدود مانند میکروکنترلرها مقیاس‌بندی شود."

#: src/hello-world/what-is-rust.md
msgid "Has no runtime or garbage collection."
msgstr "فاقد ران‌تایم (runtime)  یا جمع‌آوری زباله (garbage collection) است."

#: src/hello-world/what-is-rust.md
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr "بر قابلیت اطمینان و ایمنی بدون قربانی کردن عملکرد تمرکز دارد."

#: src/hello-world/benefits.md
msgid "Some unique selling points of Rust:"
msgstr "برخی از نقاط قوت منحصر به فرد زبان Rust:"

#: src/hello-world/benefits.md
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr ""
"_ایمنی حافظه زمان کامپایل_ - کل کلاس های باگ حافظه در زمان کامپایل جلوگیری "
"می شود"

#: src/hello-world/benefits.md
msgid "No uninitialized variables."
msgstr "هیچ متغیر مقدار‌دهی نشده‌ای (`uninitialized`) وجود ندارد."

#: src/hello-world/benefits.md
msgid "No double-frees."
msgstr "هیچ آزادسازی دوباره‌ای وجود ندارد."

#: src/hello-world/benefits.md
msgid "No use-after-free."
msgstr "هیچ استفاده‌ای پس از آزادسازی وجود ندارد."

#: src/hello-world/benefits.md
msgid "No `NULL` pointers."
msgstr "هیچ اشاره‌گر `NULL` وجود ندارد."

#: src/hello-world/benefits.md
msgid "No forgotten locked mutexes."
msgstr "هیچ موتکس قفل شدهِ فراموش شده‌ای وجود ندارد."

#: src/hello-world/benefits.md
msgid "No data races between threads."
msgstr "هیچ وضعیت رقابتی (`data races`) بین رشته‌ها وجود ندارد."

#: src/hello-world/benefits.md
msgid "No iterator invalidation."
msgstr "تکرارکننده‌ها (`iterators`) هیچگاه نامعتبر نمی‌شوند.."

#: src/hello-world/benefits.md
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr ""
"_بدون رفتار زمان اجرا تعریف نشده_ - کاری که دستور Rust انجام می دهد هرگز "
"نامشخص باقی نمی ماند"

#: src/hello-world/benefits.md
msgid "Array access is bounds checked."
msgstr "دسترسی به آرایه با بررسی محدوده چک می‌شود."

#: src/hello-world/benefits.md
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "سرریز عدد صحیح تعریف شده است (پانیک یا `wrap-around`)."

#: src/hello-world/benefits.md
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr ""
"_ویژگی های زبان مدرن_ - به اندازه زبان های سطح بالاتر گویا و ارگونومیک است"

#: src/hello-world/benefits.md
msgid "Enums and pattern matching."
msgstr "Enumها و تطابق الگوها."

#: src/hello-world/benefits.md
msgid "Generics."
msgstr "جنریک‌ها."

#: src/hello-world/benefits.md
msgid "No overhead FFI."
msgstr "FFI بدون سربار."

#: src/hello-world/benefits.md
msgid "Zero-cost abstractions."
msgstr "انتزاع‌هایی بدون هزینه."

#: src/hello-world/benefits.md
msgid "Great compiler errors."
msgstr "خطاهای کامپایل عالیست."

#: src/hello-world/benefits.md
msgid "Built-in dependency manager."
msgstr "مدیر وابستگی درون-ساختی."

#: src/hello-world/benefits.md
msgid "Built-in support for testing."
msgstr "پشتیبانی درون-ساختی از تست نویسی."

#: src/hello-world/benefits.md
msgid "Excellent Language Server Protocol support."
msgstr "پشتیبانی عالی از LSP‌."

#: src/hello-world/benefits.md
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr ""
"وقت زیادی را اینجا صرف نکنید. تمام این نکات بعداً با عمق بیشتری پوشش داده "
"خواهد شد."

#: src/hello-world/benefits.md
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"حتما از کلاس بپرسید که با چه زبان‌هایی تجربه دارند. بسته به پاسخ، می توانید "
"ویژگی‌های مختلف Rust را برجسته کنید::"

#: src/hello-world/benefits.md
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"تجربه با C یا <span dir=ltr>C++</span> : زبان Rust با استفاده از بررسی کننده "
"قرض‌گیری (اشاره به مبحث قرض گرفتن یا  `borrow`) ، یک سری کامل از _خطاهای زمان "
"اجرا_ را از بین می‌برد .t  عملکردی مانند C و <span dir=ltr>C++</span> را "
"دارید اما مشکلات عدم ایمنی حافظه را ندارید. علاوه بر این، شما یک زبان مدرن "
"با ساختارهایی مانند تطابق الگو و مدیریت وابستگی داخلی دریافت می‌کنید."

#: src/hello-world/benefits.md
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)."
msgstr ""
"تجربه با Java، Go، Python، JavaScript...: شما همان ایمنی حافظه (memory "
"safety ) را مانند آن زبان‌ها دریافت می‌کنید، به علاوه یک احساس زبان سطح بالا "
"مشابه را تجربه خواهید کرد. علاوه بر این، شما عملکرد سریع و قابل پیش‌بینی "
"مانند C و <span dir=ltr>C++</span> (بدون garbage collector) و همچنین دسترسی "
"به سخت‌افزار سطح پایین (در صورت نیاز) دریافت می‌کنید."

#: src/hello-world/playground.md
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""
"[Rust Playground](https://play.rust-lang.org/) یک راه آسان برای اجرای برنامه "
"های Rust کوتاه ارائه می دهد و پایه ای برای مثال ها و تمرین های این دوره است. "
"برنامه \"Hello-world\" را که با آن شروع می شود اجرا کنید. دارای چند ویژگی "
"مفید است:"

#: src/hello-world/playground.md
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr ""
"در زیر \"ابزارها\"، از گزینه \"rustfmt\" برای قالب بندی کد خود به روش "
"\"استاندارد\" استفاده کنید."

#: src/hello-world/playground.md
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""
"Rust دارای دو \"نمایه\" اصلی برای تولید کد است: Debug (بررسی های زمان اجرا "
"اضافی، بهینه سازی کمتر) و Release (بررسی های زمان اجرا کمتر، بهینه سازی "
"زیاد). اینها در قسمت «اشکال‌زدایی» در بالا قابل دسترسی هستند."

#: src/hello-world/playground.md
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr ""
"اگر علاقه مند هستید، از \"ASM\" در زیر \"...\" برای دیدن کد اسمبلی تولید شده "
"استفاده کنید."

#: src/hello-world/playground.md
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""
"هنگامی که دانش آموزان به سمت استراحت می روند، آنها را تشویق کنید تا "
"playground  را باز کنند و کمی تجربه کنند. آنها را تشویق کنید که برگه را باز "
"نگه دارند و در بقیه دوره چیزهایی را امتحان کنند. این به ویژه برای دانش‌آموزان "
"پیشرفته که می‌خواهند درباره بهینه‌سازی‌های Rust یا مونتاژ تولید شده بیشتر "
"بدانند مفید است."

#: src/types-and-values.md src/control-flow-basics.md src/modules.md
msgid "This segment should take about 40 minutes. It contains:"
msgstr "این بخش باید حدود ۴۰ دقیقه طول بکشد. آن شامل:"

#: src/types-and-values/hello-world.md
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"بیایید به ساده ترین برنامه Rust ممکن یعنی یک برنامه Hello World کلاسیک "
"بپردازیم:"

#: src/types-and-values/hello-world.md
msgid "\"Hello 🌍!\""
msgstr "\"سلام 🌍!\""

#: src/types-and-values/hello-world.md
msgid "What you see:"
msgstr "آنچه شما می‌بینید:"

#: src/types-and-values/hello-world.md
msgid "Functions are introduced with `fn`."
msgstr "توابع با `fn` معرفی می‌شوند."

#: src/types-and-values/hello-world.md
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr ""
"بلوک‌ها با پرانتزهای باز و بسته مانند C و <span dir=ltr>C++</span> محدود "
"می‌شوند."

#: src/types-and-values/hello-world.md
msgid "The `main` function is the entry point of the program."
msgstr "تابع `main` نقطه ورود برنامه است."

#: src/types-and-values/hello-world.md
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr ""
"زبان Rust دارای ماکروهای hygienic است، <span dir=ltr>`println!`</span> یک "
"نمونه از این است."

#: src/types-and-values/hello-world.md
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"رشته‌های Rust دارای انکودینگ UTF-8 هستند و می‌توانند شامل هر کاراکتر یونیکد "
"باشند."

#: src/types-and-values/hello-world.md
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"این اسلاید سعی می کند دانشجویان با کد Rust احساس راحتی کنند. آنها در سه روز "
"آینده خیلی از این کدها خواهند دید، بنابراین با یک چیز آشنا شروع می کنیم.."

#: src/types-and-values/hello-world.md
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"زبان Rust, زبان بسیار شبیه به سایر زبان‌های خانواده C/<span dir=ltr>C++</"
"span>/Java است.یک زبان امری است (imperative) و سعی نمی‌کند چیزی را مگر اینکه "
"کاملاً ضروری باشد، دوباره اختراع کند."

#: src/types-and-values/hello-world.md
msgid "Rust is modern with full support for things like Unicode."
msgstr "زبان Rust, یک زبان مدرن با پشتیبانی کامل از چیزهایی مانند یونیکد است."

#: src/types-and-values/hello-world.md
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"Rust از ماکروها برای موقعیت‌هایی استفاده می‌کند که می‌خواهید تعداد متغیری از  "
"آرگومان‌ها داشته باشید (بدون [اورلودینگ](../control-flow-basics/functions.md) "
"تابع)."

#: src/types-and-values/hello-world.md
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"«هاجنیک» (`hygienic‍`) بودن ماکرو به این معنی است که آنها به طور تصادفی "
"شناسه‌ها را از محدوده‌ای که در آن استفاده می‌شوند، ذخیره نمی‌کنند. ماکروهای Rust "
"در واقع فقط [تا حدی هاجنیک](https://veykril.github.io/tlborm/decl-macros/"
"minutiae/hygiene.html هستند."

#: src/types-and-values/hello-world.md
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"زبان Rust, یک زبان چند پارادایمی است. به عنوان مثال، دارای ویژگی‌های قدرتمند "
"[برنامه نویسی شی‌گرا](https://doc.rust-lang.org/book/ch17-00-oop.html) است و "
"در حالی که یک زبان فانکشنال(`functional‍`) نیست، شامل طیف وسیعی از [مفاهیم "
"فانکشنال](https://doc.rust-lang.org/book/ch13-00-functional-features.html) "
"است."

#: src/types-and-values/variables.md
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr ""
"زبان Rust از طریق سیستم تایپ استاتیک, ایمینی نوع را فراهم می‌کند. به صورت "
"پیشفرض تعریف متغییر ها از نوع «غیر قابل تغییر» (immutable) است:"

#: src/types-and-values/variables.md src/control-flow-basics/loops/for.md
#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"x: {x}\""
msgstr "\"x: {x}\""

#: src/types-and-values/variables.md
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"

#: src/types-and-values/variables.md
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""
"برای نشان دادن اینکه متغیرها به طور پیش‌فرض تغییرناپذیر هستند، کامنت \"x = "
"20\" را حذف کنید. برای اجازه دادن به تغییرات، کلمه کلیدی «mut» را اضافه کنید."

#: src/types-and-values/variables.md
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""
"«i32» در اینجا نوع متغیر است. این باید در زمان کامپایل شناخته شود، اما "
"استنتاج نوع (که بعداً پوشش داده می شود) به برنامه نویس اجازه می دهد تا در "
"بسیاری از موارد آن را حذف کند."

#: src/types-and-values/values.md
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr ""
"در اینجا چند نوع پایه داخلی و نحو برای مقادیر تحت اللفظی هر نوع آورده شده "
"است."

#: src/types-and-values/values.md src/unsafe-rust/exercise.md
msgid "Types"
msgstr "انواع"

#: src/types-and-values/values.md
msgid "Literals"
msgstr "مقادیر ثابت"

#: src/types-and-values/values.md
msgid "Signed integers"
msgstr "اعداد صحیح علامت‌دار"

#: src/types-and-values/values.md
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/types-and-values/values.md
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr ""
"<span dir=ltr><code class=hljs>-10</code>, <code class=hljs>0</code>, <code "
"class=hljs>1_000</code>, <code class=hljs>123_i64</code></span>"

#: src/types-and-values/values.md
msgid "Unsigned integers"
msgstr "اعداد صحیح مثبت"

#: src/types-and-values/values.md
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/types-and-values/values.md
msgid "`0`, `123`, `10_u16`"
msgstr ""
"<span dir=ltr><code class=hljs>0</code>, <code class=hljs>123</code>, <code "
"class=hljs>10_u16</code></span>"

#: src/types-and-values/values.md
msgid "Floating point numbers"
msgstr "اعداد با ممیز شناور"

#: src/types-and-values/values.md
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/types-and-values/values.md
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr ""
"<span dir=ltr><code class=hljs>3.14</code>, <code class=hljs>-10.0e20</"
"code>, <code class=hljs>2_f32</code></span>"

#: src/types-and-values/values.md
msgid "Unicode scalar values"
msgstr "مقادیر عددی یونیکد"

#: src/types-and-values/values.md src/android/aidl/types/primitives.md
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md
msgid "`'a'`, `'α'`, `'∞'`"
msgstr "`'a'`, `'α'`, `'∞'`"

#: src/types-and-values/values.md
msgid "Booleans"
msgstr "بولین‌ها"

#: src/types-and-values/values.md src/android/aidl/types/primitives.md
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/types-and-values/values.md
msgid "The types have widths as follows:"
msgstr "اندازه تایپ‌ها به شرح زیر است:"

#: src/types-and-values/values.md
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`و `fN` به اندازه _N_ حافظه اشغال می‌کنند.,"

#: src/types-and-values/values.md
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` و `usize` به اندازه یک اشاره‌گر حافظه اشغال می‌کنند,"

#: src/types-and-values/values.md
msgid "`char` is 32 bits wide,"
msgstr "`char` به اندازه 32 بیت حافظه اشغال می‌کنند.,"

#: src/types-and-values/values.md
msgid "`bool` is 8 bits wide."
msgstr "`bool` به اندازه 8 بیت حافظه اشغال می‌کنند."

#: src/types-and-values/values.md
msgid "There are a few syntaxes which are not shown above:"
msgstr "موارد اندکی وجود دارند که در بالا نشان داده نشده است:"

#: src/types-and-values/values.md
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"می‌توان همه خطوط زیرین `_` را در اعداد حذف کرد، آنها فقط برای خوانایی هستند.  "
"«<span dir=ltr>`1_000`</span>  می‌تواند به صورت <span dir=ltr>`1000`</span> "
"(یا <span dir=ltr>`10_00`</span>) نوشته شود و <span dir=ltr>`123_i64`</span> "
"می‌تواند به صورت <span dir=ltr>`123i64`</span> نوشته شود»."

#: src/types-and-values/arithmetic.md
msgid "\"result: {}\""
msgstr "\"result: {}\""

#: src/types-and-values/arithmetic.md
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""
"این اولین بار است که تابعی غیر از \"main\" می بینیم، اما معنی آن باید واضح "
"باشد: سه عدد صحیح می گیرد و یک عدد صحیح برمی گرداند. توابع بعداً با جزئیات "
"بیشتر پوشش داده خواهد شد."

#: src/types-and-values/arithmetic.md
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr "حسابی بسیار شبیه به زبان های دیگر است، با تقدم مشابه."

#: src/types-and-values/arithmetic.md
#, fuzzy
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do unknown things at runtime. In Rust, it's "
"defined."
msgstr ""
"در مورد سرریز اعداد صحیح چطور؟ در C و++ C سرریز اعداد صحیح _signed_ در واقع "
"تعریف نشده است و ممکن است کارهای متفاوتی را در پلتفرم ها یا کامپایلرهای "
"مختلف انجام دهد. در Rust تعریف شده است."

#: src/types-and-values/arithmetic.md
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""
"«i32» را به «i16» تغییر دهید تا یک سرریز عدد صحیح را ببینید، که در یک ساخت "
"اشکال‌زدایی وحشت می‌کند (بررسی می‌شود) و در یک نسخه انتشار می‌پیچد. گزینه های "
"دیگری مانند سرریز، اشباع و حمل وجود دارد. اینها با نحو متد قابل دسترسی "
"هستند، به عنوان مثال، `(a * b).saturating_add(b * c).saturating_add(c *a)`."

#: src/types-and-values/arithmetic.md
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""
"در واقع، کامپایلر سرریز عبارات ثابت را تشخیص می دهد، به همین دلیل است که "
"مثال به یک تابع جداگانه نیاز دارد."

#: src/types-and-values/inference.md
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "زبان Rust برای تعیین نوع متغیر به نحوه استفاده از آن نگاه می‌کند:"

#: src/types-and-values/inference.md
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"این اسلاید نشان می‌دهد که چگونه کامپایلر Rust با توجه به اعلان‌ها و استفاده‌های "
"متغیر، انواع را استنتاج می‌کند. "

#: src/types-and-values/inference.md
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"بسیار مهم است که تاکید کنیم متغیرهایی که به این صورت تعریف می‌شوند از «نوع "
"داده پویای `any`» نیستند که بتواند هر نوعی باشند. وقتی که ما از **تعیین تایپ "
"ضمنی** استفاده می‌کنیم در واقع مشابه زمانی هست که نوع داده را به صورت صریح "
"اعلام میکنیم و کد های ماشین آنها دقیقا یکسان هستند. فقط با استفاده از  تعیین "
"تایپ ضمنی میتوانید کد ها رو به صورت مختصرتر بنویسیم. "

#: src/types-and-values/inference.md
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""
"هنگامی که هیچ چیز نوع یک عدد صحیح را محدود نمی کند، Rust به طور پیش فرض روی "
"«i32» قرار می گیرد. گاهی اوقات در پیام های خطا به صورت «{integer}» نشان داده "
"می شود. به طور مشابه، تایپ ممیز شناور پیش‌فرض «f64» است."

#: src/types-and-values/inference.md
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr "// ERROR: no implementation for `{float} == {integer}`\n"

#: src/types-and-values/exercise.md
msgid ""
"The Fibonacci sequence begins with `[0,1]`. For n>1, the n'th Fibonacci "
"number is calculated recursively as the sum of the n-1'th and n-2'th "
"Fibonacci numbers."
msgstr ""
"دنباله فیبوناچی با «[0،1]» شروع می شود. برای n>1، عدد فیبوناچی n به صورت "
"بازگشتی به عنوان مجموع اعداد فیبوناچی n-1 و n-2 محاسبه می شود."

#: src/types-and-values/exercise.md
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr ""
"یک تابع fib(n) بنویسید که عدد فیبوناچی n را محاسبه کند. چه زمانی این عملکرد "
"panic می شود؟"

#: src/types-and-values/exercise.md
msgid "// The base case.\n"
msgstr "//حالت پایه\n"

#: src/types-and-values/exercise.md src/control-flow-basics/exercise.md
msgid "\"Implement this\""
msgstr "\"این را پیاده‌سازی کن\""

#: src/types-and-values/exercise.md
msgid "// The recursive case.\n"
msgstr "// حالت بازگشتی\n"

#: src/types-and-values/exercise.md src/types-and-values/solution.md
msgid "\"fib({n}) = {}\""
msgstr "\"fib({n}) = {}\""

#: src/control-flow-basics.md
msgid "if Expressions"
msgstr "عبارت if"

#: src/control-flow-basics.md src/pattern-matching.md src/concurrency/async.md
#: src/concurrency/async-control-flow.md
msgid "4 minutes"
msgstr "۴ دقیقه"

#: src/control-flow-basics.md
msgid "break and continue"
msgstr "`break` و `continue`"

#: src/control-flow-basics/if.md
msgid "`if` expressions"
msgstr "عبارات `if`"

#: src/control-flow-basics/if.md
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"شما [عبارت `if`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-expressions) رو به مانند دیگر زبان‌ها استفاده می‌کنید:"

#: src/control-flow-basics/if.md
msgid "\"zero!\""
msgstr "\"صفر!\""

#: src/control-flow-basics/if.md
msgid "\"biggish\""
msgstr "\"biggish\""

#: src/control-flow-basics/if.md
msgid "\"huge\""
msgstr "\"huge\""

#: src/control-flow-basics/if.md
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"در کنار این موضوع, می‌توانید از if به عنوان یک عبارت با قابلیت بازگشت مقدار "
"هم استفاده کنید. آخرین عبارت توی هر بلاک  if اون مقدار و نوع بازگشتی است:"

#: src/control-flow-basics/if.md
msgid "\"small\""
msgstr "\"کوچک\""

#: src/control-flow-basics/if.md
msgid "\"large\""
msgstr "\"بزرگ\""

#: src/control-flow-basics/if.md
msgid "\"number size: {}\""
msgstr "\"اندازه عدد: {}\""

#: src/control-flow-basics/if.md
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"از آنجایی که ‍`if` یک عبارت است و باید نوع خاصی داشته باشد، هر دو بلاک (`if` "
"و `else`) باید از نوع یکسانی را باز گردانند.  در نظر بگیرید که اگر بعد از "
"`x / 2` در مثال دوم `;` اضافه کنید، چه اتفاقی می افتد."

#: src/control-flow-basics/if.md
#, fuzzy
msgid ""
"An `if` expression should be used in the same way as the other expressions. "
"For example, when it is used in a `let` statement, the statement must be "
"terminated with a `;` as well. Remove the `;` before `println!` to see the "
"compiler error."
msgstr ""
"هنگامی که «if» در یک عبارت استفاده می شود، عبارت باید دارای «;» باشد تا آن "
"را از عبارت بعدی جدا کند. \";\" را قبل از \"println!\" حذف کنید تا خطای "
"کامپایلر را ببینید."

#: src/control-flow-basics/loops.md
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr ""
"سه کلمه کلیدی حلقه ای در Rust وجود دارد: \"while\"، \"loop\" و \"for\":"

#: src/control-flow-basics/loops.md
msgid "`while`"
msgstr "حلقه‌های `while`"

#: src/control-flow-basics/loops.md
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"[کلمه‌کلیدی`while` ](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) بسیار شبیه به سایر زبان‌ها عمل می‌کند."

#: src/control-flow-basics/loops.md
msgid "\"Final x: {x}\""
msgstr "\"خروجی x: {x}\""

#: src/control-flow-basics/loops/for.md
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values or the items in a collection:"
msgstr ""
"حلقه [`for`](https://doc.rust-lang.org/std/keyword.for.html) در محدوده‌ای از "
"مقادیر یا موارد موجود در یک مجموعه تکرار می‌شود:"

#: src/control-flow-basics/loops/for.md
msgid "\"elem: {elem}\""
msgstr "\"elem: {elem}\""

#: src/control-flow-basics/loops/for.md
msgid ""
"Under the hood `for` loops use a concept called \"iterators\" to handle "
"iterating over different kinds of ranges/collections. Iterators will be "
"discussed in more detail later."
msgstr ""
"حلقه‌های «for» در  از مفهومی به نام «تکرارکننده‌ها» برای مدیریت تکرار در انواع "
"مختلف محدوده/مجموعه استفاده می‌کنند. Iterators بعداً با جزئیات بیشتر مورد بحث "
"قرار خواهند گرفت."

#: src/control-flow-basics/loops/for.md
msgid ""
"Note that the first `for` loop only iterates to `4`. Show the `1..=5` syntax "
"for an inclusive range."
msgstr ""
"توجه داشته باشید که حلقه `for` فقط تا `4` تکرار می شود. نحو `1..=5` را برای "
"یک محدوده فراگیر نشان دهید."

#: src/control-flow-basics/loops/loop.md
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"[`loop`](https://doc.rust-lang.org/std/keyword.loop.html) برای همیشه، تا "
"زمانی که یک «break» ایجاد شود، حلقه می‌شود."

#: src/control-flow-basics/loops/loop.md
msgid "\"{i}\""
msgstr "\"{i}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"اگر می‌خواهید بلافاصله تکرار بعدی را شروع کنید، از [`continue`](https://doc."
"rust-lang.org/reference/expressions/loop-expr.html#continue-expressions) "
"استفاده کنید."

#: src/control-flow-basics/break-continue.md
#, fuzzy
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). With "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"اگر می‌خواهید زودتر از یک حلقه خارج شوید، از [`break`](https://doc.rust-lang."
"org/reference/expressions/loop-expr.html#break-expressions) استفاده کنید."

#: src/control-flow-basics/break-continue.md src/std-traits/exercise.md
#: src/std-traits/solution.md src/smart-pointers/trait-objects.md
#: src/borrowing/interior-mutability.md src/modules/exercise.md
#: src/modules/solution.md src/android/build-rules/library.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "\"{}\""
msgstr "\"{}\""

#: src/control-flow-basics/break-continue.md
#, fuzzy
msgid ""
"Note that `loop` is the only looping construct which can return a non-"
"trivial value. This is because it's guaranteed to only return at a `break` "
"statement (unlike `while` and `for` loops, which can also return when the "
"condition fails)."
msgstr ""
"توجه داشته باشید که loop تنها ساختار حلقه‌ای است که یک مقدار **non-trivial** "
"را برمی‌گرداند. این به دلیل این است که  تضمین می‌شود حداقل یک بار وارد آن شود "
"(برخلاف حلقه‌های `while` و `for`)."

#: src/control-flow-basics/break-continue/labels.md
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"کلیدواژه‌های `continue` و `break` هر دو می‌توانند به صورت اختیاری یک آرگومان "
"برچسب (label) بگیرند که میتوان برای  خروج از حلقه‌های تو در تو استفاده می‌کرد:"

#: src/control-flow-basics/break-continue/labels.md
msgid "\"elements searched: {elements_searched}\""
msgstr "\"elements searched: {elements_searched}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks"
msgstr "بلوک‌ها"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"A block in Rust contains a sequence of expressions, enclosed by braces `{}`. "
"Each block has a value and a type, which are those of the last expression of "
"the block:"
msgstr ""
"یک بلوک در Rust حاوی دنباله ای از عبارات است که با پرانتزهای «{}» محصور شده "
"است. هر بلوک دارای یک مقدار و یک نوع است که آخرین عبارت بلوک است:"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"y: {y}\""
msgstr "\"y: {y}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr "اگر آخرین عبارت با `;` پایان یابد، مقدار و نوع بازگشتی `()` است."

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"می‌توانید نشان دهید که چگونه با تغییر خط آخر بلاک مقدار و نوع بازگشتی تغییر "
"می‌کند. به عنوان مثال با اضافه کردن یا  حذف کردن یک `;` یا با استفاده از کلید "
"واژه `return` تغییرات را اعمال کنید."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "A variable's scope is limited to the enclosing block."
msgstr "‏محدوده (scope) یک متغیر محدود به بلاک محاصره‌کننده آن است."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"شما می توانید متغیرها را سایه بزنید، هم آنهایی که از اسکوپ‌های بیرونی هستند و "
"هم متغیرهایی که از اسکوپ یکسان هستند:"

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"before: {a}\""
msgstr "\"before: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md src/generics/exercise.md
#: src/generics/solution.md src/std-traits/from-and-into.md
msgid "\"hello\""
msgstr "\"hello\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"inner scope: {a}\""
msgstr "\"inner scope: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"shadowed in inner scope: {a}\""
msgstr "\"shadowed in inner scope: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "\"after: {a}\""
msgstr "\"after: {a}\""

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""
"با افزودن یک «b» در بلوک داخلی در آخرین مثال، و سپس تلاش برای دسترسی به آن "
"در خارج از بلوک، نشان دهید که دامنه یک متغیر محدود است."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
#, fuzzy
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variables' memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"سایه زدن با جهش متفاوت است، زیرا پس از سایه زدن، هر دو مکان حافظه متغیر به "
"طور همزمان وجود دارند. هر دو با یک نام موجود هستند، بسته به جایی که از آن در "
"کد استفاده می کنید."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid "A shadowing variable can have a different type."
msgstr "یک متغیر سایه‌دار می تواند انواع داده‌ای متفاوتی داشته باشد."

#: src/control-flow-basics/blocks-and-scopes/scopes.md
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"سایه زدن در ابتدا مبهم به نظر می رسد، اما برای نگه داشتن مقادیر پس از  <span "
"dir=ltr>`.unwrap()`</span> مناسب است."

#: src/control-flow-basics/functions.md
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"بعد اعلان تابع پارامترهای ورودی و نوع آن و سپس یک نوع برگشتی هستند (برخلاف "
"برخی از زبان‌های برنامه‌نویسی)."

#: src/control-flow-basics/functions.md
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"آخرین عبارت در بدنه تابع (یا هر بلوک دیگری) به عنوان مقدار برگشتی در نظر "
"گرفته می‌شود. به همین سادگی <span dir=ltr>`;`</span> را  میتوان در انتهای "
"عبارت حذف کنید."

#: src/control-flow-basics/functions.md
#, fuzzy
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the return type is omitted."
msgstr ""
"برخی از توابع هیچ مقدار برگشتی ندارند و «نوع یکه» <span dir=ltr>`()`</span> "
"را برمی‌گردانند. اگر <span dir=ltr>`-> ()`</span> از بخش نوع برگشتی حذف شود، "
"کامپایلر این را استنتاج خواهد کرد که هیچ نوع برگشتی وجود ندارد."

#: src/control-flow-basics/functions.md
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr ""
"بارگذاری مجدد (overloading) پشتیبانی نمی‌شود -- هر تابع فقط یک پیاده‌سازی دارد."

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr ""
"همیشه تعداد ثابتی از پارامترها را می گیرد. آرگومان های پیش فرض پشتیبانی نمی "
"شوند. ماکروها را می توان برای پشتیبانی از توابع متغیر استفاده کرد."

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr "همیشه یک مجموعه واحد از انواع آرگومان‌ها را می‌گیرد."

#: src/control-flow-basics/macros.md
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""
"ماکروها در طول کامپایل به کد Rust گسترش می‌یابند و می‌توانند تعداد متغیری از "
"آرگومان‌ها را بگیرند. آنها در پایان با یک «!» متمایز می شوند. کتابخانه "
"استاندارد Rust شامل مجموعه ای از ماکروهای مفید است."

#: src/control-flow-basics/macros.md
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr ""
"`println!(format, ..)` یک خط را در خروجی استاندارد چاپ می کند و قالب بندی "
"شرح داده شده در [`std::fmt`] (https://doc.rust-lang.org/std/fmt/index.html) "
"را اعمال می کند. ."

#: src/control-flow-basics/macros.md
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""
"`format!(format, ..)` درست مانند `println!` کار می کند، اما نتیجه را به صورت "
"یک رشته برمی گرداند."

#: src/control-flow-basics/macros.md
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr "`dbg!(expression)` مقدار عبارت را ثبت کرده و آن را برمی گرداند."

#: src/control-flow-basics/macros.md
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr ""
"`todo!()` مقداری از کد را به عنوان هنوز پیاده‌سازی نشده علامت‌گذاری می‌کند. "
"panic می کند."

#: src/control-flow-basics/macros.md
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""
"`unreachable!()` مقداری از کد را غیرقابل دسترسی علامت گذاری می کند. اگر "
"اعدام شود وحشت می کند."

#: src/control-flow-basics/macros.md
msgid "\"{n}! = {}\""
msgstr "\"{n}! = {}\""

#: src/control-flow-basics/macros.md
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""
"نکته مهم این بخش این است که این امکانات مشترک و نحوه استفاده از آنها وجود "
"دارد. اینکه چرا آنها به عنوان ماکرو تعریف می شوند و به چه چیزی گسترش می "
"یابند، بسیار مهم نیست."

#: src/control-flow-basics/macros.md
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr ""
"این دوره شامل تعریف ماکروها نمی شود، اما در بخش بعدی استفاده از ماکروهای "
"مشتق شده توضیح داده خواهد شد."

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n<sub>1</sub> greater than zero:"
msgstr ""
"‏[Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) به شرح "
"زیر تعریف می‌شود، برای هر n<sub>۱</sub> دلخواه بزرگتر از صفر:"

#: src/control-flow-basics/exercise.md
msgid ""
"If _n<sub>i</sub>_ is 1, then the sequence terminates at _n<sub>i</sub>_."
msgstr ""
"اگر _n<sub>i</sub>_ = ۱ باشد، دنباله (sequence) در _n<sub>i</sub>_ پایان "
"می‌یابد."

#: src/control-flow-basics/exercise.md
msgid "If _n<sub>i</sub>_ is even, then _n<sub>i+1</sub> = n<sub>i</sub> / 2_."
msgstr ""
"اگر _n<sub>i</sub>_ زوج باشد، آنگاه _n<sub>i+۱</sub>_ = _n<sub>i</sub>_/۲."

#: src/control-flow-basics/exercise.md
msgid ""
"If _n<sub>i</sub>_ is odd, then _n<sub>i+1</sub> = 3 * n<sub>i</sub> + 1_."
msgstr ""
"اگر _n<sub>i</sub>_ فرد باشد، آنگاه _n<sub>i+۱</sub>_ = ۳ * _n<sub>i</sub>_ "
"+ ۱."

#: src/control-flow-basics/exercise.md
msgid "For example, beginning with _n<sub>1</sub>_ = 3:"
msgstr "به عنوان مثال، با شروع از _n<sub>i</sub>_ = ۳:"

#: src/control-flow-basics/exercise.md
msgid "3 is odd, so _n<sub>2</sub>_ = 3 * 3 + 1 = 10;"
msgstr "۳ فرد است، پس _n<sub>2</sub>_ = ۳ * ۳ + ۱ = 10;"

#: src/control-flow-basics/exercise.md
msgid "10 is even, so _n<sub>3</sub>_ = 10 / 2 = 5;"
msgstr "۱۰ زوج است، پس _n<sub>3</sub>_  = ۱۰ / ۲ = ۵;"

#: src/control-flow-basics/exercise.md
msgid "5 is odd, so _n<sub>4</sub>_ = 3 * 5 + 1 = 16;"
msgstr "۵ فرد است، پس _n<sub>4</sub>_ = ۳ * ۵ + ۱ = 16;"

#: src/control-flow-basics/exercise.md
msgid "16 is even, so _n<sub>5</sub>_ = 16 / 2 = 8;"
msgstr "۱۶ زوج است، پس _n<sub>5</sub>_ = ۱۶ / ۲ = 8;"

#: src/control-flow-basics/exercise.md
msgid "8 is even, so _n<sub>6</sub>_ = 8 / 2 = 4;"
msgstr "۸ زوج است، پس _n<sub>6</sub>_ = ۸ / ۲ = 4;"

#: src/control-flow-basics/exercise.md
msgid "4 is even, so _n<sub>7</sub>_ = 4 / 2 = 2;"
msgstr "۴ زوج است، پس _n<sub>7</sub>_ = ۴ / ۲ = ۲;"

#: src/control-flow-basics/exercise.md
msgid "2 is even, so _n<sub>8</sub>_ = 1; and"
msgstr "۲ زوج است، پس _n<sub>۸</sub>_ = ۱; و"

#: src/control-flow-basics/exercise.md
msgid "the sequence terminates."
msgstr "دنباله به پایان می‌رسد."

#: src/control-flow-basics/exercise.md
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr ""
"یک تابع بنویسید تا طول دنباله Collatz برای یک n اولیه داده شده را محاسبه کند."

#: src/control-flow-basics/exercise.md src/control-flow-basics/solution.md
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr "/// Determine the length of the collatz sequence beginning at `n`.\n"

#: src/control-flow-basics/solution.md src/concurrency/threads/scoped.md
msgid "\"Length: {}\""
msgstr "\"Length: {}\""

#: src/welcome-day-1-afternoon.md src/welcome-day-2-afternoon.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4-afternoon.md
msgid "Welcome Back"
msgstr "خوش آمد"

#: src/welcome-day-1-afternoon.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 35 "
"minutes. It contains:"
msgstr ""
"با احتساب 10 دقیقه استراحت، این جلسه باید حدود 2 ساعت و 35 دقیقه طول بکشد. "
"آن شامل:"

#: src/tuples-and-arrays.md
msgid "This segment should take about 35 minutes. It contains:"
msgstr "این بخش باید حدود 35 دقیقه طول بکشد. این شامل:"

#: src/tuples-and-arrays/arrays.md
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"یک مقدار از نوع آرایه <span dir=ltr>`[T; N]`</span> دارای <span dir=ltr>`N`</"
"span>  (یک ثابت زمان کامپایل) عنصر از نوع یکسان <span dir=ltr>`T`</span> "
"است. توجه داشته باشید که طول آرایه بخشی از نوع آن است، به این معنی که <span "
"dir=ltr>`[u8; 3]`</span> و <span dir=ltr>`[u8; 4]`</span> دو نوع متفاوت در "
"نظر گرفته می‌شوند."

#: src/tuples-and-arrays/arrays.md
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""
"سعی کنید به یک عنصر آرایه خارج از محدوده دسترسی داشته باشید. دسترسی های "
"آرایه در زمان اجرا بررسی می شود. زنگ معمولاً می‌تواند این بررسی‌ها را از بین "
"ببرد و با استفاده از Rust ناایمن از آنها جلوگیری کرد."

#: src/tuples-and-arrays/arrays.md
msgid "We can use literals to assign values to arrays."
msgstr "ما می‌توانیم از مقادیر ثابت برای انتساب مقادیر به آرایه‌ها استفاده کنیم."

#: src/tuples-and-arrays/arrays.md
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"ماکرو <span dir=ltr>`println!`</span> با پارامتر فرمت <span dir=ltr>`?`</"
"span>   نیازمند پیاده سازی دیباگ است: <span dir=ltr>`{}`</span> خروجی پیش "
"فرض را می‌دهد، <span dir=ltr>`{:?}`</span>  خروجی دیباگ را می‌دهد. انواع‌ای "
"مانند اعداد صحیح و رشته‌ها خروجی پیش فرض را پیاده سازی می‌کنند، اما آرایه‌ها "
"فقط خروجی دیباگ را پیاده سازی می‌کنند. این بدان معناست که ما باید در اینجا از "
"خروجی دیباگ استفاده کنیم."

#: src/tuples-and-arrays/arrays.md
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"اضافه کردن <span dir=ltr>`#`</span>، مانند <span dir=ltr>`{a:#?}`</span>، یک "
"فرمت «چاپ زیبا» را فراخوانی می‌کند که می‌تواند خواندن آن را آسان تر کند."

#: src/tuples-and-arrays/tuples.md
msgid "Like arrays, tuples have a fixed length."
msgstr "مانند آرایه‌ها، تاپل‌ها نیز دارای طول ثابت هستند."

#: src/tuples-and-arrays/tuples.md
msgid "Tuples group together values of different types into a compound type."
msgstr "تاپل‌ها مقادیر انواع مختلف را در یک نوع مرکب کنار هم قرار می‌دهند."

#: src/tuples-and-arrays/tuples.md
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"می‌توان به فیلدهای یک تاپل با استفاده از نقطه و شماره اندیس مقدار، مانند "
"<span dir=ltr>`t.0`</span>، <span dir=ltr>`t.1`</span> دسترسی پیدا کرد."

#: src/tuples-and-arrays/tuples.md
msgid ""
"The empty tuple `()` is referred to as the \"unit type\" and signifies "
"absence of a return value, akin to `void` in other languages."
msgstr ""
"تاپل خالی `()` به عنوان `unit type` نامیده می‌شود و نشان‌دهنده عدم وجود مقدار "
"بازگشتی است، مشابه `void` در زبان‌های دیگر."

#: src/tuples-and-arrays/iteration.md
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr "عبارت `for` از تکرار روی آرایه ها (اما نه تاپل ها) پشتیبانی می کند."

#: src/tuples-and-arrays/iteration.md
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr ""
"این قابلیت از ویژگی `IntoIterator` استفاده می‌کند، اما ما هنوز به آن "
"پرداخته‌ایم."

#: src/tuples-and-arrays/iteration.md
#, fuzzy
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked, while debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""
"ماکرو `assert_ne!` در اینجا جدید است. همچنین ماکروهای `assert_eq!` و `assert!"
"` وجود دارد. این‌ها همیشه بررسی می‌شوند، در حالی که، گونه‌های فقط اشکال‌زدایی "
"مانند `debug_assert!` در نسخه‌های  ریلیز کامپایل نمی‌شوند."

#: src/tuples-and-arrays/destructuring.md
msgid ""
"When working with tuples and other structured values it's common to want to "
"extract the inner values into local variables. This can be done manually by "
"directly accessing the inner values:"
msgstr ""
"هنگام کار با تاپل ها و سایر مقادیر ساختاریافته، معمول است که بخواهید مقادیر "
"داخلی را در متغیرهای محلی استخراج کنید. این را می توان به صورت دستی با "
"دسترسی مستقیم به مقادیر داخلی انجام داد:"

#: src/tuples-and-arrays/destructuring.md
msgid "\"left: {left}, right: {right}\""
msgstr "\"left: {left}, right: {right}\""

#: src/tuples-and-arrays/destructuring.md
msgid ""
"However, Rust also supports using pattern matching to destructure a larger "
"value into its constituent parts:"
msgstr ""
"با این حال، Rust همچنین از استفاده از تطبیق الگو برای تخریب یک مقدار بزرگتر "
"در بخش های تشکیل دهنده آن پشتیبانی می کند:"

#: src/tuples-and-arrays/destructuring.md
msgid ""
"The patterns used here are \"irrefutable\", meaning that the compiler can "
"statically verify that the value on the right of `=` has the same structure "
"as the pattern."
msgstr ""
"الگوهای استفاده شده در اینجا \"irrefutable\" هستند، به این معنی که کامپایلر "
"می تواند به طور ایستا تأیید کند که مقدار سمت راست `=` ساختاری مشابه الگو "
"دارد."

#: src/tuples-and-arrays/destructuring.md
msgid ""
"A variable name is an irrefutable pattern that always matches any value, "
"hence why we can also use `let` to declare a single variable."
msgstr ""
"نام متغیر یک الگوی انکارناپذیر است که همیشه با هر مقداری مطابقت دارد، از این "
"رو می‌توانیم از «let» برای اعلام یک متغیر استفاده کنیم."

#: src/tuples-and-arrays/destructuring.md
msgid ""
"Rust also supports using patterns in conditionals, allowing for equality "
"comparison and destructuring to happen at the same time. This form of "
"pattern matching will be discussed in more detail later."
msgstr ""
"Rust همچنین از استفاده از الگوها در شرطی‌ها پشتیبانی می‌کند و امکان مقایسه "
"برابری و تخریب ساختار را در همان زمان فراهم می‌کند. این شکل از تطبیق الگو "
"بعداً با جزئیات بیشتری مورد بحث قرار خواهد گرفت."

#: src/tuples-and-arrays/destructuring.md
msgid ""
"Edit the examples above to show the compiler error when the pattern doesn't "
"match the value being matched on."
msgstr ""
"مثال‌های بالا را ویرایش کنید تا خطای کامپایلر در زمانی که الگو با مقدار "
"مطابقت‌شده مطابقت ندارد نشان داده شود."

#: src/tuples-and-arrays/exercise.md
msgid "Arrays can contain other arrays:"
msgstr "آرایه ها می توانند آرایه های دیگری نیز داشته باشند:"

#: src/tuples-and-arrays/exercise.md
msgid "What is the type of this variable?"
msgstr "نوع این متغیر چیست؟"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"از آرایه‌ای مشابه مثال بالا برای نوشتن تابع <span dir=ltr>`transpose`</span> "
"استفاده کنید که یک ماتریس را جابجا می‌کند (ردیف‌ها را به ستون‌ها تبدیل می‌کند):"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"function. This function only operates on 3x3 matrices."
msgstr ""
"کد زیر را در <https://play.rust-lang.org/> کپی کرده و توابع را پیاده‌سازی "
"کنید:"

#: src/tuples-and-arrays/exercise.md src/borrowing/exercise.md
#: src/unsafe-rust/exercise.md
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr "// TODO: این را زمانی که پیاده‌سازی‌تان تمام شد حذف کنید.\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "//\n"
msgstr "//\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr "‏// <-- این کامنت باعث می‌شود rustfmt یک خط جدید اضافه کند.\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"matrix: {:#?}\""
msgstr "\"matrix: {:#?}\""

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"transposed: {:#?}\""
msgstr "\"جابجا شده است: {:#?}\""

#: src/references.md src/smart-pointers.md src/borrowing.md
#: src/concurrency/async-pitfalls.md
msgid "This segment should take about 55 minutes. It contains:"
msgstr "این بخش باید حدود ۵۵ دقیقه طول بکشد. آن شامل:"

#: src/references/shared.md
#, fuzzy
msgid ""
"A reference provides a way to access another value without taking ownership "
"of the value, and is also called \"borrowing\". Shared references are read-"
"only, and the referenced data cannot change."
msgstr ""
"یک مرجع راهی برای دسترسی به مقدار دیگری بدون مسئولیت ارزش فراهم می کند و به "
"آن «قرض» نیز می گویند. مراجع مشترک فقط خواندنی هستند و داده های ارجاع شده "
"نمی توانند تغییر کنند."

#: src/references/shared.md
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""
"یک مرجع مشترک به یک نوع `T` دارای نوع `&T` است. یک مقدار مرجع با عملگر `&` "
"ساخته می شود. عملگر `*` یک مرجع را \"ارجاع مجدد\" می کند و مقدار آن را به "
"دست می دهد."

#: src/references/shared.md
msgid "Rust will statically forbid dangling references:"
msgstr "راست بطور استاتیک مراجع تعلیق شده (dangling) را ممنوع می‌کند:"

#: src/references/shared.md
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""
"گفته می‌شود که یک مرجع مقداری را که به آن ارجاع می‌دهد \"borrow\" (قرض) می‌کند، "
"و این مدل خوبی برای دانش‌آموزانی است که با اشاره‌گرها آشنا نیستند: کد می‌تواند "
"از مرجع برای دسترسی به مقدار استفاده کند، اما همچنان متعلق به متغیر اصلی "
"است. این دوره در روز 3 به جزئیات بیشتری در مورد مالکیت خواهد پرداخت."

#: src/references/shared.md
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""
"مراجع به عنوان اشاره گر پیاده سازی می شوند و یک مزیت کلیدی این است که می "
"توانند بسیار کوچکتر از چیزی باشند که به آن اشاره می کنند. دانش آموزانی که با "
"C یا C++ آشنا هستند، مراجع را به عنوان اشاره گر تشخیص می دهند. بخش‌های بعدی "
"دوره به این موضوع می‌پردازد که چگونه Rust از اشکالات ایمنی حافظه ناشی از "
"استفاده از نشانگرهای خام جلوگیری می‌کند."

#: src/references/shared.md
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr ""
"Rust به طور خودکار برای شما مراجع ایجاد نمی کند - `&` همیشه مورد نیاز است."

#: src/references/shared.md
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.is_ascii()`). There is no need for an `->` operator like in "
"C++."
msgstr ""
"راست در برخی موارد به‌طور خودکار از Dereference می‌کند، به‌ویژه هنگام فراخوانی "
"متدها (<span dir=ltr>`ref_x.count_ones()`</span> را امتحان کنید)."

#: src/references/shared.md
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""
"در این مثال، `r` قابل تغییر است تا بتوان آن را مجدداً اختصاص داد (`r = &b`). "
"توجه داشته باشید که این `r` را دوباره متصل می کند، به طوری که به چیز دیگری "
"اشاره می کند. این با C++ متفاوت است، جایی که انتساب به یک مرجع مقدار مرجع را "
"تغییر می دهد."

#: src/references/shared.md
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr ""
"یک مرجع مشترک اجازه تغییر مقداری را که به آن ارجاع می دهد را نمی دهد، حتی "
"اگر آن مقدار قابل تغییر باشد. \"*r = \"X\" را امتحان کنید."

#: src/references/shared.md
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""
"Rust طول عمر همه مراجع را ردیابی می کند تا اطمینان حاصل شود که آنها به "
"اندازه کافی عمر می کنند. ارجاعات آویزان نمی توانند در Rust ایمن رخ دهند. "
"`x_axis` یک ارجاع به `point` برمی‌گرداند، اما «نقطه» زمانی که تابع برمی‌گردد، "
"تخصیص داده می‌شود، بنابراین کامپایل نمی‌شود."

#: src/references/shared.md
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"هنگامی که به مالکیت در زبان راست رسیدیم، بیشتر در مورد «قرض دادن» صحبت "
"خواهیم کرد."

#: src/references/exclusive.md
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""
"مراجع انحصاری، همچنین به عنوان مراجع قابل تغییر شناخته می شوند، اجازه می "
"دهند مقداری را که به آن ارجاع می دهند تغییر دهند. آنها نوع `mut &T` دارند."

#: src/references/exclusive.md
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""
"\"انحصاری\" به این معنی است که فقط از این مرجع می توان برای دسترسی به مقدار "
"استفاده کرد. هیچ مرجع دیگری (اشتراک‌گذاری شده یا انحصاری) نمی‌تواند همزمان "
"وجود داشته باشد، و تا زمانی که مرجع انحصاری وجود دارد، نمی‌توان به مقدار "
"ارجاع‌شده دسترسی داشت. زمانی که `x_coord` زنده است، `&point.0` بسازید یا "
"`point.0` را تغییر دهید."

#: src/references/exclusive.md
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"حتماً تفاوت بین «let mut x_coord: &i32» و «let x_coord: &mut i32» را یادداشت "
"کنید. مورد اول یک مرجع مشترک را نشان می دهد که می تواند به مقادیر مختلف متصل "
"شود، در حالی که دومی نشان دهنده یک مرجع انحصاری به یک مقدار قابل تغییر است."

#: src/references/slices.md
msgid "A slice gives you a view into a larger collection:"
msgstr "یک برش به شما امکان می‌دهد نما (view) از یک مجموعه بزرگتر داشته باشید:"

#: src/references/slices.md
msgid "Slices borrow data from the sliced type."
msgstr "برش‌ها داده‌ها را از نوع برش‌شده قرض می‌گیرند."

#: src/references/slices.md
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr ""
"پرسش: اگر <span dir=ltr>`a[3]`</span> را درست قبل از چاپ <span dir=ltr>`s`</"
"span> تغییر دهید چه اتفاقی می‌افتد؟"

#: src/references/slices.md
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"ما با قرض گرفتن <span dir=ltr>`a`</span> و مشخص کردن شاخص‌های شروع و پایان در "
"براکت‌ها، برش (slice) ایجاد می‌کنیم."

#: src/references/slices.md
msgid ""
"If the slice starts at index 0, Rust’s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"اگر برش از شاخص ۰ شروع شود، سینتکس راست به ما اجازه می‌دهد شاخص شروع را حذف "
"کنیم (یعنی عدد صفر را  ننویسیم)، به این معنی که <span dir=ltr>`&a[0..a."
"len()]`</span>  و <span dir=ltr>`&a[..a.len()]`</span> یکسان  هستند."

#: src/references/slices.md
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"در مورد شاخص آخر نیز همینطور است، بنابراین <span dir=ltr>`&a[2..a.len()]`</"
"span> و <span dir=ltr>`&a[2..]`</span>  یکسان هستند."

#: src/references/slices.md
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"یک روش ساده برای برش کل آرایه، این است که از <span dir=ltr>`&a[..]`</span> "
"استفاده کنیم."

#: src/references/slices.md
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"<span dir=ltr>`s`</span> یک مرجع به برش i32 است. توجه داشته باشید که نوع "
"<span dir=ltr>`s`</span> (<span dir=ltr>`&[i32]`</span>) دیگر طول آرایه را "
"ذکر نمی‌شود. این به ما امکان می‌دهد محاسباتی را روی برش‌هایی با اندازه‌های مختلف "
"انجام دهیم."

#: src/references/slices.md
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"برش‌ها همیشه از یک شیء دیگر قرض می‌گیرند. در این مثال، <span dir=ltr>`a`</"
"span> باید حداقل به اندازه طول‌عمر برش ما، زنده (در محدوده) باقی بماند. "

#: src/references/slices.md
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"پرسش در مورد تغییر <span dir=ltr>`a[3]`</span> می تواند یک بحث جالب را شروع "
"کند، اما پاسخ‌اش این است که به دلایل ایمنی حافظه، نمی‌توانید این کار را از "
"طریق <span dir=ltr>`a`</span> در این مرحله از اجرا انجام دهید، اما می‌توانید "
"داده‌ها را از هر دو <span dir=ltr>`a`</span> و <span dir=ltr>`s`</span> به "
"طور ایمن بخوانید. این کار قبل از ایجاد برش و دوباره بعد از <span "
"dir=ltr>`println!`</span> کار میکند، زمانی که برش دیگر استفاده نمی شود. "
"جزئیات بیشتری در بخش بررسی‌کننده‌قرض (the borrow checker) توضیح خواهیم داد."

#: src/references/strings.md
msgid "We can now understand the two string types in Rust:"
msgstr "حالا می‌توانیم دو نوع رشته‌ای را در راست درک کنیم:"

#: src/references/strings.md
msgid "`&str` is a slice of UTF-8 encoded bytes, similar to `&[u8]`."
msgstr "`str&` تکه‌ای از بایت‌های رمزگذاری‌شده UTF-8، شبیه به `[u8]&` است."

#: src/references/strings.md
#, fuzzy
msgid ""
"`String` is an owned buffer of UTF-8 encoded bytes, similar to `Vec<T>`."
msgstr "`str&` تکه‌ای از بایت‌های رمزگذاری‌شده UTF-8، شبیه به `[u8]&` است."

#: src/references/strings.md src/std-traits/read-and-write.md
msgid "\"World\""
msgstr "\"دنیا\""

#: src/references/strings.md
msgid "\"s1: {s1}\""
msgstr "\"s1: {s1}\""

#: src/references/strings.md
msgid "\"Hello \""
msgstr "\"سلام\""

#: src/references/strings.md src/memory-management/move.md
msgid "\"s2: {s2}\""
msgstr "\"s2: {s2}\""

#: src/references/strings.md
msgid "\"s3: {s3}\""
msgstr "\"s3: {s3}\""

#: src/references/strings.md
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`\"Hello\"`), are stored in the program’s binary."
msgstr ""
"<span dir=ltr>`&str`</span>  یک برش رشته‌ای را معرفی می‌کند، که یک مرجع "
"غیرقابل تغییر به داده‌های رشته‌ای رمزشده UTF-8 است که در یک بلوک حافظه ذخیره "
"شده است. لیترال های رشته‌ای <span dir=ltr>`String`</span>  (`”Hello”`) در "
"باینری برنامه ذخیره می‌شوند."

#: src/references/strings.md
msgid ""
"Rust's `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"در راست نوع ‍<span dir=ltr>`String`</span> یک wrapper بر روی یک بردار از "
"بایت‌هاست. مانند <span dir=ltr>`Vec<T>`</span>، یک نوع Owned است."

#: src/references/strings.md
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"مانند بسیاری از انواع دیگر، <span dir=ltr>`String::from()`</span> یک رشته از "
"یک لیترال رشته ایجاد می‌کند. <span dir=ltr>`String::new()`</span> که رشته "
"خالی جدید ایجاد می‌کند که داده های رشته‌ای می‌توانند با استفاده از متدهای <span "
"dir=ltr>`push()`</span> و <span dir=ltr>`push_str()`</span> به آن اضافه شوند."

#: src/references/strings.md
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"ماکرو <span dir=ltr>`format!()`</span> یک راه راحت برای ایجاد یک رشته Owned "
"از مقادیر پویا است. مثل فرمت قابل پذیرش توسط ماکرو <span dir=ltr>`println!"
"()`</span> است."

#: src/references/strings.md
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""
"می‌توانید برش‌های `&str` را از `String` از طریق `&` و انتخابی محدوده انتخاب "
"کنید. اگر محدوده بایتی را انتخاب کنید که با مرزهای نویسه تراز نباشد، عبارت "
"وحشت می کند. تکرار کننده `chars` روی کاراکترها تکرار می شود و بر تلاش برای "
"درست کردن مرزهای کاراکتر ترجیح داده می شود."

#: src/references/strings.md
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"برای برنامه‌نویسان <span dir=ltr>`C++`</span>: <span dir=ltr>`&str`</span>را  "
"به عنوان <span dir=ltr>`const char*`</span> در <span dir=ltr>`C++`</span> "
"درنظر بگیرید، اما یک فرق مهم این است که در راست که همیشه به یک رشته معتبر در "
"حافظه اشاره می کند. راست نوع <span dir=ltr>`String`</span>معادل تقریبی <span "
"dir=ltr>`std::string`</span> در <span dir=ltr>`C++`</span> است (با این تفاوت "
"که فقط می‌تواند حاوی بایت‌های رمزشده UTF-8 باشد و هرگز از بهینه‌سازی Small-"
"String استفاده نمی کند)."

#: src/references/strings.md
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr ""
"رشته‌های بایت به شما امکان می‌دهند مستقیماً یک مقدار <span dir=ltr>`&[u8]`</"
"span>  ایجاد کنید:"

#: src/references/strings.md
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"رشته‌های خام به شما امکان می دهند یک مقدار <span dir=ltr><code "
"class=hljs>&str</code></span> با غیرفعال کردن فرارها ایجاد کنید:  `r\"\\n\" "
"== \"\\\\n\"`.شما می‌توانید با استفاده از تعداد برابر `#` در دو طرف دابل‌کوت "
"دابل‌کوت‌ها، دابل‌کوت‌ها را جاسازی کنید:"

#: src/references/exercise.md
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""
"ما چند توابع کاربردی برای هندسه سه بعدی ایجاد خواهیم کرد که نقطه ای را به "
"عنوان `[f64;3]` نشان می دهد. تعیین امضاهای عملکرد به عهده شماست."

#: src/references/exercise.md
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""
"// اندازه یک بردار را با جمع مربعات مختصات آن محاسبه کنید\n"
"// و سپس جذر آن را بگیرید. از متد `sqrt()` برای محاسبه جذر استفاده کنید، مثل "
"`v.sqrt()`.\n"

#: src/references/exercise.md
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""
"// یک بردار را با محاسبه اندازه‌ی آن و تقسیم تمام مختصات آن\n"
"// بر آن اندازه، نرمال‌سازی کنید.\n"

#: src/references/exercise.md
msgid "// Use the following `main` to test your work.\n"
msgstr "// از `main` زیر برای تست کار خود استفاده کنید.\n"

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of a unit vector: {}\""
msgstr "\"اندازه‌ی یک بردار واحد: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?}: {}\""
msgstr "\"اندازه‌ی {v:?}: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr "\"اندازه‌ی {v:?} پس از نرمال‌سازی: {}\""

#: src/references/solution.md
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr "/// اندازه‌ی بردار داده شده را محاسبه کنید.\n"

#: src/references/solution.md
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr "/// اندازه‌ی بردار را به 1.0 تغییر دهید بدون اینکه جهت آن تغییر کند.\n"

#: src/user-defined-types.md src/methods-and-traits.md src/lifetimes.md
msgid "This segment should take about 50 minutes. It contains:"
msgstr "این بخش حدود ۵۰ دقیقه طول خواهد کشید. شامل موارد زیر است:"

#: src/user-defined-types/named-structs.md
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "‏مانند C و C++، زبان Rust از ساختارهای سفارشی پشتیبانی می‌کند:"

#: src/user-defined-types/named-structs.md
msgid "\"{} is {} years old\""
msgstr "‏\"{} {} ساله است\""

#: src/user-defined-types/named-structs.md
#: src/android/interoperability/with-c/bindgen.md
msgid "\"Peter\""
msgstr "\"پیتر\""

#: src/user-defined-types/named-structs.md
msgid "\"Avery\""
msgstr "\"ایوری\""

#: src/user-defined-types/named-structs.md
msgid "\"Jackie\""
msgstr "\"جکی\""

#: src/user-defined-types/named-structs.md src/user-defined-types/enums.md
#: src/pattern-matching/match.md src/methods-and-traits/methods.md
msgid "Key Points:"
msgstr "نکات کلیدی:"

#: src/user-defined-types/named-structs.md
msgid "Structs work like in C or C++."
msgstr "‏ساختارها (Structs) در Rust مانند C یا C++ عمل می‌کنند."

#: src/user-defined-types/named-structs.md
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr "‏مانند C++ و برخلاف C، برای تعریف یک نوع نیازی به `typedef` نیست."

#: src/user-defined-types/named-structs.md
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "‏برخلاف C++، در Rust بین ساختارها ارث‌بری وجود ندارد."

#: src/user-defined-types/named-structs.md
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr ""
"این زمان مناسبی است تا به مردمان اطلاع دهیم که انواع مختلفی از ساختارها وجود "
"دارد."

#: src/user-defined-types/named-structs.md
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don’t have any data that you want to store in the "
"value itself."
msgstr ""
"ساختارهای بدون اندازه (مانند `struct Foo;`) ممکن است زمانی استفاده شوند که "
"می‌خواهید یک صفت (trait) را بر روی یک نوع پیاده‌سازی کنید، اما داده‌ای ندارید "
"که بخواهید در خود مقدار ذخیره کنید."

#: src/user-defined-types/named-structs.md
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"اسلاید بعدی ساختارهای تاپل (Tuple structs) را معرفی خواهد کرد، که زمانی "
"استفاده می‌شوند که نام فیلدها مهم نیستند."

#: src/user-defined-types/named-structs.md
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr ""
"اگر از قبل متغیرهایی با نام‌های مناسب دارید، می‌توانید ساختار را با استفاده از "
"یک روش میانبر ایجاد کنید."

#: src/user-defined-types/named-structs.md
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"سینتکس `..avery` به ما اجازه می‌دهد که اکثر فیلدها را از ساختار قدیمی کپی "
"کنیم بدون اینکه همه آن‌ها را صریحاً تایپ کنیم. این باید همیشه آخرین عنصر باشد."

#: src/user-defined-types/tuple-structs.md
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "اگر نام فیلدها بی‌اهمیت هستند، می‌توانید از ساختار tuple استفاده کنید:"

#: src/user-defined-types/tuple-structs.md
msgid "\"({}, {})\""
msgstr "\"({}, {})\""

#: src/user-defined-types/tuple-structs.md
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"این اغلب برایsingle-field wrapper (که newtypes نامیده می‌شوند) استفاده می‌شود:"

#: src/user-defined-types/tuple-structs.md
msgid "\"Ask a rocket scientist at NASA\""
msgstr "\"از یک دانشمند حوزه موشک در ناسا بپرس\""

#: src/user-defined-types/tuple-structs.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/bare-metal/microcontrollers/type-state.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "// ...\n"
msgstr "// ...\n"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"Newtypes یک راه مناسب برای رمزگذاری اطلاعات اضافی در مورد مقدار در یک نوع "
"اولیه (primitive type) است، به عنوان مثال:"

#: src/user-defined-types/tuple-structs.md
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr "این عدد در برخی واحدها اندازه گیری می‌شود:  `Newtons` در مثال بالا."

#: src/user-defined-types/tuple-structs.md
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"مقدار زمانی که ایجاد شد مقداری اعتبارسنجی را دریافت کرد، بنابراین دیگر لازم "
"نیست در هر بار استفاده دوباره آن را تأیید کنید: `PhoneNumber(String)` یا "
"`OddNumber(u32)`."

#: src/user-defined-types/tuple-structs.md
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"نحوه افزودن مقدار `f64` به نوع `Newtons` را با دسترسی به single field در نوع "
"جدید نشان دهید."

#: src/user-defined-types/tuple-structs.md
msgid ""
"Rust generally doesn’t like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"Rust معمولاً چیزهای غیر واضح را دوست ندارد، مانند automatic unwrapping  یا "
"به‌عنوان‌مثال استفاده از booleanها به عنوان اعداد صحیح."

#: src/user-defined-types/tuple-structs.md
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "مبحث Operator overloading در روز سوم مورد بحث قرار می گیرد (generics)."

#: src/user-defined-types/tuple-structs.md
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"این مثال، اشاره ظریفی به شکست [مدارگَرد آب‌و‌هوای مریخ](https://en.wikipedia."
"org/wiki/Mars_Climate_Orbiter) است."

#: src/user-defined-types/enums.md
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"کلمه کلیدی `enum` اجازه ایجاد نوع داده‌ای را می دهد که دارای چندین گونه مختلف "
"است:"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "// Simple variant\n"
msgstr "// Simple variant\n"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "// Tuple variant\n"
msgstr "// Tuple variant\n"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "// Struct variant\n"
msgstr "// Struct variant\n"

#: src/user-defined-types/enums.md
msgid "\"On this turn: {:?}\""
msgstr "\"در این پیچ: {:?}\""

#: src/user-defined-types/enums.md
msgid "Enumerations allow you to collect a set of values under one type."
msgstr ""
"`Enum`ها به شما امکان می دهند مجموعه‌ای از مقادیر مختلف با نوع‌های مختلف را "
"تحت یک نوع جمع آوری کنید."

#: src/user-defined-types/enums.md
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""
"`Direction` یک type با گونه‌های مختلف است. دو مقدار `Direction` وجود دارد:  "
"`Direction::Left` و `Direction::Right`."

#: src/user-defined-types/enums.md
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""

#: src/user-defined-types/enums.md
msgid "This might be a good time to compare structs and enums:"
msgstr "الان زمان خوبی برای مقایسه ساختارها و `Enum`هاست:"

#: src/user-defined-types/enums.md
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"در هر دو، می توانید یک نسخه ساده بدون فیلد (unit struct) یا یکی با انواع "
"مختلف فیلد (variant payloads) داشته باشید."

#: src/user-defined-types/enums.md
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn’t be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"شما حتی می توانید انواع مختلف یک `Enum` را با ساختارهای جداگانه پیاده سازی "
"کنید، اما در آن صورت آنها از همان نوعی که در ابتدا تعریف کردید یعنی `Enum` "
"نخواهند بود."

#: src/user-defined-types/enums.md
msgid "Rust uses minimal space to store the discriminant."
msgstr ""
"Rust از حداقل فضا برای ذخیره‌سازی متمایز‌کننده (discriminant) استفاده می‌کند."

#: src/user-defined-types/enums.md
msgid "If necessary, it stores an integer of the smallest required size"
msgstr "در صورت لزوم، یک عدد صحیح با کوچکترین اندازه مورد نیاز را ذخیره می‌کند"

#: src/user-defined-types/enums.md
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""
"اگر مقادیر متغیر مجاز همه الگوهای bit را پوشش ندهند، از الگوهای bit نامعتبر "
"برای رمزگذاری متمایز کننده (یک  \"niche optimization\") استفاده می‌کند. برای "
"مثال، `Option<&u8>` یک اشاره‌گر به یک عدد صحیح یا `NULL` را برای نوع `None` "
"ذخیره می‌کند."

#: src/user-defined-types/enums.md
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""
"شما می توانید در صورت نیاز (به عنوان مثال، برای سازگاری با C) discriminant "
"را کنترل کنید:"

#: src/user-defined-types/enums.md
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"بدون `repr`، نوع discriminant دو بایت حافظه اشغال میکند، زیرا 10001 در 2 "
"بایت جا می‌شود."

#: src/user-defined-types/enums.md src/user-defined-types/static.md
#: src/memory-management/review.md src/memory-management/move.md
#: src/memory-management/copy-types.md src/smart-pointers/box.md
#: src/borrowing/shared.md src/error-handling/result.md
msgid "More to Explore"
msgstr "برای کاوش بیشتر"

#: src/user-defined-types/enums.md
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""
"زبان Rust دارای چندین بهینه‌سازی دارد که می‌تواند برای کاهش فضای اشغال شده "
"توسط`Enum`ها استفاده کند."

#: src/user-defined-types/enums.md
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"بهینه‌سازی اشاره‌گر `NULL`: برای برخی از انواع، Rust تضمین می‌کند که <span "
"dir=ltr>`size_of::<T>()`</span>  برابر با <span dir=ltr>`size_of::"
"<Option<T>>()`</span> است."

#: src/user-defined-types/enums.md
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"کد نمونه, اگر می‌خواهید نشان دهید که نمایش بیت به بیت در عمل چگونه ممکن است "
"به نظر برسد. مهم است توجه داشته باشید که کامپایلر هیچ تضمینی در مورد این "
"نمایش نمی‌دهد، بنابراین این کاملاً ناایمن است."

#: src/user-defined-types/const.md
msgid "`const`"
msgstr "`const`"

#: src/user-defined-types/const.md
#, fuzzy
msgid ""
"Constants are evaluated at compile time and their values are inlined "
"wherever they are used:"
msgstr ""
"متغیرهای ثابت در زمان کامپایل ارزیابی می شوند و مقادیر آنها در هر جایی که "
"استفاده می شوند، درج می شوند:"

#: src/user-defined-types/const.md
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"طبق [کتاب Rust RFC](https://rust-lang.github.io/rfcs/0246-const-vs-static."
"html)، این موارد هنگام استفاده درج می شوند."

#: src/user-defined-types/const.md
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"فقط توابعی که با `const` علامت گذاری شده اند می توانند در زمان کامپایل برای "
"تولید مقادیر `const` فراخوانی شوند. با این حال، توابع `const` را می توان در "
"زمان اجرا فراخوانی کرد (بر خلاف تعریف متغییری ثابت)"

#: src/user-defined-types/const.md
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`"
msgstr ""
"به این نکته اشاره کنید که `const` شبیه `constexpr` در <span dir=ltr>`C++`</"
"span> عمل می‌کند."

#: src/user-defined-types/const.md
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"با اینکه خیلی رایج نیست که اگر کسی به یک یک مقدار ثابت  که در زمان اجرا "
"ارزیابی می‌شود از `const` استفاده کند اما مفید تر و ایمن تر از استفاده "
"`static`ها هستند."

#: src/user-defined-types/static.md
msgid "`static`"
msgstr "`static`"

#: src/user-defined-types/static.md
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"متغیرهای ایستا در طول عمر کل اجرای برنامه خواهند ماند و بنابراین منتقل "
"نمی‌شوند:"

#: src/user-defined-types/static.md
msgid "\"Welcome to RustOS 3.14\""
msgstr "\"به RustOS 3.14 خوش آمدید\""

#: src/user-defined-types/static.md
msgid "\"{BANNER}\""
msgstr "\"{BANNER}\""

#: src/user-defined-types/static.md
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"همانطور که در [کتاب Rust RFC](https://rust-lang.github.io/rfcs/0246-const-vs-"
"static.html) ذکر شده، این موارد هنگام استفاده درج نمی شوند و دارای یک مکان "
"حافظه واقعی هستند. این برای کدهای ناایمن و `embedded` مفید است و متغیر در کل "
"اجرای برنامه زنده می ماند. هنگامی که یک مقدار با اسکوپ گلوبال نیاز نیست, "
"استفاده از `const` ترجیح داده می‌شود."

#: src/user-defined-types/static.md
#, fuzzy
msgid "`static` is similar to mutable global variables in C++."
msgstr ""
"از سوی دیگر، `static` بسیار شبیه به یک متغیر سراسری `const` یا `mutable` در "
"<span dir=ltr>`C++`</span> هستند."

#: src/user-defined-types/static.md
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static` هویت شی را فراهم می‌کند: آدرسی در حافظه و حالتی که توسط انواع با "
"تغییرپذیری داخلی مانند <span dir=ltr>`Mutex<T>`</span> را نیاز دارد."

#: src/user-defined-types/static.md
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"از آنجایی که متغیرهای `static` از هر رشته‌ای (thread) قابل دسترسی هستند، باید "
"`Sync` باشند. تغییرپذیری داخلی از طریق یک [`Mutex`](https://doc.rust-lang."
"org/std/sync/struct.Mutex.html)، اتمی یا مشابه امکان پذیر است. البته که "
"داشتن متغییر های استاتیک قابل تغییر هم امکان پذیر هست اما برای این کار نیاز "
"به همگام سازی دستی دارند.  بنابراین هر دسترسی به آنها نیاز به کد `unsafe` "
"دارد. ما در فصل Unsafe Rust به استاتیک های قابل تغییر [mutable statics](../"
"unsafe/mutable-static-variables.md) نگاه خواهیم کرد."

#: src/user-defined-types/static.md
#, fuzzy
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr ""
"داده‌های `thread_local` را با ماکروی <span dir=ltr>`std::thread_local`</span> "
"می‌توان ایجاد کرد."

#: src/user-defined-types/aliases.md
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr ""
"تایپ  alias، نامی برای نوع دیگر ایجاد می کند. این دو نوع را می توان به جای "
"هم استفاده کرد."

#: src/user-defined-types/aliases.md
#, fuzzy
msgid "// Aliases are more useful with long, complex types:\n"
msgstr "// Aliases are more useful with long, complex types:\n"

#: src/user-defined-types/aliases.md
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr "برنامه‌نویسان C این را شبیه به `typedef` تشخیص می‌دهند."

#: src/user-defined-types/exercise.md
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""
"ما یک ساختار داده برای نمایش یک رویداد در یک سیستم کنترل آسانسور ایجاد "
"خواهیم کرد. این به شما بستگی دارد که انواع و عملکردها را برای ساخت رویدادهای "
"مختلف تعریف کنید. از `#[derive(Debug)]` استفاده کنید تا اجازه دهید انواع با "
"`{:?}` قالببندی شوند."

#: src/user-defined-types/exercise.md
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""
"این تمرین فقط به ایجاد و پر کردن ساختارهای داده نیاز دارد تا `main` بدون خطا "
"اجرا شود. بخش بعدی این دوره دریافت داده‌ها از این ساختارها را پوشش می‌دهد."

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""
"/// An event in the elevator system that the controller must react to.\n"

#: src/user-defined-types/exercise.md
#, fuzzy
msgid "// TODO: add required variants\n"
msgstr "// TODO: add required variants\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// A direction of travel.\n"
msgstr "/// A direction of travel.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car has arrived on the given floor.\n"
msgstr "/// The car has arrived on the given floor.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car doors have opened.\n"
msgstr "/// The car doors have opened.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car doors have closed.\n"
msgstr "/// The car doors have closed.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr "/// A floor button was pressed in the elevator car.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
#, fuzzy
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr "\"یک مسافر طبقه همکف دکمه بالا را فشار داده است: {:?} \""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr "\"ماشین به طبقه همکف رسیده است: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car door opened: {:?}\""
msgstr "\"در ماشین باز شد: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr "\"یک مسافر دکمه طبقه 3 را فشار داده است: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car door closed: {:?}\""
msgstr "\"در ماشین بسته شد: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr "\"ماشین به طبقه ۳ رسیده است: {:?}\""

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A button was pressed.\n"
msgstr "/// A button was pressed.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car has arrived at the given floor.\n"
msgstr "/// The car has arrived at the given floor.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car's doors have opened.\n"
msgstr "/// The car's doors have opened.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// The car's doors have closed.\n"
msgstr "/// The car's doors have closed.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor is represented as an integer.\n"
msgstr "/// A floor is represented as an integer.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A user-accessible button.\n"
msgstr "/// A user-accessible button.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr "/// A button in the elevator lobby on the given floor.\n"

#: src/user-defined-types/solution.md
#, fuzzy
msgid "/// A floor button within the car.\n"
msgstr "/// A floor button within the car.\n"

#: src/welcome-day-2.md
msgid "Welcome to Day 2"
msgstr "به روز ۲ خوش آمدید"

#: src/welcome-day-2.md
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr ""
"اکنون که مقدار زیادی از Rust را دیده ایم، امروز بر روی سیستم تایپ Rust تمرکز "
"خواهیم کرد:"

#: src/welcome-day-2.md
msgid "Pattern matching: extracting data from structures."
msgstr "تطبیق الگو: استخراج داده از ساختارها."

#: src/welcome-day-2.md
msgid "Methods: associating functions with types."
msgstr "متد‌ها: ارتباط توابع با تایپ ها."

#: src/welcome-day-2.md
msgid "Traits: behaviors shared by multiple types."
msgstr "Traits: رفتارهایی که توسط چندین تایپ مشترک هستند."

#: src/welcome-day-2.md
msgid "Generics: parameterizing types on other types."
msgstr "Generics: پارامتری‌سازی تایپ‌ها بر اساس تایپ‌های دیگر."

#: src/welcome-day-2.md
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr ""
"کتابخانه‌استاندارد تایپ‌ها و traits: یک گردش در کتابخانه‌ استاندارد و ارزشمند "
"Rust."

#: src/welcome-day-2.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 10 "
"minutes. It contains:"
msgstr ""
"با احتساب ۱۰ دقیقه استراحت، این جلسه باید حدود ۲ ساعت و ۱۰ دقیقه طول بکشد. "
"این شامل:"

#: src/pattern-matching.md src/std-types.md src/memory-management.md
#: src/error-handling.md
msgid "This segment should take about 1 hour. It contains:"
msgstr "این بخش باید حدود ۱ ساعت طول بکشد. این شامل:"

#: src/pattern-matching/match.md
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"کلمه کلیدی `match` به شما اجازه می‌دهد یک مقدار را با یک یا چند _الگو_ مطابقت "
"دهید. مقایسه‌ها از بالا به پایین انجام می‌شوند و اولین تطابق انتخاب می‌شود."

#: src/pattern-matching/match.md
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "الگوها می توانند مقادیر ساده ای باشند، شبیه به `switch` در C و ++C:"

#: src/pattern-matching/match.md
msgid "'x'"
msgstr "'x'"

#: src/pattern-matching/match.md
msgid "'q'"
msgstr "'q'"

#: src/pattern-matching/match.md
msgid "\"Quitting\""
msgstr "\"ترک کردن\""

#: src/pattern-matching/match.md src/generics/exercise.md
#: src/generics/solution.md src/std-traits/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'a'"
msgstr "'a'"

#: src/pattern-matching/match.md
msgid "'s'"
msgstr "'s'"

#: src/pattern-matching/match.md
msgid "'w'"
msgstr "'w'"

#: src/pattern-matching/match.md
msgid "'d'"
msgstr "'d'"

#: src/pattern-matching/match.md
msgid "\"Moving around\""
msgstr "\"حرکت در اطراف\""

#: src/pattern-matching/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'0'"
msgstr "'0'"

#: src/pattern-matching/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'9'"
msgstr "'9'"

#: src/pattern-matching/match.md
msgid "\"Number input\""
msgstr "\"ورودی شماره\""

#: src/pattern-matching/match.md
msgid "\"Lowercase: {key}\""
msgstr "\"حروف کوچک: {key}\""

#: src/pattern-matching/match.md
msgid "\"Something else\""
msgstr "\"یک چیز دیگر\""

#: src/pattern-matching/match.md
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be exhaustive, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""
"الگوی `_` یک الگوی عام (Wildcard) است که با هر مقداری مطابقت دارد. عبارت‌ها "
"باید جامع باشند، به این معنی که همه احتمالات را پوشش دهند، بنابراین `_` اغلب "
"به عنوان آخرین حالت برای پوشش تمامی موارد استفاده می‌شود."

#: src/pattern-matching/match.md
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"`match` می‌تواند به عنوان یک عبارت استفاده شود. دقیقاً مانند `if`، هر شاخه "
"match باید از یک تایپ باشد. تایپ بازگشتی، تایپ آخرین عبارت در بلاک است، اگر "
"وجود داشته باشد. در مثال بالا، تایپ بازگشتی `()` است."

#: src/pattern-matching/match.md
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr ""
"یک متغیر در الگو (`key` در این مثال) یک اتصال ایجاد می‌کند که می‌توان از آن در "
"بخش مطابقت استفاده کرد."

#: src/pattern-matching/match.md
msgid "A match guard causes the arm to match only if the condition is true."
msgstr ""
"یک guard در عبارت `match` باعث می‌شود که آن شاخه تنها در صورتی مطابقت داشته "
"باشد که شرط برقرار باشد."

#: src/pattern-matching/match.md
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr ""
"بهتر است که اشاره کنید چطوری میتوان از کاراکترهای خاص در الگو استفاده کرد"

#: src/pattern-matching/match.md
msgid "`|` as an `or`"
msgstr "`|` به عنوان `or`"

#: src/pattern-matching/match.md
msgid "`..` can expand as much as it needs to be"
msgstr "`..` برای تعیین همه محدوده یا تا جایی که میتوان گسترش یابد"

#: src/pattern-matching/match.md
msgid "`1..=5` represents an inclusive range"
msgstr ""
"<span dir=ltr><code class=hljs>1..=5</code></span> نمایانگر یک محدوده خاص است"

#: src/pattern-matching/match.md
msgid "`_` is a wild card"
msgstr "`_` نمایانگر هر حالتی است"

#: src/pattern-matching/match.md
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"guard های تطبیق به عنوان یک ویژگی سینتکس جداگانه دسته بندی می‌شوند, زمانی مهم "
"و ضروری هستند که بخواهیم ایده های پیچیده تر از الگوهای ساده بیان کنیم."

#: src/pattern-matching/match.md
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"آنها با عبارت `if` جداگانه ای در داخل یک شاخه تطبیق هستند یکسان نیستند. یک "
"عبارت `if` در داخل بلاک شاخه (پس از <span dir=ltr>`=>`</span>) پس از ورود به "
"اون شاخه خاص صدا زده میشود. اگر شرط `if` برقرار نباشد کاری به سایر شاخه های "
"عبارت `match` اصلی ندارد."

#: src/pattern-matching/match.md
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr "شرط تعریف شده در guard با کمک `|` به شرط های تطبیق الگو اضافه می‌شود."

#: src/pattern-matching/destructuring-structs.md
msgid "Structs"
msgstr "ساختارها"

#: src/pattern-matching/destructuring-structs.md
msgid "Like tuples, Struct can also be destructured by matching:"
msgstr "مانند tuple ها، ساختار را نیز می توان با تطبیق تخریب کرد:"

#: src/pattern-matching/destructuring-structs.md
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr "\"x.0 = 1, b = {b}, y = {y}\""

#: src/pattern-matching/destructuring-structs.md
msgid "\"y = 2, x = {i:?}\""
msgstr "\"y = 2, x = {i:?}\""

#: src/pattern-matching/destructuring-structs.md
msgid "\"y = {y}, other fields were ignored\""
msgstr "\"در y = {y} ، سایر فیلدها نادیده گرفته شدند\""

#: src/pattern-matching/destructuring-structs.md
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr "تغییر مقادیر لیترال در foo برای مطابقت با سایر الگوها."

#: src/pattern-matching/destructuring-structs.md
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr "اضافه کردن یک فیلد جدید به Foo و ایجاد تغییرات مورد نیاز."

#: src/pattern-matching/destructuring-structs.md
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"تشخیص تفاوت بین یک گرفتن متغییر و یک عبارت ثابت می‌تواند دشوار باشد. سعی کنید "
"‍`2` را در شاخه دوم به یک متغیر تغییر دهید و خواهید دید که  کار نمی‌کند. آن را "
"به یک `const` تغییر دهید و خواهید دید که دوباره کار می‌کند."

#: src/pattern-matching/destructuring-enums.md
msgid "Like tuples, enums can also be destructured by matching:"
msgstr "مانند tuple ها، enum ها را نیز می توان با تطبیق تخریب کرد:"

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"الگوها همچنین می‌توانند برای متصل کردن متغیرها به بخش‌هایی از مقادیر شما "
"استفاده شوند. این روش به شما اجازه می‌دهد ساختار انواع خود را بررسی کنید. "
"بیایید با یک نوع ساده `enum` شروع کنیم:"

#: src/pattern-matching/destructuring-enums.md
msgid "\"cannot divide {n} into two equal parts\""
msgstr "\"نمی توان  {n}  را به دو قسمت مساوی تقسیم کرد\""

#: src/pattern-matching/destructuring-enums.md
msgid "\"{n} divided in two is {half}\""
msgstr "\"{n} تقسیم به دو است {half}\""

#: src/pattern-matching/destructuring-enums.md
msgid "\"sorry, an error happened: {msg}\""
msgstr "\"با عرض‌پوزش، خطایی رخ داده است: {msg}\""

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"اینجا از شاخه‌ها برای _تجزیه_ مقدار `Result` استفاده کرده‌ایم. در شاخه‌ی اول، "
"`half` به مقداری که درون حالت `Ok` قرار دارد متصل شده است. در شاخه‌ی دوم، "
"`msg` به پیام خطا متصل شده است."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"عبارت `if`/`else` یک نوع enum بازمی‌گرداند که بعداً با استفاده از `match` از "
"هم باز می‌شود."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"می توانید با اضافه کردن یک فیلد دیگر `None` به `enum`  اضافه کنید و نمایش "
"خطاها هنگام اجرای کد، را تست کنید. مکان هایی را که کد شما اکنون ناقص است و "
"نحوه تلاش کامپایلر برای ارائه نکاتی به شما را نشان دهید."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched."
msgstr "مقادیر در حالات enum تنها پس از تطبیق الگو قابل دسترسی هستند."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"نشان دهید چه اتفاقی می‌افتد وقتی جستجو (مطابقت) ناقص است. به مزیتی که "
"کامپایلر Rust فراهم می‌کند، اشاره کنید که تأیید می‌کند همه حالات پوشش داده "
"شده‌اند."

#: src/pattern-matching/destructuring-enums.md
msgid ""
"Save the result of `divide_in_two` in the `result` variable and `match` it "
"in a loop. That won't compile because `msg` is consumed when matched. To fix "
"it, match `&result` instead of `result`. That will make `msg` a reference so "
"it won't be consumed. This [\"match ergonomics\"](https://rust-lang.github."
"io/rfcs/2005-match-ergonomics.html) appeared in Rust 2018. If you want to "
"support older Rust, replace `msg` with `ref msg` in the pattern."
msgstr ""
"نتیجه‌ی تابع `divide_in_two` را در متغیر `result` ذخیره کنید و آن را در یک "
"حلقه با استفاده از `match` بررسی کنید. این کد کامپایل نمی‌شود زیرا `msg` "
"هنگام مطابقت مصرف می‌شود. برای رفع این مشکل، به جای `result` از `result&` "
"استفاده کنید. این کار باعث می‌شود `msg` به صورت یک ارجاع باشد و مصرف نشود. "
"این ویژگی که به نام [\"match ergonomics\"](https://rust-lang.github.io/"
"rfcs/2005-match-ergonomics.html) شناخته می‌شود، در Rust 2018 معرفی شده است. "
"اگر می‌خواهید از نسخه‌های قدیمی‌تر Rust پشتیبانی کنید، به جای `msg` از `ref "
"msg` در الگو استفاده کنید."

#: src/pattern-matching/let-control-flow.md
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""
"زبان Rust چند ساختار کنترل جریان دارد که با سایر زبان‌ها متفاوت است. این "
"ساختارها برای مطابقت الگو استفاده می‌شوند:"

#: src/pattern-matching/let-control-flow.md
msgid "`if let` expressions"
msgstr "عبارت `if let`"

#: src/pattern-matching/let-control-flow.md
msgid "`let else` expressions"
msgstr "عبارت `let else`"

#: src/pattern-matching/let-control-flow.md
msgid "`while let` expressions"
msgstr "عبارت `while let`"

#: src/pattern-matching/let-control-flow.md
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"[عبارت `if let`](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions)  به شما امکان می‌دهد بسته به اینکه آیا یک مقدار با "
"یک الگو مطابقت دارد، کدهای مختلفی را اجرا کنید:"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"slept for {:?}\""
msgstr "\"slept for {:?}\""

#: src/pattern-matching/let-control-flow.md
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""
"برای حالت رایج مطابقت با یک الگو و بازگشت از تابع، از [`let else`](https://"
"doc.rust-lang.org/rust-by-example/flow_control/let_else.html) استفاده کنید. "
"در اینجا، حالت \"else\" باید منحرف شود (مانند `return`، `break`، یا `panic` "
"- به غیر از اینکه از انتهای بلوک خارج شود)."

#: src/pattern-matching/let-control-flow.md
msgid "\"not a hex digit\""
msgstr "\"نه یک hex digit\""

#: src/pattern-matching/let-control-flow.md
msgid "\"got empty string\""
msgstr "\"یک string خالی دریافت کردم\""

#: src/pattern-matching/let-control-flow.md
msgid "\"got None\""
msgstr "\"هیچ‌کدام\""

#: src/pattern-matching/let-control-flow.md src/pattern-matching/solution.md
msgid "\"result: {:?}\""
msgstr "\"نتیجه: {:?}\""

#: src/pattern-matching/let-control-flow.md src/generics/trait-bounds.md
#: src/smart-pointers/solution.md src/testing/solution.md
#: src/android/testing.md src/android/testing/googletest.md
msgid "\"foo\""
msgstr "\"foo\""

#: src/pattern-matching/let-control-flow.md
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"مانند `if let`، یک دستور [`while let`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#predicate-pattern-loops) وجود دارد که مقادیر "
"مقابل الگو به طور مکرر (تکرار شونده‌ای) بررسی می‌کند:"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"در اینجا [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) تا زمانی که رشته خالی نشده است، `Some(c)` را "
"برمی‌گرداند و پس از آن `None` را باز می‌گرداند. استفاده از `while let` به ما "
"این امکان را می‌دهد که به طور مداوم از میان همه موارد عبور کنیم."

#: src/pattern-matching/let-control-flow.md
msgid "if-let"
msgstr "if-let"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"برخلاف دستور `match` دستور `if let` همه حالت های ممکن را برای تطبیق الگو "
"پشتیبانی نمیکند. اگر می‌خواهید همه حالت را پوشش دهید از دستور `match` استفاده "
"کنید."

#: src/pattern-matching/let-control-flow.md
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"یک استفاده رایج از دستور `if let`، رسیدگی به مقادیر `Some` هنگام کار با "
"`Option` است."

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"برخلاف دستور `match` دستور `if let`  از <span dir=ltr>`=>`</span> برای تطبیق "
"الگو استفاده نمیکند."

#: src/pattern-matching/let-control-flow.md
msgid "let-else"
msgstr "let-else"

#: src/pattern-matching/let-control-flow.md
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""
"`if-let` ها می‌توانند به صورت تو در تو انباشته شوند، همان‌طور که در اینجا نشان "
"داده شده است. ساختار `let-else` از فلت کردن این کدهای تو در تو پشتیبانی "
"می‌کند. نسخه‌ی پیچیده را برای دانش‌آموزان بازنویسی کنید تا بتوانند تبدیل آن را "
"مشاهده کنند."

#: src/pattern-matching/let-control-flow.md
msgid "The rewritten version is:"
msgstr "نسخه‌ی بازنویسی شده به صورت زیر است:"

#: src/pattern-matching/let-control-flow.md
msgid "while-let"
msgstr "while-let"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"توجه داشته باشید که حلقه `while let` تا زمانی که مقادیر مقابل الگو طبیق "
"داشته باشد (شرط برقرار باشد)، ادامه خواهد داشت."

#: src/pattern-matching/let-control-flow.md
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"شما می‌توانید حلقه‌ی `while let` را به صورت یک حلقه بی‌پایان با یک دستور `if` "
"بازنویسی کنید که در صورت عدم وجود مقداری برای باز کردن (unwrap) از `()name."
"pop`، شکسته می‌شود. `while let` یک Syntactic sugar برای این سناریو ارائه "
"می‌دهد."

#: src/pattern-matching/exercise.md
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr "بیایید یک ارزیاب ساده بازگشتی برای عبارات حسابی بنویسیم."

#: src/pattern-matching/exercise.md
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""
"نوع `Box` در اینجا یک اشاره‌گر هوشمند است و در ادامه دوره به طور مفصل مورد "
"بررسی قرار خواهد گرفت. یک عبارت می‌تواند با استفاده از `Box::new` \"باکس\" "
"شود، همان‌طور که در تست‌ها مشاهده می‌شود. برای ارزیابی یک عبارت باکس‌شده، از "
"عملگر deref (`*`) برای \"باز کردن باکس\" استفاده کنید: `eval(*boxed_expr)`."

#: src/pattern-matching/exercise.md
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""
"برخی از عبارات نمی‌توانند ارزیابی شوند و خطا برمی‌گردانند. نوع استاندارد "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) یک enum است که یا نمایانگر یک مقدار موفقیت‌آمیز (`Ok(Value)`) یا یک خطا "
"(`Err(String)`) است. ما این نوع را به‌طور مفصل‌تر در آینده پوشش خواهیم داد."

#: src/pattern-matching/exercise.md
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""
"کد را کپی و در Rust Playground پیست کنید و پیاده‌سازی تابع `eval` را آغاز "
"کنید. محصول نهایی باید تست‌ها را پاس کند. ممکن است استفاده از `()!todo` و "
"گذراندن تست‌ها به صورت تک به تک مفید باشد. همچنین می‌توانید به طور موقت یک تست "
"را با استفاده از `[ignore]#` نادیده بگیرید:"

#: src/pattern-matching/exercise.md
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""
"اگر زودتر تمام کردید، سعی کنید یک تست بنویسید که منجر به تقسیم بر صفر یا "
"سرریز عدد صحیح شود. چگونه می‌توانید این را با استفاده از `Result` به جای "
"panic مدیریت کنید؟"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An operation to perform on two subexpressions.\n"
msgstr "/// An operation to perform on two subexpressions.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An expression, in tree form.\n"
msgstr "/// An expression, in tree form.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// An operation on two subexpressions.\n"
msgstr "/// An operation on two subexpressions.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
#, fuzzy
msgid "/// A literal value\n"
msgstr "/// A literal value\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "\"division by zero\""
msgstr "\"تقسیم بر صفر\""

#: src/pattern-matching/solution.md
msgid "\"expr: {:?}\""
msgstr "\"expr: {:?}\""

#: src/methods-and-traits/methods.md
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust به شما این امکان را می‌دهد که توابعی را با تایپ جدید خود مرتبط کنید. این "
"کار را با استفاده از بلوک `impl` انجام می‌دهید:"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// No receiver, a static method\n"
msgstr "// No receiver, a static method\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Exclusive borrowed read-write access to self\n"
msgstr "// Exclusive borrowed read-write access to self\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Shared and read-only borrowed access to self\n"
msgstr "// Shared and read-only borrowed access to self\n"

#: src/methods-and-traits/methods.md
msgid "\"Recorded {} laps for {}:\""
msgstr "\"ضبط {} دور برای {}:\""

#: src/methods-and-traits/methods.md
msgid "\"Lap {idx}: {lap} sec\""
msgstr "\"Lap {idx}: {lap} sec\""

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "// Exclusive ownership of self\n"
msgstr "// Exclusive ownership of self\n"

#: src/methods-and-traits/methods.md
msgid "\"Race {} is finished, total lap time: {}\""
msgstr "\"مسابقه {} به پایان رسید، کل زمان دور: {}\""

#: src/methods-and-traits/methods.md
msgid "\"Monaco Grand Prix\""
msgstr "\"جایزه بزرگ موناکو\""

#: src/methods-and-traits/methods.md
msgid "// race.add_lap(42);\n"
msgstr "// race.add_lap(42);\n"

#: src/methods-and-traits/methods.md
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"آرگومان‌های `self` \"گیرنده\" را مشخص می‌کنند - شیئی که متد بر روی آن عمل "
"می‌کند. چندین گیرنده رایج برای یک متد وجود دارد:"

#: src/methods-and-traits/methods.md
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`self&`: شیئی را از فراخواننده با استفاده از یک مرجع مشترک و غیرقابل تغییر "
"قرض می‌گیرد. شیء می‌تواند بعداً دوباره استفاده شود."

#: src/methods-and-traits/methods.md
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`mut self&`: شیء را از فراخواننده با استفاده از یک مرجع منحصر به فرد و قابل "
"تغییر قرض می‌گیرد. شی پس از آن نمی‌تواند دوباره استفاده شود تا زمانی که مرجع "
"به پایان برسد."

#: src/methods-and-traits/methods.md
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: مالکیت شیء را به عهده می‌گیرد و آن را از فراخواننده منتقل می‌کند. متد "
"مالک شیء می‌شود. شیء هنگامی که متد باز می‌گردد حذف خواهد شد، مگر اینکه مالکیت "
"آن به‌طور صریح منتقل شود. مالکیت کامل به‌طور خودکار به معنای قابلیت تغییر نیست."

#: src/methods-and-traits/methods.md
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr "`mut self`: مشابه مورد بالا، اما متد می‌تواند شیء را تغییر دهد."

#: src/methods-and-traits/methods.md
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"بدون گیرنده: این تبدیل به یک متد استاتیک در ساختار می‌شود. معمولاً برای ایجاد "
"سازنده‌ها استفاده می‌شود که به‌طور معمول `new` نامیده می‌شوند."

#: src/methods-and-traits/methods.md
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "مفید است که متدها را با مقایسه آنها با توابع معرفی کنیم."

#: src/methods-and-traits/methods.md
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"متدها بر روی یک نمونه از تایپی (مانند struct یا enum) فراخوانی می‌شوند، و "
"پارامتر اول نمونه را به‌عنوان نمونه `self`."

#: src/methods-and-traits/methods.md
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"توسعه‌دهندگان ممکن است تصمیم بگیرند از متدها استفاده کنند تا از نحو گیرنده "
"متد بهره‌برداری کنند و به سازمان‌دهی بهتر کد کمک کنند. با استفاده از متدها، "
"می‌توانیم تمامی کدهای پیاده‌سازی را در یک مکان قابل پیش‌بینی نگه داریم."

#: src/methods-and-traits/methods.md
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr ""
"استفاده از کلمه کلیدی `self`، که به‌عنوان گیرنده متد عمل می‌کند، را مشخص کنید."

#: src/methods-and-traits/methods.md
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"نشان دهید که `self` یک اصطلاح کوتاه‌شده برای `self: Self` است و شاید نشان "
"دهید که چگونه نام struct نیز می‌تواند استفاده شود."

#: src/methods-and-traits/methods.md
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"توضیح دهید که `Self` یک نام مستعار نوع برای تایپ است که بلوک `impl` در آن "
"قرار دارد و می‌تواند در سایر بخش‌های بلوک استفاده شود."

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"توجه کنید که چگونه `self` مانند سایر ساختارها استفاده می‌شود و dot notation "
"می‌تواند برای ارجاع به فیلدهای فردی به کار رود."

#: src/methods-and-traits/methods.md
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"این ممکن است زمان مناسبی باشد برای نشان دادن تفاوت بین `self&` و `self` با "
"تلاش برای اجرای متد `finish` دو بار."

#: src/methods-and-traits/methods.md
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"فراتر از حالت‌های مختلف `self`، تایپ‌های [special wrapper types](https://doc."
"rust-lang.org/reference/special-types-and-traits.html) نیز وجود دارند که "
"به‌عنوان تایپ‌های گیرنده مجاز هستند، مانند `<Box<Self`."

#: src/methods-and-traits/traits.md
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"راست به شما این امکان را می‌دهد که با استفاده از traits بر روی تایپ‌ها انتزاع "
"ایجاد کنید. آنها مشابه interface ها هستند:"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid "/// Return a sentence from this pet.\n"
msgstr "/// Return a sentence from this pet.\n"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid "/// Print a string to the terminal greeting this pet.\n"
msgstr "/// Print a string to the terminal greeting this pet.\n"

#: src/methods-and-traits/traits.md
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr ""
"یک trait مجموعه‌ای از متدها را تعریف می‌کند که تایپ‌ها باید آن‌ها را داشته باشند "
"تا بتوانند آن trait را پیاده‌سازی کنند."

#: src/methods-and-traits/traits.md
msgid ""
"In the \"Generics\" segment, next, we will see how to build functionality "
"that is generic over all types implementing a trait."
msgstr ""
"در بخش \"Generics\"، در ادامه خواهیم دید که چگونه می‌توانیم عملکردی بسازیم که "
"generic بر روی تمام تایپ‌های که یک trait را پیاده‌سازی کرده‌اند باشد."

#: src/methods-and-traits/traits/implementing.md
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr "\"اوه تو چثدر زیبا هستی! اسمت چیه؟ {}\""

#: src/methods-and-traits/traits/implementing.md src/generics/dyn-trait.md
#: src/smart-pointers/trait-objects.md
msgid "\"Woof, my name is {}!\""
msgstr "\"  Woof، نام من {} است!\""

#: src/methods-and-traits/traits/implementing.md src/generics/dyn-trait.md
#: src/smart-pointers/trait-objects.md
msgid "\"Fido\""
msgstr "\"Fido\""

#: src/methods-and-traits/traits/implementing.md
msgid ""
"To implement `Trait` for `Type`, you use an `impl Trait for Type { .. }` "
"block."
msgstr ""
"برای پیاده‌سازی `Trait` برای `Type`، از بلوک `{ .. } impl Trait for Type` "
"استفاده می‌کنید."

#: src/methods-and-traits/traits/implementing.md
msgid ""
"Unlike Go interfaces, just having matching methods is not enough: a `Cat` "
"type with a `talk()` method would not automatically satisfy `Pet` unless it "
"is in an `impl Pet` block."
msgstr ""
"برخلاف رابط‌های Go، داشتن فقط متدهای مطابقت‌دهنده کافی نیست: نوع `Cat` با متد "
"`()talk` به‌طور خودکار `Pet` را برآورده نمی‌کند، مگر اینکه در یک بلوک `impl "
"Pet` قرار داشته باشد."

#: src/methods-and-traits/traits/implementing.md
msgid ""
"Traits may provide default implementations of some methods. Default "
"implementations can rely on all the methods of the trait. In this case, "
"`greet` is provided, and relies on `talk`."
msgstr ""
"Traits ممکن است پیاده‌سازی‌های پیش‌فرض برای برخی از متدها ارائه دهند. "
"پیاده‌سازی‌های پیش‌فرض می‌توانند به تمامی متدهای trait وابسته باشند. در این "
"مورد، `greet` ارائه شده است و به `talk` وابسته است."

#: src/methods-and-traits/traits/supertraits.md
msgid ""
"A trait can require that types implementing it also implement other traits, "
"called _supertraits_. Here, any type implementing `Pet` must implement "
"`Animal`."
msgstr ""
"یک trait می‌تواند نیاز داشته باشد که تایپ‌هایی که آن را پیاده‌سازی می‌کنند، "
"همچنین traits دیگری به نام _supertraits_ را نیز پیاده‌سازی کنند. در اینجا، هر "
"نوعی که `Pet` را پیاده‌سازی کند، باید `Animal` را نیز پیاده‌سازی کند."

#: src/methods-and-traits/traits/supertraits.md
msgid "\"Rex\""
msgstr "\"Rex\""

#: src/methods-and-traits/traits/supertraits.md
msgid "\"{} has {} legs\""
msgstr "\"{} has {} legs\""

#: src/methods-and-traits/traits/supertraits.md
msgid ""
"This is sometimes called \"trait inheritance\" but students should not "
"expect this to behave like OO inheritance. It just specifies an additional "
"requirement on implementations of a trait."
msgstr ""
"این گاهی اوقات \"trait inheritance\" نامیده می‌شود، اما دانش‌آموزان نباید "
"انتظار داشته باشند که این رفتار مشابه وراثت در برنامه‌نویسی شیءگرا (OO) باشد. "
"این تنها یک الزام اضافی بر روی پیاده‌سازی‌های یک trait را مشخص می‌کند."

#: src/methods-and-traits/traits/associated-types.md
msgid ""
"Associated types are placeholder types which are supplied by the trait "
"implementation."
msgstr ""
"تایپ‌های مرتبط تایپ‌هایی جایگزین هستند که توسط پیاده‌سازی trait تأمین می‌شوند."

#: src/methods-and-traits/traits/associated-types.md
#: src/concurrency/async-control-flow/join.md
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/methods-and-traits/traits/associated-types.md
msgid ""
"Associated types are sometimes also called \"output types\". The key "
"observation is that the implementer, not the caller, chooses this type."
msgstr ""
"تایپ‌های مرتبط گاهی اوقات \"تایپ‌های خروجی\" نیز نامیده می‌شوند. نکته کلیدی این "
"است که پیاده‌ساز، نه فراخواننده، این تایپ را انتخاب می‌کند."

#: src/methods-and-traits/traits/associated-types.md
msgid ""
"Many standard library traits have associated types, including arithmetic "
"operators and `Iterator`."
msgstr ""
"بسیاری از traitهای کتابخانه استاندارد دارای نوع‌های مرتبط هستند، از جمله "
"اپراتورهای حسابی و `Iterator`."

#: src/methods-and-traits/deriving.md
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr ""
"Traitهای پشتیبانی‌شده می‌توانند به‌طور خودکار برای تایپ‌های سفارشی شما پیاده‌سازی "
"شوند، به شرح زیر:"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Default trait adds `default` constructor.\n"
msgstr "// Default trait adds `default` constructor.\n"

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Clone trait adds `clone` method.\n"
msgstr "// Clone trait adds `clone` method.\n"

#: src/methods-and-traits/deriving.md
msgid "\"EldurScrollz\""
msgstr "\"dog\""

#: src/methods-and-traits/deriving.md
#, fuzzy
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr "// Debug trait adds support for printing with `{:?}`.\n"

#: src/methods-and-traits/deriving.md
msgid "\"{:?} vs. {:?}\""
msgstr "\"{:?} vs. {:?}\""

#: src/methods-and-traits/deriving.md
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""
"انتساب (Derivation) با استفاده از ماکروها پیاده‌سازی می‌شود و بسیاری از "
"crateها ماکروهای مفیدی برای اضافه کردن قابلیت‌های کاربردی ارائه می‌دهند. به "
"عنوان مثال، `serde` می‌تواند پشتیبانی از ترتیب را برای یک ساختار با استفاده "
"از `[derive(Serialize)]#` فراهم کند."

#: src/methods-and-traits/exercise.md
msgid "Exercise: Logger Trait"
msgstr "تمرین: Trait Logger"

#: src/methods-and-traits/exercise.md
msgid ""
"Let's design a simple logging utility, using a trait `Logger` with a `log` "
"method. Code which might log its progress can then take an `&impl Logger`. "
"In testing, this might put messages in the test logfile, while in a "
"production build it would send messages to a log server."
msgstr ""
"بیایید یک ابزار لاگ‌ ساده طراحی کنیم که از یک trait به نام `Logger` با متد "
"`log` استفاده کند. کدی که ممکن است پیشرفت خود را لاگ کند می‌تواند یک `impl "
"Logger&` دریافت کند. در زمان تست، این ممکن است پیام‌ها را در فایل‌ لاگ تست "
"قرار دهد، در حالی که در نسخه تولید، پیام‌ها به یک سرور لاگ ارسال می‌شود."

#: src/methods-and-traits/exercise.md
msgid ""
"However, the `StderrLogger` given below logs all messages, regardless of "
"verbosity. Your task is to write a `VerbosityFilter` type that will ignore "
"messages above a maximum verbosity."
msgstr ""
"با این حال، `StderrLogger` که در زیر داده شده است، تمامی پیام‌ها را بدون توجه "
"به سطح جزئیات لاگ می‌کند. وظیفه شما این است که نوع `VerbosityFilter` را "
"بنویسید که پیام‌هایی با سطح جزئیات بالاتر از حداکثر سطح تعیین‌شده را نادیده "
"بگیرد."

#: src/methods-and-traits/exercise.md
msgid ""
"This is a common pattern: a struct wrapping a trait implementation and "
"implementing that same trait, adding behavior in the process. What other "
"kinds of wrappers might be useful in a logging utility?"
msgstr ""
"این الگو الگوی رایجی است: یک ساختارکه یک پیاده‌سازی trait را در بر می‌گیرد و "
"همان trait را پیاده‌سازی می‌کند و در این فرآیند به آن رفتار اضافی می‌دهد. چه "
"نوع‌های دیگری از پوشش‌دهنده‌ها ممکن است در یک ابزار لاگ مفید باشند؟"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "/// Log a message at the given verbosity level.\n"
msgstr "/// Log a message at the given verbosity level.\n"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"verbosity={verbosity}: {message}\""
msgstr "\"اطلاعات بیشتر={verbosity}: {message}\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"FYI\""
msgstr "\"FYI\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"Uhoh\""
msgstr "\"اوهو\""

#: src/methods-and-traits/exercise.md
#, fuzzy
msgid "// TODO: Define and implement `VerbosityFilter`.\n"
msgstr "// TODO: Define and implement `VerbosityFilter`.\n"

#: src/methods-and-traits/solution.md
#, fuzzy
msgid "/// Only log messages up to the given verbosity level.\n"
msgstr "/// Only log messages up to the given verbosity level.\n"

#: src/welcome-day-2-afternoon.md
msgid ""
"Including 10 minute breaks, this session should take about 3 hours and 15 "
"minutes. It contains:"
msgstr ""
"با احتساب ۱۰ دقیقه استراحت، این جلسه باید حدود ۳ ساعت و ۱۵ دقیقه طول بکشد. "
"آن شامل:"

#: src/generics.md src/iterators.md src/testing.md
msgid "This segment should take about 45 minutes. It contains:"
msgstr "این بخش باید حدود ۴۵ دقیقه طول بکشد. آن شامل:"

#: src/generics.md
msgid "impl Trait"
msgstr "impl Trait"

#: src/generics.md
msgid "dyn Trait"
msgstr "dyn Trait"

#: src/generics.md
msgid "Exercise: Generic min"
msgstr "تمرین: Generic `min`"

#: src/generics/generic-functions.md
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rust از generics پشتیبانی می‌کند که به شما امکان می‌دهد الگوریتم‌ها یا "
"ساختارهای داده (مانند مرتب‌سازی یا درخت دودویی) را بر روی تایپ‌های استفاده‌شده "
"یا ذخیره‌شده تخصیص دهید."

#: src/generics/generic-functions.md
#, fuzzy
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr "/// Pick `even` or `odd` depending on the value of `n`.\n"

#: src/generics/generic-functions.md
msgid "\"picked a number: {:?}\""
msgstr "\"شماره ای را انتخاب کرد: {:?}\""

#: src/generics/generic-functions.md
msgid "\"picked a tuple: {:?}\""
msgstr "\"یک تاپل انتخاب کرد: {:?}\""

#: src/generics/generic-functions.md
msgid "\"dog\""
msgstr "\"سگ\""

#: src/generics/generic-functions.md
msgid "\"cat\""
msgstr "\"گربه\""

#: src/generics/generic-functions.md
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr "Rust تایپ T را بر اساس تایپ آرگومان‌ها و مقدار بازگشتی استنباط می‌کند."

#: src/generics/generic-functions.md
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""
"این شبیه به الگوهای در ++C است، اما Rust تابع generic را بلافاصله به صورت "
"جزئی کامپایل می‌کند، بنابراین آن تابع باید برای تمام تایپ‌هایی که با محدودیت‌ها "
"مطابقت دارند معتبر باشد. به عنوان مثال، سعی کنید تابع `pick` را طوری تغییر "
"دهید که اگر `n == 0` باشد، مقدار `even + odd` را برگرداند. حتی اگر فقط "
"نمونه‌سازی تابع `pick` با اعداد صحیح استفاده شود، Rust همچنان آن را نامعتبر "
"در نظر می‌گیرد. اما ++C اجازه این کار را به شما می‌دهد."

#: src/generics/generic-functions.md
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"کد generic بر اساس محل‌های فراخوانی به کد non-generic تبدیل می‌شود. این یک "
"انتزاع بدون هزینه است: شما دقیقاً همان نتیجه‌ای را دریافت می‌کنید که گویی "
"ساختارهای داده را بدون انتزاع به صورت دستی کدنویسی کرده‌اید."

#: src/generics/generic-data.md
msgid "You can use generics to abstract over the concrete field type:"
msgstr "می‌توانید از generic‌ ها برای انتزاع نوع فیلد مشخص استفاده کنید:"

#: src/generics/generic-data.md
msgid "\"{integer:?} and {float:?}\""
msgstr "\"{integer:?} و {float:?}\""

#: src/generics/generic-data.md
msgid "\"coords: {:?}\""
msgstr "\"coords: {:?}\""

#: src/generics/generic-data.md
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"_سوال:_ چرا `T` در عبارت `{}<impl<T> Point<T` دوبار مشخص شده است؟ آیا این "
"تکراری نیست؟"

#: src/generics/generic-data.md
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"این به این دلیل است که این یک بخش پیاده‌سازی generic برای تایپ generic است. "
"آن‌ها به‌طور مستقل generic هستند."

#: src/generics/generic-data.md
msgid "It means these methods are defined for any `T`."
msgstr "این به این معناست که این متدها برای هر نوع `T` تعریف شده‌اند."

#: src/generics/generic-data.md
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "این امکان وجود دارد که `{ .. }<impl Point<u32` را بنویسید."

#: src/generics/generic-data.md
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` هنوز هم generic است و می‌توانید از `<Point<f64` استفاده کنید، اما "
"متدهای موجود در این بلوک تنها برای `<Point<u32` در دسترس خواهند بود."

#: src/generics/generic-data.md
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""
"سعی کنید یک متغیر جدید با `let p = Point { x: 5, y: 10.0 };` بسازید. کد را "
"به‌روزرسانی کنید تا نقاطی که دارای عناصر با تایپ‌های مختلف هستند را مجاز کند، "
"با استفاده از دو تایپ متغیر، مانند `T` و `U`."

#: src/generics/generic-traits.md
msgid ""
"Traits can also be generic, just like types and functions. A trait's "
"parameters get concrete types when it is used."
msgstr ""
"Traits نیز می‌توانند generic باشند، درست مانند تایپ و توابع. پارامترهای یک "
"trait زمانی که استفاده می‌شود، تایپ‌های مشخصی پیدا می‌کنند."

#: src/generics/generic-traits.md
msgid "\"Converted from integer: {from}\""
msgstr "\"تبدیل شده از integer: {from}\""

#: src/generics/generic-traits.md
msgid "\"Converted from bool: {from}\""
msgstr "\"تبدیل‌شده از bool: {from}\""

#: src/generics/generic-traits.md
msgid "\"{from_int:?}, {from_bool:?}\""
msgstr "\"{from_int:?}, {from_bool:?}\""

#: src/generics/generic-traits.md
msgid ""
"The `From` trait will be covered later in the course, but its [definition in "
"the `std` docs](https://doc.rust-lang.org/std/convert/trait.From.html) is "
"simple."
msgstr ""
"`From` trait در ادامه دوره پوشش داده خواهد شد، اما [تعریف آن در مستندات "
"`std`](https://doc.rust-lang.org/std/convert/trait.From.html) ساده است."

#: src/generics/generic-traits.md
msgid ""
"Implementations of the trait do not need to cover all possible type "
"parameters. Here, `Foo::from(\"hello\")` would not compile because there is "
"no `From<&str>` implementation for `Foo`."
msgstr ""
"پیاده‌سازی‌های trait نیازی به پوشش تمام پارامترهای تایپ ممکن ندارند. در اینجا، "
"`Foo::from(\"hello\")` کامپایل نخواهد شد زیرا پیاده‌سازی `<From<&str` برای "
"`Foo` وجود ندارد."

#: src/generics/generic-traits.md
msgid ""
"Generic traits take types as \"input\", while associated types are a kind of "
"\"output\" type. A trait can have multiple implementations for different "
"input types."
msgstr ""
"traitهای Generic تایپ‌ها را به‌عنوان \"ورودی\" می‌پذیرند، در حالی که تایپ مرتبط "
"تایپ از \"خروجی\" هستند. یک trait می‌تواند پیاده‌سازی‌های مختلفی برای تایپ‌های "
"ورودی متفاوت داشته باشد."

#: src/generics/generic-traits.md
msgid ""
"In fact, Rust requires that at most one implementation of a trait match for "
"any type T. Unlike some other languages, Rust has no heuristic for choosing "
"the \"most specific\" match. There is work on adding this support, called "
"[specialization](https://rust-lang.github.io/rfcs/1210-impl-specialization."
"html)."
msgstr ""
"در واقع، Rust نیاز دارد که حداکثر یک پیاده‌سازی از یک trait برای هر تایپ `T` "
"تطابق داشته باشد. بر خلاف برخی زبان‌های دیگر، Rust هیچ قاعده‌ای برای انتخاب "
"\"مشخص‌ترین\" تطابق را ندارد. در حال حاضر، کارهایی برای اضافه کردن این "
"پشتیبانی وجود دارد که به آن [ویژه‌سازی](https://rust-lang.github.io/rfcs/1210-"
"impl-specialization.html) می‌گویند."

#: src/generics/trait-bounds.md
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"هنگام کار با generic‌ها، معمولاً می‌خواهید نیاز داشته باشید که تایپ، trait ترید "
"خاص را پیاده‌سازی کنند، تا بتوانید متدهای آن trait را فراخوانی کنید."

#: src/generics/trait-bounds.md
#, fuzzy
msgid "You can do this with `T: Trait`:"
msgstr ""
"می‌توانید این کار را با استفاده از `T: Trait` یا `impl Trait` انجام دهید:"

#: src/generics/trait-bounds.md
#, fuzzy
msgid "// struct NotClonable;\n"
msgstr "// struct NotClonable;\n"

#: src/generics/trait-bounds.md
msgid "\"{pair:?}\""
msgstr "\"{pair:?}\""

#: src/generics/trait-bounds.md
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr "سعی کنید یک `NonClonable` بسازید و آن را به `duplicate` پاس دهید."

#: src/generics/trait-bounds.md
msgid "When multiple traits are necessary, use `+` to join them."
msgstr "زمانی که چندین ترید لازم است، از `+` برای ترکیب آن‌ها استفاده کنید."

#: src/generics/trait-bounds.md
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"یک عبارت `where` را نشان دهید، زیرا دانش‌آموزان هنگام خواندن کد با آن مواجه "
"خواهند شد."

#: src/generics/trait-bounds.md
msgid "It declutters the function signature if you have many parameters."
msgstr ""
"اگر تعداد پارامترها زیاد باشد، استفاده از عبارت `where` باعث می‌شود که امضای "
"تابع مرتب‌تر و خواناتر باشد."

#: src/generics/trait-bounds.md
msgid "It has additional features making it more powerful."
msgstr "این ویژگی‌های اضافی دارد که آن را قدرتمندتر می‌کند."

#: src/generics/trait-bounds.md
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"اگر کسی بپرسد، ویژگی اضافی این است که تایپ در سمت چپ `:` می‌تواند دلخواه "
"باشد، مانند `<Option<T`."

#: src/generics/trait-bounds.md
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""
"توجه داشته باشید که Rust (هنوز) پشتیبانی از ویژه‌سازی را ندارد. به عنوان "
"مثال، با توجه به `duplicate` اصلی، اضافه کردن یک پیاده‌سازی ویژه‌شده مانند "
"`duplicate(a: u32)` نامعتبر است."

#: src/generics/impl-trait.md
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"مشابه با محدودیت‌های trait، می‌توان از `impl Trait` syntax در آرگومان‌های تابع "
"و مقادیر بازگشتی استفاده کرد:"

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"

#: src/generics/impl-trait.md
msgid "\"{many}\""
msgstr "\"{many}\""

#: src/generics/impl-trait.md
msgid "\"{many_more}\""
msgstr "\"{many_more}\""

#: src/generics/impl-trait.md
msgid "\"debuggable: {debuggable:?}\""
msgstr "\"قابل دیباگ: {debuggable:?}\""

#: src/generics/impl-trait.md
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"`impl Trait` به شما اجازه می‌دهد با تایپ‌هایی کار کنید که نمی‌توانید نام ببرید. "
"معنی `impl Trait` در موقعیت‌های مختلف کمی متفاوت است."

#: src/generics/impl-trait.md
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"برای یک پارامتر، `impl Trait` شبیه به یک پارامتر generic ناشناخته با یک "
"محدودیت trait است."

#: src/generics/impl-trait.md
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"برای تایپ بازگشتی، به این معناست که تایپ بازگشتی تایپ مشخصی است که trait را "
"پیاده‌سازی می‌کند، بدون اینکه تایپ را نام ببرید. این می‌تواند زمانی مفید باشد "
"که نمی‌خواهید تایپ مشخص را در یک API عمومی افشا کنید."

#: src/generics/impl-trait.md
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"Inference در موقعیت بازگشتی دشوار است. تابعی که `impl Foo` را برمی‌گرداند، "
"تایپ مشخصی را که برمی‌گرداند انتخاب می‌کند، بدون اینکه آن را به طور صریح در "
"منبع بنویسد. تابعی که تایپ generic مانند `collect<B>() -> B` را برمی‌گرداند، "
"می‌تواند هر تایپ که `B` را برآورده می‌کند بازگرداند، و ممکن است فراخوانی‌کننده "
"نیاز به انتخاب یکی از آن‌ها داشته باشد، مانند `let x: Vec<_> = foo.collect()` "
"یا با استفاده از ()<turbofish، `foo.collect::<Vec<_>`."

#: src/generics/impl-trait.md
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""
"نوع `debuggable` چیست؟ سعی کنید .. = () :let debuggable` را امتحان کنید تا "
"ببینید پیام خطا چه چیزی را نشان می‌دهد."

#: src/generics/dyn-trait.md
msgid ""
"In addition to using traits for static dispatch via generics, Rust also "
"supports using them for type-erased, dynamic dispatch via trait objects:"
msgstr ""
"علاوه بر استفاده از تریدها برای فراخوانی استاتیک از طریق generic‌ها، Rust "
"همچنین از استفاده از آن‌ها برای فراخوانی داینامیک با تایپ‌های حذف‌شده از طریق "
"اشیاء trait پشتیبانی می‌کند:"

#: src/generics/dyn-trait.md src/smart-pointers/trait-objects.md
msgid "\"Miau!\""
msgstr "\"Miau!\""

#: src/generics/dyn-trait.md
#, fuzzy
msgid "// Uses generics and static dispatch.\n"
msgstr "// Use the system timer as a delay provider.\n"

#: src/generics/dyn-trait.md src/smart-pointers/trait-objects.md
msgid "\"Hello, who are you? {}\""
msgstr "\"سلام، شما کی هستید؟ {}\""

#: src/generics/dyn-trait.md
#, fuzzy
msgid "// Uses type-erasure and dynamic dispatch.\n"
msgstr "// Uses type-erasure and dynamic dispatch.\n"

#: src/generics/dyn-trait.md
msgid ""
"Generics, including `impl Trait`, use monomorphization to create a "
"specialized instance of the function for each different type that the "
"generic is instantiated with. This means that calling a trait method from "
"within a generic function still uses static dispatch, as the compiler has "
"full type information and can resolve which type's trait implementation to "
"use."
msgstr ""
"Generic‌ها، از جمله `impl Trait`، از monomorphization برای ایجاد یک نمونه "
"تخصصی از تابع برای هر تایپ مختلفی که با آن نمونه‌سازی شده استفاده می‌کنند. این "
"بدان معناست که فراخوانی یک متد trait از درون یک تابع generic همچنان از "
"فراخوانی استاتیک استفاده می‌کند، زیرا کامپایلر اطلاعات کامل تایپ را دارد و "
"می‌تواند پیاده‌سازی trait مربوط به تایپ را مشخص کند."

#: src/generics/dyn-trait.md
msgid ""
"When using `dyn Trait`, it instead uses dynamic dispatch through a [virtual "
"method table](https://en.wikipedia.org/wiki/Virtual_method_table) (vtable). "
"This means that there's a single version of `fn dynamic` that is used "
"regardless of what type of `Pet` is passed in."
msgstr ""
"زمانی که از `dyn Trait` استفاده می‌شود، به‌جای آن از فراخوانی داینامیک از طریق "
"یک [virtual method table](https://en.wikipedia.org/wiki/"
"Virtual_method_table) (vtable) استفاده می‌کند. این بدان معناست که یک نسخه "
"واحد از `fn dynamic` وجود دارد که بدون توجه به تایپ `Pet` که وارد می‌شود، "
"استفاده می‌شود."

#: src/generics/dyn-trait.md
msgid ""
"When using `dyn Trait`, the trait object needs to be behind some kind of "
"indirection. In this case it's a reference, though smart pointer types like "
"`Box` can also be used (this will be demonstrated on day 3)."
msgstr ""
"زمانی که از `dyn Trait` استفاده می‌شود، شی trait باید پشت یک تایپ واسط قرار "
"داشته باشد. در این مورد، این تایپ واسط یک ارجاع است، اگرچه تایپ‌های "
"اشاره‌گرهای هوشمند مانند `Box` نیز می‌توانند استفاده شوند (این موضوع در روز "
"سوم نشان داده خواهد شد)."

#: src/generics/dyn-trait.md
msgid ""
"At runtime, a `&dyn Pet` is represented as a \"fat pointer\", i.e. a pair of "
"two pointers: One pointer points to the concrete object that implements "
"`Pet`, and the other points to the vtable for the trait implementation for "
"that type. When calling the `talk` method on `&dyn Pet` the compiler looks "
"up the function pointer for `talk` in the vtable and then invokes the "
"function, passing the pointer to the `Dog` or `Cat` into that function. The "
"compiler doesn't need to know the concrete type of the `Pet` in order to do "
"this."
msgstr ""
"در زمان اجرا، یک `dyn Pet&` به‌صورت یک \"اشاره‌گر چاق\" (fat pointer) نمایان "
"می‌شود، یعنی یک جفت از دو اشاره‌گر: یکی از اشاره‌گرها به شیء مشخصی که `Pet` را "
"پیاده‌سازی می‌کند اشاره دارد و دیگری به vtable برای پیاده‌سازی ترید آن نوع "
"اشاره می‌کند. هنگام فراخوانی متد `talk` بر روی `dyn Pet&`، کامپایلر آدرس تابع "
"`talk` را در vtable جستجو کرده و سپس تابع را فراخوانی می‌کند و اشاره‌گر به "
"`Dog` یا `Cat` را به آن تابع پاس می‌دهد. کامپایلر نیازی به دانستن تایپ مشخص "
"`Pet` برای انجام این کار ندارد."

#: src/generics/dyn-trait.md
msgid ""
"A `dyn Trait` is considered to be \"type-erased\", because we no longer have "
"compile-time knowledge of what the concrete type is."
msgstr ""
"یک `dyn Trait` به‌عنوان \"تایپ ‌حذف‌ شده\" (type-erased) در نظر گرفته می‌شود، "
"زیرا دیگر در زمان کامپایل اطلاعاتی درباره تایپ مشخص نداریم."

#: src/generics/exercise.md
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using the [`Ord`](https://doc.rust-"
"lang.org/stable/std/cmp/trait.Ord.html) trait."
msgstr ""
"در این تمرین کوتاه، شما یک تابع `min`generic را پیاده‌سازی خواهید کرد که "
"حداقل از دو مقدار را تعیین می‌کند، با استفاده از trait [`Ord`](https://doc."
"rust-lang.org/stable/std/cmp/trait.Ord.html)."

#: src/generics/exercise.md
#, fuzzy
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr "// TODO: implement the `min` function used in `main`.\n"

#: src/generics/exercise.md src/generics/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'z'"
msgstr "'z'"

#: src/generics/exercise.md src/generics/solution.md
msgid "'7'"
msgstr "'7'"

#: src/generics/exercise.md src/generics/solution.md
msgid "'1'"
msgstr "'1'"

#: src/generics/exercise.md src/generics/solution.md
msgid "\"goodbye\""
msgstr "\"goodbye\""

#: src/generics/exercise.md src/generics/solution.md
msgid "\"bat\""
msgstr "\"bat\""

#: src/generics/exercise.md src/generics/solution.md
msgid "\"armadillo\""
msgstr "\"armadillo\""

#: src/generics/exercise.md
msgid ""
"Show students the [`Ord`](https://doc.rust-lang.org/stable/std/cmp/trait.Ord."
"html) trait and [`Ordering`](https://doc.rust-lang.org/stable/std/cmp/enum."
"Ordering.html) enum."
msgstr ""
"[`Ord`](https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html) trait و "
"[`Ordering`](https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html) "
"enum را به دانش‌آموزان نشان دهید."

#: src/std-types.md src/std-types/option.md
msgid "Option"
msgstr "Option"

#: src/std-types.md src/std-types/result.md src/error-handling.md
msgid "Result"
msgstr "نتیجه"

#: src/std-types.md src/std-types/string.md
msgid "String"
msgstr "String"

#: src/std-types.md
msgid "Vec"
msgstr "Vec"

#: src/std-types.md
msgid "HashMap"
msgstr "HashMap"

#: src/std-types.md
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""
"برای هر یک از اسلایدهای این بخش، کمی زمان صرف مرور صفحات مستندات کنید و برخی "
"از متدهای رایج‌تر را برجسته کنید."

#: src/std-types/std.md
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust دارای یک کتابخانه استاندارد است که به ایجاد مجموعه‌ای از تایپ‌های رایج "
"استفاده‌شده توسط کتابخانه‌ها و برنامه‌های Rust کمک می‌کند. به این ترتیب، دو "
"کتابخانه می‌توانند به‌راحتی با هم کار کنند زیرا هر دو از تایپ `String` یکسانی "
"استفاده می‌کنند."

#: src/std-types/std.md
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr ""
"در واقع، Rust شامل چندین لایه از کتابخانه استاندارد است: `core`، `alloc` و "
"`std`."

#: src/std-types/std.md
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core` شامل ابتدایی‌ترین تایپ‌ها و توابع است که به `libc`، تخصیص‌دهنده حافظه یا "
"حتی وجود یک سیستم‌عامل وابسته نیستند."

#: src/std-types/std.md
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` شامل تایپ‌هایی است که به یک تخصیص‌دهنده حافظه سراسری نیاز دارند، مانند "
"`Vec`، `Box` و `Arc`."

#: src/std-types/std.md
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"برنامه‌های Rust تعبیه‌شده اغلب تنها از `core` و گاهی اوقات از `alloc` استفاده "
"می‌کنند."

#: src/std-types/docs.md
msgid "Rust comes with extensive documentation. For example:"
msgstr "Rust دارای مستندات گسترده‌ای است. به عنوان مثال:"

#: src/std-types/docs.md
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"تمام جزئیات مربوط به [حلقه‌ها](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."

#: src/std-types/docs.md
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""
"تایپ‌های ابتدایی مانند [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."

#: src/std-types/docs.md
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"تایپ‌های کتابخانه استاندارد مانند [`Option`](https://doc.rust-lang.org/stable/"
"std/option/enum.Option.html) یا [`BinaryHeap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.BinaryHeap.html)."

#: src/std-types/docs.md
msgid "In fact, you can document your own code:"
msgstr "در واقع، شما می‌توانید کد خود را مستند کنید:"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"

#: src/std-types/docs.md
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"محتویات به‌عنوان Markdown پردازش می‌شوند. تمام crate‌های کتابخانه‌ای منتشرشده "
"Rust به‌طور خودکار در [`docs.rs`](https://docs.rs) با استفاده از ابزار "
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) مستند "
"می‌شوند. مستند کردن تمام آیتم‌های عمومی در یک API با استفاده از این الگو به‌طور "
"رایج مرسوم است."

#: src/std-types/docs.md
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""
"برای مستند کردن یک آیتم از درون خود آیتم (مانند درون یک ماژول)، از `!//` یا "
"`/* .. !*/` استفاده کنید که به آن \"کامنت‌های مستندات داخلی\" می‌گویند:"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"

#: src/std-types/docs.md
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"مستندات تولیدشده برای `rand` crate را در <https://docs.rs/rand> به "
"دانش‌آموزان نشان دهید."

#: src/std-types/option.md
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""
"ما قبلاً برخی استفاده‌ها از `<Option<T` را مشاهده کرده‌ایم. این تایپ یا مقداری "
"از تایپ`T` را ذخیره می‌کند یا هیچ چیزی را ذخیره نمی‌کند. به عنوان مثال، "
"[`String::find`](https://doc.rust-lang.org/stable/std/string/struct.String."
"html#method.find) یک `<Option<usize` را برمی‌گرداند."

#: src/std-types/option.md
msgid "\"Löwe 老虎 Léopard Gepardi\""
msgstr "\"Löwe 老虎 Léopard Gepardi\""

#: src/std-types/option.md
msgid "'é'"
msgstr "'é'"

#: src/std-types/option.md
msgid "\"find returned {position:?}\""
msgstr "\"پیدا کردن نوع بازگشتی{position:?}\""

#: src/std-types/option.md
msgid "'Z'"
msgstr "'Z'"

#: src/std-types/option.md
msgid "\"Character not found\""
msgstr "\"Character not found\""

#: src/std-types/option.md
msgid "`Option` is widely used, not just in the standard library."
msgstr ""
"`Option` به‌طور گسترده‌ای استفاده می‌شود و تنها در کتابخانه استاندارد محدود "
"نمی‌شود."

#: src/std-types/option.md
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""
"`unwrap` مقدار موجود در یک `Option` را برمی‌گرداند یا باعث panic می‌شود. "
"`expect` مشابه است اما پیامی برای خطا می‌پذیرد."

#: src/std-types/option.md
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr ""
"می‌توانید در مواجهه با panic  `None` کنید، اما نمی‌توانید به‌طور \"تصادفی\" "
"فراموش کنید که `None` بررسی کنید."

#: src/std-types/option.md
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""
"استفاده از `unwrap`/`expect` در همه‌جا هنگام ساخت سریع چیزی رایج است، اما کد "
"تولیدی معمولاً `None` را به‌شیوه‌ای مناسب‌تر مدیریت می‌کند."

#: src/std-types/option.md
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr ""
"بهینه‌سازی niche به این معناست که `<Option<T` اغلب اندازه‌ای مشابه با `T` در "
"حافظه دارد."

#: src/std-types/result.md
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different enum variant. It is generic: `Result<T, E>` "
"where `T` is used in the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""
"`Result` مشابه `Option` است، اما موفقیت یا شکست یک عملیات را نشان می‌دهد، "
"هرکدام با یک نوع متغیر enum متفاوت. این نوع جنریک است: `<Result<T, E` که در "
"آن `T` در متغیر `Ok` استفاده می‌شود و `E` در متغیر `Err` ظاهر می‌شود."

#: src/std-types/result.md src/error-handling/result.md
msgid "\"diary.txt\""
msgstr "\"diary.txt\""

#: src/std-types/result.md src/error-handling/result.md
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr "\"دفتر خاطرات عزیز: {contents} ({bytes} bytes)\""

#: src/std-types/result.md src/error-handling/result.md
msgid "\"Could not read file content\""
msgstr "\"نمی‌توان محتوای فایل را خواند\""

#: src/std-types/result.md src/error-handling/result.md
msgid "\"The diary could not be opened: {err}\""
msgstr "\"دفتر خاطرات باز نشد: {err}\""

#: src/std-types/result.md
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"همانند `Option`، مقدار موفقیت‌آمیز درون `Result` قرار دارد و توسعه‌دهنده را "
"ملزم به استخراج صریح آن می‌کند. این به بررسی خطاها تشویق می‌کند. در صورتی که "
"خطا هرگز نباید رخ دهد، می‌توان از `()unwrap` یا `()expect` استفاده کرد که این "
"نیز نشان‌دهنده نیت توسعه‌دهنده است."

#: src/std-types/result.md
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"مستندات `Result` مطالعه‌ای توصیه‌شده است. نه در طول دوره، اما ذکر آن ارزشمند "
"است. این مستندات شامل بسیاری از متدها و توابع کاربردی است که به برنامه‌نویسی "
"به استایل تابع‌محور کمک می‌کند."

#: src/std-types/result.md
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 4."
msgstr ""
"`Result` نوع استاندارد برای پیاده‌سازی مدیریت خطاها است که در روز چهارم دوره "
"خواهیم دید."

#: src/std-types/string.md
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is a "
"growable UTF-8 encoded string:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) یک رشته "
"قابل رشد با کدگذاری UTF-8 است:"

#: src/std-types/string.md src/std-traits/read-and-write.md
#: src/memory-management/review.md src/testing/unit-tests.md
#: src/concurrency/threads/scoped.md
msgid "\"Hello\""
msgstr "\"سلام\""

#: src/std-types/string.md
msgid "\"s1: len = {}, capacity = {}\""
msgstr "\"s1: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "'!'"
msgstr "'!'"

#: src/std-types/string.md
msgid "\"s2: len = {}, capacity = {}\""
msgstr "\"s2: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "\"🇨🇭\""
msgstr "\"🇨🇭\""

#: src/std-types/string.md
msgid "\"s3: len = {}, number of chars = {}\""
msgstr "\"s3: len = {}, number of chars = {}\""

#: src/std-types/string.md
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` پیاده‌سازی‌کننده [`Deref<Target = str>`](https://doc.rust-lang.org/"
"std/string/struct.String.html#deref-methods-str) است، که به این معناست که "
"می‌توانید تمام متدهای `str` را بر روی `String` فراخوانی کنید."

#: src/std-types/string.md
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new` یک رشته جدید خالی برمی‌گرداند. از `String::with_capacity` "
"استفاده کنید زمانی که می‌دانید چقدر داده می‌خواهید به رشته اضافه کنید."

#: src/std-types/string.md
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len` اندازه رشته `String` را به‌صورت بایت برمی‌گرداند (که ممکن است با "
"طول آن به‌صورت کاراکتر متفاوت باشد)."

#: src/std-types/string.md
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars` یک تکرارگر (iterator) از روی کاراکترهای واقعی برمی‌گرداند. "
"توجه داشته باشید که یک `char` ممکن است با آنچه که یک انسان به عنوان "
"\"کاراکتر\" در نظر می‌گیرد، متفاوت باشد به دلیل [grapheme clusters](https://"
"docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes."
"html)."

#: src/std-types/string.md
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""
"زمانی که مردم به رشته‌ها اشاره می‌کنند، ممکن است منظورشان `str&` یا `String` "
"باشد."

#: src/std-types/string.md
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"زمانی که یک تایپ، `<Deref<Target = T` را پیاده‌سازی می‌کند، کامپایلر به شما "
"این امکان را می‌دهد که به‌طور شفاف متدهای `T` را فراخوانی کنید."

#: src/std-types/string.md
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr ""
"ما هنوز `Deref` trait را بررسی نکرده‌ایم، بنابراین در این مرحله این بیشتر "
"توضیح‌دهنده ساختار نوار کناری در مستندات است."

#: src/std-types/string.md
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String` پیاده‌سازی‌کننده `<Deref<Target = str` است که به‌طور شفاف دسترسی به "
"متدهای `str` را فراهم می‌کند."

#: src/std-types/string.md
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "`;()let s3 = s1.deref` و `;let s3 = &*s1` بنویسید و مقایسه کنید ."

#: src/std-types/string.md
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr "بنویسید و مقایسه کنید `let s3 = s1.deref();` و `let s3 = &*s1;`."

#: src/std-types/string.md
msgid "Compare the different ways to index a `String`:"
msgstr "راه‌های مختلف برای ایندکس‌گذاری یک `String` را مقایسه کنید:"

#: src/std-types/string.md
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"به یک کاراکتر با استفاده از `()s3.chars().nth(i).unwrap`، جایی که `i` در "
"محدوده است یا خارج از محدوده."

#: src/std-types/string.md
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"به یک زیررشته با استفاده از `[4..0]s3`، جایی که این برش در مرزهای کاراکترها "
"است یا نباشد."

#: src/std-types/string.md
msgid ""
"Many types can be converted to a string with the [`to_string`](https://doc."
"rust-lang.org/std/string/trait.ToString.html#tymethod.to_string) method. "
"This trait is automatically implemented for all types that implement "
"`Display`, so anything that can be formatted can also be converted to a "
"string."
msgstr ""
"بسیاری از تایپ داده‌ها می‌توانند با استفاده از متد [`to_string`](https://doc."
"rust-lang.org/std/string/trait.ToString.html#tymethod.to_string) به رشته "
"تبدیل شوند. این ترید به‌طور خودکار برای تمام تایپ‌هایی که `Display` را "
"پیاده‌سازی می‌کنند، پیاده‌سازی شده است، بنابراین هر چیزی که می‌تواند قالب‌بندی "
"شود، همچنین می‌تواند به رشته تبدیل شود."

#: src/std-types/vec.md
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"این [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) بافر قابل "
"تغییر اندازه و heap-allocated است:"

#: src/std-types/vec.md
msgid "\"v1: len = {}, capacity = {}\""
msgstr "\"v1: len = {}, capacity = {}\""

#: src/std-types/vec.md
msgid "\"v2: len = {}, capacity = {}\""
msgstr "\"v2: len = {}, capacity = {}\""

#: src/std-types/vec.md
#, fuzzy
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr "// Canonical macro to initialize a vector with elements.\n"

#: src/std-types/vec.md
#, fuzzy
msgid "// Retain only the even elements.\n"
msgstr "// Retain only the even elements.\n"

#: src/std-types/vec.md
msgid "\"{v3:?}\""
msgstr "\"{v3:?}\""

#: src/std-types/vec.md
#, fuzzy
msgid "// Remove consecutive duplicates.\n"
msgstr "// Remove consecutive duplicates.\n"

#: src/std-types/vec.md
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` پیاده‌سازی‌کننده [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/"
"vec/struct.Vec.html#deref-methods-%5BT%5D) است، به این معنی که می‌توانید "
"متدهای برش را بر روی یک `Vec` فراخوانی کنید."

#: src/std-types/vec.md
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec` نوعی مجموعه است، به همراه `String` و `HashMap`. داده‌های آن در حافظه "
"heap ذخیره می‌شود. به این معنی که مقدار داده‌ها نیازی به دانستن در زمان "
"کامپایل ندارد و می‌تواند در زمان اجرا رشد یا کوچک شود."

#: src/std-types/vec.md
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"توجه داشته باشید که `<Vec<T` نیز یک تایپ generic است، اما نیازی به تعیین "
"صریح `T` ندارید. همان‌طور که همیشه با استنتاج تایپ در Rust ، `T` در زمان "
"اولین فراخوانی `push` مشخص شده است."

#: src/std-types/vec.md
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`[...]!vec` یک ماکرو استاندارد برای استفاده به‌جای `()Vec::new` است و از "
"افزودن عناصر اولیه به vector پشتیبانی می‌کند."

#: src/std-types/vec.md
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"برای ایندکس‌گذاری vector از `[` `]` استفاده می‌کنید، اما اگر از محدوده خارج "
"شود، باعث panic می‌شود. به‌طور جایگزین، استفاده از `get` یک `Option` را "
"برمی‌گرداند. تابع `pop` آخرین عنصر را حذف می‌کند."

#: src/std-types/vec.md
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""
"برش‌ها در روز سوم پوشش داده می‌شوند. در حال حاضر، دانش‌آموزان تنها باید بدانند "
"که یک مقدار از تایپ `Vec` به تمام متدهای مستند شده برش‌ها نیز دسترسی دارد."

#: src/std-types/hashmap.md
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "نقشه hash استاندارد با حفاظت در برابر حملات HashDoS:"

#: src/std-types/hashmap.md
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"ماجراهای هاکلبری فین\""

#: src/std-types/hashmap.md
msgid "\"Grimms' Fairy Tales\""
msgstr "\"قصه‌های گریمز\""

#: src/std-types/hashmap.md
msgid "\"Pride and Prejudice\""
msgstr "\"غرور و تعصب\""

#: src/std-types/hashmap.md
msgid "\"Les Misérables\""
msgstr "\"Les Misérables\""

#: src/std-types/hashmap.md
msgid "\"We know about {} books, but not Les Misérables.\""
msgstr "\"ما درباره {} کتاب می دانیم، اما Les Misérables نه.\""

#: src/std-types/hashmap.md
msgid "\"Alice's Adventure in Wonderland\""
msgstr "\"ماجراجویی آلیس در سرزمین عجایب\""

#: src/std-types/hashmap.md
msgid "\"{book}: {count} pages\""
msgstr "\"{book}: {count} صفحه‌ها\""

#: src/std-types/hashmap.md
msgid "\"{book} is unknown.\""
msgstr "\"{book} ناشناخته است.\""

#: src/std-types/hashmap.md
#, fuzzy
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr "// Use the .entry() method to insert a value if nothing is found.\n"

#: src/std-types/hashmap.md
msgid "\"{page_counts:#?}\""
msgstr "\"{page_counts:#?}\""

#: src/std-types/hashmap.md
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr "`HashMap` در prelude تعریف نشده و باید به scope وارد شود."

#: src/std-types/hashmap.md
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"سطرهای کد زیر را امتحان کنید. سطر اول بررسی می‌کند که آیا یک کتاب در "
"`HashMap` وجود دارد یا خیر و اگر وجود نداشت، یک مقدار جایگزین برمی‌گرداند. "
"سطر دوم مقدار جایگزین را در `HashMap` وارد می‌کند اگر کتاب پیدا نشد."

#: src/std-types/hashmap.md
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr "\"هری پاتر و سنگ جادو\""

#: src/std-types/hashmap.md
msgid "\"The Hunger Games\""
msgstr "\"The Hunger Games\""

#: src/std-types/hashmap.md
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr "برخلاف `!vec`، متأسفانه ماکروی استاندارد `!hashmap` وجود ندارد."

#: src/std-types/hashmap.md
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"از نسخه 1.56 Rust به بعد، `HashMap` پیاده‌سازی‌کننده [`From<[(K, V); N]>`]"
"(https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E) است که به ما "
"اجازه می‌دهد به‌راحتی یک `HashMap` را از یک آرایه مقداردهی اولیه کنیم:"

#: src/std-types/hashmap.md
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"به‌طور جایگزین، `HashMap` می‌تواند از هر `Iterator` که جفت‌های key-value را "
"تولید می‌کند، ساخته شود."

#: src/std-types/hashmap.md
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"ما `<HashMap<String, i32` را نمایش می‌دهیم و از استفاده از `str&` به‌عنوان "
"کلید اجتناب می‌کنیم تا مثال‌ها ساده‌تر شوند. استفاده از ارجاعات در مجموعه‌ها "
"البته ممکن است، اما می‌تواند به مشکلاتی با borrow checker منجر شود."

#: src/std-types/hashmap.md
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"حذف `()to_string` از مثال بالا را امتحان کنید و ببینید آیا هنوز کامپایل "
"می‌شود یا خیر. فکر می‌کنید ممکن است با چه مشکلاتی مواجه شویم؟"

#: src/std-types/hashmap.md
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"این چندین تایپ \"تایپ بازگشتی خاص متد\" دارد، مانند `std::collections::"
"hash_map::Keys`. این تایپ‌ها معمولاً در جستجوهای مستندات Rust ظاهر می‌شوند. "
"مستندات این تایپ را به دانش‌آموزان نشان دهید و پیوند مفید بازگشتی به متد "
"`keys` را نیز نمایش دهید."

#: src/std-types/exercise.md
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""
"در این تمرین، شما یک ساختار داده بسیار ساده را به‌صورت generic خواهید کرد. "
"این ساختار از [`std::collections::HashMap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.HashMap.html) برای پیگیری اینکه چه مقادیری مشاهده "
"شده‌اند و هرکدام چند بار ظاهر شده‌اند، استفاده می‌کند."

#: src/std-types/exercise.md
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""
"نسخه اولیه `Counter` به‌طور سخت‌افزاری برای مقادیر `u32` کدگذاری شده است. "
"ساختار و متدهای آن را به‌صورت generic بر اساس تایپ مقداری که در حال پیگیری "
"است، تغییر دهید، به‌طوری که `Counter` بتواند هر تایپ مقداری را پیگیری کند."

#: src/std-types/exercise.md
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""
"اگر زود تمام کردید، سعی کنید از متد [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) استفاده کنید تا "
"تعداد جستجوهای هش مورد نیاز برای پیاده‌سازی متد `count` را به نصف کاهش دهید."

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr ""
"/// Counter counts the number of times each value of type T has been seen.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Create a new Counter.\n"
msgstr "/// Create a new Counter.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Count an occurrence of the given value.\n"
msgstr "/// Count an occurrence of the given value.\n"

#: src/std-types/exercise.md src/std-types/solution.md
#, fuzzy
msgid "/// Return the number of times the given value has been seen.\n"
msgstr "/// Return the number of times the given value has been seen.\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"saw {} values equal to {}\""
msgstr "\"مقادیر {} برابر با {} را دیده‌شده\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"apple\""
msgstr "\"سیب\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"orange\""
msgstr "\"orange\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"got {} apples\""
msgstr "\"داشتم {} سیب‌ها\""

#: src/std-traits.md src/concurrency/sync-exercises.md
#: src/concurrency/async-exercises.md
msgid "This segment should take about 1 hour and 10 minutes. It contains:"
msgstr ""
"این بخش باید حدود ۱ ساعت و ۱۰ دقیقه طول بکشد. این بخش شامل موارد زیر است:"

#: src/std-traits.md
msgid "From and Into"
msgstr "From and Into"

#: src/std-traits.md
msgid "Read and Write"
msgstr "Read and Write"

#: src/std-traits.md
msgid "Default, struct update syntax"
msgstr "به طور پیش‌فرض، ساختار به‌روزرسانی syntax"

#: src/std-traits.md
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr ""
"همانند تایپ‌ها موجود در کتابخانه استاندارد، زمانی را صرف مرور مستندات هرtrait "
"کنید."

#: src/std-traits.md
msgid "This section is long. Take a break midway through."
msgstr "این بخش طولانی است. در میانه‌ی آن یک استراحت کنید."

#: src/std-traits/comparisons.md
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""
"این trait‌ها از مقایسه بین مقادیر پشتیبانی می‌کنند. همه‌ی این trait‌ها را می‌توان "
"برای تایپ‌هایی که شامل فیلدهایی هستند که این trait‌ها را پیاده‌سازی می‌کنند، "
"به‌دست آورد."

#: src/std-traits/comparisons.md
msgid "`PartialEq` and `Eq`"
msgstr "`PartialEq` and `Eq`"

#: src/std-traits/comparisons.md
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""
"`PartialEq` یک رابطه هم‌ارزی جزئی است که دارای متد الزامی `eq` و متد ارائه‌شده "
"`ne` می‌باشد. عملگرهای `==` و `=!` این متدها را فراخوانی می‌کنند."

#: src/std-traits/comparisons.md
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""
"`Eq` یک رابطه هم‌ارزی کامل است (بازتابی، متقارن، و transitive) و شامل "
"`PartialEq` می‌شود. توابعی که به هم‌ارزی کامل نیاز دارند، از `Eq` به‌عنوان یک "
"trait bound استفاده می‌کنند."

#: src/std-traits/comparisons.md
msgid "`PartialOrd` and `Ord`"
msgstr "`PartialOrd` and `Ord`"

#: src/std-traits/comparisons.md
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""
"`PartialOrd` یک ترتیب جزئی را تعریف می‌کند و دارای متد `partial_cmp` است. این "
"ویژگی برای پیاده‌سازی عملگرهای `<`، `<=`، `>=` و `>` استفاده می‌شود."

#: src/std-traits/comparisons.md
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr ""
"`Ord` یک ترتیب کامل است که در آن متد `cmp` مقدار `Ordering` را برمی‌گرداند."

#: src/std-traits/comparisons.md
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr ""
"`PartialEq` می‌تواند بین تایپ‌های مختلف پیاده‌سازی شود، اما `Eq` نمی‌تواند، زیرا "
"بازتابی است:"

#: src/std-traits/comparisons.md
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr ""
"در عمل، معمولاً این trait‌ها به‌طور خودکار به‌دست می‌آیند، اما کمتر پیش می‌آید که "
"آن‌ها به‌طور دستی پیاده‌سازی شوند."

#: src/std-traits/operators.md
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"بارگذاری مجدد عملگرها از طریق traits در [`std::ops`](https://doc.rust-lang."
"org/std/ops/index.html) پیاده‌سازی شده است:"

#: src/std-traits/operators.md
msgid "\"{:?} + {:?} = {:?}\""
msgstr "\"{:?} + {:?} = {:?}\""

#: src/std-traits/operators.md src/memory-management/drop.md
msgid "Discussion points:"
msgstr "نکات بحث:"

#: src/std-traits/operators.md
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr ""
"می‌توانید `Add` را برای `Point&` پیاده‌سازی کنید. در چه موقعیت‌هایی این کار "
"مفید است؟"

#: src/std-traits/operators.md
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"پاسخ: `Add:add` خود `self` را مصرف می‌کند. اگر تایپ `T` که برای آن عملگر را "
"بارگذاری می‌کنید، `Copy` نباشد، باید پیاده‌سازی عملگر را برای `T&` نیز در نظر "
"بگیرید. این کار از ایجاد کپی‌های غیرضروری در محل فراخوانی جلوگیری می‌کند."

#: src/std-traits/operators.md
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"چرا `Output` یک تایپ مرتبط است؟ آیا می‌توان آن را به‌عنوان یک پارامترتایپ برای "
"متد تعریف کرد؟"

#: src/std-traits/operators.md
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"پاسخ کوتاه: پارامترهای تایپ تابع توسط فراخوانی‌کننده کنترل می‌شوند، اما "
"تایپ‌های مرتبط (مانند `Output`) توسط پیاده‌ساز trait کنترل می‌شوند."

#: src/std-traits/operators.md
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"شما می‌توانید `Add` را برای دو تایپ مختلف پیاده‌سازی کنید، به‌عنوان مثال `impl "
"Add<(i32, i32)> for Point` می‌تواند یک tuple را به یک `Point` اضافه کند."

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"The `Not` trait (`!` operator) is notable because it does not \"boolify\" "
"like the same operator in C-family languages; instead, for integer types it "
"negates each bit of the number, which arithmetically is equivalent to "
"subtracting it from -1: `!5 == -6`."
msgstr ""
"عملگر `Not` یک ویژگی(`!` operator) قابل توجه است زیرا مانند همان عملگر در "
"زبان‌های خانواده C هرگز  \"boolify\"  نمی شود. در عوض، برای انواع عدد صحیح، "
"هر بیت از عدد را نفی می‌کند، که از نظر حسابی معادل کم کردن آن از -1: `!5 == "
"-6` است."

#: src/std-traits/from-and-into.md
#, fuzzy
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions. Unlike `as`, these traits correspond to "
"lossless, infallible conversions."
msgstr ""
"تایپ‌های مختلف ویژگی‌های [`From`](https://doc.rust-lang.org/std/convert/trait."
"From.html) و [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) "
"را برای تسهیل تبدیل تایپ پیاده‌سازی می‌کنند:"

#: src/std-traits/from-and-into.md
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr "\"{s}, {addr}, {one}, {bigger}\""

#: src/std-traits/from-and-into.md
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) به‌طور خودکار "
"زمانی پیاده‌سازی می‌شود که [`From`](https://doc.rust-lang.org/std/convert/"
"trait.From.html) پیاده‌سازی شده باشد:"

#: src/std-traits/from-and-into.md
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"به همین دلیل معمولاً تنها `From` پیاده‌سازی می‌شود، زیرا تایپ شما به‌طور خودکار "
"پیاده‌سازی `Into` را نیز دریافت می‌کند."

#: src/std-traits/from-and-into.md
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"هنگام اعلام تایپ ورودی تابعی مانند \"هر چیزی که می‌تواند به یک `String` تبدیل "
"شود\"، قاعده برعکس است، باید از `Into` استفاده کنید. تابع شما تایپ‌های را "
"قبول می‌کند که پیاده‌سازی `From` دارند و همچنین تاید‌هایی که فقط `Into` را "
"پیاده‌سازی کرده‌اند."

#: src/std-traits/casting.md
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""
"Rust هیچ _implicit_ ندارد، اما از تبدیل‌های صریح با استفاده از `as` پشتیبانی "
"می‌کند. این تبدیل‌ها معمولاً پیرو معنای C هستند که در آنجا تعریف شده‌اند."

#: src/std-traits/casting.md
msgid "\"as u16: {}\""
msgstr "\"as u16: {}\""

#: src/std-traits/casting.md
msgid "\"as i16: {}\""
msgstr "\"as i16: {}\""

#: src/std-traits/casting.md
msgid "\"as u8: {}\""
msgstr "\"as u8: {}\""

#: src/std-traits/casting.md
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""
"نتایج استفاده از `as` _همیشه_ در Rust تعریف شده و در تمامی پلتفرم‌ها ثابت "
"هستند. این ممکن است با شهود شما برای تغییر علامت یا تبدیل به تایپ کوچکتر "
"مطابقت نداشته باشد -- مستندات را بررسی کنید و برای وضوح بیشتر نظر دهید."

#: src/std-traits/casting.md
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""
"تبدیل تایپ با استفاده از `as` ابزاری نسبتاً حساس است که استفاده نادرست از آن "
"آسان است و می‌تواند منبعی از اشکالات ظریف باشد، به خصوص زمانی که کار نگهداری "
"آینده باعث تغییر تایپ‌های مورد استفاده یا دامنه مقادیر در تایپ‌ها شود. تبدیل‌ها "
"بهتر است تنها زمانی استفاده شوند که قصد شما نشان دادن برش بدون قید و شرط "
"باشد (مثلاً انتخاب 32 بیت پایین از یک `u64` با `as u32`، بدون توجه به آنچه در "
"بیت‌های بالا وجود دارد)."

#: src/std-traits/casting.md
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""
"برای تبدیل‌های بدون خطا (مانند تبدیل `u32` به `u64`)، استفاده از `From` یا "
"`Into` بر `as` ارجح است تا تأیید شود که تبدیل در واقع بدون خطا است. برای "
"تبدیل‌های با احتمال خطا، `TryFrom` و `TryInto` در دسترس هستند وقتی که "
"می‌خواهید تبدیل‌هایی را که به شیوه‌ای متفاوت از آن‌هایی که مطابقت ندارند، مدیریت "
"کنید."

#: src/std-traits/casting.md
msgid "Consider taking a break after this slide."
msgstr "در نظر داشته باشید که پس از این اسلاید استراحت کنید."

#: src/std-traits/casting.md
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""
"`as` مشابه به `static_cast` در ++C است. استفاده از `as` در مواردی که ممکن "
"است داده‌ها از دست برود، معمولاً توصیه نمی‌شود یا حداقل نیاز به توضیحی کامنتی "
"دارد."

#: src/std-traits/casting.md
msgid "This is common in casting integers to `usize` for use as an index."
msgstr ""
"این موضوع در تبدیل اعداد صحیح به `usize` برای استفاده به عنوان ایندکس رایج "
"است."

#: src/std-traits/read-and-write.md
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"با استفاده از [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) و "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html)، می‌توانید "
"بر روی منابع `u8` انتزاع کنید:"

#: src/std-traits/read-and-write.md
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr "b\"foo\\nbar\\nbaz\\n\""

#: src/std-traits/read-and-write.md
msgid "\"lines in slice: {}\""
msgstr "\"lines in slice: {}\""

#: src/std-traits/read-and-write.md
msgid "\"lines in file: {}\""
msgstr "\"lines in file: {}\""

#: src/std-traits/read-and-write.md
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"به طور مشابه، [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) "
"به شما امکان می‌دهد که بر روی منابع `u8` انتزاع کنید:"

#: src/std-traits/read-and-write.md
msgid "\"\\n\""
msgstr "\"\\n\""

#: src/std-traits/read-and-write.md
msgid "\"Logged: {:?}\""
msgstr "\"Logged: {:?}\""

#: src/std-traits/default.md
msgid "The `Default` Trait"
msgstr "The `Default` Trait"

#: src/std-traits/default.md
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"ویژگی [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
"یک مقدار پیش‌فرض برای یک تایپ تولید می‌کند."

#: src/std-traits/default.md
msgid "\"John Smith\""
msgstr "\"John Smith\""

#: src/std-traits/default.md
msgid "\"{default_struct:#?}\""
msgstr "\"{default_struct:#?}\""

#: src/std-traits/default.md
#, fuzzy
msgid "\"Y is set!\""
msgstr "\" مقدار Y  وارد شده است!\""

#: src/std-traits/default.md
msgid "\"{almost_default_struct:#?}\""
msgstr "\"{almost_default_struct:#?}\""

#: src/std-traits/default.md src/lifetimes/exercise.md
#: src/lifetimes/solution.md
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/std-traits/default.md
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"این ویژگی می‌تواند به طور مستقیم پیاده‌سازی شود یا می‌تواند از طریق "
"`[derive(Default)]#` به صورت خودکار تولید شود."

#: src/std-traits/default.md
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"یک پیاده‌سازی خودکار، مقداری تولید می‌کند که در آن تمامی فیلدها به مقادیر "
"پیش‌فرض خود تنظیم شده‌اند."

#: src/std-traits/default.md
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"این بدان معناست که تمام تایپ‌های موجود در ساختار نیز باید `Default` را "
"پیاده‌سازی کنند."

#: src/std-traits/default.md
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"نوع‌های استاندارد Rust اغلب `Default` را با مقادیر معقول پیاده‌سازی می‌کنند "
"(مثل `0`، `\"\"` و غیره)."

#: src/std-traits/default.md
msgid "The partial struct initialization works nicely with default."
msgstr "مقداردهی جزئی ساختارها با `Default` به خوبی کار می‌کند."

#: src/std-traits/default.md
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"کتابخانه استاندارد Rust آگاه است که تایپ‌های مختلف می‌توانند `Default` را "
"پیاده‌سازی کنند و روش‌های کمکی را فراهم می‌کند که از آن استفاده می‌کنند."

#: src/std-traits/default.md
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"سینتکس `..` به نام [سینتکس به‌روزرسانی ساختار](https://doc.rust-lang.org/book/"
"ch05-01-defining-structs.html#creating-instances-from-other-instances-with-"
"struct-update-syntax) شناخته می‌شود."

#: src/std-traits/closures.md
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"بسته‌ها یا عبارات لامبدا تایپ‌هایی دارند که نمی‌توان نام‌گذاری کرد. با این حال، "
"آن‌ها پیاده‌سازی‌های ویژه از traits [`Fn`](https://doc.rust-lang.org/std/ops/"
"trait.Fn.html)، [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut."
"html) و [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) "
"هستند:"

#: src/std-traits/closures.md
msgid "\"Calling {func_name}({input}): {}\""
msgstr "\"فراخوانی {func_name}({input}): {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"add_3\""
msgstr "\"add_3: {}\""

#: src/std-traits/closures.md
msgid "\"accumulate\""
msgstr "\"تجمیع: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid "\"multiply_sum\""
msgstr "\"multiply_sum: {}\""

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values. It can "
"be called needing only a shared reference to the closure, which means the "
"closure can be executed repeatedly and even concurrently."
msgstr ""
"یک `Fn` (برای مثال `add_3`) نه مقادیر گرفته شده را مصرف می‌کند و نه آن‌ها را "
"تغییر می‌دهد، یا شاید اصلاً چیزی را نمی‌گیرد. این تایپ می‌تواند به‌طور همزمان "
"چندین بار فراخوانی شود."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. The closure "
"object is accessed via exclusive reference, so it can be called repeatedly "
"but not concurrently."
msgstr ""
"یک `FnMut` (برای مثال `accumulate`) ممکن است مقادیر گرفته شده را تغییر دهد. "
"شما می‌توانید آن را چندین بار فراخوانی کنید، اما نه به‌طور همزمان."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. "
"Doing so consumes the closure and any values captured by move."
msgstr ""
"اگر یک `FnOnce` (برای مثال `multiply_sum`) داشته باشید، تنها می‌توانید آن را "
"یک‌بار فراخوانی کنید. ممکن است مقادیر گرفته شده را مصرف کند."

#: src/std-traits/closures.md
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` یک زیرتایپ از `FnOnce` است. `Fn` نیز یک زیرتایپ از `FnMut` و "
"`FnOnce` است. به عبارت دیگر، می‌توانید از `FnMut` در جایی که `FnOnce` نیاز "
"است استفاده کنید و از `Fn` در جایی که `FnMut` یا `FnOnce` نیاز است استفاده "
"کنید."

#: src/std-traits/closures.md
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""
"زمانی که تابعی تعریف می‌کنید که یک closure را می‌گیرد، باید از `FnOnce` "
"استفاده کنید اگر فقط یک بار آن را فراخوانی می‌کنید (یعنی یک بار استفاده "
"می‌شود)، یا از `FnMut` در غیر این صورت، و در نهایت از `Fn`. این کار بیشترین "
"انعطاف‌پذیری را برای فراخوانی‌کننده فراهم می‌کند."

#: src/std-traits/closures.md
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(which can be passed to a consumer of any of the 3 closure traits), then "
"`FnMut`, and lastly `FnOnce`."
msgstr ""
"در مقابل، زمانی که یک closure دارید، بیشترین انعطاف‌پذیری که می‌توانید داشته "
"باشید `Fn` است (که می‌تواند در هر جایی استفاده شود)، سپس `FnMut` و در نهایت "
"`FnOnce`."

#: src/std-traits/closures.md
#, fuzzy
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures. Function pointers "
"(references to `fn` items) implement `Copy` and `Fn`."
msgstr ""
"کامپایلر همچنین `Copy` (برای مثال برای `add_3`) و `Clone` (برای مثال "
"`multiply_sum`) را بر اساس آنچه که closure به دست می‌آورد، استنتاج می‌کند."

#: src/std-traits/closures.md
msgid ""
"By default, closures will capture each variable from an outer scope by the "
"least demanding form of access they can (by shared reference if possible, "
"then exclusive reference, then by move). The `move` keyword forces capture "
"by value."
msgstr ""
"به صورت پیش‌فرض، بسته‌بندی‌ها (closures) هر متغیر از یک دامنه بیرونی را با "
"کمترین سطح دسترسی ممکن (با ارجاع مشترک اگر ممکن باشد، سپس ارجاع انحصاری، سپس "
"با انتقال) capture می‌کنند. کلیدواژه `move` یا انتقال، capture را به صورت "
"value اجباری می‌کند."

#: src/std-traits/closures.md src/smart-pointers/trait-objects.md
msgid "\"{} {}\""
msgstr "\"{} {}\""

#: src/std-traits/closures.md
msgid "\"Hi\""
msgstr "\"Hi\""

#: src/std-traits/closures.md
msgid "\"Greg\""
msgstr "\"Greg\""

#: src/std-traits/exercise.md
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""
"در این مثال، شما الگوریتم کلاسیک [رمزگذاری \"ROT13\"](https://en.wikipedia."
"org/wiki/ROT13) را پیاده‌سازی خواهید کرد. این کد را به محیط Playground کپی "
"کرده و بخش‌های ناقص آن را پیاده‌سازی کنید. تنها حروف الفبای ASCII را بچرخانید "
"تا نتیجه همچنان UTF-8 معتبر باقی بماند."

#: src/std-traits/exercise.md
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr "// Implement the `Read` trait for `RotDecoder`.\n"

#: src/std-traits/exercise.md src/std-traits/solution.md
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr "\"Gb trg gb gur bgure fvqr!\""

#: src/std-traits/exercise.md src/std-traits/solution.md
msgid "\"To get to the other side!\""
msgstr "\"To get to the other side!\""

#: src/std-traits/exercise.md
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""
"چه اتفاقی می‌افتد اگر دو نمونه از `RotDecoder` را به‌هم متصل کنید که هر کدام "
"۱۳ کاراکتر را بچرخانند؟"

#: src/std-traits/solution.md
msgid "'A'"
msgstr "'A'"

#: src/welcome-day-3.md
msgid "Welcome to Day 3"
msgstr "به روز ۳ خوش آمدید"

#: src/welcome-day-3.md
msgid "Today, we will cover:"
msgstr "امروز، ما به بررسی خواهیم پرداخت:"

#: src/welcome-day-3.md
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr ""
"مدیریت حافظه، طول عمرها و بررسی‌کننده قرض‌گیری (borrow checker): چگونه زبان "
"Rust از ایمنی حافظه اطمینان حاصل می‌کند."

#: src/welcome-day-3.md
msgid "Smart pointers: standard library pointer types."
msgstr "اشاره‌گر هوشمند: تایپ‌های اشاره‌گر در کتابخانه استاندارد."

#: src/welcome-day-3.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 20 "
"minutes. It contains:"
msgstr ""
"با احتساب استراحت‌های ۱۰ دقیقه‌ای، این جلسه باید حدود ۲ ساعت و ۲۰ دقیقه طول "
"بکشد. این جلسه شامل:"

#: src/memory-management.md src/memory-management/clone.md
msgid "Clone"
msgstr "Clone"

#: src/memory-management.md
msgid "Drop"
msgstr "Drop"

#: src/memory-management/review.md
msgid "Programs allocate memory in two ways:"
msgstr "برنامه‌ها حافظه را به دو روش تخصیص می‌دهند:"

#: src/memory-management/review.md
msgid "Stack: Continuous area of memory for local variables."
msgstr ""
"Stack: بلوک پیوسته‌ای از حافظه که برای متغیرهای محلی (داخل یک تابع) استفاده "
"می‌شود."

#: src/memory-management/review.md
msgid "Values have fixed sizes known at compile time."
msgstr "مقادیر دارای اندازه‌های ثابتی هستند که در زمان کامپایل شناخته می‌شوند."

#: src/memory-management/review.md
msgid "Extremely fast: just move a stack pointer."
msgstr "بسیار سریع: فقط یک اشاره‌گر stack را جابجا کنید."

#: src/memory-management/review.md
msgid "Easy to manage: follows function calls."
msgstr "مدیریت آسان: پیرو فراخوانی‌های تابع است."

#: src/memory-management/review.md
msgid "Great memory locality."
msgstr "بهره‌وری عالی از حافظه."

#: src/memory-management/review.md
msgid "Heap: Storage of values outside of function calls."
msgstr "Heap: ذخیره‌سازی مقادیر خارج از فراخوانی‌های تابع."

#: src/memory-management/review.md
msgid "Values have dynamic sizes determined at runtime."
msgstr "مقادیر دارای اندازه‌های پویا هستند که در زمان اجرا تعیین می‌شوند."

#: src/memory-management/review.md
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "کمی کندتر از stack: نیاز به برخی از عملیات‌های مدیریتی دارد."

#: src/memory-management/review.md
msgid "No guarantee of memory locality."
msgstr "هیچ تضمینی برای بهره‌وری بالا از حافظه ندارد."

#: src/memory-management/review.md
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"ساختن یک `String` metadata با اندازه ثابت را روی stack و داده با اندازه "
"پویا، یعنی رشته واقعی، را روی heap قرار می‌دهد:"

#: src/memory-management/review.md
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"ذکر کنید که یک `String` توسط یک `Vec` پشتیبانی می‌شود، بنابراین دارای ظرفیت و "
"طول است و در صورت تغییرپذیری، می‌تواند از طریق اختصاص مجدد حافظه روی heap رشد "
"کند."

#: src/memory-management/review.md
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"اگر دانش‌آموزان درباره آن سوال کنند، می‌توانید اشاره کنید که حافظه زیرین با "
"استفاده از [System Allocator](https://doc.rust-lang.org/std/alloc/struct."
"System.html) بر روی heap اختصاص داده شده و تخصیص‌دهنده‌های سفارشی می‌توانند با "
"استفاده از [Allocator API](https://doc.rust-lang.org/std/alloc/index.html) "
"پیاده‌سازی شوند"

#: src/memory-management/review.md
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"می‌توانیم با استفاده از Rust ناامن (unsafe) نحوه چیدمان حافظه را بررسی کنیم. "
"با این حال، باید اشاره کنید که این کار به درستی ناامن است!"

#: src/memory-management/review.md src/testing/unit-tests.md
msgid "' '"
msgstr "' '"

#: src/memory-management/review.md
msgid "\"world\""
msgstr "\"دنیا\""

#: src/memory-management/review.md
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"

#: src/memory-management/review.md
msgid "\"capacity = {capacity}, ptr = {ptr:#x}, len = {len}\""
msgstr "\"capacity = {capacity}, ptr = {ptr:#x}, len = {len}\""

#: src/memory-management/approaches.md
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "به طور سنتی، زبان‌ها به دو دسته گسترده تقسیم شده‌اند:"

#: src/memory-management/approaches.md
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr "کنترل کامل از طریق مدیریت دستی حافظه: C++، C، پاسکال، ..."

#: src/memory-management/approaches.md
msgid "Programmer decides when to allocate or free heap memory."
msgstr "برنامه‌نویس تصمیم می‌گیرد که چه زمانی حافظه heap را تخصیص یا آزاد کند."

#: src/memory-management/approaches.md
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr ""
"برنامه‌نویس باید تعیین کند که آیا یک اشاره‌گر هنوز به حافظه معتبر اشاره می‌کند "
"یا نه."

#: src/memory-management/approaches.md
msgid "Studies show, programmers make mistakes."
msgstr "مطالعات نشان می‌دهد که برنامه‌نویسان اشتباهاتی مرتکب می‌شوند."

#: src/memory-management/approaches.md
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"ایمنی کامل از طریق مدیریت خودکار حافظه در زمان اجرا: جاوا، پایتون، گو، "
"هسکل، ..."

#: src/memory-management/approaches.md
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr ""
"یک سیستم زمان اجرا اطمینان می‌یابد که حافظه تا زمانی که دیگر نتواند به آن "
"ارجاع داده شود، آزاد نمی‌شود."

#: src/memory-management/approaches.md
#, fuzzy
msgid "Typically implemented with reference counting or garbage collection."
msgstr ""
"معمولاً با استفاده از شمارش ارجاع، جمع‌آوری زباله، یا RAII پیاده‌سازی می‌شود."

#: src/memory-management/approaches.md
msgid "Rust offers a new mix:"
msgstr "Rust یک ترکیب جدید ارائه می‌دهد:"

#: src/memory-management/approaches.md
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr "کنترل کامل و ایمنی از طریق اجرای صحیح مدیریت حافظه در زمان کامپایل."

#: src/memory-management/approaches.md
msgid "It does this with an explicit ownership concept."
msgstr "این کار را با استفاده از مفهوم مالکیت صریح انجام می‌دهد."

#: src/memory-management/approaches.md
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr ""
"این اسلاید به منظور کمک به دانش‌آموزانی است که از زبان‌های دیگر می‌آیند تا Rust "
"را در زمینه مناسب قرار دهند."

#: src/memory-management/approaches.md
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""
"C باید حافظه heap را به‌طور دستی با استفاده از `malloc` و `free` مدیریت کند. "
"خطاهای رایج شامل فراموش کردن فراخوانی `free`، فراخوانی آن چندین بار برای یک "
"اشاره‌گر، یا dereference کردن یک اشاره‌گر پس از آزاد شدن حافظه‌ای است که به آن "
"اشاره می‌کند."

#: src/memory-management/approaches.md
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""
"++C ابزارهایی مانند اشاره‌گرهای هوشمند (`unique_ptr`, `shared_ptr`) دارد که "
"از تضمین‌های زبانی درباره فراخوانی ویرایشگرها (destructor) برای اطمینان از "
"آزاد شدن حافظه هنگام بازگشت از تابع استفاده می‌کنند. با این حال، هنوز هم "
"بسیار آسان است که از این ابزارها به اشتباه استفاده کرده و باگ‌هایی مشابه به C "
"ایجاد کرد."

#: src/memory-management/approaches.md
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""
"جاوا، گو و پایتون به جمع‌آوری‌کننده زباله (garbage collector) برای شناسایی "
"حافظه‌ای که دیگر در دسترس نیست و دور ریختن آن متکی هستند. این امر تضمین می‌کند "
"که هر اشاره‌گری می‌تواند dereference شود و از بروز خطاهای استفاده پس از "
"آزادسازی (use-after-free) و سایر دسته‌های باگ جلوگیری می‌کند. اما، GC هزینه‌ای "
"در زمان اجرا دارد و تنظیم مناسب آن دشوار است."

#: src/memory-management/approaches.md
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""
"مدل مالکیت و قرض‌گیری Rust (ownership and borrowing) می‌تواند در بسیاری از "
"موارد عملکرد C را با عملیات‌های تخصیص و آزادسازی دقیقاً در مکان‌های مورد نیاز "
"-- با هزینه صفر -- به دست آورد. همچنین ابزارهایی مشابه به اشاره‌گرهای هوشمند +"
"+C را فراهم می‌کند. در صورت نیاز، گزینه‌های دیگری مانند شمارش ارجاع نیز در "
"دسترس هستند و حتی crates شخص ثالثی برای پشتیبانی از جمع‌آوری زباله در زمان "
"اجرا موجود است (که در این کلاس پوشش داده نمی‌شود)."

#: src/memory-management/ownership.md
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"تمام پیوندهای متغیر دارای یک **دامنه** هستند که در آن معتبر هستند و استفاده "
"از متغیر خارج از دامنه‌اش یک خطاست:"

#: src/memory-management/ownership.md
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr ""
"می‌گوییم که متغیر _مالک_ مقدار است. هر مقدار در Rust در هر لحظه دقیقاً یک مالک "
"دارد."

#: src/memory-management/ownership.md
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr ""
"در پایان دامنه، متغیر **حذف** می‌شود و داده‌ها آزاد می‌شوند. یک ویرایشگر "
"(destructor) می‌تواند در اینجا اجرا شود تا منابع را آزاد کند."

#: src/memory-management/ownership.md
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""
"دانش‌آموزانی که با پیاده‌سازی‌های جمع‌آوری زباله آشنا هستند، خواهند دانست که یک "
"جمع‌آوری‌کننده زباله با مجموعه‌ای از \"ریشه‌ها\" برای یافتن تمام حافظه‌های قابل "
"دسترسی شروع می‌کند. اصول \"مالکیت تک‌گانه\" Rust ایده مشابهی است."

#: src/memory-management/move.md
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "انتساب, *مالکیت* را بین متغیرها منتقل می‌کند:"

#: src/memory-management/move.md src/concurrency/async-control-flow/select.md
msgid "\"Hello!\""
msgstr "\"سلام!\""

#: src/memory-management/move.md
msgid "// println!(\"s1: {s1}\");\n"
msgstr "// println!(\"s1: {s1}\");\n"

#: src/memory-management/move.md
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "انتساب `s1`به `s2` مالکیت را منتقل می‌کند."

#: src/memory-management/move.md
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"زمانی که دیگر در اسکوپ `s1` نیستیم,  هیچ اتفاقی نمی‌افتد: چون `s1` مالک چیزی "
"نیست."

#: src/memory-management/move.md
msgid "When `s2` goes out of scope, the string data is freed."
msgstr "زمانی که دیگر در اسکوپ `s2` نیستیم, داده‌های رشته آزاد می‌شوند."

#: src/memory-management/move.md
msgid "Before move to `s2`:"
msgstr "قبل از انتقال به `s2` :"

#: src/memory-management/move.md
msgid "After move to `s2`:"
msgstr "بعد از انتقال به `s2` :"

#: src/memory-management/move.md
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                     :\n"
":    s1 \"(inaccessible)\"    :     :                                     :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| H  | e  | l  | l  | o  | !  |   :\n"
":   | len       |     6 |   :  |  :   +----+----+----+----+----+----+   :\n"
":   | capacity  |     6 |   :  |  :                                     :\n"
":   +-----------+-------+   :  |  :                                     :\n"
":                           :  |  `- - - - - - - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     6 |   :\n"
":   | capacity  |     6 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                     :\n"
":    s1 \"(inaccessible)\"    :     :                                     :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| H  | e  | l  | l  | o  | !  |   :\n"
":   | len       |     6 |   :  |  :   +----+----+----+----+----+----+   :\n"
":   | capacity  |     6 |   :  |  :                                     :\n"
":   +-----------+-------+   :  |  :                                     :\n"
":                           :  |  `- - - - - - - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     6 |   :\n"
":   | capacity  |     6 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/move.md
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"هنگامی که یک مقدار را به یک تابع منتقل می‌کنید، مقدار به آرگمان تابع اختصاص "
"داده می‌شود. به این شکل مالکیت را منتقل می‌کند:"

#: src/memory-management/move.md src/memory-management/clone.md
msgid "\"Hello {name}\""
msgstr "\"سلام {name}\""

#: src/memory-management/move.md src/memory-management/clone.md
#: src/android/interoperability/java.md
msgid "\"Alice\""
msgstr "\"الیس\""

#: src/memory-management/move.md
msgid "// say_hello(name);\n"
msgstr "// say_hello(name);\n"

#: src/memory-management/move.md
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"اشاره کنید که این رویه راست بر خلاف پیش‌فرض زبان <span dir=ltr>C++</span>  "
"است که در ان مقدار کپی میشود مگر که از <span dir=ltr>`std::move`</span> "
"استفاده کنیم ( تا یک مقدار را جا به جا کنیم!)"

#: src/memory-management/move.md
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"این رویه فقط برای انتقال مالکیت است. اینکه آیا هیچ کد ماشینی برای دستکاری "
"خود داده‌ها تولید می‌شود یا خیر، موضوعی برای بهینه‌سازی است و چنین کپی‌هایی "
"به‌طور تهاجمی (aggressively) بهینه‌سازی می‌شوند."

#: src/memory-management/move.md
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"مقادیر ساده (مانند اعداد صحیح) را می‌توان `Copy` کرد (اسلایدهای بعدی را "
"ببینید)."

#: src/memory-management/move.md
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "در Rust، کلون‌ها واضح بیان می‌شوند (با استفاده از `clone`)."

#: src/memory-management/move.md
msgid "In the `say_hello` example:"
msgstr "در مثال `say_hello`:"

#: src/memory-management/move.md
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"با اولین فراخوانی `say_hello`، تابع `main` مالکیت `name` را انتقال می‌دهد. پس "
"از آن، `name` دیگر نمی‌تواند در `main` استفاده شود."

#: src/memory-management/move.md
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"حافظه انباشت اختصاص داده شده برای `name` در انتهای تابع `say_hello` آزاد "
"خواهد شد."

#: src/memory-management/move.md
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"تابع `main` می‌تواند مالکیت `name` را حفظ کند اگر آن را به عنوان یک مرجع "
"(<span dir=ltr>`&name`</span>) منتقل کند و صد البته که `say_hello` یک مرجع "
"را به عنوان پارامتر باید بپذیرد."

#: src/memory-management/move.md
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"به عنوان گزینه دیگر، `main` می‌تواند یک کلون از `name` را در فراخوانی اولیه "
"تابع ای که در نظر داریم (<span dir=ltr>`name.clone()`</span>) منتقل کند."

#: src/memory-management/move.md
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"در زبان Rust سخت‌تر از <span dir=ltr>C++</span> است که سهوا کپی ایجاد کنیم, "
"زیر به صورت پیش‌فرض از مفهوم «انتقال» استفاده میکنیم و برنامه نویس مجبور است "
"هر جا که لازم هست به صورت صریح کلون را ایجاد کند."

#: src/memory-management/move.md
msgid "Defensive Copies in Modern C++"
msgstr "نسخههای دفاعی در ++C مدرن"

#: src/memory-management/move.md
msgid "Modern C++ solves this differently:"
msgstr "<span dir=ltr>C++</span> مدرن این مشکل را به شیوه متفاوتی حل می‌کند:"

#: src/memory-management/move.md
msgid "\"Cpp\""
msgstr "\"Cpp\""

#: src/memory-management/move.md
msgid "// Duplicate the data in s1.\n"
msgstr "// Duplicate the data in s1.\n"

#: src/memory-management/move.md
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"داده‌های انباشت از داده‌های `s1`  یک کپی برابر اصل برای  `s2` گرفته می‌شود که "
"این کپی به صورت مستقل است."

#: src/memory-management/move.md
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"حالا هر موقع `s1` یا `s2` از اسکوپ موردنظرشون خارج شوند هر کدام به صورت "
"جداگانه‌ای حافظه خود را آزاد میکنند."

#: src/memory-management/move.md
msgid "Before copy-assignment:"
msgstr "قبل از انتساب همراه کپی:"

#: src/memory-management/move.md
msgid "After copy-assignment:"
msgstr "بعد از انتساب همراه کپی:"

#: src/memory-management/move.md
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""
"زبان <span dir=ltr>C++</span> انتخاب کمی متفاوت نسبت به  زبان Rust انجام "
"داده است. زیرا `=` داده‌ها را کپی می‌کند، داده‌های رشته باید کلون شوند. در غیر "
"این صورت، هر موقع از اسکوپ یکی از آنها خارج شویم امکان به وجود آمدن اشتباه "
"آزادسازی مجدد حافظه رخ دهد."

#: src/memory-management/move.md
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""
"البته که زبان <span dir=ltr>C++</span> دارای  [<span dir=ltr>`std::move`</"
"span>](https://en.cppreference.com/w/cpp/utility/move)  است که برای انتقال "
"یک متغییر استفاده میشود. اگر مثال ما <span dir=ltr>`s2 = std::move(s1)`</"
"span> بود هیچ تخصیص انباشتی صورت نمیگرفت بلکه `s1` در یک وضعیت معتبر البته "
"نامشخص قرار میگرفت و برخلاف زبان Rust, توی زبان <span dir=ltr>C++</span> "
"برنامه‌نویس مجاز است که دوباره از `s1` استفاده کند."

#: src/memory-management/move.md
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""
"بر خلاف Rust، `=` در <span dir=ltr>C++</span> می‌تواند برای کپی کردن و هم "
"انتقال دادن استفاده شود."

#: src/memory-management/clone.md
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr ""
"گاهی اوقات شما _می‌خواهید_ یک نسخه از مقدار بسازید. ویژگی `Clone` این کار را "
"انجام می‌دهد."

#: src/memory-management/clone.md
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `vec!` or `Box::new`."
msgstr ""
"ایده‌ی `Clone` این است که شناسایی مکان‌های تخصیص حافظه heap آسان‌تر شود. به "
"دنبال `()clone.` و چند مورد دیگر مانند `!vec` یا `Box::new` بگردید."

#: src/memory-management/clone.md
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""
"معمولاً برای حل مشکلات مربوط به بررسی‌کننده قرض‌گیری (borrow checker) از کپی "
"کردن استفاده می‌شود و سپس در آینده تلاش می‌شود تا آن کپی‌ها بهینه‌سازی شوند."

#: src/memory-management/clone.md
msgid ""
"`clone` generally performs a deep copy of the value, meaning that if you e."
"g. clone an array, all of the elements of the array are cloned as well."
msgstr ""
"`clone` معمولاً یک کپی عمیق از مقدار را انجام می‌دهد، به این معنی که اگر به "
"عنوان مثال یک آرایه را کپی کنید، تمام عناصر آن آرایه نیز کپی خواهند شد."

#: src/memory-management/clone.md
msgid ""
"The behavior for `clone` is user-defined, so it can perform custom cloning "
"logic if needed."
msgstr ""
"رفتار `clone` توسط کاربر تعریف می‌شود، بنابراین می‌تواند در صورت نیاز، منطق "
"کپی‌برداری سفارشی را اجرا کند."

#: src/memory-management/copy-types.md
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"در حالی که مفهوم انتقال  به صورت پیش‌فرض است، در زبان راست چند نوع خاص به "
"صورت پیش‌فرض کپی می‌شوند:"

#: src/memory-management/copy-types.md
msgid "These types implement the `Copy` trait."
msgstr "این انواع‌داده ویژگی `Copy` را پیاده‌سازی کرده‌اند."

#: src/memory-management/copy-types.md
msgid "You can opt-in your own types to use copy semantics:"
msgstr "البته که میتوان برای نوع‌هایی که میسازید هم مفهوم کپی را داشته باشید:"

#: src/memory-management/copy-types.md
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "پس از انتساب، هر دو `p1` و `p2` داده‌های خود مستقل خود را دارند."

#: src/memory-management/copy-types.md
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"همچنین می‌توانیم از <span dir=ltr>`p1.clone()`</span>  برای کپی صریح داده‌ها "
"استفاده کنیم."

#: src/memory-management/copy-types.md
msgid "Copying and cloning are not the same thing:"
msgstr "کپی‌برداری و کلون‌سازی یکسان نیستند:"

#: src/memory-management/copy-types.md
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"کپی‌برداری به کپی‌های بیت به بیت از مناطق حافظه اشاره دارد و روی همه انواع "
"تعریف شده توسط شما کار نمی‌کند."

#: src/memory-management/copy-types.md
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"کپی‌برداری اجازه منطق سفارشی را نمی‌دهد (بر خلاف کپی constructors در <span "
"dir=ltr>C++</span>)."

#: src/memory-management/copy-types.md
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"کلون‌سازی یک عملیات عمومی‌تر است و همچنین با پیاده‌سازی ویژگی `Clone` امکان "
"رفتار سفارشی را فراهم می‌کند."

#: src/memory-management/copy-types.md
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr ""
"کپی‌برداری روی انواع داده‌ای که ویژگی Drop را پیاده سازی کرده اند کار نمی‌کند."

#: src/memory-management/copy-types.md
msgid "In the above example, try the following:"
msgstr "در مثال بالا، موارد زیر را امتحان کنید:"

#: src/memory-management/copy-types.md
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"یک فیلد `String` به `struct Point` اضافه کنید. کامپایل نمی‌شود زیرا `String` "
"یک نوع `Copy` نیست."

#: src/memory-management/copy-types.md
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"ویژگی `Copy` را از صفت `derive` حذف کنید. اکنون خطای کامپایلر در `!println` "
"برای `p1` قرار دارد."

#: src/memory-management/copy-types.md
msgid "Show that it works if you clone `p1` instead."
msgstr "نشان دهید که اگر `p1` را به جای کپی آن کلون کنید، کار می‌کند."

#: src/memory-management/copy-types.md
msgid ""
"Shared references are `Copy`/`Clone`, mutable references are not. This is "
"because rust requires that mutable references be exclusive, so while it's "
"valid to make a copy of a shared reference, creating a copy of a mutable "
"reference would violate Rust's borrowing rules."
msgstr ""
"ارجاعات مشترک (`shared references`) دارای ویژگی `Copy`/`Clone` هستند، اما "
"ارجاعات قابل تغییر (`mutable references`) این‌طور نیستند. این به این دلیل است "
"که Rust نیاز دارد که ارجاعات قابل تغییر منحصر به فرد باشند، بنابراین در حالی "
"که کپی کردن یک ارجاع مشترک معتبر است، ایجاد یک کپی از یک ارجاع قابل تغییر "
"قوانین قرض‌گیری Rust را نقض می‌کند."

#: src/memory-management/drop.md
msgid "The `Drop` Trait"
msgstr "ویژگی `Drop`"

#: src/memory-management/drop.md
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"مقادیر که ویژگی [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) "
"را پیاده‌سازی می‌کنند می‌توانند کدی را مشخص کنند که هنگام خروج از دامنه اجرا "
"شود:"

#: src/memory-management/drop.md
msgid "\"Dropping {}\""
msgstr "\"Dropping {}\""

#: src/memory-management/drop.md src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
msgid "\"a\""
msgstr "\"a\""

#: src/memory-management/drop.md src/android/testing/googletest.md
msgid "\"b\""
msgstr "\"a\""

#: src/memory-management/drop.md
msgid "\"c\""
msgstr "\"c\""

#: src/memory-management/drop.md
msgid "\"d\""
msgstr "\"d\""

#: src/memory-management/drop.md
msgid "\"Exiting block B\""
msgstr "\"Exiting block B\""

#: src/memory-management/drop.md
msgid "\"Exiting block A\""
msgstr "\"Exiting block A\""

#: src/memory-management/drop.md
msgid "\"Exiting main\""
msgstr "\"Exiting main\""

#: src/memory-management/drop.md
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr ""
"توجه داشته باشید که `std::mem::drop` با `std::ops::Drop::drop` یکسان نیست."

#: src/memory-management/drop.md
msgid "Values are automatically dropped when they go out of scope."
msgstr "مقادیر به طور خودکار زمانی که از دامنه خارج می‌شوند، حذف می‌شوند."

#: src/memory-management/drop.md
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""
"زمانی که یک مقدار حذف می‌شود، اگر آن مقدار ویژگی `std::ops::Drop` را "
"پیاده‌سازی کرده باشد، پیاده‌سازی `Drop::drop` آن فراخوانی خواهد شد."

#: src/memory-management/drop.md
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""
"تمام فیلدهای آن نیز سپس حذف خواهند شد، چه آن مقدار ویژگی `Drop` را پیاده‌سازی "
"کرده باشد یا نه."

#: src/memory-management/drop.md
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""
"`std::mem::drop` یک تابع خالی است که هر مقداری را می‌پذیرد. اهمیت آن در این "
"است که مالکیت مقدار را به عهده می‌گیرد، بنابراین در پایان دامنه‌اش حذف می‌شود. "
"این ویژگی آن را به روشی مناسب برای حذف صریح مقادیر پیش از آنچه که معمولاً از "
"دامنه خارج می‌شوند، تبدیل می‌کند."

#: src/memory-management/drop.md
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""
"این می‌تواند برای اشیائی که در هنگام `drop` کاری انجام می‌دهند مفید باشد: آزاد "
"کردن قفل‌ها، بستن فایل‌ها و غیره."

#: src/memory-management/drop.md
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "چرا `Drop::drop` `self` را نمی‌گیرد؟"

#: src/memory-management/drop.md
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"پاسخ کوتاه: اگر این‌طور بود، `std::mem::drop` در پایان بلوک فراخوانی می‌شد که "
"منجر به فراخوانی مجدد `Drop::drop` و ایجاد خطای سرریز (stack overflow) stack "
"می‌شد!"

#: src/memory-management/drop.md
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "سعی کنید `drop(a)` را با `()a.drop` جایگزین کنید."

#: src/memory-management/exercise.md
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""
"در این مثال، ما یک نوع داده پیچیده را پیاده‌سازی خواهیم کرد که مالک تمام "
"داده‌های خود است. ما از \"الگوی سازنده\" برای پشتیبانی از ساخت یک مقدار جدید "
"به صورت قطعه‌قطعه، با استفاده از توابع کمکی، استفاده خواهیم کرد."

#: src/memory-management/exercise.md
msgid "Fill in the missing pieces."
msgstr "جا‌های خالی را پر کنید."

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// A representation of a software package.\n"
msgstr "/// A representation of a software package.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"

#: src/memory-management/exercise.md
msgid "\"1\""
msgstr "\"1\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"

#: src/memory-management/exercise.md
msgid "\"2\""
msgstr "\"2\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the package version.\n"
msgstr "/// Set the package version.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the package authors.\n"
msgstr "/// Set the package authors.\n"

#: src/memory-management/exercise.md
msgid "\"3\""
msgstr "\"3\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Add an additional dependency.\n"
msgstr "/// Add an additional dependency.\n"

#: src/memory-management/exercise.md
msgid "\"4\""
msgstr "\"4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
#, fuzzy
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr "/// Set the language. If not set, language defaults to None.\n"

#: src/memory-management/exercise.md
msgid "\"5\""
msgstr "\"5\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"base64\""
msgstr "\"base64: {base64:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"0.13\""
msgstr "\"0.13\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"base64: {base64:?}\""
msgstr "\"base64: {base64:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"log\""
msgstr "\"log\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"0.4\""
msgstr "\"0.4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"log: {log:?}\""
msgstr "\"log: {log:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"serde\""
msgstr "\"serde\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"djmitche\""
msgstr "\"djmitche\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"4.0\""
msgstr "\"4.0\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"serde: {serde:?}\""
msgstr "\"serde: {serde:?}\""

#: src/memory-management/solution.md
msgid "\"0.1\""
msgstr "\"0.1\""

#: src/smart-pointers.md
msgid "Box<T>"
msgstr "Box<T>"

#: src/smart-pointers.md
msgid "Rc"
msgstr "Rc"

#: src/smart-pointers/box.md
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) یک اشاره‌گر مالک "
"به داده‌های روی heap است:"

#: src/smart-pointers/box.md
msgid "\"five: {}\""
msgstr "\"five: {}\""

#: src/smart-pointers/box.md
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`<Box<T` ویژگی `<Deref<Target = T` را پیاده‌سازی می‌کند، که به این معناست که "
"می‌توانید [مستقیم روش‌های `T` را روی `<Box<T` فراخوانی کنید](https://doc.rust-"
"lang.org/std/ops/trait.Deref.html#more-on-deref-coercion)."

#: src/smart-pointers/box.md
msgid ""
"Recursive data types or data types with dynamic sizes cannot be stored "
"inline without a pointer indirection, which can be worked around using `Box`:"
msgstr ""
"تایپ‌های داده‌های بازگشتی یا انواع داده با اندازه‌های دینامیک را نمی‌توان به "
"صورت inline بدون pointer indirection ذخیره کرد، که می‌توان با استفاده از "
"`Box` آن کار را کرد:"

#: src/smart-pointers/box.md
#, fuzzy
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr "/// A non-empty list: first element and the rest of the list.\n"

#: src/smart-pointers/box.md
#, fuzzy
msgid "/// An empty list.\n"
msgstr "/// An empty list.\n"

#: src/smart-pointers/box.md
msgid "\"{list:?}\""
msgstr "\"{list:?}\""

#: src/smart-pointers/box.md
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"

#: src/smart-pointers/box.md
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"`Box` مانند `std::unique_ptr` در ++C است، با این تفاوت که تضمین شده است که "
"هیچ‌گاه تهی (null) نخواهد بود."

#: src/smart-pointers/box.md
msgid "A `Box` can be useful when you:"
msgstr "`Box` می‌تواند زمانی مفید باشد که شما:"

#: src/smart-pointers/box.md
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"یک تایپ دارید که اندازه آن در زمان کامپایل مشخص نیست، اما کامپایلر Rust نیاز "
"به دانستن اندازه دقیق آن دارد."

#: src/smart-pointers/box.md
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"می‌خواهید مالکیت مقدار زیادی داده را انتقال دهید. برای جلوگیری از کپی کردن "
"حجم زیادی از داده‌ها در پشته، به جای آن داده‌ها را در heap در یک `Box` ذخیره "
"کنید تا فقط اشاره‌گر منتقل شود."

#: src/smart-pointers/box.md
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not be able to compute a fixed size for the "
"struct in memory (the `List` would be of infinite size)."
msgstr ""
"اگر از `Box` استفاده نمی‌کردیم و سعی می‌کردیم یک `List` را مستقیماً در داخل "
"`List` قرار دهیم، کامپایلر نمی‌توانست اندازه ثابتی برای ساختار در حافظه "
"محاسبه کند (زیرا `List` اندازه‌ای بی‌نهایت پیدا می‌کرد)."

#: src/smart-pointers/box.md
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` این مشکل را حل می‌کند زیرا اندازه‌ای برابر با یک اشاره‌گر عادی دارد و فقط "
"به عنصر بعدی `List` در heap اشاره می‌کند."

#: src/smart-pointers/box.md
msgid ""
"Remove the `Box` in the List definition and show the compiler error. We get "
"the message \"recursive without indirection\", because for data recursion, "
"we have to use indirection, a `Box` or reference of some kind, instead of "
"storing the value directly."
msgstr ""
"`Box` را از تعریف `List` حذف کنید و خطای کامپایلر را نمایش دهید. پیام خطا "
"\"recursive without indirection\" را دریافت خواهیم کرد، زیرا برای رکورسیون "
"داده‌ها باید از یک روش غیرمستقیم، مانند `Box` یا ارجاعی از نوعی، به جای ذخیره "
"مستقیم مقدار استفاده کنیم."

#: src/smart-pointers/box.md
msgid "Niche Optimization"
msgstr "بهینه سازی Niche"

#: src/smart-pointers/box.md
msgid ""
"Though `Box` looks like `std::unique_ptr` in C++, it cannot be empty/null. "
"This makes `Box` one of the types that allow the compiler to optimize "
"storage of some enums."
msgstr ""
"اگرچه `Box` مشابه `std::unique_ptr` در ++C به نظر می‌رسد، اما نمی‌تواند خالی/"
"null باشد. این ویژگی باعث می‌شود که `Box` یکی از تایپ‌هایی باشد که به کامپایلر "
"اجازه می‌دهد ذخیره‌سازی برخی از `enum`ها را بهینه‌سازی کند."

#: src/smart-pointers/box.md
msgid ""
"For example, `Option<Box<T>>` has the same size, as just `Box<T>`, because "
"compiler uses NULL-value to discriminate variants instead of using explicit "
"tag ([\"Null Pointer Optimization\"](https://doc.rust-lang.org/std/option/"
"#representation)):"
msgstr ""
"برای مثال، `<<Option<Box<T` همان اندازه را دارد که `<Box<T`، زیرا کامپایلر "
"از مقدار NULL برای تمایز بین variant‌ ها به جای استفاده از تگ صریح استفاده "
"می‌کند ([\"بهینه‌سازی اشاره‌گر خالی\"](https://doc.rust-lang.org/std/option/"
"#representation)):"

#: src/smart-pointers/box.md
msgid "\"Just box\""
msgstr "\"Just box\""

#: src/smart-pointers/box.md
msgid "\"Optional box\""
msgstr "\"Optional box\""

#: src/smart-pointers/box.md
msgid "\"Size of just_box: {}\""
msgstr "\"Size of just_box: {}\""

#: src/smart-pointers/box.md
msgid "\"Size of optional_box: {}\""
msgstr "\"Size of optional_box: {}\""

#: src/smart-pointers/box.md
msgid "\"Size of none: {}\""
msgstr "\"Size of none: {}\""

#: src/smart-pointers/rc.md
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) یک اشاره‌گر مشترک با "
"شمارش ارجاع است. از این هنگام استفاده کنید که نیاز دارید به داده‌های یکسان از "
"مکان‌های متعدد اشاره کنید:"

#: src/smart-pointers/rc.md
msgid "\"a: {a}\""
msgstr "\"a: {a}\""

#: src/smart-pointers/rc.md
msgid "\"b: {b}\""
msgstr "\"b: {b}\""

#: src/smart-pointers/rc.md
msgid ""
"See [`Arc`](../concurrency/shared-state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"اگر در یک محیط چند-رشته‌ای (multi-threaded) هستید، به [`Arc`](../concurrency/"
"shared-state/arc.md) و [`Mutex`](https://doc.rust-lang.org/std/sync/struct."
"Mutex.html) نگاه کنید."

#: src/smart-pointers/rc.md
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"شما می‌توانید یک اشاره‌گر مشترک را به یک اشاره‌گر [`Weak`](https://doc.rust-"
"lang.org/std/rc/struct.Weak.html) تغییر دهید تا دوره‌هایی ایجاد کنید که در "
"نهایت حذف خواهند شد."

#: src/smart-pointers/rc.md
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"شمارش `Rc` تضمین می‌کند که مقدار درون آن به مدت زمانی که ارجاع‌هایی وجود دارد، "
"معتبر خواهد بود."

#: src/smart-pointers/rc.md
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "`Rc` در Rust مشابه `std::shared_ptr` در ++C است."

#: src/smart-pointers/rc.md
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone` ارزان است: این تابع یک اشاره‌گر به همان تخصیص (allocation) ایجاد "
"می‌کند و شمارش ارجاع را افزایش می‌دهد. این عمل کپی عمیق (deep clone) انجام "
"نمی‌دهد و به طور کلی هنگام جستجو برای مسائل عملکردی در کد می‌توان آن را نادیده "
"گرفت."

#: src/smart-pointers/rc.md
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` در واقع در صورت نیاز مقدار درونی را کپی می‌کند (\"clone-on-"
"write\") و یک ارجاع قابل تغییر (mutable reference) برمی‌گرداند."

#: src/smart-pointers/rc.md
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "از `Rc::strong_count` برای بررسی شمارش ارجاع‌ها استفاده کنید."

#: src/smart-pointers/rc.md
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc::downgrade` یک شیء _با شمارش ارجاع ضعیف_ به شما می‌دهد تا دوره‌هایی ایجاد "
"کنید که به درستی حذف خواهند شد (احتمالاً به همراه `RefCell`)."

#: src/smart-pointers/trait-objects.md
msgid ""
"We previously saw how trait objects can be used with references, e.g `&dyn "
"Pet`. However, we can also use trait objects with smart pointers like `Box` "
"to create an owned trait object: `Box<dyn Pet>`."
msgstr ""
"پیش‌تر دیدیم که چگونه می‌توان ازویژگی اشیاء (trait objects) با ارجاعات استفاده "
"کرد، مثلاً `dyn Pet&`. با این حال، می‌توانیم از اشیاء ویژگی با اشاره‌گرهای "
"هوشمند مانند `Box` نیز استفاده کنیم تا یک شیء ویژگی مالک (owned trait "
"object) ایجاد کنیم: `<Box<dyn Pet`."

#: src/smart-pointers/trait-objects.md
msgid "Memory layout after allocating `pets`:"
msgstr "چیدمان حافظه پس از تخصیص `pets`:"

#: src/smart-pointers/trait-objects.md
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    \"pets: Vec<dyn Pet>\"   :     :   \"data: Cat\"         +----+----+----"
"+----+ :\n"
":   +-----------+-------+   :     :  +-------+-------+    | F  | i  | d  | "
"o  | :\n"
":   | ptr       |   o---+---+--.  :  | lives |     9 |    +----+----+----"
"+----+ :\n"
":   | len       |     2 |   :  |  :  +-------+-------+      "
"^                   :\n"
":   | capacity  |     2 |   :  |  :       ^                 "
"|                   :\n"
":   +-----------+-------+   :  |  :       |                 "
"'-------.           :\n"
":                           :  |  :       |               data:"
"\"Dog\"|           :\n"
":                           :  |  :       |              +-------+--|-------"
"+   :\n"
"`- - - - - - - - - - - - - -'  |  :   +---|-+-----+      | name  |  o, 4, 4 "
"|   :\n"
"                               `--+-->| o o | o o-|----->| age   |        5 "
"|   :\n"
"                                  :   +-|---+-|---+      +-------+----------"
"+   :\n"
"                                  :     |     "
"|                                 :\n"
"                                  `- - -| - - |- - - - - - - - - - - - - - - "
"- -'\n"
"                                        |     |\n"
"                                        |     |                      "
"\"Program text\"\n"
"                                  .- - -| - - |- - - - - - - - - - - - - - - "
"- -.\n"
"                                  :     |     |       "
"vtable                    :\n"
"                                  :     |     |      +----------------------"
"+   :\n"
"                                  :     |     `----->| \"<Dog as Pet>::"
"talk\" |   :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     |             "
"vtable                    :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     '----------->| \"<Cat as Pet>::"
"talk\" |   :\n"
"                                  :                  +----------------------"
"+   :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    \"pets: Vec<dyn Pet>\"   :     :   \"data: Cat\"         +----+----+----"
"+----+ :\n"
":   +-----------+-------+   :     :  +-------+-------+    | F  | i  | d  | "
"o  | :\n"
":   | ptr       |   o---+---+--.  :  | lives |     9 |    +----+----+----"
"+----+ :\n"
":   | len       |     2 |   :  |  :  +-------+-------+      "
"^                   :\n"
":   | capacity  |     2 |   :  |  :       ^                 "
"|                   :\n"
":   +-----------+-------+   :  |  :       |                 "
"'-------.           :\n"
":                           :  |  :       |               data:"
"\"Dog\"|           :\n"
":                           :  |  :       |              +-------+--|-------"
"+   :\n"
"`- - - - - - - - - - - - - -'  |  :   +---|-+-----+      | name  |  o, 4, 4 "
"|   :\n"
"                               `--+-->| o o | o o-|----->| age   |        5 "
"|   :\n"
"                                  :   +-|---+-|---+      +-------+----------"
"+   :\n"
"                                  :     |     "
"|                                 :\n"
"                                  `- - -| - - |- - - - - - - - - - - - - - - "
"- -'\n"
"                                        |     |\n"
"                                        |     |                      "
"\"Program text\"\n"
"                                  .- - -| - - |- - - - - - - - - - - - - - - "
"- -.\n"
"                                  :     |     |       "
"vtable                    :\n"
"                                  :     |     |      +----------------------"
"+   :\n"
"                                  :     |     `----->| \"<Dog as Pet>::"
"talk\" |   :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     |             "
"vtable                    :\n"
"                                  :     |            +----------------------"
"+   :\n"
"                                  :     '----------->| \"<Cat as Pet>::"
"talk\" |   :\n"
"                                  :                  +----------------------"
"+   :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/trait-objects.md
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"تایپ‌هایی که ویژگی معین را پیاده‌سازی می‌کنند ممکن است اندازه‌های مختلفی داشته "
"باشند. این موضوع باعث می‌شود که داشتن مواردی مانند `<Vec<dyn Pet` در مثال "
"بالا غیرممکن باشد."

#: src/smart-pointers/trait-objects.md
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet` راهی است برای اطلاع دادن به کامپایلر درباره یک تایپ با اندازه پویا "
"که ویژگی `Pet` را پیاده‌سازی می‌کند."

#: src/smart-pointers/trait-objects.md
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""
"در این مثال، `pets` در stack تخصیص داده می‌شود و داده‌های vector در heap "
"هستند. دو عنصر vector _اشاره‌گرهای چاق_ (fat pointers) هستند:"

#: src/smart-pointers/trait-objects.md
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"اشاره‌گر چاق (fat pointer) یک اشاره‌گر با عرض دو برابر است. این اشاره‌گر دو "
"مؤلفه دارد: یک اشاره‌گر به شیء واقعی و یک اشاره‌گر به [روش‌های جدول مجازی]"
"(https://en.wikipedia.org/wiki/Virtual_method_table) (vtable) برای پیاده‌سازی "
"`Pet` آن شیء خاص."

#: src/smart-pointers/trait-objects.md
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""
"داده‌های مربوط به `Dog` به نام Fido شامل فیلدهای `name` و `age` است. `Cat` "
"دارای فیلد `lives` است."

#: src/smart-pointers/trait-objects.md
msgid "Compare these outputs in the above example:"
msgstr "خروجی‌های زیر را در مثال بالا مقایسه کنید:"

#: src/smart-pointers/exercise.md
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""
"یک درخت باینری (binary tree) یک ساختار داده درختی است که در آن هر گره دو "
"فرزند (چپ و راست) دارد. ما درختی خواهیم ساخت که در آن هر گره یک مقدار را "
"ذخیره می‌کند. برای یک گره معین N، تمام گره‌های زیر درخت چپ N دارای مقادیر "
"کوچکتر خواهند بود و تمام گره‌های زیر درخت راست N دارای مقادیر بزرگتر خواهند "
"بود."

#: src/smart-pointers/exercise.md
msgid "Implement the following types, so that the given tests pass."
msgstr "تایپ‌های زیر را پیاده‌سازی کنید تا آزمایش‌های داده شده موفقیت‌آمیز باشند."

#: src/smart-pointers/exercise.md
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr ""
"اعتبار اضافی: یک تکرارگر (iterator) بر روی درخت باینری پیاده‌سازی کنید که "
"مقادیر را به ترتیب (in-order) برگرداند."

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "/// A node in the binary tree.\n"
msgstr "/// A node in the binary tree.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "/// A possibly-empty subtree.\n"
msgstr "/// A possibly-empty subtree.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"

#: src/smart-pointers/exercise.md
msgid "// Implement `new`, `insert`, `len`, and `has` for `Subtree`.\n"
msgstr "// Implement `new`, `insert`, `len`, and `has` for `Subtree`.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
#, fuzzy
msgid "// not a unique item\n"
msgstr "// not a unique item\n"

#: src/smart-pointers/solution.md src/android/testing/googletest.md
msgid "\"bar\""
msgstr "\"bar\""

#: src/welcome-day-3-afternoon.md
msgid ""
"Including 10 minute breaks, this session should take about 1 hour and 55 "
"minutes. It contains:"
msgstr ""
"با احتساب استراحت‌های ۱۰ دقیقه‌ای، این جلسه باید حدود ۱ ساعت و ۵۵ دقیقه طول "
"بکشد. این شامل:"

#: src/borrowing/shared.md
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr ""
"همان‌طور که پیش‌تر دیدیم، به جای انتقال مالکیت هنگام فراخوانی یک تابع، "
"می‌توانید به تابع اجازه دهید که _ارجاعی_ به مقدار داشته باشد:"

#: src/borrowing/shared.md
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "تابع `add` _ارجاع_ می‌گیرد به دو نقطه و یک نقطه جدید برمی‌گرداند."

#: src/borrowing/shared.md
msgid "The caller retains ownership of the inputs."
msgstr "فراخوانی‌کننده مالکیت ورودی‌ها را حفظ می‌کند."

#: src/borrowing/shared.md
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""
"این اسلاید مرور مطالب مربوط به ارجاعات از روز اول است که به طور جزئی به شامل "
"آرگومان‌های تابع و مقادیر بازگشتی گسترش یافته است."

#: src/borrowing/shared.md
msgid "Notes on stack returns and inlining:"
msgstr "یادداشت‌هایی در مورد بازگشت‌های stack و درون‌ریزی (inlining):"

#: src/borrowing/shared.md
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation, by inlining the call to add into main. Change "
"the above code to print stack addresses and run it on the [Playground]"
"(https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"برای نشان دادن این که بازگشت از `add` ارزان است، زیرا کامپایلر می‌تواند "
"عملیات کپی را حذف کند، با درون‌ریزی (inlining) فراخوانی `add` به تابع `main`، "
"کد فوق را تغییر دهید تا آدرس‌های پشته چاپ شوند و آن را در [Playground]"
"(https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"اجرا کنید یا به اسمبلی در [Godbolt](https://rust.godbolt.org/) نگاه کنید. در "
"سطح بهینه‌سازی \"DEBUG\"، آدرس‌ها باید تغییر کنند، در حالی که با تغییر به "
"تنظیم \"RELEASE\" ثابت می‌مانند:"

#: src/borrowing/shared.md
msgid ""
"The Rust compiler can do automatic inlining, that can be disabled on a "
"function level with `#[inline(never)]`."
msgstr ""
"کامپایلر Rust می‌تواند به‌طور خودکار درون‌ریزی (inlining) انجام دهد، که می‌تواند "
"در سطح تابع با `[inline(never)]#` غیرفعال شود."

#: src/borrowing/shared.md
msgid ""
"Once disabled, the printed address will change on all optimization levels. "
"Looking at Godbolt or Playground, one can see that in this case, the return "
"of the value depends on the ABI, e.g. on amd64 the two i32 that is making up "
"the point will be returned in 2 registers (eax and edx)."
msgstr ""
"پس از غیرفعال کردن درون‌ریزی، آدرس‌های چاپ شده در تمامی سطوح بهینه‌سازی تغییر "
"خواهند کرد. با نگاه کردن به Godbolt یا Playground، می‌توان دید که در این "
"حالت، بازگشت مقدار به ABI بستگی دارد، به عنوان مثال در amd64، دو `i32` که "
"نقطه را تشکیل می‌دهند، در دو رجیستر (مانند `eax` و `edx`) بازگردانده خواهند "
"شد."

#: src/borrowing/borrowck.md
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr ""
"_بررسی‌کننده ارجاع_ (borrow checker) در Rust محدودیت‌هایی بر روی روش‌های ارجاع "
"به مقادیر اعمال می‌کند. برای یک مقدار خاص، در هر زمان:"

#: src/borrowing/borrowck.md
msgid "You can have one or more shared references to the value, _or_"
msgstr "شما می‌توانید یک یا چند ارجاع اشتراکی به مقدار داشته باشید، _یا_"

#: src/borrowing/borrowck.md
msgid "You can have exactly one exclusive reference to the value."
msgstr "می‌توانید دقیقاً یک ارجاع انحصاری به مقدار داشته باشید."

#: src/borrowing/borrowck.md
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""
"توجه داشته باشید که نیاز این است که ارجاعات متضاد در همان نقطه _وجود_ نداشته "
"باشند. مهم نیست که ارجاع در کجا dereferenced شود."

#: src/borrowing/borrowck.md
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"کد بالا کامپایل نمی‌شود زیرا `a` به‌طور همزمان به‌صورت قابل تغییر (از طریق `c`) "
"و غیرقابل تغییر (از طریق `b`) ارجاع داده شده است."

#: src/borrowing/borrowck.md
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"برای اینکه کد کامپایل شود، دستور `!println` مربوط به `b` را قبل از محدوده‌ای "
"که `c` را معرفی می‌کند، منتقل کنید."

#: src/borrowing/borrowck.md
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"پس از آن تغییر، کامپایلر متوجه می‌شود که `b` تنها پیش از ارجاع جدید قابل "
"تغییر به `a` از طریق `c` استفاده می‌شود. این ویژگی بررسی‌کننده ارجاع به نام "
"non-lexical lifetimes است."

#: src/borrowing/borrowck.md
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""
"محدودیت ارجاع انحصاری بسیار قوی است. Rust از آن برای اطمینان از عدم وقوع "
"داده‌های رقابتی (data races) استفاده می‌کند. Rust همچنین _متکی_ به این محدودیت "
"برای بهینه‌سازی کد است. به عنوان مثال، مقدار پشت یک ارجاع اشتراکی می‌تواند "
"به‌طور ایمن در یک رجیستر برای طول عمر آن ارجاع کش شود."

#: src/borrowing/borrowck.md
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""
"بررسی‌کننده ارجاع به‌گونه‌ای طراحی شده است که بسیاری از الگوهای رایج را "
"پشتیبانی کند، مانند گرفتن ارجاعات انحصاری به فیلدهای مختلف در یک ساختار "
"به‌طور همزمان. اما، در برخی موقعیت‌ها، ممکن است که به‌طور کامل متوجه وضعیت نشود "
"و این اغلب منجر به \"درگیری با borrow checker\" می‌شود."

#: src/borrowing/examples.md
msgid ""
"As a concrete example of how these borrowing rules prevent memory errors, "
"consider the case of modifying a collection while there are references to "
"its elements:"
msgstr ""
"به عنوان یک مثال ملموس از چگونگی جلوگیری از خطاهای حافظه توسط این قوانین "
"ارجاع، به حالت تغییر یک مجموعه در حالی که ارجاعاتی به عناصر آن وجود دارد، "
"توجه کنید:"

#: src/borrowing/examples.md
msgid "\"{elem}\""
msgstr "\"{elem}\""

#: src/borrowing/examples.md
msgid "Similarly, consider the case of iterator invalidation:"
msgstr "به طور مشابه، به وضعیت نامعتبر شدن تکرارگر (iterator) توجه کنید:"

#: src/borrowing/examples.md
msgid ""
"In both of these cases, modifying the collection by pushing new elements "
"into it can potentially invalidate existing references to the collection's "
"elements if the collection has to reallocate."
msgstr ""
"در هر دو مورد، تغییر مجموعه با اضافه کردن عناصر جدید به آن می‌تواند به‌طور "
"بالقوه ارجاعات موجود به عناصر مجموعه را نامعتبر کند، اگر مجموعه نیاز به "
"تخصیص مجدد حافظه داشته باشد."

#: src/borrowing/interior-mutability.md
msgid ""
"In some situations, it's necessary to modify data behind a shared (read-"
"only) reference. For example, a shared data structure might have an internal "
"cache, and wish to update that cache from read-only methods."
msgstr ""
"در برخی موقعیت‌ها، لازم است که داده‌های پشت یک ارجاع اشتراکی (فقط خواندنی) را "
"تغییر دهید. به عنوان مثال، یک ساختار داده اشتراکی ممکن است دارای یک کش داخلی "
"باشد و بخواهد این کش را از روش‌های خواندنی به‌روزرسانی کند."

#: src/borrowing/interior-mutability.md
msgid ""
"The \"interior mutability\" pattern allows exclusive (mutable) access behind "
"a shared reference. The standard library provides several ways to do this, "
"all while still ensuring safety, typically by performing a runtime check."
msgstr ""
"الگوی \"تغییرپذیری داخلی\" (interior mutability) اجازه می‌دهد که دسترسی "
"انحصاری (قابل تغییر) پشت یک ارجاع اشتراکی وجود داشته باشد. کتابخانه "
"استاندارد روش‌های متعددی برای انجام این کار فراهم می‌کند، در حالی که همچنان "
"ایمنی را تضمین می‌کند، معمولاً با انجام یک بررسی در زمان اجرا."

#: src/borrowing/interior-mutability.md
msgid "`Cell`"
msgstr "`Cell`"

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"`Cell` wraps a value and allows getting or setting the value using only a "
"shared reference to the `Cell`. However, it does not allow any references to "
"the inner value. Since there are no references, borrowing rules cannot be "
"broken."
msgstr ""
"`Cell` یک مقدار را در بر می‌گیرد و امکان دریافت یا تنظیم مقدار را حتی با یک "
"ارجاع اشتراکی به `Cell` فراهم می‌کند. با این حال، `Cell` اجازه نمی‌دهد که به "
"مقدار ارجاع داده شود. از آنجا که هیچ ارجاعی وجود ندارد، قوانین ارجاع "
"نمی‌توانند نقض شوند."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "// Note that `cell` is NOT declared as mutable.\n"
msgstr "// Note that `cell` is NOT declared as mutable.\n"

#: src/borrowing/interior-mutability.md
msgid "`RefCell`"
msgstr "`RefCell`"

#: src/borrowing/interior-mutability.md
msgid ""
"`RefCell` allows accessing and mutating a wrapped value by providing "
"alternative types `Ref` and `RefMut` that emulate `&T`/`&mut T` without "
"actually being Rust references."
msgstr ""

#: src/borrowing/interior-mutability.md
msgid ""
"These types perform dynamic checks using a counter in the `RefCell` to "
"prevent existence of a `RefMut` alongside another `Ref`/`RefMut`."
msgstr ""
"این type با استفاده از یک شمارنده در `RefCell` بررسی‌های dynamic را انجام "
"می‌دهند تا از وجود `RefMut` در کنار `Ref`/`RefMut` دیگر جلوگیری کنند."

#: src/borrowing/interior-mutability.md
msgid ""
"By implementing `Deref` (and `DerefMut` for `RefMut`), these types allow "
"calling methods on the inner value without allowing references to escape."
msgstr ""
"با پیاده‌سازی `Deref` (و `DerefMut` برای `RefMut`)، این تایپ‌ها امکان فراخوانی "
"متدها روی مقدار داخلی را بدون اجازه خروج ارجاع‌ها فراهم می‌کنند."

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"// This triggers an error at runtime.\n"
"        // let other = cell.borrow();\n"
"        // println!(\"{}\", *other);\n"
msgstr ""
"// This triggers an error at runtime.\n"
"        // let other = cell.borrow();\n"
"        // println!(\"{}\", *other);\n"

#: src/borrowing/interior-mutability.md
msgid "\"{cell:?}\""
msgstr "\"{cell:?}\""

#: src/borrowing/interior-mutability.md
msgid ""
"The main thing to take away from this slide is that Rust provides _safe_ "
"ways to modify data behind a shared reference. There are a variety of ways "
"to ensure that safety, and `RefCell` and `Cell` are two of them."
msgstr ""
"مهم‌ترین نکته‌ای که باید از این اسلاید برداشت کرد این است که Rust روش‌های "
"_ایمن_ برای تغییر داده‌های پشت یک ارجاع اشتراکی ارائه می‌دهد. راه‌های مختلفی "
"برای تضمین این ایمنی وجود دارد، و `RefCell` و `Cell` دو مورد از آن‌ها هستند."

#: src/borrowing/interior-mutability.md
msgid ""
"`RefCell` enforces Rust's usual borrowing rules (either multiple shared "
"references or a single exclusive reference) with a runtime check. In this "
"case, all borrows are very short and never overlap, so the checks always "
"succeed."
msgstr ""
"`RefCell` قوانین معمول ارجاع Rust (یا چندین ارجاع اشتراکی یا یک ارجاع "
"انحصاری) را با یک بررسی در زمان اجرا اعمال می‌کند. در این حالت، همه ارجاعات "
"بسیار کوتاه هستند و هرگز هم‌پوشانی ندارند، بنابراین بررسی‌ها همیشه موفقیت‌آمیز "
"هستند."

#: src/borrowing/interior-mutability.md
msgid ""
"The extra block in the `RefCell` example is to end the borrow created by the "
"call to `borrow_mut` before we print the cell. Trying to print a borrowed "
"`RefCell` just shows the message `\"{borrowed}\"`."
msgstr ""
"بلوک اضافی در مثال `RefCell` برای پایان دادن به ارجاعی که توسط فراخوانی "
"`borrow_mut` ایجاد شده است، قبل از چاپ `cell` است. تلاش برای چاپ یک "
"`RefCell` که در حال حاضر ارجاع داده شده است، فقط پیغام `\"{borrowed}\"` را "
"نشان می‌دهد."

#: src/borrowing/interior-mutability.md
msgid ""
"`Cell` is a simpler means to ensure safety: it has a `set` method that takes "
"`&self`. This needs no runtime check, but requires moving values, which can "
"have its own cost."
msgstr ""
"`Cell` یک روش ساده‌تر برای تضمین ایمنی است: این نوع دارای متدی به نام `set` "
"است که `self&` را می‌پذیرد. این روش نیاز به بررسی در زمان اجرا ندارد، اما "
"نیاز به انتقال مقادیر دارد که می‌تواند هزینه‌های خود را داشته باشد."

#: src/borrowing/interior-mutability.md
msgid ""
"Both `RefCell` and `Cell` are `!Sync`, which means `&RefCell` and `&Cell` "
"can't be passed between threads. This prevents two threads trying to access "
"the cell at once."
msgstr ""
"هر دو `RefCell` و `Cell` دارای `!Sync` هستند، به این معنی که `RefCell&` و "
"`&Cell` نمی‌توانند بین نخ‌ها منتقل شوند. این امر مانع از دسترسی همزمان دو نخ "
"به سلول می‌شود."

#: src/borrowing/exercise.md
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"شما در حال پیاده‌سازی یک سیستم پایش سلامت هستید. به عنوان بخشی از این کار، "
"نیاز دارید تا آمار سلامت کاربران را دنبال کنید."

#: src/borrowing/exercise.md
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"شما با یک تابع ابتدایی در بلوک `impl` و همچنین یک تعریف `struct` به نام "
"`User` شروع خواهید کرد. هدف شما پیاده‌سازی متد ابتدایی در `struct` `User` است "
"که در بلوک `impl` تعریف شده است."

#: src/borrowing/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr ""
"کد زیر را به <https://play.rust-lang.org/> کپی کنید و متد‌های ناقص را تکمیل "
"کنید:"

#: src/borrowing/exercise.md
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr "\"به‌روزرسانی آمار یک کاربر بر اساس اندازه‌گیری معبار بازدید از پزشک\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#: src/android/build-rules/library.md
#: src/android/aidl/example-service/client.md
msgid "\"Bob\""
msgstr "\"Bob\""

#: src/borrowing/exercise.md src/borrowing/solution.md
msgid "\"I'm {} and my age is {}\""
msgstr "\"من {} هستم و سن من {} است\""

#: src/lifetimes/lifetime-annotations.md
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""
"یک مرجع دارای _طول عمر_ است که نباید از ارزش مورد اشاره بیشتر باشد. این "
"موضوع توسط بررسی‌کننده قرض‌ها تایید می‌شود."

#: src/lifetimes/lifetime-annotations.md
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""
"طول عمر می‌تواند ضمنی باشد - این همان چیزی است که تا کنون مشاهده کرده‌ایم. طول "
"عمرها می‌توانند صریح نیز باشند: `&'a Point`، `&'document str`. طول عمرها با "
"`'` شروع می‌شوند و `'a` نام پیش‌فرض معمولی است. `&'a Point` را به عنوان \"یک "
"`Point` قرضی که برای حداقل طول عمر `a` معتبر است\" بخوانید."

#: src/lifetimes/lifetime-annotations.md
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr ""
"طول عمرها همیشه توسط کامپایلر استنتاج می‌شوند: شما نمی‌توانید به طور دستی طول "
"عمر را اختصاص دهید. انتساب‌های صریح طول عمر محدودیت‌هایی ایجاد می‌کنند که در "
"صورت وجود ابهام است؛ کامپایلر تأیید می‌کند که یک راه‌حل معتبر وجود دارد."

#: src/lifetimes/lifetime-annotations.md
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr ""
"طول عمرها وقتی که به عبور مقادیر به توابع و بازگشت مقادیر از توابع می‌پردازیم "
"پیچیده‌تر می‌شوند."

#: src/lifetimes/lifetime-annotations.md
#, fuzzy
msgid "// What is the lifetime of p3?\n"
msgstr "// What is the lifetime of p3?\n"

#: src/lifetimes/lifetime-annotations.md
msgid "\"p3: {p3:?}\""
msgstr "\"p3: {p3:?}\""

#: src/lifetimes/lifetime-annotations.md
msgid ""
"In this example, the compiler does not know what lifetime to infer for `p3`. "
"Looking inside the function body shows that it can only safely assume that "
"`p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, Rust "
"requires explicit annotations of lifetimes on function arguments and return "
"values."
msgstr ""
"در این مثال، کامپایلر نمی‌داند که طول عمر `p3` را چگونه استنباط کند. نگاه "
"کردن به بدنه تابع نشان می‌دهد که تنها به‌طور ایمن می‌تواند فرض کند که طول عمر "
"`p3` کوتاه‌تر از `p1` و `p2` است. اما مانند تایپ‌ها، راست نیاز به توضیحات صریح "
"طول عمرها در آرگومان‌های تابع و مقادیر بازگشتی دارد."

#: src/lifetimes/lifetime-annotations.md
msgid "Add `'a` appropriately to `left_most`:"
msgstr "به تابع `left_most` به صورت مناسب `'a` را اضافه کنید:"

#: src/lifetimes/lifetime-annotations.md
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""
"این به این معناست که \"با توجه به اینکه `p1` و `p2` هر دو از `'a` بیشتر عمر "
"می‌کنند، مقدار بازگشتی برای مدت `'a` معتبر خواهد بود."

#: src/lifetimes/lifetime-annotations.md
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr ""
"در موارد معمول، عمر متغیرها می‌تواند نادیده گرفته شود، همانطور که در اسلاید "
"بعدی توضیح داده شده است."

#: src/lifetimes/lifetime-elision.md
msgid "Lifetimes in Function Calls"
msgstr "طول عمر در فراخوانی‌ توابع"

#: src/lifetimes/lifetime-elision.md
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"عمرهای مربوط به آرگومان‌های تابع و مقادیر بازگشتی باید به طور کامل مشخص شوند، "
"اما Rust اجازه می‌دهد عمرها در بیشتر موارد با [چند قانون ساده](https://doc."
"rust-lang.org/nomicon/lifetime-elision.html) نادیده گرفته شوند. این مسئله "
"استنتاج نیست -- بلکه تنها یک اصطلاح نوشتاری کوتاه است."

#: src/lifetimes/lifetime-elision.md
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr ""
"هر آرگومان که فاقد یک lifetime annotation است، یک عمر به آن اختصاص داده "
"می‌شود."

#: src/lifetimes/lifetime-elision.md
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr ""
"اگر تنها یک عمر برای آرگومان وجود داشته باشد، به تمام مقادیر بازگشتی که "
"حاشیه‌نویسی نشده‌اند، اختصاص داده می‌شود."

#: src/lifetimes/lifetime-elision.md
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""
"اگر چندین عمر آرگومان وجود داشته باشد و اولین آن برای `self` باشد، آن عمر به "
"تمام مقادیر بازگشتی که حاشیه‌نویسی نشده‌اند، اختصاص داده می‌شود."

#: src/lifetimes/lifetime-elision.md
msgid "In this example, `cab_distance` is trivially elided."
msgstr "در این مثال، `cab_distance` به طور خودکار حذف می‌شود."

#: src/lifetimes/lifetime-elision.md
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""
"تابع `nearest` مثال دیگری از تابعی است که با ارجاعات متعدد در آرگومان‌هایش "
"نیاز به حاشیه‌نویسی صریح دارد."

#: src/lifetimes/lifetime-elision.md
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr ""
"امضا را طوری تنظیم کنید که \"دروغ\" بگوید درباره طول عمر مقادیری که برگشت "
"داده می‌شوند:"

#: src/lifetimes/lifetime-elision.md
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""
"این کد کامپایل نخواهد شد، که نشان‌دهنده این است که برچسب‌های طول عمر توسط "
"کامپایلر برای اعتبارسنجی بررسی می‌شوند. توجه داشته باشید که این وضعیت برای "
"اشاره‌گرهای خام (ناامن) صدق نمی‌کند و این یکی از منابع رایج خطاها در Rust "
"ناامن است."

#: src/lifetimes/lifetime-elision.md
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""
"دانش‌آموزان ممکن است بپرسند که چه زمانی باید از طول عمرها استفاده کرد. در "
"Rust، _همیشه_ برای قرض‌ها طول عمر وجود دارد. بیشتر مواقع، حذف و استنباط تایپ "
"به این معنی است که نیازی به نوشتن این طول عمرها نیست. در موارد پیچیده‌تر، "
"برچسب‌های طول عمر می‌توانند به حل ابهام کمک کنند. اغلب، به‌ویژه در هنگام "
"پروتوتایپ‌سازی، راحت‌تر است که با داده‌های مالکیت‌شده کار کنید و مقادیر را در "
"صورت لزوم کلون کنید."

#: src/lifetimes/struct-lifetimes.md
msgid "Lifetimes in Data Structures"
msgstr "Lifetimes in Data Structures"

#: src/lifetimes/struct-lifetimes.md
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"اگر یک تایپ داده داده‌های قرضی را ذخیره کند، باید با یک طول عمر مشخص شود:"

#: src/lifetimes/struct-lifetimes.md
msgid "\"Bye {text}!\""
msgstr "\"Bye {text}!\""

#: src/lifetimes/struct-lifetimes.md
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr "\"The quick brown fox jumps over the lazy dog.\""

#: src/lifetimes/struct-lifetimes.md
#, fuzzy
msgid "// erase(text);\n"
msgstr "// erase(text);\n"

#: src/lifetimes/struct-lifetimes.md
msgid "\"{fox:?}\""
msgstr "\"{fox:?}\""

#: src/lifetimes/struct-lifetimes.md
msgid "\"{dog:?}\""
msgstr "\"{dog:?}\""

#: src/lifetimes/struct-lifetimes.md
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"در مثال بالا، حاشیه‌نویسی بر روی `Highlight` تضمین می‌کند که داده‌های زیرین "
"`str&` به مدت حداقل برابر با هر نمونه از `Highlight` که از آن داده استفاده "
"می‌کند، زنده بماند."

#: src/lifetimes/struct-lifetimes.md
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"اگر `text` قبل از پایان عمر `fox` (یا `dog`) مصرف شود، بررسی‌کننده‌ی قرض "
"(borrow checker) خطا می‌دهد."

#: src/lifetimes/struct-lifetimes.md
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"تایپ‌های دارای داده‌های قرضی (borrowed data) کاربران را مجبور می‌کنند تا "
"داده‌های اصلی را نگه دارند. این می‌تواند برای ایجاد نمایه‌های سبک مفید باشد، "
"اما معمولاً استفاده از آنها را تا حدی دشوارتر می‌کند."

#: src/lifetimes/struct-lifetimes.md
msgid "When possible, make data structures own their data directly."
msgstr "در صورت امکان، داده‌های ساختارها را به طور مستقیم مالکیت کنید."

#: src/lifetimes/struct-lifetimes.md
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"برخی از ساختارهای داده که شامل چندین ارجاع هستند، ممکن است نیاز به چندین "
"نشانه‌گذاری عمر داشته باشند. این امر می‌تواند ضروری باشد اگر بخواهید روابط "
"عمری بین ارجاعات مختلف را به علاوه عمر ساختار خود توصیف کنید. این موارد "
"بسیار پیشرفته هستند."

#: src/lifetimes/exercise.md
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""
"در این تمرین، شما یک تجزیه‌کننده برای [رمزگذاری باینری پروتوباف](https://"
"protobuf.dev/programming-guides/encoding/) خواهید ساخت. نگران نباشید، این "
"کار ساده‌تر از آن است که به نظر می‌رسد! این الگو نشان‌دهنده یک الگوی رایج در "
"تجزیه داده‌ها است که شامل عبور برش‌های داده است. داده‌های اصلی هرگز کپی نمی‌شوند."

#: src/lifetimes/exercise.md
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""
"تجزیه کامل یک پیام پروتوباف نیاز به دانستن تایپ‌های این فیلدها دارد که بر "
"اساس شماره‌های فیلد ایندکس شده‌اند. این اطلاعات معمولاً در یک فایل `proto` "
"ارائه می‌شود. در این تمرین، ما این اطلاعات را به صورت عبارات `match` در "
"توابعی که برای هر فیلد فراخوانی می‌شوند، کدگذاری خواهیم کرد."

#: src/lifetimes/exercise.md
msgid "We'll use the following proto:"
msgstr "ما از پروتوباف زیر استفاده خواهیم کرد:"

#: src/lifetimes/exercise.md
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""
"یک پیام پروتوباف به عنوان مجموعه‌ای از فیلدها، یکی پس از دیگری، کدگذاری "
"می‌شود. هر فیلد به صورت یک \"تگ\" به همراه مقدار آن پیاده‌سازی شده است. تگ "
"شامل شماره فیلد (مانند `2` برای فیلد `id` در پیام `Person`) و wire type است "
"که نحوه تعیین بار را از جریان بایت مشخص می‌کند."

#: src/lifetimes/exercise.md
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""
"اعداد، از جمله تگ، با استفاده از کدگذاری با طول متغیر به نام VARINT نمایندگی "
"می‌شوند. خوشبختانه، تابع `parse_varint` برای شما تعریف شده است. کد داده شده "
"همچنین بازخوانی‌هایی برای مدیریت فیلدهای `Person` و `PhoneNumber` و تجزیه یک "
"پیام به مجموعه‌ای از فراخوانی‌ها به آن بازخوانی‌ها را تعریف می‌کند."

#: src/lifetimes/exercise.md
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""
"برای شما باقی‌مانده است که تابع `parse_field` و ویژگی `ProtoMessage` را برای "
"`Person` و `PhoneNumber` پیاده‌سازی کنید."

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A wire type as seen on the wire.\n"
msgstr "/// A wire type as seen on the wire.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr "/// The Varint WireType indicates the value is a single VARINT.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// The I64 WireType indicates that the value is precisely 8 bytes in\n"
"    /// little-endian order containing a 64-bit signed integer or double "
"type.\n"
"    //I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""
"/// The I64 WireType indicates that the value is precisely 8 bytes in\n"
"    /// little-endian order containing a 64-bit signed integer or double "
"type.\n"
"    //I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    // little-endian order containing a 32-bit signed integer or float "
"type.\n"
"    //I32,  -- not needed for this exercise\n"
msgstr ""
"// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    // little-endian order containing a 32-bit signed integer or float "
"type.\n"
"    //I32,  -- not needed for this exercise\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A field's value, typed based on the wire type.\n"
msgstr "/// A field's value, typed based on the wire type.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr "//I64(i64),  -- not needed for this exercise\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//I32(i32),  -- not needed for this exercise\n"
msgstr "//I32(i32),  -- not needed for this exercise\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// A field, containing the field number and its value.\n"
msgstr "/// A field, containing the field number and its value.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr "//1 => WireType::I64,  -- not needed for this exercise\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "//5 => WireType::I32,  -- not needed for this exercise\n"
msgstr "//5 => WireType::I32,  -- not needed for this exercise\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Invalid wire type: {value}\""
msgstr "\"نوع سیم نامعتبر: {value}\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Expected string to be a `Len` field\""
msgstr "\"انتظار می‌رود که رشته یک فیلد Len باشد\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Invalid string\""
msgstr "\"نامعتبر string\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Expected bytes to be a `Len` field\""
msgstr "\"بایت‌های مورد انتظار یک فیلد `Len` باشند\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Expected `u64` to be a `Varint` field\""
msgstr "\"انتظار می‌رود `u64` یک فیلد `Varint` باشد\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Not enough bytes for varint\""
msgstr "\"بایت کافی برای varint نیست\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "// More than 7 bytes is invalid.\n"
msgstr "// More than 7 bytes is invalid.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
msgid "\"Too many bytes for varint\""
msgstr "\"تعداد بایت‌های زیادی برای varint\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr "/// Convert a tag into a field number and a WireType.\n"

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr "/// Parse a field, returning the remaining bytes\n"

#: src/lifetimes/exercise.md
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""
"\"بر اساس نوع سیم، یک فیلد بسازید، با مصرف هر تعداد بایت که لازم است.\""

#: src/lifetimes/exercise.md
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr "\"فیلد و هر بایت مصرف نشده را برگردانید.\""

#: src/lifetimes/exercise.md src/lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"

#: src/lifetimes/exercise.md
#, fuzzy
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"

#: src/lifetimes/exercise.md
msgid ""
"In this exercise there are various cases where protobuf parsing might fail, "
"e.g. if you try to parse an `i32` when there are fewer than 4 bytes left in "
"the data buffer. In normal Rust code we'd handle this with the `Result` "
"enum, but for simplicity in this exercise we panic if any errors are "
"encountered. On day 4 we'll cover error handling in Rust in more detail."
msgstr ""
"در این تمرین موارد مختلفی وجود دارد که ممکن است تجزیه protobuf با شکست مواجه "
"شود، مثلاً اگر بخواهید یک `i32` را هنگامی که کمتر از ۴ بایت در بافر داده "
"باقی‌مانده است، تجزیه کنید. در کد Rust معمولاً این را با استفاده از `Result` "
"مدیریت می‌کنیم، اما برای سادگی در این تمرین، اگر با هرگونه خطا مواجه شویم، به "
"جای آن که با `Result` برخورد کنیم، برنامه را متوقف خواهیم کرد. در روز چهارم، "
"به بررسی دقیق‌تر مدیریت خطا در Rust خواهیم پرداخت."

#: src/lifetimes/solution.md
msgid "\"len not a valid `usize`\""
msgstr "\"استفاده از len در `usize` معتبر نیست\""

#: src/lifetimes/solution.md
msgid "\"Unexpected EOF\""
msgstr "\"EOF غیر منتظره\""

#: src/lifetimes/solution.md
#, fuzzy
msgid "// skip everything else\n"
msgstr "// skip everything else\n"

#: src/lifetimes/solution.md src/modules/exercise.md src/modules/solution.md
#: src/testing/unit-tests.md src/testing/solution.md
msgid "\"\""
msgstr "\".\""

#: src/lifetimes/solution.md
#, fuzzy
msgid "\"beautiful name\""
msgstr "\"سلام {name}\""

#: src/lifetimes/solution.md
msgid "\"Evan\""
msgstr "\"Evan\""

#: src/lifetimes/solution.md
msgid "\"+1234-777-9090\""
msgstr "\"+1234-777-9090\""

#: src/lifetimes/solution.md
msgid "\"home\""
msgstr "\"خانه\""

#: src/welcome-day-4.md
#, fuzzy
msgid "Welcome to Day 4"
msgstr "به روز ۱ خوش آمدید"

#: src/welcome-day-4.md
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr ""
"امروز ما موضوعات مربوط به ساخت نرم افزار در مقیاس بزرگ در Rust را پوشش "
"خواهیم داد:"

#: src/welcome-day-4.md
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr "Iterators: شیرجه عمیق در ویژگی `Iterator`."

#: src/welcome-day-4.md
msgid "Modules and visibility."
msgstr "ماژول ها و قابلیت مشاهده."

#: src/welcome-day-4.md
msgid "Testing."
msgstr "تست‌کردن."

#: src/welcome-day-4.md
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "رسیدگی به خطا: panics در `Result` و اپراتور تلاش مجدد `?`."

#: src/welcome-day-4.md
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr ""
"با Unsafe Rust: پنجره فرار مبتنی بر زمان که نمی‌توانید خود را در safe Rust "
"بیان کنید."

#: src/welcome-day-4.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 40 "
"minutes. It contains:"
msgstr ""
"با احتساب ۱۰ دقیقه استراحت، این جلسه باید حدود ۲ ساعت و ۴۰ دقیقه طول بکشد. "
"شامل:"

#: src/iterators.md
msgid "Iterator"
msgstr "Iterator"

#: src/iterators.md
msgid "IntoIterator"
msgstr "IntoIterator"

#: src/iterators.md src/iterators/fromiterator.md
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/iterator.md
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""
"ویژگی ['Iterator'](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"از تکرار بیش از مقادیر در یک مجموعه پشتیبانی می‌کند. این به یک متد `next` "
"نیاز دارد و متدهای زیادی را ارائه می‌کند. بسیاری از انواع کتابخانه استاندارد "
"`Iterator`  را پیاده‌سازی می‌کنند و شما نیز می‌توانید آن را خودتان پیاده‌سازی "
"کنید:"

#: src/iterators/iterator.md
msgid "\"fib({i}): {n}\""
msgstr "\"fib({i}): {n}\""

#: src/iterators/iterator.md
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"ویژگی `Iterator` بسیاری از عملیات برنامه‌نویسی تابعی رایج را روی collectionها "
"پیاده‌سازی می‌کند (مانند `map`, `filter`, `reduce`,و غیره). این ویژگی است که "
"در آن می‌توانید تمام اسناد مربوط به آنها را پیدا کنید. در Rust، این توابع "
"باید کد را به اندازه پیاده‌سازی‌های ضروری معادل تولید کنند."

#: src/iterators/iterator.md
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` ویژگی است که باعث می‌شود حلقه‌ها کار کنند. این مجموعه "
"(collection) توسط تایپ‌های مجموعه مانند  `Vec<T>` و ارجاعاتی به آنها مانند  "
"`&Vec<T>` و  `&[T]` پیاده‌سازی می‌شود. Ranges نیز آن ‌هارا اجرا می‌کند. به همین "
"دلیل است که می‌توانید روی یک بردار با `برای i در some_vec { .. }` تکرار کنید، "
"اما  درنهایت `some_vec.next()`وجود ندارد."

#: src/iterators/intoiterator.md
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"ویژگی `Iterator` به شما می‌گوید که چگونه پس از ایجاد یک تکرار کننده، "
"_iterate_ کنید. ویژگی مرتبط [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) نحوه ایجاد یک تکرار کننده برای یک نوع را مشخص "
"می‌کند. به طور خودکار توسط حلقه `for` استفاده می‌شود."

#: src/iterators/intoiterator.md
msgid "\"point = {x}, {y}\""
msgstr "\"point = {x}, {y}\""

#: src/iterators/intoiterator.md
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr ""
"روی مستندات`IntoIterator` کلیک کنید. هر پیاده‌سازی `IntoIterator` باید دو نوع "
"را اعلام کند:"

#: src/iterators/intoiterator.md
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "ء `Item`: نوعی که باید تکرار شود، مانند `i8`،"

#: src/iterators/intoiterator.md
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"`IntoIter`: یک «Iterator» تایپ است که با متد `into_iter` برگردانده شده است."

#: src/iterators/intoiterator.md
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"توجه داشته باشید که `IntoIter` و`Item` به هم link شده‌اند: تکرار‌کننده "
"(iterator) باید همان `Item` type را داشته باشد، به این معنی که "
"`Option<Item>` را برمی‌گرداند."

#: src/iterators/intoiterator.md
msgid "The example iterates over all combinations of x and y coordinates."
msgstr "مثال روی تمام ترکیبات مختصات x و y تکرار می‌شود."

#: src/iterators/intoiterator.md
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""
"سعی کنید دو بار روی شبکه در `main` تکرار کنید. چرا این گزینه شکست می‌خورد؟ "
"توجه داشته باشید که `IntoIterator::into_iter` مالکیت `self` را می‌گیرد."

#: src/iterators/intoiterator.md
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""
"این مشکل را با اجرای `IntoIterator` برای `&Grid` و ذخیره یک reference به این "
"`Grid` در `GridIter` برطرف کنید."

#: src/iterators/intoiterator.md
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""
"همین مشکل می‌تواند برای انواع کتابخانه استاندارد رخ دهد: `برای e در "
"some_vector` مالکیت `some_vector` را در اختیار می‌گیرد و روی عناصر متعلق به "
"آن بردار تکرار می‌شود. به جای آن از `e در &some_vector` برای تکرار بر روی "
"ارجاعات به عناصر `some_vector` استفاده کنید."

#: src/iterators/fromiterator.md
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"گزینه [`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator."
"html) به شما امکان می دهد از یک [`Iterator`](https://doc.rust-lang .org/std/"
"iter/trait.Iterator.html) یک مجموعه یا collection  بسازید."

#: src/iterators/fromiterator.md
#, fuzzy
msgid "\"prime_squares: {prime_squares:?}\""
msgstr "\"prime_squares: {prime_squares:?}\""

#: src/iterators/fromiterator.md
msgid "`Iterator` implements"
msgstr "پیاده‌سازی `Iterator`"

#: src/iterators/fromiterator.md
msgid "There are two ways to specify `B` for this method:"
msgstr "دو راه برای تعیین`B` برای این روش وجود دارد:"

#: src/iterators/fromiterator.md
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""
"با کمک \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`، همانطور "
"که نشان داده شده است و به طور خلاصه `_` استفاده شده در اینجا به Rust امکان "
"می‌دهد نوع عناصر \"Vec\" را استنتاج کند."

#: src/iterators/fromiterator.md
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""
"با نوع inference:  `let prime_squares: Vec<_> = some_iterator.collect()`. "
"این مثال را برای استفاده از این فرم بازنویسی کنید."

#: src/iterators/fromiterator.md
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"پیاده‌سازی‌های اولیه `FromIterator` برای`Vec`, `HashMap` و غیره وجود دارد. "
"همچنین پیاده‌سازی‌های تخصصی‌تری وجود دارد که به شما امکان می‌دهد کارهای جالبی "
"مانند تبدیل `Iterator<Item = Result<V, E>>` به یک `Result<Vec<V>, E>` انجام "
"دهید."

#: src/iterators/exercise.md
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr ""
"در این تمرین، باید برخی از روش های ارائه شده در [`Iterator`](https://doc."
"rust-lang.org/std/iter/trait.Iterator.html) را برای پیاده‌سازی یک ویژگی پیدا "
"کنید و از آنها برای محاسبه پیچیده استفاده کنید."

#: src/iterators/exercise.md
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"کد زیر را در<https://play.rust-lang.org/> کپی کنید و تست ها را قبول کنید. از "
"یک عبارت تکرارکننده (iterator) استفاده کنید و نتیجه را جمع‌آوری (`collect`) "
"کنید تا مقدار بازگشتی را بسازید."

#: src/iterators/exercise.md src/iterators/solution.md
#, fuzzy
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"

#: src/modules.md src/modules/paths.md
msgid "use, super, self"
msgstr "use, super, self"

#: src/modules/modules.md
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"دیده‌ایم که چگونه بلوک‌های `impl` به ما اجازه می‌دهند تا namespace functions را "
"به یک type تبدیل کنیم."

#: src/modules/modules.md
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr ""
"به طور مشابه، `mod` به ما اجازه می‌دهد تا توابع و namespace type به این صورت "
"داشته باشیم:"

#: src/modules/modules.md
msgid "\"In the foo module\""
msgstr "\"در ماژول foo\""

#: src/modules/modules.md
msgid "\"In the bar module\""
msgstr "\"در ماژول نواری\""

#: src/modules/modules.md
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"بسته‌ها یا Packageهای عملکردی را ارائه می‌کنند و شامل یک فایل`Cargo.toml` "
"می‌شوند که نحوه ساخت بسته‌ای از crateهای 1+ را شرح می‌دهد."

#: src/modules/modules.md
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"در واقع Crateها درختی از ماژول‌ها هستند که در آن یک crate باینری یک فایل "
"اجرایی ایجاد می‌کند و یک crate کتابخانه در یک کتابخانه کامپایل می‌شود."

#: src/modules/modules.md
msgid "Modules define organization, scope, and are the focus of this section."
msgstr "ماژول‌های organization، scope، و تمرکز این بخش را تعریف می‌کنند."

#: src/modules/filesystem.md
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr "حذف محتوای ماژول به Rust می‌گوید که آن را در فایل دیگری جستجو کند:"

#: src/modules/filesystem.md
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"این به rust می‌گوید که محتوای ماژول `garden` در`src/garden.rs`یافت می‌شود. به "
"طور مشابه، ماژول `garden::vegetables` را می‌توان در `src/garden/vegetables."
"rs` یافت."

#: src/modules/filesystem.md
msgid "The `crate` root is in:"
msgstr "ریشه`crate`  در:"

#: src/modules/filesystem.md
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (for a library crate)"

#: src/modules/filesystem.md
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (for a binary crate)"

#: src/modules/filesystem.md
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"ماژول‌های تعریف‌شده در فایل‌ها را نیز می‌توان با استفاده از «کامنت‌های مستند "
"داخلی» مستند کرد. اینها موردی را که حاوی آنها است - در این مورد، یک ماژول "
"مستند می‌کنند."

#: src/modules/filesystem.md
#, fuzzy
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "// Re-export types from this module.\n"
msgstr "// Re-export types from this module.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "/// Sow the given seed packets.\n"
msgstr "/// Sow the given seed packets.\n"

#: src/modules/filesystem.md
#, fuzzy
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr "/// Harvest the produce in the garden that is ready.\n"

#: src/modules/filesystem.md
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"قبل از Rust 2018، ماژول‌ها باید به جای `module.rs` در `module/mod.rs` قرار "
"می‌گرفتند و این هنوز یک جایگزین کارآمد برای نسخه‌های بعد از 2018 است."

#: src/modules/filesystem.md
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"دلیل اصلی معرفی `filename.rs` به‌عنوان جایگزین `filename/mod.rs` این بود که "
"تشخیص بسیاری از فایل‌ها با نام `mod.rs` در IDE‌ها دشوار است."

#: src/modules/filesystem.md
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"لانه‌گزینی(nesting) عمیق‌تر می‌تواند از folderها استفاده کند، حتی اگر ماژول "
"اصلی یک فایل باشد:"

#: src/modules/filesystem.md
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""
"مکانی که rust به دنبال ماژول‌ها می‌گردد را می‌توان با دستور کامپایلر تغییر داد:"

#: src/modules/filesystem.md
msgid "\"some/path.rs\""
msgstr "\"some/path.rs\""

#: src/modules/filesystem.md
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"برای مثال، اگر می‌خواهید تست‌هایی را برای یک ماژول در فایلی به نام "
"`some_module_test.rs` قرار دهید، مفید است، شبیه به قرارداد (convention) در "
"Go."

#: src/modules/visibility.md
msgid "Modules are a privacy boundary:"
msgstr "ماژول‌ها یک مرز حریم خصوصی هستند:"

#: src/modules/visibility.md
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"گزینه‌های ماژول به طور پیش‌فرض private هستند (جزئیات پیاده سازی را پنهان "
"می‌کند)."

#: src/modules/visibility.md
msgid "Parent and sibling items are always visible."
msgstr "کزینه‌های sibling و sibling همیشه قابل مشاهده است."

#: src/modules/visibility.md
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"به عبارت دیگر، اگر یک مورد در ماژول `foo` قابل مشاهده باشد، در همه "
"فرزندان`foo` قابل مشاهده است."

#: src/modules/visibility.md
msgid "\"outer::private\""
msgstr "\"outer::private\""

#: src/modules/visibility.md
msgid "\"outer::public\""
msgstr "\"outer::public\""

#: src/modules/visibility.md
msgid "\"outer::inner::private\""
msgstr "\"outer::inner::private\""

#: src/modules/visibility.md
msgid "\"outer::inner::public\""
msgstr "\"outer::inner::public\""

#: src/modules/visibility.md
msgid "Use the `pub` keyword to make modules public."
msgstr "از کلمه کلیدی `pub` برای public کردن ماژول‌ها استفاده کنید."

#: src/modules/visibility.md
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"علاوه بر این، مشخص‌کننده‌های پیشرفته `pub(...)` برای محدود کردن دامنه دید "
"عمومی وجود دارد."

#: src/modules/visibility.md
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"این آدرس با ببینید [Rust Reference](https://doc.rust-lang.org/reference/"
"visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."

#: src/modules/visibility.md
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "پیکربندی قابل نمایش بودن `pub(crate)` یک الگوی رایج است."

#: src/modules/visibility.md
msgid "Less commonly, you can give visibility to a specific path."
msgstr "این مورد کمتر متداول است، شما می‌توانید به یک مسیر خاص دید بدهید."

#: src/modules/visibility.md
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"در هر صورت، قابلیت دیدن باید به یک ماژول والد (و همه فرزندان آن) داده شود."

#: src/modules/paths.md
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"یک ماژول می‌تواند نمادها را از ماژول دیگری با `use` وارد محدوده کند. شما "
"معمولاً چیزی شبیه به این را در بالای هر ماژول خواهید دید:"

#: src/modules/paths.md
msgid "Paths"
msgstr "مسیر"

#: src/modules/paths.md
msgid "Paths are resolved as follows:"
msgstr "مسیرها (Paths) به شرح زیر حل می‌شوند:"

#: src/modules/paths.md
msgid "As a relative path:"
msgstr "به عنوان یک path نسبی:"

#: src/modules/paths.md
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "در واقع `foo` یا `self::foo` به `foo` در ماژول فعلی اشاره دارد،"

#: src/modules/paths.md
msgid "`super::foo` refers to `foo` in the parent module."
msgstr ""

#: src/modules/paths.md
msgid "As an absolute path:"
msgstr "به عنوان یک path مطلق:"

#: src/modules/paths.md
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` به `foo` در ریشه جعبه فعلی اشاره دارد,"

#: src/modules/paths.md
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "یک `bar::foo` به `foo` در `bar` crate اشاره دارد."

#: src/modules/paths.md
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""
"این\"re-export\" نمادها در مسیر کوتاه‌تری معمول است. برای مثال، `lib.rs` سطح "
"بالا در یک crate ممکن است داشته باشد"

#: src/modules/paths.md
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""
"در دسترس قرار دادن `DiskStorage` و `NetworkStorage` برای سایر  crateها با یک "
"مسیر راحت و کوتاه."

#: src/modules/paths.md
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""
"در بیشتر موارد، فقط مواردی که در یک ماژول ظاهر می‌شوند باید `use` شوند. با‌ "
"این‌حال، یک ویژگی (trait) باید در محدوده باشد تا بتوان هر method ای را روی آن "
"ویژگی فراخوانی کرد، حتی اگر نوعی که آن ویژگی را اجرا می کند قبلاً در محدوده "
"باشد. به عنوان مثال، برای استفاده از متد `read_to_string` در نوعی که ویژگی "
"`Read` را اجرا می‌کند، باید از `use std::io::Read` استفاده کنید."

#: src/modules/paths.md
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""
"عبارت `use` می‌تواند دارای علامت عام باشد:  `use std::io::*`. از این کار منع "
"شده است زیرا مشخص نیست کدام موارد import می‌شوند و ممکن است در طول زمان تغییر "
"کنند."

#: src/modules/exercise.md
msgid ""
"In this exercise, you will reorganize a small GUI Library implementation. "
"This library defines a `Widget` trait and a few implementations of that "
"trait, as well as a `main` function."
msgstr ""
"در این تمرین، یک پیاده‌سازی کتابخانه GUI کوچک را دوباره سازماندهی خواهید کرد. "
"این کتابخانه یک ویژگی`Widget` و چند پیاده‌سازی از آن ویژگی و همچنین یک تابع "
"`main` را تعریف می‌کند."

#: src/modules/exercise.md
msgid ""
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""
"معمول است که هر نوع یا مجموعه‌ای از انواع مرتبط نزدیک را در ماژول خود قرار "
"دهید، بنابراین هر نوع ویجت باید ماژول خاص خود را داشته باشد."

#: src/modules/exercise.md
msgid "Cargo Setup"
msgstr "Cargo Setup"

#: src/modules/exercise.md
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""
"یک Rust playground  فقط از یک فایل پشتیبانی می‌کند، بنابراین باید یک پروژه "
"Cargo را در سیستم فایل محلی خود ایجاد کنید:"

#: src/modules/exercise.md
msgid ""
"Edit the resulting `src/main.rs` to add `mod` statements, and add additional "
"files in the `src` directory."
msgstr ""
"این `src/main.rs` حاصل را ویرایش کنید تا عبارات `mod` را اضافه کنید و "
"فایل‌های اضافی را در دایرکتوری `src` اضافه کنید."

#: src/modules/exercise.md
msgid "Source"
msgstr "منبع"

#: src/modules/exercise.md
msgid "Here's the single-module implementation of the GUI library:"
msgstr "در اینجا اجرای تک ماژول کتابخانه GUI آمده است:"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Natural width of `self`.\n"
msgstr "/// Natural width of `self`.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Draw the widget into a buffer.\n"
msgstr "/// Draw the widget into a buffer.\n"

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "/// Draw the widget on standard output.\n"
msgstr "/// Draw the widget on standard output.\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"{buffer}\""
msgstr "\"{buffer}\""

#: src/modules/exercise.md
#, fuzzy
msgid "// Add 4 paddings for borders\n"
msgstr "// Add 4 paddings for borders\n"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"// TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use "
"the\n"
"        // ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use "
"the\n"
"        // ?-operator here instead of .unwrap().\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+-{:-<inner_width$}-+\""
msgstr "\"+-{:-<inner_width$}-+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"| {:^inner_width$} |\""
msgstr "\"| {:^inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+={:=<inner_width$}=+\""
msgstr "\"+={:=<inner_width$}=+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"| {:inner_width$} |\""
msgstr "\"| {:inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
#, fuzzy
msgid "// add a bit of padding\n"
msgstr "// add a bit of padding\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+{:-<width$}+\""
msgstr "\"+{:-<width$}+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"|{:^width$}|\""
msgstr "\"|{:^width$}|\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"Rust GUI Demo 1.23\""
msgstr "\"Rust GUI Demo 1.23\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"This is a small text GUI demo.\""
msgstr "\"این یک نسخه نمایشی GUI برای متنی کوچک است.\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"Click me!\""
msgstr "\"Click me!\""

#: src/modules/exercise.md
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""
"دانش‌آموزان را تشویق کنید تا کد را به‌گونه‌ای تقسیم کنند که برایشان طبیعی است و "
"به اعلان‌های `mod`, `use` و `pub`عادت کنند. پس از آن، در مورد اینکه چه "
"organizationهایی idiomatic هستند بحث کنید."

#: src/modules/solution.md
msgid "// ---- src/widgets.rs ----\n"
msgstr "// ---- src/widgets.rs ----\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/label.rs ----\n"
msgstr "// ---- src/widgets/label.rs ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Label-width\n"
msgstr "// ANCHOR_END: Label-width\n"

#: src/modules/solution.md
msgid "// ANCHOR: Label-draw_into\n"
msgstr "// ANCHOR: Label-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr "// ANCHOR_END: Label-draw_into\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/button.rs ----\n"
msgstr "// ---- src/widgets/button.rs ----\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Button-width\n"
msgstr "// ANCHOR_END: Button-width\n"

#: src/modules/solution.md
msgid "// ANCHOR: Button-draw_into\n"
msgstr "// ANCHOR: Button-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr "// ANCHOR_END: Button-draw_into\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/window.rs ----\n"
msgstr "// ---- src/widgets/window.rs ----\n"

#: src/modules/solution.md
#, fuzzy
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"

#: src/modules/solution.md
msgid "// ANCHOR: Window-draw_into\n"
msgstr "// ANCHOR: Window-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr "// ANCHOR_END: Window-draw_into\n"

#: src/modules/solution.md
#, fuzzy
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"

#: src/modules/solution.md
msgid "// ---- src/main.rs ----\n"
msgstr "// ---- src/main.rs ----\n"

#: src/testing/unit-tests.md
msgid "Unit Tests"
msgstr "تست‌های واحد (Unit Tests)"

#: src/testing/unit-tests.md
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust and Cargo با یک چارچوب تست واحد ساده ارائه می شود:"

#: src/testing/unit-tests.md
msgid "Unit tests are supported throughout your code."
msgstr ""

#: src/testing/unit-tests.md
msgid "Integration tests are supported via the `tests/` directory."
msgstr "تست‌های یکپارچه‌سازی از طریق دایرکتوری `tests/` پشتیبانی می‌شوند."

#: src/testing/unit-tests.md
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""
"تست‌ها با `#[test]`علامت‌گذاری شده‌اند. تست‌های واحد اغلب در یک ماژول `tests` "
"تودرتو قرار می‌گیرند و از `#[cfg(test)]` استفاده می‌کنند تا آنها را به صورت "
"مشروط تنها در هنگام build تست‌ها کامپایل کنند."

#: src/testing/unit-tests.md
msgid "\"Hello World\""
msgstr "\"سلام دنیا!\""

#: src/testing/unit-tests.md
msgid "This lets you unit test private helpers."
msgstr "این به شما امکان می‌دهد تا private helper را آزمایش کنید."

#: src/testing/unit-tests.md
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"ویژگی  `#[cfg(test)]` تنها زمانی فعال است که `cargo test` را اجرا کنید."

#: src/testing/unit-tests.md
msgid "Run the tests in the playground in order to show their results."
msgstr "تست‌ها را در playground اجرا کنید تا نتیجه‌های آن‌ها را نشان‌دهید."

#: src/testing/other.md
msgid "Integration Tests"
msgstr "Integration Tests"

#: src/testing/other.md
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"اگر می‌خواهید کتابخانه خود را به عنوان یک سرویس‌گیرنده آزمایش کنید، از تست "
"یکپارچه‌سازی (integration test) استفاده کنید."

#: src/testing/other.md
msgid "Create a `.rs` file under `tests/`:"
msgstr "یک فایل  `.rs` در زیر  `tests/` بسازید:"

#: src/testing/other.md
#, fuzzy
msgid "// tests/my_library.rs\n"
msgstr "// tests/my_library.rs\n"

#: src/testing/other.md
msgid "These tests only have access to the public API of your crate."
msgstr "این آزمایش‌ها فقط به public API مربوط به crate شما دسترسی دارند."

#: src/testing/other.md
msgid "Documentation Tests"
msgstr "تست‌ سندها"

#: src/testing/other.md
msgid "Rust has built-in support for documentation tests:"
msgstr "زبان Rust دارای پشتیبانی داخلی برای تست‌های مستندسازی است:"

#: src/testing/other.md
#, fuzzy
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"

#: src/testing/other.md
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"بلوک‌های کد در commentها `///` به طور خودکار به عنوان کد Rust دیده می‌شوند."

#: src/testing/other.md
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "این کد به عنوان بخشی از `cargo test` کامپایل و اجرا می‌شود."

#: src/testing/other.md
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr ""
"افزودن  `#` به کد، آن را از مستندات پنهان می‌کند، اما همچنان آن را کامپایل/"
"اجرا می‌کند."

#: src/testing/other.md
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"کد بالا را در [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0) "
"تست کنید."

#: src/testing/lints.md
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""
"کامپایلر Rust پیام‌های خطای جالب و همچنین  built-in lint مناسبی تولید می‌کند. "
"[Clippy](https://doc.rust-lang.org/clippy/)  که lintهای بیشتری را ارائه "
"می‌دهد، که در گروه‌هایی سازماندهی شده‌اند که می‌توانند در هر پروژه فعال شوند."

#: src/testing/lints.md
msgid "\"X probably fits in a u16, right? {}\""
msgstr ""
"\"\"X احتمالاً در یک u16 مناسب است، درست است؟ {}\"X احتمالاً در یک u16 مناسب "
"است، درست است؟ {}\""

#: src/testing/lints.md
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""
"نمونه کد را اجرا کنید و پیام خطا را بررسی کنید. lintهایی نیز در اینجا قابل "
"مشاهده هستند، اما پس از کامپایل شدن کد، آن‌ها نشان‌داده نمی‌شوند. برای نمایش آن "
"lintها به سایت Playground بروید."

#: src/testing/lints.md
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""
"پس از رفع lintها،  `clippy`  را در سایت playground اجرا کنید تا هشدارهای "
"clippy نشان داده شود. Clippy مستندات گسترده‌ای از  lintهای خود دارد و همیشه  "
"lintهای جدید (از جمله default-deny lint) را اضافه می‌کند."

#: src/testing/lints.md
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""
"توجه داشته باشید که خطاها یا هشدارهای مربوط به  `help: ...` را می‌توان با "
"`cargo fix` یا از طریق ویرایشگر خود برطرف کرد."

#: src/testing/exercise.md
msgid "Luhn Algorithm"
msgstr "الگوریتم  Luhn"

#: src/testing/exercise.md
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[الگوریتم Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) برای "
"اعتبارسنجی شماره‌های کارت اعتباری استفاده می‌شود. این الگوریتم یک رشته را به "
"عنوان ورودی دریافت می‌کند و برای اعتبارسنجی شماره کارت اعتباری مراحل زیر را "
"انجام می‌دهد:"

#: src/testing/exercise.md
#, fuzzy
msgid "Ignore all spaces. Reject numbers with fewer than two digits."
msgstr "تمام فضاها را نادیده بگیرید.شماره‌هایی با کمتر از دو رقم را رد کنید."

#: src/testing/exercise.md
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"با حرکت از سمت راست رشته به چپ، هر دومین رقم را دوبل کنید: برای شماره "
"`1234`، `3` و `1` را دوبل می‌کنیم. برای شماره `98765`، `6` و `8` را دوبل "
"می‌کنیم."

#: src/testing/exercise.md
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"پس از دوبل کردن یک عدد، اگر اون جفت خروجی بیش از 9 باشد، ارقام را جمع کنید. "
"بنابراین، دوبل کردن `7` به `14` تبدیل می‌شود که به <span dir=ltr>`1 + 4 = 5`</"
"span> تبدیل می‌شود."

#: src/testing/exercise.md
msgid "Sum all the undoubled and doubled digits."
msgstr "تمام ارقام دو برابر نشده و دو برابر شده را جمع کنید."

#: src/testing/exercise.md
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "اگر مجموع با ‍`0` خاتمه یابد، شماره کارت اعتباری معتبر است."

#: src/testing/exercise.md
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most of the algorithm is "
"implemented correctly."
msgstr ""
"کد ارائه شده یک پیاده‌سازی باگ از الگوریتم luhn را به همراه دو unit test پایه "
"ارائه می‌کند که تأیید می‌کند بیشتر الگوریتم به درستی پیاده‌سازی شده است."

#: src/testing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"کد زیر را به <span dir=ltr><https://play.rust-lang.org/></span>  کپی کنید و "
"تابع را پیاده‌سازی کنید."

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4263 9826 4026 9299\""
msgstr "\"4263 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4539 3195 0343 6467\""
msgstr "\"4539 3195 0343 6467\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"7992 7398 713\""
msgstr "\"7992 7398 713\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4223 9826 4026 9299\""
msgstr "\"4223 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4539 3195 0343 6476\""
msgstr "\"4539 3195 0343 6476\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"8273 1232 7352 0569\""
msgstr "\"8273 1232 7352 0569\""

#: src/testing/solution.md
#, fuzzy
msgid "// This is the buggy version that appears in the problem.\n"
msgstr "// This is the buggy version that appears in the problem.\n"

#: src/testing/solution.md
#, fuzzy
msgid "// This is the solution and passes all of the tests below.\n"
msgstr "// This is the solution and passes all of the tests below.\n"

#: src/testing/solution.md
msgid "\"1234 5678 1234 5670\""
msgstr "\"1234 5678 1234 5670\""

#: src/testing/solution.md
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr "\"آیا {cc_number} یک شماره کارت اعتباری معتبر است؟ {}\""

#: src/testing/solution.md
msgid "\"yes\""
msgstr "\"بله\""

#: src/testing/solution.md
msgid "\"no\""
msgstr "\"نه\""

#: src/testing/solution.md
msgid "\"foo 0 0\""
msgstr "\"foo 0 0\""

#: src/testing/solution.md
msgid "\" \""
msgstr "\" \""

#: src/testing/solution.md
msgid "\"  \""
msgstr "\"  \""

#: src/testing/solution.md
msgid "\"    \""
msgstr "\"    \""

#: src/testing/solution.md
msgid "\"0\""
msgstr "\"0\""

#: src/testing/solution.md
msgid "\" 0 0 \""
msgstr "\" 0 0 \""

#: src/welcome-day-4-afternoon.md
#, fuzzy
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 15 "
"minutes. It contains:"
msgstr ""
"با احتساب 10 دقیقه استراحت، این جلسه باید حدود 2 ساعت و 5 دقیقه طول بکشد. آن "
"شامل:"

#: src/error-handling.md
msgid "Error Trait"
msgstr "ویژگی (Trait) خطا"

#: src/error-handling.md
msgid "thiserror and anyhow"
msgstr "thiserror و anyhow"

#: src/error-handling.md src/error-handling/exercise.md
msgid "Exercise: Rewriting with Result"
msgstr "تمرین: بازنویسی با نتیجه"

#: src/error-handling/panics.md
msgid "Rust handles fatal errors with a \"panic\"."
msgstr "Rust خطاهای مهلک را با \"panic\" کنترل می‌کند."

#: src/error-handling/panics.md
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "اگر یک خطای مرگبار در زمان اجرا رخ دهد، Rust باعث panic می‌شود:"

#: src/error-handling/panics.md
msgid "\"v[100]: {}\""
msgstr "\"v[100]: {}\""

#: src/error-handling/panics.md
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "استفاده از Panicها برای خطاهای غیر قابل جبران و غیرمنتظره است."

#: src/error-handling/panics.md
msgid "Panics are symptoms of bugs in the program."
msgstr "پانیک‌ها علائم باگ در برنامه هستند."

#: src/error-handling/panics.md
msgid "Runtime failures like failed bounds checks can panic"
msgstr "خرابی‌های زمان اجرا مانند failed bounds checkها می‌تواند باعث panic شود"

#: src/error-handling/panics.md
msgid "Assertions (such as `assert!`) panic on failure"
msgstr "Assertions (such as `assert!`) panic on failure"

#: src/error-handling/panics.md
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr "پنیک‌های خاص می‌توانند از ماکرو `panic!` استفاده کنند."

#: src/error-handling/panics.md
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr ""
"یک panic را \"باز\" ​​می‌کند و مقادیر را حذف می‌کند درست مثل اینکه توابع برگشته "
"باشند."

#: src/error-handling/panics.md
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"اگر خرابی قابل قبول نیست، از APIهای بدون panic (مانند `Vec::get`) استفاده "
"کنید."

#: src/error-handling/panics.md
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"به طور پیش‌فرض، panic باعث unwind شدن stack می‌شود. unwinding را می‌توان "
"گرفت( در واقع منظور این است که می‌توان آن را caught کرد):"

#: src/error-handling/panics.md
msgid "\"No problem here!\""
msgstr "\"اینجا مشکلی نیست!\""

#: src/error-handling/panics.md
msgid "\"{result:?}\""
msgstr "\"{result:?}\""

#: src/error-handling/panics.md
msgid "\"oh no!\""
msgstr "\"oh no!\""

#: src/error-handling/panics.md
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr ""
"گرفتن (Catching) غیر معمول است. سعی نکنید exceptionها را با `catch_unwind` "
"پیاده‌سازی کنید!"

#: src/error-handling/panics.md
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"این کار می‌تواند در سرورهایی مفید باشد که حتی در صورت خراب شدن یک درخواست، "
"باید به کار خود ادامه دهند."

#: src/error-handling/panics.md
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"اگر `panic = 'abort'` در `Cargo.toml`» شما تنظیم شده باشد، این مورد کار "
"نمی‌کند."

#: src/error-handling/result.md
msgid ""
"Our primary mechanism for error handling in Rust is the [`Result`](https://"
"doc.rust-lang.org/stable/std/result/enum.Result.html) enum, which we briefly "
"saw when discussing standard library types."
msgstr ""
"مکانیسم اصلی ما برای مدیریت خطا در Rust، فهرست [`Result`](https://doc.rust-"
"lang.org/stable/std/result/enum.Result.html) است، که به طور خلاصه هنگام بحث "
"در مورد تایپ‌های کتابخانه استاندارد مشاهده کردیم."

#: src/error-handling/result.md
msgid ""
"`Result` has two variants: `Ok` which contains the success value, and `Err` "
"which contains an error value of some kind."
msgstr ""

#: src/error-handling/result.md
msgid ""
"Whether or not a function can produce an error is encoded in the function's "
"type signature by having the function return a `Result` value."
msgstr ""
"اینکه آیا یک تابع می‌تواند خطا ایجاد کند یا نه، در signature نوع تابع با "
"برگرداندن تابع مقدار `Result` کدگذاری می‌شود."

#: src/error-handling/result.md
msgid ""
"Like with `Option`, there is no way to forget to handle an error: You cannot "
"access either the success value or the error value without first pattern "
"matching on the `Result` to check which variant you have. Methods like "
"`unwrap` make it easier to write quick-and-dirty code that doesn't do robust "
"error handling, but means that you can always see in your source code where "
"proper error handling is being skipped."
msgstr ""
"مانند `Option`، هیچ راهی برای فراموش کردن خطا وجود ندارد: شما نمی‌توانید به "
"مقدار موفقیت یا مقدار خطا بدون تطبیق الگوی اولیه در `Result` دسترسی پیدا "
"کنید تا بررسی کنید کدام نوع را دارید. روش‌هایی مانند`unwrap`  نوشتن کدهای "
"سریع و کثیف را آسان‌تر می‌کنند که مدیریت خطا را به خوبی انجام نمی‌دهد، اما به "
"این معنی است که همیشه می‌توانید در کد منبع خود ببینید که در کجا مدیریت صحیح "
"خطا نادیده گرفته می‌شود."

#: src/error-handling/result.md
msgid ""
"It may be helpful to compare error handling in Rust to error handling "
"conventions that students may be familiar with from other programming "
"languages."
msgstr ""
"مقایسه مدیریت خطا در Rust با قراردادهای مدیریت خطا که دانش‌آموزان ممکن است با "
"سایر زبان‌های برنامه‌نویسی آشنا باشند، ممکن است مفید باشد."

#: src/error-handling/result.md
msgid "Many languages use exceptions, e.g. C++, Java, Python."
msgstr ""
"بسیاری از زبان‌ها از exceptionها استفاده می‌کنند، به عنوان مثال.  ++C، جاوا، "
"پایتون."

#: src/error-handling/result.md
msgid ""
"In most languages with exceptions, whether or not a function can throw an "
"exception is not visible as part of its type signature. This generally means "
"that you can't tell when calling a function if it may throw an exception or "
"not."
msgstr ""
"در اکثر زبان‌های دارای exception، این که آیا یک تابع می‌تواند استثنا ایجاد کند "
"یا نه، به عنوان بخشی از نوع امضای(signature) آن قابل مشاهده نیست. این به طور "
"کلی به این معنی است که هنگام فراخوانی یک تابع نمی‌توانید بگویید که آیا ممکن "
"است یک exception ایجاد کند یا خیر."

#: src/error-handling/result.md
msgid ""
"Exceptions generally unwind the call stack, propagating upward until a `try` "
"block is reached. An error originating deep in the call stack may impact an "
"unrelated function further up."
msgstr ""
"استثناها معمولاً call stack را باز می‌کنند و تا رسیدن به بلوک `try` به سمت "
"بالا منتشر می‌شوند. خطایی که در اعماق call stack ایجاد می‌شود ممکن است بر "
"عملکرد نامرتبط بیشتر تأثیر بگذارد."

#: src/error-handling/result.md
msgid "Error Numbers"
msgstr "شماره‌های خطا"

#: src/error-handling/result.md
msgid ""
"Some languages have functions return an error number (or some other error "
"value) separately from the successful return value of the function. Examples "
"include C and Go."
msgstr ""
"برخی از زبان‌ها دارای توابعی هستند که یک عدد خطا (یا مقداری خطای دیگر) را جدا "
"از مقدار بازگشت موفقیت‌آمیز تابع برمی‌گردانند. به عنوان مثال می توان به C و Go "
"اشاره کرد."

#: src/error-handling/result.md
msgid ""
"Depending on the language it may be possible to forget to check the error "
"value, in which case you may be accessing an uninitialized or otherwise "
"invalid success value."
msgstr ""
"بسته به زبان ممکن است فراموش کنید مقدار خطا را بررسی کنید، در این صورت ممکن "
"است به یک مقدار موفقیت نامعتبر یا نامعتبر دسترسی داشته باشید."

#: src/error-handling/try.md
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"خطاهای زمان اجرا مانند connection-refused یا file-not-found با نوع «نتیجه» "
"مدیریت می‌شوند، اما تطبیق این نوع در هر تماس می‌تواند دشوار باشد. اپراتور `?`  "
"برای برگرداندن خطاها به تماس گیرنده استفاده می‌شود. این به شما امکان می‌دهد تا "
"موارد مشترک را بازگردانید."

#: src/error-handling/try.md
msgid "into the much simpler"
msgstr "بسیار ساده‌تر"

#: src/error-handling/try.md
msgid "We can use this to simplify our error handling code:"
msgstr "می‌توانیم از این برای ساده‌سازی کد رسیدگی به خطا استفاده کنیم:"

#: src/error-handling/try.md
#, fuzzy
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"alice\").unwrap();\n"

#: src/error-handling/try.md src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
msgid "\"config.dat\""
msgstr "\"config.dat\""

#: src/error-handling/try.md src/error-handling/try-conversions.md
msgid "\"username or error: {username:?}\""
msgstr "\"نام‌کاربری یا خطا: {username:?}\""

#: src/error-handling/try.md
msgid "Simplify the `read_username` function to use `?`."
msgstr "تابع `read_username` را برای استفاده از `?` ساده کنید."

#: src/error-handling/try.md
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "متغیر`username` می تواند  `Ok(string)` یا `Err(error)` باشد."

#: src/error-handling/try.md
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"از فراخوانی `fs::write` برای آزمایش سناریوهای مختلف استفاده کنید: بدون فایل، "
"فایل خالی، فایل با نام کاربری."

#: src/error-handling/try.md
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process::Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""
"توجه داشته باشید که `main` تا زمانی که `std::process::Termination` را "
"پیاده‌سازی کند، می‌تواند `نتیجه<(), E>` را برگرداند. در عمل، این بدان معنی است "
"که `E` پیاده‌سازی `Debug` را انجام‌می‌دهد. فایل اجرایی، نوع  `Err` را چاپ می‌کند "
"و در صورت خطا، وضعیت خروج غیر صفر (nonzero) را برمی‌گرداند."

#: src/error-handling/try-conversions.md
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr "گسترش مؤثر `?` کمی پیچیده‌تر از آنچه قبلاً ذکر شد است:"

#: src/error-handling/try-conversions.md
msgid "works the same as"
msgstr "به طو مشابه کار می‌کند"

#: src/error-handling/try-conversions.md
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"فراخوانی `From::from` در اینجا به این معنی است که ما سعی می کنیم نوع خطا را "
"به نوع بازگشتی توسط تابع تبدیل کنیم. این باعث می‌شود که خطاها به خطاهای سطح "
"بالاتر کپسوله شوند."

#: src/error-handling/try-conversions.md
msgid "\"IO error: {e}\""
msgstr "\"IO error: {e}\""

#: src/error-handling/try-conversions.md
msgid "\"Found no username in {path}\""
msgstr "\"در این  {path} نام کاربری یافت نشد\""

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "//std::fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//std::fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/try-conversions.md
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""
"عملگر `?` باید مقداری سازگار با نوع بازگشتی تابع برگرداند. برای `Result`، به "
"این معنی است که انواع خطا باید سازگار باشند. تابعی که`Result<T, ErrorOuter>` "
"را برمی‌گرداند، تنها می‌تواند از  `?`  در مقداری از تایپ‌های  `Result<U, "
"ErrorInner>` استفاده کند اگر `ErrorOuter` و `ErrorInner`  یک نوع باشند یا "
"اگر `ErrorOuter` از<ErrorInner>` را پیاده‌سازی کند."

#: src/error-handling/try-conversions.md
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""
"یک جایگزین رایج برای پیاده سازی `From`جهت `Result::map_err` است، به خصوص "
"زمانی که تبدیل‌ها فقط در یک مکان انجام می‌شود."

#: src/error-handling/try-conversions.md
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""
"هیچ الزامی برای سازگاری `Option` وجود ندارد. تابعی که `Option<T>` را برمی "
"گرداند می تواند از عملگر `?` در `Option<U>` برای انواع دلخواه `T` و `U` "
"استفاده کند."

#: src/error-handling/try-conversions.md
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""
"یک تابعی که `Result` را برمی‌گرداند دیگر نمی‌تواند از `?` در `Option` استفاده "
"کند و بالعکس. با این‌حال، `Option::ok_or`  یک  `Option` را به `Result`  تبدیل "
"می‌کند در حالی که `Result::ok` «نتیجه» را به `Option` تبدیل می‌کند."

#: src/error-handling/error.md
msgid "Dynamic Error Types"
msgstr "انواع خطاهای Dynamic"

#: src/error-handling/error.md
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"گاهی اوقات می‌خواهیم اجازه دهیم هر نوع خطای بدون نوشتن enum خودمان که تمام "
"احتمالات مختلف را پوشش می‌دهد، برگردانده شود. ویژگی `std::error::Error` ایجاد "
"یک object مشخ استه که می‌تواند حاوی هر خطایی باشد را آسان می‌کند."

#: src/error-handling/error.md
msgid "\"count.dat\""
msgstr "\"count.dat\""

#: src/error-handling/error.md
msgid "\"1i3\""
msgstr "\"1i3\""

#: src/error-handling/error.md
msgid "\"Count: {count}\""
msgstr "\"تعداد: {count}\""

#: src/error-handling/error.md
msgid "\"Error: {err}\""
msgstr "\"Error: {err}\""

#: src/error-handling/error.md
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""
"تابع `read_count`می‌تواند `std::io::Error` (از عملیات فایل) یا `std::num::"
"ParseIntError` (از `String::parse`) را برگرداند."

#: src/error-handling/error.md
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"خطاهای Boxing باعث صرفه‌جویی در کد می شود، اما توانایی رسیدگی به موارد خطای "
"مختلف را به طور متفاوت در برنامه از بین می‌برد. به این ترتیب استفاده از "
"`Box<dyn Error>` در public API یک کتابخانه ایده خوبی نیست، اما می‌تواند گزینه "
"خوبی در برنامه‌ای باشد که فقط می‌خواهید پیام خطا را در جایی نمایش دهید."

#: src/error-handling/error.md
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""
"هنگام تعریف یک نوع خطای سفارشی، مطمئن شوید که ویژگی `std::error::Error` را "
"اجرا کنید تا بتوان آن را در جعبه قرار داد. اما اگر نیاز به پشتیبانی از ویژگی "
"`no_std` دارید، به خاطر داشته باشید که ویژگی `std::error::Error` در حال حاضر "
"با `no_std` در [nightly](https://github.com/rust-lang) سازگار است."

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling."
msgstr ""
"این [`thiserror`](https://docs.rs/thiserror/) و [`anyhow`](https://docs.rs/"
"anyhow/) crateها به طور گسترده ای برای ساده کردن رسیدگی به خطا استفاده "
"می‌شوند."

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`thiserror` is often used in libraries to create custom error types that "
"implement `From<T>`."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow` is often used by applications to help with error handling in "
"functions, including adding contextual information to your errors."
msgstr ""
"اغلب `anyhow` توسط برنامه‌ها برای کمک به مدیریت خطا در توابع، از جمله افزودن "
"اطلاعات متنی به خطاهای شما، استفاده می‌شود."

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Found no username in {0}\""
msgstr "\"هیچ نام‌کاربری در {0} یافت نشد\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Failed to open {path}\""
msgstr "\"{path} باز نشد\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Failed to read\""
msgstr "\"شکست در خواندن\""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Username: {username}\""
msgstr "\"نام‌کاربری: {username}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Error: {err:?}\""
msgstr "\"Error: {err:?}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror`"
msgstr "`thiserror`"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""
"ماکرو استخراج `Error` توسط `thiserror` ارائه می‌شود و دارای ویژگی‌های مفید "
"زیادی برای کمک به تعریف انواع خطا به روشی فشرده است."

#: src/error-handling/thiserror-and-anyhow.md
msgid "The `std::error::Error` trait is derived automatically."
msgstr "ویژگی `std::error::Error` به طور خودکار مشتق می‌شود."

#: src/error-handling/thiserror-and-anyhow.md
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr "پیام  `#[error]` برای استخراج ویژگی `Display` استفاده می‌شود."

#: src/error-handling/thiserror-and-anyhow.md
msgid "`anyhow`"
msgstr "`anyhow`"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error` اساساً پوششی (wrapper) در اطراف`Box<dyn Error>` است. به این "
"ترتیب معمولاً انتخاب خوبی برای API عمومی یک کتابخانه نیست، اما به طور گسترده "
"در برنامه‌های مختلف استفاده می‌شود."

#: src/error-handling/thiserror-and-anyhow.md
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr "`anyhow::Result<V>`یک type مستعار برای است`Result<V, anyhow::Error>`."

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr "در صورت لزوم می‌توان نوع خطای واقعی داخل آن را برای بررسی استخراج کرد."

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"عملکرد ارائه شده توسط `anyhow::Result<T>` ممکن است برای توسعه‌دهندگان Go آشنا "
"باشد، زیرا الگوهای استفاده و ارگونومی مشابهی را با `(T, error)` از Go ارائه "
"می‌دهد."

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""
"`anyhow::Context` یک ویژگی است که برای  typeهای استاندارد `Result` و "
"`Option` پیاده‌سازی شده است. `use anyhow::Context` برای فعال کردن `."
"context()` و `.with_context()` در آن  typeها ضروری است."

#: src/error-handling/exercise.md
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""
"در زیر یک تجزیه‌کننده بسیار ساده برای یک زبان عبارت پیاده‌سازی می‌کند. با این "
"حال، با panic خطاها را کنترل می‌کند. آن را بازنویسی کنید تا به جای آن از "
"مدیریت خطای اصطلاحی استفاده کنید و خطاها را به بازگشت از `main` منتشر کنید. "
"با خیال راحت از `thiserror` و `anyhow` استفاده کنید."

#: src/error-handling/exercise.md
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""
"نکته: با رفع خطا در عملکرد `parse` شروع کنید. هنگامی که به درستی کار کرد، "
"`Tokenizer` را برای پیاده‌سازی `Iterator<Item=Result<Token, TokenizerError>>` "
"به‌روزرسانی کنید و آن را در parser کنترل کنید."

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// An arithmetic operator.\n"
msgstr "/// An arithmetic operator.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A token in the expression language.\n"
msgstr "/// A token in the expression language.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// An expression in the expression language.\n"
msgstr "/// An expression in the expression language.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A reference to a variable.\n"
msgstr "/// A reference to a variable.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A literal number.\n"
msgstr "/// A literal number.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "/// A binary operation.\n"
msgstr "/// A binary operation.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'_'"
msgstr "'_'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'+'"
msgstr "'+'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'-'"
msgstr "'-'"

#: src/error-handling/exercise.md
msgid "\"Unexpected character {c}\""
msgstr "\"کاراکتر غیرمنتظره {c}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"Unexpected end of input\""
msgstr "\"پایان غیرمنتظره در ورودی\""

#: src/error-handling/exercise.md
msgid "\"Invalid 32-bit integer'\""
msgstr "\"عدد صحیح 32-bit  نامعتبر\""

#: src/error-handling/exercise.md
msgid "\"Unexpected token {tok:?}\""
msgstr "\"توکن غیرمنتظره {tok:?}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
#, fuzzy
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr "// Look ahead to parse a binary operation if present.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"10+foo+20-30\""
msgstr "\"10+foo+20-30\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"{expr:?}\""
msgstr "\"{expr:?}\""

#: src/error-handling/solution.md
msgid "\"Unexpected character '{0}' in input\""
msgstr "\"کاراکتر غیرمنتظره \"{0}\" در ورودی\""

#: src/error-handling/solution.md
msgid "\"Tokenizer error: {0}\""
msgstr "\"خطای توکن‌سازی: {0}\""

#: src/error-handling/solution.md
msgid "\"Unexpected token {0:?}\""
msgstr "\"توکن (token) غیرمنتظره {0:?}\""

#: src/error-handling/solution.md
msgid "\"Invalid number\""
msgstr "\"شماره نامعتبر\""

#: src/unsafe-rust.md
msgid "This segment should take about 1 hour and 5 minutes. It contains:"
msgstr "این بخش باید حدود ۱ ساعت و ۵ دقیقه طول بکشد.و شامل موارد زیر است:"

#: src/unsafe-rust/unsafe.md
msgid "The Rust language has two parts:"
msgstr "زبان Rust دو بخش دارد:"

#: src/unsafe-rust/unsafe.md
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr ""
"در **Safe Rust:** حافظه ایمن یا memory safe، هیچ رفتار تعریف نشده‌ای امکان "
"پذیر نیست."

#: src/unsafe-rust/unsafe.md
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"در **Unsafe Rust:** در صورت نقض پیش‌شرط‌ها، می‌تواند باعث رفتار نامشخص شود."

#: src/unsafe-rust/unsafe.md
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"ما عمدتاً safe Rust را در این دوره دیدیم، اما مهم است که بدانیم Unsafe Rust "
"چیست."

#: src/unsafe-rust/unsafe.md
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"کد ناامن معمولا کوچک و ایزوله است و صحت آن باید به دقت مستند شود. معمولاً در "
"یک لایه انتزاعی ایمن پیچیده می‌شود."

#: src/unsafe-rust/unsafe.md
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "این Unsafe Rust به شما امکان دسترسی به پنج قابلیت جدید را می‌دهد:"

#: src/unsafe-rust/unsafe.md
msgid "Dereference raw pointers."
msgstr "اشاره‌گرهای خام."

#: src/unsafe-rust/unsafe.md
msgid "Access or modify mutable static variables."
msgstr "به متغیرهای mutable static variable  تغییر دسترسی دهید."

#: src/unsafe-rust/unsafe.md
msgid "Access `union` fields."
msgstr "به فیلدهای  `union`  دسترسی پیدا کنید."

#: src/unsafe-rust/unsafe.md
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "توابع `unsafe`، از جمله توابع `extern` را فراخوانی کنید."

#: src/unsafe-rust/unsafe.md
msgid "Implement `unsafe` traits."
msgstr "ویژگی‌های `unsafe` را اجرا کنید."

#: src/unsafe-rust/unsafe.md
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"در ادامه به طور خلاصه به قابلیت‌های unsafe می‌پردازیم. برای جزئیات کامل، لطفاً "
"به [Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) و [Rustonomicon](https://doc.rust-lang.org/nomicon/)."

#: src/unsafe-rust/unsafe.md
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"همینطور Unsafe Rust به این معنی نیست که کد نادرست است. این بدان معنی است که "
"توسعه‌دهندگان برخی از ویژگی‌های ایمنی کامپایلر را خاموش کرده‌اند و باید کد صحیح "
"را خودشان بنویسند. این بدان معناست که کامپایلر دیگر قواعد ایمنی Rust را اجرا "
"نمی‌کند."

#: src/unsafe-rust/dereferencing.md
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "ایجاد اشاره‌گر ایمن است، اما عدم ارجاع به آنها «ناامن» یا `unsafe` است:"

#: src/unsafe-rust/dereferencing.md
msgid "\"careful!\""
msgstr "\"مراقب باش!\""

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"// SAFETY: r1 and r2 were obtained from references and so are guaranteed to\n"
"    // be non-null and properly aligned, the objects underlying the "
"references\n"
"    // from which they were obtained are live throughout the whole unsafe\n"
"    // block, and they are not accessed either through the references or\n"
"    // concurrently through any other pointers.\n"
msgstr ""
"// SAFETY: r1 and r2 were obtained from references and so are guaranteed to\n"
"    // be non-null and properly aligned, the objects underlying the "
"references\n"
"    // from which they were obtained are live throughout the whole unsafe\n"
"    // block, and they are not accessed either through the references or\n"
"    // concurrently through any other pointers.\n"

#: src/unsafe-rust/dereferencing.md
msgid "\"r1 is: {}\""
msgstr "\"r1 برابر هست: {}\""

#: src/unsafe-rust/dereferencing.md
msgid "\"uhoh\""
msgstr "\"اوهو\""

#: src/unsafe-rust/dereferencing.md
msgid "\"r2 is: {}\""
msgstr "\"r2 برابر هست: {}\""

#: src/unsafe-rust/dereferencing.md
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"

#: src/unsafe-rust/dereferencing.md
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"این تمرین خوبی است (و طبق راهنمای سبک Android Rust لازم است) برای هر بلوک "
"`unsafe` یک نظر بنویسید و توضیح دهد که چگونه کد داخل آن الزامات ایمنی عملیات "
"ناامنی را که انجام می‌دهد برآورده می‌کند."

#: src/unsafe-rust/dereferencing.md
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"در مورد عدم ارجاع اشاره‌گر، این بدان معنی است که نشانگرها باید [_valid_]"
"(https://doc.rust-lang.org/std/ptr/index.html#safety) باشند، یعنی:"

#: src/unsafe-rust/dereferencing.md
msgid "The pointer must be non-null."
msgstr "اشاره‌گر باید غیر تهی یا non-null باشد."

#: src/unsafe-rust/dereferencing.md
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"اشاره‌گر باید _dereferenceable_ باشد (در محدوده یک object اختصاص داده شده)."

#: src/unsafe-rust/dereferencing.md
msgid "The object must not have been deallocated."
msgstr "این object نباید جابجا شده باشد."

#: src/unsafe-rust/dereferencing.md
msgid "There must not be concurrent accesses to the same location."
msgstr "دسترسی همزمان به یک مکان نباید وجود داشته باشد."

#: src/unsafe-rust/dereferencing.md
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"اگر اشاره‌گر با فرستادن یک reference به دست آمده باشد، object زیرین باید live "
"باشد و نمی‌توان از هیچ مرجعی برای دسترسی به حافظه استفاده کرد."

#: src/unsafe-rust/dereferencing.md
msgid "In most cases the pointer must also be properly aligned."
msgstr "در بیشتر موارد، اشاره‌گر نیز باید به درستی تراز شود."

#: src/unsafe-rust/dereferencing.md
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""
"بخش «NOT SAFE» نمونه‌ای از یک نوع رایج از اشکال UB را ارائه می‌کند: `*r1`  "
"دارای طول عمر  `'static` است، بنابراین `r3` دارای نوع  `&'static String` است "
"و بنابراین عمر `s` بیشتر می‌شود. ایجاد یک مرجع از یک اشاره گر نیاز به دقت "
"بسیار دارد."

#: src/unsafe-rust/mutable-static.md
msgid "It is safe to read an immutable static variable:"
msgstr "خواندن یک متغیر استاتیک تغییرناپذیر بی‌خطر است:"

#: src/unsafe-rust/mutable-static.md
msgid "\"Hello, world!\""
msgstr "\"سلام دنیا!\""

#: src/unsafe-rust/mutable-static.md
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr "\"HELLO_WORLD: {HELLO_WORLD}\""

#: src/unsafe-rust/mutable-static.md
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"با‌این‌حال، از آنجایی که شرایط رقابتی داده‌ها ممکن است رخ دهد، خواندن و نوشتن "
"متغیرهای mutable static ناامن است:"

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid ""
"// SAFETY: There are no other threads which could be accessing `COUNTER`.\n"
msgstr ""
"// SAFETY: There are no other threads which could be accessing `COUNTER`.\n"

#: src/unsafe-rust/mutable-static.md
msgid "\"COUNTER: {COUNTER}\""
msgstr "\"COUNTER: {COUNTER}\""

#: src/unsafe-rust/mutable-static.md
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"برنامه در اینجا امن است زیرا single-thread است. با این حال، کامپایلر Rust "
"محافظه کار است و بدترین‌ها را در نظر می‌گیرد.  `unsafe` را حذف کنید و ببینید "
"چگونه کامپایلر توضیح می‌دهد که جهش یک static از چندین thread یک رفتار تعریف "
"نشده است."

#: src/unsafe-rust/mutable-static.md
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"استفاده از یک static قابل تغییر (mutable) به طور کلی ایده بدی است، اما "
"مواردی وجود دارد که ممکن است در کدهای سطح پایین `no_std` منطقی باشد، مانند "
"اجرای یک heap allocator یا کار با برخی از APIهای مربوط به زبان C."

#: src/unsafe-rust/unions.md
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"همینطور Unionها مانند enum‌ها هستند، اما شما باید خودتان active field را "
"ردیابی کنید:"

#: src/unsafe-rust/unions.md
msgid "\"int: {}\""
msgstr "\"int: {}\""

#: src/unsafe-rust/unions.md
msgid "\"bool: {}\""
msgstr "\"bool: {}\""

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "// Undefined behavior!\n"
msgstr "هیچ رفتار تعریف نشده‌ای در زمان اجرا:"

#: src/unsafe-rust/unions.md
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"به طور کلی Unionها در Rust به ندرت مورد نیاز هستند زیرا معمولاً می‌توانید از "
"enum استفاده کنید. آنها گاهی اوقات برای تعامل با APIهای کتابخانه C مورد نیاز "
"هستند."

#: src/unsafe-rust/unions.md
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"اگر فقط می‌خواهید بایت‌ها را به‌عنوان نوع متفاوتی تفسیر کنید، احتمالاً [`std::"
"mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html "
"را می‌خواهید ) یا یک safe wrapper مانند جعبه [`zerocopy`(https://crates.io/"
"crates/zerocopy)."

#: src/unsafe-rust/unsafe-functions.md
msgid "Calling Unsafe Functions"
msgstr "فراخوانی متدهای ناامن"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"یک function یا method را می‌توان `unsafe` علامت‌گذاری کرد، اگر دارای پیش‌شرط‌های "
"اضافی باشد که باید برای جلوگیری از رفتار نامشخص رعایت کنید:"

#: src/unsafe-rust/unsafe-functions.md src/unsafe-rust/exercise.md
#: src/unsafe-rust/solution.md src/android/interoperability/with-c.md
#: src/android/interoperability/with-c/rust.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/exercises/chromium/build-rules.md src/bare-metal/aps/inline-assembly.md
#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"C\""
msgstr "\"C\""

#: src/unsafe-rust/unsafe-functions.md
msgid "\"🗻∈🌏\""
msgstr "\"🗻∈🌏\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// SAFETY: The indices are in the correct order, within the bounds of the\n"
"    // string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""
"// SAFETY: The indices are in the correct order, within the bounds of the\n"
"    // string slice, and lie on UTF-8 sequence boundaries.\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"emoji: {}\""
msgstr "\"emoji: {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid "\"char count: {}\""
msgstr "\"char count: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// SAFETY: `abs` doesn't deal with pointers and doesn't have any safety\n"
"    // requirements.\n"
msgstr ""
"// SAFETY: `abs` doesn't deal with pointers and doesn't have any safety\n"
"    // requirements.\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"Absolute value of -3 according to C: {}\""
msgstr "\"مقدار مطلق ۳- طبق C: {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "Writing Unsafe Functions"
msgstr "نوشتن متدهای ناامن"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"اگر عملکردهای خود را برای جلوگیری از رفتار نامشخص به شرایط خاصی نیاز دارند، "
"می‌توانید به‌عنوان`unsafe` علامت‌گذاری کنید."

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "// SAFETY: ...\n"
msgstr "// SAFETY: ...\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"a = {}, b = {}\""
msgstr "\"a = {}, b = {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"تابع `get_unchecked`، مانند اکثر توابع `_unchecked`، ناامن است، زیرا اگر در "
"محدوده نادرست باشد، می‌تواند یک UB ایجاد کند. `abs` به دلیل دیگری نادرست است: "
"این یک تابع خارجی (FFI) است. فراخوانی توابع خارجی معمولاً زمانی مشکل‌ساز است "
"که آن توابع کارهایی را با اشاره‌گرهایی انجام می‌دهند که ممکن است مدل حافظه "
"Rust را نقض کنند، اما به طور کلی هر تابع C ممکن است تحت هر شرایط دلخواه "
"رفتار نامشخصی داشته باشد."

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"زبان برنامه‌نویسی `\"C\"` در این مثال ABI است. [ABIهای دیگر نیز در دسترس "
"هستند](https://doc.rust-lang.org/reference/items/external-blocks.html)."

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr ""
"ما در واقع از pointerها برای یک تابع`swap`  استفاده نمی‌کنیم - این کار را "
"می‌توان به‌طور ایمن با referenceها انجام داد."

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"توجه داشته باشید که کد ناامن در یک تابع ناامن بدون بلوک `unsafe` مجاز است. "
"ما می‌توانیم این کار را با  `#[deny(unsafe_op_in_unsafe_fn)]` غیرمجاز کنیم. "
"سعی کنید آن را اضافه کنید و ببینید چه اتفاقی می افتد. این احتمالاً در نسخه "
"بعدی Rust تغییر خواهد کرد."

#: src/unsafe-rust/unsafe-traits.md
msgid "Implementing Unsafe Traits"
msgstr "پیاده سازی صفات (Traits) ناامن"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"مانند توابع، اگر پیاده‌سازی باید شرایط خاصی را تضمین کند تا از رفتار نامشخص "
"جلوگیری شود، می‌توانید یک ویژگی را به‌عنوان `unsafe` علامت‌گذاری کنید."

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"برای مثال،  `zerocopy` crate  یک ویژگی ناامن دارد که [چیزی شبیه به این]"
"(https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html) است:"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"

#: src/unsafe-rust/unsafe-traits.md
#, fuzzy
msgid "// SAFETY: `u32` has a defined representation and no padding.\n"
msgstr "// SAFETY: `u32` has a defined representation and no padding.\n"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"باید یک بخش `# Safety` در Rustdoc برای این صفت (trait) وجود داشته باشد که "
"شرایط لازم برای اجرای ایمن این trait را توضیح دهد."

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr "بخش ایمنی واقعی برای `AsBytes`  نسبتا طولانی‌تر و پیچیده‌تر است."

#: src/unsafe-rust/unsafe-traits.md
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "ویژگی‌های داخلی`Send` و `Sync`  ناامن (unsafe) هستند."

#: src/unsafe-rust/exercise.md
msgid "Safe FFI Wrapper"
msgstr "امن بودن FFI Wrapper"

#: src/unsafe-rust/exercise.md
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"زبان Rust پشتیبانی بسیار خوبی برای فراخوانی توابع از طریق رابط تابع خارجی "
"_foreign function interface_ (FFI) دارد. ما از آن برای ساختن یک پوشش امن "
"برای توابع `libc` استفاده می‌کنیم که از C برای خواندن نام فایل ها در یک فهرست "
"استفاده می کنید."

#: src/unsafe-rust/exercise.md
msgid "You will want to consult the manual pages:"
msgstr "شما می‌خواهید به صفحات راهنما مراجعه کنید:"

#: src/unsafe-rust/exercise.md
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr "همچنین می‌خواهید [`std::ffi`](https://doc.rust-lang.or) را مرور کنید"

#: src/unsafe-rust/exercise.md
msgid "Encoding"
msgstr "رمزگذاری"

#: src/unsafe-rust/exercise.md
msgid "Use"
msgstr "استفاده"

#: src/unsafe-rust/exercise.md
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) و [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md
msgid "UTF-8"
msgstr "UTF-8"

#: src/unsafe-rust/exercise.md
msgid "Text processing in Rust"
msgstr "پردازش متن در Rust"

#: src/unsafe-rust/exercise.md
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md
msgid "NUL-terminated"
msgstr "NUL-terminated"

#: src/unsafe-rust/exercise.md
msgid "Communicating with C functions"
msgstr "ارتباط با توابع C"

#: src/unsafe-rust/exercise.md
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) و [`OsString`]"
"(https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md
msgid "OS-specific"
msgstr "مخصوص سیستم‌عامل"

#: src/unsafe-rust/exercise.md
msgid "Communicating with the OS"
msgstr "برقراری ارتباط با سیستم‌عامل"

#: src/unsafe-rust/exercise.md
msgid "You will convert between all these types:"
msgstr "شما بین تمام این typeها تبدیل خواهید کرد:"

#: src/unsafe-rust/exercise.md
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""

#: src/unsafe-rust/exercise.md
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"`CString` به `*const i8`: برای فراخوانی توابع C به یک اشاره‌گر نیاز دارید,"

#: src/unsafe-rust/exercise.md
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"از `*const i8` به `&CStr`: به چیزی نیاز دارید که بتواند کاراکتر `\\0` را "
"پیدا کند,"

#: src/unsafe-rust/exercise.md
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr` به `&[u8]`: یک slice بایت universal interface  برای «برخی داده‌های "
"ناشناخته» است،"

#: src/unsafe-rust/exercise.md
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"از `&[u8]` به `&OsStr`: `&OsStr` گامی به سوی `OsString` است، از [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) برای ایجاد "
"آن استفاده کنید،"

#: src/unsafe-rust/exercise.md
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""

#: src/unsafe-rust/exercise.md
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"مورد [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) همچنین یک فصل "
"بسیار مفید در مورد FFI دارد."

#: src/unsafe-rust/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"کد زیر را در <https://play.rust-lang.org/> کپی کنید و توابع و متدهای از "
"مفقود شده را پر کنید:"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"macos\""
msgstr "\"macos\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr "// Layout according to the macOS man page for dir(5).\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"readdir$INODE64\""
msgstr "\"readdir$INODE64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"

#: src/unsafe-rust/exercise.md
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr "// Keep calling readdir until we get a NULL pointer back.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#, fuzzy
msgid "// Call closedir as needed.\n"
msgstr "// Call closedir as needed.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#: src/android/interoperability/with-c/rust.md
msgid "\".\""
msgstr "\".\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"files: {:#?}\""
msgstr "\"files: {:#?}\""

#: src/unsafe-rust/solution.md
msgid "\"Invalid path: {err}\""
msgstr "\"مسیر نامعتبر: {err}\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr "// SAFETY: path.as_ptr() cannot be NULL.\n"

#: src/unsafe-rust/solution.md
msgid "\"Could not open {:?}\""
msgstr "\"نمی‌توان {:?} را باز کرد\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// We have reached the end of the directory.\n"
msgstr "// We have reached the end of the directory.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr "// SAFETY: self.dir is not NULL.\n"

#: src/unsafe-rust/solution.md
msgid "\"Could not close {:?}\""
msgstr "\"نمی‌توان {:?} را ببندد\""

#: src/unsafe-rust/solution.md
msgid "\"no-such-directory\""
msgstr "\"نه مشابه این دایرکتوری\""

#: src/unsafe-rust/solution.md
msgid "\"Non UTF-8 character in path\""
msgstr "\"نویسه غیر UTF-8 در مسیر\""

#: src/unsafe-rust/solution.md
msgid "\"..\""
msgstr "\"..\""

#: src/unsafe-rust/solution.md
msgid "\"foo.txt\""
msgstr "\"foo.txt\""

#: src/unsafe-rust/solution.md
msgid "\"The Foo Diaries\\n\""
msgstr "\"این خاطرات Foo است \\n\""

#: src/unsafe-rust/solution.md
msgid "\"bar.png\""
msgstr "\"bar.png\""

#: src/unsafe-rust/solution.md
msgid "\"<PNG>\\n\""
msgstr "\"<PNG>\\n\""

#: src/unsafe-rust/solution.md
msgid "\"crab.rs\""
msgstr "\"crab.rs\""

#: src/unsafe-rust/solution.md
msgid "\"//! Crab\\n\""
msgstr "\"//! Crab\\n\""

#: src/android.md
msgid "Welcome to Rust in Android"
msgstr "به Rust در Android خوش‌آمدید"

#: src/android.md
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"‏ Rust برای system software در اندروید پشتیبانی می‌شود. این بدان معناست که می "
"توانید سرویس‌ها، کتابخانه‌‌ها، درایورها یا حتی سیستم‌عامل جدید را در Rust "
"بنویسید (یا در صورت نیاز کدهای موجود را بهبود ببخشید)."

#: src/android.md
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"ما امروز سعی خواهیم کرد Rust را از یکی از پروژه‌های خودتان فراخوانی کنیم. "
"بنابراین سعی کنید گوشه کوچکی از پایه کد خود را پیدا کنید تا بتوانیم برخی از "
"خطوط کد را به Rust منتقل کنیم. هر چه وابستگی‌ها و انواع \"exotic\" کمتر باشد "
"برای ما بهتر است. چیزی که برخی از بایت‌های خام را تجزیه کند ایده آل خواهد بود."

#: src/android.md
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr ""
"با‌توجه‌به افزایش استفاده از Rust در اندروید، سخنران ممکن است به یکی از موارد "
"زیر اشاره کند:"

#: src/android.md
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""
"‏ مثال سرویس: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"

#: src/android.md
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""
"کتابخانه‌ها: [Rutabaga Virtual Graphics Interface]‌(https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"

#: src/android.md
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"

#: src/android.md
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"

#: src/android/setup.md
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"ما از یک دستگاه Cuttlefish Android Virtual برای آزمایش کد خود استفاده خواهیم "
"کرد. مطمئن شوید که به یکی از آنها دسترسی دارید یا یک مورد جدید ایجاد کنید:"

#: src/android/setup.md
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"لطفاً برای جزئیات به [Android Developer Codelab]‌(https://source.android.com/"
"docs/setup/start) مراجعه کنید."

#: src/android/setup.md
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""
"‏ Cuttlefish یک Android device مرجع است که برای کار بر روی دسکتاپ های لینوکس "
"عمومی طراحی شده است. پشتیبانی از MacOS نیز برنامه‌ریزی شده است."

#: src/android/setup.md
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""
"این Cuttlefish system image تعهد بالایی به دستگاه‌های واقعی دارد و شبیه‌ساز "
"ایده آل برای اجرای بسیاری از موارد استفاده از Rust است."

#: src/android/build-rules.md
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"‏ Android build system (Soong) از Rust از طریق تعدادی ماژول پشتیبانی می‌کند:"

#: src/android/build-rules.md
msgid "Module Type"
msgstr "Module Type"

#: src/android/build-rules.md
msgid "Description"
msgstr "توضیحات"

#: src/android/build-rules.md
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md
msgid "Produces a Rust binary."
msgstr "یک Rust binary تولید می‌کند."

#: src/android/build-rules.md
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"یک کتابخانه Rust تولید می‌کند و هر دو نوع `rlib` و `dylib` را ارائه می‌دهد."

#: src/android/build-rules.md
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"یک کتابخانه Rust C قابل استفاده توسط ماژول‌های `cc` تولید می‌کند و انواع "
"متغیرهای static و share را ارائه می‌کند."

#: src/android/build-rules.md
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"یک کتابخانه `proc-macro` تولید می‌کند. اینها مشابه پلاگین‌های کامپایلر هستند."

#: src/android/build-rules.md
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""
"یک باینری تست Rust تولید می‌کند که از استاندارد Rust test مهار شده استفاده "
"می‌کند."

#: src/android/build-rules.md
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "یک `libfuzzer` باینری Rust fuzz تولید می‌کند."

#: src/android/build-rules.md
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"یک source تولید می‌کند و یک کتابخانه Rust تولید می‌کند که یک interface برای یک "
"protobuf خاص فراهم می‌کند."

#: src/android/build-rules.md
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"یک source تولید می‌کند و یک کتابخانه Rust حاوی پیوندهای Rust به کتابخانه‌های C "
"تولید می‌کند."

#: src/android/build-rules.md
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "در ادامه به `rust_binary` و `rust_binary` نگاه خواهیم کرد."

#: src/android/build-rules.md
msgid "Additional items speaker may mention:"
msgstr "موارد دیگری که سخنران ممکن است ذکر کند:"

#: src/android/build-rules.md
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr ""
"‏ Cargo برای repoهای چند‌زبانه بهینه‌سازی نشده است و همچنین packageها را از "
"اینترنت دانلود می‌کند."

#: src/android/build-rules.md
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""
"برای انطباق و کارایی، اندروید باید crates in-tree داشته باشد. همچنین باید با "
"کد C/C++/Java همکاری داشته باشد. Soong این شکاف را پر می کند."

#: src/android/build-rules.md
#, fuzzy
msgid ""
"Soong has many similarities to [Bazel](https://bazel.build/), which is the "
"open-source variant of Blaze (used in google3)."
msgstr ""
"‏ Soong شباهت‌های زیادی به Bazel دارد که نوع open-source از Blaze است (مورد "
"استفاده در google3)."

#: src/android/build-rules.md
#, fuzzy
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr "واقعیت جالب: داده‌های Star Trek یک اندروید از نوع Soong است."

#: src/android/build-rules/binary.md
msgid "Rust Binaries"
msgstr "Rust Binaries"

#: src/android/build-rules/binary.md
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"اجازه دهید با یک برنامه ساده شروع کنیم. در ریشه یک AOSP، فایل های زیر را "
"ایجاد کنید:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md
msgid "\"hello_rust\""
msgstr "\"hello_rust\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#: src/android/logging.md
msgid "\"src/main.rs\""
msgstr "\"src/main.rs\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "//! Rust demo.\n"
msgstr "//! Rust demo.\n"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#, fuzzy
msgid "/// Prints a greeting to standard output.\n"
msgstr "/// Prints a greeting to standard output.\n"

#: src/android/build-rules/binary.md src/exercises/chromium/build-rules.md
msgid "\"Hello from Rust!\""
msgstr "\"سلام از Rust!\""

#: src/android/build-rules/binary.md
msgid "You can now build, push, and run the binary:"
msgstr "اکنون می‌توانید باینری را بسازید، push  و اجرا کنید:"

#: src/android/build-rules/binary.md
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"

#: src/android/build-rules/library.md
msgid "Rust Libraries"
msgstr "کتابخانه‌های Rust"

#: src/android/build-rules/library.md
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"شما از `rust_library` برای ایجاد یک کتابخانه Rust جدید برای Android استفاده "
"می‌کنید."

#: src/android/build-rules/library.md
msgid "Here we declare a dependency on two libraries:"
msgstr "در اینجا ما یک وابستگی به دو کتابخانه را اعلام می‌کنیم:"

#: src/android/build-rules/library.md
msgid "`libgreeting`, which we define below,"
msgstr "‏ `libgreeting`, چیزی که در زیر تعریف می‌کنیم,"

#: src/android/build-rules/library.md
#, fuzzy
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"‏`libtextwrap`، که این crates‌ای است که قبلاً در [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/) عرضه شده است."

#: src/android/build-rules/library.md
msgid "\"hello_rust_with_dep\""
msgstr "\"hello_rust_with_dep\""

#: src/android/build-rules/library.md
msgid "\"libgreetings\""
msgstr "\"libgreetings\""

#: src/android/build-rules/library.md
msgid "\"libtextwrap\""
msgstr "\"libtextwrap\""

#: src/android/build-rules/library.md
msgid "// Need this to avoid dynamic link error.\n"
msgstr "// Need this to avoid dynamic link error.\n"

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"greetings\""
msgstr "\"greetings\""

#: src/android/build-rules/library.md
#: src/android/aidl/example-service/service.md src/android/testing.md
#: src/android/interoperability/java.md
msgid "\"src/lib.rs\""
msgstr "\"src/lib.rs\""

#: src/android/build-rules/library.md
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md
#, fuzzy
msgid "//! Greeting library.\n"
msgstr "//! Greeting library.\n"

#: src/android/build-rules/library.md
msgid "/// Greet `name`.\n"
msgstr "/// Greet `name`.\n"

#: src/android/build-rules/library.md
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr "\"سلام {name}، از آشنایی با شما بسیار خوشحالم!\""

#: src/android/build-rules/library.md
msgid "You build, push, and run the binary like before:"
msgstr "باینری را مانند قبل می سازید، push و اجرا می‌کنید:"

#: src/android/build-rules/library.md
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"

#: src/android/aidl.md
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"‏[Android Interface Definition Language (AIDL)](https://developer.android.com/"
"guide/components/aidl) در Rust پشتیبانی می‌شود:"

#: src/android/aidl.md
msgid "Rust code can call existing AIDL servers,"
msgstr "کد Rust می تواند سرورهای AIDL موجود را فراخوانی کند,"

#: src/android/aidl.md
msgid "You can create new AIDL servers in Rust."
msgstr "می‌توانید سرورهای جدید AIDL را در Rust ایجاد کنید."

#: src/android/aidl/birthday-service.md
msgid ""
"To illustrate how to use Rust with Binder, we're going to walk through the "
"process of creating a Binder interface. We're then going to both implement "
"the described service and write client code that talks to that service."
msgstr ""
"برای نشان‌دادن نحوه استفاده از Rust با Binder، ما می‌خواهیم روند ایجاد رابط "
"Binder را بررسی کنیم. سپس هم سرویس توصیف‌شده را پیاده‌سازی می‌کنیم و هم کد "
"کلاینت را می‌نویسیم که با آن سرویس صحبت می‌کند."

#: src/android/aidl/example-service/interface.md
msgid "AIDL Interfaces"
msgstr "AIDL Interfaces"

#: src/android/aidl/example-service/interface.md
msgid "You declare the API of your service using an AIDL interface:"
msgstr "شما API سرویس خود را با استفاده از یک AIDL interface اعلام می‌کنید:"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#: src/android/aidl/example-service/changing-definition.md
msgid "/** Birthday service interface. */"
msgstr "/** Birthday service interface. */"

#: src/android/aidl/example-service/interface.md
#: src/android/aidl/example-service/service-bindings.md
#: src/android/aidl/example-service/changing-definition.md
msgid "/** Generate a Happy Birthday message. */"
msgstr "/** Generate a Happy Birthday message. */"

#: src/android/aidl/example-service/interface.md
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/example-service/interface.md
msgid "\"com.example.birthdayservice\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/example-service/interface.md
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr "\"com/example/birthdayservice/*.aidl\""

#: src/android/aidl/example-service/interface.md
msgid "// Rust is not enabled by default\n"
msgstr "// Rust is not enabled by default\n"

#: src/android/aidl/example-service/interface.md
msgid ""
"Note that the directory structure under the `aidl/` directory needs to match "
"the package name used in the AIDL file, i.e. the package is `com.example."
"birthdayservice` and the file is at `aidl/com/example/IBirthdayService.aidl`."
msgstr ""
"توجه داشته باشید که ساختار دایرکتوری زیر دایرکتوری `aidl/` باید با نام "
"package استفاده شده در فایل AIDL مطابقت داشته باشد، به‌عنوان‌مثال بسته `com."
"example.birthdayservice` بوده و این فایل در `aidl/com/example/"
"IBirthdayService.aidl` است."

#: src/android/aidl/example-service/service-bindings.md
msgid "Generated Service API"
msgstr "Generated Service API"

#: src/android/aidl/example-service/service-bindings.md
msgid ""
"Binder generates a trait corresponding to the interface definition. trait to "
"talk to the service."
msgstr ""
"Binder یک trait مطابق با تعریف interface تولید می‌کند. trait برای صحبت کردن "
"با سرویس است."

#: src/android/aidl/example-service/service-bindings.md
msgid "_Generated trait_:"
msgstr "_Generated trait_:"

#: src/android/aidl/example-service/service-bindings.md
msgid ""
"Your service will need to implement this trait, and your client will use "
"this trait to talk to the service."
msgstr ""
"سرویس شما باید این trait را پیاده‌سازی کند و کلاینت شما از این ویژگی برای "
"صحبت با سرویس‌ها استفاده خواهد کرد."

#: src/android/aidl/example-service/service-bindings.md
msgid ""
"The generated bindings can be found at `out/soong/.intermediates/<path to "
"module>/`."
msgstr ""
"پیوندهای تولید شده را می توان در `out/soong/.intermediates/<path to module>/"
"` یافت."

#: src/android/aidl/example-service/service-bindings.md
msgid ""
"Point out how the generated function signature, specifically the argument "
"and return types, correspond the interface definition."
msgstr ""
"اشاره کنید که چگونه function signature تولید شده، به ویژه typeهای آرگومان و "
"بازگشتی، با تعریف interface مطابقت دارد."

#: src/android/aidl/example-service/service-bindings.md
msgid ""
"`String` for an argument results in a different Rust type than `String` as a "
"return type."
msgstr ""
"‏ `String` برای آرگومان منجر به type متفاوتی Rust نسبت به `String` به عنوان "
"type برگشتی می‌شود."

#: src/android/aidl/example-service/service.md
msgid "Service Implementation"
msgstr "پیاده‌سازی سرویس‌ها"

#: src/android/aidl/example-service/service.md
msgid "We can now implement the AIDL service:"
msgstr "اکنون می‌توانیم سرویس AIDL را پیاده‌سازی کنیم:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/changing-implementation.md
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/example-service/service.md
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "/// The `IBirthdayService` implementation.\n"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/changing-implementation.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr "\"Happy Birthday {name}, congratulations with the {years} years!\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
msgid "\"libbirthdayservice\""
msgstr "\"libbirthdayservice\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"birthdayservice\""
msgstr "\"birthdayservice\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
msgid "\"com.example.birthdayservice-rust\""
msgstr "\"com.example.birthdayservice-rust\""

#: src/android/aidl/example-service/service.md
#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
msgid "\"libbinder_rs\""
msgstr "\"libbinder_rs\""

#: src/android/aidl/example-service/service.md
msgid ""
"Point out the path to the generated `IBirthdayService` trait, and explain "
"why each of the segments is necessary."
msgstr ""
"به مسیر ایجاد  `IBirthdayService` trait  اشاره کنید و توضیح‌دهید که چرا هر یک "
"از بخش‌ها ضروری است."

#: src/android/aidl/example-service/service.md
msgid ""
"TODO: What does the `binder::Interface` trait do? Are there methods to "
"override? Where source?"
msgstr ""
"‏ TODO: trait وویژگی `binder::Interface` چه کاری انجام می‌دهد؟ آیا متد‌هایی "
"برای override وجود دارد؟ source کجاست؟"

#: src/android/aidl/example-service/server.md
msgid "AIDL Server"
msgstr "AIDL Server"

#: src/android/aidl/example-service/server.md
msgid "Finally, we can create a server which exposes the service:"
msgstr "در نهایت، می توانیم سروری ایجاد کنیم که سرویس را expose می‌کند:"

#: src/android/aidl/example-service/server.md
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "//! Birthday service.\n"
msgstr "//! Birthday service.\n"

#: src/android/aidl/example-service/server.md
msgid "/// Entry point for birthday service.\n"
msgstr "/// Entry point for birthday service.\n"

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"Failed to register service\""
msgstr "\"Failed to register service\""

#: src/android/aidl/example-service/server.md
#, fuzzy
msgid "\"birthday_server\""
msgstr "\"birthday_server\""

#: src/android/aidl/example-service/server.md
msgid "\"src/server.rs\""
msgstr "\"src/server.rs\""

#: src/android/aidl/example-service/server.md
#: src/android/aidl/example-service/client.md
msgid "// To avoid dynamic link error.\n"
msgstr "// To avoid dynamic link error.\n"

#: src/android/aidl/example-service/server.md
msgid ""
"The process for taking a user-defined service implementation (in this case "
"the `BirthdayService` type, which implements the `IBirthdayService`) and "
"starting it as a Binder service has multiple steps, and may appear more "
"complicated than students are used to if they've used Binder from C++ or "
"another language. Explain to students why each step is necessary."
msgstr ""
"فرآیند اجرای یک سرویس تعریف‌شده توسط کاربر (در این مورد نوع `BirthdayService` "
"که `IBirthdayService` را پیاده‌سازی می‌کند) و شروع آن به‌عنوان یک سرویس Binder "
"چند مرحله دارد و ممکن است پیچیده‌تر از آنچه دانش‌آموزان به آن عادت کرده‌اند به "
"نظر برسد. اگر آن‌ها از Binder برای C++ یا زبان دیگری استفاده کردند. به "
"دانش‌آموزان توضیح دهید که چرا هر مرحله لازم است."

#: src/android/aidl/example-service/server.md
msgid "Create an instance of your service type (`BirthdayService`)."
msgstr "نمونه‌ای از نوع سرویس خود (`BirthdayService`) ایجاد کنید."

#: src/android/aidl/example-service/server.md
msgid ""
"Wrap the service object in corresponding `Bn*` type (`BnBirthdayService` in "
"this case). This type is generated by Binder and provides the common Binder "
"functionality that would be provided by the `BnBinder` base class in C++. We "
"don't have inheritance in Rust, so instead we use composition, putting our "
"`BirthdayService` within the generated `BnBinderService`."
msgstr ""
"این service object را در `Bn*` type مربوطه قرار دهید (در این مورد،"
"`BnBirthdayService`). این نوع توسط Binder تولید می‌شود و عملکرد رایج Binder "
"را ارائه می‌کند که توسط کلاس پایه `BnBinder` در C++ ارائه می‌شود. ما در Rust "
"ارث‌بری یا inheritance نداریم، بنابراین در عوض از ترکیب composition می‌کنیم و "
"`BirthdayService` خود را در `BnBinderService` تولید شده قرار می‌دهیم."

#: src/android/aidl/example-service/server.md
msgid ""
"Call `add_service`, giving it a service identifier and your service object "
"(the `BnBirthdayService` object in the example)."
msgstr ""
"‏ `add_service` را فراخوانی کنید و به آن یک شناسه سرویس و شی‏ سرویس خود بدهید "
"(شی‏ «BnBirthdayService» در مثال)."

#: src/android/aidl/example-service/server.md
msgid ""
"Call `join_thread_pool` to add the current thread to Binder's thread pool "
"and start listening for connections."
msgstr ""
"‏ `join_thread_pool` را فراخوانی کنید تا thread فعلی را به Binder thread "
"اضافه کنید و شروع به گوش دادن برای connectionها کنید."

#: src/android/aidl/example-service/deploy.md
msgid "We can now build, push, and start the service:"
msgstr "اکنون می‌توانیم سرویس را بسازیم، push کنیم و شروع کنیم:"

#: src/android/aidl/example-service/deploy.md
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/example-service/deploy.md
msgid "In another terminal, check that the service runs:"
msgstr "در ترمینال دیگر، بررسی کنید که آیا سرویسی اجرا شود:"

#: src/android/aidl/example-service/deploy.md
msgid "You can also call the service with `service call`:"
msgstr "همچنین می‌توانید با `service call` با سرویس تماس بگیرید:"

#: src/android/aidl/example-service/client.md
msgid "AIDL Client"
msgstr "AIDL Client"

#: src/android/aidl/example-service/client.md
msgid "Finally, we can create a Rust client for our new service."
msgstr "در‌نهایت، ما می‌توانیم یک Rust client برای سرویس جدید خود ایجاد کنیم."

#: src/android/aidl/example-service/client.md
#: src/android/aidl/example-service/changing-implementation.md
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/example-service/client.md
msgid "/// Call the birthday service.\n"
msgstr "/// Call the birthday service.\n"

#: src/android/aidl/example-service/client.md src/android/aidl/types/objects.md
#: src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "\"Failed to connect to BirthdayService\""
msgstr "\"Failed to connect to BirthdayService\""

#: src/android/aidl/example-service/client.md
msgid "// Call the service.\n"
msgstr "// Call the service.\n"

#: src/android/aidl/example-service/client.md
msgid "\"{msg}\""
msgstr "\"{msg}\""

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"birthday_client\""
msgstr "\"birthday_client\""

#: src/android/aidl/example-service/client.md
#, fuzzy
msgid "\"src/client.rs\""
msgstr "\"src/client.rs\""

#: src/android/aidl/example-service/client.md
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "توجه داشته باشید که client به `libbirthdayservice` وابسته نیست."

#: src/android/aidl/example-service/client.md
msgid "Build, push, and run the client on your device:"
msgstr "کلاینت را در دستگاه خود بسازید، push کرده و اجرا کنید:"

#: src/android/aidl/example-service/client.md
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"

#: src/android/aidl/example-service/client.md
msgid ""
"`Strong<dyn IBirthdayService>` is the trait object representing the service "
"that the client has connected to."
msgstr ""
"‏`Strong<dyn IBirthdayService>` یک trait object است که نشان‌دهنده سرویسی است "
"که کلاینت به آن متصل شده است."

#: src/android/aidl/example-service/client.md
msgid ""
"`Strong` is a custom smart pointer type for Binder. It handles both an in-"
"process ref count for the service trait object, and the global Binder ref "
"count that tracks how many processes have a reference to the object."
msgstr ""
"‏ `Strong` یک نوع اشاره‌گر هوشمند سفارشی برای Binder است. هم تعداد ref های "
"درون فرآیندی (in-process) را برای سرویس trait object مدیریت می‌کند و هم "
"شمارنده global Binder را که تعداد فرآیندهایی را که به object ارجاع دارند را "
"ردیابی می‌کند."

#: src/android/aidl/example-service/client.md
msgid ""
"Note that the trait object that the client uses to talk to the service uses "
"the exact same trait that the server implements. For a given Binder "
"interface, there is a single Rust trait generated that both client and "
"server use."
msgstr ""
"توجه داشته باشید که trait object که کلاینت برای صحبت با سرویس استفاده می‌کند، "
"دقیقاً از همان ویژگی استفاده می‌کند که سرور پیاده‌سازی می‌کند. برای یک Binder "
"interface معین، یک trait یا ویژگی Rust ایجاد شده است که هم کلاینت و هم سرور "
"از آن استفاده می‌کنند."

#: src/android/aidl/example-service/client.md
msgid ""
"Use the same service identifier used when registering the service. This "
"should ideally be defined in a common crate that both the client and server "
"can depend on."
msgstr ""
"از همان شناسه سرویس استفاده شده در هنگام ثبت سرویس استفاده کنید. این به طور "
"ایده‌آل باید در یک crate مشترک تعریف شود که هم کلاینت و هم سرور می توانند به "
"آن وابسته باشند."

#: src/android/aidl/example-service/changing-definition.md
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"اجازه دهید API را با عملکرد بیشتری گسترش دهیم: می‌خواهیم به مشتریان اجازه "
"دهیم لیستی از خطوط را برای کارت تولد مشخص کنند:"

#: src/android/aidl/example-service/changing-definition.md
msgid "This results in an updated trait definition for `IBirthdayService`:"
msgstr "این منجر به یک تعریف ویژگی به روز شده برای `IBirthdayService` می‌شود:"

#: src/android/aidl/example-service/changing-definition.md
msgid ""
"Note how the `String[]` in the AIDL definition is translated as a "
"`&[String]` in Rust, i.e. that idiomatic Rust types are used in the "
"generated bindings wherever possible:"
msgstr ""
"توجه داشته باشید که چگونه `String[]`در تعریف AIDL به عنوان  `&[String]` در "
"Rust ترجمه می‌شود، به‌عنوان مثال از idiomatic Rust type در bindingهای تولید "
"شده تا جایی که ممکن است استفاده می‌شود:"

#: src/android/aidl/example-service/changing-definition.md
msgid "`in` array arguments are translated to slices."
msgstr "آرگومان های آرایه `in` به sliceها ترجمه می‌شوند."

#: src/android/aidl/example-service/changing-definition.md
msgid "`out` and `inout` args are translated to `&mut Vec<T>`."
msgstr "آرگومان‌های`out` و `inout` به  `&mut Vec<T>` ترجمه می‌شوند."

#: src/android/aidl/example-service/changing-definition.md
msgid "Return values are translated to returning a `Vec<T>`."
msgstr "مقادیر بازگشتی به بازگرداندن `Vec<T>` ترجمه می‌شوند."

#: src/android/aidl/example-service/changing-implementation.md
msgid "Updating Client and Service"
msgstr "به‌روزرسانی کلاینت و سرویس‌ها"

#: src/android/aidl/example-service/changing-implementation.md
msgid "Update the client and server code to account for the new API."
msgstr "کد سرویس کلاینت و سرور را برای حساب کردن API جدید به‌روز کنید."

#: src/android/aidl/example-service/changing-implementation.md
msgid "'\\n'"
msgstr "'\\n'"

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "\"Habby birfday to yuuuuu\""
msgstr "\"Habby birfday to yuuuuu\""

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid "\"And also: many more\""
msgstr "\"And also: many more\""

#: src/android/aidl/example-service/changing-implementation.md
#, fuzzy
msgid ""
"TODO: Move code snippets into project files where they'll actually be built?"
msgstr ""
"‏TODO: قطعات کد را به فایل‌های پروژه منتقل کنید، جایی که واقعاً ساخته می‌شوند؟"

#: src/android/aidl/types.md
msgid "Working With AIDL Types"
msgstr "کار با انواع AIDL"

#: src/android/aidl/types.md
msgid "AIDL types translate into the appropriate idiomatic Rust type:"
msgstr "انواع AIDL به نوع اصطلاحی Rust مناسب ترجمه می‌شوند:"

#: src/android/aidl/types.md
msgid "Primitive types map (mostly) to idiomatic Rust types."
msgstr ""
"انواع اولیه یا Primitive types (بیشتر) به idiomatic Rust type نگاشت می‌شوند."

#: src/android/aidl/types.md
msgid "Collection types like slices, `Vec`s and string types are supported."
msgstr ""
"انواع Collectionها مانند sliceها،`Vec` و  string typeها پشتیبانی می‌شوند."

#: src/android/aidl/types.md
msgid ""
"References to AIDL objects and file handles can be sent between clients and "
"services."
msgstr ""
"ارجاع به AIDL objects و دسته فایل‌ها را می‌توان بین clientها و سرویس‌ها ارسال "
"کرد."

#: src/android/aidl/types.md
msgid "File handles and parcelables are fully supported."
msgstr "دسته‌های فایل و بسته‌بندی‌ها به طور کامل پشتیبانی می‌شوند."

#: src/android/aidl/types/primitives.md
msgid "Primitive types map (mostly) idiomatically:"
msgstr ""
"انواع ابتدایی یا Primitive type (معمولاً) به صورت idiomatically نگاشت می‌شوند:"

#: src/android/aidl/types/primitives.md
msgid "AIDL Type"
msgstr "AIDL Type"

#: src/android/aidl/types/primitives.md src/android/aidl/types/arrays.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "Rust Type"
msgstr "Rust Type"

#: src/android/aidl/types/primitives.md
msgid "Note"
msgstr "نکته"

#: src/android/aidl/types/primitives.md
msgid "`boolean`"
msgstr "بولین‌ها`boolean`"

#: src/android/aidl/types/primitives.md
msgid "`byte`"
msgstr "`byte`"

#: src/android/aidl/types/primitives.md
msgid "`i8`"
msgstr "`i8`"

#: src/android/aidl/types/primitives.md
msgid "Note that bytes are signed."
msgstr "توجه داشته باشید که بایت‌ها امضا شده‌اند."

#: src/android/aidl/types/primitives.md
msgid "`u16`"
msgstr "`u16`"

#: src/android/aidl/types/primitives.md
msgid "Note the usage of `u16`, NOT `u32`."
msgstr "به استفاده از `u16` توجه کنید، نه `u32`."

#: src/android/aidl/types/primitives.md
msgid "`int`"
msgstr "`int`"

#: src/android/aidl/types/primitives.md
msgid "`i32`"
msgstr "`i32`"

#: src/android/aidl/types/primitives.md
msgid "`long`"
msgstr "`long`"

#: src/android/aidl/types/primitives.md
msgid "`i64`"
msgstr "`i64`"

#: src/android/aidl/types/primitives.md
msgid "`float`"
msgstr "`float`"

#: src/android/aidl/types/primitives.md
msgid "`f32`"
msgstr "`f32`"

#: src/android/aidl/types/primitives.md
msgid "`double`"
msgstr "`double`"

#: src/android/aidl/types/primitives.md
msgid "`f64`"
msgstr "`f64`"

#: src/android/aidl/types/arrays.md
msgid ""
"The array types (`T[]`, `byte[]`, and `List<T>`) get translated to the "
"appropriate Rust array type depending on how they are used in the function "
"signature:"
msgstr ""
"انواع آرایه (`T[]`, `byte[]`, و `List<T>`) بسته به نحوه استفاده از آنها در "
"function signature، به Rust array type  مناسب ترجمه می‌شوند:"

#: src/android/aidl/types/arrays.md
msgid "Position"
msgstr "موقعیت"

#: src/android/aidl/types/arrays.md
msgid "`in` argument"
msgstr "`in` argument"

#: src/android/aidl/types/arrays.md
msgid "`&[T]`"
msgstr "`&[T]`"

#: src/android/aidl/types/arrays.md
msgid "`out`/`inout` argument"
msgstr "`out`/`inout` argument"

#: src/android/aidl/types/arrays.md
msgid "`&mut Vec<T>`"
msgstr "`&mut Vec<T>`"

#: src/android/aidl/types/arrays.md
msgid "Return"
msgstr "Return"

#: src/android/aidl/types/arrays.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`Vec<T>`"
msgstr "`Vec<T>`"

#: src/android/aidl/types/arrays.md
msgid ""
"In Android 13 or higher, fixed-size arrays are supported, i.e. `T[N]` "
"becomes `[T; N]`. Fixed-size arrays can have multiple dimensions (e.g. "
"`int[3][4]`). In the Java backend, fixed-size arrays are represented as "
"array types."
msgstr ""
"در اندروید ۱۳ یا بالاتر، آرایه‌های با اندازه ثابت پشتیبانی می‌شوند، یعنی "
"`T[N]` به `[T; N]`. آرایه‌های با اندازه ثابت می‌توانند چندین بعد داشته باشند "
"(مانند ‌`int[3][4]`. در Java backend، آرایه‌های با اندازه ثابت به عنوان array "
"type نمایش داده می‌شوند."

#: src/android/aidl/types/arrays.md
msgid "Arrays in parcelable fields always get translated to `Vec<T>`."
msgstr "آرایه‌های موجود در فیلدهای parcelable همیشه به `Vec<T>` ترجمه می‌شوند."

#: src/android/aidl/types/objects.md
msgid ""
"AIDL objects can be sent either as a concrete AIDL type or as the type-"
"erased `IBinder` interface:"
msgstr ""
"‏ AIDL objects را می‌توان به‌عنوان یک نوع AIDL مشخص یا به عنوان `IBinder` "
"interface پاک‌شده ارسال کرد:"

#: src/android/aidl/types/objects.md
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider."
"aidl**:"
msgstr ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider."
"aidl**:"

#: src/android/aidl/types/objects.md src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl**:"
msgstr ""
"**birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl**:"

#: src/android/aidl/types/objects.md
msgid "/** The same thing, but using a binder object. */"
msgstr "/** The same thing, but using a binder object. */"

#: src/android/aidl/types/objects.md
msgid "/** The same thing, but using `IBinder`. */"
msgstr "/** The same thing, but using `IBinder`. */"

#: src/android/aidl/types/objects.md src/android/aidl/types/parcelables.md
#: src/android/aidl/types/file-descriptor.md
msgid "**birthday_service/src/client.rs**:"
msgstr "**birthday_service/src/client.rs**:"

#: src/android/aidl/types/objects.md
msgid "/// Rust struct implementing the `IBirthdayInfoProvider` interface.\n"
msgstr "/// Rust struct implementing the `IBirthdayInfoProvider` interface.\n"

#: src/android/aidl/types/objects.md
msgid "// Create a binder object for the `IBirthdayInfoProvider` interface.\n"
msgstr "// Create a binder object for the `IBirthdayInfoProvider` interface.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid "// Send the binder object to the service.\n"
msgstr "// SAFETY: `abs` doesn't have any safety requirements.\n"

#: src/android/aidl/types/objects.md
#, fuzzy
msgid ""
"// Perform the same operation but passing the provider as an `SpIBinder`.\n"
msgstr ""
"// Perform the same operation but passing the provider as an `SpIBinder`.\n"

#: src/android/aidl/types/objects.md
msgid ""
"Note the usage of `BnBirthdayInfoProvider`. This serves the same purpose as "
"`BnBirthdayService` that we saw previously."
msgstr ""
"به استفاده از `BnBirthdayInfoProvider` توجه کنید. این همان هدف "
"`BnBirthdayService` است که قبلاً دیدیم."

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid "Binder for Rust supports sending parcelables directly:"
msgstr "‏ Binder برای Rust از ارسال مستقیم بسته‌بندی‌ها پشتیبانی می‌کند:"

#: src/android/aidl/types/parcelables.md
msgid ""
"**birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl**:"
msgstr ""
"**birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl**:"

#: src/android/aidl/types/parcelables.md
#, fuzzy
msgid "/** The same thing, but with a parcelable. */"
msgstr "/** The same thing, but with a parcelable. */"

#: src/android/aidl/types/file-descriptor.md
msgid ""
"Files can be sent between Binder clients/servers using the "
"`ParcelFileDescriptor` type:"
msgstr ""
"فایل‌ها را می‌توان با استفاده از نوع `ParcelFileDescriptor` بین کلاینت‌ها/"
"سرورهای Binder ارسال کرد:"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "/** The same thing, but loads info from a file. */"
msgstr "/** The same thing, but loads info from a file. */"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "// Open a file and put the birthday info in it.\n"
msgstr "// Open a file and put the birthday info in it.\n"

#: src/android/aidl/types/file-descriptor.md
msgid "\"/data/local/tmp/birthday.info\""
msgstr "\"/data/local/tmp/birthday.info\""

#: src/android/aidl/types/file-descriptor.md
msgid "\"{name}\""
msgstr "\"{name}\""

#: src/android/aidl/types/file-descriptor.md
msgid "\"{years}\""
msgstr "\"{years}\""

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid "// Create a `ParcelFileDescriptor` from the file and send it.\n"
msgstr "// Create a `ParcelFileDescriptor` from the file and send it.\n"

#: src/android/aidl/types/file-descriptor.md
msgid "**birthday_service/src/lib.rs**:"
msgstr "**birthday_service/src/lib.rs**:"

#: src/android/aidl/types/file-descriptor.md
#, fuzzy
msgid ""
"// Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps\n"
"        // an `OwnedFd`, which can be cloned and then used to create a "
"`File`\n"
"        // object.\n"
msgstr ""
"// Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps\n"
"        // an `OwnedFd`, which can be cloned and then used to create a "
"`File`\n"
"        // object.\n"

#: src/android/aidl/types/file-descriptor.md
msgid "\"Invalid file handle\""
msgstr "\"کنترل فایل نامعتبر\""

#: src/android/aidl/types/file-descriptor.md
msgid ""
"`ParcelFileDescriptor` wraps an `OwnedFd`, and so can be created from a "
"`File` (or any other type that wraps an `OwnedFd`), and can be used to "
"create a new `File` handle on the other side."
msgstr ""
"‏ `ParcelFileDescriptor` یک `OwnedFd` را احاطه می‌کند و بنابراین می‌تواند از یک "
"`File` (یا هر نوع دیگری که یک `OwnedFd` را احاطه می‌کند) ایجاد کند و می‌تواند "
"برای ایجاد یک دسته `File` جدید در طرف دیگر استفاده شود."

#: src/android/aidl/types/file-descriptor.md
msgid ""
"Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and "
"UNIX sockets."
msgstr ""
"انواع دیگر توصیف‌گرهای فایل را می توان بسته‌بندی و ارسال کرد، به‌عنوان‌مثال. "
"سوکت های TCP، UDP و UNIX."

#: src/android/testing.md
msgid "Testing in Android"
msgstr "تست‌کردن در Android"

#: src/android/testing.md
msgid ""
"Building on [Testing](../testing.md), we will now look at how unit tests "
"work in AOSP. Use the `rust_test` module for your unit tests:"
msgstr ""
"بر اساس [Testing](../testing.md)، اکنون به نحوه عملکرد unit testها در AOSP "
"خواهیم پرداخت. از ماژول `rust_test` برای تست های واحد خود استفاده کنید:"

#: src/android/testing.md
msgid "_testing/Android.bp_:"
msgstr "_testing/Android.bp_:"

#: src/android/testing.md
msgid "\"libleftpad\""
msgstr "\"libleftpad\""

#: src/android/testing.md
msgid "\"leftpad\""
msgstr "leftpad\""

#: src/android/testing.md
msgid "\"libleftpad_test\""
msgstr "\"libleftpad_test\""

#: src/android/testing.md
msgid "\"leftpad_test\""
msgstr "\"leftpad_test\""

#: src/android/testing.md src/android/interoperability/with-c/bindgen.md
msgid "\"general-tests\""
msgstr "\"general-tests\""

#: src/android/testing.md
msgid "_testing/src/lib.rs_:"
msgstr "_testing/src/lib.rs_:"

#: src/android/testing.md
#, fuzzy
msgid "//! Left-padding library.\n"
msgstr "//! Left-padding library.\n"

#: src/android/testing.md
#, fuzzy
msgid "/// Left-pad `s` to `width`.\n"
msgstr "/// Left-pad `s` to `width`.\n"

#: src/android/testing.md
msgid "\"{s:>width$}\""
msgstr "\"{s:>width$}\""

#: src/android/testing.md
msgid "\"  foo\""
msgstr "\"  foo\""

#: src/android/testing.md
msgid "\"foobar\""
msgstr "\"foobar\""

#: src/android/testing.md
msgid "You can now run the test with"
msgstr "اکنون می توانید تست را با"

#: src/android/testing.md
msgid "The output looks like this:"
msgstr "خروجی به شکل زیر است:"

#: src/android/testing.md
msgid ""
"```text\n"
"INFO: Elapsed time: 2.666s, Critical Path: 2.40s\n"
"INFO: 3 processes: 2 internal, 1 linux-sandbox.\n"
"INFO: Build completed successfully, 3 total actions\n"
"//comprehensive-rust-android/testing:libleftpad_test_host            PASSED "
"in 2.3s\n"
"    PASSED  libleftpad_test.tests::long_string (0.0s)\n"
"    PASSED  libleftpad_test.tests::short_string (0.0s)\n"
"Test cases: finished with 2 passing and 0 failing out of 2 test cases\n"
"```"
msgstr ""
"```text\n"
"INFO: Elapsed time: 2.666s, Critical Path: 2.40s\n"
"INFO: 3 processes: 2 internal, 1 linux-sandbox.\n"
"INFO: Build completed successfully, 3 total actions\n"
"//comprehensive-rust-android/testing:libleftpad_test_host            PASSED "
"in 2.3s\n"
"    PASSED  libleftpad_test.tests::long_string (0.0s)\n"
"    PASSED  libleftpad_test.tests::short_string (0.0s)\n"
"Test cases: finished with 2 passing and 0 failing out of 2 test cases\n"
"```"

#: src/android/testing.md
msgid ""
"Notice how you only mention the root of the library crate. Tests are found "
"recursively in nested modules."
msgstr ""
"توجه کنید که چگونه فقط ریشه crate کتابخانه را ذکر می‌کنید. تست‌ها به صورت "
"بازگشتی در ماژول‌های تودرتو یافت می‌شوند."

#: src/android/testing/googletest.md
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"جعبه [GoogleTest](https://docs.rs/googletest/) با استفاده از _matchers_ "
"اجازه می‌دهد تا assertهای آزمایشی انعطاف‌پذیر را انجام دهید:"

#: src/android/testing/googletest.md
msgid "\"baz\""
msgstr "\"baz\""

#: src/android/testing/googletest.md
msgid "\"xyz\""
msgstr "\"xyz\""

#: src/android/testing/googletest.md
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""
"اگر آخرین عنصر را به`\"!\"`تغییر دهیم، آزمایش با یک پیغام خطای ساختار یافته "
"که خطا را pin-pointing می‌کند، شکست می خورد:"

#: src/android/testing/googletest.md
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""
"‏ GoogleTest بخشی از Rust Playground نیست، بنابراین باید این مثال را در یک "
"محیط local اجرا کنید. برای افزودن سریع آن به پروژه Cargo موجود، از `cargo "
"add googletest` استفاده کنید."

#: src/android/testing/googletest.md
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""
"خط `use googletest::prelude::*;` تعدادی از  [ماکروها و typeهای پرکاربرد]"
"(https://docs.rs/googletest/latest/googletest/prelude/index.html) را وارد "
"می‌کند."

#: src/android/testing/googletest.md
#, fuzzy
msgid ""
"This just scratches the surface, there are many builtin matchers. Consider "
"going through the first chapter of [\"Advanced testing for Rust "
"applications\"](https://rust-exercises.com/advanced-testing/), a self-guided "
"Rust course: it provides a guided introduction to the library, with "
"exercises to help you get comfortable with `googletest` macros, its matchers "
"and its overall philosophy."
msgstr ""
"این فقط سطح را نشان می‌دهد، تطبیق‌های داخلی زیادی وجود دارد. فصل اول [‌آزمایش "
"پیشرفته برای برنامه های Rust]‌(https://github.com/mainmatter/rust-advanced-"
"testing-workshop)، یک دوره آموزشی Rust را در نظر بگیرید: این یک مقدمه "
"راهنمایی برای کتابخانه با تمرین‌هایی که به شما کمک می‌کند با ماکروهای "
"`googletest` و مطابقت‌های آن و فلسفه کلی آن راحت باشید."

#: src/android/testing/googletest.md
msgid ""
"A particularly nice feature is that mismatches in multi-line strings are "
"shown as a diff:"
msgstr ""
"یک ویژگی خاص خوب این است که عدم تطابق در string‌های چند خطی به صورت یک تفاوت "
"نشان داده می شود:"

#: src/android/testing/googletest.md
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""

#: src/android/testing/googletest.md
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""

#: src/android/testing/googletest.md
msgid "shows a color-coded diff (colors not shown here):"
msgstr "تفاوت رنگی را نشان می‌دهد (رنگ ها در اینجا نشان‌داده نمی‌شوند):"

#: src/android/testing/googletest.md
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""
"این crate یک پورت [GoogleTest for C++]‌(https://google.github.io/googletest/) "
"در Rust است."

#: src/android/testing/mocking.md
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""
"برای mocking از  [Mockall](https://docs.rs/mockall/) که یک کتابخانه محبوب "
"بوده استفاده شده است. برای استفاده از traitها، باید کد خود را مجدداً تغییر "
"دهید، سپس می‌توانید به سرعت آنها را mock کنید:"

#: src/android/testing/mocking.md
msgid ""
"Mockall is the recommended mocking library in Android (AOSP). There are "
"other [mocking libraries available on crates.io](https://crates.io/keywords/"
"mock), in particular in the area of mocking HTTP services. The other mocking "
"libraries work in a similar fashion as Mockall, meaning that they make it "
"easy to get a mock implementation of a given trait."
msgstr ""
"‏ Mockall کتابخانه mocking توصیه شده در Android (AOSP) است. [کتابخانه‌های "
"mocking دیگری در crates.io](https://crates.io/keywords/mock) در دسترس هستند، "
"به‌ویژه در زمینه سرویس‌های mocking HTTP. سایر کتابخانه‌های mocking به روشی "
"مشابه Mockall کار می‌کنند، به این معنی که اجرای ساختگی یا mock یک ویژگی خاص "
"را آسان می‌کنند."

#: src/android/testing/mocking.md
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""
"توجه داشته باشید که mocking تا حدودی _جنجال_برانگیز_ است: mockها به شما این "
"امکان را می‌دهند که آزمون را کاملاً از وابستگی‌های آن جدا کنید. نتیجه فوری آن، "
"اجرای سریع‌تر و پایدارتر تست است. از طرف دیگر، mockها را می توان به اشتباه "
"پیکربندی کرد و خروجی متفاوتی با آنچه وابستگی های واقعی انجام می دادند را "
"برگرداند."

#: src/android/testing/mocking.md
#, fuzzy
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""
"در صورت امکان، توصیه می‌شود از وابستگی‌های واقعی استفاده کنید. به عنوان مثال، "
"بسیاری از پایگاه‌داده‌ها به شما اجازه می‌دهند تا یک in-memory backend را "
"پیکربندی کنید. این به این معنی است که شما در تست های خود رفتار صحیح را "
"دریافت می کنید، به علاوه آنها سریع هستند و به طور خودکار پس از اجرای عملیات "
"مخصوص به خود پاک می شوند."

#: src/android/testing/mocking.md
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""
"به‌طور‌ مشابه، بسیاری از frameworkهای وب به شما اجازه می‌دهند یک سرور در یک "
"process دیگر راه‌اندازی کنید که به یک پورت تصادفی در `localhost` متصل می‌شود. "
"همیشه این را به mock کردن framework ترجیح دهید زیرا به شما کمک می‌کند کد خود "
"را در محیط واقعی آزمایش کنید."

#: src/android/testing/mocking.md
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""
"‏ Mockall بخشی از Rust Playground نیست، بنابراین باید این مثال را در یک محیط "
"local اجرا کنید. از  `cargo add mockall` برای اضافه کردن سریع Mockall به "
"پروژه Cargo موجود استفاده کنید."

#: src/android/testing/mocking.md
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""
"‏ Mockall عملکرد بسیار بیشتری دارد. به ویژه، می‌توانید انتظاراتی را تنظیم کنید "
"که به استدلال های ارائه شده بستگی دارد. در اینجا ما از این برای mock کردن "
"عملکرد cat استفاده می‌کنیم که 3 ساعت پس از آخرین باری که به آن غذا داده شده "
"گرسنه می‌شود:"

#: src/android/testing/mocking.md
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""
"می‌توانید از `.times(n)` برای محدود‌کردن تعداد دفعاتی که یک mock method "
"می‌تواند به`n` فراخوانی شود استفاده کنید --- در صورت عدم ارضای این روش، زمانی "
"که آن را حذف کنید به‌طور خودکار دچار panic می‌شود."

#: src/android/logging.md
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"باید از  `log` crate  برای ورود خودکار به`logcat` (روی دستگاه) یا `stdout` "
"(روی host) استفاده کنید:"

#: src/android/logging.md
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md
msgid "\"hello_rust_logs\""
msgstr "\"hello_rust_logs\""

#: src/android/logging.md
msgid "\"liblog_rust\""
msgstr "\"liblog_rust\""

#: src/android/logging.md
msgid "\"liblogger\""
msgstr "\"liblogger\""

#: src/android/logging.md
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md
#, fuzzy
msgid "//! Rust logging demo.\n"
msgstr "//! Rust logging demo.\n"

#: src/android/logging.md
#, fuzzy
msgid "/// Logs a greeting.\n"
msgstr "/// Logs a greeting.\n"

#: src/android/logging.md
msgid "\"rust\""
msgstr "\"rust\""

#: src/android/logging.md
msgid "\"Starting program.\""
msgstr "\"شروع برنامه.\""

#: src/android/logging.md
msgid "\"Things are going fine.\""
msgstr "\"کارها خوب پیش می‌رود.\""

#: src/android/logging.md
#, fuzzy
msgid "\"Something went wrong!\""
msgstr "\"Something went wrong!\""

#: src/android/logging.md src/android/interoperability/with-c/bindgen.md
#: src/android/interoperability/with-c/rust.md
msgid "Build, push, and run the binary on your device:"
msgstr "ساخت، push و اجرای باینری‌ها روی یک ماشین:"

#: src/android/logging.md
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md
msgid "The logs show up in `adb logcat`:"
msgstr "لاگ‌ها در `adb logcat` نشان‌داده می‌شوند:"

#: src/android/interoperability.md
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"‏‌Rust از قابلیت همکاری با زبان‌های دیگر پشتیبانی می‌کند. این بدان معنی است که "
"شما می‌توانید:"

#: src/android/interoperability.md
msgid "Call Rust functions from other languages."
msgstr "توابع Rust را از زبان های دیگر فراخوانی کنید."

#: src/android/interoperability.md
msgid "Call functions written in other languages from Rust."
msgstr "فراخوانی توابع نوشته شده به زبان های دیگر از Rust."

#: src/android/interoperability.md
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"وقتی توابعی را به‌ یک زبان خارجی فراخوانی می‌کنید، می‌گوییم که از یک رابط تابع "
"خارج( _foreign function interface_) که به نام FFI نیز شناخته می‌شود، استفاده "
"می‌کنید."

#: src/android/interoperability/with-c.md
msgid "Interoperability with C"
msgstr "قابلیت همکاری با C"

#: src/android/interoperability/with-c.md
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"‏ Rust پشتیبانی کاملی برای link دادن object fileهایی با یک  فراخوانی C دارد. "
"به طور مشابه، می توانید توابع Rust را export کرده و آنها را از C فراخوانی "
"کنید."

#: src/android/interoperability/with-c.md
msgid "You can do it by hand if you want:"
msgstr "در صورت تمایل می‌توانید این کار را دستی انجام دهید:"

#: src/android/interoperability/with-c.md
#, fuzzy
msgid "// SAFETY: `abs` doesn't have any safety requirements.\n"
msgstr "// SAFETY: `abs` doesn't have any safety requirements.\n"

#: src/android/interoperability/with-c.md
msgid "\"{x}, {abs_x}\""
msgstr "\"{x}, {abs_x}\""

#: src/android/interoperability/with-c.md
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../unsafe-rust/"
"exercise.md)."
msgstr ""
"ما قبلاً این را در [تمرین Safe FFI Wrapper](../../unsafe-rust/exercise.md) "
"دیدیم."

#: src/android/interoperability/with-c.md
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"این مستلزم آگاهی کامل از پلتفرم هدف است و برای production توصیه نمی‌شود."

#: src/android/interoperability/with-c.md
msgid "We will look at better options next."
msgstr "در ادامه گزینه‌های بهتر را بررسی خواهیم کرد."

#: src/android/interoperability/with-c/bindgen.md
msgid "Using Bindgen"
msgstr "با استفاده از Bindgen"

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"ابزار [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"می‌تواند اتصالات را از یک فایل هدر C به طور خودکار ایجاد کند."

#: src/android/interoperability/with-c/bindgen.md
msgid "First create a small C library:"
msgstr "ابتدا یک کتابخانه کوچک C ایجاد کنید:"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "<stdio.h>"
msgstr "<stdio.h>"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday.h\""
msgstr "\"libbirthday.h\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"+--------------\\n\""
msgstr "\"+--------------\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"| Happy Birthday %s!\\n\""
msgstr "\"| Happy Birthday %s!\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"| Congratulations with the %i years!\\n\""
msgstr "\"| Congratulations with the %i years!\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "Add this to your `Android.bp` file:"
msgstr "این را به فایل `Android.bp` خود اضافه کنید:"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperability/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday\""
msgstr "\"libbirthday\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday.c\""
msgstr "\"libbirthday.c\""

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"یک فایل هدر wrapper برای کتابخانه ایجاد کنید (در این مثال به شدت مورد نیاز "
"نیست):"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "You can now auto-generate the bindings:"
msgstr "اکنون می توانید اتصالات (bindings) را به طور خودکار ایجاد کنید:"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday_bindgen\""
msgstr "\"libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"birthday_bindgen\""
msgstr "\"birthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday_wrapper.h\""
msgstr "\"libbirthday_wrapper.h\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"bindings\""
msgstr "\"bindings\""

#: src/android/interoperability/with-c/bindgen.md
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "در نهایت، می‌توانیم از bindingها در برنامه Rust خود استفاده کنیم:"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"print_birthday_card\""
msgstr "\"چاپ_کارت_تولد\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"main.rs\""
msgstr "\"main.rs\""

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "//! Bindgen demo.\n"
msgstr "//! Bindgen demo.\n"

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"// SAFETY: The pointer we pass is valid because it came from a Rust\n"
"    // reference, and the `name` it contains refers to `name` above which "
"also\n"
"    // remains valid. `print_card` doesn't store either pointer to use "
"later\n"
"    // after it returns.\n"
msgstr ""
"// SAFETY: The pointer we pass is valid because it came from a Rust\n"
"    // reference, and the `name` it contains refers to `name` above which "
"also\n"
"    // remains valid. `print_card` doesn't store either pointer to use "
"later\n"
"    // after it returns.\n"

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"در نهایت، ما می‌توانیم تست‌های تولید شده خودکار را برای اطمینان از کارکرد "
"اتصالات (bindings) اجرا کنیم:"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday_bindgen_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\":libbirthday_bindgen\""
msgstr "\":libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"none\""
msgstr "\"none\""

#: src/android/interoperability/with-c/bindgen.md
msgid "// Generated file, skip linting\n"
msgstr "// Generated file, skip linting\n"

#: src/android/interoperability/with-c/rust.md
msgid "Calling Rust"
msgstr "فراخوانی Rust"

#: src/android/interoperability/with-c/rust.md
msgid "Exporting Rust functions and types to C is easy:"
msgstr "صدور یا Exporting توابع و تایپ‌ها از Rust به C آسان است:"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md
msgid "//! Rust FFI demo.\n"
msgstr "//! Rust FFI demo.\n"

#: src/android/interoperability/with-c/rust.md
msgid "/// Analyze the numbers.\n"
msgstr "/// Analyze the numbers.\n"

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"x ({x}) is smallest!\""
msgstr "\"x ({x}) is smallest!\""

#: src/android/interoperability/with-c/rust.md
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr "\" مقدارy  ({y}) احتمالا بزرگتر از x ({x}) است\""

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"libanalyze_ffi\""
msgstr "\"libanalyze_ffi\""

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze_ffi\""
msgstr "\"analyze_ffi\""

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze.rs\""
msgstr "\"analyze.rs\""

#: src/android/interoperability/with-c/rust.md
msgid "We can now call this from a C binary:"
msgstr "اکنون می توانیم این را از یک باینری C فراخوانی کنیم:"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze.h\""
msgstr "\"analyze.h\""

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze_numbers\""
msgstr "\"analyze_numbers\""

#: src/android/interoperability/with-c/rust.md
msgid "\"main.c\""
msgstr "\"main.c\""

#: src/android/interoperability/with-c/rust.md
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` نام‌گذاری معمول Rust را غیرفعال می‌کند، بنابراین نماد صادر شده "
"فقط نام تابع خواهد بود. همچنین می‌توانید از `#[export_name = \"some_name\"]` "
"برای تعیین هر نامی استفاده کنید."

#: src/android/interoperability/cpp.md
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"این [CXX crate](https://cxx.rs/) امکان همکاری امن بین Rust و C++ را فراهم "
"می‌کند."

#: src/android/interoperability/cpp.md
msgid "The overall approach looks like this:"
msgstr "رویکرد کلی به این صورت است:"

#: src/android/interoperability/cpp/bridge.md
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""
"‏ CXX متکی به توصیفی از signatureهای تابع است که از هر زبان به زبان دیگر در "
"معرض دید قرار می‌گیرد. شما این توضیحات را با استفاده از بلوک‌های خارجی در یک "
"ماژول Rust ارائه می‌کنید که با attribute ماکروها `#[cxx::bridge]`  شرح داده "
"شده است."

#: src/android/interoperability/cpp/bridge.md
msgid "\"org::blobstore\""
msgstr "\"org::blobstore\""

#: src/android/interoperability/cpp/bridge.md
msgid "// Shared structs with fields visible to both languages.\n"
msgstr "// Shared structs with fields visible to both languages.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
msgid "// Rust types and signatures exposed to C++.\n"
msgstr "// Rust types and signatures exposed to C++.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#: src/android/interoperability/cpp/rust-result.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "\"Rust\""
msgstr "\"Rust\""

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#, fuzzy
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr "// C++ types and signatures exposed to Rust.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/android/interoperability/cpp/cpp-exception.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "\"C++\""
msgstr "\"C++\""

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"include/blobstore.h\""
msgstr "\"include/blobstore.h\""

#: src/android/interoperability/cpp/bridge.md
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr "پل به طور کلی در یک ماژول `ffi`در crate شما اعلام می‌شود."

#: src/android/interoperability/cpp/bridge.md
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""
"از اعلان‌های (declarations) انجام شده در ماژول پل، CXX تعاریف مطابق با type/"
"function در Rust و ++C را ایجاد می‌کند تا آن موارد را در معرض هر دو زبان قرار "
"دهد."

#: src/android/interoperability/cpp/bridge.md
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""
"برای مشاهده کد Rust ایجاد شده از [cargo-expand](https://github.com/dtolnay/"
"cargo-expand) که برای مشاهده ماکرو proc توسعه یافته استفاده کنید. برای بیشتر "
"نمونه‌ها از `cargo expand ::ffi` فقط برای گسترش ماژول `ffi` استفاده کنید "
"(اگرچه این برای پروژه‌های Android کاربرد ندارد)."

#: src/android/interoperability/cpp/bridge.md
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr "برای مشاهده کد  ++C  تولید شده به `target/cxxbridge` نگاه کنید."

#: src/android/interoperability/cpp/rust-bridge.md
msgid "Rust Bridge Declarations"
msgstr "تعریف پل در Rust"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "// Opaque type\n"
msgstr "// Opaque type\n"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "// Method on `MyType`\n"
msgstr "// Method on `MyType`\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Free function\n"
msgstr "توابع"

#: src/android/interoperability/cpp/rust-bridge.md
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""
"موارد اعلام شده در موارد  `extern \"Rust\"` reference که در محدوده ماژول "
"والد قرار دارند."

#: src/android/interoperability/cpp/rust-bridge.md
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""
"تولیدکننده کد CXX از `extern \"Rust\"` خارجی شما برای تولید یک فایل هدر  +"
"+C  حاوی اعلان‌های  ++C  مربوطه استفاده می‌کند. header تولید‌شده همان مسیری را "
"دارد که فایل منبع Rust حاوی پل دارای آن است، به جز استفاده از پسوند فایل rs."
"h."

#: src/android/interoperability/cpp/generated-cpp.md
msgid "Results in (roughly) the following C++:"
msgstr "نتیجه (تقریبی) ++C در زیر است:"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "C++ Bridge Declarations"
msgstr "C++ Bridge Declarations"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "Results in (roughly) the following Rust:"
msgstr "نتیجه (تقریبی) Rust در زیر است:"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr "\"org$blobstore$cxxbridge1$new_blobstore_client\""

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""

#: src/android/interoperability/cpp/cpp-bridge.md
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""
"برنامه‌نویس نیازی به تضمینی در مورد درست بودن signatureهایی که تایپ کرده است "
"ندارد. CXX اظهارات ثابتی را انجام می دهد که signatureها دقیقاً با آنچه در ++C "
"اعلام شده مطابقت دارند."

#: src/android/interoperability/cpp/cpp-bridge.md
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""
"بلوک‌های `unsafe extern` به شما امکان می‌دهند توابع ++C را که برای فراخوانی از "
"Rust امن هستند را اعلام کنید."

#: src/android/interoperability/cpp/shared-types.md
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr "// A=1, J=11, Q=12, K=13\n"

#: src/android/interoperability/cpp/shared-types.md
msgid "Only C-like (unit) enums are supported."
msgstr "فقط C-like (unit) enums پشتیبانی می‌شود."

#: src/android/interoperability/cpp/shared-types.md
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""
"تعداد محدودی از ویژگی‌ها برای `#[derive()]`در انواع مشترک پشتیبانی می‌شوند. "
"عملکرد مربوطه نیز برای کد ++C ایجاد می شود، به عنوان مثال. اگر `Hash` را "
"استخراج کنید، پیاده‌سازی `std::hash` برای نوع ++C مربوطه نیز ایجاد می‌کند."

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated Rust:"
msgstr "Generated Rust:"

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated C++:"
msgstr "Generated C++:"

#: src/android/interoperability/cpp/shared-enums.md
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""
"در سمت Rust، کد تولید شده برای enums مشترک در واقع ساختاری است که یک مقدار "
"عددی را بسته‌بندی می‌کند. به این دلیل که UB در ++C نیست تا یک کلاس enum مقداری "
"متفاوت از همه انواع فهرست شده داشته باشد و نمایش‌دهنده Rust مورد نظر ما باید "
"رفتار مشابهی داشته باشد."

#: src/android/interoperability/cpp/rust-result.md
msgid "\"fallible1 requires depth > 0\""
msgstr "\"fallible1 به عمق > 0 نیاز دارد\""

#: src/android/interoperability/cpp/rust-result.md
msgid "\"Success!\""
msgstr "\"Success!\""

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr ""
"توابع Rust که «نتیجه» را برمی‌گردانند به exceptionهای سمت  ++C  ترجمه می‌شوند."

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""
"این exception به وقوع پیوسته همیشه از نوع `rust::Error` خواهد بود که در درجه "
"اول راهی برای دریافت string پیام خطا نشان می‌دهد. پیغام خطا از نوع "
"خطای`Display` می‌آید."

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""
"باز شدن panic از Rust به ++C همیشه باعث می‌شود که فرآیند بلافاصله خاتمه یابد."

#: src/android/interoperability/cpp/cpp-exception.md
msgid "\"example/include/example.h\""
msgstr "\"example/include/example.h\""

#: src/android/interoperability/cpp/cpp-exception.md
msgid "\"Error: {}\""
msgstr "\"Error: {}\""

#: src/android/interoperability/cpp/cpp-exception.md
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""
"توابع ++C اعلام شده (declared) برای برگرداندن `Result`، هر exception صورت "
"گرفته شده در سمت ++C را می‌گیرند و آن را به عنوان مقدار `Err` به تابع "
"فراخوانی Rust برمی‌گردانند."

#: src/android/interoperability/cpp/cpp-exception.md
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""
"اگر یک exception از یک  extern \"C++\" function که توسط پل CXX برای بازگشت "
"\"نتیجه\" اعلان نشده است، ایجاد شود، برنامه C++'  `std::terminate` را "
"فراخوانی می‌کند. این رفتار معادل همان exception است که از طریق یک `noexcept` "
"C++ function فعال می‌شود."

#: src/android/interoperability/cpp/type-mapping.md
msgid "C++ Type"
msgstr "C++ Type"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::String`"
msgstr "`rust::String`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Str`"
msgstr "`rust::Str`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`CxxString`"
msgstr "`CxxString`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`std::string`"
msgstr "`std::string`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&[T]`/`&mut [T]`"
msgstr "`&[T]`/`&mut [T]`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Slice`"
msgstr "`rust::Slice`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Box<T>`"
msgstr "`rust::Box<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`UniquePtr<T>`"
msgstr "`UniquePtr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`std::unique_ptr<T>`"
msgstr "`std::unique_ptr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Vec<T>`"
msgstr "`rust::Vec<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`CxxVector<T>`"
msgstr "`CxxVector<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`std::vector<T>`"
msgstr "`std::vector<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""
"این typeها را می‌توان در فیلدهای ساختارهای مشترک و آرگومان‌ها و extern "
"functionها استفاده کرد."

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""
"توجه داشته باشید که  `String` در Rust مستقیماً به `std::string` نگاشت نمی‌شود. "
"چند دلیل برای این وجود دارد:"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr ""
"‏`std::string` ثابت UTF-8 را که  `String` به آن نیاز دارد را پشتیبانی نمی‌کند."

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""
"این دو نوع طرح‌بندی‌های متفاوتی در حافظه دارند و بنابراین نمی‌توان آنها را "
"مستقیماً بین زبان‌ها منتقل کرد."

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""
"‏ `std::string` به سازنده‌های حرکتی نیاز دارد که با معنای حرکت Rust مطابقت "
"ندارند، بنابراین `std::string` نمی‌تواند با مقدار به Rust منتقل شود."

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
msgid "Building in Android"
msgstr "ساخت در اندروید"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""
"یک `cc_library_static` برای ساخت کتابخانه ++C از جمله هدر و فایل منبع تولید "
"شده CXX ایجاد کنید."

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"libcxx_test_cpp\""
msgstr "\"libcxx_test_cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid "\"cxx_test.cpp\""
msgstr "\"cxx_test.cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid "\"cxx-bridge-header\""
msgstr "\"cxx-bridge-header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"libcxx_test_bridge_header\""
msgstr "\"libcxx_test_bridge_header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"libcxx_test_bridge_code\""
msgstr "\"libcxx_test_bridge_code\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""
"به این نکته اشاره کنید که `libcxx_test_bridge_header` و  "
"`libcxx_test_bridge_code` وابستگی‌هایی برای پیوندهای ++C تولید شده توسط CXX ​​"
"هستند. نحوه تنظیم اینها را در اسلاید بعدی نشان خواهیم داد."

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""
"توجه داشته باشید که برای ایجاد تعاریف رایج CXX باید به کتابخانه `cxx-bridge-"
"header` وابسته باشید."

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""
"مستندات کامل برای استفاده از CXX در Android را می‌توانید در این آدرس پیدا "
"کنید [the Android docs](https://source.android.com/docs/setup/build/rust/"
"building-rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx). "
"ممکن است بخواهید آن پیوند را با کلاس به اشتراک بگذارید تا دانش‌آموزان بدانند "
"که در آینده می‌توانند این دستورالعمل‌ها را دوباره پیدا کنند."

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""
"دو نوع ژانر ایجاد کنید: یکی برای تولید هدر CXX و دیگری برای تولید فایل منبع "
"CXX. سپس از اینها به عنوان ورودی `cc_library_static` استفاده می‌شود."

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"cxxbridge\""
msgstr "\"cxxbridge\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr "\"$(location cxxbridge) $(in) --header > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"lib.rs\""
msgstr "\"lib.rs\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"lib.rs.h\""
msgstr "\"lib.rs.h\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr "// Generate the C++ code that Rust calls into.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr "\"$(location cxxbridge) $(in) > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"lib.rs.cc\""
msgstr "\"lib.rs.cc\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""
"ابزار`cxxbridge` یک ابزار مستقل است که سمت ++C ماژول پل را تولید می‌کند. در "
"Android گنجانده شده و به عنوان ابزار Soong در دسترس است."

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""
"طبق قرارداد، اگر فایل منبع Rust شما `lib.rs` باشد، فایل header شما `lib.rs."
"h` و فایل منبع شما  `lib.rs.cc` نام خواهد داشت. اگرچه این قرارداد نامگذاری "
"اجرا نمی‌شود."

#: src/android/interoperability/cpp/android-build-rust.md
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr ""
"یک`rust_binary` ایجاد کنید که به `libcxx` و `cc_library_static` شما بستگی "
"دارد."

#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"cxx_test\""
msgstr "\"cxx_test\""

#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"libcxx\""
msgstr "\"libcxx\""

#: src/android/interoperability/java.md
msgid "Interoperability with Java"
msgstr "قابلیت همکاری با جاوا"

#: src/android/interoperability/java.md
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"جاوا می‌تواند objectهای مشترک را از طریق [واسط بومی جاوا [Java Native "
"Interface (JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface) "
"بارگیری کند.  [`jni` crate](https://docs.rs/jni/) به شما امکان می دهد یک "
"کتابخانه سازگار ایجاد کنید."

#: src/android/interoperability/java.md
msgid "First, we create a Rust function to export to Java:"
msgstr "ابتدا یک تابع Rust برای export به Java ایجاد می‌کنیم:"

#: src/android/interoperability/java.md
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "//! Rust <-> Java FFI demo.\n"
msgstr "//! Rust <-> Java FFI demo.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "/// HelloWorld::hello method implementation.\n"
msgstr "/// HelloWorld::hello method implementation.\n"

#: src/android/interoperability/java.md
msgid "\"system\""
msgstr "\"system\""

#: src/android/interoperability/java.md
msgid "\"Hello, {input}!\""
msgstr "\"سلام, {input}!\""

#: src/android/interoperability/java.md
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md
msgid "\"libhello_jni\""
msgstr "\"libhello_jni\""

#: src/android/interoperability/java.md
msgid "\"hello_jni\""
msgstr "\"hello_jni\""

#: src/android/interoperability/java.md
msgid "\"libjni\""
msgstr "\"libjni\""

#: src/android/interoperability/java.md
msgid "We then call this function from Java:"
msgstr "سپس این تابع را از جاوا فراخوانی می کنیم:"

#: src/android/interoperability/java.md
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md
msgid "\"helloworld_jni\""
msgstr "\"helloworld_jni\""

#: src/android/interoperability/java.md
msgid "\"HelloWorld.java\""
msgstr "سلام دنیا\"HelloWorld.java\""

#: src/android/interoperability/java.md
msgid "\"HelloWorld\""
msgstr "\"HelloWorld\""

#: src/android/interoperability/java.md
msgid "Finally, you can build, sync, and run the binary:"
msgstr "در نهایت، می‌توانید باینری را بسازید، همگام‌سازی کنید و اجرا کنید:"

#: src/exercises/android/morning.md
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"این یک تمرین گروهی است: ما به یکی از پروژه‌هایی که با آن کار می‌کنید نگاه "
"می‌کنیم و سعی می‌کنیم مقداری Rust را در آن ادغام کنیم. چند پیشنهاد:"

#: src/exercises/android/morning.md
msgid "Call your AIDL service with a client written in Rust."
msgstr "با سرویس AIDL خود با کلاینت که در Rust نوشته شده است تماس بگیرید."

#: src/exercises/android/morning.md
msgid "Move a function from your project to Rust and call it."
msgstr "یک تابع را از پروژه خود به Rust منتقل کنید و آن را فراخوانی کنید."

#: src/exercises/android/morning.md
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"هیچ راه‌حلی در اینجا ارائه نشده است زیرا این مورد باز است: به فردی در کلاس "
"متکی است که یک قطعه کد دارد که می توانید آن را به Rust on fly تبدیل کنید."

#: src/chromium.md
msgid "Welcome to Rust in Chromium"
msgstr "به Rust در Chromium خوش‌آمدید"

#: src/chromium.md
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""
"‏ Rust برای کتابخانه‌های شخص ثالث در Chromium پشتیبانی می‌شود، با glue code اول "
"شخص برای اتصال بین Rust و کد موجود در ++Chromium C."

#: src/chromium.md
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""
"امروز ما با Rust ارتباط می‌گیریم تا کار احمقانه‌ای با stringها انجام دهد. اگر "
"گوشه‌ای از کد را دارید که در آن رشته UTF8 را به کاربر نشان می دهید، به جای "
"قسمت دقیقی که در مورد آن صحبت می‌کنیم، این دستور العمل را در قسمت خود از "
"پایگاه کد دنبال کنید."

#: src/chromium/setup.md
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""
"مطمئن شوید که می‌توانید Chromium را build و اجرا کنید. هر پلتفرم و مجموعه‌ای "
"از build flag ها بدون مشکل هستند، تا زمانی که کد شما نسبتاً جدید باشد (موقعیت "
"commit 1223636 به بعد، مربوط به نوامبر 2023):"

#: src/chromium/setup.md
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr ""
"(یک component به صورت debug build برای سریع‌ترین زمان تکرار توصیه می‌شود. این "
"یک حالت پیش‌فرض است!)"

#: src/chromium/setup.md
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""
"اگر از قبل در آن مرحله نیستید، به [چگونه Chromium بسازیم](https://www."
"chromium.org/developers/how-tos/get-the-code/) مراجعه کنید. هشدار: راه‌اندازی "
"برای build Chromium زمان زیادی می‌برد."

#: src/chromium/setup.md
msgid "It's also recommended that you have Visual Studio code installed."
msgstr "همچنین توصیه می شود که Visual Studio code را نصب کرده باشید."

#: src/chromium/setup.md
msgid "About the exercises"
msgstr "در مورد تمرین‌ها"

#: src/chromium/setup.md
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""
"این بخش از دوره دارای یک سری تمرینات است که بر روی یکدیگر ساخته می‌شوند. ما "
"آنها را به جای اینکه فقط در انتها انجام دهیم، در طول دوره پخش خواهیم کرد. "
"اگر برای تکمیل قسمت خاصی وقت ندارید، نگران نباشید: می توانید در اسلاید بعدی "
"به عقب برگردید."

#: src/chromium/cargo.md
msgid ""
"The Rust community typically uses `cargo` and libraries from [crates.io]"
"(https://crates.io/). Chromium is built using `gn` and `ninja` and a curated "
"set of dependencies."
msgstr ""
"جامعه Rust معمولاً از `cargo` و کتابخانه‌های [crates.io](https://crates.io/) "
"استفاده می‌کند. Chromium با استفاده از `gn` و `ninja` و مجموعه‌ای از وابستگی‌ها "
"ساخته شده است."

#: src/chromium/cargo.md
msgid "When writing code in Rust, your choices are:"
msgstr "هنگام نوشتن کد در Rust، انتخاب‌های شما عبارتند از:"

#: src/chromium/cargo.md
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""
"از `gn` و `ninja`  با کمک الگوهای `//build/rust/*.gni` استفاده کنید (مثلاً "
"`rust_static_library` که بعداً با آن آشنا خواهیم شد). این از toolchain و "
"crateهای بررسی‌شده Chromium استفاده می‌کند."

#: src/chromium/cargo.md
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""
"از `cargo` استفاده کنید، اما [خود را به toolchain و crateهای بررسی‌شده "
"Chromium محدود کنید](https://chromium.googlesource.com/chromium/src/+/refs/"
"heads/main/docs/rust.md#Using-cargo)"

#: src/chromium/cargo.md
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""
"از `cargo` استفاده کنید، به یک [toolchain](https://rustup.rs/) و/یا "
"[crateهای دانلود شده از اینترنت]‌(https://crates.io/) اعتماد کنید."

#: src/chromium/cargo.md
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""
"از اینجا به بعد ما روی `gn` و `ninja` تمرکز خواهیم کرد، زیرا به این ترتیب "
"می‌توان کد Rust را در مرورگر Chromium ایجاد کرد. در عین حال، Cargo بخش مهمی "
"از اکوسیستم Rust است و شما باید آن را در جعبه ابزار خود نگه دارید."

#: src/chromium/cargo.md
msgid "Mini exercise"
msgstr "خرده تمرین"

#: src/chromium/cargo.md
msgid "Split into small groups and:"
msgstr "به گروه‌های کوچک تقسیم شده و:"

#: src/chromium/cargo.md
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr ""
"سناریوهای طوفان فکری که در آن `cargo` ممکن است مزیتی را ارائه دهد و نمایه "
"ریسک‌های این سناریوها را ارزیابی کند."

#: src/chromium/cargo.md
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""
"در هنگام استفاده از `gn` و `ninja`و `cargo` آفلاین و غیره در مورد ابزارها، "
"کتابخانه‌ها و گروه‌هایی از افراد بحث کنید."

#: src/chromium/cargo.md
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""
"از دانش‌آموزان بخواهید که قبل از اتمام تمرین از نگاه کردن به یادداشت‌های "
"سخنران خودداری کنند. با فرض اینکه افرادی که دوره را می‌گذرانند از نظر فیزیکی "
"با هم هستند، از آنها بخواهید در گروه های کوچک ۳-۴ نفره بحث کنند."

#: src/chromium/cargo.md
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr ""
"نکته‌ها/تکنیک‌ها مربوط به بخش اول تمرین (\"سناریوهایی که Cargo ممکن است مزیتی "
"را ارائه دهد\"):"

#: src/chromium/cargo.md
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""
"این فوق العاده است که هنگام نوشتن یک ابزار یا نمونه‌سازی بخشی از Chromium به "
"اکوسیستم غنی کتابخانه‌های crates.io دسترسی داشته باشید. تقریباً برای هر چیزی "
"یک crate وجود دارد و معمولاً استفاده از آنها بسیار لذت بخش است. (`clap` برای "
"تجزیه خط فرمان، `serde` برای سریال‌سازی/جداسازی‌سریال به/از قالب‌های مختلف، "
"`itertools` برای کار با تکرارکننده‌ها (iterators) و غیره)."

#: src/chromium/cargo.md
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""
"‏ `cargo` بررسی کردن یک کتابخانه را آسان می‌کند (فقط یک خط به `Cargo.toml` "
"اضافه کنید و شروع به نوشتن کد کنید)"

#: src/chromium/cargo.md
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""
"شاید ارزش این را داشته باشد که چگونه CPAN به انتخاب `perl` کمک کرد. یا "
"مقایسه با `python` + `pip`."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""
"تجربه توسعه نه تنها با ابزارهای اصلی Rust (به عنوان مثال استفاده از `rustup` "
"برای تغییر به نسخه `rustc` متفاوت در هنگام آزمایش crate ای که نیاز به کار بر "
"روی پایداری‌های شبانه، فعلی و قدیمی‌تر دارد) بسیار خوب است، بلکه توسط یک "
"اکوسیستم نیز انجام می‌شود. از ابزارهای شخص ثالث (مثلاً موزیلا `cargo vet` را "
"برای ساده‌سازی و اشتراک‌گذاری ممیزی‌های امنیتی فراهم می‌کند؛ `criterion` crate "
"راهی ساده برای اجرای benchmark‌ها می‌دهد)."

#: src/chromium/cargo.md
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""
"‏ `cargo` افزودن ابزارها را از طریق`cargo install --locked cargo-vet` تسهیل "
"می‌کند."

#: src/chromium/cargo.md
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr ""
"ممکن است ارزش مقایسه با برنامه‌های افزودنی کروم یا افزونه‌های VScode را داشته "
"باشد."

#: src/chromium/cargo.md
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr ""
"نمونه‌های کلی و عمومی از پروژه‌هایی که `cargo` ممکن است انتخاب مناسبی باشد:"

#: src/chromium/cargo.md
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""
"شاید تعجب‌آور باشد که Rust به طور فزاینده ای در صنعت برای نوشتن ابزارهای خط "
"فرمان محبوب می‌شود. گستردگی و ارگونومی کتابخانه‌ها با پایتون قابل مقایسه است، "
"درحالی‌که قوی‌تر (به لطف تایپ سیستم غنی) است و سریعتر کار می‌کند (به عنوان یک "
"زبان کامپایل شده و نه مفسری)."

#: src/chromium/cargo.md
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""
"مشارکت در اکوسیستم Rust مستلزم استفاده از ابزار استاندارد Rust مانند Cargo "
"است. کتابخانه‌هایی که می‌خواهند مشارکت‌های خارجی دریافت کنند و می‌خواهند خارج از "
"Chromium استفاده شوند (مثلاً در محیط‌های ساخت Bazel یا Android/Soong) احتمالاً "
"باید از Cargo استفاده کنند."

#: src/chromium/cargo.md
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr "نمونه‌هایی از پروژه‌های مرتبط با Chromium که مبتنی بر `cargo` هستند:"

#: src/chromium/cargo.md
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""
"‏ `serde_json_lenient` (در قسمت‌های دیگر Google آزمایش شده  که منجر به PRهایی "
"با بهبود در عملکرد می‌باشد.)"

#: src/chromium/cargo.md
msgid "Fontations libraries like `font-types`"
msgstr "کتابخانه‌های فونت مانند `font-types`"

#: src/chromium/cargo.md
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""
"ابزار `gnrt` (ما بعداً در دوره با آن آشنا خواهیم شد) که برای تجزیه خط فرمان "
"به `clap` و برای فایل‌های پیکربندی به `toml` بستگی دارد."

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain."
msgstr ""
"سلب مسئولیت: یک دلیل منحصر به فرد برای استفاده از `cargo` در دسترس نبودن "
"`gn` در هنگام ساخت و راه‌اندازی کتابخانه استاندارد Rust درحین ساخت Rust "
"toolchain بود."

#: src/chromium/cargo.md
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, but `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""
"‏ `run_gnrt.py` از کپی Chromium از `cargo` و `rustc` استفاده می‌کند.`gnrt` به "
"کتابخانه‌های شخص ثالثی بستگی دارد که از اینترنت دانلود شده‌اند، اما  `run_gnrt."
"py`  از `cargo` می‌پرسد که فقط محتوای `--locked` از طریق `Cargo.lock` مجاز "
"است.)"

#: src/chromium/cargo.md
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr ""
"دانش‌آموزان ممکن است موارد زیر را به طور ضمنی یا صریح مورد اعتماد تشخیص‌دهند:"

#: src/chromium/cargo.md
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""
"`rustc` (کامپایلر Rust) که به نوبه خود به کتابخانه‌های LLVM، کامپایلر Clang، "
"منابع `rustc` (برگرفته از GitHub، بررسی شده توسط تیم کامپایلر Rust) وابسته "
"است، کامپایلر Rust باینری که برای راه‌اندازی بارگیری (bootstrapping) شده است"

#: src/chromium/cargo.md
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""
"‏ `rustup` (شاید شایان ذکر است که  `rustup` زیر چتر سازمان https://github.com/"
"rust-lang/ - همانند `rustc` توسعه یافته است)"

#: src/chromium/cargo.md
msgid "`cargo`, `rustfmt`, etc."
msgstr "`cargo`, `rustfmt`,سایر موارد."

#: src/chromium/cargo.md
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""
"زیرساخت‌های داخلی مختلف (ربات‌هایی که `rustc` می‌سازند، سیستمی برای توزیع "
"toolchain از پیش‌ساخته شده بین مهندسان Chromium و بقیغ)"

#: src/chromium/cargo.md
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr "ابزار Cargo مانند `cargo audit`، `cargo vet` و غیره."

#: src/chromium/cargo.md
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""
"کتابخانه‌های Rust در `//third_party/rust` عرضه شده است (بازرسی شده توسط "
"security@chromium.org)"

#: src/chromium/cargo.md
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr "سایر کتابخانه‌های Rust (بعضی خاص، برخی کاملاً محبوب و پرکاربرد)"

#: src/chromium/policy.md
msgid "Chromium Rust policy"
msgstr "رویکرد Chromium Rust"

#: src/chromium/policy.md
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""
"‏ Chromium هنوز Rust شخص اول را مجاز نمی‌کند، مگر در موارد نادر که توسط [Area "
"Tech Leads](https://source.chromium.org/chromium/chromium/src/+/main:"
"ATL_OWNERS) تأیید شده است."

#: src/chromium/policy.md
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""
"رویکردهای Chromium در مورد کتابخانه‌های شخص ثالث [اینجا](https://chromium."
"googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#rust) "
"مشخص شده است. Rust برای کتابخانه‌های شخص ثالث تحت شرایط مختلف مجاز است، از "
"جمله اینکه آیا آنها بهترین گزینه برای کارایی بالا یا موارد امنیتی هستند."

#: src/chromium/policy.md
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""
"تعداد بسیار کمی از کتابخانه‌های Rust مستقیماً یک C/C++ API را در معرض دید "
"(expose) قرار می‌دهند، به این معنی که تقریباً همه این کتابخانه‌ها به مقدار کمی "
"glue code اول شخص نیاز دارند."

#: src/chromium/policy.md
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/chromium/policy.md
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""
"کد Rust glue اول شخص برای یک crate شخص ثالث خاص معمولاً باید در `third_party/"
"rust/<crate>/<version>/wrapper` نگهداری شود."

#: src/chromium/policy.md
msgid "Because of this, today's course will be heavily focused on:"
msgstr "به‌همین دلیل، دوره‌ی امروز به شدت بر روی موارد زیر متمرکز خواهد شد:"

#: src/chromium/policy.md
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr "آوردن کتابخانه های Rust شخص ثالث (\"crates\")"

#: src/chromium/policy.md
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr ""
"نوشتن glue code برای اینکه بتوانید به کمک آن crateها از ++Chromium C استفاده "
"کنید."

#: src/chromium/policy.md
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr ""
"اگر این رویکرد در طول زمان تغییر کند، این دوره به گونه‌ای تکامل می‌یابد که در "
"مسیر مناسب ادامه یابد."

#: src/chromium/build-rules.md
msgid "Build rules"
msgstr "قوانین Build"

#: src/chromium/build-rules.md
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""
"کد Rust معمولاً با استفاده از `cargo` ساخته می‌شود. Chromium با  `gn` و "
"`ninja` جهت کارایی بیشتر ساخته می‌شود --- قواعد استاتیک آن حداکثر موازی‌سازی "
"را امکان‌پذیر می‌سازد. Rust نیز از این قاعده مستثنی نیست."

#: src/chromium/build-rules.md
msgid "Adding Rust code to Chromium"
msgstr "افزودن کد Rust به Chromium"

#: src/chromium/build-rules.md
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr ""
"در برخی از فایل‌های موجود `BUILD.gn` یک `rust_static_library` را اعلام کنید:"

#: src/chromium/build-rules.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules.md
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""
"همچنین می‌توانید `deps` را روی سایر اهداف Rust اضافه کنید. بعداً از این برای "
"وابستگی به کد شخص ثالث استفاده خواهیم کرد."

#: src/chromium/build-rules.md
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""
"شما باید هر دوی crate root و فهرست کامل منابع را مشخص کنید. `crate_root` "
"فایلی است که به کامپایلر Rust داده می‌شود که نشان‌دهنده فایل ریشه واحد کامپایل "
"است --- معمولاً به‌نام `lib.rs` است. همینطور `sources` فهرست کاملی از تمام "
"فایل‌های منبعی است که  `ninja` برای تعیین زمان لازم برای بازسازی به آن‌ها نیاز "
"دارد."

#: src/chromium/build-rules.md
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""
"(چیزی به نام Rust `source_set` وجود ندارد، زیرا در Rust، تمامی crate یک واحد "
"جمع‌آوری است. `static_library` کوچک‌ترین واحد است.)"

#: src/chromium/build-rules.md
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""
"دانش‌آموزان ممکن است تعجب کنند که چرا به جای استفاده از [پشتیبانی داخلی gn "
"برای کتابخانه‌های استاتیک Rust](https://gn.googlesource.com/gn/+/main/docs/"
"reference.md#func_static_library) به یک الگوی gn نیاز داریم. پاسخ این است که "
"این الگو از CXX interop، ویژگی‌های Rust و تست‌های واحد پشتیبانی می‌کند که بعداً "
"از برخی از آنها استفاده خواهیم کرد."

#: src/chromium/build-rules/unsafe.md
msgid "Including `unsafe` Rust Code"
msgstr "شامل کد `unsafe` Rust"

#: src/chromium/build-rules/unsafe.md
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""
"کد ناامن Rust به طور پیش‌فرض در  `rust_static_library` غیرمجاز است --- "
"کامپایل نمی‌شود. اگر به کد unsafe Rust نیاز دارید، `allow_unsafe = true` را "
"به هدف gn اضافه کنید. (بعداً در دوره ما شرایطی را خواهیم دید که در آن لازم "
"است.)"

#: src/chromium/build-rules/unsafe.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"

#: src/chromium/build-rules/depending.md
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr "به سادگی هدف بالا را به `deps` برخی از اهداف Chromium C++ اضافه کنید."

#: src/chromium/build-rules/depending.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules/vscode.md
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""
"تایپ‌ها در کد Rust حذف شده اند که باعث می‌شود یک IDE خوب حتی مفیدتر از++C "
"باشد. کد ویژوال استودیو برای Rust در Chromium به خوبی کار می کند و برای "
"استفاده از آن،"

#: src/chromium/build-rules/vscode.md
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""
"اطمینان حاصل کنید که VSCode شما دارای extension `rust-analyzer` است، نه "
"فرم‌های قبلی پشتیبانی از Rust"

#: src/chromium/build-rules/vscode.md
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr ""
"‏ `gn gen out/Debug --export-rust-project` (یا معادل آن برای دایرکتوری خروجی "
"شما)"

#: src/chromium/build-rules/vscode.md
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr "`ln -s out/Debug/rust-project.json rust-project.json`"

#: src/chromium/build-rules/vscode.md
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""
"اگر مخاطب به طور طبیعی نسبت به IDE‌ها علاقه نداشته باشد، نمایش برخی از "
"ویژگی‌های code annotation و کاوش در rust-analyzer می‌تواند مفید باشد."

#: src/chromium/build-rules/vscode.md
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""
"مراحل زیر ممکن است به نسخه نمایشی کمک کند (اما در عوض از یک قطعه Rust مربوط "
"به Chromium که بیشتر با آن آشنا هستید استفاده کنید):"

#: src/chromium/build-rules/vscode.md
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr ""
"‏ `components/qr_code_generator/qr_code_generator_ffi_glue.rs` را باز کنید"

#: src/chromium/build-rules/vscode.md
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""
"مکان نما را روی فراخوانی `QrCode::new` (حدود خط 26) در "
"\\`qr_code_generator_ffi_glue.rs قرار دهید"

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""
"نسخه‌ی نمایشی **نمایش مستندات ** (typical bindings: vscode = ctrl k i; vim/"
"CoC = K)."

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""
"نسخه‌ی Demo یا نمایشی **go to definition** (typical bindings: vscode = F12; "
"vim/CoC = g d). (این شما را به `//third_party/rust/.../qr_code-.../src/lib."
"rs` می‌رساند.)"

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""
"نسخه آزمایشی **outline** و در ادامه به متد `QrCode::with_bits` بروید (حدود "
"خط 164؛ طرح کلی در پنجره file explorer در vscode است؛ typical vim/CoC "
"bindings = space o)"

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **type annotations** (there are quite a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""
"نسخه‌ی نمایشی **type annotations** (مثال های بسیار خوبی در متد  `QrCode::"
"with_bits` وجود دارد)"

#: src/chromium/build-rules/vscode.md
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""
"ممکن است مهم باشد که `gn gen ... --export-rust-project` باید پس از ویرایش "
"فایل‌های `BUILD.gn` (که در طول تمرین‌های این جلسه چند بار انجام می‌دهیم) دوباره "
"اجرا شود."

#: src/exercises/chromium/build-rules.md
msgid "Build rules exercise"
msgstr "تمرین قواعد ساخت"

#: src/exercises/chromium/build-rules.md
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""
"در ساخت Chromium خود، یک Rust target جدید به `//ui/base/BUILD.gn` اضافه کنید "
"که حاوی:"

#: src/exercises/chromium/build-rules.md
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to allow unsafe code in your `gn` "
"target."
msgstr ""
"**مهم**: توجه داشته باشید که `no_mangle` در اینجا توسط کامپایلر Rust نوعی "
"ناامنی (type of unsafety) در نظر گرفته می‌شود، بنابراین باید کد unsafe را در "
"`gn` target خود مجاز کنید."

#: src/exercises/chromium/build-rules.md
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""
"این هدف جدید Rust را به عنوان وابستگی به `//ui/base:base` اضافه کنید. این "
"تابع را در بالای `ui/base/resource/resource_bundle.cc` اعلام کنید (بعداً "
"خواهیم دید که چگونه می‌توان این کار را با ابزارهای تولید bindings خودکار کرد):"

#: src/exercises/chromium/build-rules.md
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""
"این تابع را از جایی در `ui/base/resource/resource_bundle.cc` فراخوانی کنید - "
"ما قسمت بالای `ResourceBundle::MaybeMangleLocalizedString` را پیشنهاد "
"می‌کنیم. Chromium را Build و اجرا کنید و مطمئن شوید که \"Hello from Rust!\" "
"بارها چاپ می‌شود."

#: src/exercises/chromium/build-rules.md
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""
"اگر از VSCode استفاده می‌کنید، اکنون Rust را تنظیم کنید تا در VSCode به خوبی "
"کار کند. این کار در تمرین‌های بعدی مفید خواهد بود. اگر موفق شده‌اید، می‌توانید "
"از کلیک راست روی\"Go to definition\" در`println!` استفاده کنید."

#: src/exercises/chromium/build-rules.md
#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Where to find help"
msgstr "کجا می‌توان help پیدا کرد"

#: src/exercises/chromium/build-rules.md
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""
"گزینه‌های موجود برای [`rust_static_library` gn template](https://source."
"chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;"
"l=16)"

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""
"اطلاعات درباره [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/abi."
"html#the-no_mangle-attribute)"

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""
"اطلاعات درباره [`extern \"C\"`](https://doc.rust-lang.org/std/keyword.extern."
"html)"

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""
"اطلاعاتی درباره gnهای [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"

#: src/exercises/chromium/build-rules.md
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""
"این مثال غیرعادی است زیرا به زبان متقابل با کمترین مخرج مشترک، C خلاصه "
"می‌شود. بعداً در دوره،  ++C  آن را مستقیماً به Rust وصل خواهیم کرد."

#: src/exercises/chromium/build-rules.md
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""
"‏ `allow_unsafe = true` در اینجا مورد نیاز است زیرا `#[no_mangle]` ممکن است "
"به Rust اجازه دهد دو تابع با نام یکسان تولید کند و Rust دیگر نمی‌تواند تضمین "
"کند که تابع مورد نظر فراخوانی شده است."

#: src/exercises/chromium/build-rules.md
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""
"اگر به یک فایل اجرایی Rust خالص نیاز دارید، می‌توانید این کار را با استفاده "
"از الگوی`rust_executable` gn  نیز انجام دهید."

#: src/chromium/testing.md
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""
"جامعه Rust معمولاً unit testهای را در یک ماژول قرار می‌دهد که در همان فایل "
"منبع کد مورد آزمایش قرار می‌گیرد. این مورد [قبل‌تر](../testing.md) در دوره "
"پوشش داده شده بود و به این صورت است:"

#: src/chromium/testing.md
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""
"در Chromium باید unit testها را در یک فایل منبع جداگانه قرار دهیم و همچنان "
"این روش را برای Rust دنبال می‌کنیم --- این باعث می‌شود تست‌ها به طور مداوم قابل "
"کشف باشند و کمک می‌کند از بازسازی فایل‌های `.rs` برای بار دوم (در پیکربندی "
"`test`) جلوگیری شود."

#: src/chromium/testing.md
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr "این منجر به گزینه‌های زیر برای تست کد Rust در Chromium می‌شود:"

#: src/chromium/testing.md
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""
"تست‌های Native Rust (یعنی `#[test]`). خارج از `//third_party/rust` مناسب نیست."

#: src/chromium/testing.md
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""
"تست‌های `gtest` که در C++ نوشته شده‌اند و Rust را از طریق تماس‌های FFI انجام "
"می‌دهند. زمانی که کد Rust فقط یک لایه نازکی از FFI است و unit testها موجود، "
"پوشش کافی برای ویژگی‌هایی که ارائه می‌کنند کافی است."

#: src/chromium/testing.md
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""
"آزمایش‌های `gtest` که در Rust نوشته شده‌اند و از crate تحت آزمایش از طریق API "
"عمومی آن استفاده می‌کنند (در صورت نیاز از `pub mod for_testing { ... }` » "
"استفاده می‌کنند. این موضوع در چند اسلاید بعد معرفی شده است."

#: src/chromium/testing.md
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""
"ذکر کنید که تست‌هایnative Rust در مورد crateهای شخص ثالث باید در نهایت توسط "
"روبات‌های Chromium انجام شود. (چنین آزمایشی به ندرت مورد نیاز است --- فقط پس "
"از افزودن یا به‌روز‌رسانی crateهای شخص ثالث.)"

#: src/chromium/testing.md
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""
"برخی از مثال‌ها ممکن است به توضیح اینکه چه زمانی باید از  C++ `gtest` در "
"مقابل Rust `gtest` استفاده شود کمک کند:"

#: src/chromium/testing.md
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""
"‏ QR عملکرد بسیار کمی در لایه Rust شخص اول دارد (این فقط یک چسب FFI باریک "
"است) و بنابراین از unit testهای++C موجود برای آزمایش ++C و اجرای Rust "
"استفاده می‌کند (تست‌ها را پارامتر می‌کند تا Rust را با استفاده از یک "
"`ScopedFeatureList` آن را فعال یا غیرفعال کند."

#: src/chromium/testing.md
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""
"‏ Hypothetical/WIP PNG ممکن است نیاز به پیاده‌سازی ایمن از حافظه تبدیل‌های "
"پیکسلی داشته باشد که توسط `libpng` ارائه شده‌اند اما در `png` crate وجود "
"ندارند - به عنوان مثال. RGBA => BGRA یا تصحیح‌گر گاما (gamma correction). "
"چنین عملکردی ممکن است از آزمایش های جداگانه‌ای که در Rust نوشته شده است "
"بهره‌مند شود."

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""
"کتابخانه [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/"
"src/+/main/testing/rust_gtest_interop/README.md) راهی را ارائه می‌دهد:"

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""
"از یک تابع Rust به عنوان یک تست `gtest` استفاده کنید (با استفاده از "
"`#[gtest(...)]` attribute)"

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""
"از `expect_eq!`  و ماکروهای مشابه (شبیه به `assert_eq!` استفاده کنید، اما "
"وقتی assertion ناموفق بود، panic نکنید و تست را خاتمه ندهید)."

#: src/chromium/testing/rust-gtest-interop.md
msgid "Example:"
msgstr "مثال:"

#: src/chromium/testing/build-gn.md
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""
"ساده‌ترین راه برای build Rust `gtest` اضافه‌کردن آن‌ها به یک باینری تست موجود "
"است که از قبل حاوی تست‌هایی است که در ++C نوشته شده‌اند. به عنوان مثال:"

#: src/chromium/testing/build-gn.md
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/testing/build-gn.md
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""
"نگارش تست‌های Rust در یک `static_library` جداگانه نیز کار می‌کند، اما نیاز به "
"اعلام دستی وابستگی به کتابخانه‌های پشتیبانی دارد:"

#: src/chromium/testing/build-gn.md
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""
"پس از افزودن `:my_rust_lib` به GN `deps`، همچنان باید نحوه وارد کردن و "
"استفاده از `my_rust_lib` را از `my_rust_lib_unittest.rs` یاد بگیریم. ما یک "
"`crate_name` صریح برای `my_rust_lib` ارائه نکرده‌ایم، بنابراین نام crate آن "
"بر اساس مسیر و نام کامل هدف محاسبه می‌شود. خوشبختانه ما می‌توانیم با استفاده "
"از ماکرو `chromium::import!` از `chromium` crate که به‌طور خودکار وارد می‌شود، "
"درنتیجه از کار با چنین نامی پرهیز کنیم:"

#: src/chromium/testing/chromium-import-macro.md
msgid "\"//ui/base:my_rust_lib\""
msgstr "\"//ui/base:my_rust_lib\""

#: src/chromium/testing/chromium-import-macro.md
msgid "Under the covers the macro expands to something similar to:"
msgstr "در زیر جلدها، ماکرو به چیزی شبیه به زیر گسترش می یابد:"

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""
"اطلاعات بیشتر را می‌توانید در [ doc comment](https://source.chromium.org/"
"chromium/chromium/src/+/main:build/rust/chromium_prelude/chromium_prelude.rs?"
"q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) پیدا کنید. ماکرو مربوطه `chromium::"
"import`."

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""
"‏`rust_static_library` از تعیین نام صریح از طریق ویژگی`crate_name` پشتیبانی "
"می‌کند، اما انجام این کار ممنوع است و از آن جلوگیری می‌شود زیرا نام crate باید "
"در سطح سراسری منحصر‌به‌فرد باشد. crates.io منحصر‌به‌فرد بودن نام crateهای خود را "
"تضمین می‌کند، بنابراین اهداف`cargo_crate` GN (تولید شده توسط ابزار  `gnrt` که "
"در بخش بعدی پوشش داده شده است) از نام‌های crate کوتاه استفاده می‌کنند."

#: src/exercises/chromium/testing.md
msgid "Testing exercise"
msgstr "تمرین تستی"

#: src/exercises/chromium/testing.md
msgid "Time for another exercise!"
msgstr "وقت یک تمرین دیگر است!"

#: src/exercises/chromium/testing.md
msgid "In your Chromium build:"
msgstr "درChromium build شما باید:"

#: src/exercises/chromium/testing.md
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""
"یک تابع قابل آزمایش در کنار `hello_from_rust` اضافه کنید. چند پیشنهاد: اضافه "
"کردن دو عدد صحیح دریافت شده به عنوان آرگومان، محاسبه عدد فیبوناچی nام، جمع "
"اعداد صحیح در یک برش و غیره."

#: src/exercises/chromium/testing.md
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr "یک فایل`..._unittest.rs` جداگانه با یک تست برای تابع جدید اضافه کنید."

#: src/exercises/chromium/testing.md
msgid "Add the new tests to `BUILD.gn`."
msgstr "تست‌های جدید را به `BUILD.gn` اضافه کنید."

#: src/exercises/chromium/testing.md
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""
"تست‌ها را بسازید، اجرا کنید و بررسی کنید که آيا تست جدید به درستی کار می‌کند."

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""
"جامعه Rust گزینه‌های متعددی را برای C++/Rust interop ارائه می‌دهد، با ابزارهای "
"جدیدی که همیشه در حال توسعه هستند. در حال حاضر، Chromium از ابزاری به نام "
"CXX استفاده می‌کند."

#: src/chromium/interoperability-with-cpp.md
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""
"شما کل مرز زبان (language boundary) خود را در یک زبان تعریف interface (که "
"بسیار شبیه Rust به نظر می رسد) توصیف می کنید و سپس ابزارهای CXX اعلان‌هایی را "
"برای توابع و تایپ‌ها در Rust و ++C ایجاد می‌کنند."

#: src/chromium/interoperability-with-cpp.md
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""
"برای مثال کامل استفاده از این [آموزش CXX](https://cxx.rs/tutorial.html) را "
"ببینید."

#: src/chromium/interoperability-with-cpp.md
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""
"از طریق دیاگرام صحبت کنید. توضیح دهید که در پشت صحنه، این دقیقاً همان کاری را "
"انجام می‌دهد که قبلاً انجام می‌دادید. به این نکته اشاره کنید که خودکارسازی "
"فرآیند دارای مزایای زیر است:"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""
"این ابزار تضمین می‌کند که مجانب ++C و Rust مطابقت کامل دارند (مثلاً اگر "
"`#[cxx::bridge]` با تعاریف واقعی ++C یا Rust مطابقت نداشته باشد، درنتیجه با "
"خطاهای کامپایل مواجه می‌شوید اما با اتصال‌های دستی غیرهمگام‌شده (out-of-sync "
"manual bindings) می‌توانید رفتار نامشخص دریافت کنید)"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""
"این ابزار تولید Thunk‌های FFI (کارکردهای کوچک، سازگار با C-ABI، و رایگان) را "
"برای ویژگی های غیر C (به عنوان مثال فعال کردن تماس‌های FFI به‌ متدهای Rust) به "
"طور خودکار انجام می دهد؛ اتصال های دستی نیاز به نوشتن چنین عملکردهای سطح "
"بالا و رایگان به صورت دستی دارد."

#: src/chromium/interoperability-with-cpp.md
msgid "The tool and the library can handle a set of core types - for example:"
msgstr ""
"ابزارها و کتابخانه می‌توانند مجموعه‌ای از انواع هسته (core types) را مدیریت "
"کنند - به عنوان مثال:"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""
"‏ `&[T]` را می‌توان از مرز FFI عبور داد، حتی اگر هیچ‌گونه طرح‌بندی ABI یا حافظه "
"خاصی را تضمین نکند. با اتصال‌های (bindings) دستی،`std::span<T>` / `&[T]` باید "
"به‌صورت دستی تخریب شود و از یک pointer و length به صورت مجدد ساخته شود - با "
"توجه به اینکه هر زبان sliceهای خالی را کمی متفاوت نشان می‌دهد، درنتیجه مستعد "
"خطا است)"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""
"اشاره گرهای هوشمند مانند `std::unique_ptr<T>`, `std::shared_ptr<T>` و/یا  "
"`Box` به صورت native پشتیبانی می‌شوند. با کمک اتصال‌های دستی (manual "
"bindings)، باید C-ABI-compatible raw pointers را پاس کنید که خطرات ایمنی و "
"طول عمر را افزایش می‌دهد."

#: src/chromium/interoperability-with-cpp.md
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""
"تایپ‌های `rust::String` و `CxxString` تفاوت‌ها را در نمایش stringها در بین "
"زبان‌ها درک و حفظ می‌کنند (به عنوان مثال، `rust::String::lossy` می‌تواند یک "
"Rust string  را از ورودی غیر UTF8 و `rust::String::c_str` بسازد و می‌تواند یک "
"string را با NUL خاتمه دهد)."

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""
"‏ CXX مستلزم آن است که کل مرز C++/Rust در ماژول‌های `cxx::bridge` در کد منبع `."
"rs` اعلام شود."

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "\"example/include/blobstore.h\""
msgstr "\"example/include/blobstore.h\""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "// Definitions of Rust types and functions go here\n"
msgstr "// Definitions of Rust types and functions go here\n"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Point out:"
msgstr "اشاره کنید:"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""
"اگرچه این شبیه به یک `mod` معمولی Rust است، اما ماکرو رویه‌ای `#[cxx::"
"bridge]` کارهای پیچیده‌ای برای آن انجام می‌دهد و کد تولید شده کمی پیچیده تر "
"است - اگرچه این کار همچنان منجر به یک  `mod` به نام `ffi` در کد شما می شود."

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr "پشتیبانی Native در ++C برای`std::unique_ptr`در Rust"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Native support for Rust slices in C++"
msgstr "پشتیبانی Native برای Rust Slices در ++C"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr "فراخوانی از ++C به Rust و تایپ‌های Rust (در قسمت بالا)"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr "فراخوانی از Rust به ++C و تایپ‌های ++C (در قسمت پایین)"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""
"تصور نادرست رایج**: به نظر می‌رسد هِدِر ++C توسط Rust تجزیه می‌شود، اما این "
"گمراه کننده است. این هِدِر هرگز توسط Rust تفسیر نمی‌شود، بلکه به سادگی "
"`#include` در کد ++C تولید‌شده برای کامپایلرهای ++C است."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr ""
"تا حد زیادی مفیدترین صفحه هنگام استفاده از CXX برابر [type reference]"
"(https://cxx.rs/bindings.html) است."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "CXX fundamentally suits cases where:"
msgstr "‏ CXX به‌طورکلی مناسب مواردی است که:"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr ""
"اینترفیس ++Rust-C شما به اندازه کافی ساده است که می‌توانید همه آن را اعلام یا "
"declare کنید."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""
"شما فقط از تایپ‌هایی استفاده می‌کنید که قبلاً توسط CXX ​​پشتیبانی می‌شوند، برای "
"مثال`std::unique_ptr`, `std::string`, `&[u8]` و غیره."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr ""
"این مورد محدودیت‌های زیادی دارد --- برای مثال عدم پشتیبانی از تایپ 'Option' "
"Rust."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""
"این محدودیت‌ها ما را محدود می‌کنند تا از Rust در Chromium فقط برای \"گره‌های "
"برگ\" به خوبی ایزوله شده استفاده کنیم نه برای تعامل دلخواه ++Rust-C. هنگام "
"در نظر گرفتن یک مورد استفاده برای Rust در Chromium، یک نقطه شروع خوب این است "
"که پیش نویس پیوندهای CXX برای مرز زبان (language boundary) را پیش‌نویس کنید "
"تا ببینید آیا به اندازه کافی ساده به نظر می رسد یا خیر."

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr "همچنین باید برخی از نکات مهم دیگر را با CXX مطرح کنید، به عنوان مثال:"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr "مدیریت خطای آن بر اساسC++ exception است (در اسلاید بعدی ارائه شده است)"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Function pointers are awkward to use."
msgstr "استفاده ازFunction pointerها دشوار است."

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""
"‏ CXX [پشتیبانی از  `Result<T,E>`](https://cxx.rs/binding/result.html)  به C+"
"+ exception متکی است، بنابراین نمی‌توانیم از آن در Chromium استفاده کنیم. "
"جایگزین‌های آن عبارتند از:"

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "The `T` part of `Result<T, E>` can be:"
msgstr "قسمت `T` از `نتیجه<T، E>` می تواند باشد:"

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""
"از طریق پارامترهای خارجی (به عنوان مثال از طریق `&mut T`) برگردانده شده است. "
"این مستلزم آن است که `T` بتواند از مرز FFI عبور کند - برای مثال `T` باید "
"باشد:"

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "A primitive type (like `u32` or `usize`)"
msgstr "یک type اولیه (مانند `u32` یا `usize`)"

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""
"تایپی که به طور native توسط `cxx` پشتیبانی می‌شود (مانند  `UniquePtr<T>`) که "
"دارای یک مقدار پیش‌فرض مناسب برای استفاده در موارد خرابی است (_unlike_ "
"`Box<T>`)."

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""
"در سمت Rust حفظ شده و از طریق مرجع در معرض دید قرار گرفته است. این کار ممکن "
"است زمانی مورد نیاز باشد که `T` یک تایپ Rust است که نمی‌تواند از مرز FFI عبور "
"کند و نمی تواند در `UniquePtr<T>` ذخیره شود."

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "The `E` part of `Result<T, E>` can be:"
msgstr "قسمت `E` از `Result<T, E>` می‌تواند باشد:"

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""
"به‌عنوان یک boolean برگردانده می‌شود (مثلاً `true` نشان‌دهنده موفقیت و `false` "
"نشان‌دهنده یک شکست است)"

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""
"حفظ جزئیات خطا در تئوری امکان پذیر است، اما تاکنون در عمل مورد نیاز نبوده "
"است."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid "CXX Error Handling: QR Example"
msgstr "مدیریت خطا CXX: مثال QR"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""
"تولید کد QR [نمونه‌ای](https://source.chromium.org/chromium/chromium/src/+/"
"main:components/qr_code_generator/qr_code_generator_ffi_glue.rs;l=13-18;"
"drc=7bf1b75b9101ca2013) است که در آن بولی برای ارتباط موفقیت در مق‌بل شکست و "
"جایی که نتیجه موفقیت آمیز را می‌توان از مرز FFI عبور داد استفاده می شود:"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid "\"qr_code_generator\""
msgstr "\"qr_code_generator\""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""
"دانش آموزان ممکن است در مورد معنایی خروجی `out_qr_size` کنجکاو باشند. این "
"اندازه بردار نیست بلکه اندازه کد QR است (و مسلماً کمی اضافی است - درواقع این "
"جذر اندازه بردار است)."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""
"شاید لازم باشد قبل از فراخوانی تابع Rust به اهمیت مقداردهی اولیه "
"`out_qr_size` اشاره کنیم. ایجاد یک مرجع Rust که به حافظه اولیه اشاره می‌کند، "
"منجر به رفتار نامشخص می‌شود (برخلاف ++C، زمانی که تنها عمل عدم ارجاع چنین "
"حافظه‌ای منجر به UB می‌شود)."

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data can’t be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""
"اگر دانش‌آموزان درباره `Pin` سؤال می‌کنند، توضیح دهید که چرا CXX برای ارجاع‌های "
"قابل تغییر به داده‌های ++C به آن نیاز دارد: پاسخ این است که داده‌های++C را "
"نمی‌توان مانند داده‌های Rust جابه‌جا کرد، زیرا ممکن است حاوی نشانگرهای "
"خودارجاعی (self-referential pointers) باشد."

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "CXX Error Handling: PNG Example"
msgstr "مدیریت خطا CXX: مثال PNG"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""
"نمونه اولیه PNG decoder نشان می‌دهد که وقتی نتیجه موفقیت آمیز نمی‌تواند از مرز "
"FFI عبور کند و چه کاری می توان انجام داد:"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "\"gfx::rust_bindings\""
msgstr "\"gfx::rust_bindings\""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr "/// C++ bindings for the `crate::png::PngReader` type.\n"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""
"‏ \"PngReader\" و \"ResultOfPngReader\" تایپ‌های Rust هستند --- objectهای از "
"این نوع نمیتوانند بدون جهت‌گیری غیرمستقیم `Box<T>` از مرز FFI عبور کنند. ما "
"نمی‌توانیم `out_parameter: &mut PngReader` داشته باشیم، زیرا CXX به ++C اجازه "
"نمی‌دهد Rust object ها را براساس مقدار ذخیره کند."

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""
"این مثال نشان می‌دهد که حتی اگر CXX از genericها و templateهای دلخواه "
"پشتیبانی نمی‌کند، ما همچنان می‌توانیم آنها را از مرز FFI عبور دهیم و آنها را "
"به‌صورت دستی تخصصی/تک‌شکلی ( specializing / monomorphizing) در یک نوع غیرعمومی "
"تبدیل کنیم. در مثال `ResultOfPngReader` یک نوع non-generic است که به متدهای "
"مناسب `Result<T, E>` (به عنوان مثال به «is_err»، «unwrap» و/یا «as_mut» "
"ارسال می‌شود."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "Using cxx in Chromium"
msgstr "استفاده از cxx در Chromium"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""
"در Chromium، یک `#[cxx::bridge] mod` مستقل برای هر برگ گره‌ای که می‌خواهیم از "
"Rust استفاده کنیم را تعریف می‌کنیم. شما معمولاً برای هر `rust_static_library` "
"یکی دارید. پس فقط اضافه کنید."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr "به هدف `rust_static_library` موجود در کنار `crate_root` و `sources`."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr " headerهای ++C در یک مکان منطقی تولید می‌شوند، بنابراین شما می‌توانید"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr "\"ui/base/my_rust_file.rs.h\""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""
"برخی از توابع کاربردی را در `//base`  برای تبدیل به/از تایپ‌های ++Chromium C "
"به انواع CXX Rust پیدا خواهید کرد --- برای مثال [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src /+/main:base/containers/span_rust."
"h;l=21)."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr ""
"دانش‌آموزان ممکن است بپرسند --- چرا هنوز به `allow_unsafe = true` نیاز داریم؟"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""
"پاسخ کلی این است که هیچ کد ++C/C با استانداردهای معمول Rust \"ایمن\" نیست. "
"فراخوانی مجدد و برگشتی به ++C/C  از Rust ممکن است کارهای دلخواه را در حافظه "
"انجام دهد و ایمنی طرح‌بندی داده‌های خود Rust را به خطر بیندازد. وجود کلمات "
"کلیدی بسیار زیاد «ناامن» در تعامل ++C/C  می‌تواند به نسبت سیگنال به نویز چنین "
"کلمه کلیدی آسیب برساند و این [جنجال‌برانگیز]‌(https://steveklabnik.com/writing/"
"the-cxx-debate) است، اما به طور دقیق، آوردن هر کد خارجی به یک باینری Rust "
"می‌تواند باعث رفتار غیرمنتظره از دیدگاه Rust شود."

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""
"پاسخ دقیقق دردیاگرام بالای [این صفحه](../interoperability-with-cpp.md) نهفته "
"است  --- در پشت صحنه، CXX توابع Rust «ناامن» و `extern \"C\"` را درست مانند "
"در بخش قبل به صورت دستی انجام دادیم."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Exercise: Interoperability with C++"
msgstr "تمرین: قابلیت همکاری با ++C"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part one"
msgstr "قسمت اول"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""
"در فایل Rust که قبلاً ایجاد کرده‌اید، یک `#[cxx::bridge]` اضافه کنید که یک "
"تابع را مشخص می‌کند که باید از++C فراخوانی شود که نام `hello_from_rust` دارد، "
"بدون اینکه پارامتر و هیچ مقداری برگرداند."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""
"تابع `hello_from_rust` قبلی خود را برای حذف  `extern \"C\"` و `#[no_mangle]` "
"تغییر دهید. حالا این فقط یک تابع استاندارد Rust است."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Modify your `gn` target to build these bindings."
msgstr "هدف `gn` خود را برای ایجاد این پیوندها (bindings) تغییر دهید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""
"در کد ++C خود، forward-declaration برای `hello_from_rust` را حذف کنید. در "
"عوض، فایل هِدِر تولید شده را اضافه کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Build and run!"
msgstr "Build و run!"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part two"
msgstr "قسمت دوم"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""
"ایده خوبی است که کمی با CXX بازی کنید. این به شما کمک می کند تا به این فکر "
"کنید که Rust در Chromium واقعا چقدر انعطاف پذیر است."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Some things to try:"
msgstr "برخی از چیزهایی که باید امتحان کنید:"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Call back into C++ from Rust. You will need:"
msgstr "از Rust دوباره به  ++C فراخوانی کنید. درنهایت شما نیاز خواهید داشت:"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""
"یک فایل هِدِر اضافی که می‌توانید از `cxx::bridge` خود `include!` را وارد کنید. "
"شما باید تابع ++C خود را در آن فایل هِدِر جدید اعلام کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""
"یک بلوک `unsafe` برای فراخوانی چنین تابعی، یا به طور متناوب کلمه کلیدی "
"`unsafe` را در `#[cxx::bridge]` خود [همانطور که در اینجا توضیح داده شده است]"
"(https://cxx.rs/extern-c++.html#functions-and-member-functions)."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""
"همچنین ممکن است لازم باشد`#include \"third_party/rust/cxx/v1/crate/include/"
"cxx.h\"` را وارد کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Pass a C++ string from C++ into Rust."
msgstr "یک رشته++C را از ++C به Rust منتقل کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Pass a reference to a C++ object into Rust."
msgstr "ارسال یک reference از یک C++ object به Rust ."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"عمداً امضاهای تابع Rust را که از `#[cxx::bridge]` مطابقت ندارند، دریافت کنید "
"و به خطاهایی که می بینید عادت کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"عمداً امضاهای تابع ++C را که از `#[cxx::bridge]` مطابقت ندارند، دریافت کنید و "
"به خطاهایی که می بینید عادت کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""
"یک `std::unique_ptr` از نوعی از ++C را به Rust ارسال کنید، به طوری که Rust "
"بتواند دارای یک C++ object باشد."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""
"یک Rust object ایجاد کنید و آن را به ++C ارسال کنید تا ++C مالک آن باشد. "
"(نکته: شما به یک `Box` نیاز دارید)."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr "چند متد را در نوع ++C اعلام کنید. آنها را از Rust فراخوانی کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr "چند متد را در Rust type اعلام کنید. از ++C آن‌ها را فراخوانی کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part three"
msgstr "قسمت سوم"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""
"اکنون نقاط قوت و محدودیت‌های CXX interop را درک کرده‌اید، به چند مورد استفاده "
"برای Rust در Chromium فکر کنید که در آن رابط به اندازه کافی ساده باشد. نحوه "
"تعریف این رابط را ترسیم کنید."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr "یک [`cxx` binding reference](https://cxx.rs/bindings.html)"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""
"یک  [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Some of the questions you may encounter:"
msgstr ""
"برخی از سؤالاتی که ممکن است با آن مواجه شوید:برخی از سوالاتی که ممکن است با "
"آن مواجه شوید:"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""
"من مشکلی در مقداردهی اولیه یک متغیر از نوع X با نوع Y می‌بینم، که در آن X و Y "
"هر دو نوع تابع هستند. بخاطر اینکه تابع ++ C شما کاملاً با اعلان موجود در "
"`cxx::bridge` شما مطابقت ندارد."

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""
"به نظر می‌رسد می‌توانم آزادانه مراجع ++C را به منابع Rust تبدیل کنم. آیا این "
"خطر UB را ندارد؟ برای تایپ‌های _opaque_ CXX، خیر، زیرا اندازه آنها صفر است. "
"برای انواع بی‌اهمیت CXX بله، ممکن است باعث UB شود، اگرچه طراحی CXX ساخت چنین "
"نمونه‌ای را بسیار دشوار می‌کند."

#: src/chromium/adding-third-party-crates.md
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""
"کتابخانه‌های Rust \"Crates\" نامیده می‌شوند و در [crates.io](https://crates."
"io) یافت می‌شوند. وابستگی cratesهای Rust به یکدیگر بسیار آسان است. بنابراین "
"آنها این کار را انجام می‌دهند!"

#: src/chromium/adding-third-party-crates.md
msgid "Property"
msgstr "ویژگی"

#: src/chromium/adding-third-party-crates.md
msgid "C++ library"
msgstr "C++ library"

#: src/chromium/adding-third-party-crates.md
msgid "Rust crate"
msgstr "Rust crate"

#: src/chromium/adding-third-party-crates.md
msgid "Build system"
msgstr "Build system"

#: src/chromium/adding-third-party-crates.md
msgid "Lots"
msgstr "تعداد زیادی"

#: src/chromium/adding-third-party-crates.md
msgid "Consistent: `Cargo.toml`"
msgstr "یکپارچگی: `Cargo.toml`"

#: src/chromium/adding-third-party-crates.md
msgid "Typical library size"
msgstr "اندازه کتابخانه معمولی"

#: src/chromium/adding-third-party-crates.md
msgid "Large-ish"
msgstr "Large-ish"

#: src/chromium/adding-third-party-crates.md
msgid "Small"
msgstr "کوچک"

#: src/chromium/adding-third-party-crates.md
msgid "Transitive dependencies"
msgstr "وابستگی‌های گذرا"

#: src/chromium/adding-third-party-crates.md
msgid "Few"
msgstr "Few"

#: src/chromium/adding-third-party-crates.md
msgid "For a Chromium engineer, this has pros and cons:"
msgstr "برای یک مهندس Chromium، این مزایا و معایب دارد:"

#: src/chromium/adding-third-party-crates.md
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""
"همه crateها از یک سیستم ساخت مشترک استفاده می‌کنند، بنابراین می‌توانیم گنجاندن "
"آن‌ها در Chromium را خودکار کنیم..."

#: src/chromium/adding-third-party-crates.md
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr ""
"... اما، crateها معمولاً وابستگی‌های گذرا دارند، بنابراین احتمالاً مجبور خواهید "
"بود چندین کتابخانه را بیاورید."

#: src/chromium/adding-third-party-crates.md
msgid "We'll discuss:"
msgstr "بحث خواهیم کرد:"

#: src/chromium/adding-third-party-crates.md
msgid "How to put a crate in the Chromium source code tree"
msgstr "نحوه قرار دادن یک crate در درخت کد منبع Chromium"

#: src/chromium/adding-third-party-crates.md
msgid "How to make `gn` build rules for it"
msgstr "چگونه قوانین ساخت `gn` برای آن ایجاد کنیم"

#: src/chromium/adding-third-party-crates.md
msgid "How to audit its source code for sufficient safety."
msgstr "نحوه بررسی کد منبع آن برای ایمنی کافی"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr "پیکربندی فایل `Cargo.toml` برای افزودن crateها"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""
"‏ Chromium دارای یک مجموعه واحد از وابستگی‌های crate مستقیم با مدیریت مرکزی "
"است. اینها از طریق یک [`Cargo.toml`](https://source.chromium.org/chromium/"
"chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo.toml) مدیریت "
"می‌شوند :"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""
"مانند هر `Cargo.toml` دیگری، می‌توانید [جزئیات بیشتر در مورد وابستگی‌ها]"
"(https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) را "
"مشخص کنید --- معمولاً شما می‌خواهید «ویژگی‌هایی» را که می‌خواهید در crate فعال "
"کنید را مشخص کنید."

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""
"هنگام افزودن crate به Chromium، اغلب باید اطلاعات اضافی را در یک فایل اضافی، "
"`gnrt_config.toml` ارائه کنید، که در ادامه با آن آشنا خواهیم شد."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""
"در کنار `Cargo.toml` یک  [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml) قرار دارد. این شامل برنامه‌های  extension مخصوص Chromium برای مدیریت "
"crate است."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr ""
"اگر crate جدیدی اضافه کنید، باید حداقل`group` را مشخص کنید. این یکی از:"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "For instance,"
msgstr "به عنوان مثال،"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""
"بسته به طرح کد منبع crate، ممکن است لازم باشد از این فایل برای تعیین محل "
"یافتن فایل (های) مجوز آن استفاده کنید."

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr ""
"بعداً، موارد دیگری را که برای حل مشکلات باید پیکربندی کنید، در این فایل "
"مشاهده خواهیم کرد."

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""
"ابزاری به نام `gnrt` می‌داند که چگونه جعبه‌ها را بارگیری کند و چگونه قواعد "
"`BUILD.gn` را ایجاد کند."

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "To start, download the crate you want like this:"
msgstr "برای شروع، crate مورد نظر خود را به صورت زیر دانلود کنید:"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""
"اگرچه ابزار`gnrt` بخشی از کد منبع Chromium است، با اجرای این دستور، "
"وابستگی‌های آن را از `crates.io` دانلود و اجرا می‌کنید. [بخش قبلی](../cargo."
"md) را در مورد این تصمیم امنیتی ببینید."

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "This `vendor` command may download:"
msgstr "این `vendor` command ممکن است بارگیری کند:"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Your crate"
msgstr "جعبه‌های (crates) کاربردی شما"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Direct and transitive dependencies"
msgstr "وابستگی های مستقیم و گذرا"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""
"نسخه‌های جدید crateهای دیگر، همانطور که `cargo` برای حل کردن مجموعه کامل "
"جعبه‌های مورد نیاز Chromium لازم است."

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""
"‏ Chromium وصله‌هایی را برای برخی crateها نگهداری می‌کند که در`//third_party/"
"rust/chromium_crates_io/patches` نگهداری می‌شوند. این‌ها به‌طور خودکار دوباره "
"اعمال می‌شوند، اما اگر وصله نشد، ممکن است نیاز به اقدام دستی داشته باشید."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr ""
"هنگامی که crate را دانلود کردید، فایل‌های `BUILD.gn` را مانند این تولید کنید:"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Now run `git status`. You should find:"
msgstr "اکنون `git status` را اجرا کنید. شما باید این موارد را پیدا کنید:"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""
"حداقل یک کد منبع جعبه جدید در `third_party/rust/chromium_crates_io/vendor`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""
"حداقل یک `BUILD.gn` جدید در `third_party/rust/<crate name>/v<major semver "
"version>`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "An appropriate `README.chromium`"
msgstr "یک `README.chromium` مناسب"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"لطفا به [مرجع Rust ](https://doc.rust-lang.org/reference/type-layout.html) "
"مراجعه کنید."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr ""
"نگاهی دقیق بیندازید، به‌خصوص به چیزهایی که در `third_party/rust` ایجاد می‌شوند."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""
"کمی در مورد semver --- و به‌ویژه روشی که در Chromium اجازه می‌دهد چندین نسخه "
"ناسازگار از crateها را مجاز کند، صحبت کنید. این مورد که در اکوسیستم Cargo "
"منع می‌شود ولی گاهی اوقات ضروری است."

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""
"اگر build شما با شکست مواجه شد، ممکن است به دلیل `build.rs` باشد: برنامه‌هایی "
"که کارهای دلخواه را در زمان build انجام می‌دهند. این مورد به‌طورکلی در تضاد با "
"طراحی `gn` و `ninja` است که هدفشان قواعد build ایستا، قطعی برای به حداکثر "
"رساندن موازی‌سازی و تکرارپذیری buildها است."

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr ""
"برخی از اقدامات `build.rs` به طور خودکار پشتیبانی می‌شوند. دیگران نیاز به "
"اقدام دارند:"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "build script effect"
msgstr "ساخت افکت اسکریپت"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Supported by our gn templates"
msgstr "توسط قالب‌های gn ما پشتیبانی می‌شود"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Work required by you"
msgstr "کار مورد نیاز شما"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Checking rustc version to configure features on and off"
msgstr "بررسی نسخه rustc برای پیکربندی ویژگی‌ها روشن و خاموش"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes"
msgstr "بلی"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "None"
msgstr "None"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Checking platform or CPU to configure features on and off"
msgstr "بررسی پلتفرم یا CPU برای پیکربندی ویژگی‌های روشن و خاموش"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Generating code"
msgstr "تولید کردن کد"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes - specify in `gnrt_config.toml`"
msgstr "بله - در `gnrt_config.toml` مشخص کنید"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Building C/C++"
msgstr "Building C/C++"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "No"
msgstr "خیر"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Patch around it"
msgstr "اطراف آن را Patch کنید"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Arbitrary other actions"
msgstr "سایر اقدامات دلخواه"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""
"خوشبختانه، اکثر crateها حاوی build script نیستند و خوشبختانه، اکثر build "
"scriptها تنها دو عمل اصلی را انجام می‌دهند."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""
"اگه `ninja` درباره نبودن فایل‌ها اعتراض کرد، `build.rs` را بررسی کنید و "
"ببینید که آیا کدهای منبع را می‌نویسد."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""
"در این صورت، [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) را "
"تغییر دهید تا `build-script-outputs` به crate اضافه شود. اگر این یک وابستگی "
"گذرا است، یعنی وابستگی که کد Chromium نباید مستقیماً به آن وابسته باشد، پس "
"`allow-first-party-usage=false` را نیز اضافه کنید. چندین نمونه از قبل در آن "
"فایل وجود دارد:"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""
"اکنون [`gnrt.py -- gen`](../generating-gn-build-rules.md) را مجدداً اجرا کنید "
"تا فایل‌های  `BUILD.gn` را دوباره تولید کنید تا به ninja اطلاع دهید که این "
"فایل خروجی خاص ورودی مراحل build بعدی است."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""
"برخی از crateها از crate مربوط به [`cc`](https://crates.io/crates/cc) برای "
"build و link کتابخانه‌های C/C++ استفاده می‌کنند. crateهای دیگر C/C++ را با "
"استفاده از [`bindgen`](https://crates.io/crates/bindgen) در اسکریپت‌های build "
"خود تجزیه می‌کنند. این فعالیت‌ها را نمی‌توان در زمینه Chromium پشتیبانی کرد --- "
"سیستم ساخت gn، ninja و LLVM ما در بیان روابط بین build actionsها بسیار خاص "
"است."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "So, your options are:"
msgstr "بنابراین، گزینه‌های شما عبارتند از:"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Avoid these crates"
msgstr "از این crateها اجتناب کنید"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Apply a patch to the crate."
msgstr "یک وصله (patch) روی crate بزنید."

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""
"وصله‌ها (Patches) باید در`third_party/rust/chromium_crates_io/patches/"
"<crate>` نگهداری شوند - برای مثال [Patchها در مقابل `](https://source."
"chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - و هر بار که crate را upgrade می‌کند به‌طور "
"خودکار توسط`gnrt` اعمال می‌شود."

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""
"هنگامی که یک crate شخص ثالث اضافه کردید و قواعد build را ایجاد کردید که با "
"توجه به نوع crate می‌تواند ساده باشد. درنتیجه هدف `rust_static_library` خود "
"را پیدا کنید و یک `dep` روی هدف `:lib` در crate خود اضافه کنید."

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Specifically,"
msgstr "به‌طور‌مشخص،"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Auditing Third Party Crates"
msgstr "حسابرسی Crateهای شخص ثالث"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""
"افزودن کتابخانه‌های جدید تابع [قواعد](https://chromium.googlesource.com/"
"chromium/src/+/refs/heads/main/docs/rust.md#Third_party-review) مربوط به "
"Chromium است، اما البته موضوع بررسی امنیتی نیز وجود دارد. از آنجایی که ممکن "
"است نه تنها یک crate، بلکه وابستگی‌های گذرا را نیز وارد کنید، ممکن است کدهای "
"زیادی برای بررسی وجود داشته باشد. از سوی دیگر، safe Rust code  می‌تواند عوارض "
"جانبی محدودی داشته باشد. پس چگونه باید آن را بررسی کنید؟"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""
"با گذشت زمان، Chromium قصد دارد به فرآیندی بر اساس [cargo vet](https://"
"mozilla.github.io/cargo-vet/) حرکت کند."

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr "در همین حال، برای هر crate جدید اضافه شده، موارد زیر را بررسی می کنیم:"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""
"بدانید که چرا هر crate استفاده می‌شود. رابطه بین crateها چیست؟ اگر سیستم ساخت "
"هر جعبه حاوی `build.rs`  یا ماکروهای رویه‌ای (procedural macros) است، مشخص "
"کنید که آن‌ها برای چه چیزی هستند. آیا آنها با روشی که Chromium به طور معمول "
"ساخته و built می‌شود سازگار هستند؟"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Check each crate seems to be reasonably well maintained"
msgstr "بررسی کنید که هر crate به نظر برسد که به خوبی نگهداری شده باشد."

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""
"از `cd third-party/rust/chromium_crates_io; cargo audit` استفاده کنید. بررسی "
"cargo برای بررسی آسیب‌پذیری‌های شناخته‌شده (ابتدا باید  `cargo install cargo-"
"audit` که از قضا شامل دانلود وابستگی‌های زیادی از اینترنت می‌شود[2](../cargo."
"md))"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""
"مطمئن شوید هر کد `unsafe` به اندازه کافی برای [قاعده دو](https://chromium."
"googlesource.com/chromium/src/+/main/docs/security/rule-of-2.md#unsafe-code-"
"in-safe-languages)  خوب است"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Check for any use of `fs` or `net` APIs"
msgstr "هرگونه استفاده از APIهای `fs` یا `net` را بررسی کنید"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""
"تمام کدها را در سطح کافی بخوانید تا به دنبال هر چیزی که ممکن است به طور مخرب "
"وارد شده باشد را بگردید. (در اینجا نمی توانید به طور واقع بینانه به دنبال "
"نتیجه ۱۰۰ درصدی باشید: اغلب کدهای زیادی وجود دارد.)"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""
"این‌ها فقط دستورالعمل‌هایی هستند --- با بازبین‌هایی از `security@chromium.org` "
"کار کنید تا راه درستی برای اطمینان از crate پیدا کنید."

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Checking Crates into Chromium Source Code"
msgstr "بررسی Crateها در کد منبع Chromium"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "`git status` should reveal:"
msgstr "‏ `git status` باید نشان دهد:"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr "کد Crate در `//third_party/rust/chromium_crates_io`"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""
"متادیتا (`BUILD.gn` و `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Please also add an `OWNERS` file in the latter location."
msgstr "لطفاً یک فایل`OWNERS` در مکان دیگر نیز اضافه کنید."

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""
"باید همه اینها را به همراه تغییرات `Cargo.toml` و `gnrt_config.toml`  خود در "
"مخزن Chromium قرار دهید."

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""
"**مهم**: باید از `git add -f` استفاده کنید زیرا در غیر این صورت فایل‌های  `."
"gitignore` ممکن است منجر به حذف برخی از فایل‌ها شود."

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""
"در حین انجام این کار، ممکن است متوجه شوید که بررسی‌های پیش‌ارسال به دلیل زبان "
"غیرمطرح با شکست مواجه می‌شوند. بخاطر این که داده‌های Rust crate معمولاً شامل "
"نام شاخه‌های git می‌شوند و بسیاری از پروژه‌ها هنوز از اصطلاحات غیرمطرح در آنجا "
"استفاده می‌کنند. بنابراین ممکن است لازم باشد این موارد را اجرا کنید:"

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""
"شما به‌عنوان مالک هر وابستگی شخص ثالث Chromium، [انتظار می‌رود آن را با هرگونه "
"اصلاحات امنیتی به‌روز نگه دارید](https://chromium.googlesource.com/chromium/"
"src/+/main/docs/adding_to_third_party.md#add-owners). امید است که ما به زودی "
"این را برای crateهای Rust خودکار کنیم، اما در حال حاضر، همچنان مسئولیت "
"شماست، همانطور که برای هر وابستگی به شخص ثالث دیگر این مسئولیت را دارید."

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""
"‏ [uwuify](https://crates.io/crates/uwuify) را به Chromium اضافه کنید و "
"[ویژگی‌های پیش‌فرض](https://doc.rust-lang.org/cargo/reference/features."
"html#the-default-feature). فرض کنید از crate در ارسال و دریافت بسته‌ها برای "
"Chromium استفاده می‌شود، اما برای رسیدگی به ورودی‌های غیرقابل اعتماد استفاده "
"نمی‌شود."

#: src/exercises/chromium/third-party.md
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""
"(در تمرین بعدی از uwuify برای Chromium استفاده خواهیم کرد، اما در صورت تمایل "
"می‌توانید این کار را انجام دهید. همینطور می‌توانید یک هدف ['rust_executable']"
"(https://source.chromium.org /chromium/chromium/src/+/main:build/rust/"
"rust_executable.gni) جدید ایجاد کنید که از `uwuify` استفاده می‌کند)."

#: src/exercises/chromium/third-party.md
msgid "Students will need to download lots of transitive dependencies."
msgstr "دانش‌آموزان باید تعداد زیادی وابستگی گذرا را دانلود کنند."

#: src/exercises/chromium/third-party.md
msgid "The total crates needed are:"
msgstr "کل crateهای مورد نیاز عبارتند از:"

#: src/exercises/chromium/third-party.md
msgid "`instant`,"
msgstr "`instant`,"

#: src/exercises/chromium/third-party.md
msgid "`lock_api`,"
msgstr "`lock_api`,"

#: src/exercises/chromium/third-party.md
msgid "`parking_lot`,"
msgstr "`parking_lot`,"

#: src/exercises/chromium/third-party.md
msgid "`parking_lot_core`,"
msgstr "`parking_lot_core`,"

#: src/exercises/chromium/third-party.md
msgid "`redox_syscall`,"
msgstr "`redox_syscall`,"

#: src/exercises/chromium/third-party.md
msgid "`scopeguard`,"
msgstr "`scopeguard`,"

#: src/exercises/chromium/third-party.md
msgid "`smallvec`, and"
msgstr "`smallvec`, و"

#: src/exercises/chromium/third-party.md
msgid "`uwuify`."
msgstr "`uwuify`."

#: src/exercises/chromium/third-party.md
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""
"اگر دانش‌آموزان حتی بیشتر از آن دانلود می‌کنند، احتمالا فراموش کرده‌اند که "
"ویژگی‌های پیش‌فرض را خاموش کنند."

#: src/exercises/chromium/third-party.md
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""
"با تشکر از [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) برای این "
"crate!"

#: src/exercises/chromium/bringing-it-together.md
msgid "Bringing It Together --- Exercise"
msgstr "برای جمع‌آوری آن --- تمرین کنید"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr ""
"در این تمرین، می‌خواهید یک ویژگی کاملاً جدید Chromium را اضافه کنید و همه "
"چیزهایی را که قبلاً یاد گرفته‌اید جمع آوری کنید."

#: src/exercises/chromium/bringing-it-together.md
msgid "The Brief from Product Management"
msgstr "خلاصه‌ای از مدیریت محصول"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""
"جامعه‌ای از pixyها کشف شده است که در یک جنگل بارانی دور افتاده زندگی می کنند. "
"مهم است که Chromium برای pixyها را در اسرع وقت به آنها تحویل دهیم."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr ""
"لازمه کار این است که تمام stringهای رابط کاربری Chromium به زبان Pixie ترجمه "
"شوند."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""
"زمانی برای منتظر ماندن برای ترجمه‌های مناسب وجود ندارد، اما خوشبختانه زبان "
"pixie بسیار نزدیک به انگلیسی است و به نظر می‌رسد که Rust crate ای وجود دارد "
"که ترجمه را انجام می‌دهد."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""
"در واقع، شما قبلا [آن crate را در تمرین قبلی وارد کردید](https://crates.io/"
"crates/uwuify)."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""
"(بدیهی است که ترجمه های واقعی Chrome نیاز به دقت و تلاش باورنکردنی دارند. "
"این مورد را ارسال نکنید!)"

#: src/exercises/chromium/bringing-it-together.md
msgid "Steps"
msgstr "گام‌ها"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""
"‏ `ResourceBundle::MaybeMangleLocalizedString` را تغییر دهید تا همه stringها "
"را قبل از نمایش یکپارچه کند. در این build خاص Chromium، بدون در نظر گرفتن "
"تنظیمات `mangle_localized_strings_` همیشه باید این کار را انجام دهد."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""
"اگر همه این تمرین‌ها را درست انجام داده‌اید، به شما تبریک می‌گوییم، باید Chrome "
"را برای pixies ایجاد می‌کردید!"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""
"‏ UTF16 در مقابل UTF8. دانش‌آموزان باید بدانند که stringهای Rust همیشه UTF8 "
"هستند و احتمالاً تصمیم خواهند گرفت که بهتر است تبدیل را در سمت C++ با استفاده "
"از `base::UTF16ToUTF8`  انجام دهند و دوباره برگردند."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""
"اگر دانش‌آموزان تصمیم بگیرند که تبدیل را در سمت Rust انجام دهند، باید "
"[`String::from_utf16`](https://doc.rust-lang.org/std/string/struct.String."
"html#method را در نظر بگیرند. مدیریت خطا را در نظر بگیرید و در نظر داشته "
"باشید که کدام [نوع های پشتیبانی شده از CXX می توانند تعداد زیادی از u16 ها "
"را منتقل کنند](https://cxx.rs/binding/slice.html)."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""
"دانش‌آموزها ممکن است مرز C++/Rust را به روش های مختلف طراحی کنند، به عنوان "
"مثال. گرفتن و برگرداندن stringها بر اساس مقدار، یا گرفتن یک مرجع قابل تغییر "
"به یک string. اگر از یک مرجع قابل تغییر استفاده شود، CXX احتمالاً به دانش‌آموز "
"می‌گوید که باید از [`Pin`](https://doc.rust-lang.org/std/pin/) استفاده کند. "
"ممکن است لازم باشد توضیح دهید `Pin` چه می‌کند و سپس توضیح دهید که چرا CXX به "
"آن برای ارجاع‌های قابل تغییر به داده‌های  C++  نیاز دارد: پاسخ این است که "
"داده‌های C++  را نمی‌توان مانند داده‌های Rust جابه‌جا کرد، زیرا ممکن است حاوی "
"نشانگرهای خودارجاعی (self-referential pointers) باشد."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""
"هدف C++ حاوی `ResourceBundle::MaybeMangleLocalizedString` باید به هدف "
"`rust_static_library` وابسته باشد. دانش‌آموز احتمالاً از قبل این کار را انجام "
"داده است."

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""
"هدف `rust_static_library` باید به `//third_party/rust/uwuify/v0_2:lib` "
"وابسته باشد."

#: src/exercises/chromium/solutions.md
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""
"راه‌حل‌های تمرینات Chromium را می‌توانید در [این سری از CLs](https://chromium-"
"review.googlesource.com/c/chromium/src/+/5096560) پیدا کنید."

#: src/bare-metal.md
msgid "Welcome to Bare Metal Rust"
msgstr "به Bare Metal Rust خوش آمدید"

#: src/bare-metal.md
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"این یک دوره مستقل یک روزه در مورد bare-metal Rust است که با هدف افرادی که با "
"اصول Rust آشنا هستند (شاید از اتمام دوره جامع Rust) و در حالت ایده آل نیز "
"تجربه برنامه‌نویسی bare-metal به زبان دیگری را دارند، مانند C می‌باشد."

#: src/bare-metal.md
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"امروز ما در مورد'bare-metal' Rust صحبت خواهیم کرد: اجرای کد Rust بدون "
"سیستم‌عامل در ادامه به چند بخش تقسیم خواهد شد:"

#: src/bare-metal.md
msgid "What is `no_std` Rust?"
msgstr "این `no_std` Rust چیست؟"

#: src/bare-metal.md
msgid "Writing firmware for microcontrollers."
msgstr "نوشتنfirmware برای میکروکنترلرها."

#: src/bare-metal.md
msgid "Writing bootloader / kernel code for application processors."
msgstr "نوشتن کد bootloader / kernel  برای پردازنده‌های برنامه."

#: src/bare-metal.md
msgid "Some useful crates for bare-metal Rust development."
msgstr "برخی از crateهای مفید برای توسعه bare-metal Rust."

#: src/bare-metal.md
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF52833 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"برای بخش میکروکنترلر دوره ما از [BBC micro:bit](https://microbit.org/) v2 به "
"عنوان مثال استفاده خواهیم کرد. این یک [برد توسعه](https://tech.microbit.org/"
"hardware/) مبتنی بر میکروکنترلر Nordic nRF52833 با چند LED و دکمه، شتاب‌سنج و "
"قطب‌نما متصل به I2C و یک دیباگر SWD روی برد است."

#: src/bare-metal.md
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"برای شروع، ابزارهایی را که بعداً به آنها نیاز خواهیم داشت نصب کنید. در لینوکس "
"یا دبیان:"

#: src/bare-metal.md
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"و به کاربران گروه `plugdev` اجازه دسترسی به برنامه‌نویس micro:bit را بدهید:"

#: src/bare-metal.md src/bare-metal/microcontrollers/debugging.md
msgid "On MacOS:"
msgstr "در MacOS:"

#: src/bare-metal/no_std.md
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md
msgid "`Option`, `Result`"
msgstr "`Option`, `Result`"

#: src/bare-metal/no_std.md
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md
msgid "`NonNull` and all the usual pointer-related functions"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Future` and `async`/`await`"
msgstr "`Future` و `async`/`await`"

#: src/bare-metal/no_std.md
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md
msgid "`Duration`"
msgstr "`Duration`"

#: src/bare-metal/no_std.md
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md
msgid "`Error`"
msgstr "`Error`"

#: src/bare-metal/no_std.md
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`File` and the rest of `fs`"
msgstr "یک `File` و بقیه  در `fs`."

#: src/bare-metal/no_std.md
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md
msgid "`HashMap` depends on RNG."
msgstr "یک `HashMap` به RNG وابسته است."

#: src/bare-metal/no_std.md
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr ""

#: src/bare-metal/minimal.md
msgid "A minimal `no_std` program"
msgstr "یک برنامه حداقلی از`no_std`"

#: src/bare-metal/minimal.md
msgid "This will compile to an empty binary."
msgstr "این به یک باینری خالی کامپایل می‌شود."

#: src/bare-metal/minimal.md
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""

#: src/bare-metal/minimal.md
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "همچنین می‌توان آن را توسط crate دیگری مانند  `panic-halt` تهیه کرد."

#: src/bare-metal/minimal.md
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"بسته به هدف، ممکن است لازم باشد برای جلوگیری از خطای `eh_personality` را "
"`panic = \"abort\"`  کامپایل کنید."

#: src/bare-metal/minimal.md
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"توجه داشته باشید که `main`  یا هیچ نقطه ورودی دیگری وجود ندارد. این به شما "
"بستگی دارد که نقطه ورود خود را تعریف کنید. این معمولاً شامل یک اسکریپت linker "
"و مقداری کد اسمبلی برای تنظیم موارد آماده برای اجرای کد Rust است."

#: src/bare-metal/alloc.md
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"برای استفاده از `alloc` باید یک [global (heap) allocator](https://doc.rust-"
"lang.org/stable/std/alloc/trait.GlobalAlloc.html) را پیاده‌سازی کنید."

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// SAFETY: `HEAP` is only used here and `entry` is only called once.\n"
msgstr "// SAFETY: `HEAP` is only used here and `entry` is only called once.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// Give the allocator some memory to allocate.\n"
msgstr "// Give the allocator some memory to allocate.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "// Now we can do things that require heap allocation.\n"
msgstr "// Now we can do things that require heap allocation.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "\"A string\""
msgstr "String"

#: src/bare-metal/alloc.md
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator`یک third-party crate است که یک تخصیص‌دهنده buddy "
"system را پیاده‌سازی می‌کند. crateهای دیگر در دسترس هستند یا می‌توانید نسخه "
"مربوط به خود را بنویسید یا به تخصیص دهنده موجود خود متصل کنید."

#: src/bare-metal/alloc.md
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"پارامتر const `LockedHeap` حداکثر ترتیب تخصیص‌دهنده (allocator) است. یعنی در "
"این مورد می‌تواند مناطقی تا 2\\*\\*32  بایت را اختصاص دهد."

#: src/bare-metal/alloc.md
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"اگر هر crate ای در درخت وابستگی شما به  `alloc` بستگی دارد، باید دقیقاً یک "
"تخصیص‌دهنده سراسری در باینری خود تعریف کنید. معمولاً این کار در binary crate "
"سطح بالا انجام می‌شود."

#: src/bare-metal/alloc.md
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"برای اطمینان از اینکه `panic_halt` crate لینک شده است، استفاده `extern crate "
"panic_halt as _` ضروری است، بنابراین panic handler آن را دریافت می‌کنیم."

#: src/bare-metal/alloc.md
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr "این مثال ساخته می شود اما اجرا نمی‌شود، زیرا entry point ندارد."

#: src/bare-metal/microcontrollers.md
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"یک `cortex_m_rt` crate (در میان چیزهای دیگر) یکreset handler  برای "
"میکروکنترلرهای Cortex M فراهم می‌کند."

#: src/bare-metal/microcontrollers.md
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"در ادامه نحوه دسترسی به لوازم جانبی (peripherals) را با افزایش سطح انتزاع "
"بررسی خواهیم کرد."

#: src/bare-metal/microcontrollers.md
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"ماکرو `cortex_m_rt::entry` مستلزم این است که تابع دارای نوع `cortex_m_rt::"
"entry` باشد، زیرا بازگشت به reset handler  منطقی نیست."

#: src/bare-metal/microcontrollers.md
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "مثال را با `cargo embed --bin minimal` اجرا کنید"

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"اکثر میکروکنترلرها از طریق IO دارای memory-map به تجهیزات جانبی "
"(peripherals) دسترسی دارند. بیایید سعی کنیم یک LED را در micro:bit خود روشن "
"کنیم:"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "/// GPIO port 0 peripheral address\n"
msgstr "/// GPIO port 0 peripheral address\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "// GPIO peripheral offsets\n"
msgstr "// GPIO peripheral offsets\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid "// PIN_CNF fields\n"
msgstr "// PIN_CNF fields\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"

#: src/bare-metal/microcontrollers/mmio.md
#, fuzzy
msgid ""
"// SAFETY: The pointers are to valid peripheral control registers, and no\n"
"    // aliases exist.\n"
msgstr ""
"// SAFETY: The pointers are to valid peripheral control registers, and no\n"
"    // aliases exist.\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr "// Set pin 28 low and pin 21 high to turn the LED on.\n"

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"در GPIO 0 پایه ۲۱  به ستون اول ماتریس LED و پایه ۲۸ به ردیف اول متصل است."

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#: src/bare-metal/microcontrollers/board-support.md
msgid "Run the example with:"
msgstr "مثال را با:"

#: src/bare-metal/microcontrollers/pacs.md
msgid "Peripheral Access Crates"
msgstr "Crateهای دسترسی جانبی"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"گزینه [`svd2rust`](https://crates.io/crates/svd2rust)  که  wrapperهای Rust "
"عمدتاً ایمن را برای تجهیزات جانبی دارای memory-map از فایل‌های[CMSIS-SVD]"
"(https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html) تولید می‌کند."

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"فایل‌های SVD (System View Description) در واقع فایل‌های XML هستند که معمولاً "
"توسط فروشندگان تجهیزات ریزپردازنده ارائه می‌شوند که memory map دستگاه را "
"توصیف می‌کنند."

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"آنها بر اساس peripheral، register، field و value، با نام، توضیحات، آدرس و "
"غیره سازماندهی می‌شوند."

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"فایل‌های SVD اغلب دارای باگ و ناقص هستند، بنابراین پروژه‌های مختلفی وجود دارد "
"که اشتباهات را اصلاح می‌کنند، جزئیات گمشده را اضافه می‌کنند و crateهای تولید "
"شده را منتشر می‌کنند."

#: src/bare-metal/microcontrollers/pacs.md
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt` جدول برداری را از جمله موارد دیگر ارائه می‌دهد."

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"اگر`cargo install cargo-binutils` را انجام دهید، می‌توانید  `cargo objdump --"
"bin pac -- -d --no-show-raw-insn` را اجرا کنید تا باینری حاصل را ببینید."

#: src/bare-metal/microcontrollers/hals.md
msgid "HAL crates"
msgstr "HAL crates"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"این [crateهای HAL]‌(https://github.com/rust-embedded/wesome-embedded-rust#hal-"
"implementation-crates) برای بسیاری از میکروکنترلرها بسته‌بندی‌هایی را در اطراف "
"تجهیزات جانبی مختلف ارائه می‌دهند. اینها معمولاً ویژگی‌های [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal) را پیاده‌سازی می‌کنند."

#: src/bare-metal/microcontrollers/hals.md
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr "// Create HAL wrapper for GPIO port 0.\n"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"بسیاری از HAL crateها برای انواعی از دستگاه های Cortex-M و RISC-V از جمله "
"میکروکنترلرهای STM32، GD32، nRF، NXP، MSP430، AVR و PIC مختلف وجود دارد."

#: src/bare-metal/microcontrollers/board-support.md
msgid "Board support crates"
msgstr "Board support crates"

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"پشتیبانی crateهای Boardها که برای راحتی بیشتر سطح پوششی بیشتری را برای یک "
"board خاص فراهم می‌کنند."

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"در این مورد crate پشتیبانی برد فقط نام‌های مفیدتر و مقداری مقداردهی اولیه را "
"ارائه می‌دهد."

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"این crate ممکن است شامل درایورهایی برای برخی از دستگاه‌های داخلی خارج از خود "
"میکروکنترلر نیز باشد."

#: src/bare-metal/microcontrollers/board-support.md
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "ء `microbit-v2` شامل یک درایور ساده برای ماتریس LED است."

#: src/bare-metal/microcontrollers/type-state.md
msgid "The type state pattern"
msgstr "یک تایپ state pattern"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"

#: src/bare-metal/microcontrollers/type-state.md
#, fuzzy
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr "// pin_input.is_high(); // Error, moved.\n"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"پین‌ها `Copy` یا `Clone` را اجرا نمی‌کنند، بنابراین فقط یک نمونه از هر کدام "
"می‌تواند وجود داشته باشد. هنگامی که یک pin از ساختار پورت خارج می شود، هیچ کس "
"دیگری نمی تواند آن را بگیرد."

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can’t keep use the old instance afterwards."
msgstr ""
"تغییر پیکربندی pin، نمونه pin ​​قدیمی را مصرف می‌کند، بنابراین نمی‌توانید پس از "
"آن از pin قدیمی استفاده کنید."

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"این type یک مقدار state را نشان می‌دهد که در آن قرار دارد: به عنوان مثال. در "
"این مورد، وضعیت پیکربندی یک پین GPIO. این state machine را در type system "
"رمزگذاری می‌کند و تضمین می‌کند که سعی نکنید از pin به روشی خاص استفاده کنید "
"بدون اینکه ابتدا آن را به درستی پیکربندی کنید. state transition غیرمجاز در "
"زمان کامپایل شناسایی می‌شود."

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"می‌توانید `is_high` را در یک پین ورودی و `set_high` را در یک پایه خروجی "
"فراخوانی کنید، اما برعکس امکان پذیر نیست."

#: src/bare-metal/microcontrollers/type-state.md
msgid "Many HAL crates follow this pattern."
msgstr "بسیاری از HAL crateها از این الگو پیروی می‌کنند."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals:"
msgstr ""
"این crate ['embedded-hal'](https://crates.io/crates/embedded-hal) تعدادی "
"ویژگی را ارائه می‌دهد که میکروکنترلرهای جانبی رایج را پوشش می‌دهد:"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "PWM"
msgstr "PWM"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "Delay timers"
msgstr "تایمرهای تاخیری"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "I2C and SPI buses and devices"
msgstr "گذرگاه‌ها و دستگاه‌های I2C و SPI"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs and broken "
"out into [`embedded-io`](https://crates.io/crates/embedded-io), [`embedded-"
"can`](https://crates.io/crates/embedded-can) and [`rand_core`](https://"
"crates.io/crates/rand_core) respectively."
msgstr ""
"ویژگی‌های مشابه برای جریان‌های بایت (مانند UART)، گذرگاه‌های CAN و RNG و تقسیم "
"شدن به [`embedded-io`](https://crates.io/crates/embedded-io)، [`embedded-"
"can`](https ://crates.io/crates/embedded-can) و [`rand_core`](https://crates."
"io/crates/rand_core) به ترتیب."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI device instance."
msgstr ""
"سپس crateهای دیگر [درایورها](https://github.com/rust-embedded/wesome-"
"embedded-rust#driver-crates) را بر حسب این ویژگی‌ها پیاده‌سازی می‌کنند، به "
"عنوان مثال. یک درایور شتاب سنج ممکن است به یک نمونه دستگاه I2C یا SPI نیاز "
"داشته باشد."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"The traits cover using the peripherals but not initialising or configuring "
"them, as initialisation and configuration is usually highly platform-"
"specific."
msgstr ""
"این ویژگی‌ها با استفاده از وسایل جانبی(peripherals) پوشش می‌دهند، اما آنها را "
"مقداردهی اولیه یا پیکربندی نمی‌کنند، زیرا مقداردهی اولیه و پیکربندی معمولاً به "
"پلتفرم خاص بستگی دارد."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"پیاده‌سازی‌هایی برای بسیاری از میکروکنترلرها و همچنین پلتفرم‌های دیگری مانند "
"لینوکس در Raspberry Pi وجود دارد."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"[`embedded-hal-async`](https://crates.io/crates/embedded-hal-async) provides "
"async versions of the traits."
msgstr ""
"برای[`embedded-hal-async`](https://crates.io/crates/embedded-hal-async) "
"نسخه‌های async از traitها را ارائه می دهد."

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"[`embedded-hal-nb`](https://crates.io/crates/embedded-hal-nb) provides "
"another approach to non-blocking I/O, based on the [`nb`](https://crates.io/"
"crates/nb) crate."
msgstr ""
"مورد [`embedded-hal-nb`](https://crates.io/crates/embedded-hal-nb) رویکرد "
"دیگری را برای عدم مسدود کردن I/O ارائه می دهد که بر اساس [`nb`](https:// "
"crates.io/crates/nb) crate است."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"یک [probe-rs](https://probe.rs/) یک مجموعه ابزار مفید برای اشکال زدایی "
"جاسازی شده است، مانند OpenOCD است، اما بهتر یکپارچه شده است."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr ""
"SWD (Serial Wire Debug) و JTAG از طریق پروب های CMSIS-DAP، ST-Link و J-Link"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr "GDB stub و Microsoft DAP (Debug Adapter Protocol) server"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "Cargo integration"
msgstr "ادغام Cargo"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
"`buddy_system_allocator`یک third-party crate است که یک تخصیص‌دهنده buddy "
"system را پیاده‌سازی می‌کند. crateهای دیگر در دسترس هستند یا می‌توانید نسخه "
"مربوط به خود را بنویسید یا به تخصیص دهنده موجود خود متصل کنید."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) یک "
"پروتکل استاندارد ARM از طریق USB است که برای یک دیباگر درون مداری جهت دسترسی "
"به پورت  CoreSight Debug Access در انواع مختلف پردازنده‌های Arm Cortex  مورد "
"استفاده قرار گرفته و این همان چیزی است که دیباگر داخلی در BBC micro:bit از "
"آن استفاده می‌کند."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link طیفی از دیباگرهای درون مدار از ST Microelectronics است، J-Link "
"محدوده ای از SEGGER است."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"پورت دسترسی Debug معمولا یا یک رابط JTAG 5 پین یا Serial Wire Debug 2 پین "
"است."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rs یک کتابخانه است که در صورت تمایل می‌توانید آن را در ابزارهای خود "
"ادغام کنید."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[پروتکل آداپتور Debug مایکروسافت](https://microsoft.github.io/debug-adapter-"
"protocol/) به VSCode و سایر IDE‌ها اجازه می‌دهد کدهای موجود در هر میکروکنترلر "
"پشتیبانی‌شده را Debug کنند."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr ""
"این cargo-embed یک باینری است که با استفاده از کتابخانه probe-rs ساخته شده "
"است."

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT (Real Time Transfers) مکانیزمی برای انتقال داده‌ها بین debug host  و "
"target از طریق تعدادی بافر حلقه‌ای (ringbuffers) است."

#: src/bare-metal/microcontrollers/debugging.md
msgid "_Embed.toml_:"
msgstr "_Embed.toml_:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "در یک ترمینال تحت  `src/bare-metal/microcontrollers/examples/`:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "In another terminal in the same directory:"
msgstr "در ترمینال دیگری در همان دایرکتوری:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "On gLinux or Debian:"
msgstr "در gLinux یا Debian:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "In GDB, try running:"
msgstr "در GDB، اجرا کنید:"

#: src/bare-metal/microcontrollers/other-projects.md
#: src/bare-metal/aps/other-projects.md
msgid "Other projects"
msgstr "پروژه‌های دیگر"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"همراهی مبتنی بر وقفه بلادرنگ\""

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""
"مدیریت منابع مشترک، ارسال پیام، زمان‌بندی تسک (task scheduling)، صف تایمر "
"(timer queue)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Embassy](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "اجرا کننده‌های `async` اولویت‌دار، تایمرها، شبکه، USB"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""
"RTOS متمرکز بر امنیت با برنامه‌ریزی پیشگیرانه و پشتیبانی از واحد حفاظت از "
"حافظه"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"یک Microkernel RTOS از شرکت Oxide Computer با protection از حافظه، درایورهای "
"غیرمجاز و IPC"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"برخی از پلتفرم‌ها پیاده‌سازی `std` دارند، به عنوان مثال. [esp-idf](https://esp-"
"rs.github.io/book/overview/using-the-standard-library.html)."

#: src/bare-metal/microcontrollers/other-projects.md
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr ""
"RTIC را می‌توان یک RTOS یا یک چارچوب همزمان (concurrency framework) در نظر "
"گرفت."

#: src/bare-metal/microcontrollers/other-projects.md
msgid "It doesn't include any HALs."
msgstr "این شامل هیچ HAL نیست."

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"از Cortex-M NVIC (کنترل‌کننده وقفه مجازی تودرتو-Nested Virtual Interrupt "
"Controller) برای زمان‌بندی به جای یک هسته مناسب استفاده می‌کند."

#: src/bare-metal/microcontrollers/other-projects.md
msgid "Cortex-M only."
msgstr "Cortex-M فقط."

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"گوگل از TockOS در میکروکنترلر Haven برای کلیدهای امنیتی Titan استفاده می‌کند."

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"در واقع FreeRTOS بیشتر به زبان C نوشته شده است، اما رابط‌های Rust برای نوشتن "
"برنامه‌ها در این حالت وجود دارد."

#: src/exercises/bare-metal/morning.md
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"ما جهت را از قطب‌نمای I2C می‌خوانیم و خوانش‌ها را در یک پورت سریال ثبت می‌کنیم."

#: src/exercises/bare-metal/morning.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"پس از دیدن تمرین‌ها، می‌توانید به [راه حل‌ها] (solutions-morning.md) ارائه شده "
"نگاه کنید."

#: src/exercises/bare-metal/compass.md
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"ما جهت را از قطب‌نمای I2C می خوانیم و خوانش‌ها را در یک پورت سریال ثبت می‌کنیم. "
"اگر وقت دارید، سعی کنید آن را به نحوی روی LED‌ها نیز نمایش دهید یا به نوعی از "
"دکمه‌ها استفاده کنید."

#: src/exercises/bare-metal/compass.md
msgid "Hints:"
msgstr "نکته‌ها:"

#: src/exercises/bare-metal/compass.md
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"مستندات [`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) و "
"[`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) به همراه "
"crateهای آن را بررسی کنید همانطور که [micro:bit hardware](https://tech."
"microbit.org/hardware/) را بررسی می‌کنید."

#: src/exercises/bare-metal/compass.md
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr "واحد اندازه‌گیری اینرسی در قطعه LSM303AGR به bus داخلی I2C متصل است."

#: src/exercises/bare-metal/compass.md
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""
"TWI نام دیگری برای I2C است، بنابراین دستگاه جانبی اصلی I2C TWIM نامیده می‌شود."

#: src/exercises/bare-metal/compass.md
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::i2c::"
"I2c` trait. The [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/"
"microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"درایور LSM303AGR به چیزی نیاز دارد که ویژگی `embedded_hal::i2c::I2c` را اجرا "
"کند. ساختار[`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/"
"microbit/hal/struct.Twim.html)  این مورد را پیاده‌سازی می‌کند."

#: src/exercises/bare-metal/compass.md
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"شما یک ساختار ['microbit::Board'](https://docs.rs/microbit-v2/latest/"
"microbit/struct.Board.html) با فیلدهایی برای پین‌ها و تجهیزات جانبی مختلف "
"دارید."

#: src/exercises/bare-metal/compass.md
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"در صورت تمایل می‌توانید به [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) نیز نگاه کنید، اما برای این تمرین لازم نیست."

#: src/exercises/bare-metal/compass.md
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"این [الگوی تمرین](../../comprehensive-rust-exercises.zip) را دانلود کنید و "
"فایل‌های زیر را در دایرکتوری `compass` جستجو کنید."

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_src/main.rs_:"
msgstr "_src/main.rs_:"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr "_Cargo.toml_ (نیاز به تغییر ندارد):"

#: src/exercises/bare-metal/compass.md
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr "_Embed.toml_ (نیازی به تغییر این نیست):"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md
msgid "See the serial output on Linux with:"
msgstr "مشاهده خروجی سریال در لینوکس با:"

#: src/exercises/bare-metal/compass.md
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""
"یا در سیستم‌عامل Mac چیزی شبیه به (نام دستگاه ممکن است کمی متفاوت باشد):"

#: src/exercises/bare-metal/compass.md
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "برای خروج از picocom از Ctrl+A و  Ctrl+Q استفاده کنید."

#: src/exercises/bare-metal/solutions-morning.md
msgid "Bare Metal Rust Morning Exercise"
msgstr "تمرین صبحگاهی Bare Metal Rust"

#: src/exercises/bare-metal/solutions-morning.md
msgid "([back to exercise](compass.md))"
msgstr "([back to exercise](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Configure serial port.\n"
msgstr "// Configure serial port.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Use the system timer as a delay provider.\n"
msgstr "// Use the system timer as a delay provider.\n"

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr "// Set up the I2C controller and Inertial Measurement Unit.\n"

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"Setting up IMU...\""
msgstr "\"راه اندازی IMU...\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Set up display and timer.\n"
msgstr "// Set up display and timer.\n"

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"Ready.\""
msgstr "\"آماده.\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid "// Read compass data and log it to the serial port.\n"
msgstr "// Read compass data and log it to the serial port.\n"

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"{},{},{}\\t{},{},{}\""
msgstr "\"{},{},{}\\t{},{},{}\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"

#: src/bare-metal/aps.md
msgid "Application processors"
msgstr "Application processors"

#: src/bare-metal/aps.md
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"تا اینجا در مورد میکروکنترلرهایی مانند سری Arm Cortex-M صحبت کردیم. حالا "
"بیایید سعی کنیم چیزی برای Cortex-A بنویسیم. برای سادگی، ما فقط با بردQEMU's "
"aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) "
"کار می‌کنیم."

#: src/bare-metal/aps.md
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"به طور کلی، میکروکنترلرها دارای MMU یا چندین سطح دسترسی (سطوح استثنا در "
"پردازنده‌های Arm، حلقه‌ها در x86) نیستند، در حالی که پردازنده‌های برنامه دارای "
"دسترسی هستند."

#: src/bare-metal/aps.md
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU از شبیه‌سازی ماشین‌های مختلف یا مدل‌های برد مختلف برای هر معماری پشتیبانی "
"می کند. برد 'virt' با هیچ سخت‌افزار واقعی خاصی مطابقت ندارد، اما صرفا برای "
"ماشین‌های مجازی طراحی شده است."

#: src/bare-metal/aps/entry-point.md
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""
"قبل از اینکه بتوانیم اجرای کد Rust را شروع کنیم، باید مقداری مقداردهی اولیه "
"را انجام دهیم."

#: src/bare-metal/aps/entry-point.md
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"

#: src/bare-metal/aps/entry-point.md
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"این همان چیزی است که برای C وجود دارد: مقداردهی اولیه وضعیت پردازنده، صفر "
"کردن BSS و تنظیم stack pointer."

#: src/bare-metal/aps/entry-point.md
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"این BSS (نماد شروع بلوک، به دلایل تاریخی) بخشی از object file است که حاوی "
"متغیرهای تخصیص یافته استاتیکی است که مقدار اولیه آنها صفر است. برای جلوگیری "
"از اتلاف فضا روی صفر، آنها از تصویر حذف شده‌اند. کامپایلر فرض می‌کند که لودر "
"از صفر کردن آنها مراقبت می‌کند."

#: src/bare-metal/aps/entry-point.md
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"ممکن است BSS قبلاً صفر شده باشد، بسته به اینکه چگونه حافظه مقداردهی اولیه شده "
"و تصویر بارگذاری شده است، اما برای اطمینان آن را صفر می‌کنیم."

#: src/bare-metal/aps/entry-point.md
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""
"قبل از خواندن یا نوشتن هر حافظه باید MMU و cache را فعال کنیم. اگر این کار "
"را نکنیم:"

#: src/bare-metal/aps/entry-point.md
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"دسترسی‌های بدون تراز خطا خواهند داشت. ما کد Rust را برای هدف`aarch64-unknown-"
"none` می‌سازیم که `+strict-align` را تنظیم می‌کند تا از ایجاد دسترسی‌های بدون "
"تراز توسط کامپایلر جلوگیری کند، بنابراین در این مورد باید خوب باشد، اما "
"لزوماً اینطور نیست."

#: src/bare-metal/aps/entry-point.md
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"اگر در VM اجرا می‌شد، این کار می‌تواند منجر به مشکلات انسجام cache شود. مشکل "
"این است که VM مستقیماً با حافظه cache غیرفعال شده به حافظه دسترسی پیدا می‌کند، "
"در حالی که host دارای نام مستعار قابل cache برای همان حافظه است. حتی اگر "
"cache به طور صریح به حافظه دسترسی نداشته باشد، دسترسی‌های گمانه‌زنی می‌تواند "
"منجر به پر شدن حافظه cache شود، و پس از پاک شدن حافظه cache یا فعال کردن "
"حافظه توسط VM، تغییرات از یک یا دیگری از بین می‌رود. (حافظه cache با آدرس "
"فیزیکی کلید می‌خورد، نه VA یا IPA.)"

#: src/bare-metal/aps/entry-point.md
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"برای سادگی، ما فقط از یک pagetable کدگذاری شده استفاده می کنیم (به`idmap.S` "
"مراجعه کنید) که ۱ گیگابایت اول فضای آدرس را برای دستگاه‌ها، ۱ گیگابایت بعدی "
"را برای DRAM و ۱ گیگابایت دیگر را برای دستگاه‌های بیشتر نگاشت می‌کند. این با "
"چیدمان حافظه‌ای که QEMU استفاده می‌کند مطابقت دارد."

#: src/bare-metal/aps/entry-point.md
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""
"ما همچنین exception vector (`vbar_el1`) را تنظیم کردیم که در ادامه بیشتر در "
"مورد آن خواهیم دید."

#: src/bare-metal/aps/entry-point.md
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"همه مثال‌ها امروز بعد از ظهر فرض می‌کنند که ما در سطح استثنا 1 (EL1) اجرا "
"خواهیم کرد. اگر نیاز به اجرا در سطح استثنایی متفاوت دارید، باید `entry.S`را "
"بر این اساس تغییر دهید."

#: src/bare-metal/aps/inline-assembly.md
msgid "Inline assembly"
msgstr "Inline assembly"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"گاهی اوقات برای انجام کارهایی که با کد Rust امکان پذیر نیست، باید از اسمبلی "
"استفاده کنیم. به عنوان مثال، برای برقراری یک HVC (hypervisor call) نایز است "
"که به firmware بگویید سیستم را خاموش کند:"

#: src/bare-metal/aps/inline-assembly.md
#, fuzzy
msgid ""
"// SAFETY: this only uses the declared registers and doesn't do anything\n"
"    // with memory.\n"
msgstr ""
"// SAFETY: this only uses the declared registers and doesn't do anything\n"
"    // with memory.\n"

#: src/bare-metal/aps/inline-assembly.md
msgid "\"hvc #0\""
msgstr "\"hvc #0\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w0\""
msgstr "\"w0\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w1\""
msgstr "\"w1\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w2\""
msgstr "\"w2\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w3\""
msgstr "\"w3\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w4\""
msgstr "\"w4\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w5\""
msgstr "\"w5\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w6\""
msgstr "\"w6\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w7\""
msgstr "\"w7\""

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"(اگر واقعاُ می‌خواهید این کار را انجام دهید، از crate مربوطه [`smccc`](https://"
"crates.io/crates/smccc) استفاده کنید که دارای بسته‌بندی(wrapper) برای همه این "
"عملکردها است.)"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"‏ PSCI یک رابط هدایت‌گر Arm Power State است که مجموعه‌ای استاندارد از توابع "
"برای مدیریت وضعیت‌های power در سیستم و CPU بوده، از جمله موارد دیگری از این "
"مورد توسط میان‌افزار EL3 و hypervisor در بسیاری از سیستم‌ها پیاده سازی شده است."

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"یک  `0 => _` syntax  به این معنی است که رجیستر را قبل از اجرای کد اسمبلی "
"درون خطی به 0 مقداردهی کنید و پس از آن محتوای آن را نادیده بگیرید. ما باید "
"از `inout` به جای `in` استفاده کنیم زیرا این فراخوانی به طور بالقوه می‌تواند "
"محتویات رجیسترها را مخدوش کند."

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"این تابع `main` باید به صورت`#[no_mangle]` و  `extern \"C\"` باشد زیرا از "
"نقطه ورودی (entry point) ما در `entry.S` فراخوانی می‌شود."

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"`_x0`–`_x3` are the values of registers `x0`–`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`–`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"‏ `_x0`–`_x3` مقادیر رجیسترهای `x0`–`x3` هستند که به طور معمول توسط "
"bootloader برای ارسال چیزهایی مانند اشاره‌گر به device tree استفاده می‌شود. "
"طبق قرارداد فراخوانی استاندارد aarch64 (که همان چیزی است که `extern \"C\"` "
"برای استفاده مشخص می‌کند)، رجیسترهای `x0`–`x7` برای ۸ آرگومان اول ارسال شده "
"به یک تابع استفاده می‌شوند، بنابراین `entry.S` این کار را انجام نمی‌دهد. لازم "
"نیست کار خاصی انجام دهید، جز اینکه مطمئن شوید که این مورد رجیسترها را تغییر "
"نمی‌دهد."

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"مثال را در QEMU با `make qemu_psci` در زیر `src/bare-metal/aps/examples` "
"اجرا کنید."

#: src/bare-metal/aps/mmio.md
msgid "Volatile memory access for MMIO"
msgstr "دسترسی به حافظه فرار برای MMIO"

#: src/bare-metal/aps/mmio.md
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "از `pointer::read_volatile` و `pointer::write_volatile` استفاده کنید."

#: src/bare-metal/aps/mmio.md
msgid "Never hold a reference."
msgstr "هرگز reference‌ای را نگه ندارید."

#: src/bare-metal/aps/mmio.md
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"‏ `addr_of!` به شما امکان می‌دهد بدون ایجاد یک مرجع میانی، فیلدهایی از "
"ساختارها را دریافت کنید."

#: src/bare-metal/aps/mmio.md
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"دسترسی فرار (Volatile access): عملیات خواندن یا نوشتن ممکن است عوارض جانبی "
"داشته باشد، بنابراین از کامپایلر یا سخت‌افزار از مرتب‌سازی مجدد، کپی‌کردن یا "
"حذف آنها جلوگیری کنید."

#: src/bare-metal/aps/mmio.md
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"معمولاً اگر بنویسید و سپس بخوانید، به عنوان مثال. از طریق یک reference، "
"کامپایلر ممکن است فرض کند که مقدار خوانده شده همان مقداری است که نوشته شده "
"است و در واقع خواندن memory را سخت‌تر نکند."

#: src/bare-metal/aps/mmio.md
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"برخی از crateهای موجود برای دسترسی فَرار(volatile access) به سخت‌افزار دارای "
"referenceهایی هستند، اما این همیشه درست نیست. هر زمان که یک reference وجود "
"داشته باشد، کامپایلر ممکن است انتخاب کند که reference آن را لغو کند."

#: src/bare-metal/aps/mmio.md
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"از ماکرو `addr_of!` برای دریافت اشاره‌گرهای struct field از یک اشاره‌گر به "
"ساختار استفاده کنید."

#: src/bare-metal/aps/uart.md
msgid "Let's write a UART driver"
msgstr "بیایید یک درایور UART بنویسیم"

#: src/bare-metal/aps/uart.md
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"این ماشین QEMU 'virt' یک  [PL011](https://developer.arm.com/documentation/"
"ddi0183/g) به‌عنوان UART دارد، پس بیایید یک درایور برای آن بنویسیم."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr "/// Minimal driver for a PL011 UART.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "/// Writes a single byte to the UART.\n"
msgstr "/// Writes a single byte to the UART.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Wait until there is room in the TX buffer.\n"
msgstr "// Wait until there is room in the TX buffer.\n"

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"// SAFETY: We know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// SAFETY: We know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Write to the TX buffer.\n"
msgstr "// Write to the TX buffer.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// Wait until the UART is no longer busy.\n"
msgstr "// Wait until the UART is no longer busy.\n"

#: src/bare-metal/aps/uart.md
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"توجه داشته باشید که `Uart::new` ناامن یا unsafe است در حالی که متد‌های دیگر "
"ایمن هستند. این به‌خاطر این است که تا زمانی که تماس گیرنده `Uart::new` تضمین "
"کند که الزامات ایمنی آن برآورده شده است (یعنی فقط یک نمونه از درایور برای یک "
"UART مشخص وجود دارد و هیچ چیز دیگری نام مستعار فضای آدرس آن را ندارد)، پس "
"همیشه می‌توان `write_byte` را بعداً فراخوانی کرد زیرا می‌توانیم پیش‌شرط‌های لازم "
"را فرض کنیم."

#: src/bare-metal/aps/uart.md
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"ما می‌توانستیم این کار را به صورت دیگری انجام دهیم ( ساخت `new` را ایمن کنیم، "
"اما `write_byte` را ناامن کنیم)، اما استفاده از آن بسیار راحت‌تر خواهد بود، "
"زیرا هر مکانی که `write_byte` را صدا می‌زند باید در مورد ایمنی یا safety "
"استدلال کند."

#: src/bare-metal/aps/uart.md
#, fuzzy
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"این یک الگوی رایج برای نوشتن بسته‌های ایمن کد ناامن است: انتقال بار اثبات "
"سلامت عملکردی از تعداد زیادی مکان به تعداد کمتری مکان."

#: src/bare-metal/aps/uart/traits.md
msgid "More traits"
msgstr "‏ traitهای بیشتر"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"ما ویژگی `Debug` را استخراج کردیم. اجرای چند ویژگی دیگر نیز مفید خواهد بود."

#: src/bare-metal/aps/uart/traits.md
#, fuzzy
msgid ""
"// SAFETY: `Uart` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// SAFETY: `Uart` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"پیاده‌سازی `Write`به ما امکان می‌دهد از ماکروهای `write!` و `writeln!` با تایپ "
"`Uart` خود استفاده کنیم."

#: src/bare-metal/aps/uart/traits.md
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"مثال را در QEMU با `make qemu_minimal` در زیر `src/bare-metal/aps/examples` "
"اجرا کنید."

#: src/bare-metal/aps/better-uart.md
msgid "A better UART driver"
msgstr "یک درایور UART بهتر"

#: src/bare-metal/aps/better-uart.md
#, fuzzy
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"‏ PL011 در واقع [مجموعه رجیسترهای زیادی دارد](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers) و اضافه کردن "
"offset برای ساختن اشاره‌گرها برای دسترسی به آنها مستعدخطا است و حتی فرآبند "
"خواندن را می‌تواند پیچیده کند، برخی از آن فیلدها از نوع bit هستند که دسترسی "
"به آنها به روشی ساختاریافته خوب است."

#: src/bare-metal/aps/better-uart.md
msgid "Offset"
msgstr "افست"

#: src/bare-metal/aps/better-uart.md
msgid "Register name"
msgstr "نام رجیستر"

#: src/bare-metal/aps/better-uart.md
msgid "Width"
msgstr "عرض"

#: src/bare-metal/aps/better-uart.md
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md
msgid "4"
msgstr "4"

#: src/bare-metal/aps/better-uart.md
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md
msgid "FR"
msgstr "FR"

#: src/bare-metal/aps/better-uart.md
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md
msgid "8"
msgstr "8"

#: src/bare-metal/aps/better-uart.md
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md
msgid "6"
msgstr "6"

#: src/bare-metal/aps/better-uart.md
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md
msgid "CR"
msgstr "CR"

#: src/bare-metal/aps/better-uart.md
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md
msgid "3"
msgstr "3"

#: src/bare-metal/aps/better-uart.md
msgid "There are also some ID registers which have been omitted for brevity."
msgstr "همچنین برخی از ID register هایی وجود دارد که برای اختصار حذف شده‌اند."

#: src/bare-metal/aps/better-uart/bitflags.md
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"این crate برای [`bitflags`](https://crates.io/crates/bitflags) جهت کار با "
"bitflags مفید است."

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Flags from the UART flag register.\n"
msgstr "/// Flags from the UART flag register.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Clear to send.\n"
msgstr "/// Clear to send.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Data set ready.\n"
msgstr "/// Data set ready.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Data carrier detect.\n"
msgstr "/// Data carrier detect.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// UART busy transmitting data.\n"
msgstr "/// UART busy transmitting data.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Receive FIFO is empty.\n"
msgstr "/// Receive FIFO is empty.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Transmit FIFO is full.\n"
msgstr "/// Transmit FIFO is full.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Receive FIFO is full.\n"
msgstr "/// Receive FIFO is full.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Transmit FIFO is empty.\n"
msgstr "/// Transmit FIFO is empty.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
#, fuzzy
msgid "/// Ring indicator.\n"
msgstr "/// Ring indicator.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"ماکرو `bitflags!` یک نوع جدید چیزی مانند`Flags(u16)` را به همراه تعدادی "
"پیاده‌سازی متد برای دریافت و تنظیم flagها ایجاد می‌کند."

#: src/bare-metal/aps/better-uart/registers.md
msgid "Multiple registers"
msgstr "رجیستر چندگانه"

#: src/bare-metal/aps/better-uart/registers.md
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"ما می‌توانیم از یک ساختار برای نمایش طرح memory layout یک رجیستر UART استفاده "
"کنیم."

#: src/bare-metal/aps/better-uart/registers.md
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"‏ [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) به کامپایلر می گوید که فیلدهای ساختاری را به ترتیب قرار دهد "
"و این پیروی از قوانین مشابه با زبان C است. این کار را برای ساختار ما برای "
"داشتن یک طرح قابل پیش‌بینی ضروری است، زیرا نمایش پیش‌فرض Rust به کامپایلر "
"اجازه می دهد تا (از جمله موارد دیگر) فیلدها را به هر نحوی که صلاح بداند مرتب "
"کند."

#: src/bare-metal/aps/better-uart/driver.md
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "حال بیایید از ساختار جدید `Registers` در درایور خود استفاده کنیم."

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "/// Driver for a PL011 UART.\n"
msgstr "/// Driver for a PL011 UART.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL011 device which is appropriately mapped.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
"\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control\n"
"            // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// SAFETY: We know that self.registers points to the control\n"
"            // registers of a PL011 device which is appropriately mapped.\n"

#: src/bare-metal/aps/better-uart/driver.md
#, fuzzy
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr "// TODO: Check for error conditions in bits 8-11.\n"

#: src/bare-metal/aps/better-uart/driver.md
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"به استفاده از `addr_of!` / `addr_of_mut!` برای دریافت pointerها به فیلدهای "
"جداگانه بدون ایجاد یک reference میانی توجه کنید، که ممکن است نادرست باشد."

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
msgid "Using it"
msgstr "با استفاده از آن"

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""
"بیایید یک برنامه کوچک با استفاده از درایور خود بنویسیم تا روی کنسول سریال "
"بنویسیم و بایت‌های ورودی را echo کنیم."

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base address of the primary PL011 UART.\n"
msgstr "/// Base address of the primary PL011 UART.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and\n"
"    // nothing else accesses that address range.\n"
msgstr ""
"// SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and\n"
"    // nothing else accesses that address range.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""

#: src/bare-metal/aps/better-uart/using.md
msgid "b'\\r'"
msgstr "b'\\r'"

#: src/bare-metal/aps/better-uart/using.md
#: src/concurrency/async-pitfalls/cancellation.md
msgid "b'\\n'"
msgstr "b'\\n'"

#: src/bare-metal/aps/better-uart/using.md
msgid "b'q'"
msgstr "b'q'"

#: src/bare-metal/aps/better-uart/using.md
msgid "\"Bye!\""
msgstr "\"Bye!\""

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"همانطور که در مثال [inline assembly]‌(../inline-assembly.md)، این تابع `main` "
"از کد نقطه ورودی ما در `entry.S` فراخوانی می‌شود. برای جزئیات بیشتر، "
"یادداشت‌های سخنرانی‌ها را در آنجا ببینید."

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"مثال را در QEMU با `make qemu` در زیر `src/bare-metal/aps/examples` اجرا "
"کنید."

#: src/bare-metal/aps/logging.md
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"خوب است که بتوانید از ماکروهای logging از crate [`log`](https://crates.io/"
"crates/log) استفاده کنید. ما می‌توانیم این کار را با اجرای ویژگی `Log` انجام "
"دهیم."

#: src/bare-metal/aps/logging.md
msgid "\"[{}] {}\""
msgstr "\"[{}] {}\""

#: src/bare-metal/aps/logging.md
#, fuzzy
msgid "/// Initialises UART logger.\n"
msgstr "/// Initialises UART logger.\n"

#: src/bare-metal/aps/logging.md
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"باز کردن در`log` ایمن است زیرا `LOGGER` را قبل از فراخوانی `set_logger` "
"مقداردهی اولیه می‌کنیم."

#: src/bare-metal/aps/logging/using.md
msgid "We need to initialise the logger before we use it."
msgstr "قبل از استفاده از لاگر باید مقداردهی اولیه کنیم."

#: src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"{info}\""
msgstr "\"{info}\""

#: src/bare-metal/aps/logging/using.md
msgid "Note that our panic handler can now log details of panics."
msgstr ""
"توجه داشته باشید که panic handler ما اکنون می تواند جزئیات panic را ثبت کند."

#: src/bare-metal/aps/logging/using.md
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"مثال را در QEMU با `make qemu_logger` در زیر `src/bare-metal/aps/examples` "
"اجرا کنید."

#: src/bare-metal/aps/exceptions.md
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"‏ AArch64 یک جدول برداری استثنایی با ۱۶ ورودی، برای ۴ نوع استثنا "
"(synchronous، IRQ، FIQ، SError) از ۴ حالت (Ecurrent EL with SP0, current EL "
"with SPx, lower EL using AArch64, lower EL using AArch32) تعریف می‌کند. ما "
"این کار را در اسمبلی پیاده‌سازی می‌کنیم تا رجیسترهای فرار (volatile) را قبل از "
"فراخوانی Rust در stack ذخیره کنیم:"

#: src/bare-metal/aps/exceptions.md
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""
"‏ EL سطح استثنا است. تمام نمونه‌های ما امروز بعدازظهر در EL1 اجرا می‌شوند."

#: src/bare-metal/aps/exceptions.md
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"برای سادگی، ما بین SP0 و SPx برای استثناهای EL فعلی، یا بین AArch32 و "
"AArch64 برای استثناهای پایین EL تمایز قائل نمی‌شویم."

#: src/bare-metal/aps/exceptions.md
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""
"برای این مثال، ما فقط exception را log کرده و سپس خاموش می‌کنیم، زیرا انتظار "
"نداریم هیچ یک از آنها واقعاً اتفاق بیفتد."

#: src/bare-metal/aps/exceptions.md
#, fuzzy
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"می‌توانیم به handlerهای exception و context اجرای اصلی‌مان کمابیش مانند "
"threadهای مختلف فکر کنیم. [`Send` and `Sync`](../../concurrency/send-sync."
"md) آنچه را که می‌توانیم بین آنها به اشتراک بگذاریم، دقیقاً مانند threadها، "
"کنترل می‌کنند. برای مثال، اگر می‌خواهیم مقداری را بین handlerهای exception و "
"بقیه برنامه به اشتراک بگذاریم که بیشتر در مورد `Send` است اما مربوط به "
"`Sync` نیست، باید آن را در چیزی مانند`Mutex` محصور کرده و یک استاتیک در آن "
"قرار دهیم."

#: src/bare-metal/aps/other-projects.md
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "\"coreboot without the C\""
msgstr "\"coreboot without the C\""

#: src/bare-metal/aps/other-projects.md
msgid "Supports x86, aarch64 and RISC-V."
msgstr "پشتیبانی از x86، aarch64 و RISC-V."

#: src/bare-metal/aps/other-projects.md
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "به جای اینکه خود درایورهای زیادی داشته باشد، به LinuxBoot متکی است."

#: src/bare-metal/aps/other-projects.md
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"راه‌اندازی، درایور UART و bootloader ساده، JTAG، سطوح exception، مدیریت "
"exception و page tableها"

#: src/bare-metal/aps/other-projects.md
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"برخی ابهامات در مورد نگهداری کَش و راه‌اندازی اولیه در Rust، لزوماً مثال خوبی "
"برای کپی کردن برای کد production نیست."

#: src/bare-metal/aps/other-projects.md
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md
msgid "Static analysis to determine maximum stack usage."
msgstr "تجزیه‌و‌تحلیل استاتیک برای تعیین حداکثر استفاده از stack."

#: src/bare-metal/aps/other-projects.md
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"آموزش سیستم عامل RaspberryPi، کد Rust را قبل از فعال شدن MMU و حافظه کَش اجرا "
"می‌کند. این کار memory را می‌خواند و روی آن می‌نویسد (به عنوان مثال stack). "
"بااین‌حال:"

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"بدون MMU و حافظه کَش، دسترسی‌های بدون تراز دچار خطا خواهند شد.این‌ها با "
"`aarch64-unknown-none` ساخته می‌شود که `+strict-align` را تنظیم کنند تا از "
"ایجاد دسترسی‌های غیرهمتراز توسط کامپایلر جلوگیری کند، بنابراین همیشه باید "
"صحیح باشد، اما لزوماً اینطور نیست."

#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"اگر در VM اجرا می‌شد، این می‌تواند منجر به مشکلات انسجام کَش (cache coherency) "
"شود. مشکل این است که ماشین مجازی مستقیماً با حافظه کَش غیرفعال شده به حافظه "
"دسترسی پیدا می‌کند، درحالی‌که host دارای alias قابل کَش برای همان حافظه است. "
"حتی اگر host به طور صریح به حافظه دسترسی نداشته باشد، دسترسی‌های موقتی "
"می‌تواند منجر به پر شدن حافظه کَش شود و سپس تغییرات از یکی پس از دیگری از بین "
"می‌رود. باز هم در این مورد خاص درست است (مستقیماً روی سخت‌افزار بدون hypervisor "
"اجرا می‌شود)، اما به‌طورکلی الگوی خوبی نیست."

#: src/bare-metal/useful-crates.md
msgid "Useful crates"
msgstr "جعبه‌های (crates) کاربردی"

#: src/bare-metal/useful-crates.md
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"ما به چند crate می‌پردازیم که برخی از مشکلات رایج در برنامه‌نویسی bare-metal "
"را حل می‌کند."

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"این crate [`zerocopy`](https://docs.rs/zerocopy/) (از Fuchsia) صفات و "
"ماکروهایی را برای تبدیل ایمن بین دنباله‌های بایت و انواع دیگر فراهم می‌کند."

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"این برای MMIO مناسب نیست (زیرا از خواندن و نوشتن فرار یا volatile استفاده "
"نمی‌کند)، اما می‌تواند برای کار با ساختارهای مشترک با سخت افزار مفید باشد. "
"توسط DMA، یا از طریق برخی از رابط‌های خارجی ارسال می‌شود."

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"‏ `FromBytes` را می‌توان برای انواعی که هر الگوی بایتی برای آنها معتبر است "
"پیاده‌سازی کرد و بنابراین می‌توان با خیال راحت از یک دنباله بایت‌های نامعتبر "
"تبدیل کرد."

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"تلاش برای استخراج `FromBytes` برای این تایپ‌ها ناموفق خواهد بود، زیرا "
"`RequestType` از همه مقادیر ممکن u32 به عنوان متمایزکننده استفاده نمی‌کند، "
"بنابراین همه الگوهای بایت معتبر نیستند."

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder` دارای تایپ‌های برای اعداد اولیه مطلع از byte-order است."

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"مثال را با `cargo run` در `src/bare-metal/useful-crates/zerocopy-example/"
"`اجرا کنید. (به دلیل وابستگی به crate در Playground اجرا نمی‌شود.)"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"این crate [`aarch64-paging`](https://crates.io/crates/aarch64-paging) به شما "
"امکان می‌دهد page tableها را مطابق با معماری سیستم حافظه‌مجازی AArch64 ایجاد "
"کنید."

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Create a new page table with identity mapping.\n"
msgstr "// Create a new page table with identity mapping.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr "// Map a 2 MiB region of memory as read-only.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
#, fuzzy
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr "// Set `TTBR0_EL1` to activate the page table.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"در حال حاضر فقط از EL1 پشتیبانی می‌کند، اما پشتیبانی از سایر سطوح استثنا باید "
"ساده باشد."

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"این مورد در Android برای [Protected VM Firmware]‌(https://cs.android.com/"
"android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/) استفاده می‌شود."

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"هیچ راه آسانی برای اجرای این مثال وجود ندارد، زیرا باید روی سخت‌افزار واقعی "
"یا تحت QEMU اجرا شود."

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"‏ ['buddy_system_allocator'](https://crates.io/crates/buddy_system_allocator) "
"یک third-party crate است که یک buddy system allocator را پیاده‌سازی می‌کند. "
"می‌توان آن را هم برای ['LockedHeap'](https://docs.rs/"
"buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html) "
"در پیاده‌سازی [`GlobalAlloc`]‌(https://doc.rust-lang.org/core/alloc/trait."
"GlobalAlloc.html) استفاده کرد. بنابراین می‌توانید از crate استاندارد `alloc` "
"(همانطور که [قبل از](../alloc.md) دیدیم) یا برای تخصیص فضای آدرس دیگر "
"استفاده کنید. به عنوان مثال، ممکن است بخواهیم فضای MMIO را برای PCI BARها "
"اختصاص دهیم:"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "PCI BARs always have alignment equal to their size."
msgstr "‏ PCI BAR‌ها همیشه دارای تراز برابر با اندازه خود هستند."

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"مثال را با `cargo run` در `src/bare-metal/useful-crates/allocator-example/` "
"اجرا کنید. (به دلیل وابستگی به crate در Playground اجرا نمی‌شود.)"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"گاهی اوقات شما چیزی را می‌خواهید که بتوان آن را مانند Vec تغییر اندازه داد، "
"اما بدون heap allocation که [`tinyvec`]  (https://crates.io/crates/tinyvec) "
"این را فراهم می‌کند: یک برداری که توسط یک آرایه یا برش پشتیبانی می‌شود که "
"می‌تواند به‌صورت ایستا allocate داده شود یا روی stack که تعداد عناصر استفاده "
"شده را ردیابی می‌کند و اگر سعی کنید بیشتر از آنچه که اختصاص‌داده‌شده را استفاده "
"کنید panic می‌کند."

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"‏ `tinyvec` نیاز دارد که تایپ عنصر `Default` را برای مقداردهی اولیه اجرا کند."

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"‏ Rust Playground شامل `tinyvec` می‌شود، بنابراین این مثال به‌خوبی به صورت "
"داخلی اجرا می‌شود."

#: src/bare-metal/useful-crates/spin.md
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"‏ `std::sync::Mutex` و دیگر موارد اولیه همگام‌سازی از `std::sync` در `core` یا "
"`alloc` موجود نیستند. چگونه می‌توانیم هماهنگ‌سازی یا تغییرپذیری داخلی، مانند "
"اشتراک‌گذاری وضعیت بین CPU‌های مختلف را مدیریت کنیم؟"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"این crate [`spin`](https://crates.io/crates/spin) معادل‌های مبتنی بر "
"spinlock، بسیاری از این موارد اولیه را ارائه می‌کند."

#: src/bare-metal/useful-crates/spin.md
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"اگر در handlerهای وقفه قفل می‌کنید مراقب باشید که از بن بست(deadlock) جلوگیری "
"کنید."

#: src/bare-metal/useful-crates/spin.md
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"‏ `spin` همچنین دارای اجرای  ticket lock mutex است. معادل‌های `RwLock`, "
"`Barrier` و `Once` از `std::sync`. و `Lazy` برای مقداردهی اولیه lazy."

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"این crate ['once_cell'](https://crates.io/crates/once_cell) همچنین دارای "
"تایپ‌های مفیدی برای مقداردهی اولیه دیرهنگام با رویکرد کمی متفاوت به `spin::"
"once::Once` است."

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"‏ Playground Rust شامل `spin` است، بنابراین این مثال به خوبی به صورت داخلی "
"اجرا می‌شود."

#: src/bare-metal/android.md
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"برای ساختن یک bare-metal Rust binary در AOSP، باید از یک `rust_ffi_static` "
"Soong برای ساخت کد Rust خود استفاده کنید، سپس از یک `cc_binary` با یک linker "
"script برای تولید binary استفاده کرده و سپس از یک `raw_binary` برای تبدیل "
"ELF به یک raw binary آماده اجرا استفاده کنید."

#: src/bare-metal/android/vmbase.md
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md
#, fuzzy
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/main/"
"libs/libvmbase/) library provides a linker script and useful defaults for "
"the build rules, along with an entry point, UART console logging and more."
msgstr ""
"برای ماشین‌های مجازی که تحت crosvm در aarch64 اجرا می‌شوند، کتابخانه [vmbase]"
"(https://android.googlesource.com/platform/packages/modules/Virtualization/+/"
"refs/heads/master/vmbase/) یک اسکریپت linker و پیش‌فرض‌های مفیدی را ارائه "
"می‌کند. برای این قوانین ساخت، همراه با یک نقطه ورودی، UART console logging و "
"موارد دیگر."

#: src/bare-metal/android/vmbase.md
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""
"این ماکرو `main!`عملکرد اصلی شما را مشخص می‌کند تا از نقطه ورودی `vmbase` "
"فراخوانی شود."

#: src/bare-metal/android/vmbase.md
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"نقطه ورودی `vmbase` مقدار دهی اولیه کنسول را کنترل می‌کند و در صورت بازگشت "
"main function، یک PSCI_SYSTEM_OFF برای خاموش کردن VM صادر می‌کند."

#: src/exercises/bare-metal/afternoon.md
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "ما یک درایور برای دستگاه PL031 real-time clock  خواهیم نوشت."

#: src/exercises/bare-metal/afternoon.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"پس از بررسی تمرین‌ها، می‌توانید به [راه‌حل ها](solutions-afternoon.md) ارائه "
"شده نگاهی بیندازید."

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "RTC driver"
msgstr "RTC driver"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"ماشین QEMU aarch64 virt دارای یک ساعت بلادرنگ [PL031](https://developer.arm."
"com/documentation/ddi0224/c) در 0x9010000 است. برای این تمرین باید یک درایور "
"برای آن بنویسید."

#: src/exercises/bare-metal/rtc.md
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""
"از آن برای چاپ زمان جاری در کنسول سریال استفاده کنید. می‌توانید از crate "
"[`chrono`](https://crates.io/crates/chrono) برای قالب‌بندی date/time استفاده "
"کنید."

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""
"از match register و raw interrupt status استفاده کنید تا تا زمان معینی منتظر "
"بمانید، به عنوان مثال. ۳ ثانیه در آینده نزدیک (Call [`core::hint::spin_loop`]"
"(https://doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"

#: src/exercises/bare-metal/rtc.md
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""
"‏ _افزونه‌ها اگر زمان دارید:_ وقفه ایجاد شده توسط تطبیق RTC را فعال کرده و آن "
"را مدیریت کنید. می‌توانید از درایور ارائه شده در crate [`arm-gic`](https://"
"docs.rs/arm-gic/) برای پیکربندی Arm Generic Interrupt Controller استفاده "
"کنید."

#: src/exercises/bare-metal/rtc.md
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr "از وقفه RTC استفاده کنید که به عنوان `IntId::spi(2)` به GIC متصل است."

#: src/exercises/bare-metal/rtc.md
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""
"هنگامی که وقفه (interrupt) فعال شد، می‌توانید هسته را از طریق `arm_gic::"
"wfi()` به حالت Sleep درآورید، که باعث می‌شود هسته تا زمانی که وقفه دریافت کند "
"به خواب برود."

#: src/exercises/bare-metal/rtc.md
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""
"دانلود از [exercise template](../../comprehensive-rust-exercises.zip) و "
"فایل‌های زیر را در دایرکتوری `rtc` جستجو کنید."

#: src/exercises/bare-metal/rtc.md
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""
"‏ _src/exceptions.rs_ (شما فقط باید این را برای بخش سوم تمرین تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr "‏ _src/logger.rs_ (نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr "_src/pl011.rs_ (نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr "_build.rs_ (نیازی نیست این مورد رو تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr "_entry.S_ ( نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr "_exceptions.S_ ( نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr "_idmap.S_ (نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr "_image.ld_ (نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr "_Makefile_ (نیازی نیست این مورد را تغییر دهید):"

#: src/exercises/bare-metal/rtc.md
msgid "Run the code in QEMU with `make qemu`."
msgstr "کد را در QEMU با  `make qemu` اجرا کنید."

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "Bare Metal Rust Afternoon"
msgstr "بعدازظهربا Bare Metal Rust"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "([back to exercise](rtc.md))"
msgstr "([back to exercise](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "_main.rs_:"
msgstr "_main.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base addresses of the GICv3.\n"
msgstr "/// Base addresses of the GICv3.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Base address of the PL031 RTC.\n"
msgstr "/// Base address of the PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr "/// The IRQ used by the PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr "\"main({:#x}, {:#x}, {:#x}, {:#x})\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""
"// SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and\n"
"    // nothing else accesses that address range.\n"
msgstr ""
"// SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and\n"
"    // nothing else accesses that address range.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"RTC: {time}\""
msgstr "\"RTC: {time}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr "// Wait for 3 seconds, without interrupts.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"Waiting for {}\""
msgstr "\"Waiting for {}\""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"matched={}, interrupt_pending={}\""
msgstr "\"matched={}, interrupt_pending={}\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "\"Finished waiting\""
msgstr "\"Finished waiting\""

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr "// Wait another 3 seconds for an interrupt.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "_pl031.rs_:"
msgstr "_pl031.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Data register\n"
msgstr "/// Data register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Match register\n"
msgstr "/// Match register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Load register\n"
msgstr "/// Load register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Control register\n"
msgstr "/// Control register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr "/// Interrupt Mask Set or Clear register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Raw Interrupt Status\n"
msgstr "/// Raw Interrupt Status\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Masked Interrupt Status\n"
msgstr "/// Masked Interrupt Status\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Interrupt Clear Register\n"
msgstr "/// Interrupt Clear Register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr "/// Driver for a PL031 real-time clock.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Reads the current RTC value.\n"
msgstr "/// Reads the current RTC value.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL031 device which is appropriately mapped.\n"
msgstr ""
"// SAFETY: We know that self.registers points to the control registers\n"
"        // of a PL031 device which is appropriately mapped.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "/// Clears a pending interrupt, if any.\n"
msgstr "/// Clears a pending interrupt, if any.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid ""
"// SAFETY: `Rtc` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// SAFETY: `Rtc` just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"

#: src/concurrency/welcome.md
msgid "Welcome to Concurrency in Rust"
msgstr "به مبحث Concurrency در Rust خوش‌آمدید"

#: src/concurrency/welcome.md
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"زبان Rust به طور کامل از concurrency در سطح thread های سیستم‌عامل با استفاده "
"از mutex ها و channel ها پشتیبانی می‌کند."

#: src/concurrency/welcome.md
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"سیستم Rust راست نقش مهمی در تبدیل بسیاری از باگ‌های concurrency به باگ‌های "
"زمان کامپایل ایفا می‌کند. این مورد اغلب به‌عنوان هم‌زمانی بی‌پروا ( _fearless "
"concurrency_) شناخته می‌شود زیرا می‌توانید به کامپایلر برای اطمینان از صحت در "
"زمان اجرا (runtime) اعتماد کنید."

#: src/concurrency/welcome.md src/concurrency/welcome-async.md
msgid ""
"Including 10 minute breaks, this session should take about 3 hours and 20 "
"minutes. It contains:"
msgstr ""
"با احتساب استراحت‌های ۱۰ دقیقه‌ای، این جلسه باید حدود ۳ ساعت و ۲۰ دقیقه طول "
"بکشد. شامل موارد زیر است:"

#: src/concurrency/welcome.md
msgid ""
"Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc."
msgstr ""
"‏ Rust به ما اجازه می‌دهد تا به ابزارهای همزمانی سیستم عامل دسترسی داشته "
"باشیم: thread‌ها، سازوکارهای همگام‌سازی و غیره."

#: src/concurrency/welcome.md
msgid ""
"The type system gives us safety for concurrency without any special features."
msgstr ""
"این سیستم تایپ به ما ایمنی لازم برای concurrency بدون هیچ ویژگی خاصی می‌دهد."

#: src/concurrency/welcome.md
msgid ""
"The same tools that help with \"concurrent\" access in a single thread (e."
"g., a called function that might mutate an argument or save references to it "
"to read later) save us from multi-threading issues."
msgstr ""
" همان ابزارهایی که به ما در دسترسی concurrent در یک thread واحد کمک می‌کنند "
"(مانند یک تابع فراخوانی شده که ممکن است یک آرگومان را تغییر دهد یا مراجعی به "
"آن را برای خواندن بعد ذخیره کند) ما را از مشکلات multi-threading نجات می‌دهند."

#: src/concurrency/threads.md src/concurrency/shared-state.md
#: src/concurrency/async.md
msgid "This segment should take about 30 minutes. It contains:"
msgstr "این بخش باید حدود ۳۰ دقیقه طول بکشد و شامل موارد زیر است:"

#: src/concurrency/threads/plain.md
msgid "Rust threads work similarly to threads in other languages:"
msgstr "threadهای Rust مانند threadها در زبان‌های دیگر کار می‌کنند:"

#: src/concurrency/threads/plain.md
msgid "\"Count in thread: {i}!\""
msgstr "\"شمارنده thread: {i}!\""

#: src/concurrency/threads/plain.md
msgid "\"Main thread: {i}\""
msgstr "\"Main thread: {i}\""

#: src/concurrency/threads/plain.md
msgid ""
"Spawning new threads does not automatically delay program termination at the "
"end of `main`."
msgstr ""
"ایجاد threadهای جدید به طور خودکار خاتمه برنامه را تا پایان `main` به تاخیر "
"نمی‌اندازد."

#: src/concurrency/threads/plain.md
msgid "Thread panics are independent of each other."
msgstr "Thread panicها مستقل از یکدیگر هستند."

#: src/concurrency/threads/plain.md
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"‏Panicها می‌تواند payloadای را حمل کند که می‌توان آن را با «downcast_ref» باز "
"کرد."

#: src/concurrency/threads/plain.md
msgid "Rust thread APIs look not too different from e.g. C++ ones."
msgstr ""
"‏Rust thread API ها خیلی متفاوت از موارد دیگر به نظر نمی‌رسند. که C++ یکی از "
"آن‌ها است."

#: src/concurrency/threads/plain.md
msgid "Run the example."
msgstr "مثال را اجرا کنید."

#: src/concurrency/threads/plain.md
msgid ""
"5ms timing is loose enough that main and spawned threads stay mostly in "
"lockstep."
msgstr ""
"زمان‌بندی 5 میلی‌ثانیه به اندازه‌ای سست هستند که thread اصلی و spawned threadها "
"عمدتاً همگام می‌مانند."

#: src/concurrency/threads/plain.md
msgid "Notice that the program ends before the spawned thread reaches 10!"
msgstr ""
"توجه داشته باشید که برنامه قبل از اینکه thread spawned به مقدار ۱۰ برسد به "
"پایان می‌رسد!"

#: src/concurrency/threads/plain.md
msgid ""
"This is because main ends the program and spawned threads do not make it "
"persist."
msgstr ""
"این به خاطر است که انتهای main برنامه است و spawned threadها ایجاد شده باعث "
"تداوم آن نمی‌شوند."

#: src/concurrency/threads/plain.md
msgid "Compare to pthreads/C++ std::thread/boost::thread if desired."
msgstr "در مقابسه با pthreads/C++ std::thread/boost::thread اگر مطلوب باشد."

#: src/concurrency/threads/plain.md
msgid "How do we wait around for the spawned thread to complete?"
msgstr "چقدر باید صبر کنیم تا یک spawned thread تکمیل شود؟"

#: src/concurrency/threads/plain.md
msgid ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) "
"returns a `JoinHandle`. Look at the docs."
msgstr ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) "
"returns a `JoinHandle`. به سند نگاه کنید."

#: src/concurrency/threads/plain.md
msgid ""
"`JoinHandle` has a [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) method that blocks."
msgstr ""
"`JoinHandle` دارد [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) متد آن بلاک‌ها."

#: src/concurrency/threads/plain.md
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish and have the program count all the way to 10."
msgstr ""
"از «let handle = thread::spawn(...)» و بعد از «handle.join()» استفاده کنید "
"تا منتظر بمانید تا thread تمام شود و شمارنده برنامه برابر با مقدار ۱۰ باشد."

#: src/concurrency/threads/plain.md
msgid "Now what if we want to return a value?"
msgstr "حالا اگر بخواهیم مقداری را برگردانیم چه؟"

#: src/concurrency/threads/plain.md
msgid "Look at docs again:"
msgstr "دوباره به اسناد نگاه کنید:"

#: src/concurrency/threads/plain.md
msgid ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html)'s "
"closure returns `T`"
msgstr ""
"[`thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html)'s "
"closure returns `T`"

#: src/concurrency/threads/plain.md
msgid ""
"`JoinHandle` [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) returns `thread::Result<T>`"
msgstr ""
"`JoinHandle` [`.join()`](https://doc.rust-lang.org/std/thread/struct."
"JoinHandle.html#method.join) returns `thread::Result<T>`"

#: src/concurrency/threads/plain.md
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"returned value."
msgstr ""
"به کمک`Result` از «handle.join()» برای دسترسی به مقدار برگشتی استفاده کنید."

#: src/concurrency/threads/plain.md
msgid "Ok, what about the other case?"
msgstr "خوب، مورد دیگر چطور؟"

#: src/concurrency/threads/plain.md
msgid "Trigger a panic in the thread. Note that this doesn't panic `main`."
msgstr ""
"فعال‌سازی یک panic در یک thread. توجه شود که این مورد panic `main` نیست."

#: src/concurrency/threads/plain.md
msgid ""
"Access the panic payload. This is a good time to talk about [`Any`](https://"
"doc.rust-lang.org/std/any/index.html)."
msgstr ""
"دسترسی به این panic payload. بهترین زمان برای پرداخت به این موضوع است [`Any`]"
"(https://doc.rust-lang.org/std/any/index.html)."

#: src/concurrency/threads/plain.md
msgid "Now we can return values from threads! What about taking inputs?"
msgstr ""
"اکنون می‌توانیم مقادیر را از رشته‌ها برگردانیم! در مورد گرفتن ورودی‌ها چطور؟"

#: src/concurrency/threads/plain.md
msgid "Capture something by reference in the thread closure."
msgstr "چیزی را از طریق reference در بسته‌بندی thread  ثبت کنید."

#: src/concurrency/threads/plain.md
msgid "An error message indicates we must move it."
msgstr "یک پیغام خطا نشان می‌دهد که باید آن را جابجا کنیم."

#: src/concurrency/threads/plain.md
msgid "Move it in, see we can compute and then return a derived value."
msgstr ""
"آن را به داخل منتقل کنید، درنتیجه ما می توانیم محاسبه کنیم و سپس یک مقدار "
"مشتق شده را برگردانیم."

#: src/concurrency/threads/plain.md
msgid "If we want to borrow?"
msgstr "اگر بخواهیم قرض (borrow) بگیریم چطور؟"

#: src/concurrency/threads/plain.md
msgid ""
"Main kills child threads when it returns, but another function would just "
"return and leave them running."
msgstr ""
" تابع ‏Main در هنگام بازگشت threadهای فرزند را از بین می‌برد، اما تابع دیگری "
"return می‌شود و آنها را در حال اجرا می‌گذارد."

#: src/concurrency/threads/plain.md
msgid "That would be stack use-after-return, which violates memory safety!"
msgstr ""
"این کار می‌تواند منجر به stack استفاده پس از return شود که memory safety را "
"نقض می‌کند!"

#: src/concurrency/threads/plain.md
msgid "How do we avoid this? see next slide."
msgstr "چگونه از آن جلوگیری کنیم؟ صفحه بعدی را ببینید."

#: src/concurrency/threads/scoped.md
msgid "Normal threads cannot borrow from their environment:"
msgstr "‏thread‌های معمولی نمی‌توانند از محیط خود قرض (borrow) بگیرند:"

#: src/concurrency/threads/scoped.md
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"به‌هرحال, می‌توانید برای این مورد [scoped thread](https://doc.rust-lang.org/"
"std/thread/fn.scope.html) ببینید:"

#: src/concurrency/threads/scoped.md
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"دلیل آن این است که وقتی تابع «thread::scope» کامل می‌شود، اتصال همه thread‌ها "
"تضمین می‌شود، بنابراین می‌توانند داده‌های قرضی را برگردانند."

#: src/concurrency/threads/scoped.md
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"قوانین عادی قرض‌گیری Rust اعمال می‌شود: شما می‌توانید به‌صورت تغییرپذیر(mutable) "
"با یک thread یا غیرقابل تغییر (immutable) با هر تعداد thread قرض (borrow) "
"بگیرید."

#: src/concurrency/channels.md src/concurrency/async-control-flow.md
msgid "This segment should take about 20 minutes. It contains:"
msgstr "این بخش باید حدود ۲۰ دقیقه طول بکشد. این شامل:"

#: src/concurrency/channels/senders-receivers.md
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"کانال‌های Rust دارای دو بخش هستند: `Sender<T>` و `Receiver<T>`. این دو بخش از "
"طریق channel به هم متصل می‌شوند، اما شما فقط نقاط پایانی (end-points) را "
"می‌بینید."

#: src/concurrency/channels/senders-receivers.md
msgid "\"Received: {:?}\""
msgstr "\"دریافت شد: {:?}\""

#: src/concurrency/channels/senders-receivers.md
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""

#: src/concurrency/channels/senders-receivers.md
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""

#: src/concurrency/channels/unbounded.md
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "شما یک کانال نامحدود و ناهمزمان با `mpsc::channel()` دریافت می کنید:"

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"Message {i}\""
msgstr "\"Message {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr "\"{thread_id:?}: sent Message {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"{thread_id:?}: done\""
msgstr "\"{thread_id:?}: انجام شد\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"Main: got {msg}\""
msgstr "\"Main: got {msg}\""

#: src/concurrency/channels/bounded.md
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr ""
"با کانال‌های bounded (synchronous)، فرآیند `send` می‌تواند thread فعلی را "
"مسدود کند:"

#: src/concurrency/channels/bounded.md
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"فراخوانی  `send` تا زمانی که فضای کافی در کانال برای پیام جدید وجود داشته "
"باشد، thread کنونی را مسدود می‌کند. اگر کسی از کانال چیزی نخواند آنگاه thread "
"را می‌توان به طور نامحدود مسدود کرد."

#: src/concurrency/channels/bounded.md
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"اگر کانال بسته شود، تماس برای `send` با یک error قطع می‌شود (به همین "
"دلیل`Result` را برمی‌گرداند. هنگامی که گیرنده از بین می رود یک کانال بسته "
"می‌شود."

#: src/concurrency/channels/bounded.md
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `recv`."
msgstr ""
"یک کانال محدود ( bounded channel) با اندازه صفر را \"کانال ملاقات\" یا "
"\"rendezvous channel\" می‌‌نامند. هر ارسال، thread فعلی را مسدود می‌کند تا "
"زمانی که رشته دیگری `recv` را فراخواند."

#: src/concurrency/send-sync.md
msgid "Send"
msgstr "ارسال"

#: src/concurrency/send-sync.md
msgid "Sync"
msgstr "همگام‌سازی"

#: src/concurrency/send-sync/marker-traits.md
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"‏ Rust چگونه می‌داند که دسترسی مشترک در سراسر threadها را ممنوع می‌کند؟ پاسخ در "
"دو trait است:"

#: src/concurrency/send-sync/marker-traits.md
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"‏[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): در صورتی که "
"جابجایی `T` در امتداد thread boundary ایمن باشد، تایپ `T` از جنس `Send` است."

#: src/concurrency/send-sync/marker-traits.md
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"‏[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): در صورتی که "
"جابجایی یک `&T` در سراسر یک thread boundary ایمن باشد، یک تایپ `T` از جنس "
"`Sync`  است."

#: src/concurrency/send-sync/marker-traits.md
msgid ""
"`Send` and `Sync` are [unsafe traits](../../unsafe-rust/unsafe-traits.md). "
"The compiler will automatically derive them for your types as long as they "
"only contain `Send` and `Sync` types. You can also implement them manually "
"when you know it is valid."
msgstr ""
"‏`Send` و `Sync` [ویژگی‌های ناامن] هستند (../../unsafe-rust/unsafe-traits.md). "
"کامپایلر به‌طور خودکار آنها را برای تایپ‌های شما مشتق می‌کند تا زمانی که فقط "
"دارای انواع `Send` و `Sync` باشند. شما همچنین می توانید آنها را به صورت دستی "
"پیاده سازی کنید به‌خصوص زمانی که می دانید مقدار آن معتبر است."

#: src/concurrency/send-sync/marker-traits.md
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"می‌توان این traitها را به عنوان نشانگرهایی در نظر گرفت که نوعی ویژگی thread-"
"safety خاصی را دارد."

#: src/concurrency/send-sync/marker-traits.md
msgid "They can be used in the generic constraints as normal traits."
msgstr "آنها را می‌توان در محدودیت‌های generic به عنوان  trait عادی استفاده کرد."

#: src/concurrency/send-sync/send.md
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"اگر انتقال مقدار `T` به thread دیگری امن باشد، تایپ `T` در [`Send`](https://"
"doc.rust-lang.org/std/marker/trait.Send.html) است."

#: src/concurrency/send-sync/send.md
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"تأثیر انتقال مالکیت (moving ownership) به یک thread دیگر این است که "
"_نابودگرها_ ( _destructors_ ) در آن thread اجرا می شوند. بنابراین سوال این "
"است که چه زمانی می‌توانید یک مقدار را در یک thread تخصیص دهید و آن را در "
"thread دیگر توزیع کنید."

#: src/concurrency/send-sync/send.md
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"به عنوان مثال، اتصال به کتابخانه SQLite فقط باید از یک thread قابل دسترسی "
"باشد."

#: src/concurrency/send-sync/sync.md
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"یک تایپ `T` در واقع نوعی [`Sync`](https://doc.rust-lang.org/std/marker/trait."
"Sync.html) است، اگر در دسترسی به یک  مقدار`T` از طریق چندین رشته به طور "
"همزمان امن باشد."

#: src/concurrency/send-sync/sync.md
msgid "More precisely, the definition is:"
msgstr "به طور دقیق‌تر، تعریف این طور است:"

#: src/concurrency/send-sync/sync.md
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`T` یک نوع `Sync` فقط و فقط زمانی که `&T` یک نوع `Send` باشد"

#: src/concurrency/send-sync/sync.md
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"این عبارت به طور کلی روشی مختصر برای گفتن این است که اگر یک تایپ برای "
"استفاده مشترک امن باشد، انتقال ارجاعات (pass references) آن به threadها نیز "
"امن است."

#: src/concurrency/send-sync/sync.md
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"این به خاطراست که اگر یک تایپ از جنس Sync باشد، به این معنی است که می‌توان آن "
"را در چند thread بدون خطر در مورد وضعیت رقابتی داده یا سایر مشکلات Sync به "
"اشتراک گذاشت، بنابراین انتقال آن به thread‌ای دیگر امن است. ارجاع به تایپ  "
"نیز برای انتقال به threadای دیگر ایمن است، زیرا داده‌هایی که به آن ارجاع "
"می‌دهد می‌توانند از هر threadای با خیال راحت دسترسی داشته باشند."

#: src/concurrency/send-sync/examples.md
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md
msgid "Most types you come across are `Send + Sync`:"
msgstr "اکثر انواعی که با آنها روبرو می شوید `Send + Sync` هستند:"

#: src/concurrency/send-sync/examples.md
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, ..."

#: src/concurrency/send-sync/examples.md
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."

#: src/concurrency/send-sync/examples.md
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr ""
"‏`Arc<T>`:به طور صریح از طریق تعداد شمارش atomic reference  با thread-safe."

#: src/concurrency/send-sync/examples.md
msgid "`mpsc::Sender<T>`: As of 1.72.0."
msgstr "`mpsc::Sender<T>`: از 1.72.0."

#: src/concurrency/send-sync/examples.md
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"‏`AtomicBool`، `AtomicU8`، ...: از دستورالعمل های atomic ویژه استفاده می‌کند."

#: src/concurrency/send-sync/examples.md
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"در صورت وجود پارامترهای نوع، تایپ‌های generic معمولاً از نوع  `Send + Sync`  "
"هستند.`Send + Sync`."

#: src/concurrency/send-sync/examples.md
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"این تایپ‌ها را می‌توان به رشته‌های دیگر منتقل کرد، اما آنها ایمن نیستند. به طور "
"معمول به دلیل تغییرپذیری داخلی(interior mutability):"

#: src/concurrency/send-sync/examples.md
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`Cell<T>`"
msgstr "`Cell<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"These types are safe to access (via shared references) from multiple "
"threads, but they cannot be moved to another thread:"
msgstr ""
"این تایپ‌ها از نظر thread ایمن هستند، اما نمی توان آنها را به thread دیگری "
"منتقل کرد:"

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them. However, an already-locked mutex can have its "
"guarded variable read by any thread with which the guard is shared."
msgstr ""
"‏«MutexGuard<T: Sync>»: از ابتدایی‌های سطح سیستم‌عامل استفاده می‌کند که باید در "
"threadای که آنها را ایجاد کرده است، توزیع شوند."

#: src/concurrency/send-sync/examples.md
msgid "`!Send + !Sync`"
msgstr "`!Send + !Sync`"

#: src/concurrency/send-sync/examples.md
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"این تایپ‌ها از نظر thread ایمن نیستند و نمی توان آنها را به رشته های دیگر "
"منتقل کرد:"

#: src/concurrency/send-sync/examples.md
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"‏\"Rc<T>\": هر \"Rc<T>\" دارای یک ارجاع به \"RcBox<T>\" است که حاوی تعداد "
"مراجع غیر atomic است."

#: src/concurrency/send-sync/examples.md
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"درمورد `*const T`, `*mut T`: زبان فرض Rust می کند که اشاره گرهای خام ممکن "
"است ملاحظات همزمانی خاصی داشته باشند."

#: src/concurrency/shared-state.md
msgid "Arc"
msgstr "Arc"

#: src/concurrency/shared-state.md
msgid "Mutex"
msgstr "Mutex"

#: src/concurrency/shared-state/arc.md
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"‏[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) اجازه می‌دهد "
"تا دسترسی read-only مشترک از طریق `Arc::clone` صورت پذیرد:"

#: src/concurrency/shared-state/arc.md
msgid "\"{thread_id:?}: {v:?}\""
msgstr "\"{thread_id:?}: {v:?}\""

#: src/concurrency/shared-state/arc.md src/concurrency/shared-state/example.md
msgid "\"v: {v:?}\""
msgstr "\"v: {v:?}\""

#: src/concurrency/shared-state/arc.md
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"‏\"Arc\" مخفف \"Atomic Reference Counted\" است، یک نسخه ایمن از `Rc` که از "
"عملیات atomic استفاده می‌کند."

#: src/concurrency/shared-state/arc.md
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"‏\"Arc<T>\" به طور کلی \"Clone\" را خواه `T` انجام دهد یا نه، پیاده سازی می "
"کند. `Send` و `Sync` را اگر و فقط در صورتی پیاده‌سازی می‌کند که `T` هر دوی "
"آنها را پیاده‌سازی کند."

#: src/concurrency/shared-state/arc.md
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` هزینه یک عملیات atomic که اجرا می‌شود را دارد، اما پس از آن "
"استفاده از 'T' آزاد است."

#: src/concurrency/shared-state/arc.md
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"مراقب reference cycleها باشید، `Arc` از garbage collector برای شناسایی آنها "
"استفاده نمی‌کند."

#: src/concurrency/shared-state/arc.md
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` می‌تواند مفید باشد."

#: src/concurrency/shared-state/mutex.md
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface (another form of [interior mutability](../../borrowing/interior-"
"mutability.md)):"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) تضمین "
"می‌کند که حذف متقابل _و_ امکان دسترسی قابل تغییر (mutable) به \"T\" را در پشت "
"یکread-only interface  (شکل دیگری از [تغییرپذیری (mutable) داخلی](../../"
"borrowing/interior-mutability.md)) فراهم می‌کند."

#: src/concurrency/shared-state/mutex.md
msgid "\"v: {:?}\""
msgstr "\"v: {:?}\""

#: src/concurrency/shared-state/mutex.md
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"توجه کنید که چگونه یک [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) برای اجرای "
"کامل آن داریم."

#: src/concurrency/shared-state/mutex.md
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"‏«Mutex» در Rust مانند مجموعه‌ای با تنها یک عنصر --- داده‌های محافظت شده "
"(protected) به نظر می‌رسد."

#: src/concurrency/shared-state/mutex.md
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"نمی‌توان قبل از دسترسی به داده‌های محافظت شده یا protected، دسترسی mutex را "
"فراموش کرد."

#: src/concurrency/shared-state/mutex.md
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"با گرفتن lock می‌توانید `&mut T` را از `&Mutex<T>` دریافت کنید.`MutexGuard` "
"تضمین می‌کند که`&mut T` بیشتر از قفل نگه‌داشته شده، موجود نمی‌ماند."

#: src/concurrency/shared-state/mutex.md
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"‏`Mutex<T>` هر دوی پیاده سازی `Send` و `Sync` iff (فقط و فقط) `T` از `Send` "
"استفاده‌ می‌کنند."

#: src/concurrency/shared-state/mutex.md
msgid "A read-write lock counterpart: `RwLock`."
msgstr "‏ همتای قفل خواندن و نوشتن: `RwLock`."

#: src/concurrency/shared-state/mutex.md
msgid "Why does `lock()` return a `Result`?"
msgstr "چرا `lock()` یک`Result` برمی‌گرداند؟"

#: src/concurrency/shared-state/mutex.md
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"اگر threadای که  `Mutex`  را نگه می‌دارد دچار panic شود، `Mutex` «مسموم/"
"poisoned» می‌شود تا نشان دهد که داده‌هایی که محافظت می‌کند ممکن است در وضعیت "
"ناسازگاری باشند. فراخوانی `lock()` در یک mutex مسموم با یک [«PoisonError»] "
"(https://doc.rust-lang.org/std/sync/struct.PoisonError.html) انجام نمی‌شود. "
"می‌توانید `into_inner()` را در مورد خطا برای بازیابی داده‌ها بدون توجه به آن "
"فراخوانی کنید."

#: src/concurrency/shared-state/example.md
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "اجازه دهید `Arc` و `Mutex` را در عمل ببینیم:"

#: src/concurrency/shared-state/example.md
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr "// use std::sync::{Arc, Mutex};\n"

#: src/concurrency/shared-state/example.md
msgid "Possible solution:"
msgstr "راه‌حل ممکن:"

#: src/concurrency/shared-state/example.md
msgid "Notable parts:"
msgstr "بخش‌های قابل توجه:"

#: src/concurrency/shared-state/example.md
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr "‏ `v` در `Arc` و `Mutex` احاطه می‌شود، زیرا مسائل آنها شبیه به هم است."

#: src/concurrency/shared-state/example.md
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"قرار دادن یک `Mutex` در یک `Arc` یک الگوی رایج برای به اشتراک گذاشتن حالت "
"قابل تغییر (mutable) بین threadها است."

#: src/concurrency/shared-state/example.md
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"‏ `v: Arc<_>` باید به عنوان `v2` کلون شود تا بتوان آن را به thread دیگری "
"منتقل کرد. نکته `move` به  lambda signature اضافه شد."

#: src/concurrency/shared-state/example.md
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr "بلوک‌ها برای محدود کردن دامنه `LockGuard` تا حد امکان معرفی شده‌اند."

#: src/concurrency/sync-exercises/dining-philosophers.md
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "مسئله ناهار خوردن فیلسوفان، در واقع یک مسئله کلاسیک concurrency است:"

#: src/concurrency/sync-exercises/dining-philosophers.md
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"پنج فیلسوف در کنار هم دور یک میز غذا می‌خورند. هر فیلسوف جایگاه خاص خود را در "
"میز دارد. بین هر بشقاب یک چنگال قرار دارد. غذایی که سِرو می‌شود نوعی اسپاگتی "
"است که باید با دو چنگال خورده شود. هر فیلسوف فقط می‌تواند به طور متناوب فکر "
"کند و غذا بخورد. علاوه بر این، یک فیلسوف فقط می‌تواند اسپاگتی خود را زمانی "
"بخورد که هم چنگال چپ و هم چنگال راست را داشته باشد؛ بنابراین دو چنگال فقط "
"زمانی در دسترس خواهد بود که دو همسایه نزدیک آنها در حال فکرکردن باشند و نه "
"در حال غذاخوردن. پس از اینکه یک فیلسوف غذاخوردن را تمام کرد، هر دو چنگال را "
"پایین می‌گذارد."

#: src/concurrency/sync-exercises/dining-philosophers.md
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"برای این تمرین به یک [Cargo installation](../../cargo/running-locally.md) "
"محلی نیاز دارید. کد زیر را در فایلی به نام `src/main.rs` کپی کنید، جاهای "
"خالی را پر کنید و آزمایش کنید که `cargo run` به بن‌بست (deadlock) نمی‌خورد:"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"Eureka! {} has a new idea!\""
msgstr "\"ایول! {} یک ایده جدید!\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Pick up forks...\n"
msgstr "// Pick up forks...\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"{} is eating...\""
msgstr "\"{} is eating...\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"Socrates\""
msgstr "\"Socrates\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"Hypatia\""
msgstr "\"Hypatia\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"Plato\""
msgstr "\"Plato\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"Aristotle\""
msgstr "\"Aristotle\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/sync-exercises/solutions.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"Pythagoras\""
msgstr "\"Pythagoras\""

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "// Create forks\n"
msgstr "// Create forks\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
msgid "// Create philosophers\n"
msgstr "// Create philosophers\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#, fuzzy
msgid "// Make each of them think and eat 100 times\n"
msgstr "// Make each of them think and eat 100 times\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Output their thoughts\n"
msgstr "// Output their thoughts\n"

#: src/concurrency/sync-exercises/dining-philosophers.md
msgid "You can use the following `Cargo.toml`:"
msgstr "می توانید از `Cargo.toml` زیر استفاده کنید:"

#: src/concurrency/sync-exercises/dining-philosophers.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"اجازه دهید از دانش جدید خود برای ایجاد یک جستجوگر لینک multi-thread استفاده "
"کنیم. باید از یک صفحه وب شروع شود و بررسی کنید که لینک‌های موجود در صفحه "
"معتبر هستند. باید به‌صورت بازگشتی صفحات دیگر را در همان دامنه بررسی کند و این "
"کار را تا زمانی که همه صفحات تأیید نشده‌اند ادامه دهد."

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). You will also need a way to find links, we can use [`scraper`]"
"(https://docs.rs/scraper/). Finally, we'll need some way of handling errors, "
"we will use [`thiserror`](https://docs.rs/thiserror/)."
msgstr ""
"برای این کار به یک کلاینت HTTP مانند [`reqwest`](https://docs.rs/reqwest/) "
"نیاز دارید. شما همچنین به راهی برای یافتن لینک‌ها نیاز دارید، ما می توانیم از "
"[`reqwest`](https://docs.rs/reqwest/) استفاده کنیم. در نهایت، ما به روشی "
"برای رسیدگی به خطاها نیاز داریم پس درنتیجه از [`thiserror`](https://docs.rs/"
"thiserror/) استفاده خواهیم کرد."

#: src/concurrency/sync-exercises/link-checker.md
#, fuzzy
msgid "Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"یک پروژه Cargo جدید ایجاد کنید و آن را به عنوان یک وابستگی با `reqwest` "
"اعلام کنید:"

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"اگر`cargo add` با `error: no such subcommand` ناموفق بود، لطفاً فایل `Cargo."
"toml` را دستی ویرایش کنید و وابستگی‌های ذکر شده در زیر را اضافه کنید."

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"فراخوانی‌ها `cargo add` را در فایل `Cargo.toml` به‌صورت زیر به‌روزرسانی می‌کند:"

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"اکنون می توانید صفحه شروع را دانلود کنید. با یک سایت کوچک مانند `https://www."
"google.org/` امتحان کنید."

#: src/concurrency/sync-exercises/link-checker.md
msgid "Your `src/main.rs` file should look something like this:"
msgstr "فایل `src/main.rs` شما باید چیزی شبیه به این باشد:"

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
msgid "\"request error: {0}\""
msgstr "\"request error: {0}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"bad http response: {0}\""
msgstr "\"bad http response: {0}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
msgid "\"Checking {:#}\""
msgstr "\"بررسی {:#}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
msgid "\"href\""
msgstr "\"href\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""

#: src/concurrency/sync-exercises/link-checker.md
#: src/concurrency/sync-exercises/solutions.md
msgid "\"https://www.google.org\""
msgstr "\"https://www.google.org\""

#: src/concurrency/sync-exercises/link-checker.md
msgid "\"Links: {links:#?}\""
msgstr "\"Links: {links:#?}\""

#: src/concurrency/sync-exercises/link-checker.md
msgid "\"Could not extract links: {err:#}\""
msgstr "\"نمی‌تواند لینک را باز کند: {err:#}\""

#: src/concurrency/sync-exercises/link-checker.md
msgid "Run the code in `src/main.rs` with"
msgstr "این کد را در `src/main.rs` اجرا کنید"

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"برای بررسی موازی لینک‌ها از threadها استفاده کنید: URLهایی را که باید بررسی "
"شوند به یک channel ارسال کنید و اجازه دهید چند thread به‌صورت موازی URLها را "
"بررسی کنند."

#: src/concurrency/sync-exercises/link-checker.md
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"این را به صورت بازگشتی پیوندها گسترش دهید تا از همه صفحات را در دامنه «www."
"google.org» استخراج کنید. حد بالا را حدود ۱۰۰ صفحه یا بیشتر قرار دهید تا در "
"نهایت توسط سایت مسدود نشوید."

#: src/concurrency/sync-exercises/solutions.md
msgid "\"{} is trying to eat\""
msgstr "\"{} is trying to eat\""

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"

#: src/concurrency/sync-exercises/solutions.md
msgid "\"{thought}\""
msgstr "\"{thought}\""

#: src/concurrency/sync-exercises/solutions.md
msgid "Link Checker"
msgstr "جستجوگر Link"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr ""
"/// Determine whether links within the given page should be extracted.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"

#: src/concurrency/sync-exercises/solutions.md
#, fuzzy
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr "// The sender got dropped. No more commands coming in.\n"

#: src/concurrency/sync-exercises/solutions.md
msgid "\"Got crawling error: {:#}\""
msgstr "\"خطای crawling دریافت شد: {:#}\""

#: src/concurrency/sync-exercises/solutions.md
msgid "\"Bad URLs: {:#?}\""
msgstr "\"Bad URLs: {:#?}\""

#: src/concurrency/welcome-async.md
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"‏ \"Async\" یک مدل concurrency است که در آن چندین کار به طور هم‌زمان با اجرای "
"هر کار تا زمانی که مسدود شود، اجرا می‌شود و سپس به کار دیگری که آماده ادامه "
"دادن است سوئیچ می‌شود. این مدل اجازه می‌دهد تا تعداد بیشتری کار را روی تعداد "
"محدودی از رشته‌ها اجرا کنید و به این دلیل است که سربار هر task معمولاً بسیار "
"کم است و سیستم‌‌عامل‌ها معمولاً مقدماتی را برای شناسایی مؤثر I/O که قادر به "
"ادامه هستند فراهم می‌کنند."

#: src/concurrency/welcome-async.md
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"عملیات Rust asynchronous بر اساس \"futures\" است، که نشان‌دهنده کاری است که "
"ممکن است در آینده تکمیل شود. future‌ها تا زمانی که علامت کامل بودنشان را "
"ندهند، «polled» می‌شوند."

#: src/concurrency/welcome-async.md
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"‏ Futureها توسط یک زمان‌بندی ناهمزمان نظارت می‌شوند و چندین زمان‌بندی مختلف در "
"دسترس هستند."

#: src/concurrency/welcome-async.md
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"پایتون مدل مشابهی را در «asyncio» خود دارد. با‌این‌حال، تایپ «Future» آن مبتنی "
"بر callback است و poll نشده است. برنامه‌های Async Python به یک «حلقه» شبیه به "
"runtime در Rust نیاز دارند."

#: src/concurrency/welcome-async.md
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"این مورد شبیه \"Promise\" در جاوا اسکریپت است که دوباره مبتنی بر callback "
"است. runtime زبان حلقه رویداد (event loop) را پیاده سازی می‌کند، بنابراین "
"بسیاری از جزئیات واضح در Promise پنهان می‌شوند."

#: src/concurrency/async.md
msgid "async/await"
msgstr "async/await"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"در سطح بالا، کد Rust async بسیار شبیه کد متوالی \"عادی\" است (\"normal\" "
"sequential code):"

#: src/concurrency/async/async-await.md
#, fuzzy
msgid "\"Count is: {i}!\""
msgstr "\"Count is: {i}!\""

#: src/concurrency/async/async-await.md
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"توجه داشته باشید که این یک مثال ساده برای نشان دادن syntax است. هیچ عملیات "
"طولانی مدت یا هیچ هم‌زمانی(concurrency) واقعی در آن وجود ندارد!"

#: src/concurrency/async/async-await.md
msgid "What is the return type of an async call?"
msgstr "نوع برگشت async call چیست؟"

#: src/concurrency/async/async-await.md
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"برای مشاهده type از `let future: () = async_main(10);` در `main` استفاده "
"کنید."

#: src/concurrency/async/async-await.md
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr ""
"کلمه کلیدی \"async\" شیرینیِ syntax زبان Rust است. کامپایلر نوع بازگشتی را با "
"یک future جایگزین می‌کند."

#: src/concurrency/async/async-await.md
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"شما نمی‌توانید بدون دستورالعمل‌های اضافی به کامپایلر در مورد نحوه استفاده از "
"future بازگشتی، `main` را async کنید."

#: src/concurrency/async/async-await.md
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"برای اجرای کدهای همگام به یک اجرا‌ کننده (executor) نیاز دارید.`block_on` که "
"thread رشته فعلی را تا زمانی که future ارائه شده تکمیل شود مسدود می‌کند."

#: src/concurrency/async/async-await.md
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"همیشه `await` به طور ناهمزمان (asyn) منتظر تکمیل یک عملیات دیگر است. برخلاف "
"`block_on` یک  `await` معمولاً thread فعلی را مسدود نمی‌کند."

#: src/concurrency/async/async-await.md
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr ""
"‏ `.await` فقط می‌تواند در داخل یک تابع `async` استفاده شود (یا block؛ این "
"مورد در آینده معرفی می‌شوند)."

#: src/concurrency/async/futures.md
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) یک trait "
"است، اجرا شده توسط objectهایی که نشان دهنده عملیاتی هستند که ممکن است هنوز "
"کامل نشده باشد. می‌توان یک future را poll کرد و `poll` یک [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html) را برمی‌گرداند."

#: src/concurrency/async/futures.md
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"یک تابع async یک `impl Future` را برمی‌گرداند. همچنین امکان (اما غیرمعمول) "
"پیاده‌سازی `Future` برای تایپ‌های خودتان نیز وجود دارد. برای مثال،  "
"`JoinHandle`  برگردانده شده از `tokio::spawn` `Future` را پیاده‌سازی می‌کند تا "
"امکان پیوستن (joining) به آن را فراهم کند."

#: src/concurrency/async/futures.md
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"کلمه کلیدی `.await` که برای Future اعمال می‌شود، باعث می‌شود که تابع async "
"فعلی تا زمانی که Future آماده شود متوقف شود و سپس خروجی آن ارزیابی شود."

#: src/concurrency/async/futures.md
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"تایپ‌های `Future` و `Poll` دقیقاً همانطور که نشان داده شده است اجرا می شوند. "
"برای نمایش پیاده‌سازی‌ها در اسناد، روی لینک‌ها کلیک کنید."

#: src/concurrency/async/futures.md
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"ما به `Pin` و `Context` نخواهیم رسید، زیرا به جای ساختن کدهای اولیه async، "
"بر نوشتن کدهای async تمرکز خواهیم کرد. به طور خلاصه:"

#: src/concurrency/async/futures.md
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"‏ `Context` به Future اجازه می‌دهد تا زمانی که رویدادی رخ می دهد، خود را برای "
"poll مجدد برنامه‌ریزی کند."

#: src/concurrency/async/futures.md
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"‏ `Pin` تضمین می‌کند که Future در حافظه جابه‌جا نمی‌شود، بنابراین pointerهای "
"future معتبر باقی می‌مانند. این برای اجازه دادن به referenceها برای معتبر "
"ماندن پس از  `.await` لازم است."

#: src/concurrency/async/runtimes.md
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"یک _runtime_ برای انجام عملیات به صورت ناهمزمان از (a_reactor_) پشتیبانی می "
"کند و مسئول اجرای futureها (an _executor_) است. Rust یک runtime داخلی ندارد، "
"اما چندین گزینه دیگر در دسترس است:"

#: src/concurrency/async/runtimes.md
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"‏[Tokio](https://tokio.rs/): کارایی(performant)، با یک اکوسیستم با کارایی "
"بالا به خوبی توسعه یافته مانند [Hyper](https://hyper.rs/) برای HTTP یا "
"[Tonic] (https://github) .com/hyperium/tonic) برای gRPC."

#: src/concurrency/async/runtimes.md
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"‏[async-std](https://async.rs/):: هدفش این است که یک \"std for async\" باشد و "
"شامل یک runtime اولیه در `async::task` است."

#: src/concurrency/async/runtimes.md
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/): ساده و سبک است"

#: src/concurrency/async/runtimes.md
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"چندین برنامه بزرگتر زمان اجرا (runtime) مخصوص به خود را دارند. برای مثال، "
"[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/"
"fuchsia-async/src/lib.rs) اکنون یکی runtime دارد."

#: src/concurrency/async/runtimes.md
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"توجه داشته باشید که از میان زمان‌های اجرا ذکر شده، فقط Tokio در playground "
"زبان Rust پشتیبانی می‌شود.playground همچنین اجازه ورود/خروجی (I/O) را نمی "
"دهد، بنابراین بیشتر چیزهای async جالب نمی‌توانند در playground اجرا شوند."

#: src/concurrency/async/runtimes.md
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"‏ Futureها از این جهت «بی‌اثر(inert)» هستند که هیچ کاری انجام نمی‌دهند (حتی "
"عملیات I/O را شروع نمی‌کنند) مگر اینکه یک مجری(executor) وجود داشته باشد که "
"آنها را polling کند. به عنوان مثال، این با JS Promises متفاوت است که حتی اگر "
"هرگز استفاده نشوند تا پایان کامل شدن برنامه اجرا خواهند شد."

#: src/concurrency/async/runtimes/tokio.md
#, fuzzy
msgid "Tokio provides:"
msgstr "Tokio provides:"

#: src/concurrency/async/runtimes/tokio.md
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr ""
"یک runtime از نوع multi-thread برای اجرای کدهای ناهمزمان(asynchronous)."

#: src/concurrency/async/runtimes/tokio.md
msgid "An asynchronous version of the standard library."
msgstr "یک asynchronous version کتابخانه‌ای استاندارد است."

#: src/concurrency/async/runtimes/tokio.md
msgid "A large ecosystem of libraries."
msgstr "اکوسیستم بزرگی از کتابخانه‌ها."

#: src/concurrency/async/runtimes/tokio.md
msgid "\"Count in task: {i}!\""
msgstr "\"شمارش  task: {i}!\""

#: src/concurrency/async/runtimes/tokio.md
msgid "\"Main task: {i}\""
msgstr "\"Main task: {i}\""

#: src/concurrency/async/runtimes/tokio.md
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr "با ماکرو `tokio::main` اکنون می‌توانیم `main` را async کنیم."

#: src/concurrency/async/runtimes/tokio.md
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "تابع `spawn` یک \"task\" جدید و همزمان ایجاد می‌کند."

#: src/concurrency/async/runtimes/tokio.md
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"توجه: `spawn` یک  `Future` می‌گیرد، شما `.await` را در `count_to` صدا نمی‌زنید."

#: src/concurrency/async/runtimes/tokio.md
msgid "**Further exploration:**"
msgstr "**Further بررسی:**"

#: src/concurrency/async/runtimes/tokio.md
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"چرا `count_to`  (معمولا) به مقدار ۱۰ نمی‌رسد؟ این نمونه‌ای از لغو async است. "
"`tokio::spawn` یک handle را برمی‌گرداند که می‌توان مدتی منتظر ماند تا تمام شود."

#: src/concurrency/async/runtimes/tokio.md
msgid "Try `count_to(10).await` instead of spawning."
msgstr "به جای  spawn مورد `count_to(10).await`» را امتحان کنید."

#: src/concurrency/async/runtimes/tokio.md
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "منتظر کار برگشتی از `tokio::spawn` باشید."

#: src/concurrency/async/tasks.md
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "‏ Rust یک task system دارد که نوعی thread سبک‌ وزن است."

#: src/concurrency/async/tasks.md
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"یک task یک future در سطح بالا دارد که اجراکننده (executor) برای ادامه کار آن "
"را poll می‌کند. آن future ممکن است یک یا چند future تودرتو داشته باشد که متد "
"`poll` آن را `poll` می‌کند، که به طور ناپایداری با یک stack فراخوانی شده "
"مطابقت دارد. همزمانی در یک task با poll از چندین child future، مانند رقابت "
"یک تایمر و یک عملیات I/O امکان‌پذیر است."

#: src/concurrency/async/tasks.md
msgid "\"127.0.0.1:0\""
msgstr "\"127.0.0.1:0\""

#: src/concurrency/async/tasks.md
msgid "\"listening on port {}\""
msgstr "\"listening on port {}\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"connection from {addr:?}\""
msgstr "\"connection from {addr:?}\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "b\"Who are you?\\n\""
msgstr "b\"Who are you?\\n\""

#: src/concurrency/async/tasks.md
#, fuzzy
msgid "\"socket error\""
msgstr "\"socket error\""

#: src/concurrency/async/tasks.md
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr "\"از تماس تلفنی متشکریم، {name}!\\n\""

#: src/concurrency/async/tasks.md src/concurrency/async-control-flow/join.md
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"این مثال را در `src/main.rs` آماده شده خود کپی کنید و آن را از آنجا اجرا "
"کنید."

#: src/concurrency/async/tasks.md
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""
"سعی کنید با یک ابزار اتصال TCP مانند [nc](https://www.unix.com/man-page/"
"linux/1/nc/) یا [telnet](https://www.unix.com/) به آن متصل شوید."

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"از دانش‌آموزان بخواهید که وضعیت سرور مورد مثال را با چند کلاینت متصل تجسم "
"کنند. چه taskهایی وجود دارد؟ Future آنها چیست؟"

#: src/concurrency/async/tasks.md
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"این اولین بار است که بلوک `async` را می‌بینیم. این شبیه به بسته شدن است، اما "
"هیچ استدلالی ندارد. مقدار بازگشتی آن از نوع Future است، شبیه به  `async fn`."

#: src/concurrency/async/tasks.md
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"بلوک async را به یک تابع تغییر دهید و مدیریت خطا را با استفاده از `?` بهبود "
"بخشید."

#: src/concurrency/async-control-flow/channels.md
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"چندین crate از asynchronous channel پشتیبانی می‌کنند. به عنوان مثال `tokio`:"

#: src/concurrency/async-control-flow/channels.md
msgid "\"Received {count} pings so far.\""
msgstr "\"تاکنون {count} عدد ping دریافت شده است.\""

#: src/concurrency/async-control-flow/channels.md
msgid "\"ping_handler complete\""
msgstr "\"ping_handler کامل‌شده‌است\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Failed to send ping.\""
msgstr "\"Failed to send ping.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Sent {} pings so far.\""
msgstr "\"Sent {} pings so far.\""

#: src/concurrency/async-control-flow/channels.md
#, fuzzy
msgid "\"Something went wrong in ping handler task.\""
msgstr "\"Something went wrong in ping handler task.\""

#: src/concurrency/async-control-flow/channels.md
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""
"اندازه کانال را به`3` تغییر دهید و ببینید که چگونه بر اجرا تأثیر می‌گذارد."

#: src/concurrency/async-control-flow/channels.md
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](../channels.md)."
msgstr ""
"به‌طور‌کلی، interface شبیه به channelهای `sync` است که در [کلاس صبح‌گاهی](../"
"channels.md) دیده می‌شود."

#: src/concurrency/async-control-flow/channels.md
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr "تماس `std::mem::drop` را حذف کنید. چه اتفاقی می‌افتد؟ چرا؟"

#: src/concurrency/async-control-flow/channels.md
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"این crate مربوط به [Flume](https://docs.rs/flume/latest/flume/) دارای "
"کانال‌هایی است که  `sync` و `async` `send` و `recv` را اجرا می‌کنند. این کار "
"می‌تواند برای برنامه‌های پیچیده با taskهای پردازشی IO و CPU سنگین مناسب باشد."

#: src/concurrency/async-control-flow/channels.md
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"چیزی که کار با کانال‌های `async` را ترجیح می‌دهد، توانایی ترکیب آن‌ها با دیگر "
"`future` برای ترکیب آنها و ایجاد جریان کنترل پیچیده است."

#: src/concurrency/async-control-flow/join.md
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"عملیات پیوستن (join) منتظر می‌ماند تا تمام مجموعه‌ای از futureها آماده شوند و "
"مجموعه‌ای (collection) از نتایج آنها را برمی‌گرداند. این شبیه به `Promise.all` "
"در JavaScript یا `asyncio.gather` در پایتون است."

#: src/concurrency/async-control-flow/join.md
msgid "\"https://google.com\""
msgstr "\"https://google.com\""

#: src/concurrency/async-control-flow/join.md
msgid "\"https://httpbin.org/ip\""
msgstr "\"https://httpbin.org/ip\""

#: src/concurrency/async-control-flow/join.md
msgid "\"https://play.rust-lang.org/\""
msgstr "\"https://play.rust-lang.org/\""

#: src/concurrency/async-control-flow/join.md
msgid "\"BAD_URL\""
msgstr "\"BAD_URL\""

#: src/concurrency/async-control-flow/join.md
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"برای چند future از تایپ‌های مختلف، می‌توانید از `std::future::join!` استفاده "
"کنید، اما باید بدانید که در زمان کامپایل چند future خواهید داشت. این در حال "
"حاضر در جعبه (crate از نوع `futures` است که به زودی در `std::future` تثبیت "
"می‌شود."

#: src/concurrency/async-control-flow/join.md
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"خطر `join` این است که یکی از future‌ها ممکن است هرگز resolve نشود، این مسئله "
"باعث می‌شود برنامه شما متوقف شود."

#: src/concurrency/async-control-flow/join.md
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"همچنین می‌توانید `join_all` را با `join!` ترکیب کنید، به‌عنوان مثال برای "
"پیوستن (`join!`) همه درخواست‌ها به یک سرویس http و همچنین یک کوئری پایگاه "
"داده سعی کنید `tokio::time::sleep` را با استفاده از `futures::join!` به "
"future اضافه کنید. این یک timeout نیست (که به `select!`نیاز دارد و در فصل "
"بعدی توضیح داده ‌می‌شود) بلکه `join!` را نشان می‌دهد."

#: src/concurrency/async-control-flow/select.md
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"یک عملیات انتخابی منتظر می‌ماند تا هر یک از مجموعه‌ای از futureها آماده شود و "
"به نتیجه آن future پاسخ می‌دهد. در JavaScript این مورد شبیه به `Promise.race` "
"است و در پایتون با `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)` قابل مقایسه می‌باشد."

#: src/concurrency/async-control-flow/select.md
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When a `future` is ready, "
"its return value is destructured by the `pattern`. The `statement` is then "
"run with the resulting variables. The `statement` result becomes the result "
"of the `select!` macro."
msgstr ""
"مانند یک عبارت تطبیقی (match statement)، بدنه `pattern` دارای تعدادی بازو "
"است که هر کدام به شکل عبارت `pattern = future => statement` هستند. هنگامی که "
"`future` آماده است، مقدار بازگشتی آن توسط `pattern` تخریب می‌شود. سپس "
"`statement` با متغیرهای حاصل اجرا می‌شود. در نتیجه `statement` نتیجه‌ي ماکرو "
"`select!` می‌شود."

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"got: {msg}\""
msgstr "\"{msg}\""

#: src/concurrency/async-control-flow/select.md
msgid "\"timeout\""
msgstr "\"timeout\""

#: src/concurrency/async-control-flow/select.md
#, fuzzy
msgid "\"Failed to send greeting\""
msgstr "\"Failed to send ping.\""

#: src/concurrency/async-control-flow/select.md
msgid "\"Listener failed\""
msgstr "\"شنونده شکست خورد\""

#: src/concurrency/async-control-flow/select.md
msgid ""
"The `listener` async block here is a common form: wait for some async event, "
"or for a timeout. Change the `sleep` to sleep longer to see it fail. Why "
"does the `send` also fail in this situation?"
msgstr ""
"بلوک async `listener` در اینجا یک شکل رایج است: منتظر برخی رویدادهای async "
"یا به‌عنوان مثال برای timeoutها باشید. `sleep` را به sleep طولانی‌تر تغییر "
"دهید تا شاهد شکست آن باشید. چرا `send` نیز در این شرایط شکست می‌خورد؟"

#: src/concurrency/async-control-flow/select.md
msgid ""
"`select!` is also often used in a loop in \"actor\" architectures, where a "
"task reacts to events in a loop. That has some pitfalls, which will be "
"discussed in the next segment."
msgstr ""

#: src/concurrency/async-pitfalls.md
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter."
msgstr ""
"‏ Async / await انتزاع راحت و کارآمدی را برای برنامه نویسی concurrent "
"asynchronous فراهم می‌کند. با‌این‌حال، مدل async/wait در Rust نیز با سهم خود از "
"مشکلات و pitfallها و footgunها همراه است. برخی از آنها را در این فصل توضیح "
"می‌دهیم."

#: src/concurrency/async-pitfalls.md
msgid "Pin"
msgstr "Pin"

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid "Blocking the executor"
msgstr "مسدود کردن executor"

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"اکثر async runtimeهای تنها به  IO task اجازه می‌دهند که به صورت همزمان "
"(concurrent) اجرا شوند. این بدان معنی است که تسک‌های block کردن CPU باعث "
"مسدود شدن executor و جلوگیری از اجرای سایر تسک‌ها می‌شود. یک راه حل آسان این "
"است که در صورت امکان از متدهای معادل async استفاده کنید."

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr "\"future {id} slept for {duration_ms}ms, finished after {}ms\""

#: src/concurrency/async-pitfalls/blocking-executor.md
#, fuzzy
msgid "\"current_thread\""
msgstr "\"current_thread\""

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"کد را اجرا کنید و ببینید که sleep‌ها به طور متوالی اتفاق می‌افتند و نه به صورت "
"همزمان (concurrent)."

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"این `\"current_thread\"` همه taskها را روی یک thread قرار می‌دهد. این "
"اثرگذاری را آشکارتر می‌کند، اما این اشکال همچنان در طبیعت multi-threaded وجود "
"دارد."

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"‏ `std::thread::sleep` را به `tokio::time::sleep` تغییر دهید و منتظر نتیجه "
"باشید."

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"راه‌حل دیگر `tokio::task::spawn_blocking` است که یک thread واقعی ایجاد می‌کند "
"و handle آن را بدون مسدود کردن executor به future تبدیل می‌کند."

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"شما نباید taskها را به عنوان thread‌های سیستم عامل در نظر بگیرید. آنها از "
"نگاشت ۱ به ۱ پشتیبانی نمی‌کنند و اکثر executorها به بسیاری از taskها اجازه "
"می‌دهند روی یک thread سیستم عامل اجرا شوند. این امر به‌ویژه هنگام تعامل با "
"کتابخانه‌های دیگر از طریق FFI مشکل‌ساز است، جایی که آن کتابخانه ممکن است به "
"ذخیره‌سازی محلی thread یا نگاشت (map) به threadهای سیستم‌عامل خاص (مانند CUDA) "
"بستگی داشته باشد. در چنین شرایطی `tokio::task::spawn_blocking` را ترجیح دهید."

#: src/concurrency/async-pitfalls/blocking-executor.md
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"با احتیاط از همگام‌سازی mutexها استفاده کنید. نگه داشتن یک mutex روی یک `."
"await` ممکن است باعث مسدود شدن task دیگری شود و آن task ممکن است در همان "
"thread در حال اجرا باشد."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"Async blocks and functions return types implementing the `Future` trait. The "
"type returned is the result of a compiler transformation which turns local "
"variables into data stored inside the future."
msgstr ""
"بلوک‌ها و توابع Async انواعی را برمی‌گردانند که ویژگی `Future` را پیاده‌سازی "
"می‌کنند. نوع برگشتی نتیجه تبدیل کامپایلر است که متغیرهای محلی را به داده های "
"ذخیره شده در future تبدیل می کند."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"Some of those variables can hold pointers to other local variables. Because "
"of that, the future should never be moved to a different memory location, as "
"it would invalidate those pointers."
msgstr ""
"برخی از این متغیرها می‌توانند اشاره‌گرهایی را برای سایر متغیرهای محلی نگه "
"دارند. به همین دلیل، future هرگز نباید به مکان حافظه دیگری منتقل شود، زیرا "
"این pointerها را باطل می‌کند."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"To prevent moving the future type in memory, it can only be polled through a "
"pinned pointer. `Pin` is a wrapper around a reference that disallows all "
"operations that would move the instance it points to into a different memory "
"location."
msgstr ""
"برای جلوگیری از جابجایی تایپ future در حافظه، فقط از طریق یک pointer پین شده "
"می توان آن را بررسی کرد. `Pin` یک wrapper در اطراف یک reference است که تمام "
"عملیاتی را که می‌تواند نمونه‌ای را که به آن اشاره می‌کند به یک مکان حافظه "
"متفاوت منتقل کند را ممنوع می‌کند."

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr "// A worker which listens for work on a queue and performs it.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// Pretend to work.\n"
msgstr "// Pretend to work.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed to send response\""
msgstr "\"failed to send response\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// TODO: report number of iterations every 100ms\n"
msgstr "// TODO: report number of iterations every 100ms\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr "// A requester which requests work and waits for it to complete.\n"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed to send on work queue\""
msgstr "\"failed to send on work queue\""

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid "\"failed waiting for response\""
msgstr "\"failed waiting for response\""

#: src/concurrency/async-pitfalls/pin.md
msgid "\"work result for iteration {i}: {resp}\""
msgstr "\"نتیجه کار برای تکرار  {i}: {resp}\""

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"شما ممکن است این را به عنوان نمونه ای از الگوی بازیگر (actor pattern) تشخیص "
"دهید. بازیگران معمولاً `select!` را در یک حلقه صدا می‌زنند."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""
"این به عنوان یک جمع‌بندی از چند درس قبلی عمل می کند، بنابراین وقت خود را صرف "
"آن کنید."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"به‌سادگی یک `_ = sleep(Duration::from_millis(100)) => { println!(..) }` را به "
"`select!` اضافه کنید. این مورد هرگز اجرا نمی شود. چرا؟"

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr "درعوض، یک `timeout_fut` حاوی آن future خارج از `loop` اضافه کنید:"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"این مورد هنوز کار نمی‌کند. خطاهای کامپایلر را دنبال کنید، `&mut` را به  "
"`timeout_fut` در `select!` اضافه کنید تا حرکت را ادامه دهید، سپس از `Box::"
"pin` استفاده کنید:"

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires:"
msgstr ""
"این مورد کامپایل می‌شود، اما پس از انقضای timeout و در هر تکرار برابر با "
"`Poll::Ready` است (future ترکیبی به این مسئله کمک می‌کند). به‌روزرسانی برای "
"بازنشانی `timeout_fut` هر بار که منقضی می‌شود:"

#: src/concurrency/async-pitfalls/pin.md
#, fuzzy
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"جعبه allocateها بر روی heap. در برخی موارد، `std::pin::pin!` (فقط به تازگی "
"تثبیت شده است، با کدهای قدیمی‌تر که اغلب از `tokio::pin!` استفاده می‌کنند) نیز "
"یک گزینه است، اما استفاده از آن برای futureای که دوباره تخصیص داده می‌شود "
"دشوار است."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"جایگزین دیگر این است که به هیچ وجه از `pin` استفاده نکنید، بلکه task دیگری "
"ایجاد کنید که هر 100 میلی‌ثانیه به یک کانال `oneshot` ارسال می‌شود."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"Data that contains pointers to itself is called self-referential. Normally, "
"the Rust borrow checker would prevent self-referential data from being "
"moved, as the references cannot outlive the data they point to. However, the "
"code transformation for async blocks and functions is not verified by the "
"borrow checker."
msgstr ""
"داده‌هایی که حاوی اشاره‌گرهایی به خود هستند، خود ارجاعی ( self-referential) "
"نامیده می شوند. به طور معمول، Rust borrow checker از جابجایی داده‌های "
"خودارجاعی جلوگیری می‌کند، زیرا منابع نمی‌توانند بیشتر از داده‌هایی که به آنها "
"اشاره می‌کنند زنده بمانند. با‌این‌حال، تبدیل کد برای بلوک‌ها و توابع async توسط "
"borrow checker تأیید نمی‌شود."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"`Pin` is a wrapper around a reference. An object cannot be moved from its "
"place using a pinned pointer. However, it can still be moved through an "
"unpinned pointer."
msgstr ""
"‏ `Pin` یک wrapper در اطراف یک reference است. یک object را نمی‌توان با استفاده "
"از یک pointer پین شده از جای خود حرکت داد. با این حال، هنوز هم می‌توان آن را "
"از طریق یک pointer بدون پین جابجا کرد."

#: src/concurrency/async-pitfalls/pin.md
msgid ""
"The `poll` method of the `Future` trait uses `Pin<&mut Self>` instead of "
"`&mut Self` to refer to the instance. That's why it can only be called on a "
"pinned pointer."
msgstr ""
"متد `poll` از ویژگی `Future` از `Pin<&mut Self>` به جای `&mut Self` برای "
"اشاره به نمونه (instance) استفاده می‌‌کند. به همین دلیل است که فقط می‌توان آن "
"را روی یک اشاره‌‌گر پین شده فراخوانی کرد."

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"Async methods in traits are were stabilized only recently, in the 1.75 "
"release. This required support for using return-position `impl Trait` (RPIT) "
"in traits, as the desugaring for `async fn` includes `-> impl Future<Output "
"= ...>`."
msgstr ""
"متدهای Async در traitها اخیراً در انتشار 1.75 تثبیت شده‌اند. این نیاز به "
"پشتیبانی برای استفاده از موقعیت بازگشتی `impl Trait` (RPIT) در traitها را "
"داشت، زیرا شیرین‌زدایی (desugaring) برای `async fn` شامل `-> impl "
"Future<Output = ...>` است."

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"However, even with the native support today there are some pitfalls around "
"`async fn` and RPIT in traits:"
msgstr ""
"با این‌حال، حتی با پشتیبانی native امروز، برخی از مشکلات در مورد `async fn` و "
"RPIT در ویژگی‌ها وجود دارد:"

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"Return-position impl Trait captures all in-scope lifetimes (so some patterns "
"of borrowing cannot be expressed)"
msgstr ""
"‏Return-position impl Trait تمام طول عمرهای درون محدوده را ثبت می کند "
"(بنابراین برخی از الگوهای قرض کردن (borrowing) نمی توانند بیان شوند)"

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"Traits whose methods use return-position `impl trait` or `async` are not "
"`dyn` compatible."
msgstr ""
"ویژگی‌هایی که متد‌های آن‌ها از موقعیت بازگشتی `impl trait` یا `async` استفاده "
"می‌کنند با `dyn` سازگار نیستند."

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid ""
"If we do need `dyn` support, the crate [async_trait](https://docs.rs/async-"
"trait/latest/async_trait/) provides a workaround through a macro, with some "
"caveats:"
msgstr ""
"اگر به پشتیبانی `dyn` نیاز داریم، crate [async_trait](https://docs.rs/async-"
"trait/latest/async_trait/) راه‌حلی را از طریق یک ماکرو ارائه می‌کند، با ذکر "
"چند نکته:"

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid "\"running all sleepers..\""
msgstr "\"running all sleepers..\""

#: src/concurrency/async-pitfalls/async-traits.md
#, fuzzy
msgid "\"slept for {}ms\""
msgstr "\"slept for {}ms\""

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"استفاده از `async_trait` آسان است، اما توجه داشته باشید که برای رسیدن به این "
"هدف از heap allocationها استفاده می‌کند. این heap allocation دارای سربار "
"عملکرد است."

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"چالش‌های پشتیبانی برای `async trait` در زبان Rust بسیار عمیق هستند و احتمالاً "
"ارزش توصیف عمیق در اینجا را ندارند. Niko Matsakis در [این پست](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/) آنها را به خوبی توضیح داده است. به خصوص اگر شما به این موضوع علاقه‌مند "
"هستید."

#: src/concurrency/async-pitfalls/async-traits.md
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"سعی کنید یک sleep خواب جدید ایجاد کنید که برای مدت زمان تصادفی می‌خوابد و آن "
"را به Vec اضافه کنید."

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"کنار گذاشتن future به این معنی است که دیگر هرگز نمی‌توان آن را poll کرد. به "
"این حالت _cancellation_ می‌گویند و می‌تواند در هر نقطه `await` رخ دهد. برای "
"اطمینان از عملکرد صحیح سیستم حتی در صورت لغو futureها، دقت مناسب لازم است. "
"به‌عنوان ‌مثال، نباید داده‌ها را از دست بدهد یا به بن‌بست (deadlock) برسد."

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "\"not UTF-8\""
msgstr "\"not UTF-8\""

#: src/concurrency/async-pitfalls/cancellation.md
msgid "\"hi\\nthere\\n\""
msgstr "\"hi\\nthere\\n\""

#: src/concurrency/async-pitfalls/cancellation.md
msgid "\"tick!\""
msgstr "\"tick!\""

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"کامپایلر در مورد cancellation-safety کمکی نمی‌کند. باید مستندات API را "
"بخوانید و در نظر بگیرید که `async fn` شما چه وضعیتی دارد."

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""
"برخلاف `panic` و `?`، لغو یا cancellation بخشی از جریان کنترل عادی (و رسیدگی "
"به خطا) است."

#: src/concurrency/async-pitfalls/cancellation.md
msgid "The example loses parts of the string."
msgstr "اسن مثال بخش‌هایی از string را از دست می‌دهد."

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""
"هر زمان که شاخه `tick()` اول تمام شود، `next()` و `buf` آن حذف می شوند."

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr "‏`LinesReader` را می‌توان با تبدیل `buf` به بخشی از ساختار، ایمن کرد:"

#: src/concurrency/async-pitfalls/cancellation.md
#, fuzzy
msgid "// prefix buf and bytes with self.\n"
msgstr "// prefix buf and bytes with self.\n"

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"‏ ['Interval::tick'](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) برای cancellation-safe است زیرا ردیابی می‌کند که آیا یک "
"tick  تحویل داده شده است."

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"‏ [`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) برای cancellation-safe است زیرا داده‌ها را "
"برمی‌گرداند یا نمی‌خواند."

#: src/concurrency/async-pitfalls/cancellation.md
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"‏ [`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) مشابه مثال است و شبیه cancellation-"
"safe نیست. برای جزئیات و موارد جایگزین به مستندات آن مراجعه کنید."

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "فلسفه Dining  --- Async"

#: src/concurrency/async-exercises/dining-philosophers.md
msgid ""
"See [dining philosophers](../sync-exercises/dining-philosophers.md) for a "
"description of the problem."
msgstr ""
"برای توضیح مشکل به [dining philosophers](../sync-exercises/dining-"
"philosophers.md) مراجعه کنید."

#: src/concurrency/async-exercises/dining-philosophers.md
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"مانند قبل، برای این تمرین به Cargo installation](../../cargo/running-locally."
"md) نیاز دارید. کد زیر را در فایلی به نام `src/main.rs` کپی کنید، جاهای خالی "
"را پر کنید و تست کنید که `cargo run` به بن بست (`src/main.rs`) نمی‌خورد:"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Keep trying until we have both forks\n"
msgstr "// Keep trying until we have both forks\n"

#: src/concurrency/async-exercises/dining-philosophers.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Make them think and eat\n"
msgstr "// Make them think and eat\n"

#: src/concurrency/async-exercises/dining-philosophers.md
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"از آنجایی که این بار از Async Rust استفاده می‌کنید، به وابستگی `tokio` نیاز "
"دارید. می‌توانید از `Cargo.toml` زیر استفاده کنید:"

#: src/concurrency/async-exercises/dining-philosophers.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"

#: src/concurrency/async-exercises/dining-philosophers.md
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""
"همچنین توجه داشته باشید که این بار باید از ماژول `Mutex` و `mpsc` از `tokio` "
"crate استفاده کنید."

#: src/concurrency/async-exercises/dining-philosophers.md
msgid "Can you make your implementation single-threaded?"
msgstr "آیا می‌توانید پیاده‌سازی خود را تک thread ای کنید؟"

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"در این تمرین، ما می‌خواهیم از دانش جدید خود برای پیاده سازی یک برنامه "
"broadcast chat استفاده کنیم. ما یک سرور چت داریم که کاربران به آن متصل "
"می‌شوند و پیام‌های خود را منتشر می‌کنند. کلاینت پیام‌های کاربر را از ورودی "
"استاندارد می‌خواند و آنها را به سرور ارسال می‌کند. سرور چت هر پیامی را که "
"دریافت می‌کند برای همه کاربران پخش می‌کند."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""
"برای این کار، از [ broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) در سمت سرور و [`tokio_websockets`](https://"
"docs.rs/tokio-websockets/) برای ارتباط بین کلاینت و سرور."

#: src/concurrency/async-exercises/chat-app.md
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "یک پروژه Cargo جدید ایجاد کنید و وابستگی‌های زیر را اضافه کنید:"

#: src/concurrency/async-exercises/chat-app.md
msgid "_Cargo.toml_:"
msgstr "_Cargo.toml_:"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.1.0\"\n"
"tokio = { version = \"1.40.0\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.9.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.1.0\"\n"
"tokio = { version = \"1.38.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.8.3\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"

#: src/concurrency/async-exercises/chat-app.md
msgid "The required APIs"
msgstr "‏API‌های مورد نیاز"

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""
"شما به توابع زیر از `tokio` و [`tokio_websockets`](https://docs.rs/tokio-"
"websockets/) نیاز دارید. چند دقیقه را برای آشنایی با API اختصاص دهید."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"‏ [StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) توسط `WebSocketStream`: برای خواندن "
"ناهمزمان پیام‌ها از یک جریان وب سوکت."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"‏[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) پیاده‌سازی شده توسط `WebSocketStream`: برای "
"ارسال ناهمزمان پیام‌ها در یک Websocket Stream."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"‏[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): برای خواندن ناهمزمان پیام‌های کاربر از ورودی "
"استاندارد."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"‏[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): برای اشتراک در یک broadcast channel."

#: src/concurrency/async-exercises/chat-app.md
msgid "Two binaries"
msgstr "دو باینری"

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""
"به طور معمول در یک پروژه Cargo، شما می توانید فقط یک فایل باینری و یک فایل "
"`src/main.rs` داشته باشید. در این پروژه به دو باینری نیاز داریم. یکی برای "
"کلاینت و دیگری برای سرور. شما به طور بالقوه می‌توانید آنها را در دو پروژه "
"Cargo جداگانه بسازید، اما ما آنها را در یک پروژه Cargo واحد با دو باینری "
"قرار می‌دهیم. برای این کار، کلاینت و کد سرور باید زیر `src/bin` قرار گیرند "
"(به[documentation](https://doc.rust-lang.org/cargo/reference/cargo-targets."
"html#binaries) مراجعه کنید )."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""
"کد سرور و کلاینت زیر را به ترتیب در`src/bin/server.rs` و `src/bin/client.rs` "
"کپی کنید. وظیفه شما این است که این فایل‌ها را همانطور که در زیر توضیح داده "
"شده است تکمیل کنید."

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "_src/bin/server.rs_:"
msgstr "_src/bin/server.rs_:"

#: src/concurrency/async-exercises/chat-app.md
#, fuzzy
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr "// TODO: For a hint, see the description of the task below.\n"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"127.0.0.1:2000\""
msgstr "\"127.0.0.1:2000\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"listening on port 2000\""
msgstr "\"listening on port 2000\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "\"New connection from {addr:?}\""
msgstr "\"اتصال جدید از {addr:?}\""

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr "// Wrap the raw TCP stream into a websocket.\n"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
msgid "_src/bin/client.rs_:"
msgstr "_src/bin/client.rs_:"

#: src/concurrency/async-exercises/chat-app.md
#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"ws://127.0.0.1:2000\""
msgstr "\"ws://127.0.0.1:2000\""

#: src/concurrency/async-exercises/chat-app.md
msgid "Running the binaries"
msgstr "راه‌اندازی باینری"

#: src/concurrency/async-exercises/chat-app.md
msgid "Run the server with:"
msgstr "سرور را راه‌اندازی کنید با استفاده از:"

#: src/concurrency/async-exercises/chat-app.md
msgid "and the client with:"
msgstr "و این کلاینت با:"

#: src/concurrency/async-exercises/chat-app.md
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "تابع `handle_connection` را در `src/bin/server.rs` پیاده‌سازی کنید."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"نکته: از `tokio::select!` برای انجام همزمان دو task در یک حلقه پیوسته "
"استفاده کنید. یک task پیام‌هایی را از کلاینت دریافت می‌کند و آنها را "
"پخش(broadcast) می‌کند. دیگری پیام‌های دریافت شده توسط سرور را برای کاربر ارسال "
"می‌کند."

#: src/concurrency/async-exercises/chat-app.md
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "تابع اصلی را در `src/bin/client.rs` تکمیل کنید."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"نکته: مانند قبل، از `tokio::select!` در یک حلقه پیوسته برای انجام همزمان دو "
"task استفاده کنید: (۱) خواندن پیام های کاربر از ورودی استاندارد و ارسال آنها "
"به سرور و (۲) دریافت پیام از سرور و نمایش آنها برای کاربر."

#: src/concurrency/async-exercises/chat-app.md
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""
"اختیاری: پس از اتمام کار، کد را تغییر دهید تا پیام‌ها برای همه کلاینت‌ها، به "
"جز فرستنده پیام، منتشر شود."

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// If we didn't get the left fork, drop the right fork if we\n"
"                // have it and let other tasks make progress.\n"
msgstr ""
"// If we didn't get the left fork, drop the right fork if we\n"
"                // have it and let other tasks make progress.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// If we didn't get the right fork, drop the left fork and let\n"
"                // other tasks make progress.\n"
msgstr ""
"// If we didn't get the right fork, drop the left fork and let\n"
"                // other tasks make progress.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// The locks are dropped here\n"
msgstr "// The locks are dropped here\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr "// tx is dropped here, so we don't need to explicitly drop it later\n"

#: src/concurrency/async-exercises/solutions.md
msgid "\"Here is a thought: {thought}\""
msgstr "\"در اینجا یک ایده وجود دارد: {thought}\""

#: src/concurrency/async-exercises/solutions.md
msgid "\"Welcome to chat! Type a message\""
msgstr "\"به chat خوش آمدید! یک پیام تایپ کنید\""

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"From client {addr:?} {text:?}\""
msgstr "\"From client {addr:?} {text:?}\""

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr "// Continuous loop for concurrently sending and receiving messages.\n"

#: src/concurrency/async-exercises/solutions.md
#, fuzzy
msgid "\"From server: {}\""
msgstr "\"From server: {}\""

#: src/thanks.md
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"ممنون که آموزش‌هایی را از Comprehensive Rust 🦀! رو گرفتید. امیدواریم لذت "
"برده باشید و برای‌ شما مفید بوده باشد."

#: src/thanks.md
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"ما از برگزاری این دوره بسیار لذت بردیم. این دوره کامل نیست، بنابراین اگر "
"اشتباهی را مشاهده کردید یا ایده‌ای برای بهبود دارید، لطفاً با [در GitHub با ما "
"تماس بگیرید](https://github.com/google/comprehensive-rust/discussions) وارد "
"شوید. ما دوست داریم از شما بشنویم."

#: src/glossary.md
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""
"در زیر واژه‌نامه‌ای است که هدف آن ارائه تعریف کوتاهی از بسیاری از اصطلاحات در "
"زبان Rust است. برای ترجمه‌ها، این مورد نیز برای اتصال این اصطلاح به زبان اصلی "
"انگلیسی است."

#. Please add the English term in italic after your translated term. Also, please keep the hard line breaks to ensure a nice formatting.
#: src/glossary.md
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/review.md)."
msgstr ""
"allocate:  \n"
"تخصیص حافظه پویا در [heap]‌(memory-management/review.md)."

#: src/glossary.md
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""
"argument:  \n"
"اطلاعاتی که به یک تابع یا متد منتقل می‌شود."

#: src/glossary.md
msgid ""
"associated type:  \n"
"A type associated with a specific trait. Useful for defining the "
"relationship between types."
msgstr ""
"نوع مرتبط:\n"
"نوعی که با یک ویژگی خاص مرتبط است. برای تعریف رابطه بین typeها مفید است."

#: src/glossary.md
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""
"Bare-metal Rust:  \n"
"توسعه سطح پایین Rust، اغلب در سیستم‌هایی که سیستم‌عامل ندارند، مستقر می‌شود. "
"[Bare-metal Rust](bare-metal.md) را ببینید."

#: src/glossary.md
msgid ""
"block:  \n"
"See [Blocks](control-flow-basics/blocks-and-scopes.md) and _scope_."
msgstr ""
"block:  \n"
"‏[Blocks]‌(control-flow-basics/blocks-and-scopes.md) و _scope_ را ببینید."

#: src/glossary.md
msgid ""
"borrow:  \n"
"See [Borrowing](borrowing/shared.md)."
msgstr ""
"borrow:  \n"
"‏ [Borrowing](borrowing/shared.md) را ببینید."

#: src/glossary.md
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""
"borrow checker:  \n"
"بخشی از کامپایلر Rust که بررسی می‌کند که همه قرض‌ها (borrows) معتبر هستند."

# recheck
#: src/glossary.md
#, fuzzy
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""
"brace:  \n"
"‏ `{` and `}`. نامیده می‌شوند _curly brace_, آنها delimit _blocks_."

#: src/glossary.md
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""
"build:  \n"
"فرآیند تبدیل کد منبع به کد اجرایی یا یک برنامه قابل استفاده می‌باشد."

#: src/glossary.md
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""
"call:  \n"
"برای فراخوانی یا اجرای یک تابع یا متد، کاربرد دارد."

#: src/glossary.md
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""
"channel:  \n"
"‏ برای ارسال ایمن پیام‌ها [بین threadها]‌(concurrency/channels.md) استفاده "
"می‌شود."

#: src/glossary.md
msgid ""
"Comprehensive Rust 🦀:  \n"
"The courses here are jointly called Comprehensive Rust 🦀."
msgstr ""
"Comprehensive Rust 🦀:  \n"
"دوره‌های اینجا Comprehensive Rust 🦀 نامیده می‌شوند."

#: src/glossary.md
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""
"concurrency:  \n"
"اجرای چندین  task یا process به طور همزمان."

#: src/glossary.md
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency/welcome.md)."
msgstr ""
"Concurrency در Rust ‏[Concurrency in Rust](concurrency/welcome.md) را ببینید."

#: src/glossary.md
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""
"constant:  \n"
"مقداری که در طول اجرای برنامه تغییر نمی‌کند."

#: src/glossary.md
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""
"control flow:  \n"
"ترتیبی که دستورات یا عملگرها در یک برنامه اجرا می‌شوند."

#: src/glossary.md
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""
"crash:  \n"
"یک شکست (failure) یا خاتمه غیرمنتظره و کنترل نشده یک برنامه است."

#: src/glossary.md
msgid ""
"enumeration:  \n"
"A data type that holds one of several named constants, possibly with an "
"associated tuple or struct."
msgstr ""
"enumeration:  \n"
"یک نوع داده که یکی از چندین ثابت نامگذاری شده را، احتمالاً با یک تاپل یا "
"ساختار مرتبط، نگه می‌دارد."

#: src/glossary.md
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""
"error:  \n"
"شرایط یا نتیجه غیرمنتظره‌ای که از رفتار مورد انتظار خارج می‌شود."

#: src/glossary.md
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""
"error handling:  \n"
"فرآیند مدیریت و پاسخگویی به خطاهایی که در حین اجرای برنامه رخ می‌دهد."

#: src/glossary.md
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""
"exercise:  \n"
" مشکل یا task که برای تمرین و آزمایش مهارت‌های برنامه‌نویسی طراحی شده است."

#: src/glossary.md
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""
"function:  \n"
"یک بلوک کد قابل استفاده مجدد که وظیفه خاصی را انجام می‌دهد."

#: src/glossary.md
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""
"garbage collector:  \n"
"مکانیزمی که به طور خودکار حافظه اشغال شده توسط اشیایی که دیگر استفاده "
"نمی‌شوند را آزاد می‌کند."

#: src/glossary.md
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""
"generics:  \n"
"قابلیتی که امکان نوشتن کد با متغیرهایی برای انواع را فراهم می‌کند و امکان "
"استفاده مجدد از کد با انواع داده‌های مختلف را فراهم می‌کند."

#: src/glossary.md
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""
"immutable:  \n"
"پس از ایجاد، دیگر قابل تغییر نیست."

#: src/glossary.md
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""
"integration test:  \n"
"نوعی تست که تعامل بین بخش‌ها یا اجزای مختلف یک سیستم را تأیید می‌کند."

#: src/glossary.md
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""
"keyword:  \n"
"یک کلمه رزرو شده در یک زبان برنامه‌نویسی که معنای خاصی دارد و نمی‌توان از آن "
"به عنوان شناسه یا سایر نامگذاری‌ها استفاده کرد."

#: src/glossary.md
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""
"library:  \n"
"مجموعه‌ای از routine‌ها یا کدهای از پیش کامپایل شده که می تواند توسط برنامه‌ها "
"استفاده شود."

#: src/glossary.md
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""
"macro:  \n"
"ماکروهای Rust را می‌توان با یک `!` در نام آن تشخیص داد. ماکروها زمانی استفاده "
"می‌شوند که توابع عادی کافی نباشد. یک مثال معمولی `format!` است که تعداد "
"متغیری از آرگومان‌ها را می‌گیرد که توسط توابع Rust پشتیبانی نمی‌شوند."

#: src/glossary.md
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""
"`main` function:  \n"
"\n"
"برنامه‌های Rust با تابع `main` شروع به اجرا می‌کنند."

#: src/glossary.md
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""
"match:  \n"
"یک ساختار جریان کنترلی در Rust که امکان تطبیق الگو بر روی مقدار یک عبارت را "
"فراهم می‌کند."

#: src/glossary.md
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""
"memory leak:  \n"
"وضعیتی که در آن برنامه نمی‌تواند حافظه‌ای را که دیگر مورد نیاز نیست آزاد کند و "
"منجر به افزایش تدریجی استفاده از حافظه می‌شود."

#: src/glossary.md
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""
"method:  \n"
"یک تابع مرتبط با یک object یا یک type در Rust."

#: src/glossary.md
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""
"module:  \n"
"فضای نامی که شامل تعاریفی مانند توابع، انواع یا صفات برای سازماندهی کد در "
"Rust است."

#: src/glossary.md
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""
"move:  \n"
"انتقال مالکیت (ownership) یک مقدار از یک متغیر به متغیر دیگر در Rust."

#: src/glossary.md
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""
"mutable:  \n"
"یک ویژگی در Rust که به متغیرها اجازه می‌دهد پس از اعلان، اصلاح شوند."

#: src/glossary.md
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""
"ownership:  \n"
"مفهومی در Rust که مشخص می‌کند کدام قسمت از کد مسئول مدیریت حافظه مرتبط با یک "
"مقدار است."

#: src/glossary.md
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""
"panic:  \n"
"یک وضعیت خطای غیرقابل جبران در Rust که منجر به خاتمه برنامه می‌شود."

#: src/glossary.md
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""
"parameter:  \n"
"مقداری که هنگام فراخوانی به یک تابع یا متد ارسال می‌شود."

#: src/glossary.md
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""
"pattern:  \n"
"ترکیبی از مقادیر، عبارت‌ها یا ساختارهایی که می‌توانند با یک عبارت در Rust "
"مطابقت داده شوند."

#: src/glossary.md
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""
"payload:  \n"
"داده یا اطلاعاتی که توسط یک پیام، رویداد یا ساختار داده حمل می‌شود."

#: src/glossary.md
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""
"program:  \n"
"مجموعه‌ای از دستورالعمل‌هایی که یک کامپیوتر می‌تواند برای انجام یک کار خاص یا "
"حل یک مشکل خاصی اجرا کند."

#: src/glossary.md
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""
"مجموعه‌ای از دستورالعمل‌هایی که یک کامپیوتر می‌تواند برای انجام یک کار خاص یا "
"حل یک مشکل خاص اجرا کند."

#: src/glossary.md
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""
"receiver:  \n"
"اولین پارامتر در متد Rust که نمونه‌ای را نشان می‌دهد که متد در آن فراخوانی "
"می‌شود."

#: src/glossary.md
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""
"reference counting:  \n"
"یک تکنیک مدیریت حافظه که در آن تعداد ارجاعات به یک object ردیابی می‌شود و "
"زمانی که شمارش به صفر می‌رسد، object تخصیص داده می‌شود."

#: src/glossary.md
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""
"return:  \n"
"یک کلمه کلیدی در Rust برای نشان دادن مقداری که باید از یک تابع برگردانده شود "
"استفاده می‌شود."

#: src/glossary.md
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""
"Rust:  \n"
"یک زبان برنامه‌نویسی سیستمی که بر safety، کارایی و concurrency تمرکز دارد."

#: src/glossary.md
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 4 of this course."
msgstr ""
"Rust Fundamentals:  \n"
"روزهای ۱ تا ۴ این دوره."

# check in browser again
#: src/glossary.md
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""
"Rust در Android:\n"
"این [Rust in Android](android.md) را ببینید."

#: src/glossary.md
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr ""
"‏ Rust در Chromium:  \n"
"‏ [Rust in Chromium](chromium.md) را ببینید."

#: src/glossary.md
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""
"safe:  \n"
"به کدی اشاره دارد که به قوانین مالکیت (ownership) در زبان Rust و قرض‌گرفتن "
"(borrowing) پایبند است و از خطاهای مربوط به حافظه جلوگیری می‌کند."

#: src/glossary.md
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""
"scope:  \n"
"منطقه‌ای از یک برنامه که در آن یک متغیر معتبر است و می‌توان از آن استفاده کرد."

#: src/glossary.md
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""
"standard library:  \n"
"مجموعه‌ای از ماژول‌ها که عملکردهای ضروری را در Rust ارائه می‌دهند."

#: src/glossary.md
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""
"static:  \n"
"یک کلمه کلیدی در Rust برای تعریف متغیرهای ثابت یا موارد با طول عمر `'static` "
"استفاده می‌شود."

#: src/glossary.md
msgid ""
"string:  \n"
"A data type storing textual data. See [Strings](references/strings.html) for "
"more."
msgstr ""
"string:  \n"
"نوع داده‌ای که داده‌های متنی را ذخیره می‌کند. برای اطلاعات بیشتر به [Strings]"
"(references/strings.html) مراجعه کنید."

#: src/glossary.md
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""
"struct:  \n"
"یک نوع داده ترکیبی در Rust که متغیرهای انواع مختلف را تحت یک نام واحد جمع "
"می‌کند."

#: src/glossary.md
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""
"test:  \n"
"یک ماژول Rust حاوی توابعی که صحت عملکردهای دیگر را آزمایش می‌کند."

#: src/glossary.md
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""
"thread:  \n"
"دنباله‌ای جداگانه از اجرا در یک برنامه که امکان اجرای همزمان را فراهم می‌کند."

#: src/glossary.md
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""
"thread safety:  \n"
"ویژگی برنامه‌ای که رفتار صحیح را در یک محیط multithread تضمین می‌کند."

#: src/glossary.md
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""
"trait:  \n"
"مجموعه‌ای از متدهای تعریف شده برای یک type ناشناخته، راهی برای دستیابی به "
"polymorphism در Rust ارائه می‌دهد."

#: src/glossary.md
#, fuzzy
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""
"trait bound:  \n"
"انتزاعی که در آن می‌توانید برای پیاده‌سازی برخی از ویژگی‌های (traitها) مورد "
"علاقه‌تان به typeها نیاز داشته باشید."

#: src/glossary.md
msgid ""
"tuple:  \n"
"A composite data type that contains variables of different types. Tuple "
"fields have no names, and are accessed by their ordinal numbers."
msgstr ""
"tuple:  \n"
"یک data type ترکیبی که شامل متغیرهایی از انواع مختلف است. فیلدهای Tuple "
"بی‌نام هستند و با شماره ترتیبی آنها قابل دسترسی هستند."

#: src/glossary.md
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""
"type:  \n"
"طبقه‌بندی که مشخص می‌کند کدام عملیات را می‌توان بر روی مقادیری از یک تایپ خاص "
"در Rust انجام داد."

#: src/glossary.md
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""
"type inference:  \n"
"توانایی کامپایلر Rust برای شناسایی تایپ یک متغیر یا عبارت."

#: src/glossary.md
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""
"undefined behavior:  \n"
"اقدامات یا شرایطی در Rust که هیچ نتیجه مشخصی ندارند و اغلب منجر به رفتار "
"غیرقابل پیش‌بینی برنامه می‌شوند."

#: src/glossary.md
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""
"union:  \n"
"یک data type که می‌تواند مقادیری از انواع مختلف را در خود نگه دارد، اما فقط "
"یکی در یک زمان خاص."

#: src/glossary.md
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""
"unit test:  \n"
"‏ Rust با پشتیبانی داخلی برای اجرای unit testهای کوچک و integration testهای "
"بزرگتر ارائه می‌شود. [Unit Tests](testing/unit-tests.html) را ببینید."

#: src/glossary.md
msgid ""
"unit type:  \n"
"Type that holds no data, written as a tuple with no members."
msgstr ""
"unit type:  \n"
"نوعی که هیچ داده‌ای را در خود نگه نمی‌دارد و به صورت tuple بدون هیچ عضوی نوشته "
"شده است."

#: src/glossary.md
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe-rust/unsafe.md)."
msgstr ""
"unsafe:  \n"
"زیرمجموعه (subset) در Rust که به شما امکان می‌دهد رفتار نامشخصی را فعال‌سازی "
"کنید. [Unsafe Rust] (unsafe-rust/unsafe.md) را ببینید."

#: src/glossary.md
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""
"variable:  \n"
"یک مکان حافظه که داده‌ها را ذخیره می‌کند. متغیرها در یک _scope_ معتبر هستند."

#: src/other-resources.md
msgid "Other Rust Resources"
msgstr "سایر منابع برای Rust"

#: src/other-resources.md
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"جامعه Rust منابع بسیار باکیفیت و رایگان را به صورت آنلاین ایجاد کرده است."

#: src/other-resources.md
msgid "Official Documentation"
msgstr "مستندات رسمی"

#: src/other-resources.md
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"پروژه Rust میزبان منابع بسیاری است. این‌ منابع، Rust را به طور کامل پوشش "
"می‌دهند:"

#: src/other-resources.md
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"‏ [زبان برنامه نویسی Rust] (https://doc.rust-lang.org/book/): کتاب رایگان و "
"معروف در مورد Rust که این زبان را با جزئیات دقیقی پوشش می‌دهد و شامل چند "
"پروژه برای ساخت نرم‌افزار می‌شود."

#: src/other-resources.md
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"‏ [Rust By Example](https://doc.rust-lang.org/rust-by-example/): در مورد Rust "
"syntax را به کمک یک سری از مثال‌ها پوشش می‌دهد که ساختارهای مختلف را به نمایش "
"می‌گذارد. گاهی اوقات شامل تمرین‌های کوچکی می‌شود که از شما خواسته می‌شود کد را "
"در مثال‌ها گسترش دهید."

#: src/other-resources.md
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"‏ [Rust Standard Library]‌(https://doc.rust-lang.org/std/): مستندات کامل "
"کتابخانه استاندارد برای Rust می‌باشد."

#: src/other-resources.md
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"‏ [The Rust Reference](https://doc.rust-lang.org/reference/): کتاب ناقصی که "
"گرامر و مدل حافظه Rust را توصیف می‌کند."

#: src/other-resources.md
msgid "More specialized guides hosted on the official Rust site:"
msgstr "راهنماهای تخصصی بیشتر میزبانی شده در سایت رسمی Rust:"

#: src/other-resources.md
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"‏[Rustonomicon](https://doc.rust-lang.org/nomicon/): که unsafe Rust ناامن را "
"پوشش می‌دهد، از جمله کار با pointerهای خام و interfaceهای با زبان های دیگر "
"(FFI) را تشریح می‌کند."

#: src/other-resources.md
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"‏ [برنامه نویسی ناهمزمان در Rust](https://rust-lang.github.io/async-book/): "
"مدل برنامه‌نویسی ناهمزمان (asynchronous programming) جدیدی را پوشش می‌دهد که "
"پس از نگارش کتاب Rust معرفی شده است."

#: src/other-resources.md
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"‏ [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"مقدمه‌ای بر استفاده از Rust در embedded deviceها که بدون سیستم‌عامل هستند را "
"شامل می‌شود."

#: src/other-resources.md
msgid "Unofficial Learning Material"
msgstr "مطالب آموزشی غیر‌رسمی"

#: src/other-resources.md
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "مجموعه کوچکی از راهنماها و آموزش‌های دیگر برای Rust:"

#: src/other-resources.md
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"‏ [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): درباره "
"Rust را از دیدگاه برنامه‌نویسان سطح پایین C پوشش می‌دهد."

#: src/other-resources.md
msgid ""
"[Rust for Embedded C Programmers](https://opentitan.org/book/doc/"
"rust_for_c_devs.html): covers Rust from the perspective of developers who "
"write firmware in C."
msgstr ""
"‏ [Rust for Embedded C Programmers](https://opentitan.org/book/doc/"
"rust_for_c_devs.html): که Rust را از دیدگاه توسعه‌دهندگانی که سیستم‌عامل را به "
"زبان C می‌نویسند پوشش می‌دهد."

#: src/other-resources.md
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"‏ [Rust for Professionals](https://overexact.com/rust-for-professionals/): که "
"syntax مورد استفاده Rust را به کمک  مقایسه‌های جانبی با زبان‌های دیگر مانند C، "
"C++، Java، JavaScript و Python پوشش می‌دهد."

#: src/other-resources.md
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"‏ [Rust on Exercism](https://exercism.org/tracks/rust): بیش از ۱۰۰ تمرین برای "
"کمک به یادگیری Rust را شامل می‌شود."

#: src/other-resources.md
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"‏ [Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): مجموعه‌ای از ارائه‌های کوچک که هم بخش پایه و هم پیشرفته "
"زبان Rust را پوشش می‌دهد. موضوعات دیگری مانند WebAssembly و async/wait نیز "
"پوشش داده شده است."

#: src/other-resources.md
#, fuzzy
msgid ""
"[Advanced testing for Rust applications](https://rust-exercises.com/advanced-"
"testing/): a self-paced workshop that goes beyond Rust's built-in testing "
"framework. It covers `googletest`, snapshot testing, mocking as well as how "
"to write your own custom test harness."
msgstr ""
"‏ [تست پیشرفته برای برنامه‌های Rust](https://github.com/mainmatter/rust-"
"advanced-testing-workshop): کارگاهی خودآموز که فراتر از چارچوب تست داخلی "
"Rust است. این `googletest`، تست snapshot و mocking و همچنین نحوه نوشتن "
"تست‌های سفارشی خود را پوشش می‌دهد."

#: src/other-resources.md
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"‏ [Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/"
"beginners-series-to-rust/) و [اولین قدم های خود را با Rust بردارید](https://"
"docs.microsoft. com/en-us/learn/paths/rust-first-steps/): دو راهنمای Rust با "
"هدف توسعه‌دهندگان جدید می‌باشد. اولی مجموعه‌ای از ۳۵ ویدیو و دومی مجموعه‌ای از "
"۱۱ ماژول است که دستور Rust و ساختارهای اولیه را پوشش می‌دهد."

#: src/other-resources.md
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"‏ [Learn Rust With Entirely Too Linked Lists]‌(https://rust-unofficial.github."
"io/too-many-lists/): کاوش عمیق قوانین مدیریت حافظه Rust، از طریق اجرای چند "
"نوع مختلف list structure."

#: src/other-resources.md
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"لطفاً [Little Book of Rust Books]‌(https://lborb.github.io/book/) را برای "
"کتاب‌های بیشتر در مورد Rust ببینید."

#: src/credits.md
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"مطالب در اینجا بر روی بسیاری از منابع عالی مستندات Rust ساخته شده است. برای "
"فهرست کامل منابع مفید به صفحه [دیگر منابع]‌(other-resources.md) مراجعه کنید."

#: src/credits.md
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"محتوای Comprehensive Rust تحت مجوز Apache 2.0 مجوز دارند، لطفاً برای جزئیات "
"بیشتر به ['LICENSE'](https://github.com/google/comprehensive-rust/blob/main/"
"LICENSE) مراجعه کنید."

#: src/credits.md
msgid "Rust by Example"
msgstr "‏ Rust به‌همراه مثال"

#: src/credits.md
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"‏ برخی از مثال‌ها و تمرین‌ها از [Rust by Example]‌(https://doc.rust-lang.org/"
"rust-by-example/) کپی و اقتباس شده‌اند. لطفاً برای جزئیات، از جمله شرایط "
"license، به دایرکتوری `third_party/rust-by-example/` مراجعه کنید."

#: src/credits.md
msgid "Rust on Exercism"
msgstr "‏ Rust در تمرین‌ها"

#: src/credits.md
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"برخی تمرین‌‌ا از [Rust on Exercism]‌(https://exercism.org/tracks/rust) کپی و "
"اقتباس شده‌اند. لطفاً برای جزئیات، از جمله شرایط license، به دایرکتوری "
"`third_party/rust-on-exercism/` مراجعه کنید."

#: src/credits.md
msgid "CXX"
msgstr "CXX"

#: src/credits.md
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"بخش [Interoperability with C++](android/interoperability/cpp.md) از تصویری "
"از [CXX](https://cxx.rs/) استفاده می‌کند. لطفاً برای جزئیات، از جمله شرایط "
"license، دایرکتوری `third_party/cxx/` را ببینید."

#~ msgid "Slices: `&[T]`"
#~ msgstr "برش ها: `&[T]`"

#~ msgid "Slices: &\\[T\\]"
#~ msgstr "برش‌ها: `[T]&`"

#~ msgid ""
#~ "By default, closures will capture by reference if they can. The `move` "
#~ "keyword makes them capture by value."
#~ msgstr ""
#~ "به‌طور پیش‌فرض، closure ها اگر بتوانند، با ارجاع (reference) مقادیر را "
#~ "می‌گیرند. کلمه کلیدی `move` باعث می‌شود که آنها مقادیر را به‌صورت مالکیت (by "
#~ "value) بگیرند."

#~ msgid ""
#~ "There is a plan to transition [Android](https://source.android.com/docs/"
#~ "setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
#~ "com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/"
#~ "setup/build/bazel/introduction) to Bazel."
#~ msgstr ""
#~ "برنامه‌ای برای انتقال [Android](https://source.android.com/docs/setup/"
#~ "build/bazel/introduction)، [ChromeOS](https://chromium.googlesource.com/"
#~ "chromiumos/bazel/) وجود دارد و انتقال [Fuchsia](https://source.android."
#~ "com/docs/setup/build/bazel/introduction) به Bazel."

#~ msgid ""
#~ "Learning Bazel-like build rules is useful for all Rust OS developers."
#~ msgstr ""
#~ "یادگیری قوانین ساخت Bazel-like برای همه توسعه‌دهندگان Rust OS مفید است."

#~ msgid ""
#~ "Threads are all daemon threads, the main thread does not wait for them."
#~ msgstr "‏Thread‌ها همه daemon thread هستند و main thread منتظر آنها نیست."

#, fuzzy
#~ msgid "\"Felix\""
#~ msgstr "\"Felix\""

#, fuzzy
#~ msgid "\"Failed to send cat.\""
#~ msgstr "\"Failed to send cat.\""

#, fuzzy
#~ msgid "\"Failed to send dog.\""
#~ msgstr "\"Failed to send dog.\""

#, fuzzy
#~ msgid "\"Failed to receive winner\""
#~ msgstr "\"Failed to receive winner\""

#, fuzzy
#~ msgid "\"Winner is {winner:?}\""
#~ msgstr "\"Winner is {winner:?}\""

#~ msgid ""
#~ "In this example, we have a race between a cat and a dog. "
#~ "`first_animal_to_finish_race` listens to both channels and will pick "
#~ "whichever arrives first. Since the dog takes 50ms, it wins against the "
#~ "cat that take 500ms."
#~ msgstr ""
#~ "در این مثال مسابقه‌ای بین گربه و سگ داریم. `first_animal_to_finish_race` "
#~ "به هر دو channelها گوش می‌دهد و هر کدام را زودتر وارد شوند را انتخاب می‌کند."
#~ "بنابراین سگ ۵۰ میلی‌ثانیه طول می‌کشد، در برابر گربه‌ای که ۵۰۰ میلی‌ثانیه طول "
#~ "می‌کشد تا پیروز شود."

#~ msgid ""
#~ "You can use `oneshot` channels in this example as the channels are "
#~ "supposed to receive only one `send`."
#~ msgstr ""
#~ "در این مثال می‌توانید از کانال‌های `oneshot` استفاده کنید زیرا قرار است "
#~ "کانال‌ها فقط یک `send` را دریافت کنند."

#~ msgid ""
#~ "Try adding a deadline to the race, demonstrating selecting different "
#~ "sorts of futures."
#~ msgstr ""
#~ "سعی کنید یک ضرب الاجل به رقابت اضافه کنید و انتخاب انواع مختلف future را "
#~ "نشان دهید."

#~ msgid ""
#~ "Note that `select!` drops unmatched branches, which cancels their "
#~ "futures. It is easiest to use when every execution of `select!` creates "
#~ "new futures."
#~ msgstr ""
#~ "توجه داشته باشید که `select!` شاخه‌های (branch) بی‌همتا را حذف می کند و  "
#~ "future آنها را لغو می‌کند. زمانی که هر اجرای `select!` می‌تواند future‌های "
#~ "جدیدی ایجاد می‌کند، راحت‌ترین استفاده از آن است."

#~ msgid ""
#~ "An alternative is to pass `&mut future` instead of the future itself, but "
#~ "this can lead to issues, further discussed in the pinning slide."
#~ msgstr ""
#~ "یک راه جایگزین این است که به جای خودِ future از `&mut future` استفاده "
#~ "کنید، اما این کار می‌تواند منجر به مسائلی شود که بیشتر در اسلاید سنجاق "
#~ "(pinning slide) شده بحث شده است."

#~ msgid "1 hour and 20 minutes"
#~ msgstr "۱ ساعت و ۲۰ دقیقه"

#~ msgid "1 hour and 40 minutes"
#~ msgstr "۱ ساعت ۴۰ دقیقه"

#~ msgid "Day 2 Afternoon (4 hours, including breaks)"
#~ msgstr "روز دوم بعدازظهر (4 ساعت با احتساب استراحت)"

#~ msgid "You can use "
#~ msgstr "شما می توانید استفاده کنید "

#, fuzzy
#~ msgid "`String` is an owned, heap-allocated buffer of UTF-8 bytes."
#~ msgstr "`String` یک بافر متعلق به پشته از UTF-8 بایت است."

#~ msgid "`match` expressions"
#~ msgstr "عبارت `match`"

#~ msgid "Box"
#~ msgstr "Box"

#~ msgid "Conditionals"
#~ msgstr "شرط ها"

#~ msgid "Static and Const"
#~ msgstr "Static و Const"

#~ msgid "Control Flow"
#~ msgstr "کنترل جریان"

#, fuzzy
#~ msgid "[Pattern Matching](../pattern-matching.md) (50 minutes)"
#~ msgstr ""
#~ "به [تطبیق الگو](../pattern-matching.md) مراجعه کنید تا در مورد الگوها در "
#~ "Rust اطلاعات بیشتری کسب کنید."

#, fuzzy
#~ msgid "`String` - a modifiable, owned string."
#~ msgstr "`String` یک بافر رشته‌ای قابل تغییر است."

#~ msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
#~ msgstr "بسیاری از دستور زبان Rust مشابه زبان‌های C، C++ یا Java خواهد بود:"

#, fuzzy
#~ msgid "Blocks are delimited by curly braces."
#~ msgstr "بلاک‌ها و اسکوپ‌ها با پرانتزهای باز و بسته مشخص می‌شوند."

#~ msgid ""
#~ "Line comments are started with `//`, block comments are delimited by `/"
#~ "* ... */`."
#~ msgstr ""
#~ "کامنت‌های تک خطی با ‍`//` شروع می‌شوند و کامنت‌های چند خطی با `/* ... */` "
#~ "مشخص می‌شوند."

#~ msgid "Keywords like `if` and `while` work the same."
#~ msgstr "کلمات کلیدی مانند `if `و `while` به همان صورت عمل می‌کنند."

#~ msgid "Variable assignment is done with `=`, comparison is done with `==`."
#~ msgstr "انتساب متغیر با `=` انجام می‌شود، مقایسه با `==` انجام می‌شود."

#~ msgid ""
#~ "In this case we break the outer loop after 3 iterations of the inner loop."
#~ msgstr ""
#~ "در این مورد، پس از 3 تکرار حلقه `inner`، از حلقه `outer` خارج می‌شویم."

#~ msgid "`[T; N]`"
#~ msgstr "<span dir=ltr><code class=hljs>[T; N]</code></span>"

#~ msgid "`[20, 30, 40]`, `[0; 3]`"
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>[20, 30, 40]</code>, <code class=hljs>[0; "
#~ "3]</code></span>"

#~ msgid "`()`, `(T,)`, `(T1, T2)`, ..."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>()</code>, <code class=hljs>(T,)</code>, "
#~ "<code class=hljs>(T1, T2)</code>, …</span>"

#~ msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>()</code>, <code class=hljs>('x',)</code>, "
#~ "<code class=hljs>('x', 1.2)</code>, …</span>"

#~ msgid "Array assignment and access:"
#~ msgstr "انتساب و دسترسی به آرایه:"

#~ msgid "Tuple assignment and access:"
#~ msgstr "انتساب و دسترسی به تاپل:"

#~ msgid "Arrays:"
#~ msgstr "آرایه‌ها:"

#~ msgid "Tuples:"
#~ msgstr ":تاپل‌ها"

#, fuzzy
#~ msgid ""
#~ "The empty tuple `()` is also known as the \"unit type\". It is both a "
#~ "type, and the only valid value of that type --- that is to say both the "
#~ "type and its value are expressed as `()`. It is used to indicate, for "
#~ "example, that a function or expression has no return value, as we'll see "
#~ "in a future slide."
#~ msgstr ""
#~ "تاپل خالی <span dir=ltr>`()`</span> همچنین به عنوان «نوع یکه» شناخته "
#~ "می‌شود. این هم یک نوع است و هم تنها مقدار معتبر آن نوع - یعنی هم نوع و هم "
#~ "مقدار آن به صورت <span dir=ltr>`()`</span> بیان می‌شوند.رای مثال برای نشان "
#~ "دادن اینکه یک تابع یا عبارت هیچ مقدار برگشتی ندارد استفاده می‌شود، همانطور "
#~ "که در اسلاید بعدی خواهیم دید. "

#, fuzzy
#~ msgid ""
#~ "You can think of it as `void` that can be familiar to you from other "
#~ "programming languages."
#~ msgstr ""
#~ "می‌توانید آن را به عنوان `void` در نظر بگیرید که ممکن است از سایر زبان‌های "
#~ "برنامه‌نویسی برایتان آشنا باشد."

#, fuzzy
#~ msgid "You can destructure tuples and arrays by matching on their elements:"
#~ msgstr ""
#~ "می توانید آرایه‌ها، تاپل‌ها و برش‌ها را با تطابق با عناصر آنها destructure "
#~ "کنید."

#, fuzzy
#~ msgid "Create a new array pattern using `_` to represent an element."
#~ msgstr "یک الگوی جدید با استفاده از `_` برای نمایش یک عنصر ایجاد کنید."

#~ msgid "Add more values to the array."
#~ msgstr "مقادیر بیشتری را به آرایه اضافه کنید."

#~ msgid ""
#~ "Point out that how `..` will expand to account for different number of "
#~ "elements."
#~ msgstr ""
#~ "اشاره کنید که چگونه `..` برای در نظر گرفتن تعداد عناصر مختلف، گسترش خواهد "
#~ "یافت."

#~ msgid ""
#~ "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
#~ msgstr ""
#~ "مطابقت با انتهای آرایه رو با با الگوهای <span dir=ltr>`[.., b]`</span>  و "
#~ "<span dir=ltr>`[a@..,b]`</span> را نشان دهید."

#~ msgid "Hard-code both functions to operate on 3 × 3 matrices."
#~ msgstr "هر دو تابع را برای کار بر روی ماتریس‌های 3 × 3 هاردکد کنید."

#, fuzzy
#~ msgid ""
#~ "Static and constant variables are two different ways to create globally-"
#~ "scoped values that cannot be moved or reallocated during the execution of "
#~ "the program."
#~ msgstr ""
#~ "متغیرهای `ثابت` و `ایستا` دو روش متفاوت برای ایجاد مقادیر با اسکوپ گلوبال "
#~ "(قابل دسترس در کل برنامه) هستند که نمی‌توانند در طول اجرای برنامه منتقل یا "
#~ "دوباره تعریف شوند."

#~ msgid "Properties table:"
#~ msgstr "جدول خاصیت‌ها:"

#~ msgid "Has an address in memory"
#~ msgstr "دارای یک آدرس واقعی در حافظه"

#~ msgid "No (inlined)"
#~ msgstr "خیر (به صورت درون خطی)"

#~ msgid "Lives for the entire duration of the program"
#~ msgstr "در طول‌عمر کل برنامه زنده می‌ماند؟"

#~ msgid "Can be mutable"
#~ msgstr "میتوان قابل تغییر اش کرد"

#~ msgid "Yes (unsafe)"
#~ msgstr "بلی (unsafe)"

#~ msgid "Evaluated at compile time"
#~ msgstr "ارزیابی در زمان کامپایل"

#~ msgid "Yes (initialised at compile time)"
#~ msgstr "بلی (در زمان کامپایل ساخته می‌شود)"

#~ msgid "Inlined wherever it is used"
#~ msgstr "به صورت درون‌خطی هر جا که استفاده میشود قرار میگیرد"

#, fuzzy
#~ msgid "[Pattern Matching](./pattern-matching.md) (50 minutes)"
#~ msgstr ""
#~ "به [تطبیق الگو](../pattern-matching.md) مراجعه کنید تا در مورد الگوها در "
#~ "Rust اطلاعات بیشتری کسب کنید."

#~ msgid "Rust terminology:"
#~ msgstr "اصطلاحات راست:"

#~ msgid "`&str` an immutable reference to a string slice."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>&amp;str</code></span>  یک مرجع غیرقابل "
#~ "تغییر به یک برش از رشته‌ است."

#~ msgid "`String` a mutable string buffer."
#~ msgstr "`String` یک بافر رشته‌ای قابل تغییر است."

#, fuzzy
#~ msgid "// Undefined behavior if abs misbehaves.\n"
#~ msgstr "هیچ رفتار تعریف نشده‌ای در زمان اجرا:"

#, fuzzy
#~ msgid "\"aarch64-linux-gnu\""
#~ msgstr "aarch64-paging"

#, fuzzy
#~ msgid "\"exceptions.S\""
#~ msgstr "استثناها"

#, fuzzy
#~ msgid "aarch64-linux-gnu"
#~ msgstr "aarch64-paging"

#~ msgid "Small Example"
#~ msgstr "یک مثال ساده"

#~ msgid "Why Rust?"
#~ msgstr "چرا Rust؟"

#~ msgid "An Example in C"
#~ msgstr "یک مثال در زبان C"

#~ msgid "Compile Time Guarantees"
#~ msgstr "ضمانت‌های زمان کامپایل"

#~ msgid "Runtime Guarantees"
#~ msgstr "ضمانت‌های زمان اجرا"

#~ msgid "Modern Features"
#~ msgstr "ویژگی‌های جدید"

#~ msgid "Basic Syntax"
#~ msgstr "سینتکس‌های مقدماتی"

#~ msgid "String vs str"
#~ msgstr "String در مقابل str"

#~ msgid "Rustdoc"
#~ msgstr "داکیومنت نویسی"

#~ msgid "Overloading"
#~ msgstr "سربارگذاری"

#~ msgid "Arrays and for Loops"
#~ msgstr "آرایه ها و حلقه های for"

#~ msgid "for expressions"
#~ msgstr "عبارت  for"

#~ msgid "while expressions"
#~ msgstr "عبارت حلقه while"

#~ msgid "break & continue"
#~ msgstr "توقف و ادامه دادن (break & continue)"

#~ msgid "loop expressions"
#~ msgstr "عبارت loop"

#~ msgid "Variant Payloads"
#~ msgstr "Variant Payloads"

#~ msgid "Enum Sizes"
#~ msgstr "اندازه ی Enum ها"

#~ msgid "if let expressions"
#~ msgstr "عبارت if let"

#~ msgid "while let expressions"
#~ msgstr "عبارت while let"

#~ msgid "match expressions"
#~ msgstr "عبارت تطبیق"

#~ msgid "Destructuring Arrays"
#~ msgstr "تخریب آرایه‌ها"

#~ msgid "Match Guards"
#~ msgstr "گاردهای تطبیق"

#~ msgid "Stack vs Heap"
#~ msgstr "مقایسه پشته و انباشت"

#~ msgid "Stack Memory"
#~ msgstr "حافظه پشته"

#~ msgid "Manual Memory Management"
#~ msgstr "مدیریت دستی حافظه"

#~ msgid "Scope-Based Memory Management"
#~ msgstr "مدیریت حافظه مبتنی بر دامنه"

#~ msgid "Garbage Collection"
#~ msgstr "جمع آوری زباله (GC)"

#~ msgid "Rust Memory Management"
#~ msgstr "مدیریت حافظه Rust"

#~ msgid "Moved Strings in Rust"
#~ msgstr "های جابجا شده در Rust String"

#~ msgid "Double Frees in Modern C++"
#~ msgstr "آزاد سازی مضاعف در سی‌پلاس‌پلاس مدرن"

#~ msgid "Moves in Function Calls"
#~ msgstr "جابه‌جایی در صدا زدن توابع"

#~ msgid "Copying and Cloning"
#~ msgstr "کپی برداری و شبیه سازی"

#~ msgid "Shared and Unique Borrows"
#~ msgstr "قرض گرفتن‌های مشترک و منحصر به فرد"

#~ msgid "Field Shorthand Syntax"
#~ msgstr "نحو اختصاری فیلد"

#~ msgid "Storing Books"
#~ msgstr "ذخیره سازی کتاب"

#~ msgid "Option and Result"
#~ msgstr "Option و Result"

#~ msgid "Iterators and Ownership"
#~ msgstr "تکرار کننده ها و مالکیت"

#~ msgid "Strings and Iterators"
#~ msgstr "رشته ها و تکرار کننده‌ها (Strings and Iterators)"

#~ msgid "Generic Methods"
#~ msgstr "متدهای جنریک"

#~ msgid "Monomorphization"
#~ msgstr "تک شکلی"

#~ msgid "Default Methods"
#~ msgstr "متدهای پیشفرض"

#~ msgid "Important Traits"
#~ msgstr "صفات مهم"

#~ msgid "Default"
#~ msgstr "پیش‌فرض"

#~ msgid "Operators: Add, Mul, ..."
#~ msgstr "عملگر‌های: جمع و ضرب, ..."

#~ msgid "Closures: Fn, FnMut, FnOnce"
#~ msgstr "بسته شدن‌ها: Fn, FnMut, FnOnce"

#~ msgid "A Simple GUI Library"
#~ msgstr "یک کتابخانه GUI ساده"

#~ msgid "Points and Polygons"
#~ msgstr "نقطه‌ها و چند ضلعی‌ها"

#~ msgid "Catching Stack Unwinding"
#~ msgstr "گرفتن Stack در حال بازگشایی"

#~ msgid "Structured Error Handling"
#~ msgstr "مدیریت خطای ساختاری"

#~ msgid "Propagating Errors with ?"
#~ msgstr "انتشار خطاها با استفاده از عملگر ؟"

#~ msgid "Converting Error Types"
#~ msgstr "تبدیل انواع خطا"

#~ msgid "Deriving Error Enums"
#~ msgstr "استخراج شماره‌های خطا"

#~ msgid "Adding Context to Errors"
#~ msgstr "اضافه کردن زمینه (Context) به خطاها"

#~ msgid "no_std"
#~ msgstr "no_std"

#~ msgid "alloc"
#~ msgstr "alloc"

#~ msgid "embedded-hal"
#~ msgstr "embedded-hal"

#~ msgid "zerocopy"
#~ msgstr "صفر کپی (zerocopy)"

#~ msgid "buddy_system_allocator"
#~ msgstr "buddy_system_allocator"

#~ msgid "tinyvec"
#~ msgstr "tinyvec"

#~ msgid "spin"
#~ msgstr "چرخش"

#~ msgid "Day 1 Morning"
#~ msgstr "روز ۱ صبح"

#~ msgid "Day 1 Afternoon"
#~ msgstr "روز ۱ عصر"

#~ msgid "Day 2 Morning"
#~ msgstr "روز ۲ صبح"

#~ msgid "Day 2 Afternoon"
#~ msgstr "روز ۲ عصر"

#~ msgid "Day 3 Morning"
#~ msgstr "روز ۳ صبح"

#~ msgid "Day 3 Afternoon"
#~ msgstr "روز ۳ عصر"

#~ msgid "Bare Metal Rust Morning"
#~ msgstr "صبح‌گاه با Bare Metal Rust"

#~ msgid "Concurrency Morning"
#~ msgstr "صبح‌گاه با همزمانی (Concurrency)"

#~ msgid "Concurrency Afternoon"
#~ msgstr "همزمانی: عصر"

#~ msgid ""
#~ "Day 1: Basic Rust, syntax, control flow, creating and consuming values."
#~ msgstr "روز 1: Rust مقدمات, سینتکس, کنترل جریان, ساخت و مصرف مقادیر."

#~ msgid ""
#~ "Day 2: Memory management, ownership, compound data types, and the "
#~ "standard library."
#~ msgstr "روز 2: مدیریت حافظه, مالکیت, انواع داده مرکب و کتابخانه استاندارد."

#~ msgid "Day 3: Generics, traits, error handling, testing, and unsafe Rust."
#~ msgstr "روز 3: جنریک‌ها, صفات, مدیریت خطا, تست‌کردن و Rust ناایمن."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
#~ "and `continue`."
#~ msgstr ""
#~ "سازوکارهای کنترل جریان: `if`, `if let`, `while`, `while let`, `break` و "
#~ "`continue`. "

#~ msgid ""
#~ "The idea for the first day is to show _just enough_ of Rust to be able to "
#~ "speak about the famous borrow checker. The way Rust handles memory is a "
#~ "major feature and we should show students this right away."
#~ msgstr ""
#~ "ایده برای روز اول این است که فقط به اندازه کافی از Rust را نشان دهیم تا "
#~ "بتوانیم در مورد بررسی کننده قرض `borrow checker` معروف صحبت کنیم.نحوه "
#~ "مدیریت حافظه توسط Rust یک ویژگی مهم است و باید آن را بلافاصله به "
#~ "دانشجویان نشان دهیم."

#~ msgid ""
#~ "If you're teaching this in a classroom, this is a good place to go over "
#~ "the schedule. We suggest splitting the day into two parts (following the "
#~ "slides):"
#~ msgstr ""
#~ "اینجا مکان مناسبی برای یک برنامه ریزی است.,اگر که شما این موضوع را در "
#~ "کلاس درس می دهیدما پیشنهاد می کنیم که روز را به دو قسمت تقسیم "
#~ "کنید(اسلاید‌ها را دنبال کنید)"

#~ msgid "Morning: 9:00 to 12:00,"
#~ msgstr "صبح: ۹:۰۰ تا ۱۲:۰۰"

#~ msgid "Afternoon: 13:00 to 16:00."
#~ msgstr "بعد از ظهر: ۱۳:۰۰ تا ۱۶:۰۰"

#~ msgid ""
#~ "You can of course adjust this as necessary. Please make sure to include "
#~ "breaks, we recommend a break every hour!"
#~ msgstr ""
#~ "البته می‌توانید این را بر‌حسب نیاز تنظیم کنید. لطفا مطمئن شوید که استراحت‌ها "
#~ "را نیز درنظر بگیرید، ما توصیه می‌کنیم هر ساعت یک استراحت داشته باشید!"

#~ msgid "Here is a small example program in Rust:"
#~ msgstr "یک برنامه کوچیک در Rust:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {              // Program entry point\n"
#~ "    let mut x: i32 = 6;  // Mutable variable binding\n"
#~ "    print!(\"{x}\");       // Macro for printing, like printf\n"
#~ "    while x != 1 {       // No parenthesis around expression\n"
#~ "        if x % 2 == 0 {  // Math like in other languages\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {              // نقطه ورودی برنامه\n"
#~ "    let mut x: i32 = 6;  //انتساب متغیر قابل تغییر\n"
#~ "    print!(\"{x}\");       // ماکرویی برای چاپ‌کردن به مانند printf\n"
#~ "    while x != 1 {       // هیچ پرانتزی اطراف دستور نیست\n"
#~ "        if x % 2 == 0 {  // محاسبات مانند بقیه زبان ها \n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The code implements the Collatz conjecture: it is believed that the loop "
#~ "will always end, but this is not yet proved. Edit the code and play with "
#~ "different inputs."
#~ msgstr ""
#~ "این کد حدس کولاتز (`Collatz conjecture`) را پیاده سازی می کند: اعتقاد بر "
#~ "این است که حلقه همیشه تمام می شود، اما این هنوز ثابت نشده است. کد را "
#~ "ویرایش کنید و با ورودی‌های مختلف بازی کنید."

#~ msgid ""
#~ "Explain that all variables are statically typed. Try removing `i32` to "
#~ "trigger type inference. Try with `i8` instead and trigger a runtime "
#~ "integer overflow."
#~ msgstr ""
#~ "توضیح دهید که همه متغیرها از نوع استاتیک هستند. سعی کنید `i32` را حذف "
#~ "کنید تا استنتاج نوع را فعال کنید. با `i8` امتحان کنید و سرریز "
#~ "(`overflow`) عدد صحیح در زمان اجرا را فعال کنید.."

#~ msgid "Change `let mut x` to `let x`, discuss the compiler error."
#~ msgstr ""
#~ "`let mut x` را به `let x` تغییر دهید، و خطای کامپایلر را بررسی کنید."

#~ msgid ""
#~ "Show how `print!` gives a compilation error if the arguments don't match "
#~ "the format string."
#~ msgstr ""
#~ "نشان دهید که چگونه <span dir=ltr>`print!`</span> در صورت عدم تطابق "
#~ "آرگومان‌ها با قالب رشته (`format string`) ، خطای کامپایل می دهد."

#~ msgid ""
#~ "Show how you need to use `{}` as a placeholder if you want to print an "
#~ "expression which is more complex than just a single variable."
#~ msgstr ""
#~ "نشان دهید که چگونه در صورت تمایل به چاپ عبارتی که پیچیده‌تر از یک متغیر "
#~ "واحد است،  باید از ‍`{}` به عنوان جایگزین استفاده کنید."

#~ msgid ""
#~ "Show the students the standard library, show them how to search for `std::"
#~ "fmt` which has the rules of the formatting mini-language. It's important "
#~ "that the students become familiar with searching in the standard library."
#~ msgstr ""
#~ "کتابخانه استاندارد را به دانشجویان نشان دهید، به آنها نشان دهید که چگونه "
#~ "`std::fmt` را که قوانین زبان-کوچک قالب‌بندی را دارد جستجو کنند. مهم است که "
#~ "دانشجویان  با جستجو در کتابخانه استاندارد آشنا شوند."

#~ msgid ""
#~ "In a shell `rustup doc std::fmt` will open a browser on the local std::"
#~ "fmt documentation"
#~ msgstr ""
#~ "در یک خط‌‌‌‌فرمان (`shell`) دستور `rustup doc std::fmt` را بزنید تا مستندات "
#~ "محلی ‍`std::fmt` را توی مرورگر باز کند."

#~ msgid "Compile time memory safety."
#~ msgstr "ایمنی حافظه در زمان کامپایل."

#~ msgid "Lack of undefined runtime behavior."
#~ msgstr "عدم وجود رفتار نامشخص در زمان اجرا."

#~ msgid "Modern language features."
#~ msgstr "ویژگی‌های زبانی مدرن."

#~ msgid "Let's consider the following \"minimum wrong example\" program in C:"
#~ msgstr ""
#~ "بیایید برنامه «نمونه ای از حداقل اشتباهات» زیر را در C در نظر بگیریم:"

#~ msgid "How many bugs do you spot?"
#~ msgstr "چند باگ پیدا می کنید؟"

#~ msgid ""
#~ "Despite just 29 lines of code, this C example contains serious bugs in at "
#~ "least 11:"
#~ msgstr "با وجود تنها ۲۹ خط کد، این مثال C حداقل 11 باگ جدی دارد: "

#~ msgid "Assignment `=` instead of equality comparison `==` (line 28)"
#~ msgstr "تخصیص `=` به جای مقایسه برابری `==` (خط ۲۸)"

#~ msgid "Excess argument to `printf` (line 23)"
#~ msgstr "ارگمان اضافی به `printf` (خط ۲۳)"

#~ msgid "File descriptor leak (after line 26)"
#~ msgstr "نشت توصیفگر فایل (`File descriptor`) (پس از خط ۲۶)"

#~ msgid "Forgotten braces in multi-line `if` (line 22)"
#~ msgstr "فراموشی پرانتز در `if` چند خطی (خط ۲۲)"

#~ msgid "Forgotten `break` in a `switch` statement (line 32)"
#~ msgstr "فراموشی `break` در `switch` (خط ۳۲)"

#~ msgid ""
#~ "Forgotten NUL-termination of the `buf` string, leading to a buffer "
#~ "overflow (line 29)"
#~ msgstr "فراموشی خاتمه `NUL` رشته `buf`، منجر به سرریز بافر (خط ۲۹) "

#~ msgid "Memory leak by not freeing the `malloc`\\-allocated buffer (line 21)"
#~ msgstr "نشت حافظه با آزاد نکردن بافر اختصاص داده شده توسط `malloc` (خط ۲۱)"

#~ msgid "Out-of-bounds access (line 17)"
#~ msgstr "دسترسی خارج از محدوده (خط ۱۷)"

#~ msgid "Unchecked cases in the `switch` statement (line 11)"
#~ msgstr "حالات بررسی نشده در `switch` (خط ۱۱)"

#~ msgid "Unchecked return values of `stat` and `fopen` (lines 18 and 26)"
#~ msgstr "مقادیر برگشتی از `stat` و `fopen`  بررسی نشده (خطوط ۱۸ و ۲۶)"

#~ msgid ""
#~ "_Shouldn't these bugs be obvious even for a C compiler?_  \n"
#~ "No, surprisingly this code compiles warning-free at the default warning "
#~ "level, even in the latest GCC version (13.2 as of writing)."
#~ msgstr ""
#~ "_آیا این باگها نباید برای یک کامپایلر C نمایان باشد؟_  \n"
#~ "نه، به طور شگفت انگیزی این کد بدون هیچ هشدار در سطح هشدار(`warning`) پیش "
#~ "فرض کامپایل می شود، حتی در آخرین نسخه GCC (۱۳.۲  این کتاب در زمان نوشتن)."

#~ msgid ""
#~ "_Isn't this a highly unrealistic example?_  \n"
#~ "Absolutely not, these kind of bugs have lead to serious security "
#~ "vulnerabilities in the past. Some examples:"
#~ msgstr ""
#~ "_آیا این یک مثال خیلی غیر واقعی نیست؟_  \n"
#~ "ابدا نه، این نوع از باگ‌ها در گذشته منجر به آسیب‌پذیری‌های امنیتی جدی "
#~ "شده‌اند. چند نمونه:"

#~ msgid ""
#~ "Assignment `=` instead of equality comparison `==`: [The Linux Backdoor "
#~ "Attempt of 2003](https://freedom-to-tinker.com/2013/10/09/the-linux-"
#~ "backdoor-attempt-of-2003)"
#~ msgstr ""
#~ "تخصیص `=` به جای مقایسه برابر بودن `==`: [The Linux Backdoor Attempt of "
#~ "2003](https://freedom-to-tinker.com/2013/10/09/the-linux-backdoor-attempt-"
#~ "of-2003)"

#~ msgid ""
#~ "Forgotten braces in multi-line `if`: [The Apple goto fail vulnerability]"
#~ "(https://dwheeler.com/essays/apple-goto-fail.html)"
#~ msgstr ""
#~ "فراموشی پرانتز در `if` چند خطی: [The Apple goto fail vulnerability]"
#~ "(https://dwheeler.com/essays/apple-goto-fail.html)"

#~ msgid ""
#~ "Forgotten `break` in a `switch` statement: [The break that broke sudo]"
#~ "(https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-hole-"
#~ "the-break-that-broke-sudo)"
#~ msgstr ""
#~ "فراموشی گذاشتن `break` در `switch`: <span dir=ltr>[The break that broke "
#~ "sudo](https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-"
#~ "hole-the-break-that-broke-sudo) <span>"

#~ msgid ""
#~ "_How is Rust any better here?_  \n"
#~ "Safe Rust makes all of these bugs impossible:"
#~ msgstr ""
#~ "_چطوری زبان راست در اینجا بهتر عمل می‌کند?_  \n"
#~ "راست ایمن تمام این باگ‌ها را غیرممکن می‌کند:"

#~ msgid "Assignments inside an `if` clause are not supported."
#~ msgstr "تخصیص‌ها در داخل یک شرط `if` پشتیبانی نمی‌شوند."

#~ msgid "Format strings are checked at compile-time."
#~ msgstr "قالب‌بندی رشته‌ها در زمان کامپایل بررسی می‌شوند."

#~ msgid "Resources are freed at the end of scope via the `Drop` trait."
#~ msgstr "منابع در پایان اسکوپ از طریق ویژگی `Drop` آزاد می‌شوند."

#~ msgid "All `if` clauses require braces."
#~ msgstr "همه شرط‌های `if` نیاز به پرانتز دارند."

#~ msgid ""
#~ "`match` (as the Rust equivalent to `switch`) does not fall-through, hence "
#~ "you can't accidentally forget a `break`."
#~ msgstr ""
#~ "دستور`match` (به عنوان معادل Rust برای `switch`) فرو نمی‌پاشد (منظور fall-"
#~ "through  پذیر بودن ان است) ، بنابراین نمی‌توانید به طور تصادفی یک break را "
#~ "فراموش کنید."

#~ msgid "Buffer slices carry their size and don't rely on a NUL terminator."
#~ msgstr ""
#~ "برش‌های بافر اندازه خود را حمل می‌کنند و به خاتمه دهنده `NUL` متکی نیستند."

#~ msgid ""
#~ "Heap-allocated memory is freed via the `Drop` trait when the "
#~ "corresponding `Box` leaves the scope."
#~ msgstr ""
#~ "حافظه اختصاص داده شده به پشته از طریق ویژگی `Drop` زمانی آزاد می‌شود که "
#~ "`Box` مورد نظر اسکوپ مربوطه را ترک کند.‍"

#~ msgid ""
#~ "Out-of-bounds accesses cause a panic or can be checked via the `get` "
#~ "method of a slice."
#~ msgstr ""
#~ "دسترسی‌های خارج از محدوده باعث پانیک می‌شوند یا می‌توان آنها را از طریق متد "
#~ "get یک برش (`slice`) بررسی کرد."

#~ msgid "`match` mandates that all cases are handled."
#~ msgstr "دستور `match` الزام می‌کند که حالات بررسی شوند."

#~ msgid ""
#~ "Fallible Rust functions return `Result` values that need to be unwrapped "
#~ "and thereby checked for success. Additionally, the compiler emits a "
#~ "warning if you miss to check the return value of a function marked with "
#~ "`#[must_use]`."
#~ msgstr ""
#~ "توابع خطا پذیر در زبان Rust مقدار Result را برمی‌گردانند که باید باز شوند "
#~ "و در نتیجه برای موفقیت بررسی شوند. علاوه بر این، اگر بررسی مقدار برگشتی "
#~ "تابعی که با <span dir=ltr>`#[must_use]`</span> علامت گذاری شده است را "
#~ "فراموش کنید، کامپایلر هشدار می‌دهد."

#~ msgid "Static memory management at compile time:"
#~ msgstr "مدیریت حافظه ایستا در زمان کامپایل:"

#~ msgid "No memory leaks (_mostly_, see notes)."
#~ msgstr ""
#~ "هیچ نشت حافظه‌ای وجود ندارد (_به طور کلی_، به یادداشت‌ها مراجعه کنید)."

#~ msgid ""
#~ "It is possible to produce memory leaks in (safe) Rust. Some examples are:"
#~ msgstr ""
#~ "ایجاد نشت حافظه در Rust (ایمن) امکان‌پذیر است. برخی از نمونه‌ها عبارتند از:"

#~ msgid ""
#~ "You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
#~ "html#method.leak) to leak a pointer. A use of this could be to get "
#~ "runtime-initialized and runtime-sized static variables"
#~ msgstr ""
#~ "می توانید از <span dir=ltr>[`Box::leak`](https://doc.rust-lang.org/std/"
#~ "boxed/struct.Box.html#method.leak)</span>  برای نشت دادن یک اشاره‌گر "
#~ "استفاده کنید.یک مورد استفاده از این کار می‌تواند برای بدست آوردن متغیرهای "
#~ "ایستا با مقداردهی اولیه و اندازه در زمان اجرا باشد."

#~ msgid ""
#~ "You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn."
#~ "forget.html) to make the compiler \"forget\" about a value (meaning the "
#~ "destructor is never run)."
#~ msgstr ""
#~ "می توانید از <span dir=ltr>[`std::mem::forget`](https://doc.rust-lang.org/"
#~ "std/mem/fn.forget.html)</span>  استفاده کنید تا کامپایلر «مقدار» را "
#~ "فراموش کند (به این معنا که تابع مخرب (`destructor`) هرگز اجرا نمی‌شود)."

#~ msgid ""
#~ "You can also accidentally create a [reference cycle](https://doc.rust-"
#~ "lang.org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
#~ msgstr ""
#~ "همچنین می‌توانید به طور تصادفی یک [چرخه ارجاع](https://doc.rust-lang.org/"
#~ "book/ch15-06-reference-cycles.html) با `Rc` یا `Arc` ایجاد کنید."

#~ msgid ""
#~ "In fact, some will consider infinitely populating a collection a memory "
#~ "leak and Rust does not protect from those."
#~ msgstr ""
#~ "در واقع، برخی از افراد پر کردن بی نهایت یک مجموعه را به عنوان نشت حافظه "
#~ "در نظر می‌گیرند و Rust از آن محافظت نمی‌کند."

#~ msgid ""
#~ "For the purpose of this course, \"No memory leaks\" should be understood "
#~ "as \"Pretty much no _accidental_ memory leaks\"."
#~ msgstr ""
#~ "برای این دوره، «هیچ نشت حافظه ای» باید به عنوان «تقریبا هیچ نشت حافظه "
#~ "_تصادفی_» درنظر گرفته شود."

#~ msgid ""
#~ "Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
#~ "lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
#~ "flag. If enabled, the program will panic (a controlled crash of the "
#~ "program), otherwise you get wrap-around semantics. By default, you get "
#~ "panics in debug mode (`cargo build`) and wrap-around in release mode "
#~ "(`cargo build --release`)."
#~ msgstr ""
#~ "سرریز عدد صحیح از طریق پرچم زمان کامپایل [`overflow-checks`](https://doc."
#~ "rust-lang.org/rustc/codegen-options/index.html#overflow-checks) تعریف شده "
#~ "است. اگر فعال باشد، برنامه خطا خواهد کرد (یک خرابی به صورت کنترل شده)، در "
#~ "غیر این صورت wrap-around خواهید داشت.به طور پیش فرض، در حالت توسعه `debug "
#~ "(cargo build)` شما خطا خواهید داشت. و در حالت گرفتن خروجی برای پروداکشن "
#~ "`release (cargo build --release)` حالت wrap-around خواهید داشت."

#~ msgid ""
#~ "Bounds checking cannot be disabled with a compiler flag. It can also not "
#~ "be disabled directly with the `unsafe` keyword. However, `unsafe` allows "
#~ "you to call functions such as `slice::get_unchecked` which does not do "
#~ "bounds checking."
#~ msgstr ""
#~ "بررسی محدوده نمی‌تواند با پرچم کامپایل غیرفعال شود. همچنین نمی‌توان آن را "
#~ "به طور مستقیم با کلمه کلیدی `unsafe` غیرفعال کرد. با این حال، `unsafe` به "
#~ "شما امکان می‌دهد توابعی مانند `slice::get_unchecked` را صدا بزنید که بررسی "
#~ "محدوده را انجام نمی‌دهد. "

#~ msgid "Rust is built with all the experience gained in the last decades."
#~ msgstr ""
#~ "زبان Rust با استفاده از تمام تجربیاتی که در دهه‌های گذشته به دست آمده "
#~ "ساخته شده است."

#~ msgid "Language Features"
#~ msgstr "ویژگی‌های زبان"

#~ msgid "Tooling"
#~ msgstr "ابزارها"

#~ msgid ""
#~ "Zero-cost abstractions, similar to C++, means that you don't have to "
#~ "'pay' for higher-level programming constructs with memory or CPU. For "
#~ "example, writing a loop using `for` should result in roughly the same low "
#~ "level instructions as using the `.iter().fold()` construct."
#~ msgstr ""
#~ "انتزاع‌های بدون هزینه، مشابه <span dir=ltr>C++</span>، به این معنی است که "
#~ "شما مجبور نیستید برای  ساختارهای برنامه‌نویسی سطح بالاتر با حافظه یا CPU "
#~ "«هزینه»‌ای پرداخت کنید. به عنوان مثال، نوشتن یک حلقه با استفاده از for "
#~ "باید تقریباً به همان دستورالعمل‌های سطح پایین به عنوان استفاده از ساختار "
#~ "<span dir=ltr>`iter().fold()`</span> منجر شود."

#~ msgid ""
#~ "It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
#~ "also known as 'sum types', which allow the type system to express things "
#~ "like `Option<T>` and `Result<T, E>`."
#~ msgstr ""
#~ "ارزش ذکر را دارد که Enum‌های زبان Rust  از «انواع داده جبری» هستند که "
#~ "همچنین به عنوان «انواع جمع» شناخته می‌شوند، که به تایپ‌ سیستم اجازه می‌دهد "
#~ "چیزهایی مانند  <span dir=ltr>`Option<T>`</span>  و <span "
#~ "dir=ltr>`Result<T, E>`</span> را بیان کند."

#~ msgid ""
#~ "Remind people to read the errors --- many developers have gotten used to "
#~ "ignore lengthy compiler output. The Rust compiler is significantly more "
#~ "talkative than other compilers. It will often provide you with "
#~ "_actionable_ feedback, ready to copy-paste into your code."
#~ msgstr ""
#~ "به افراد یادآوری کنید که خطاها را بخوانند --- بسیاری از توسعه دهندگان به "
#~ "نادیده گرفتن خروجی طولانی کامپایلر عادت کرده‌اند. کامپایلر Rust به طور "
#~ "قابل توجه‌ای پرحرف‌تر از سایر کامپایلرها است. اغلب بازخوردهای _عملیاتی_ را "
#~ "در اختیار شما قرار می‌دهد که آماده کپی و پیست کردن در کد شما هستند."

#~ msgid ""
#~ "The Rust standard library is small compared to languages like Java, "
#~ "Python, and Go. Rust does not come with several things you might consider "
#~ "standard and essential:"
#~ msgstr ""
#~ "کتابخانه استاندارد Rust در مقایسه با زبان‌هایی مانند Java، Python و Go "
#~ "کوچک است.  زبان Rust با چندین چیز که ممکن است آنها را استاندارد و ضروری "
#~ "در نظر بگیرید همراه نیست:"

#~ msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
#~ msgstr ""
#~ "یک تولید‌کننده عدد تصادفی، اما <span dir=ltr>[کتابخانه `rand`](https://"
#~ "docs.rs/rand/)</span> را ببینید."

#~ msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
#~ msgstr ""
#~ "پشتیبانی از SSL یا TLS، اما میتوانید <span dir=ltr>[کتابخانه `rusttls`]"
#~ "(https://docs.rs/rustls/)</span> را ببینید."

#~ msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
#~ msgstr ""
#~ "پشتیبانی از JSON، اما <span dir=ltr>[کتابخانه `serde_json`](https://docs."
#~ "rs/serde_json/)</span> را ببینید."

#~ msgid ""
#~ "The reasoning behind this is that functionality in the standard library "
#~ "cannot go away, so it has to be very stable. For the examples above, the "
#~ "Rust community is still working on finding the best solution --- and "
#~ "perhaps there isn't a single \"best solution\" for some of these things."
#~ msgstr ""
#~ "منطق پشت این امر این است که نمیتوان عملکردی را از کتابخانه استاندارد حذف "
#~ "کرد، بنابراین باید بسیار پایدار باشد. برای مثال‌های بالا، جامعه Rust هنوز "
#~ "در تلاش است تا بهترین راه حل را پیدا کند --- و شاید برای برخی از این "
#~ "موارد، یک «بهترین راه حل» وجود نداشته باشد. "

#~ msgid ""
#~ "Rust comes with a built-in package manager in the form of Cargo and this "
#~ "makes it trivial to download and compile third-party crates. A "
#~ "consequence of this is that the standard library can be smaller."
#~ msgstr ""
#~ "زبان Rust همراه با یک مدیر بسته درون-ساختی به اسم Cargo ارائه می شود و "
#~ "این امر  دانلود و کامپایل کردن crates شخص ثالث را بسیار آسان می کند. یکی "
#~ "از پیامدهای این امر این است که کتابخانه استاندارد می تواند کوچکتر باشد."

#~ msgid ""
#~ "Discovering good third-party crates can be a problem. Sites like <https://"
#~ "lib.rs/> help with this by letting you compare health metrics for crates "
#~ "to find a good and trusted one."
#~ msgstr ""
#~ "یافتن crates خوب شخص ثالث می تواند مشکل باشد. سایت‌هایی مانند <span "
#~ "dir=ltr><https://lib.rs/></span> با اجازه مقایسه معیارهای سلامت برای "
#~ "crates به شما کمک می‌کنند تا یک مورد خوب و قابل اعتماد را پیدا کنید."

#~ msgid ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
#~ "implementation used in major IDEs and text editors."
#~ msgstr ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/): یک پیاده  سازی LSP است "
#~ "که در IDE‌ها و ویرایشگرهای متن اصلی استفاده می‌شود."

#~ msgid "`\"foo\"`, `\"two\\nlines\"`"
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>\"foo\"</code>, <code class=hljs>\"two\n"
#~ "lines\"</code></span>"

#~ msgid "Like C++, Rust has references:"
#~ msgstr "مانند <span dir=ltr>C++</span>، راست دارای مراجع است:"

#~ msgid ""
#~ "We must dereference `ref_x` when assigning to it, similar to C and C++ "
#~ "pointers."
#~ msgstr ""
#~ "باید هنگام تعریف <span dir=ltr>`ref_x`</span> ارجاع دهی شود، مشابه "
#~ "اشاره‌گرهای C و <span dir=ltr>C++</span>."

#~ msgid ""
#~ "References that are declared as `mut` can be bound to different values "
#~ "over their lifetime."
#~ msgstr ""
#~ "مراجع‌ای که به‌عنوان `mut` تعریف می‌شوند، می‌توانند در طول عمر خود به مقادیر "
#~ "مختلفی ارجاع داده شوند."

#~ msgid "A reference is said to \"borrow\" the value it refers to."
#~ msgstr "گفته می‌شود که یک مرجع مقدار مورد اشاره خود را «قرض می‌گیرد»."

#~ msgid ""
#~ "Rust is tracking the lifetimes of all references to ensure they live long "
#~ "enough."
#~ msgstr ""
#~ "راست برای اینکه اطمینان حاصل کند طول‌عمر همه مراجع به اندازه کافی است, "
#~ "آنها را رهگیری می‌کند."

#~ msgid "`String` vs `str`"
#~ msgstr "<span dir=ltr>`String`</span> در مقابل <span dir=ltr>`str`</span> "

#~ msgid ""
#~ "You can borrow `&str` slices from `String` via `&` and optionally range "
#~ "selection."
#~ msgstr ""
#~ "شما می‌توانید برش‌های &str را از <span dir=ltr>`String`</span> از طریق `&` "
#~ "و انتخاب محدوده به صورت اختیاری، قرض بگیرید."

#~ msgid ""
#~ "A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
#~ "Fizz_buzz) interview question:"
#~ msgstr ""
#~ "یک نسخه راست از سوال مصاحبه معروف مصاحبه [FizzBuzz](https://en.wikipedia."
#~ "org/wiki/Fizz_buzz):"

#~ msgid ""
#~ "We refer in `main` to a function written below. Neither forward "
#~ "declarations nor headers are necessary. "
#~ msgstr ""
#~ "ما در <span dir=ltr>`main`</span> به یک تابعی که در زیرش نوشته شده است "
#~ "اشاره می‌کنیم.  نیازی به اعلان از قبل تابع <span dir=ltr>`main`</span> یا "
#~ "در بخش هدر نیست. "

#~ msgid ""
#~ "The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
#~ "`=n`, which causes it to include the upper bound."
#~ msgstr ""
#~ "عبارت تعیین محدوده در حلقه <span dir=ltr>`for`</span> در <span "
#~ "dir=ltr>`print_fizzbuzz_to()`</span> حاوی <span dir=ltr>`=n`</span> است "
#~ "که باعث می‌شود محدوده حد بالا را هم شامل شود (آخرین عنصر)."

#~ msgid ""
#~ "All language items in Rust can be documented using special `///` syntax."
#~ msgstr ""
#~ "همه موارد زبان در راست را می‌توان با استفاده از سینتکس ویژه `///` مستند "
#~ "کرد."

#~ msgid ""
#~ "This course does not include rustdoc on slides, just to save space, but "
#~ "in real code they should be present."
#~ msgstr ""
#~ "این دوره برای صرفه‌جویی در نوشتار متنی rustdoc را در اسلایدها قرار نمی‌دهد، "
#~ "اما در کدهای دنیای واقعی باید وجود داشته باشد."

#~ msgid ""
#~ "Inner doc comments are discussed later (in the page on modules) and need "
#~ "not be addressed here."
#~ msgstr ""
#~ "کامنت های داخل کد در بخش‌های بعدی (در صفحه مربوط به ماژول‌ها) مورد بحث قرار "
#~ "می‌گیرد و نیازی به پرداختن به آنها در اینجا نیست."

#~ msgid ""
#~ "Rustdoc comments can contain code snippets that we can run and test using "
#~ "`cargo test`. We will discuss these tests in the [Testing section](../"
#~ "testing/doc-tests.html)."
#~ msgstr ""
#~ "کامنت های rustdoc می‌توانند حاوی قطعه کدهایی باشند که می‌توانیم آنها را با "
#~ "استفاده از <span dir=ltr>`cargo test`</span> اجرا و تست کنیم.  ما در  "
#~ "[بخش تست نویسی](../testing/doc-tests.html)  در مورد این تست‌ها بحث خواهیم "
#~ "کرد."

#~ msgid ""
#~ "Methods are functions associated with a type. The `self` argument of a "
#~ "method is an instance of the type it is associated with:"
#~ msgstr ""
#~ "متدها، تابع‌هایی مربوط به یک نوع خاص هستند. آرگومان `self` یک متد، نمونه‌ای "
#~ "از نوعی است که با آن مرتبط است:"

#~ msgid ""
#~ "We will look much more at methods in today's exercise and in tomorrow's "
#~ "class."
#~ msgstr "در تمرین امروز و کلاس فردا بیشتر به متدها می‌پردازیم."

#~ msgid ""
#~ "Add a static method called `Rectangle::new` and call this from `main`:"
#~ msgstr ""
#~ "یک متد استاتیک به نام <span dir=ltr>`Rectangle::new`</span> اضافه کنید و "
#~ "آن را از `main` فراخوانی کنید:"

#~ msgid ""
#~ "While _technically_, Rust does not have custom constructors, static "
#~ "methods are commonly used to initialize structs (but don't have to). The "
#~ "actual constructor, `Rectangle { width, height }`, could be called "
#~ "directly. See the [Rustnomicon](https://doc.rust-lang.org/nomicon/"
#~ "constructors.html)."
#~ msgstr ""
#~ "در حالی که از _نظر فنی_  راست یک متد سازنده خاص ندارد، معمولاً  از متدهای "
#~ "استاتیک برای مقداردهی اولیه ساختارها استفاده می‌شود (اما الزامی نیست). "
#~ "سازنده اصلی ، <span dir=ltr>`Rectangle { width, height }`</span> ،  را "
#~ "می‌توان به طور مستقیم فراخوانی کرد. برای اطلاعات بیشتر [Rustnomicon]"
#~ "(https://doc.rust-lang.org/nomicon/constructors.html) را ببینید."

#~ msgid ""
#~ "Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
#~ "static methods can take arbitrary parameters."
#~ msgstr ""
#~ "برای نشان دادن اینکه چنین متدهای استاتیک می‌توانند آرگومان‌های دلخواه "
#~ "بگیرند،   با ارگمان‌های یک سازنده <span dir=ltr>`Rectangle::square(width: "
#~ "u32)`</span> اضافه کنید."

#~ msgid "Function Overloading"
#~ msgstr "سربارگذاری تابع (Function Overloading)"

#~ msgid "Overloading is not supported:"
#~ msgstr "سربارگذاری پشتیبانی نمیشود, چون:"

#~ msgid "Always takes a fixed number of parameters."
#~ msgstr "همیشه تعداد ثابتی از آرگومان‌ها می‌گیرد."

#~ msgid "Default values are not supported:"
#~ msgstr "مقادیر پیش‌فرض پشتیبانی نمی‌شوند:"

#~ msgid "All call sites have the same number of arguments."
#~ msgstr "تمام محل‌های فراخوانی دارای تعداد یکسانی از آرگومان هستند."

#~ msgid "Macros are sometimes used as an alternative."
#~ msgstr "گاهی اوقات از ماکروها به عنوان جایگزین استفاده می‌شود."

#~ msgid "However, function parameters can be generic:"
#~ msgstr "با این حال، پارامترهای تابع می‌توانند جنریک باشند:"

#~ msgid ""
#~ "When using generics, the standard library's `Into<T>` can provide a kind "
#~ "of limited polymorphism on argument types. We will see more details in a "
#~ "later section."
#~ msgstr ""
#~ "هنگام استفاده از جنریک‌ها، <span dir=ltr>`Into<T>`</span>  کتابخانه "
#~ "استاندارد می‌تواند نوعی چندشکلی (polymorphism) محدود در انواع آرگومان‌ها "
#~ "فراهم کند. جزئیات بیشتر را در بخش‌های بعدی خواهیم دید."

#~ msgid "Day 1: Morning Exercises"
#~ msgstr "روز اول: تمرین‌های صبح"

#~ msgid "In these exercises, we will explore two parts of Rust:"
#~ msgstr "در این تمرین‌ها، دو بخش از راست را بررسی خواهیم کرد:"

#~ msgid "Implicit conversions between types."
#~ msgstr "تبدیل‌های ضمنی بین انواع"

#~ msgid "Arrays and `for` loops."
#~ msgstr "آرایه‌ها و حلقه‌های `for`"

#~ msgid "A few things to consider while solving the exercises:"
#~ msgstr "چند نکته را هنگام حل تمرین‌ها درنظر بگیرید:"

#~ msgid ""
#~ "Use a local Rust installation, if possible. This way you can get auto-"
#~ "completion in your editor. See the page about [Using Cargo](../../cargo."
#~ "md) for details on installing Rust."
#~ msgstr ""
#~ "در صورت امکان، از نصب محلی راست استفاده کنید. از این طریق می‌توانید از "
#~ "تکمیل خودکار در ویرایشگر خود استفاده کنید.  برای جزئیات بیشتر در مورد نصب "
#~ "راست، صفحه مربوط به [استفاده از کارگو](../../cargo.md)  را ببینید."

#~ msgid "Alternatively, use the Rust Playground."
#~ msgstr "در غیر این صورت از `Rust Playground` استفاده کنید."

#~ msgid ""
#~ "The code snippets are not editable on purpose: the inline code snippets "
#~ "lose their state if you navigate away from the page."
#~ msgstr ""
#~ "قطعه کدها به صورت عمدی قابل ویرایش نیستند: قطعه کدهای درون‌خطی اگر از صفحه "
#~ "خارج شوید،  به حالت پیش‌فرض بازنشانی می‌شوند و تغییرات شما درنظر گرفته "
#~ "نمی‌شود."

#~ msgid ""
#~ "Rust will not automatically apply _implicit conversions_ between types "
#~ "([unlike C++](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion)). You can see this in a program like this:"
#~ msgstr ""
#~ "راست به طور خودکار تبدیل‌های صریح بین انواع را اعمال نمی‌کند ([برخلاف زبان "
#~ "<span dir=ltr>`C++`</span>](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion)).به عنوان مثال میتوانید این را در یک برنامه ببینید:"

#~ msgid ""
#~ "The Rust integer types all implement the [`From<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.Into.html) traits to let us convert between "
#~ "them. The `From<T>` trait has a single `from()` method and similarly, the "
#~ "`Into<T>` trait has a single `into()` method. Implementing these traits "
#~ "is how a type expresses that it can be converted into another type."
#~ msgstr ""
#~ "همه انواع عدد صحیح راست، تریت‌های (Trait) [<span dir=ltr>`Into<T>`</span>]"
#~ "(https://doc.rust-lang.org/std/convert/trait.Into.html) و [<span "
#~ "dir=ltr>`From<T>`</span>](https://doc.rust-lang.org/std/convert/trait."
#~ "From.html) را پیاده‌سازی می‌کنند تا به ما امکان تبدیل بین انواع عددی صحیح "
#~ "را بدهند. با پیاده سازی ویژگی <span dir=ltr>`From<T>`</span> همه انواع به "
#~ "صورت مشترک یک متد <span dir=ltr>`from()`</span> را دارند. با پیاده‌سازی "
#~ "تریت <span dir=ltr>`Into<T>`</span>  همه انواع یک متد مشترک به اسم <span "
#~ "dir=ltr>`into()`</span> را دارند. پیاده‌سازی این تریت‌ها راهی است که یک نوع "
#~ "بیان می‌کند که می‌تواند به نوع دیگری تبدیل شود."

#~ msgid ""
#~ "The standard library has an implementation of `From<i8> for i16`, which "
#~ "means that we can convert a variable `x` of type `i8` to an `i16` by "
#~ "calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> "
#~ "for i16` implementation automatically create an implementation of "
#~ "`Into<i16> for i8`."
#~ msgstr ""
#~ "کتابخانه استاندارد یک پیاده‌سازی <span dir=ltr>`From<i8> for i16`</span> "
#~ "دارد <span dir=ltr>`i16`</span> دارد، به این معنی که می‌توانیم یک متغیر "
#~ "`x` از نوع `i8` را با فراخوانی <span dir=ltr>`i16::from(x)`</span>  به یک "
#~ "<span dir=ltr>`i16`</span>  تبدیل کنیم.  یا به شیوه ساده‌تر، با <span "
#~ "dir=ltr>`x.into()`</span> ، زیرا پیاده‌سازی <span dir=ltr>`From<i8>`</"
#~ "span>  برای نوع <span dir=ltr>`i16`</span>  به طور خودکار پیاده‌سازی<span "
#~ "dir=ltr>`Into<i16>`</span>  برای نوع `i8` را ایجاد می‌کند."

#~ msgid ""
#~ "The same applies for your own `From` implementations for your own types, "
#~ "so it is sufficient to only implement `From` to get a respective `Into` "
#~ "implementation automatically."
#~ msgstr ""
#~ "همین امر برای پیاده‌سازی‌های <span dir=ltr>`From`</span> خودتان برای انواع "
#~ "خودتان نیز صدق می‌کند،  بنابراین کافیست فقط <span dir=ltr>`From`</span> را "
#~ "پیاده‌سازی کنید تا به طور خودکار پیاده‌سازی <span dir=ltr>`Into`</span> "
#~ "مربوطه را دریافت کنید."

#~ msgid "Execute the above program and look at the compiler error."
#~ msgstr "برنامه فوق را اجرا و به خطای کامپایلر نگاه کنید."

#~ msgid "Update the code above to use `into()` to do the conversion."
#~ msgstr ""
#~ "کد بالا را به گونه‌ای به‌روزرسانی کنید که از <span dir=ltr>`into()`</span> "
#~ "برای انجام تبدیل استفاده شود."

#~ msgid ""
#~ "Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
#~ "`i128`) to see which types you can convert to which other types. Try "
#~ "converting small types to big types and the other way around. Check the "
#~ "[standard library documentation](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html) to see if `From<T>` is implemented for the pairs you "
#~ "check."
#~ msgstr ""
#~ "نوع داده  `x` و `y` را به چیزهای دیگری (مانند `f32`, `bool`, `i128`) "
#~ "تغییر دهید تا ببینید کدام انواع را می‌توانید به کدام انواع دیگر تبدیل "
#~ "کنید.  سعی کنید انواع کوچک را به انواع بزرگ تبدیل کنید و برعکس. [مستندات "
#~ "کتابخانه استاندارد](https://doc.rust-lang.org/std/convert/trait.From."
#~ "html) را بررسی کنید  تا ببینید آیا <span dir=ltr>`From<T>`</span> برای "
#~ "تبدیل انواع‌ایی که بررسی می‌کنید پیاده‌سازی شده است یا نه."

#~ msgid "Arrays and `for` Loops"
#~ msgstr "آرایه‌ها و حلقه‌های `for`"

#~ msgid "We saw that an array can be declared like this:"
#~ msgstr "دیدیم که یک آرایه را می‌توان به صورت زیر تعریف کرد: "

#~ msgid ""
#~ "You can print such an array by asking for its debug representation with "
#~ "`{:?}`:"
#~ msgstr ""
#~ "می‌توانید چنین آرایه‌ای را با درخواست نمایش اشکال‌زدایی آن با <span "
#~ "dir=ltr>`{:?}`</span> چاپ کنید:"

#~ msgid ""
#~ "Rust lets you iterate over things like arrays and ranges using the `for` "
#~ "keyword:"
#~ msgstr ""
#~ "راست به شما این امکان را می‌دهد تا با استفاده از کلمه کلیدی `for` بر روی "
#~ "چیزهایی مانند آرایه‌ها و رنج‌ها پیمایش کنید:"

#~ msgid "Bonus Question"
#~ msgstr "سوال جایزه‌دار"

#~ msgid ""
#~ "Could you use `&[i32]` slices instead of hard-coded 3 × 3 matrices for "
#~ "your argument and return types? Something like `&[&[i32]]` for a two-"
#~ "dimensional slice-of-slices. Why or why not?"
#~ msgstr ""
#~ "آیا می‌توانید به جای ماتریس‌های 3 × 3 هاردکد شده از برش‌های <span "
#~ "dir=ltr>`&[i32]`</span>  برای آرگومان و انواع برگشتی تابع خود استفاده "
#~ "کنید؟ چیزی شبیه <span dir=ltr>`&[&[i32]]`</span> برای برش-از-برش دو بعدی. "
#~ "آیا امکان پذیر هست؟ چرا اره و چرا نه؟"

#~ msgid ""
#~ "See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
#~ "quality implementation."
#~ msgstr ""
#~ "برای دیدن یک پیاده‌سازی با کیفیت پروداکشن به جعبه [<span "
#~ "dir=ltr>`ndarray`</span>](https://docs.rs/ndarray/) سر بزنید."

#~ msgid ""
#~ "The solution and the answer to the bonus section are available in the  "
#~ "[Solution](solutions-morning.md#arrays-and-for-loops) section."
#~ msgstr ""
#~ "راه‌حل‌ها و پاسخ به بخش جایزه در بخش جواب‌ها](solutions-morning.md#arrays-"
#~ "and-for-loops) موجود است."

#~ msgid ""
#~ "The use of the reference `&array` within `for n in &array` is a subtle "
#~ "preview of issues of ownership that will come later in the afternoon."
#~ msgstr ""
#~ "استفاده از ارجاع <span dir=ltr>`&array`</span>  در بخش <span dir=ltr>`for "
#~ "n in &array`</span>  پیش‌نمایشی کوچکی از مسئله مالکیت است در قسمت عصر که "
#~ "بعداً   به ان خواهیم پرداخت."

#~ msgid "Without the `&`..."
#~ msgstr "بدون استفاده از `&` ..."

#~ msgid ""
#~ "The loop would have been one that consumes the array.  This is a change "
#~ "[introduced in the 2021 Edition](https://doc.rust-lang.org/edition-guide/"
#~ "rust-2021/IntoIterator-for-arrays.html)."
#~ msgstr ""
#~ "حلقه به گونه‌ای می‌بود که آرایه را مصرف می‌کند. این تغییری [در ویرایش سال "
#~ "۲۰۲۱ معرفی شده است.](https://doc.rust-lang.org/edition-guide/rust-2021/"
#~ "IntoIterator-for-arrays.html)"

#~ msgid ""
#~ "An implicit array copy would have occurred.  Since `i32` is a copy type, "
#~ "then `[i32; 3]` is also a copy type."
#~ msgstr ""
#~ "یک کپی آرایه ضمنی رخ می‌داد. از آنجایی که `i32` یک نوع کپی است، پس <span "
#~ "dir=ltr>`[i32; 3]`</span>  نیز یک نوع کپی است."

#~ msgid ""
#~ "As we have seen, `if` is an expression in Rust. It is used to "
#~ "conditionally evaluate one of two blocks, but the blocks can have a value "
#~ "which then becomes the value of the `if` expression. Other control flow "
#~ "expressions work similarly in Rust."
#~ msgstr ""
#~ "همانطور که دیدیم، `if` در Rust یک عبارت است.  عبارت `if` برای آن استفاده "
#~ "می‌شود که یکی از ۲ بلوک شرطی را در راست ایجاد کند. توجه داشته باشید که در "
#~ "راست این بلاک  های `if`  میتوانند یک مقدار را برگرداند و در اصطلاح یک "
#~ "مقدار داشته باشند. بقیه عبارات کنترل جریان نیز مشابه این کار میکنند."

#~ msgid ""
#~ "The same rule is used for functions: the value of the function body is "
#~ "the return value:"
#~ msgstr ""
#~ "قانون مشابه‌ای برای توابع نیز صدق می‌کند:  آخرین مقدار  در بلاک تابع مقدار "
#~ "برگشتی است: "

#~ msgid ""
#~ "The point of this slide is to show that blocks have a type and value in "
#~ "Rust. "
#~ msgstr ""
#~ "هدف از این اسلاید نشان دادن این است که بلوک ها در Rust دارای نوع و مقدار "
#~ "هستند. "

#~ msgid ""
#~ "The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is "
#~ "closely related to the [`while let` loop](while-let-expressions.md). It "
#~ "will automatically call `into_iter()` on the expression and then iterate "
#~ "over it:"
#~ msgstr ""
#~ "[حلقه `for`](https://doc.rust-lang.org/std/keyword.for.html)  به طور "
#~ "نزدیکی به حلقه [حلقه `while let` ](while-let-expressions.md) مرتبط است. "
#~ "حلقه `for` به طور خودکار  <span dir=ltr>`into_iter()`</span> را روی "
#~ "عبارت  فراخوانی می‌کند و سپس روی آن پیشمایش انجام می‌دهد:"

#~ msgid "You can use `break` and `continue` here as usual."
#~ msgstr ""
#~ "مثل بقیه زبان‌ها می‌توانید از `break` و `continue` به صورت عادی استفاده "
#~ "کنید."

#~ msgid "Index iteration is not a special syntax in Rust for just that case."
#~ msgstr "پیشمایش اندیس در زبان راست دارای سینتکس خاصی نمی‌باشد."

#~ msgid "`(0..10)` is a range that implements an `Iterator` trait. "
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>(0..10)</code></span>  یک محدوده است که "
#~ "ویژگی `Iterator` را پیاده‌سازی می‌کند."

#~ msgid ""
#~ "`step_by` is a method that returns another `Iterator` that skips every "
#~ "other element. "
#~ msgstr ""
#~ "متد `step_by`,  متدی است که یک `Iterator` دیگر با قابلیت در نظر نگرفتن "
#~ "بقیه عناصر را برمی‌گرداند."

#~ msgid ""
#~ "Modify the elements in the vector and explain the compiler errors. Change "
#~ "vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
#~ msgstr ""
#~ "عناصر را در بردار تغییر دهید و خطاهای کامپایلر را توضیح دهید. بردار v را "
#~ "قابل تغییر کنید (با اضافه کردن `mut`) و حلقه  `for` را به <span "
#~ "dir=ltr>`for x in v.iter_mut()`</span> تغییر دهید."

#~ msgid "`loop` expressions"
#~ msgstr "عبارات `loop`"

#~ msgid ""
#~ "Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
#~ "expressions/loop-expr.html#infinite-loops) which creates an endless loop."
#~ msgstr ""
#~ "در نهایت، [کلمه کلیدی `loop`](https://doc.rust-lang.org/reference/"
#~ "expressions/loop-expr.html#infinite-loops) وجود دارد که یک حلقه بی‌پایان "
#~ "ایجاد می‌کند."

#~ msgid "Here you must either `break` or `return` to stop the loop:"
#~ msgstr ""
#~ "اینجا باید از `break` یا `return` برای توقف حلقه و خروج از آن استفاده "
#~ "کنید:"

#~ msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
#~ msgstr ""
#~ "حلقه `loop` را با یک مقدار متوقف کنید (به عنوان مثال <span dir=ltr>`break "
#~ "8`</span> ) و آن را چاپ کنید."

#~ msgid ""
#~ "Due to type inference the `i32` is optional. We will gradually show the "
#~ "types less and less as the course progresses."
#~ msgstr ""
#~ "به دلیل تعیین نوع ضمنی گذاشتن `i32` اختیاریست. با جلو  رفتن در این دوره "
#~ "کمتر و کمتر آن را نشان خواهیم داد."

#~ msgid ""
#~ "The following code tells the compiler to copy into a certain generic "
#~ "container without the code ever explicitly specifying the contained type, "
#~ "using `_` as a placeholder:"
#~ msgstr ""
#~ "کد زیر به کامپایلر می‌گوید که بدون اینکه کد به صراحت نوع داده را مشخص کند، "
#~ "در یک کانتینر عمومی (generic container)  خاص کپی کند، با استفاده از _ به "
#~ "عنوان یک جایگزین برای اعلام نوع داده: "

#~ msgid ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
#~ "std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-"
#~ "lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
#~ "HashSet%3CT,+S%3E) implements."
#~ msgstr ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect) به [`FromIterator`](https://doc.rust-lang.org/std/"
#~ "iter/trait.FromIterator.html) متکی است که [`HashSet`](https://doc.rust-"
#~ "lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
#~ "HashSet%3CT,+S%3E) آن را پیاده‌سازی می‌کند."

#~ msgid "Static and Constant Variables"
#~ msgstr "متغیر‌های ایستا و ثابت"

#~ msgid ""
#~ "The following code demonstrates why the compiler can't simply reuse "
#~ "memory locations when shadowing an immutable variable in a scope, even if "
#~ "the type does not change."
#~ msgstr ""
#~ "کد زیر نشان می دهد که چرا کامپایلر نمی تواند به سادگی از مکان های حافظه "
#~ "که قبلا برای یک متغییر در نظر گرفته است به صورت مجدد وقتی که یک متغییر "
#~ "غیر قابل تغییر داریم استفاده کند. حتی اگر چه نوع داده تغییر نکند."

#~ msgid ""
#~ "This page offers an enum type `CoinFlip` with two variants `Heads` and "
#~ "`Tails`. You might note the namespace when using variants."
#~ msgstr ""
#~ "در این صفحه نوع`Enum`به اسم `CoinFlip` که دارای `Heads` و `Tails` می‌باشد. "
#~ "هنگام استفاده از `Enum`ها، به این اینگونه نام‌ها توجه کنید."

#~ msgid "In both, associated functions are defined within an `impl` block."
#~ msgstr "در هر دو، توابع مورد نیازشون در داخل یک بلاک `impl` تعریف می‌شوند."

#~ msgid ""
#~ "You can define richer enums where the variants carry data. You can then "
#~ "use the `match` statement to extract the data from each variant:"
#~ msgstr ""
#~ "می توانید شمارش های غنی تری را تعریف کنید که در آن انواع مختلف داده "
#~ "باشند. سپس می‌توانید از دستور `match` برای استخراج داده‌ها از هر فیلد "
#~ "استفاده کنید:"

#~ msgid ""
#~ "The expression is matched against the patterns from top to bottom. There "
#~ "is no fall-through like in C or C++."
#~ msgstr ""
#~ "بر خلاف زبان‌های برخلاف C یا <span dir=ltr>`C++`</span> طبیق الگو به صورت "
#~ "از بالا به پایین نمی‌باشد."

#~ msgid ""
#~ "The match expression has a value. The value is the last expression in the "
#~ "match arm which was executed."
#~ msgstr ""
#~ "عبارت `match` دارای یک مقدار بازگشتی است. این مقدار آخرین عبارت در بازوی "
#~ "`match` ای است که اجرا شده است."

#~ msgid ""
#~ "Starting from the top we look for what pattern matches the value then run "
#~ "the code following the arrow. Once we find a match, we stop. "
#~ msgstr ""
#~ "از بالا شروع می‌کنیم و به دنبال الگویی هستیم که با مقدار مطابقت داشته "
#~ "باشد، سپس کد پس از <span dir=ltr>`=>`</span> را اجرا می‌کنیم. بعد از اینکه "
#~ "توی match اولین طبیق الگو انجام شد جستجو متوقف میشود."

#~ msgid "`match` inspects a hidden discriminant field in the `enum`."
#~ msgstr ""
#~ "دستور `match` یک فیلد تشخیصی پنهان (hidden discriminant field) در `enum` "
#~ "را بررسی می کند."

#~ msgid ""
#~ "It is possible to retrieve the discriminant by calling `std::mem::"
#~ "discriminant()`"
#~ msgstr ""
#~ "می توان با فراخوانی <span dir=ltr>`std::mem::discriminant()`</span> فیلد "
#~ "تشخیصی پنهان  را دریافت کرد."

#~ msgid ""
#~ "This is useful, for example, if implementing `PartialEq` for structs "
#~ "where comparing field values doesn't affect equality."
#~ msgstr ""
#~ "بهتره بدانیم که اگر `PartialEq` را برای ساختارهایی پیاده سازی کنیم. "
#~ "قابلیت  `PartialEq`  بر برابری تأثیر نمی‌گذارد."

#~ msgid ""
#~ "`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
#~ "Click(Click)` with a top level `struct Click { ... }`. The inlined "
#~ "version cannot implement traits, for example."
#~ msgstr ""
#~ "<span dir=ltr>`WebEvent::Click { ... }`</span> دقیقاً مانند <span "
#~ "dir=ltr>`WebEvent::Click(Click)`</span> با <span dir=ltr>`struct Click "
#~ "{ ... }`</span> در سطح بالا نیست.برای مثال, نسخه درون‌خطی نمی‌تواند ویژگی‌ها "
#~ "را پیاده‌سازی کند."

#~ msgid ""
#~ "Rust enums are packed tightly, taking constraints due to alignment into "
#~ "account:"
#~ msgstr ""
#~ "`enum`ها در Rust به صورت فشرده بسته بندی شده اند، با در نظر گرفتن محدودیت "
#~ "های ناشی از هم ترازی:"

#~ msgid ""
#~ "Internally Rust is using a field (discriminant) to keep track of the enum "
#~ "variant."
#~ msgstr ""
#~ "زبان Rust, به صورت داخلی از یک فیلد (discriminant) برای رهگیری نوع "
#~ "فیلدهای `enum` استفاده می کند."

#~ msgid "Try out other types such as"
#~ msgstr "سایر انواع‌داده را امتحان کنید، مانند:"

#~ msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>dbg_size!(bool)</code></span>: اندازه توی "
#~ "حافظه 1 بایت، فضای مورد نیاز برای align نیز  1 بایت است,"

#~ msgid ""
#~ "`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche "
#~ "optimization, see below),"
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>dbg_size!(Option<bool>)</code></span>:  "
#~ "اندازه توی حافظه 1 بایت، ، فضای مورد نیاز برای align نیز  1 بایت است "
#~ "(بهینه‌سازی خاص، در زیر ببینید)"

#~ msgid ""
#~ "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>dbg_size!(&i32)</code></span>: اندازه توی "
#~ "حافظه ۸ بایت، ، فضای مورد نیاز برای align نیز  ۸ بایت است (روی ماشین ۶۴ "
#~ "بیتی)"

#~ msgid ""
#~ "`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
#~ "optimization, see below)."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>dbg_size!(Option<&i32>)</code></span>: "
#~ "اندازه توی حافظه ۸ بایت، ، فضای مورد نیاز برای align نیز  ۸ بایت است "
#~ "(بهینه‌سازی اشاره‌گر NULL را در زیر ببینید)"

#~ msgid ""
#~ "Niche optimization: Rust will merge unused bit patterns for the enum "
#~ "discriminant."
#~ msgstr ""
#~ "بهینه‌سازی خاص: Rust الگوهای بیتی استفاده نشده را برای discriminant نوع "
#~ "`Enum` ادغام می‌کند."

#~ msgid ""
#~ "More complex example if you want to discuss what happens when we chain "
#~ "more than 256 `Option`s together."
#~ msgstr ""
#~ "مثال پیچیده‌تر اگر می‌خواهید در مورد اتفاقی که می‌افتد زمانی که بیش از ۲۶۵ "
#~ "عدد `Option` را به صورت تو در تو صدا بزنیم بحث کنید."

#~ msgid ""
#~ "Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-"
#~ "example/flow_control/let_else.html) construct allows to do a "
#~ "destructuring assignment, or if it fails, execute a block which is "
#~ "required to abort normal control flow (with `panic`/`return`/`break`/"
#~ "`continue`):"
#~ msgstr ""
#~ "از نسخه 1.65، یک کلیدواژه مشابه به اسم  [`let-else`](https://doc.rust-"
#~ "lang.org/rust-by-example/flow_control/let_else.html) اجازه می‌دهد تا یک "
#~ "انتساب به صورت destructuring انجام شود، یا اگر شکست خورد، یک بلوک را اجرا "
#~ "کند که برای خاتمه دادن به جریان کنترل عادی (با panic/return/break/"
#~ "continue) ضروری است:"

#~ msgid ""
#~ "The [`match` keyword](https://doc.rust-lang.org/reference/expressions/"
#~ "match-expr.html) is used to match a value against one or more patterns. "
#~ "In that sense, it works like a series of `if let` expressions:"
#~ msgstr ""
#~ "[کلمه‌کلیدی `match`](https://doc.rust-lang.org/reference/expressions/match-"
#~ "expr.html) برای مطابقت یک مقدار در برابر یک یا چند الگو استفاده می‌شود. از "
#~ "این نظر، مانند یک سری عبارات `if let` عمل می‌کند:"

#~ msgid "Save the match expression to a variable and print it out."
#~ msgstr ""
#~ "مقادر بازگشتی از دستور `match` را در متغییری ذخیره کنید و آن را چاپ کنید."

#~ msgid "Remove `.as_deref()` and explain the error."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>.as_deref()</code></span> را حذف کنید و "
#~ "خطا را توضیح دهید."

#~ msgid ""
#~ "`std::env::args().next()` returns an `Option<String>`, but we cannot "
#~ "match against `String`."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>std::env::args().next()</code></span> یک "
#~ "<span dir=ltr>`Option<String>`</span>  را برمی‌گرداند،چرا نمی توانیم به "
#~ "عنوان `String` تطبیق الگو کنیم؟"

#~ msgid ""
#~ "`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our "
#~ "case, this turns `Option<String>` into `Option<&str>`."
#~ msgstr ""
#~ "<span dir=ltr><code class=hljs>as_deref()</code></span>  یک <span "
#~ "dir=ltr>`Option<T>`</span> را به <span dir=ltr>`Option<&T::Target>`</"
#~ "span>  تبدیل می‌کند. در مورد ما، این <span dir=ltr>`Option<String>`</span> "
#~ "را به <span dir=ltr>`Option<&str>`</span> تبدیل می‌کند."

#~ msgid ""
#~ "We can now use pattern matching to match against the `&str` inside "
#~ "`Option`."
#~ msgstr ""
#~ "اکنون می‌توانیم از تطبیق الگو برای مطابقت با <span dir=ltr>`&str`</span> "
#~ "داخل `Option` استفاده کنیم."

#~ msgid "The `_` pattern is a wildcard pattern which matches any value."
#~ msgstr ""
#~ "الگوی _ یک الگوی wildcard (هر حالتی) است که با هر مقداری مطابقت دارد."

#~ msgid ""
#~ "It can be useful to show how binding works, by for instance replacing a "
#~ "wildcard character with a variable, or removing the quotes around `q`."
#~ msgstr ""
#~ "می‌توان با جایگزینی یک کاراکتر`_` با یک متغیر، یا حذف نقل قول ها در اطراف "
#~ "`q`، به نمایش نحوه کارکرد انتساب کمک کرد."

#~ msgid "You can demonstrate matching on a reference."
#~ msgstr "می‌توانید تطبیق الگو را با یک ارجاع را نشان دهید."

#~ msgid ""
#~ "This might be a good time to bring up the concept of irrefutable "
#~ "patterns, as the term can show up in error messages."
#~ msgstr ""
#~ "این ممکن است زمان خوبی برای مطرح کردن مفهوم الگوهای غیرقابل انکار "
#~ "(irrefutable patterns) باشد، زیرا این اصطلاح می تواند در پیام های خطا "
#~ "ظاهر شود."

#~ msgid "You can also destructure `structs`:"
#~ msgstr "همچنین می‌توانید `structs` را destructure کنید:"

#~ msgid ""
#~ "Destructuring of slices of unknown length also works with patterns of "
#~ "fixed length."
#~ msgstr ""
#~ "برای destructure کردن برش هایی با طول ناشناخته نیز با الگوهای طول ثابت "
#~ "کار می کند."

#~ msgid ""
#~ "When matching, you can add a _guard_ to a pattern. This is an arbitrary "
#~ "Boolean expression which will be executed if the pattern matches:"
#~ msgstr ""
#~ "هنگام تطابق، می توانید یک _guard_ به یک الگو اضافه کنید. این یک عبارت "
#~ "بولین دلخواه است که در صورت مطابقت الگو اجرا می شود."

#~ msgid ""
#~ "You can use the variables defined in the pattern in your if expression."
#~ msgstr ""
#~ "می توانید از متغیرهای تعریف شده در الگو در عبارت `if` خود استفاده کنید."

#~ msgid "Day 1: Afternoon Exercises"
#~ msgstr "روز ۱: تمرین‌های عصر"

#~ msgid "We will look at two things:"
#~ msgstr "ما روی ۲ تا چیز نگاهی می‌اندازیم:"

#~ msgid "The Luhn algorithm,"
#~ msgstr "الگوریتم  Luhn"

#~ msgid "An exercise on pattern matching."
#~ msgstr "تمرینی درباره تطبیق الگو"

#~ msgid ""
#~ "Try to solve the problem the \"simple\" way first, using `for` loops and "
#~ "integers. Then, revisit the solution and try to implement it with "
#~ "iterators."
#~ msgstr ""
#~ "ابتدا سعی کنید مشکل را به روش «ساده» با استفاده از حلقه‌های `for` و اعداد "
#~ "صحیح حل کنید. سپس،  سعی کنید آن را با استفاده از `iterator`ها پیاده‌سازی "
#~ "کنید."

#~ msgid ""
#~ "Memory management: stack vs heap, manual memory management, scope-based "
#~ "memory management, and garbage collection."
#~ msgstr ""
#~ "مدیریت حافظه: پشته (Stack) در مقابل انباشت (Heap)، مدیریت دستی حافظه، "
#~ "مدیریت حافظه مبتنی بر اسکوپ و جمع آوری زباله. "

#~ msgid ""
#~ "Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
#~ msgstr ""
#~ "Ownership: حرکت semantics،copying و cloning, borrowing  و lifetimes."

#~ msgid "Structs and methods."
#~ msgstr "ساختارها و متدها."

#~ msgid ""
#~ "The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
#~ "`Rc` and `Arc`."
#~ msgstr ""
#~ "کتابخانه استاندارد:  `String`, `Option` و `Result`, `Vec`, `HashMap`, "
#~ "`Rc` و `Arc`."

#~ msgid "Modules: visibility, paths, and filesystem hierarchy."
#~ msgstr "ماژول‌ها: قابل دیدن بودن, مسیرها و مدیریت سلسله مراتبی فایل‌سیستم"

#~ msgid "First, let's refresh how memory management works."
#~ msgstr ""
#~ "قبل از هر چیزی, آنچه درباره مدیریت حافظه میدونیم رو بروز رسانی کنیم."

#~ msgid "The Stack vs The Heap"
#~ msgstr "پشته (Stack) در مقابل انباشت (Heap)"

#~ msgid "Stack and Heap Example"
#~ msgstr "یک مثال از پشته و انباشت"

#~ msgid "You allocate and deallocate heap memory yourself."
#~ msgstr "شما خودتان حافظه انباشت را تخصیص داده و تخصیص‌زدایی می‌کنید."

#~ msgid ""
#~ "If not done with care, this can lead to crashes, bugs, security "
#~ "vulnerabilities, and memory leaks."
#~ msgstr ""
#~ "اگر با دقت انجام نشود، این می تواند منجر به خرابی، اشکال، آسیب‌پذیری‌های "
#~ "امنیتی و نشتی حافظه شود."

#~ msgid "C Example"
#~ msgstr "مثالی در زبان C"

#~ msgid "You must call `free` on every pointer you allocate with `malloc`:"
#~ msgstr ""
#~ "باید `free` را برای هر اشاره‌گری که با `malloc` تخصیص می‌دهید، فراخوانی "
#~ "کنید:"

#~ msgid ""
#~ "Memory is leaked if the function returns early between `malloc` and "
#~ "`free`: the pointer is lost and we cannot deallocate the memory. Worse, "
#~ "freeing the pointer twice, or accessing a freed pointer can lead to "
#~ "exploitable security vulnerabilities."
#~ msgstr ""
#~ "اگر تابع بین `malloc` و `free` مقداری را بازگرداند و از تابع خارج شویم، "
#~ "حافظه نشت می‌کند: اشاره گر گم می‌شود و نمی‌توانیم حافظه را تخصیص‌زدایی کنیم. "
#~ "بدتر از آن، آزاد کردن مجدد اشاره گر یا دسترسی به یک اشاره گر که قبلا آزاد "
#~ "شده می‌تواند منجر به آسیب‌پذیری‌های امنیتی قابل سوءاستفاده شود."

#~ msgid ""
#~ "Constructors and destructors let you hook into the lifetime of an object."
#~ msgstr ""
#~ "سازنده‌ها و مخرب‌ها به شما امکان می‌دهند تا به طول‌عمر یک شیء متصل (hook) "
#~ "شوید."

#~ msgid ""
#~ "By wrapping a pointer in an object, you can free memory when the object "
#~ "is destroyed. The compiler guarantees that this happens, even if an "
#~ "exception is raised."
#~ msgstr ""
#~ "با پیچیدن (wrapping) یک اشاره گر در یک شیء، می‌توانید هنگام تخریب شیء، "
#~ "حافظه را آزاد کنید. کامپایلر تضمین می‌کند که این اتفاق می‌افتد، حتی اگر یک "
#~ "exception ایجاد شود."

#~ msgid ""
#~ "This is often called _resource acquisition is initialization_ (RAII) and "
#~ "gives you smart pointers."
#~ msgstr ""
#~ "این اغلب به عنوان _resource acquisition is initialization_  (RAII) نامیده "
#~ "می‌شود و به شما اشاره گرهای هوشمند می‌دهد."

#~ msgid ""
#~ "The `std::unique_ptr` object is allocated on the stack, and points to "
#~ "memory allocated on the heap."
#~ msgstr ""
#~ "ابجکت <span dir=ltr>`std::unique_ptr`</span> در پشته تخصیص داده می‌شود و "
#~ "به حافظه‌ای که روی انباشت تخصیص داده شده اشاره می‌کند."

#~ msgid ""
#~ "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
#~ msgstr ""
#~ "در پایان `say_hello`، تابع مخرب <span dir=ltr>`std::unique_ptr`</span> "
#~ "اجرا می‌شود."

#~ msgid "The destructor frees the `Person` object it points to."
#~ msgstr "مخرب شیء `Person` را که به آن اشاره می‌کند، آزاد می‌کند."

#~ msgid ""
#~ "Special move constructors are used when passing ownership to a function:"
#~ msgstr ""
#~ "هنگام انتقال مالکیت به یک تابع از سازنده‌های مخصوص انتقال استفاده می‌شود:"

#~ msgid ""
#~ "An alternative to manual and scope-based memory management is automatic "
#~ "memory management:"
#~ msgstr ""
#~ "یک جایگزین برای مدیریت حافظه دستی و مبتنی بر اسکوپ، مدیریت حافظه خودکار "
#~ "است:"

#~ msgid "The programmer never allocates or deallocates memory explicitly."
#~ msgstr "برنامه نویس هیچ وقت به صورت صریح حافظه را تخصیص یا آزاد نمیکند."

#~ msgid ""
#~ "A garbage collector finds unused memory and deallocates it for the "
#~ "programmer."
#~ msgstr ""
#~ "یک جمع‌آوری زباله حافظه استفاده نشده را پیدا می‌کند و آن را برای برنامه‌نویس "
#~ "تخصیص‌زدایی (آزاد) می‌کند."

#~ msgid "Java Example"
#~ msgstr "مثالی در Java"

#~ msgid "The `person` object is not deallocated after `sayHello` returns:"
#~ msgstr "شیء `person` پس از بازگشت `sayHello` تخصیص‌زدایی نمی‌شود:"

#~ msgid "Memory Management in Rust"
#~ msgstr "مدیریت حافظه در Rust"

#~ msgid "Memory management in Rust is a mix:"
#~ msgstr "مدیریت حافظه در Rust ترکیبی از موارد زیر است:"

#~ msgid "Safe and correct like Java, but without a garbage collector."
#~ msgstr "ایمن و صحیح مانند جاوا، اما بدون جمع‌آوری زباله."

#~ msgid "Scope-based like C++, but the compiler enforces full adherence."
#~ msgstr ""
#~ "مبتنی بر اسکوپ مانند <span dir=ltr>C++</span>، اما کامپایلر همه موارد را "
#~ "رعایت می‌کند."

#~ msgid ""
#~ "A Rust user can choose the right abstraction for the situation, some even "
#~ "have no cost at runtime like C."
#~ msgstr ""
#~ "کاربر Rust می‌تواند انتخاب کند که کدام انتزاع برای وضعیت مورد نظر مناسب "
#~ "است، برخی مانند C  هزینه‌ای در زمان اجرا ندارند."

#~ msgid "Rust achieves this by modeling _ownership_ explicitly."
#~ msgstr "زبان Rust این کار را با مدل‌سازی صریح مالکیت انجام می‌دهد."

#~ msgid ""
#~ "If asked how at this point, you can mention that in Rust this is usually "
#~ "handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
#~ "boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct."
#~ "Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
#~ "(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
#~ "ownership and memory allocation via various means, and prevent the "
#~ "potential errors in C."
#~ msgstr ""
#~ "اگر توی این مرحله از شما پرسیده شد که چطوری این کار انجام می‌شود, میتوانید "
#~ "به این موضوع که زبان راست معمولاً توسط انواع `wrapper RAII` مانند [`Box`]"
#~ "(https://doc.rust-lang.org/std/boxed/struct.Box.html), [`Vec`](https://"
#~ "doc.rust-lang.org/std/vec/struct.Vec.html), [`Rc`](https://doc.rust-lang."
#~ "org/std/rc/struct.Rc.html), یا [`Arc`](https://doc.rust-lang.org/std/sync/"
#~ "struct.Arc.html) مدیریت را انجام میدهد. این‌ها مالکیت و تخصیص حافظه را از "
#~ "طریق روش‌های مختلف دربرمی‌گیرند و از خطاهای بالقوه در C جلوگیری می‌کنند."

#~ msgid ""
#~ "You may be asked about destructors here, the [Drop](https://doc.rust-lang."
#~ "org/std/ops/trait.Drop.html) trait is the Rust equivalent."
#~ msgstr ""
#~ "اگر درباره مخرب‌ها (destructors) از شما پرسیدند, مخرب ها معادل پیاده‌سازی "
#~ "[Drop](https://doc.rust-lang.org/std/ops/trait.Drop.html) هستند."

#~ msgid "A destructor can run here to free up resources."
#~ msgstr "یک مخرب می‌تواند در اینجا اجرا شود تا منابع را آزاد کند."

#~ msgid "There is always _exactly_ one variable binding which owns a value."
#~ msgstr "همیشه مالکیت یک مقدار را یک متغییر که بهش انتساب میدیم دارد"

#~ msgid "The heap data from `s1` is reused for `s2`."
#~ msgstr "داده‌های انباشت از `s1` دوباره  برای `s2` استفاده می‌شود."

#~ msgid ""
#~ "When `s1` goes out of scope, nothing happens (it has been moved from)."
#~ msgstr "وقتی از اسکوپ `s1` خارج می‌شویم، هیچ اتفاقی نمی‌افتد."

#~ msgid ""
#~ "If students ask about `derive`, it is sufficient to say that this is a "
#~ "way to generate code in Rust at compile time. In this case the default "
#~ "implementations of `Copy` and `Clone` traits are generated."
#~ msgstr ""
#~ "اگر دانشجویان در مورد `derive` پرسیدند، کافی است بگوییم که این راهی برای "
#~ "تولید کد در`Rust` در زمان کامپایل است. در این مورد، پیاده‌سازی‌های پیش‌فرض "
#~ "صفت‌های `Copy` و `Clone` تولید می‌شوند."

#, fuzzy
#~ msgid "Drawing A Simple GUI"
#~ msgstr "یک کتابخانه GUI ساده"

#, fuzzy
#~ msgid "concurrency:"
#~ msgstr "همزمانی"

#, fuzzy
#~ msgid "control flow:"
#~ msgstr "کنترل جریان"

#, fuzzy
#~ msgid "error handling:"
#~ msgstr "مدیریت خطا (Error Handling)"

#, fuzzy
#~ msgid "garbage collector:"
#~ msgstr "Garbage Collection"

#, fuzzy
#~ msgid "generics:"
#~ msgstr "Generics"

#, fuzzy
#~ msgid "integration test:"
#~ msgstr "Integration Tests"

#, fuzzy
#~ msgid "main function:"
#~ msgstr "فراخوانی متدهای ناامن"

#, fuzzy
#~ msgid "method:"
#~ msgstr "متدها"

#, fuzzy
#~ msgid "module:"
#~ msgstr "ماژول‌ها"

#, fuzzy
#~ msgid "ownership:"
#~ msgstr "مالکیت"

#, fuzzy
#~ msgid "panic:"
#~ msgstr "Panics"

#, fuzzy
#~ msgid "receiver:"
#~ msgstr "درایور"

#, fuzzy
#~ msgid "standard library:"
#~ msgstr "کتابخانه‌های استاندارد"

#, fuzzy
#~ msgid "struct:"
#~ msgstr "ساختارها"

#, fuzzy
#~ msgid "thread:"
#~ msgstr "تردها"

#, fuzzy
#~ msgid "trait:"
#~ msgstr "trait:"

#, fuzzy
#~ msgid "union:"
#~ msgstr "Unions"

#, fuzzy
#~ msgid "unit test:"
#~ msgstr "تست‌های واحد (Unit Tests)"

#, fuzzy
#~ msgid "variable:\\"
#~ msgstr "متغیرها"

#, fuzzy
#~ msgid "Pattern matching"
#~ msgstr "تطبیق الگو"
