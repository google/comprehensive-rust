msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 🦀\n"
"POT-Creation-Date: 2024-01-24T13:24:49+01:00\n"
"PO-Revision-Date: 2023-06-06 13:18+0900\n"
"Last-Translator: Kenta Aratani <kentaaratani@coinez.jp>\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md src/index.md
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "Comprehensive Rust 🦀 へようこそ"

#: src/SUMMARY.md src/running-the-course.md
msgid "Running the Course"
msgstr "講座の運営について"

#: src/SUMMARY.md src/running-the-course/course-structure.md
msgid "Course Structure"
msgstr "講座の構成"

#: src/SUMMARY.md src/running-the-course/keyboard-shortcuts.md
msgid "Keyboard Shortcuts"
msgstr "キーボード ショートカット"

#: src/SUMMARY.md src/running-the-course/translations.md
msgid "Translations"
msgstr "翻訳"

#: src/SUMMARY.md src/cargo.md
msgid "Using Cargo"
msgstr "Cargoの使用"

#: src/SUMMARY.md
msgid "Rust Ecosystem"
msgstr "Rust エコシステム"

#: src/SUMMARY.md
msgid "Code Samples"
msgstr "コードサンプル"

#: src/SUMMARY.md
msgid "Running Cargo Locally"
msgstr "ローカル環境での実行"

#: src/SUMMARY.md
msgid "Day 1: Morning"
msgstr "Day 1： AM"

#: src/SUMMARY.md
msgid "Welcome"
msgstr "ようこそ"

#: src/SUMMARY.md src/hello-world.md src/hello-world/hello-world.md
msgid "Hello, World"
msgstr "Hello, World"

#: src/SUMMARY.md src/hello-world/what-is-rust.md
msgid "What is Rust?"
msgstr "Rustとは？"

#: src/SUMMARY.md src/hello-world/benefits.md
msgid "Benefits of Rust"
msgstr "Rustのメリット"

#: src/SUMMARY.md src/hello-world/playground.md
msgid "Playground"
msgstr "プレイグラウンド"

#: src/SUMMARY.md src/types-and-values.md
msgid "Types and Values"
msgstr "型と値"

#: src/SUMMARY.md src/types-and-values/variables.md
msgid "Variables"
msgstr "変数"

#: src/SUMMARY.md src/types-and-values/values.md
msgid "Values"
msgstr "値"

#: src/SUMMARY.md src/types-and-values/arithmetic.md
msgid "Arithmetic"
msgstr "算術"

#: src/SUMMARY.md src/types-and-values/strings.md
msgid "Strings"
msgstr "文字列"

#: src/SUMMARY.md src/types-and-values/inference.md
msgid "Type Inference"
msgstr "型推論"

#: src/SUMMARY.md src/types-and-values/exercise.md
msgid "Exercise: Fibonacci"
msgstr "演習: フィボナッチ"

#: src/SUMMARY.md src/types-and-values/solution.md
#: src/control-flow-basics/solution.md src/tuples-and-arrays/solution.md
#: src/references/solution.md src/user-defined-types/solution.md
#: src/pattern-matching/solution.md src/methods-and-traits/solution.md
#: src/generics/solution.md src/std-types/solution.md
#: src/std-traits/solution.md src/memory-management/solution.md
#: src/smart-pointers/solution.md src/borrowing/solution.md
#: src/slices-and-lifetimes/solution.md src/iterators/solution.md
#: src/modules/solution.md src/testing/solution.md
#: src/error-handling/solution.md src/unsafe-rust/solution.md
msgid "Solution"
msgstr "解答"

#: src/SUMMARY.md src/control-flow-basics.md
msgid "Control Flow Basics"
msgstr "制御フローの基本"

#: src/SUMMARY.md src/control-flow-basics/conditionals.md
msgid "Conditionals"
msgstr "条件文"

#: src/SUMMARY.md src/control-flow-basics/loops.md
msgid "Loops"
msgstr "ループ"

#: src/SUMMARY.md src/control-flow-basics/break-continue.md
msgid "`break` and `continue`"
msgstr "`break` と `continue`"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks and Scopes"
msgstr "ブロックとスコープ"

#: src/SUMMARY.md src/control-flow-basics/functions.md
msgid "Functions"
msgstr "関数"

#: src/SUMMARY.md src/control-flow-basics/macros.md
msgid "Macros"
msgstr "マクロ"

#: src/SUMMARY.md src/control-flow-basics/exercise.md
msgid "Exercise: Collatz Sequence"
msgstr "演習: コラッツ数列"

#: src/SUMMARY.md
msgid "Day 1: Afternoon"
msgstr "Day 1： PM"

#: src/SUMMARY.md src/tuples-and-arrays.md
#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuples and Arrays"
msgstr "タプルと配列"

#: src/SUMMARY.md src/tuples-and-arrays/iteration.md
msgid "Array Iteration"
msgstr "配列のイテレート"

#: src/SUMMARY.md src/tuples-and-arrays/match.md src/pattern-matching.md
msgid "Pattern Matching"
msgstr "パターンマッチング"

#: src/SUMMARY.md src/tuples-and-arrays/destructuring.md
#: src/pattern-matching/destructuring.md
#, fuzzy
msgid "Destructuring"
msgstr "列挙型編"

#: src/SUMMARY.md src/tuples-and-arrays/exercise.md
msgid "Exercise: Nested Arrays"
msgstr "演習: ネストされた配列"

#: src/SUMMARY.md src/references.md
msgid "References"
msgstr "参照"

#: src/SUMMARY.md src/references/shared.md
msgid "Shared References"
msgstr "共有参照"

#: src/SUMMARY.md src/references/exclusive.md
msgid "Exclusive References"
msgstr "排他参照"

#: src/SUMMARY.md src/references/exercise.md
msgid "Exercise: Geometry"
msgstr "演習: ジオメトリ"

#: src/SUMMARY.md src/user-defined-types.md
msgid "User-Defined Types"
msgstr "ユーザー定義型"

#: src/SUMMARY.md src/user-defined-types/named-structs.md
#, fuzzy
msgid "Named Structs"
msgstr "構造体（structs）"

#: src/SUMMARY.md src/user-defined-types/tuple-structs.md
msgid "Tuple Structs"
msgstr "タプル構造体"

#: src/SUMMARY.md src/user-defined-types/enums.md
#: src/pattern-matching/destructuring.md
msgid "Enums"
msgstr "列挙型（enums）"

#: src/SUMMARY.md src/user-defined-types/static-and-const.md
msgid "Static and Const"
msgstr ""

#: src/SUMMARY.md src/user-defined-types/aliases.md
msgid "Type Aliases"
msgstr "型エイリアス"

#: src/SUMMARY.md src/user-defined-types/exercise.md
msgid "Exercise: Elevator Events"
msgstr "演習: エレベーターでのイベント"

#: src/SUMMARY.md
msgid "Day 2: Morning"
msgstr "Day 2： AM"

#: src/SUMMARY.md src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "Let Control Flow"
msgstr "制御フロー"

#: src/SUMMARY.md src/pattern-matching/exercise.md
msgid "Exercise: Expression Evaluation"
msgstr "演習: 式の評価"

#: src/SUMMARY.md src/methods-and-traits.md
msgid "Methods and Traits"
msgstr ""

#: src/SUMMARY.md src/methods-and-traits/methods.md
msgid "Methods"
msgstr "メソッド"

#: src/SUMMARY.md src/methods-and-traits/traits.md
msgid "Traits"
msgstr "トレイト（trait）"

#: src/SUMMARY.md src/methods-and-traits/deriving.md
#, fuzzy
msgid "Deriving"
msgstr "トレイトの導出"

#: src/SUMMARY.md src/methods-and-traits/trait-objects.md
msgid "Trait Objects"
msgstr "トレイトオブジェクト"

#: src/SUMMARY.md src/methods-and-traits/exercise.md
msgid "Exercise: Generic Logger"
msgstr "演習: ジェネリックなロガー"

#: src/SUMMARY.md src/generics.md
msgid "Generics"
msgstr "ジェネリクス（generics）"

#: src/SUMMARY.md src/generics/generic-functions.md
#, fuzzy
msgid "Generic Functions"
msgstr "Extern関数"

#: src/SUMMARY.md src/generics/generic-data.md
msgid "Generic Data Types"
msgstr "ジェネリックデータ型"

#: src/SUMMARY.md src/generics/trait-bounds.md
msgid "Trait Bounds"
msgstr "トレイト制約"

#: src/SUMMARY.md src/generics/impl-trait.md
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md src/generics/exercise.md
msgid "Exercise: Generic `min`"
msgstr "演習: ジェネリックな `min`"

#: src/SUMMARY.md
msgid "Day 2: Afternoon"
msgstr "Day 2： PM"

#: src/SUMMARY.md src/std-types.md
#, fuzzy
msgid "Standard Library Types"
msgstr "標準ライブラリ"

#: src/SUMMARY.md src/std-types/std.md
msgid "Standard Library"
msgstr "標準ライブラリ"

#: src/SUMMARY.md src/std-types/docs.md
msgid "Documentation"
msgstr "ドキュメント"

#: src/SUMMARY.md
msgid "`Option`"
msgstr "`Option`"

#: src/SUMMARY.md
msgid "`Result`"
msgstr "`Result`"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "`String`"
msgstr "`String`"

#: src/SUMMARY.md src/std-types/vec.md
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md src/std-types/hashmap.md src/bare-metal/no_std.md
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md src/std-types/exercise.md
msgid "Exercise: Counter"
msgstr "演習: カウンター"

#: src/SUMMARY.md src/std-traits.md
#, fuzzy
msgid "Standard Library Traits"
msgstr "標準ライブラリ"

#: src/SUMMARY.md src/std-traits/comparisons.md src/async.md
msgid "Comparisons"
msgstr "他の言語との比較"

#: src/SUMMARY.md src/std-traits/operators.md
#, fuzzy
msgid "Operators"
msgstr "イテレータ"

#: src/SUMMARY.md src/std-traits/from-and-into.md
msgid "`From` and `Into`"
msgstr "`From` と `Into`"

#: src/SUMMARY.md src/std-traits/casting.md
#, fuzzy
msgid "Casting"
msgstr "テスト"

#: src/SUMMARY.md src/std-traits/read-and-write.md
msgid "`Read` and `Write`"
msgstr "`Read` と `Write`"

#: src/SUMMARY.md
msgid "`Default`, struct update syntax"
msgstr "`Default`、構造体更新記法"

#: src/SUMMARY.md src/std-traits/closures.md
msgid "Closures"
msgstr "クロージャ"

#: src/SUMMARY.md src/std-traits/exercise.md
msgid "Exercise: ROT13"
msgstr "演習: ROT13暗号"

#: src/SUMMARY.md
msgid "Day 3: Morning"
msgstr "Day 3： AM"

#: src/SUMMARY.md src/memory-management.md
msgid "Memory Management"
msgstr "メモリ管理"

#: src/SUMMARY.md src/memory-management/review.md
msgid "Review of Program Memory"
msgstr "プログラム メモリの見直し"

#: src/SUMMARY.md src/memory-management/approaches.md
#, fuzzy
msgid "Approaches to Memory Management"
msgstr "Rustのメモリ管理"

#: src/SUMMARY.md src/memory-management/ownership.md
msgid "Ownership"
msgstr "所有権"

#: src/SUMMARY.md src/memory-management/move.md
msgid "Move Semantics"
msgstr "ムーブセマンティクス"

#: src/SUMMARY.md
msgid "`Clone`"
msgstr "`Clone`"

#: src/SUMMARY.md src/memory-management/copy-types.md
msgid "Copy Types"
msgstr "Copy 型"

#: src/SUMMARY.md
msgid "`Drop`"
msgstr "`Drop`"

#: src/SUMMARY.md src/memory-management/exercise.md
msgid "Exercise: Builder Type"
msgstr "演習: ビルダー型"

#: src/SUMMARY.md src/smart-pointers.md
msgid "Smart Pointers"
msgstr "スマートポインタ"

#: src/SUMMARY.md src/smart-pointers/box.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`Box<T>`"
msgstr "`Box<T>`"

#: src/SUMMARY.md src/smart-pointers/rc.md
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md src/smart-pointers/exercise.md
msgid "Exercise: Binary Tree"
msgstr "演習: バイナリツリー"

#: src/SUMMARY.md
msgid "Day 3: Afternoon"
msgstr "Day 3： PM"

#: src/SUMMARY.md src/borrowing.md
msgid "Borrowing"
msgstr "借用"

#: src/SUMMARY.md src/borrowing/shared.md
#, fuzzy
msgid "Borrowing a Value"
msgstr "借用"

#: src/SUMMARY.md src/borrowing/borrowck.md
#, fuzzy
msgid "Borrow Checking"
msgstr "借用"

#: src/SUMMARY.md src/borrowing/interior-mutability.md
msgid "Interior Mutability"
msgstr "内部可変性"

#: src/SUMMARY.md src/borrowing/exercise.md
msgid "Exercise: Health Statistics"
msgstr "演習: 健康に関する統計"

#: src/SUMMARY.md src/slices-and-lifetimes.md
#, fuzzy
msgid "Slices and Lifetimes"
msgstr "ライフタイム"

#: src/SUMMARY.md
#, fuzzy
msgid "Slices: `&[T]`"
msgstr "スライス型"

#: src/SUMMARY.md src/slices-and-lifetimes/str.md
msgid "String References"
msgstr "Stringの参照"

#: src/SUMMARY.md src/slices-and-lifetimes/lifetime-annotations.md
msgid "Lifetime Annotations"
msgstr "関数とライフタイム"

#: src/SUMMARY.md
#, fuzzy
msgid "Lifetime Elision"
msgstr "ライフタイム"

#: src/SUMMARY.md
#, fuzzy
msgid "Struct Lifetimes"
msgstr "ライフタイム"

#: src/SUMMARY.md src/slices-and-lifetimes/exercise.md
msgid "Exercise: Protobuf Parsing"
msgstr "演習: Protobufの解析"

#: src/SUMMARY.md
msgid "Day 4: Morning"
msgstr "Day 4： AM"

#: src/SUMMARY.md src/iterators.md
msgid "Iterators"
msgstr "イテレータ"

#: src/SUMMARY.md src/iterators/iterator.md src/bare-metal/no_std.md
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md src/iterators/intoiterator.md
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md
msgid "`FromIterator`"
msgstr "`FromIterator`"

#: src/SUMMARY.md src/iterators/exercise.md
msgid "Exercise: Iterator Method Chaining"
msgstr "演習: イテレータのメソッドチェーン"

#: src/SUMMARY.md src/modules.md src/modules/modules.md
#, fuzzy
msgid "Modules"
msgstr "モジュール タイプ"

#: src/SUMMARY.md src/modules/filesystem.md
msgid "Filesystem Hierarchy"
msgstr "ファイルシステム階層"

#: src/SUMMARY.md src/modules/visibility.md
msgid "Visibility"
msgstr "可視性"

#: src/SUMMARY.md
msgid "`use`, `super`, `self`"
msgstr "`use`、`super`、`self`"

#: src/SUMMARY.md src/modules/exercise.md
#, fuzzy
msgid "Exercise: Modules for a GUI Library"
msgstr "[演習: GUI ライブラリのモジュール](./modules/exercise.md)（15 分）"

#: src/SUMMARY.md src/testing.md src/chromium/testing.md
msgid "Testing"
msgstr "テスト"

#: src/SUMMARY.md
msgid "Test Modules"
msgstr "テストモジュール"

#: src/SUMMARY.md src/testing/other.md
#, fuzzy
msgid "Other Types of Tests"
msgstr "他のプロジェクト"

#: src/SUMMARY.md src/testing/useful-crates.md
msgid "Useful Crates"
msgstr "便利クレート"

#: src/SUMMARY.md src/testing/googletest.md
msgid "GoogleTest"
msgstr "GoogleTest"

#: src/SUMMARY.md src/testing/mocking.md
msgid "Mocking"
msgstr "モック"

#: src/SUMMARY.md src/testing/lints.md
msgid "Compiler Lints and Clippy"
msgstr "コンパイラの Lints と Clippy"

#: src/SUMMARY.md src/testing/exercise.md
#, fuzzy
msgid "Exercise: Luhn Algorithm"
msgstr "Luhnアルゴリズム"

#: src/SUMMARY.md
msgid "Day 4: Afternoon"
msgstr "Day 4： PM"

#: src/SUMMARY.md src/error-handling.md
msgid "Error Handling"
msgstr "エラー処理"

#: src/SUMMARY.md src/error-handling/panics.md
msgid "Panics"
msgstr "パニック（panic）"

#: src/SUMMARY.md src/error-handling/try.md
#, fuzzy
msgid "Try Operator"
msgstr "Iterator"

#: src/SUMMARY.md src/error-handling/try-conversions.md
#, fuzzy
msgid "Try Conversions"
msgstr "暗黙的な型変換"

#: src/SUMMARY.md
msgid "`Error` Trait"
msgstr "`Error`トレイト"

#: src/SUMMARY.md src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror` and `anyhow`"
msgstr "`thiserror` と `anyhow`"

#: src/SUMMARY.md
msgid "Exercise: Rewriting with `Result`"
msgstr "演習: `Result` を使用した書き換え"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/unsafe.md
msgid "Unsafe Rust"
msgstr "Unsafe Rust"

#: src/SUMMARY.md
#, fuzzy
msgid "Unsafe"
msgstr "Unsafe Rust"

#: src/SUMMARY.md src/unsafe-rust/dereferencing.md
msgid "Dereferencing Raw Pointers"
msgstr "生ポインタの参照外し"

#: src/SUMMARY.md src/unsafe-rust/mutable-static.md
msgid "Mutable Static Variables"
msgstr "可変なstatic変数"

#: src/SUMMARY.md src/unsafe-rust/unions.md
msgid "Unions"
msgstr "共用体"

#: src/SUMMARY.md src/unsafe-rust/unsafe-functions.md
msgid "Unsafe Functions"
msgstr "Unsafe関数の呼び出し"

#: src/SUMMARY.md
msgid "Unsafe Traits"
msgstr "Unsafeなトレイトの実装"

#: src/SUMMARY.md
msgid "Exercise: FFI Wrapper"
msgstr "演習: FFIラッパー"

#: src/SUMMARY.md src/bare-metal/android.md
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md src/android/setup.md src/chromium/setup.md
msgid "Setup"
msgstr "セットアップ"

#: src/SUMMARY.md src/android/build-rules.md
msgid "Build Rules"
msgstr "ビルドのルール"

#: src/SUMMARY.md
msgid "Binary"
msgstr "バイナリ"

#: src/SUMMARY.md
msgid "Library"
msgstr "ライブラリ"

#: src/SUMMARY.md src/android/aidl.md
msgid "AIDL"
msgstr "AIDL（Androidインターフェイス定義言語）"

#: src/SUMMARY.md
msgid "Interface"
msgstr "インターフェイス"

#: src/SUMMARY.md
msgid "Implementation"
msgstr "実装"

#: src/SUMMARY.md
msgid "Server"
msgstr "サーバ"

#: src/SUMMARY.md src/android/aidl/deploy.md
msgid "Deploy"
msgstr "デプロイ"

#: src/SUMMARY.md
msgid "Client"
msgstr "クライアント"

#: src/SUMMARY.md src/android/aidl/changing.md
msgid "Changing API"
msgstr "APIの変更"

#: src/SUMMARY.md src/android/logging.md src/bare-metal/aps/logging.md
msgid "Logging"
msgstr "ログ出力"

#: src/SUMMARY.md src/android/interoperability.md
msgid "Interoperability"
msgstr "相互運用性"

#: src/SUMMARY.md
msgid "With C"
msgstr "C"

#: src/SUMMARY.md
msgid "Calling C with Bindgen"
msgstr "BindgenによるCの呼び出し"

#: src/SUMMARY.md
msgid "Calling Rust from C"
msgstr "CからRust呼び出し"

#: src/SUMMARY.md src/android/interoperability/cpp.md
msgid "With C++"
msgstr "C++"

#: src/SUMMARY.md src/android/interoperability/cpp/bridge.md
#, fuzzy
msgid "The Bridge Module"
msgstr "テストモジュール"

#: src/SUMMARY.md
msgid "Rust Bridge"
msgstr "Rustブリッジ"

#: src/SUMMARY.md src/android/interoperability/cpp/generated-cpp.md
msgid "Generated C++"
msgstr "生成された C++"

#: src/SUMMARY.md
msgid "C++ Bridge"
msgstr "C++ ブリッジ"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-types.md
msgid "Shared Types"
msgstr "共有の型"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-enums.md
msgid "Shared Enums"
msgstr "共有の列挙型"

#: src/SUMMARY.md src/android/interoperability/cpp/rust-result.md
#, fuzzy
msgid "Rust Error Handling"
msgstr "エラー処理"

#: src/SUMMARY.md src/android/interoperability/cpp/cpp-exception.md
#, fuzzy
msgid "C++ Error Handling"
msgstr "エラー処理"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "Additional Types"
msgstr "その他の型"

#: src/SUMMARY.md
msgid "Building for Android: C++"
msgstr "Android 向けのビルド: C++"

#: src/SUMMARY.md
msgid "Building for Android: Genrules"
msgstr "Android 向けのビルド: Genrules"

#: src/SUMMARY.md
msgid "Building for Android: Rust"
msgstr "Android 向けのビルド: Rust"

#: src/SUMMARY.md
msgid "With Java"
msgstr "Java"

#: src/SUMMARY.md src/exercises/android/morning.md
#: src/exercises/bare-metal/morning.md src/exercises/bare-metal/afternoon.md
#: src/exercises/concurrency/morning.md src/exercises/concurrency/afternoon.md
msgid "Exercises"
msgstr "練習問題"

#: src/SUMMARY.md
msgid "Chromium"
msgstr "Chromium"

#: src/SUMMARY.md src/chromium/cargo.md
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr "Chromium と Cargo のエコシステムの比較"

#: src/SUMMARY.md
msgid "Policy"
msgstr "ポリシー"

#: src/SUMMARY.md
#, fuzzy
msgid "Unsafe Code"
msgstr "Unsafe Rust"

#: src/SUMMARY.md src/chromium/build-rules/depending.md
msgid "Depending on Rust Code from Chromium C++"
msgstr "Chromium C++からRustのコードに依存させる"

#: src/SUMMARY.md src/chromium/build-rules/vscode.md
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: src/SUMMARY.md src/exercises/chromium/third-party.md
msgid "Exercise"
msgstr "演習"

#: src/SUMMARY.md src/chromium/testing/rust-gtest-interop.md
msgid "`rust_gtest_interop` Library"
msgstr "`rust_gtest_interop` ライブラリ"

#: src/SUMMARY.md src/chromium/testing/build-gn.md
msgid "GN Rules for Rust Tests"
msgstr "Rust テスト用の GN ルール"

#: src/SUMMARY.md src/chromium/testing/chromium-import-macro.md
msgid "`chromium::import!` Macro"
msgstr "`chromium::import!` マクロ"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Interoperability with C++"
msgstr "C との相互運用性"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Example Bindings"
msgstr "例"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Limitations of CXX"
msgstr "CXXの限界"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid "CXX Error Handling"
msgstr "エラー処理"

#: src/SUMMARY.md
#, fuzzy
msgid "Error Handling: QR Example"
msgstr "エラー処理"

#: src/SUMMARY.md
#, fuzzy
msgid "Error Handling: PNG Example"
msgstr "エラー処理"

#: src/SUMMARY.md
msgid "Using CXX in Chromium"
msgstr "Chromium で CXX を使用する"

#: src/SUMMARY.md src/chromium/adding-third-party-crates.md
msgid "Adding Third Party Crates"
msgstr "サードパーティのクレートを追加する"

#: src/SUMMARY.md
msgid "Configuring Cargo.toml"
msgstr "Cargo.toml を構成する"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid "Configuring `gnrt_config.toml`"
msgstr "`gnrt_config.toml` を構成する"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Downloading Crates"
msgstr "クレートをダウンロードする"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Generating `gn` Build Rules"
msgstr "`gn` ビルドルールを生成する"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Resolving Problems"
msgstr "問題を解決する"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid "Build Scripts Which Generate Code"
msgstr "コードを生成するビルドスクリプト"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr "C++をビルドする、もしくは、任意のアクションを実行するビルドスクリプト"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Depending on a Crate"
msgstr "クレートへの依存を設定する"

#: src/SUMMARY.md
msgid "Reviews and Audits"
msgstr "審査と監査"

#: src/SUMMARY.md
msgid "Checking into Chromium Source Code"
msgstr "Chromium ソースコードにチェックインする"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid "Keeping Crates Up to Date"
msgstr "クレートを最新の状態に保つ"

#: src/SUMMARY.md
msgid "Bringing It Together - Exercise"
msgstr "まとめ - 演習"

#: src/SUMMARY.md src/exercises/chromium/solutions.md
#, fuzzy
msgid "Exercise Solutions"
msgstr "演習: 式の評価"

#: src/SUMMARY.md
#, fuzzy
msgid "Bare Metal: Morning"
msgstr "ベアメタル Rust：午前の講座"

#: src/SUMMARY.md src/bare-metal/no_std.md
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md
msgid "A Minimal Example"
msgstr "例"

#: src/SUMMARY.md src/bare-metal/no_std.md src/bare-metal/alloc.md
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md src/bare-metal/microcontrollers.md
msgid "Microcontrollers"
msgstr "マイクロコントローラ"

#: src/SUMMARY.md src/bare-metal/microcontrollers/mmio.md
msgid "Raw MMIO"
msgstr "生MMIO（メモリマップドI/O）"

#: src/SUMMARY.md
msgid "PACs"
msgstr "PACs"

#: src/SUMMARY.md
msgid "HAL Crates"
msgstr "HALクレート"

#: src/SUMMARY.md
msgid "Board Support Crates"
msgstr "ボードサポートクレート"

#: src/SUMMARY.md
msgid "The Type State Pattern"
msgstr "タイプステートパターン"

#: src/SUMMARY.md src/bare-metal/microcontrollers/embedded-hal.md
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "`probe-rs` and `cargo-embed`"
msgstr "probe-rs, cargo-embed"

#: src/SUMMARY.md src/bare-metal/microcontrollers/debugging.md
msgid "Debugging"
msgstr "デバッグ"

#: src/SUMMARY.md
msgid "Other Projects"
msgstr "他のプロジェクト"

#: src/SUMMARY.md src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "Compass"
msgstr "コンパス"

#: src/SUMMARY.md
msgid "Solutions"
msgstr "解答"

#: src/SUMMARY.md
msgid "Bare Metal: Afternoon"
msgstr "ベアメタル： PM"

#: src/SUMMARY.md
msgid "Application Processors"
msgstr "アプリケーションプロセッサ"

#: src/SUMMARY.md src/bare-metal/aps/entry-point.md
msgid "Getting Ready to Rust"
msgstr "Rust の準備"

#: src/SUMMARY.md
msgid "Inline Assembly"
msgstr "インラインアセンブリ"

#: src/SUMMARY.md
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md
msgid "Let's Write a UART Driver"
msgstr "UARTドライバを書いてみよう"

#: src/SUMMARY.md
msgid "More Traits"
msgstr "他のトレイト"

#: src/SUMMARY.md
msgid "A Better UART Driver"
msgstr "UARTドライバの改善"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/bitflags.md
msgid "Bitflags"
msgstr "ビットフラッグ"

#: src/SUMMARY.md
msgid "Multiple Registers"
msgstr "複数のレジスタ"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/driver.md
msgid "Driver"
msgstr "ドライバ"

#: src/SUMMARY.md
msgid "Using It"
msgstr "使用例"

#: src/SUMMARY.md src/bare-metal/aps/exceptions.md
msgid "Exceptions"
msgstr "例外"

#: src/SUMMARY.md src/bare-metal/useful-crates/zerocopy.md
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md src/bare-metal/useful-crates/aarch64-paging.md
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/SUMMARY.md src/bare-metal/useful-crates/tinyvec.md
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md src/bare-metal/useful-crates/spin.md
msgid "`spin`"
msgstr "`spin`"

#: src/SUMMARY.md
msgid "`vmbase`"
msgstr "`vmbase`"

#: src/SUMMARY.md
msgid "RTC Driver"
msgstr "RTC（リアルタイムクロック）ドライバ"

#: src/SUMMARY.md
msgid "Concurrency: Morning"
msgstr "並行性： AM"

#: src/SUMMARY.md src/concurrency/threads.md
msgid "Threads"
msgstr "スレッド"

#: src/SUMMARY.md src/concurrency/scoped-threads.md
msgid "Scoped Threads"
msgstr "スコープ付きスレッド"

#: src/SUMMARY.md src/concurrency/channels.md
msgid "Channels"
msgstr "チャネル"

#: src/SUMMARY.md src/concurrency/channels/unbounded.md
msgid "Unbounded Channels"
msgstr "Unboundedチャネル"

#: src/SUMMARY.md src/concurrency/channels/bounded.md
msgid "Bounded Channels"
msgstr "Boundedチャネル"

#: src/SUMMARY.md src/concurrency/send-sync.md
msgid "`Send` and `Sync`"
msgstr "`Send`と`Sync`"

#: src/SUMMARY.md src/concurrency/send-sync/send.md
msgid "`Send`"
msgstr "`Send`"

#: src/SUMMARY.md src/concurrency/send-sync/sync.md
msgid "`Sync`"
msgstr "`Sync`"

#: src/SUMMARY.md src/concurrency/send-sync/examples.md
msgid "Examples"
msgstr "例"

#: src/SUMMARY.md src/concurrency/shared_state.md
msgid "Shared State"
msgstr "状態共有"

#: src/SUMMARY.md src/concurrency/shared_state/arc.md
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md src/concurrency/shared_state/mutex.md
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/SUMMARY.md src/memory-management/review.md
#: src/error-handling/try-conversions.md
#: src/concurrency/shared_state/example.md
msgid "Example"
msgstr "例"

#: src/SUMMARY.md src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
msgid "Dining Philosophers"
msgstr "食事する哲学者"

#: src/SUMMARY.md src/exercises/concurrency/link-checker.md
msgid "Multi-threaded Link Checker"
msgstr "マルチスレッド・リンクチェッカー"

#: src/SUMMARY.md
msgid "Concurrency: Afternoon"
msgstr "並行性： PM"

#: src/SUMMARY.md
msgid "Async Basics"
msgstr "Asyncの基礎"

#: src/SUMMARY.md src/async/async-await.md
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/SUMMARY.md src/async/futures.md
msgid "Futures"
msgstr "Future"

#: src/SUMMARY.md src/async/runtimes.md
msgid "Runtimes"
msgstr "ランタイム"

#: src/SUMMARY.md src/async/runtimes/tokio.md
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md src/exercises/concurrency/link-checker.md src/async/tasks.md
#: src/exercises/concurrency/chat-app.md
msgid "Tasks"
msgstr "タスク"

#: src/SUMMARY.md src/async/channels.md
msgid "Async Channels"
msgstr "Asyncチャネル"

#: src/SUMMARY.md
msgid "Control Flow"
msgstr "制御フロー"

#: src/SUMMARY.md src/async/control-flow/join.md
msgid "Join"
msgstr "Join"

#: src/SUMMARY.md src/async/control-flow/select.md
msgid "Select"
msgstr "Select"

#: src/SUMMARY.md
msgid "Pitfalls"
msgstr "落とし穴"

#: src/SUMMARY.md
msgid "Blocking the Executor"
msgstr "エグゼキュータのブロッキング"

#: src/SUMMARY.md src/async/pitfalls/pin.md
msgid "`Pin`"
msgstr "`Pin`"

#: src/SUMMARY.md src/async/pitfalls/async-traits.md
msgid "Async Traits"
msgstr "Asyncトレイト"

#: src/SUMMARY.md src/async/pitfalls/cancellation.md
#, fuzzy
msgid "Cancellation"
msgstr "インストール"

#: src/SUMMARY.md src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "Broadcast Chat Application"
msgstr "ブロードキャスト・チャットアプリ"

#: src/SUMMARY.md
msgid "Final Words"
msgstr "最後に"

#: src/SUMMARY.md src/thanks.md
msgid "Thanks!"
msgstr "ありがとうございました！"

#: src/SUMMARY.md src/glossary.md
msgid "Glossary"
msgstr "用語集"

#: src/SUMMARY.md
msgid "Other Resources"
msgstr "参考資料"

#: src/SUMMARY.md src/credits.md
msgid "Credits"
msgstr "クレジット"

#: src/index.md
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"

#: src/index.md
#, fuzzy
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"この資料は、GoogleのAndroidチームによって開発された3日間のRust講座です。本講"
"座では、基本構文からジェネリクスやエラー処理など、幅広い内容をカバーします。"
"また、最終日にはAndroid専用の内容も含まれています。"

#: src/index.md
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"コースの最新バージョンは <https://google.github.io/comprehensive-rust/> にあ"
"ります。他の場所でお読みの場合は、そちらで最新情報をご確認ください。"

#: src/index.md
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"本講座の目的は、Rustを教える事です。Rustに関する前提知識は不要としており、次"
"の目標を設定しています："

#: src/index.md
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "Rustの基本構文と言語についての理解を深める。"

#: src/index.md
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr "既存のプログラムを修正したり、新規プログラムをRustで書けるようにする。"

#: src/index.md
msgid "Show you common Rust idioms."
msgstr "一般的なRustのイディオムを紹介する。"

#: src/index.md
msgid "We call the first four course days Rust Fundamentals."
msgstr "コースの最初の4日間を「Rust の基礎」と呼びます。"

#: src/index.md
#, fuzzy
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""
"最初の3日間は、Rustの基礎を学びます。その後、より専門的なトピックに進む事がで"
"きます："

#: src/index.md
#, fuzzy
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md)： Androidオープンソースプラットフォーム（AOSP）でRustを"
"使用するための半日講座。C、C++、およびJavaとの相互運用性も含まれます。"

#: src/index.md
#, fuzzy
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[ChromiumでのRust](../chromium.md) は半日コースで、Chromium ブラウザの一部と"
"してRustを使用する方法について詳しく説明します。Chromium の `gn` ビルドシステ"
"ムでRustを使用することで、サードパーティライブラリ（「クレート」）、および C+"
"+ との相互運用性を導入できます。"

#: src/index.md
#, fuzzy
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md)： ベアメタル（組み込み）開発でRustを使用するため"
"の1日講座。マイクロコントローラとアプリケーションプロセッサの両方が対象となり"
"ます。"

#: src/index.md
#, fuzzy
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[Concurrency](concurrency.md)： Rustの並行性についての1日講座。並行性（スレッ"
"ドとミューテックスを用いたプリエンプティブなスケジューリング）と、async/await"
"を使用した並行性（futuresを用いた協調的マルチタスク）がカバーされます。"

#: src/index.md
msgid "Non-Goals"
msgstr "本講座の対象外"

#: src/index.md
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rustは非常に汎用性の高い言語であり、数日で全てを網羅する事はできません。本講"
"座の目標として設定されていないものには、以下のようなものがあります："

#: src/index.md
#, fuzzy
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"マクロ（macro）の開発。マクロの詳細については、[Rust Book 日本語版 Ch. 19.5]"
"(https://doc.rust-jp.rs/book-ja/ch19-06-macros.html)と[Rust by Example 日本語"
"版 Ch.17](http://doc.rust-jp.rs/rust-by-example-ja/macros.html)を参照してくだ"
"さい。"

#: src/index.md
msgid "Assumptions"
msgstr "前提知識"

#: src/index.md
#, fuzzy
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"本講座では、既にプログラミングの知識がある事を前提としています。Rustは静的型"
"付け言語であり、Rustのアプローチをより分かりやすく説明するために、時折CやC+"
"+との比較を行います。"

#: src/index.md
#, fuzzy
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"もし受講者の知識がPythonやJavaScriptなどの動的型付け言語に限定されている場合"
"でも、本講座の受講は可能です。"

#: src/index.md
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"これはスピーカーノートの一例です。これを使用してスライドを捕捉します。講師が"
"カバーすべき要点や、授業でよく出る質問への回答などが含まれます。"

#: src/running-the-course.md src/running-the-course/course-structure.md
msgid "This page is for the course instructor."
msgstr "このページは講師用です。"

#: src/running-the-course.md
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr "以下は、Google内での講座の運営方法に関する情報です。"

#: src/running-the-course.md
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""
"クラスは通常午前9時から午後4時までで、途中で1時間の昼食休憩があります。つま"
"り、午前のクラスが3時間、午後のクラスが3時間となります。どちらのセッションに"
"も、休憩と、受講者が演習に取り組むための時間が複数回含まれています。"

#: src/running-the-course.md
msgid "Before you run the course, you will want to:"
msgstr "講座開始までに、以下にあげる準備を済ませておくと良いでしょう："

#: src/running-the-course.md
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"資料に慣れておいてください。要点を強調するためにスピーカーノートが用意されて"
"います（内容の追加にご協力ください！）。プレゼン時には、スクリーンを見やすい"
"状態で保つために、スピーカーノートはポップアップウィンドウで開いてください"
"（スピーカーノートの横にある小さな矢印をクリック）。"

#: src/running-the-course.md
#, fuzzy
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"あらかじめ日程を決めておいてください。講座は最低でも3日かかるため、2週間にわ"
"たって日程を組む事を推奨しています。過去の受講者によると、講座の間に数日"
"ギャップを設ける事で内容が吸収しやすくなります。"

#: src/running-the-course.md
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"十分な広さの部屋を確保しておいてください。15~25名程度のクラスを推奨していま"
"す。受講者にとって質問がしやすい人数であり、1人の講師が質問に答える時間も確保"
"できる規模だからです。また、皆さんはPCで作業をする必要があるため、講師を含め"
"た人数分の机を用意しておいてください。ライブコーディング形式での実施を想定し"
"ているため、講壇は不要です。"

#: src/running-the-course.md
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"当日は少し早めに到着して準備をしてください。自分のPCで実行する`mdbook serve`"
"から直接プレゼンを行う事を推奨します（[インストール手順](https://github.com/"
"google/comprehensive-rust#building)はこちら）。これにより、ページ切り替え時に"
"遅延なしで最適なパフォーマンスが得られます。また、PCを使用する事で、受講者や"
"自分自身が見つけたタイプミスなども修正可能になります。"

#: src/running-the-course.md
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"練習問題は個人か小さいグループで解いてください。回答をレビューする時間も含"
"め、各練習問題に30~45分を費やします。受講者が行き詰まっているかどうか、何か質"
"問があるかなど確認してください。複数の受講者が同じ問題で詰まっている場合、ク"
"ラス全体に対してそれを共有し、解決策を提供してください。例えば、探している情"
"報が標準ライブラリのどこにあるかを示す、など。"

#: src/running-the-course.md
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"以上です。運営頑張ってください！皆さんにとっても楽しい時間になりますように！"

#: src/running-the-course.md
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"本講座の改善に向けて[フィードバック](https://github.com/google/comprehensive-"
"rust/discussions/86)をお願いします。うまくいった点や改善点について幅広くご意"
"見お聞かせください。[受講者からのフィードバック](https://github.com/google/"
"comprehensive-rust/discussions/100)も歓迎しております！"

#: src/running-the-course/course-structure.md
msgid "Rust Fundamentals"
msgstr "Rust の基礎"

#: src/running-the-course/course-structure.md
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""
"[Rust の基礎](../welcome-day-1.md) を構成する最初の 4 日間で、さまざまな項目"
"を駆け足で学びます。"

#: src/running-the-course/course-structure.md
msgid "Course schedule:"
msgstr "コースのスケジュール:"

#: src/running-the-course/course-structure.md
msgid "Day 1 Morning (3 hours, including breaks)"
msgstr "1 日目の午前（休憩を含めて 3 時間）"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-1.md) (5 minutes)"
msgstr "[ようこそ](../welcome-day-1.md)（5 分）"

#: src/running-the-course/course-structure.md
msgid "[Hello, World](../hello-world.md) (20 minutes)"
msgstr "[Hello, World](../hello-world.md)（20 分）"

#: src/running-the-course/course-structure.md
msgid "[Types and Values](../types-and-values.md) (1 hour and 5 minutes)"
msgstr "[型と値](../types-and-values.md)（1 時間 5 分）"

#: src/running-the-course/course-structure.md
msgid "[Control Flow Basics](../control-flow-basics.md) (1 hour)"
msgstr "[制御フローの基本](../control-flow-basics.md)（1 時間）"

#: src/running-the-course/course-structure.md
msgid "Day 1 Afternoon (2 hours and 55 minutes, including breaks)"
msgstr "1 日目の午後（休憩を含めて 2 時間 55 分）"

#: src/running-the-course/course-structure.md
msgid "[Tuples and Arrays](../tuples-and-arrays.md) (1 hour)"
msgstr "[タプルと配列](../tuples-and-arrays.md)（1 時間）"

#: src/running-the-course/course-structure.md
msgid "[References](../references.md) (50 minutes)"
msgstr "[参照](../references.md)（50 分）"

#: src/running-the-course/course-structure.md
msgid "[User-Defined Types](../user-defined-types.md) (50 minutes)"
msgstr "[ユーザー定義型](../user-defined-types.md)（50 分）"

#: src/running-the-course/course-structure.md
msgid "Day 2 Morning (3 hours and 5 minutes, including breaks)"
msgstr "2 日目の午前（休憩を含めて 3 時間 5 分）"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-2.md) (3 minutes)"
msgstr "[ようこそ](../welcome-day-2.md)（3 分）"

#: src/running-the-course/course-structure.md
msgid "[Pattern Matching](../pattern-matching.md) (50 minutes)"
msgstr "[パターン マッチング](../pattern-matching.md)（50 分）"

#: src/running-the-course/course-structure.md
msgid "[Methods and Traits](../methods-and-traits.md) (55 minutes)"
msgstr "[メソッドとトレイト](../methods-and-train.md)（55 分）"

#: src/running-the-course/course-structure.md
msgid "[Generics](../generics.md) (45 minutes)"
msgstr "[ジェネリクス](../generics.md)（45 分）"

#: src/running-the-course/course-structure.md
msgid "Day 2 Afternoon (3 hours, including breaks)"
msgstr "2 日目の午後（休憩を含めて 3 時間）"

#: src/running-the-course/course-structure.md
msgid "[Standard Library Types](../std-types.md) (1 hour and 10 minutes)"
msgstr "[標準ライブラリ型](../std-types.md)（1 時間 10 分）"

#: src/running-the-course/course-structure.md
msgid "[Standard Library Traits](../std-traits.md) (1 hour and 40 minutes)"
msgstr "[標準ライブラリ トレイト](../std-train.md)（1 時間 40 分）"

#: src/running-the-course/course-structure.md
msgid "Day 3 Morning (2 hours and 15 minutes, including breaks)"
msgstr "3 日目の午前（休憩を含めて 2 時間 15 分）"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-3.md) (3 minutes)"
msgstr "[ようこそ](../welcome-day-3.md)（3 分）"

#: src/running-the-course/course-structure.md
msgid "[Memory Management](../memory-management.md) (1 hour and 10 minutes)"
msgstr "[メモリ管理](../memory-management.md)（1 時間 10 分）"

#: src/running-the-course/course-structure.md
msgid "[Smart Pointers](../smart-pointers.md) (45 minutes)"
msgstr "[スマート ポインタ](../smart-pointers.md)（45 分）"

#: src/running-the-course/course-structure.md
msgid "Day 3 Afternoon (2 hours and 20 minutes, including breaks)"
msgstr "3 日目の午後（休憩を含めて 2 時間 20 分）"

#: src/running-the-course/course-structure.md
msgid "[Borrowing](../borrowing.md) (1 hour)"
msgstr "[借用](../borrowing.md)（1 時間）"

#: src/running-the-course/course-structure.md
msgid ""
"[Slices and Lifetimes](../slices-and-lifetimes.md) (1 hour and 10 minutes)"
msgstr "[スライスとライフタイム](../slices-and-lifetimes.md)（1 時間 10 分）"

#: src/running-the-course/course-structure.md
msgid "Day 4 Morning (3 hours and 5 minutes, including breaks)"
msgstr "4 日目の午前（休憩を含めて 3 時間 5 分）"

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-4.md) (3 minutes)"
msgstr "[ようこそ](../welcome-day-4.md)（3 分）"

#: src/running-the-course/course-structure.md
msgid "[Iterators](../iterators.md) (45 minutes)"
msgstr "[イテレータ](../iterators.md)（45 分）"

#: src/running-the-course/course-structure.md
msgid "[Modules](../modules.md) (40 minutes)"
msgstr "[モジュール](../modules.md)（40 分）"

#: src/running-the-course/course-structure.md
msgid "[Testing](../testing.md) (1 hour and 5 minutes)"
msgstr "[テスト](../testing.md)（1 時間 5 分）"

#: src/running-the-course/course-structure.md
msgid "Day 4 Afternoon (2 hours, including breaks)"
msgstr "4 日目の午後（休憩を含めて 2 時間）"

#: src/running-the-course/course-structure.md
msgid "[Error Handling](../error-handling.md) (45 minutes)"
msgstr "[エラー処理](../error-handling.md)（45 分）"

#: src/running-the-course/course-structure.md
msgid "[Unsafe Rust](../unsafe-rust.md) (1 hour and 5 minutes)"
msgstr "[Unsafe Rust](../unsafe-rust.md)（1 時間 5 分）"

#: src/running-the-course/course-structure.md
msgid "Deep Dives"
msgstr "専門的なトピック"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""
"Rustの基礎に関する3日間の講座に加え、いくつかのより専門的なトピックも用意され"
"ています："

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Rust in Android"
msgstr "Android での Rust へようこそ"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Android編](../android.md)は、Androidオープンソースプラットフォーム（AOSP）で"
"Rustを使用するための半日程度の講座です。C、C++、およびJavaとの相互運用性も含"
"まれます。"

#: src/running-the-course/course-structure.md
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"[AOSPのチェックアウト](https://source.android.com/docs/setup/download/"
"downloading)が必要です。同じ端末から[講座のリポジトリ](https://github.com/"
"google/comprehensive-rust)をチェックアウトし、`src/android/`ディレクトリを"
"AOSPチェックアウトのルートに移動してください。これにより、Androidビルドシステ"
"ムが`src/android/`内の`Android.bp`を確認できるようになります。"

#: src/running-the-course/course-structure.md
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"エミュレータまたは実際のデバイスで`adb sync`が機能する事を確認し、`src/"
"android/build_all.sh`を使用して全てのAndroidの例を事前にビルドしてください。"
"スクリプトを読んで実行コマンドを確認し、手動で実行した際に正常に動作する事を"
"確認してください。"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Rust in Chromium"
msgstr "Chromium の Rust へようこそ"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""
"[Chromium での Rust](../chromium.md) は半日コースで、Chromium ブラウザの一部"
"として Rust を使用する方法について詳しく説明します。Chromium の `gn` ビルドシ"
"ステムで Rust を使用することで、サードパーティ ライブラリ（「クレート」）、お"
"よび C++ との相互運用性を導入できます。"

#: src/running-the-course/course-structure.md
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""
"受講者は、Chromium をビルドできる必要があります。時間を短縮できるデバッグのコ"
"ンポーネント ビルドを [推奨](../chromium/setup.md) しますが、どのようなビルド"
"でも問題ありません。作成した Chromium ブラウザを実行できることを確認します。"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Bare-Metal Rust"
msgstr "ベアメタル"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[ベアメタル編](../bare-metal.md)は、ベアメタル（組み込み）開発でRustを使用す"
"るための1日講座です。マイクロコントローラとアプリケーションプロセッサの両方が"
"対象となります。"

#: src/running-the-course/course-structure.md
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"マイクロコントローラの章では、事前に[BBCmicro:bit](https://microbit.org/)v2開"
"発ボードを購入する必要があります。また、[welcomeページ](../bare-metal.md)で説"
"明されているように、複数のパッケージをインストールする必要があります。"

#: src/running-the-course/course-structure.md
msgid "Concurrency in Rust"
msgstr "Rustでの並行性"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[並行性編](../concurrency.md) は、並行性とasync/awaitを使用した並行性について"
"の1日講座です。"

#: src/running-the-course/course-structure.md
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"新規クレートの作成と、依存関係（dependencies）のダウンロードが必要です。その"
"後、例を`src/main.rs`にコピペして実行する事ができます："

#: src/running-the-course/course-structure.md
msgid "Format"
msgstr "フォーマット"

#: src/running-the-course/course-structure.md
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"本講座はインタラクティブな形式で行います。積極的に質問して、Rustへの理解を深"
"めてください！"

#: src/running-the-course/keyboard-shortcuts.md
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "mdBookには、便利なショートカットキーがいくつか存在します："

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Left"
msgstr "Arrow-Left"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the previous page."
msgstr "： 前のページに移動"

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Right"
msgstr "Arrow-Right"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the next page."
msgstr "： 次のページに移動。"

#: src/running-the-course/keyboard-shortcuts.md src/cargo/code-samples.md
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Execute the code sample that has focus."
msgstr "： フォーカスを持つコードサンプルを実行"

#: src/running-the-course/keyboard-shortcuts.md
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Activate the search bar."
msgstr "： 検索バーを起動"

#: src/running-the-course/translations.md
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr "本資料は、ボランティアによって翻訳されています："

#: src/running-the-course/translations.md
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[ポルトガル語（ブラジル）](https://google.github.io/comprehensive-rust/pt-"
"BR/): [@rastringer](https://github.com/rastringer)、[@hugojacob](https://"
"github.com/hugojacob)、[@joaovicmendes](https://github.com/joaovicmendes)、"
"[@henrif75](https://github.com/henrif75)"

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""
"[中国語（簡体字）](https://google.github.io/comprehensive-rust/zh-CN/): "
"[@suetfei](https://github.com/suetfei)、[@wnghl](https://github.com/wnghl)、"
"[@anlunx](https://github.com/anlunx)、[@kongy](https://github.com/kongy)、"
"[@noahdragon](https://github.com/noahdragon)、[@superwhd](https://github.com/"
"superwhd)、[@SketchK](https://github.com/SketchK)、[@nodmp](https://github."
"com/nodmp)"

#: src/running-the-course/translations.md
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[中国語（繁体字）](https://google.github.io/comprehensive-rust/zh-TW/): "
"[@hueich](https://github.com/hueich)、[@victorhsieh](https://github.com/"
"victorhsieh)、[@mingyc](https://github.com/mingyc)、[@kuanhungchen](https://"
"github.com/kuanhungchen)、[@johnathan79717](https://github.com/"
"johnathan79717)"

#: src/running-the-course/translations.md
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""
"[韓国語](https://google.github.io/comprehensive-rust/ko/): [@keispace]"
"(https://github.com/keispace)、[@jiyongp](https://github.com/jiyongp)、"
"[@jooyunghan](https://github.com/jooyunghan)"

#: src/running-the-course/translations.md
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[スペイン語](https://google.github.io/comprehensive-rust/es/): [@deavid]"
"(https://github.com/deavid)"

#: src/running-the-course/translations.md
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr "画面右上の言語切り替えボタンから、切り替えを行なってください。"

#: src/running-the-course/translations.md
#, fuzzy
msgid "Incomplete Translations"
msgstr "翻訳"

#: src/running-the-course/translations.md
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr "進行中の翻訳が多数あります。最新の翻訳へのリンクを以下に示します。"

#: src/running-the-course/translations.md
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[ベンガル語](https://google.github.io/comprehensive-rust/bn/): [@raselmandol]"
"(https://github.com/raselmandol)"

#: src/running-the-course/translations.md
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""
"[フランス語](https://google.github.io/comprehensive-rust/fr/): [@KookaS]"
"(https://github.com/KookaS)、[@vcaen](https://github.com/vcaen)"

#: src/running-the-course/translations.md
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[ドイツ語](https://google.github.io/comprehensive-rust/de/): [@Throvn]"
"(https://github.com/Throvn)、[@ronaldfw](https://github.com/ronaldfw)"

#: src/running-the-course/translations.md
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[日本語](https://google.github.io/comprehensive-rust/ja/): [@CoinEZ-JPN]"
"(https://github.com/CoinEZ)、[@momotaro1105](https://github.com/momotaro1105)"

#: src/running-the-course/translations.md
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"この取り組みにご協力いただける場合は、[our instructions](https://github.com/"
"google/comprehensive-rust/blob/main/TRANSLATIONS.md)をご覧ください。翻訳は"
"[issue tracker](https://github.com/google/comprehensive-rust/issues/282)で管"
"理されています。"

#: src/cargo.md
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"Rustを学び始めると、まもなくRustエコシステムで広く使われているビルドシステム"
"兼パッケージマネージャである[Cargo](https://doc.rust-lang.org/cargo/)という標"
"準ツールに出会います。ここでは、Cargoの概要や使用方法、そして本講座における重"
"要性について簡単に説明します。"

#: src/cargo.md
msgid "Installation"
msgstr "インストール"

#: src/cargo.md
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**<https://rustup.rs/> の手順に沿ってインストールしてください。**"

#: src/cargo.md
#, fuzzy
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"Rustupも、cargoやrustcと一緒にコマンドラインユーティリティとしてインストール"
"されます。Rustupを使用することで、ツールチェーンのインストールや切り替え、ク"
"ロスコンパイルの設定などが行えます。"

#: src/cargo.md
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""
"Rust をインストールしたら、Rust で動作するようにエディタまたは IDE を設定する"
"必要があります。ほとんどのエディタでは、[rust-analyzer](https://rust-"
"analyzer.github.io/) と通信することでこれを行います。rust-analyzer は、[VS "
"Code](https://code.visualstudio.com/)、[Emacs](https://rust-analyzer.github."
"io/manual.html#emacs)、[Vim / Neovim](https://rust-analyzer.github.io/manual."
"html#vimneovim) など、多くのエディタ向けにオートコンプリート機能と「定義に移"
"動」機能を提供します。[RustRover](https://www.jetbrains.com/rust/) という別"
"の IDE も用意されています。"

#: src/cargo.md
#, fuzzy
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"Debian/Ubuntuを使用している場合、以下のコマンドを使ってcargo、rustのソース"
"コード、[Rust formatter](https://github.com/rust-lang/rustfmt)をインストール"
"します"

#: src/cargo/rust-ecosystem.md
msgid "The Rust Ecosystem"
msgstr "Rust エコシステム"

#: src/cargo/rust-ecosystem.md
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "Rustエコシステムの主要ツールは以下の通りです："

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`： Rustのコンパイラです。`.rs`ファイルをバイナリや他の中間形式に変換し"
"ます。"

#: src/cargo/rust-ecosystem.md
#, fuzzy
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`： Rustのビルドシステム兼パッケージマネージャです。<https://crates.io>"
"でホストされている依存関係をダウンロードし、プロジェクトビルド時に`rustc`に渡"
"します。Cargo に組み込まれたテストランナを使って、ユニットテストを実行するこ"
"ともできます。"

#: src/cargo/rust-ecosystem.md
#, fuzzy
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`： Rustのツールチェーンを管理するためのツールです。`rustc`や`cargo`の"
"インストールやアップデートに使用されます。標準ライブラリのドキュメントをダウ"
"ンロードする事も可能です。また、複数のRustのバージョンがインストールされてい"
"る場合、`rustup`で切り替えが行えます。"

#: src/cargo/rust-ecosystem.md src/hello-world/hello-world.md
#: src/tuples-and-arrays/tuples-and-arrays.md src/references/exclusive.md
#: src/pattern-matching/destructuring.md src/memory-management/move.md
#: src/error-handling/try.md src/android/setup.md src/concurrency/threads.md
#: src/async/async-await.md
msgid "Key points:"
msgstr "要点："

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust言語とコンパイラは、6週間のリリースサイクルを採用しています。新しいリリー"
"スは、古いリリースとの後方互換性を維持しながら、新機能を提供します。"

#: src/cargo/rust-ecosystem.md
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "リリースチャネルは3つあります：「stable」「beta」「nightly」。"

#: src/cargo/rust-ecosystem.md
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"新機能は「nightly」でテストされ、「beta」が6週間毎に「stable」となります。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"依存関係は、代替の [レジストリ](https://doc.rust-lang.org/cargo/reference/"
"registries.html)、git、フォルダなどから解決することもできます。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rustには[editions](https://doc.rust-lang.org/edition-guide/)（エディション）"
"があります：現在のエディションはRust2021です。以前はRust2015とRust2018でし"
"た。"

#: src/cargo/rust-ecosystem.md
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr "エディションでは、後方非互換な変更を加える事ができます。"

#: src/cargo/rust-ecosystem.md
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"コードの破損を防ぐために、エディションはオプトイン方式です：`Cargo.toml`で、"
"クレートに対して適用したいエディションを選択します。"

#: src/cargo/rust-ecosystem.md
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"エコシステムの分断を避けるために、コンパイラは異なるエディションのコードを混"
"在させる事ができます。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"コンパイラを直接使用する事は非常に稀であり、基本的には`cargo`を介します。"

#: src/cargo/rust-ecosystem.md
#, fuzzy
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr "`Cargo`は非常に包括的なツールであり、多くの機能を備えています："

#: src/cargo/rust-ecosystem.md
msgid "Project/package structure"
msgstr "プロジェクト・パッケージの構造管理"

#: src/cargo/rust-ecosystem.md
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)（ワー"
"クスペース）"

#: src/cargo/rust-ecosystem.md
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "開発用とランタイム用の依存関係管理・キャッシュ"

#: src/cargo/rust-ecosystem.md
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)（ビルドスクリプト）"

#: src/cargo/rust-ecosystem.md
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"

#: src/cargo/rust-ecosystem.md
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"[cargo clippy](https://github.com/rust-lang/rust-clippy)などのサブコマンドプ"
"ラグインによる拡張"

#: src/cargo/rust-ecosystem.md
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"詳細は[official Cargo Book](https://doc.rust-lang.org/cargo/)を参照してくださ"
"い。"

#: src/cargo/code-samples.md
msgid "Code Samples in This Training"
msgstr "講座のサンプルコード"

#: src/cargo/code-samples.md
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"本講座は、主にブラウザ内で実行可能な例を使います。こうする事で、セットアップ"
"が容易になり、一貫した開発環境の提供が可能となります。"

#: src/cargo/code-samples.md
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"ただし、できればCargoをインストールしてください： 練習問題で使えると便利で"
"す。また最終日に依存関係を扱う課題を扱いますが、そこではCargoが必要になりま"
"す。"

#: src/cargo/code-samples.md
msgid "The code blocks in this course are fully interactive:"
msgstr "講座のコードブロックはインタラクティブです："

#: src/cargo/code-samples.md src/cargo/running-locally.md
msgid "\"Edit me!\""
msgstr "\"Edit me!\""

#: src/cargo/code-samples.md
msgid "You can use "
msgstr "ボックス内にフォーカスがある状態で"

#: src/cargo/code-samples.md
#, fuzzy
msgid " to execute the code when focus is in the text box."
msgstr "を押すと、コードが実行されます。"

#: src/cargo/code-samples.md
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"ほとんどのサンプルコードは上記のように編集可能ですが、一部だけ以下のような理"
"由から編集不可となっています："

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"講座のページ内に埋め込まれたプレイグラウンドでユニットテストは実行できませ"
"ん。コードを実際のプレイグラウンドで開き、デモンストレーションを行う必要があ"
"ります。"

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"講座のページ内に埋め込まれたプレイグラウンドでは、ページ移動すると状態が失わ"
"れます！故に、受講生はローカル環境や実際のプレイグラウンドを使用して問題を解"
"く必要があります。"

#: src/cargo/running-locally.md
msgid "Running Code Locally with Cargo"
msgstr "Cargoを使ってローカルで実行"

#: src/cargo/running-locally.md
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"コードをローカルで試したい場合、[Rust Bookの手順](https://doc.rust-lang.org/"
"book/ch01-01-installation.html)に従ってRustをインストールしてください。正常に"
"インストールされたら、`rustc`と`cargo`が使えるようになります。最新のstableリ"
"リースのバージョンは以下の通りです："

#: src/cargo/running-locally.md
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"Rust は下位互換性を維持しているため、新しいバージョンを使用することもできま"
"す。"

#: src/cargo/running-locally.md
#, fuzzy
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"次に、本講座の例を参考にしながら、以下の手順に従ってRustのバイナリをビルドし"
"てください："

#: src/cargo/running-locally.md
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "「Copy to clipboard」でコードをコピー。"

#: src/cargo/running-locally.md
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr "`cargo new exercise`で`exercise/`ディレクトリを作成："

#: src/cargo/running-locally.md
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""
"`exercise/`ディレクトリに移動し、`cargo run`でバイナリをビルドして実行："

#: src/cargo/running-locally.md
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"`src/main.rs`のボイラープレートコードを、コピーしたコードで置き換えてくださ"
"い。例えば、前のページの例を使った場合、`src/main.rs`は以下のようになります。"

#: src/cargo/running-locally.md
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "`cargo run`で更新されたバイナリをビルドして実行："

#: src/cargo/running-locally.md
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"`cargo check`でプロジェクトのエラーチェックを行い、`cargo build`でコンパイル"
"だけ（実行はせず）を行います。通常のデバッグビルドでは、生成されたファイルは"
"`target/debug/`に格納されます。最適化されたリリースビルドには`cargo build —"
"release`を使い、ファイルは`target/release/`に格納されます。"

#: src/cargo/running-locally.md
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"プロジェクトに依存関係を追加するには、`Cargo.toml`を編集します。その後、"
"`cargo`コマンドを実行すると、自動的に不足している依存関係がダウンロードされて"
"コンパイルされます。"

#: src/cargo/running-locally.md
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"受講者にCargoのインストールとローカルエディタの使用を勧めてください。通常の開"
"発環境を持つ事で、作業がスムーズになります。"

#: src/welcome-day-1.md
msgid "Welcome to Day 1"
msgstr "Day 1へようこそ"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"「Comprehensive Rust」の初日です。本日は多岐にわたる内容をカバーします："

#: src/welcome-day-1.md
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Rustの基本的な構文： 変数、スカラー型と複合型、列挙型、構造体、参照、関数、メ"
"ソッド。"

#: src/welcome-day-1.md
#, fuzzy
msgid "Types and type inference."
msgstr "型推論"

#: src/welcome-day-1.md
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr "制御フローの構造: ループ、条件など。"

#: src/welcome-day-1.md
msgid "User-defined types: structs and enums."
msgstr "ユーザー定義型: 構造体と列挙型。"

#: src/welcome-day-1.md
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr "パターン マッチング: 列挙型、構造体、配列の分解。"

#: src/welcome-day-1.md src/welcome-day-2.md src/welcome-day-3.md
#: src/welcome-day-4.md
msgid "Schedule"
msgstr "スケジュール"

#: src/welcome-day-1.md src/welcome-day-1-afternoon.md src/welcome-day-2.md
#: src/welcome-day-2-afternoon.md src/welcome-day-3.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4.md
#: src/welcome-day-4-afternoon.md
msgid "In this session:"
msgstr "このセッションの内容:"

#: src/welcome-day-1.md
msgid "[Welcome](./welcome-day-1.md) (5 minutes)"
msgstr "[ようこそ](./welcome-day-1.md)（5 分）"

#: src/welcome-day-1.md
msgid "[Hello, World](./hello-world.md) (20 minutes)"
msgstr "[Hello, World](./hello-world.md)（20 分）"

#: src/welcome-day-1.md
msgid "[Types and Values](./types-and-values.md) (1 hour and 5 minutes)"
msgstr "[型と値](./types-and-values.md)（1 時間 5 分）"

#: src/welcome-day-1.md
msgid "[Control Flow Basics](./control-flow-basics.md) (1 hour)"
msgstr "[制御フローの基本](./control-flow-basics.md)（1 時間）"

#: src/welcome-day-1.md src/welcome-day-2-afternoon.md
msgid "Including 10 minute breaks, this session should take about 3 hours"
msgstr "このセッションの所要時間は、10 分間の休憩を入れて約 3 時間です。"

#: src/welcome-day-1.md
msgid "Please remind the students that:"
msgstr "受講生に伝えてください："

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr "分からない事があれば、最後まで待たずに質問をしてください。"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr ""
"本講座はインタラクティブな形式で行うため、積極的にディスカッションをしてくだ"
"さい！"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"講師の方へ： ディスカッションはなるべく関連性を有する範囲に留めましょう。例え"
"ば、他言語との比較を行う場合には、あくまでもRustとどう違うのかまでを議論の範"
"囲に設定してください。また、バランスの取り方が難しいかもしれませんが、一方的"
"に話すよりもなるべくディスカッションを許容するように心がけてください。"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr "質問があった場合、おそらく将来的に話す内容に触れる事になります。"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"これは全く問題ありません！復習は学びの重要な要素です。スライドはあくまでもサ"
"ポートとして用意されているものであり、ご自身の判断でスキップも可能です。"

#: src/welcome-day-1.md
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""
"1 日目は、他の言語にも共通する Rust の「基本的な」事項を示します。Rust のより"
"高度な部分については、後日説明します。"

#: src/welcome-day-1.md
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""
"教室で教える場合は、ここでスケジュールを確認することをおすすめします。各セグ"
"メントの終わりに演習を行い、休憩を挟んでから答え合わせをしてください。上記の"
"時間配分は、あくまでコースを予定どおりに進めるための目安ですので、必要に応じ"
"て柔軟に調整してください。"

#: src/hello-world.md src/types-and-values.md src/control-flow-basics.md
#: src/tuples-and-arrays.md src/references.md src/user-defined-types.md
#: src/pattern-matching.md src/methods-and-traits.md src/generics.md
#: src/std-types.md src/std-traits.md src/memory-management.md
#: src/smart-pointers.md src/borrowing.md src/slices-and-lifetimes.md
#: src/iterators.md src/modules.md src/testing.md src/error-handling.md
#: src/unsafe-rust.md
msgid "In this segment:"
msgstr "このセグメントの内容:"

#: src/hello-world.md
msgid "[What is Rust?](./hello-world/what-is-rust.md) (10 minutes)"
msgstr "[Rust とは](./hello-world/what-is-rust.md)（10 分）"

#: src/hello-world.md
msgid "[Hello, World](./hello-world/hello-world.md) (5 minutes)"
msgstr "[Hello, World](./hello-world/hello-world.md)（5 分）"

#: src/hello-world.md
msgid "[Benefits of Rust](./hello-world/benefits.md) (3 minutes)"
msgstr "[Rust のメリット](./hello-world/benefits.md)（3 分）"

#: src/hello-world.md
msgid "[Playground](./hello-world/playground.md) (2 minutes)"
msgstr "[プレイグラウンド](./hello-world/playground.md)（2 分）"

#: src/hello-world.md
msgid "This segment should take about 20 minutes"
msgstr "このセグメントの所要時間は約 20 分です"

#: src/hello-world/what-is-rust.md
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rustは[2015年に1.0版がリリース](https://blog.rust-lang.org/2015/05/15/"
"Rust-1.0.html)された新しいプログラミング言語です："

#: src/hello-world/what-is-rust.md
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "RustはC++と同様に、静的にコンパイルされる言語です"

#: src/hello-world/what-is-rust.md
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc`はバックエンドにLLVMを使用しています。"

#: src/hello-world/what-is-rust.md
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rustは多くの[プラットフォームとアーキテクチャ](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html)をサポートしています："

#: src/hello-world/what-is-rust.md
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, …"

#: src/hello-world/what-is-rust.md
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, …"

#: src/hello-world/what-is-rust.md
msgid "Rust is used for a wide range of devices:"
msgstr "Rustは様々なデバイスで使用されています："

#: src/hello-world/what-is-rust.md
msgid "firmware and boot loaders,"
msgstr "ファームウェアやブートローダ、"

#: src/hello-world/what-is-rust.md
msgid "smart displays,"
msgstr "スマートディスプレイ、"

#: src/hello-world/what-is-rust.md
msgid "mobile phones,"
msgstr "携帯電話、"

#: src/hello-world/what-is-rust.md
msgid "desktops,"
msgstr "デスクトップ、"

#: src/hello-world/what-is-rust.md
msgid "servers."
msgstr "サーバ。"

#: src/hello-world/what-is-rust.md
msgid "Rust fits in the same area as C++:"
msgstr "RustとC++が似ているところ:"

#: src/hello-world/what-is-rust.md
msgid "High flexibility."
msgstr "高い柔軟性。"

#: src/hello-world/what-is-rust.md
msgid "High level of control."
msgstr "高度な制御性。"

#: src/hello-world/what-is-rust.md
#, fuzzy
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr "携帯電話のようなデバイスにまでスケールダウンが可能"

#: src/hello-world/what-is-rust.md
msgid "Has no runtime or garbage collection."
msgstr "ランタイムやガベージコレクションがない。"

#: src/hello-world/what-is-rust.md
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr "パフォーマンスを犠牲にせず、信頼性と安全性に焦点を当てている。"

#: src/hello-world/hello-world.md
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"さっそく一番シンプルなプログラムである定番のHello Worldからみてみましょう："

#: src/hello-world/hello-world.md
msgid "\"Hello 🌍!\""
msgstr "\"Hello 🌍!\""

#: src/hello-world/hello-world.md
msgid "What you see:"
msgstr "プログラムの中身："

#: src/hello-world/hello-world.md
msgid "Functions are introduced with `fn`."
msgstr "関数は`fn`で導入されます。"

#: src/hello-world/hello-world.md
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "CやC++と同様に、ブロックは波括弧で囲みます。"

#: src/hello-world/hello-world.md
msgid "The `main` function is the entry point of the program."
msgstr "`main`関数はプログラムのエントリーポイントになります。"

#: src/hello-world/hello-world.md
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rustには衛生的なマクロがあり、`println!`はその一例です。"

#: src/hello-world/hello-world.md
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"Rustの文字列はUTF-8でエンコードされ、どんなUnicode文字でも含む事ができます。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"このスライドの目的は、Rustのコードに慣れてもらう事です。この4日間で大量のRust"
"コードを見る事になるので、馴染みのあるものから始めてみましょう。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"Rustは、C/C++/Java系統の言語によく似ています。Rustは、命令型（関数型ではな"
"く）であり、必須でない限り機能の再発明はしません。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid "Rust is modern with full support for things like Unicode."
msgstr "RustはUnicodeなどにも完全に対応している現代的な言語です。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"Rustで可変長引数を用いたい場合は、マクロを使用します(関数[オーバーロード]"
"(basic-syntax/functions-interlude.md)はありません)。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"マクロが「衛生的 (hygienic)」であるとは、そのマクロが呼び出されるスコープにあ"
"る識別子と、そのマクロ内部の識別子が衝突しないことが保証されていることを言い"
"ます。Rustのマクロは、実際には[部分的にしか衛生的](https://veykril.github.io/"
"tlborm/decl-macros/minutiae/hygiene.html)ではありません。"

#: src/hello-world/hello-world.md
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"Rust はマルチパラダイムです。たとえば、強力な [オブジェクト指向プログラミング"
"機能](https://doc.rust-lang.org/book/ch17-00-oop.html) を備えている一方、非関"
"数型言語であるにもかかわらず、さまざまな [関数的概念](https://doc.rust-lang."
"org/book/ch13-00-functional-features.html) を内包しています。"

#: src/hello-world/benefits.md
msgid "Some unique selling points of Rust:"
msgstr "Rustのユニークなセールスポイントをいくつか紹介します："

#: src/hello-world/benefits.md
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr ""
"_コンパイル時のメモリ安全性_ - クラス全体のメモリのバグをコンパイル時に防止し"
"ます。"

#: src/hello-world/benefits.md
msgid "No uninitialized variables."
msgstr "未初期化の変数がない。"

#: src/hello-world/benefits.md
msgid "No double-frees."
msgstr "二重解放が起きない。"

#: src/hello-world/benefits.md
msgid "No use-after-free."
msgstr "解放済みメモリ使用（use-after-free）がない。"

#: src/hello-world/benefits.md
msgid "No `NULL` pointers."
msgstr "`NULL`（ヌル）ポインタがない。"

#: src/hello-world/benefits.md
msgid "No forgotten locked mutexes."
msgstr "ミューテックス（mutex）のロックの解除忘れがない。"

#: src/hello-world/benefits.md
msgid "No data races between threads."
msgstr "スレッド間でデータ競合しない。"

#: src/hello-world/benefits.md
msgid "No iterator invalidation."
msgstr "イテレータが無効化されない。"

#: src/hello-world/benefits.md
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr ""
"_未定義のランタイム動作がない_ - Rust ステートメントで行われる処理が未規定の"
"まま残ることはありません。"

#: src/hello-world/benefits.md
msgid "Array access is bounds checked."
msgstr "配列へのアクセスには境界チェックが行われる。"

#: src/hello-world/benefits.md
#, fuzzy
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "整数オーバーフローの挙動が定義されている。"

#: src/hello-world/benefits.md
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr ""
"_最新の言語機能_ - 高水準言語に匹敵する表現力があり、人間が使いやすい機能を備"
"えています。"

#: src/hello-world/benefits.md
msgid "Enums and pattern matching."
msgstr "列挙型とパターンマッチング"

#: src/hello-world/benefits.md
msgid "Generics."
msgstr "ジェネリクス"

#: src/hello-world/benefits.md
msgid "No overhead FFI."
msgstr "オーバーヘッドのないFFI"

#: src/hello-world/benefits.md
msgid "Zero-cost abstractions."
msgstr "ゼロコスト抽象化"

#: src/hello-world/benefits.md
msgid "Great compiler errors."
msgstr "優秀なコンパイルエラー。"

#: src/hello-world/benefits.md
msgid "Built-in dependency manager."
msgstr "組み込みの依存関係マネージャ。"

#: src/hello-world/benefits.md
msgid "Built-in support for testing."
msgstr "組み込みのテストサポート。"

#: src/hello-world/benefits.md
msgid "Excellent Language Server Protocol support."
msgstr "Language Server Protocol（LSP）のサポート。"

#: src/hello-world/benefits.md
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr ""
"ここにはあまり時間をかけないでください。これらのポイントについては、後ほど詳"
"しく説明します。"

#: src/hello-world/benefits.md
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"受講者にどの言語の経験があるかを尋ねてください。回答に応じて、Rustのさまざま"
"な特徴を強調することができます："

#: src/hello-world/benefits.md
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"CまたはC++の経験がある場合： Rustは借用チェッカーを介して実行時エラーの一部を"
"排除してくれます。それに加え、CやC++と同等のパフォーマンスを得ることができ、"
"メモリ安全性の問題はありません。さらに、パターンマッチングや組み込みの依存関"
"係管理などの構造要素を含む現代的な言語です。"

#: src/hello-world/benefits.md
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Java、Go、Python、JavaScriptなどの経験がある場合： これらの言語と同様のメモリ"
"安全性と、高水準言語に近い感覚を得ることができます。また、CやC++のように高速"
"かつ予測可能なパフォーマンス（ガベージコレクタがない）を得ることができ、（必"
"要なら）低水準なハードウェアへのアクセスも可能です"

#: src/hello-world/playground.md
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""
"このコースの例や演習には、短い Rust プログラムを簡単に実行できる [Rust プレイ"
"グラウンド](https://play.rust-lang.org/) を使用します。最初の「hello-world」"
"プログラムを実行してみましょう。次のような便利な機能があります。"

#: src/hello-world/playground.md
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr ""
"「Tools」 にある `rustfmt` オプションを使用して、コードを「standard」の形式で"
"フォーマットします。"

#: src/hello-world/playground.md
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""
"Rust には、コードを生成するための主要な「プロファイル」が 2 つあります。1 つ"
"は Debug（追加のランタイムチェックがあり、最適化が少ない）で、もう 1 つは "
"Release（ランタイムチェックが少なく、最適化が多い）です。これらは上部の "
"[Debug] からアクセスできます。"

#: src/hello-world/playground.md
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr ""
"興味がある場合は、「...」 の下にある 「ASM」 を使用すると、生成されたアセンブ"
"リ コードを確認できます。"

#: src/hello-world/playground.md
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""
"受講者が休憩に入ったら、プレイグラウンドを開いていろいろ試してみるよう促しま"
"す。タブを開いたままにして、コースの残りの部分で学習したことを試すようすすめ"
"ましょう。これは、Rust の最適化や生成されたアセンブリについて詳しく知りたい受"
"講者に特に役立ちます。"

#: src/types-and-values.md
msgid "[Variables](./types-and-values/variables.md) (5 minutes)"
msgstr "[変数](./types-and-values/variables.md)（5 分）"

#: src/types-and-values.md
msgid "[Values](./types-and-values/values.md) (10 minutes)"
msgstr "[値](./types-and-values/values.md)（10 分）"

#: src/types-and-values.md
msgid "[Arithmetic](./types-and-values/arithmetic.md) (5 minutes)"
msgstr "[算術](./types-and-values/arithmetic.md)（5 分）"

#: src/types-and-values.md
msgid "[Strings](./types-and-values/strings.md) (10 minutes)"
msgstr "[文字列](./types-and-values/strings.md)（10 分）"

#: src/types-and-values.md
msgid "[Type Inference](./types-and-values/inference.md) (5 minutes)"
msgstr "[型推論](./types-and-values/inference.md)（5 分）"

#: src/types-and-values.md
msgid "[Exercise: Fibonacci](./types-and-values/exercise.md) (30 minutes)"
msgstr "[演習: フィボナッチ](./types-and-values/exercise.md)（30 分）"

#: src/types-and-values.md src/testing.md src/unsafe-rust.md
msgid "This segment should take about 1 hour and 5 minutes"
msgstr "このセグメントの所要時間は約 1 時間 5 分です"

#: src/types-and-values/variables.md
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr ""
"Rust は静的型付けによって型安全性を提供します。変数のバインディングは `let` "
"を使用して行います。"

#: src/types-and-values/variables.md src/control-flow-basics/loops.md
#: src/control-flow-basics/break-continue.md
#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"x: {x}\""
msgstr "\"x: {x}\""

#: src/types-and-values/variables.md
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"

#: src/types-and-values/variables.md
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""
"`x = 20` のコメント化を解除して、変数がデフォルトで不変であることを示します。"
"変更を許可するには、`mut` キーワードを追加します。"

#: src/types-and-values/variables.md
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""
"ここでの `i32` は変数の型です。これはコンパイル時に指定する必要がありますが、"
"多くの場合、プログラマーは型推論（後述）を使用することでこれを省略できます。"

#: src/types-and-values/values.md
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr "基本的な組み込み型と、各型のリテラル値の構文を以下に示します。"

#: src/types-and-values/values.md src/tuples-and-arrays/tuples-and-arrays.md
#: src/unsafe-rust/exercise.md
msgid "Types"
msgstr "型"

#: src/types-and-values/values.md src/tuples-and-arrays/tuples-and-arrays.md
msgid "Literals"
msgstr "リテラル"

#: src/types-and-values/values.md
msgid "Signed integers"
msgstr "符号付き整数"

#: src/types-and-values/values.md
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`、`i16`、`i32`、`i64`、`i128`、`isize`"

#: src/types-and-values/values.md
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`、`0`、`1_000`、`123_i64`"

#: src/types-and-values/values.md
msgid "Unsigned integers"
msgstr "符号なし整数"

#: src/types-and-values/values.md
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`、`u16`、`u32`、`u64`、`u128`、`usize`"

#: src/types-and-values/values.md
msgid "`0`, `123`, `10_u16`"
msgstr "`0`、`123`、`10_u16`"

#: src/types-and-values/values.md
msgid "Floating point numbers"
msgstr "浮動小数点数"

#: src/types-and-values/values.md
msgid "`f32`, `f64`"
msgstr "`f32`、`f64`"

#: src/types-and-values/values.md
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`、`-10.0e20`、`2_f32`"

#: src/types-and-values/values.md
msgid "Unicode scalar values"
msgstr "Unicode スカラー値"

#: src/types-and-values/values.md
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md
msgid "`'a'`, `'α'`, `'∞'`"
msgstr "`'a'`、`'α'`、`'∞'`"

#: src/types-and-values/values.md
msgid "Booleans"
msgstr "ブール値"

#: src/types-and-values/values.md
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md
msgid "`true`, `false`"
msgstr "`true`、`false`"

#: src/types-and-values/values.md
msgid "The types have widths as follows:"
msgstr "各型の幅は次のとおりです。"

#: src/types-and-values/values.md
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`、`uN`、`fN` は _N_ ビット幅です。"

#: src/types-and-values/values.md
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` と `usize` はポインタの幅です。"

#: src/types-and-values/values.md
msgid "`char` is 32 bits wide,"
msgstr "`char` は 32 ビット幅です。"

#: src/types-and-values/values.md
msgid "`bool` is 8 bits wide."
msgstr "`bool` は 8 ビット幅です。"

#: src/types-and-values/values.md
msgid "There are a few syntaxes which are not shown above:"
msgstr "上記には示されていない構文もあります。"

#: src/types-and-values/values.md
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"数字のアンダースコアはすべて省略できます。アンダースコアは読みやすくするため"
"にのみ使用します。そのため、`1_000` は `1000`（または `10_00`）、`123_i64` "
"は `123i64` と記述できます。"

#: src/types-and-values/arithmetic.md
msgid "\"result: {}\""
msgstr "\"result: {}\""

#: src/types-and-values/arithmetic.md
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""
"`main` 以外の関数が出てきたのは今回が初めてですが、その意味は明確です。つま"
"り、3 つの整数を取り、1 つの整数を返します。関数については、後で詳しく説明し"
"ます。"

#: src/types-and-values/arithmetic.md
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr "算術は他の言語とよく似ており、優先順位も類似しています。"

#: src/types-and-values/arithmetic.md
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do different things on different platforms or "
"compilers. In Rust, it's defined."
msgstr ""
"整数オーバーフローはどうでしょうか。C と C++ では、 _符号付き_ 整数のオーバー"
"フローは実際には未定義であり、プラットフォームやコンパイラによって動作が異な"
"る場合があります。Rust では、整数オーバーフローが定義されています。"

#: src/types-and-values/arithmetic.md
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""
"`i32` を `i16` に変更して、整数オーバーフローを確認します。これは、デバッグビ"
"ルドではパニックになり（チェックされ）、リリースビルドではラップされます。"
"オーバーフロー、飽和、キャリーなどのオプションもあり、メソッド構文を使用して"
"これらのオプションにアクセスします（例: `(a * b).saturating_add(b * c)."
"saturating_add(c * a)`）。"

#: src/types-and-values/arithmetic.md
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""
"実際には、コンパイラは定数式のオーバーフローを検出します。この例で別の関数が"
"必要になるのはそのためです。"

#: src/types-and-values/strings.md
msgid ""
"Rust has two types to represent strings, both of which will be covered in "
"more depth later. Both _always_ store UTF-8 encoded strings."
msgstr ""
"Rust には文字列を表す 2 つの型があります。どちらも後ほど詳しく説明します。両"
"方とも、 _常に_ UTF-8 でエンコードされた文字列を格納します。"

#: src/types-and-values/strings.md
msgid "`String` - a modifiable, owned string."
msgstr "`String` - 変更可能で、所有権をもつ文字列。"

#: src/types-and-values/strings.md
msgid "`&str` - a read-only string. String literals have this type."
msgstr "`&str` - 読み取り専用の文字列。文字列リテラルはこの型です。"

#: src/types-and-values/strings.md
msgid "\"Greetings\""
msgstr "\"Greetings\""

#: src/types-and-values/strings.md
msgid "\"🪐\""
msgstr "\"🪐\""

#: src/types-and-values/strings.md
msgid "\", \""
msgstr "\", \""

#: src/types-and-values/strings.md
msgid "\"final sentence: {}\""
msgstr "\"final sentence: {}\""

#: src/types-and-values/strings.md src/async/control-flow/join.md
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/types-and-values/strings.md
msgid "//println!(\"{:?}\", &sentence[12..13]);\n"
msgstr "//println!(\"{:?}\", &sentence[12..13]);\n"

#: src/types-and-values/strings.md
msgid ""
"This slide introduces strings. Everything here will be covered in more depth "
"later, but this is enough for subsequent slides and exercises to use strings."
msgstr ""
"このスライドでは文字列を紹介します。ここで取り上げた内容については後ほど詳し"
"く説明しますが、以降のスライドや演習で文字列を使用するにはこれで十分です。"

#: src/types-and-values/strings.md
msgid "Invalid UTF-8 in a string is UB, and this not allowed in safe Rust."
msgstr "文字列内の無効な UTF-8 は UB であり、Safe Rust では許可されません。"

#: src/types-and-values/strings.md
msgid ""
"`String` is a user-defined type with a constructor (`::new()`) and methods "
"like `s.push_str(..)`."
msgstr ""
"`String` は、コンストラクタ（`::new()` と `s.push_str(..)` などのメソッド）を"
"持つユーザー定義型です。"

#: src/types-and-values/strings.md
msgid ""
"The `&` in `&str` indicates that this is a reference. We will cover "
"references later, so for now just think of `&str` as a unit meaning \"a read-"
"only string\"."
msgstr ""
"`&str` 内の `&` は、これが参照であることを示します。参照については後ほど説明"
"しますので、ここでは `&str` を、「読み取り専用の文字列」を意味する単位と考え"
"てください。"

#: src/types-and-values/strings.md
msgid ""
"The commented-out line is indexing into the string by byte position. "
"`12..13` does not end on a character boundary, so the program panics. Adjust "
"it to a range that does, based on the error message."
msgstr ""
"コメントアウトされた行は、バイト位置で文字列をインデックス化しています。"
"`12..13` は文字境界で終わっていないため、プログラムはパニックします。エラー "
"メッセージに基づいて、適切な範囲に調整してください。"

#: src/types-and-values/strings.md
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"未加工の文字列を使用すると、エスケープを無効にして `&str` 値を作成できます"
"（`r\"\\n\" == \"\\\\n\"`）。二重引用符を埋め込むには、引用符の両側に同量の "
"`#` を使用します。"

#: src/types-and-values/inference.md
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Rust は、どのように変数が _使用されているか_ を確認することで、型を判別しま"
"す。"

#: src/types-and-values/inference.md
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"このスライドは、変数の宣言と使用方法による制約に基づいて、Rust コンパイラが型"
"を推測する仕組みを示しています。"

#: src/types-and-values/inference.md
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"このように宣言された変数は、どのようなデータも保持できる動的な「任意の型」で"
"はない、という点を強調することが非常に重要です。このような宣言によって生成さ"
"れたマシンコードは、型の明示的な宣言と同一です。コンパイラが代わりに作業を行"
"い、より簡潔なコードの作成を支援します。"

#: src/types-and-values/inference.md
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""
"整数リテラルの型に制約がない場合、Rust はデフォルトで `i32` を使用します。こ"
"れは、エラー メッセージに `{integer}` として表示されることがあります。同様"
"に、浮動小数点リテラルはデフォルトで `f64` になります。"

#: src/types-and-values/inference.md
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr "// エラー: `{float} == {integer}` の実装がありません\n"

#: src/types-and-values/exercise.md
msgid ""
"The first and second Fibonacci numbers are both `1`. For n>2, the n'th "
"Fibonacci number is calculated recursively as the sum of the n-1'th and "
"n-2'th Fibonacci numbers."
msgstr ""
"1 つ目と 2 つ目のフィボナッチ数はどちらも `1` です。n>2 の場合、n 番目のフィ"
"ボナッチ数は、n-1 番目のフィボナッチ数と n-2 番目のフィボナッチ数の合計として"
"再帰的に計算されます。"

#: src/types-and-values/exercise.md
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr ""
"n 番目のフィボナッチ数を計算する関数 `fib(n)` を記述します。この関数はいつパ"
"ニックするでしょうか。"

#: src/types-and-values/exercise.md
msgid "// The base case.\n"
msgstr "// ベースケース。\n"

#: src/types-and-values/exercise.md src/control-flow-basics/exercise.md
msgid "\"Implement this\""
msgstr "\"ここを実装してください\""

#: src/types-and-values/exercise.md
msgid "// The recursive case.\n"
msgstr "// 再帰的なケース。\n"

#: src/types-and-values/exercise.md src/types-and-values/solution.md
msgid "\"fib(n) = {}\""
msgstr "\"fib(n) = {}\""

#: src/control-flow-basics.md
msgid "[Conditionals](./control-flow-basics/conditionals.md) (5 minutes)"
msgstr "[条件文](./control-flow-basics/conditionals.md)（5 分）"

#: src/control-flow-basics.md
msgid "[Loops](./control-flow-basics/loops.md) (5 minutes)"
msgstr "[ループ](./control-flow-basics/loops.md)（5 分）"

#: src/control-flow-basics.md
msgid ""
"[break and continue](./control-flow-basics/break-continue.md) (5 minutes)"
msgstr "[break と continue](./control-flow-basics/break-continue.md)（5 分）"

#: src/control-flow-basics.md
msgid ""
"[Blocks and Scopes](./control-flow-basics/blocks-and-scopes.md) (10 minutes)"
msgstr ""
"[ブロックとスコープ](./control-flow-basics/blocks-and-scopes.md)（10 分）"

#: src/control-flow-basics.md
msgid "[Functions](./control-flow-basics/functions.md) (3 minutes)"
msgstr "[関数](./control-flow-basics/functions.md)（3 分）"

#: src/control-flow-basics.md
msgid "[Macros](./control-flow-basics/macros.md) (2 minutes)"
msgstr "[マクロ](./control-flow-basics/macros.md)（2 分）"

#: src/control-flow-basics.md
msgid ""
"[Exercise: Collatz Sequence](./control-flow-basics/exercise.md) (30 minutes)"
msgstr "[演習: コラッツ数列](./control-flow-basics/exercise.md)（30 分）"

#: src/control-flow-basics.md src/tuples-and-arrays.md src/borrowing.md
msgid "This segment should take about 1 hour"
msgstr "このセグメントの所要時間は約 1 時間です"

#: src/control-flow-basics/conditionals.md
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Rust の構文の多くは、C、C++、Java で見覚えがあるでしょう。"

#: src/control-flow-basics/conditionals.md
#, fuzzy
msgid "Blocks are delimited by curly braces."
msgstr "CやC++と同様に、ブロックは波括弧で囲みます。"

#: src/control-flow-basics/conditionals.md
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr ""
"行コメントは `//` で始まり、ブロック コメントは `/* ... */` で区切られます。"

#: src/control-flow-basics/conditionals.md
msgid "Keywords like `if` and `while` work the same."
msgstr "`if` や `while` などのキーワードの動作は同じです。"

#: src/control-flow-basics/conditionals.md
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr "変数の代入は `=` で行われ、比較は `==` で行われます。"

#: src/control-flow-basics/conditionals.md
msgid "`if` expressions"
msgstr "`if` 式"

#: src/control-flow-basics/conditionals.md
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"Rust の [`if` 式](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-expressions) は、他の言語における `if` 文と全く同じように使えます。"

#: src/control-flow-basics/conditionals.md
msgid "\"small\""
msgstr "\"small\""

#: src/control-flow-basics/conditionals.md
msgid "\"biggish\""
msgstr "\"biggish\""

#: src/control-flow-basics/conditionals.md
msgid "\"huge\""
msgstr "\"huge\""

#: src/control-flow-basics/conditionals.md
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"さらに、`if` を式としても用いることができます。それぞれのブロックにある最後の"
"式が、`if` 式の値となります。"

#: src/control-flow-basics/conditionals.md
msgid "\"large\""
msgstr "\"large\""

#: src/control-flow-basics/conditionals.md
msgid "\"number size: {}\""
msgstr "\"number size: {}\""

#: src/control-flow-basics/conditionals.md
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"`if` は式であるため、1 つの決まった型を持たなくてはなりません。したがって、"
"`if` 式の分岐ブロックは同一の型を持つ必要があります。2 つ目の例において、"
"`x / 2` のあとに `;` を付け加えると何が起こるでしょうか。"

#: src/control-flow-basics/conditionals.md
msgid ""
"When `if` is used in an expression, the expression must have a `;` to "
"separate it from the next statement. Remove the `;` before `println!` to see "
"the compiler error."
msgstr ""
"式で `if` を使用する場合、次のステートメントと区切るために、式に `;` を含める"
"必要があります。`println!` の前にある `;` を削除すると、コンパイラ エラーが表"
"示されます。"

#: src/control-flow-basics/loops.md
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr ""
"Rust には、`while`、`loop`、`for` の 3 つのループ キーワードがあります。"

#: src/control-flow-basics/loops.md
msgid "`while`"
msgstr "`while`"

#: src/control-flow-basics/loops.md
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"[`while` キーワード](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) は、他の言語における `while` と非常によく似た働き"
"をします。"

#: src/control-flow-basics/loops.md
msgid "\"Final x: {x}\""
msgstr "\"Final x: {x}\""

#: src/control-flow-basics/loops.md
msgid "`for`"
msgstr "`for`"

#: src/control-flow-basics/loops.md
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values:"
msgstr ""
"[`for` ループ](https://doc.rust-lang.org/std/keyword.for.html) は、値の範囲を"
"反復処理します。"

#: src/control-flow-basics/loops.md
msgid "`loop`"
msgstr "`loop`"

#: src/control-flow-basics/loops.md
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"[`loop` ステートメント](https://doc.rust-lang.org/std/keyword.loop.html) は、"
"`break` まで永久にループするだけです。"

#: src/control-flow-basics/loops.md
msgid "\"{i}\""
msgstr "\"{i}\""

#: src/control-flow-basics/loops.md
msgid ""
"We will discuss iteration later; for now, just stick to range expressions."
msgstr ""
"反復処理については後で説明しますので、ここでは範囲式だけに注目してください。"

#: src/control-flow-basics/loops.md
msgid ""
"Note that the `for` loop only iterates to `4`. Show the `1..=5` syntax for "
"an inclusive range."
msgstr ""
"なお、この `for` ループは `4` までしか反復処理しません。5 を範囲に含める場合"
"の構文は `1..=5` であることを示します。"

#: src/control-flow-basics/break-continue.md
#, fuzzy
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). For "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"ループから早く抜け出したい場合は [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions) を使用してください。"

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"次のイテレーションをすぐさま開始したい場合は [`continue`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#continue-expressions) を使用し"
"てください。"

#: src/control-flow-basics/break-continue.md
msgid "\"{result}\""
msgstr "\"{result}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"`continue` と `break` はオプションでラベル引数を取ることができます。ラベルは"
"ネストしたループから抜け出すために使われます。"

#: src/control-flow-basics/break-continue.md
msgid "\"x: {x}, i: {i}\""
msgstr "\"x: {x}, i: {i}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"上の例では、内側のループを 3 回イテレーションしたのちに外側のループを抜けるこ"
"とになります。"

#: src/control-flow-basics/break-continue.md
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"注意が必要なのは、`loop` が唯一、非自明な値を返すことができるループ構造である"
"という点です。これは、`loop` が少なくとも一度は必ず実行されることが保証されて"
"いるからです（これに対して、while や for ループは必ずしも実行されるわけではあ"
"りません）。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks"
msgstr "コードブロック"

#: src/control-flow-basics/blocks-and-scopes.md
#, fuzzy
msgid ""
"A block in Rust contains a sequence of expressions, enclosed by braces `{}`. "
"Each block has a value and a type, which are those of the last expression of "
"the block:"
msgstr ""
"Rust におけるブロックの中にはいくつかの式が存在します。それぞれのブロックは値"
"と型を持っており、ブロックの値や型はそのブロック内にある最後の式の値や型と一"
"致します。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"y: {y}\""
msgstr "\"y: {y}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"最後の式が `;` で終了した場合、ブロック全体の値と型は `()` になります。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Scopes and Shadowing"
msgstr "スコープとシャドーイング"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "A variable's scope is limited to the enclosing block."
msgstr "変数のスコープは、囲まれたブロック内に限定されます。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"外側のスコープの変数と、同じスコープの変数の両方をシャドーイングできます。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"before: {a}\""
msgstr "\"before: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md src/std-traits/from-and-into.md
#: src/slices-and-lifetimes/solution.md
msgid "\"hello\""
msgstr "\"hello\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"inner scope: {a}\""
msgstr "\"inner scope: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"shadowed in inner scope: {a}\""
msgstr "\"shadowed in inner scope: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"after: {a}\""
msgstr "\"after: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"ブロック内にある最後の行を変更することによって、ブロック全体の値が変わること"
"が分かります。例えば、行末のセミコロンを追加/削除したり、`return` を使用した"
"りすることで、ブロックの値は変化します。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""
"最後の例の内側のブロックに `b` を追加し、そのブロックの外側でアクセスを試みる"
"ことで、変数のスコープが制限されていることを示します。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variable's memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"シャドーイング後は両方の変数のメモリ位置が同時に存在するため、シャドーイング"
"はミューテーションとは異なります。どちらも、コードで使用する場所に応じて同じ"
"名前で使用できます。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "A shadowing variable can have a different type."
msgstr "シャドーイング変数の型はさまざまです。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"シャドーイングは一見わかりにくいように見えますが、`.unwrap()` の後の値を保持"
"する場合に便利です。"

#: src/control-flow-basics/functions.md
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"宣言パラメータの後には型（一部のプログラミング言語と逆）、戻り値の型が続きま"
"す。"

#: src/control-flow-basics/functions.md
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"関数本体（または任意のブロック）内の最後の式が戻り値になります。式の末尾の `;"
"` を省略します。`return` キーワードは早期リターンに使用できますが、関数の最後"
"は「裸の値」の形式にするのが慣用的です（`return` を使用するには `gcd` をリ"
"ファクタリングします）。"

#: src/control-flow-basics/functions.md
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"戻り値がなく、'unit type'、`()` を返す関数もあります。`-> ()` の戻り値の型が"
"省略されている場合、コンパイラはこれを推測します。"

#: src/control-flow-basics/functions.md
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr "オーバーロードはサポートされていません。各関数の実装は 1 つです。"

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr ""
"常に固定数のパラメータを受け取ります。デフォルトの引数はサポートされていませ"
"ん。マクロを使用して可変関数をサポートできます。"

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr ""
"常に 1 つのパラメータ型セットを受け取ります。これらの型は汎用にすることもでき"
"ますが、これについては後で説明します。"

#: src/control-flow-basics/macros.md
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""
"マクロはコンパイル時に Rust コードに展開され、可変長引数を取ることができま"
"す。これらは末尾の `!` で区別されます。Rust 標準ライブラリには、各種の便利な"
"マクロが含まれています。"

#: src/control-flow-basics/macros.md
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr ""
"`println!(format, ..)`: [`std::fmt`](https://doc.rust-lang.org/std/fmt/index."
"html) で説明されている書式を適用して、1 行を標準出力に出力します。"

#: src/control-flow-basics/macros.md
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""
"`format!(format, ..)`: `println!` と同様に機能しますが、結果を文字列として返"
"します。"

#: src/control-flow-basics/macros.md
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr "`dbg!(expression)`: 式の値をログに記録して返します。"

#: src/control-flow-basics/macros.md
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr ""
"`todo!()`: 一部のコードに未実装のマークを付けます。実行するとパニックが発生し"
"ます。"

#: src/control-flow-basics/macros.md
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""
"`unreachable!()`: コードの一部をアクセス不能としてマークします。実行するとパ"
"ニックが発生します。"

#: src/control-flow-basics/macros.md
msgid "\"{n}! = {}\""
msgstr "\"{n}! = {}\""

#: src/control-flow-basics/macros.md
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""
"このセクションの要点は、マクロの一般的な利便性と、その使用方法を示すことにあ"
"ります。マクロとして定義されている理由と、展開先は特に重要ではありません。"

#: src/control-flow-basics/macros.md
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr ""
"マクロの定義についてはコースでは説明しませんが、後のセクションで導出マクロの"
"使用について説明します。"

#: src/control-flow-basics/exercise.md
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n"
msgstr ""
"[コラッツ数列](https://en.wikipedia.org/wiki/Collatz_conjecture) は、ゼロより"
"大きい任意の n"

#: src/control-flow-basics/exercise.md
msgid "1"
msgstr "1"

#: src/control-flow-basics/exercise.md
msgid " greater than zero:"
msgstr "  に対して、次のように定義されます。"

#: src/control-flow-basics/exercise.md
msgid "If _n"
msgstr "_n"

#: src/control-flow-basics/exercise.md
msgid "i"
msgstr "i"

#: src/control-flow-basics/exercise.md
msgid "_ is 1, then the sequence terminates at _n"
msgstr "_ が 1 の場合、数列は _n"

#: src/control-flow-basics/exercise.md
msgid "_."
msgstr "_で終了します。"

#: src/control-flow-basics/exercise.md
msgid "_ is even, then _n"
msgstr "_ が偶数の場合、_n"

#: src/control-flow-basics/exercise.md
msgid "i+1"
msgstr "i+1"

#: src/control-flow-basics/exercise.md
msgid " = n"
msgstr " = n"

#: src/control-flow-basics/exercise.md
msgid " / 2_."
msgstr " / 2_ になります。"

#: src/control-flow-basics/exercise.md
msgid "_ is odd, then _n"
msgstr "_ が奇数の場合、_n"

#: src/control-flow-basics/exercise.md
msgid " = 3 * n"
msgstr " = 3 * n"

#: src/control-flow-basics/exercise.md
msgid " + 1_."
msgstr " + 1_ になります。"

#: src/control-flow-basics/exercise.md
msgid "For example, beginning with _n"
msgstr "たとえば、_n"

#: src/control-flow-basics/exercise.md
msgid "_ = 3:"
msgstr "_ = 3 で始まる場合は以下のようになります。"

#: src/control-flow-basics/exercise.md
msgid "3 is odd, so _n"
msgstr "3 は奇数なので、_n"

#: src/control-flow-basics/exercise.md
msgid "2"
msgstr "2"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 3 + 1 = 10;"
msgstr "_ = 3 * 3 + 1 = 10 になります。"

#: src/control-flow-basics/exercise.md
msgid "10 is even, so _n"
msgstr "10 は偶数なので、_n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "3"
msgstr "3"

#: src/control-flow-basics/exercise.md
msgid "_ = 10 / 2 = 5;"
msgstr "_ = 10 / 2 = 5 になります。"

#: src/control-flow-basics/exercise.md
msgid "5 is odd, so _n"
msgstr "5 は奇数なので、_n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "4"
msgstr "4"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 5 + 1 = 16;"
msgstr "_ = 3 * 5 + 1 = 16 になります。"

#: src/control-flow-basics/exercise.md
msgid "16 is even, so _n"
msgstr "16 は偶数なので、_n"

#: src/control-flow-basics/exercise.md
msgid "5"
msgstr "5"

#: src/control-flow-basics/exercise.md
msgid "_ = 16 / 2 = 8;"
msgstr "_ = 16 / 2 = 8 になります。"

#: src/control-flow-basics/exercise.md
msgid "8 is even, so _n"
msgstr "8 は偶数なので、_n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "6"
msgstr "6"

#: src/control-flow-basics/exercise.md
msgid "_ = 8 / 2 = 4;"
msgstr "_ = 8 / 2 = 4 になります。"

#: src/control-flow-basics/exercise.md
msgid "4 is even, so _n"
msgstr "4 は偶数なので、_n"

#: src/control-flow-basics/exercise.md
msgid "7"
msgstr "7"

#: src/control-flow-basics/exercise.md
msgid "_ = 4 / 2 = 2;"
msgstr "_ = 4 / 2 = 2 になります。"

#: src/control-flow-basics/exercise.md
msgid "2 is even, so _n"
msgstr "2 は偶数なので、_n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "8"
msgstr "8"

#: src/control-flow-basics/exercise.md
msgid "_ = 1; and"
msgstr "_ = 1 になります。"

#: src/control-flow-basics/exercise.md
msgid "the sequence terminates."
msgstr "数列は終了します。"

#: src/control-flow-basics/exercise.md
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr ""
"任意の初期値 `n` に対するコラッツ数列の長さを計算する関数を作成します。"

#: src/control-flow-basics/exercise.md src/control-flow-basics/solution.md
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr "/// `n` から始まるコラッツ数列の長さを決定。\n"

#: src/control-flow-basics/solution.md src/concurrency/scoped-threads.md
msgid "\"Length: {}\""
msgstr "\"Length: {}\""

#: src/welcome-day-1-afternoon.md src/welcome-day-2-afternoon.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4-afternoon.md
msgid "Welcome Back"
msgstr "おかえり"

#: src/welcome-day-1-afternoon.md
msgid "[Tuples and Arrays](./tuples-and-arrays.md) (1 hour)"
msgstr "[タプルと配列](./tuples-and-arrays.md)（1 時間）"

#: src/welcome-day-1-afternoon.md
msgid "[References](./references.md) (50 minutes)"
msgstr "[参照](./references.md)（50 分）"

#: src/welcome-day-1-afternoon.md
msgid "[User-Defined Types](./user-defined-types.md) (50 minutes)"
msgstr "[ユーザー定義型](./user-defined-types.md)（50 分）"

#: src/welcome-day-1-afternoon.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 55 "
"minutes"
msgstr "このセッションの所要時間は、10 分間の休憩を入れて約 2 時間 55 分です。"

#: src/tuples-and-arrays.md
msgid ""
"[Tuples and Arrays](./tuples-and-arrays/tuples-and-arrays.md) (10 minutes)"
msgstr "[タプルと配列](./tuples-and-arrays/tuples-and-arrays.md)（10 分）"

#: src/tuples-and-arrays.md
msgid "[Array Iteration](./tuples-and-arrays/iteration.md) (3 minutes)"
msgstr "[配列の反復処理](./tuples-and-arrays/iteration.md)（3 分）"

#: src/tuples-and-arrays.md
msgid "[Pattern Matching](./tuples-and-arrays/match.md) (10 minutes)"
msgstr "[パターン マッチング](./tuples-and-arrays/match.md)（10 分）"

#: src/tuples-and-arrays.md
msgid "[Destructuring](./tuples-and-arrays/destructuring.md) (5 minutes)"
msgstr "[分解](./tuples-and-arrays/destructuring.md)（5 分）"

#: src/tuples-and-arrays.md
msgid "[Exercise: Nested Arrays](./tuples-and-arrays/exercise.md) (30 minutes)"
msgstr "[演習: ネストされた配列](./tuples-and-arrays/exercise.md)（30 分）"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Tuples and arrays are the first \"compound\" types we have seen. All "
"elements of an array have the same type, while tuples can accommodate "
"different types. Both types have a size fixed at compile time."
msgstr ""
"タプルと配列は、このコースで初めて扱う「複合」型です。配列のすべての要素の型"
"は同じですが、タプルは異なる型に対応できます。どちらの型もコンパイル時にサイ"
"ズが固定されます。"

#: src/tuples-and-arrays/tuples-and-arrays.md
#: src/tuples-and-arrays/destructuring.md
msgid "Arrays"
msgstr "配列"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`[T; N]`"
msgstr "`[T; N]`"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr "`[20, 30, 40]`、`[0; 3]`"

#: src/tuples-and-arrays/tuples-and-arrays.md
#: src/tuples-and-arrays/destructuring.md
msgid "Tuples"
msgstr "タプル"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr "`()`、`(T,)`、`(T1, T2)`、..."

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr "`()`、`('x',)`、`('x', 1.2)`、..."

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Array assignment and access:"
msgstr "配列の代入とアクセス:"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuple assignment and access:"
msgstr "タプルの代入とアクセス:"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Arrays:"
msgstr "配列:"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"配列型 `[T; N]`には、同じ型 `T` の `N`（コンパイル時定数）個の要素が保持され"
"ます。なお、配列の長さはその型の一部分です。つまり、`[u8; 3]` と `[u8; 4]` "
"は 2 つの異なる型とみなされます。スライス（サイズが実行時に決定される）につい"
"ては後で説明します。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""
"境界外の配列要素にアクセスしてみてください。配列アクセスは実行時にチェックさ"
"れます。Rust では通常、これらのチェックを最適化により除去できます（Unsafe "
"Rust を使用することで回避できます）。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "We can use literals to assign values to arrays."
msgstr "リテラルを使用して配列に値を代入することができます。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"`println!` マクロは、`?` 形式のパラメータを使用してデバッグ実装を要求します。"
"つまり、`{}` はデフォルトの出力を、`{:?}` はデバッグ出力を提供します。整数や"
"文字列などの型はデフォルトの出力を実装しますが、配列はデバッグ出力のみを実装"
"します。そのため、ここではデバッグ出力を使用する必要があります。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"`#` を追加すると（例: `{a:#?}`）、読みやすい「プリティ プリント」形式が呼び出"
"されます。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuples:"
msgstr "タプル:"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Like arrays, tuples have a fixed length."
msgstr "配列と同様に、タプルの長さは固定されています。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuples group together values of different types into a compound type."
msgstr "タプルは、異なる型の値を複合型にグループ化します。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""
"タプルのフィールドには、ピリオドと値のインデックス（例: `t.0`、`t.1`）でアク"
"セスできます。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type --- that is to say both the type and "
"its value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide."
msgstr ""
"空のタプル `()` は、「ユニット型」とも呼ばれます。これは型であるとともに、そ"
"の型で唯一の有効な値です。つまり、型とその値の両方が `()` として表現されま"
"す。以降のスライドで説明するように、これは関数や式に戻り値がないことを示す場"
"合などに使用されます。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"You can think of it as `void` that can be familiar to you from other "
"programming languages."
msgstr ""
"これは、他のプログラミング言語で馴染みのある `void` と考えることができます。"

#: src/tuples-and-arrays/iteration.md
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr ""
"for ステートメントでは、配列の反復処理がサポートされています（タプルはサポー"
"トされていません）。"

#: src/tuples-and-arrays/iteration.md
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr ""
"この機能は `IntoIterator` トレイトを使用しますが、これはまだ説明していませ"
"ん。"

#: src/tuples-and-arrays/iteration.md
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked while, debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""
"ここでは `assert_ne!` マクロが新たに加わっていますが、他にも `assert_eq! マク"
"ロと`assert!` マクロがあります。これらは常にチェックされますが、"
"`debug_assert!` などのデバッグ専用の派生ツールは、リリースビルドでは何もコン"
"パイルされません。"

#: src/tuples-and-arrays/match.md
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"`match` キーワードを使用すると、1 つ以上のパターンに対して値を照合できます。"
"上から順に照合が行われ、最初に一致したパターンのみが実行されます。"

#: src/tuples-and-arrays/match.md
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "C や C++ の `switch` と同様に、パターンには単純な値を指定できます。"

#: src/tuples-and-arrays/match.md
msgid "'x'"
msgstr "'x'"

#: src/tuples-and-arrays/match.md
msgid "'q'"
msgstr "'q'"

#: src/tuples-and-arrays/match.md
msgid "\"Quitting\""
msgstr "\"Quitting\""

#: src/tuples-and-arrays/match.md src/std-traits/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'a'"
msgstr "'a'"

#: src/tuples-and-arrays/match.md
msgid "'s'"
msgstr "'s'"

#: src/tuples-and-arrays/match.md
msgid "'w'"
msgstr "'w'"

#: src/tuples-and-arrays/match.md
msgid "'d'"
msgstr "'d'"

#: src/tuples-and-arrays/match.md
msgid "\"Moving around\""
msgstr "\"Moving around\""

#: src/tuples-and-arrays/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'0'"
msgstr "'0'"

#: src/tuples-and-arrays/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'9'"
msgstr "'9'"

#: src/tuples-and-arrays/match.md
msgid "\"Number input\""
msgstr "\"Number input\""

#: src/tuples-and-arrays/match.md
msgid "\"Lowercase: {key}\""
msgstr "\"Lowercase: {key}\""

#: src/tuples-and-arrays/match.md
msgid "\"Something else\""
msgstr "\"Something else\""

#: src/tuples-and-arrays/match.md
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be irrefutable, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""
"`_` パターンは、任意の値に一致するワイルドカード パターンです。式は論駁不可能"
"でなければなりません。つまり、あらゆる可能性をカバーする必要があるため、最後"
"のキャッチオール ケースとして `_` がよく使用されます。"

#: src/tuples-and-arrays/match.md
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"一致を式として使用できます。`if` と同様に、各マッチアームは同じ型にする必要が"
"あります。型は、ブロックの最後の式です（存在する場合）。上記の例では、型は "
"`()` です。"

#: src/tuples-and-arrays/match.md
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr ""
"パターンの変数（この例では `key`）により、マッチアーム内で使用できるバイン"
"ディングが作成されます。"

#: src/tuples-and-arrays/match.md
msgid "A match guard causes the arm to match only if the condition is true."
msgstr "マッチガードにより、条件が true の場合にのみアームが一致します。"

#: src/tuples-and-arrays/match.md src/user-defined-types/named-structs.md
#: src/user-defined-types/enums.md src/methods-and-traits/methods.md
msgid "Key Points:"
msgstr "キーポイント: "

#: src/tuples-and-arrays/match.md
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr "特定の文字がパターンでどのように使用されるかを説明します。"

#: src/tuples-and-arrays/match.md
msgid "`|` as an `or`"
msgstr "`|` を `or` として指定する"

#: src/tuples-and-arrays/match.md
msgid "`..` can expand as much as it needs to be"
msgstr "`..` は必要に応じて展開できる"

#: src/tuples-and-arrays/match.md
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5` は 5 を含む範囲を表す"

#: src/tuples-and-arrays/match.md
msgid "`_` is a wild card"
msgstr "`_` はワイルドカードを表す"

#: src/tuples-and-arrays/match.md
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"パターンのみでは表現できない複雑な概念を簡潔に表現したい場合、独立した構文機"
"能であるマッチガードは重要かつ必要です。"

#: src/tuples-and-arrays/match.md
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"マッチガードは、マッチアーム内の個別の `if` 式とは異なります。分岐ブロック内"
"（`=>` の後）の `if` 式は、マッチアームが選択された後に実行されます。そのブ"
"ロック内で `if` 条件が満たされなかった場合、元の `match` 式の他のアームは考慮"
"されません。"

#: src/tuples-and-arrays/match.md
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"ガードで定義された条件は、`|` が付いたパターン内のすべての式に適用されます。"

#: src/tuples-and-arrays/destructuring.md
msgid ""
"Destructuring is a way of extracting data from a data structure by writing a "
"pattern that is matched up to the data structure, binding variables to "
"subcomponents of the data structure."
msgstr ""
"分解とは、データ構造に一致するパターンを記述し、変数をデータ構造のサブコン"
"ポーネントにバインドすることで、データ構造からデータを抽出する方法です。"

#: src/tuples-and-arrays/destructuring.md
msgid "You can destructure tuples and arrays by matching on their elements:"
msgstr "タプルと配列は、要素を照合することで分解できます。"

#: src/tuples-and-arrays/destructuring.md
msgid "\"on Y axis\""
msgstr "\"on Y axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"on X axis\""
msgstr "\"on X axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"left of Y axis\""
msgstr "\"left of Y axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"below X axis\""
msgstr "\"below X axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"first quadrant\""
msgstr "\"first quadrant\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"Tell me about {triple:?}\""
msgstr "\"Tell me about {triple:?}\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"First is 0, y = {y}, and z = {z}\""
msgstr "\"First is 0, y = {y}, and z = {z}\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"First is 1 and the rest were ignored\""
msgstr "\"First is 1 and the rest were ignored\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"All elements were ignored\""
msgstr "\"All elements were ignored\""

#: src/tuples-and-arrays/destructuring.md
msgid "Create a new array pattern using `_` to represent an element."
msgstr "`_` を使用して要素を表す新しい配列パターンを作成します。"

#: src/tuples-and-arrays/destructuring.md
msgid "Add more values to the array."
msgstr "配列に値を追加します。"

#: src/tuples-and-arrays/destructuring.md
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr "要素数が異なる場合に `..` がどのように展開されるかを説明します。"

#: src/tuples-and-arrays/destructuring.md
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr "パターン `[.., b]` と `[a@..,b]` で末尾を照合します。"

#: src/tuples-and-arrays/exercise.md
msgid "Arrays can contain other arrays:"
msgstr "配列には他の配列を含めることができます。"

#: src/tuples-and-arrays/exercise.md
#, fuzzy
msgid "What is the type of this variable?"
msgstr "非同期の呼び出しの返り値の型は？"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"上記のような配列を使用して、行列を転置（行を列に変換）する `transpose` 関数を"
"記述します。"

#: src/tuples-and-arrays/exercise.md
msgid "Hard-code both functions to operate on 3 × 3 matrices."
msgstr "3 × 3 の行列で動作するように、両方の関数をハードコードします。"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"以下のコードを <https://play.rust-lang.org/> にコピーして、関数を実装します。"

#: src/tuples-and-arrays/exercise.md src/borrowing/exercise.md
#: src/unsafe-rust/exercise.md
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr "// TODO: 実装が完了したら、これを削除します。\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr "// <-- このコメントにより rustfmt で改行を追加\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"matrix: {:#?}\""
msgstr "\"matrix: {:#?}\""

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"transposed: {:#?}\""
msgstr "\"transposed: {:#?}\""

#: src/tuples-and-arrays/solution.md
msgid "//\n"
msgstr "//\n"

#: src/references.md
msgid "[Shared References](./references/shared.md) (10 minutes)"
msgstr "[共有参照](./references/shared.md)（10 分）"

#: src/references.md
msgid "[Exclusive References](./references/exclusive.md) (10 minutes)"
msgstr "[排他参照](./references/except.md)（10 分）"

#: src/references.md
msgid "[Exercise: Geometry](./references/exercise.md) (30 minutes)"
msgstr "[演習: ジオメトリ](./references/exercise.md)（30 分）"

#: src/references.md src/user-defined-types.md src/pattern-matching.md
msgid "This segment should take about 50 minutes"
msgstr "このセグメントの所要時間は約 50 分です"

#: src/references/shared.md
msgid ""
"A reference provides a way to access another value without taking "
"responsibility for the value, and is also called \"borrowing\". Shared "
"references are read-only, and the referenced data cannot change."
msgstr ""
"参照を使用すると、値について責任を負うことなく別の値にアクセスできます。参照"
"は「借用」とも呼ばれます。共有参照は読み取り専用であり、参照先のデータは変更"
"できません。"

#: src/references/shared.md
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""
"型 `T` への共有参照の型は `&T` です。参照値は `&` 演算子で作成されます。`*` "
"演算子は参照を「逆参照」し、その値を生成します。"

#: src/references/shared.md
msgid "Rust will statically forbid dangling references:"
msgstr "Rust はダングリング参照を静的に禁止します。"

#: src/references/shared.md
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""
"参照とは、参照する値を「借用する」ことだと言われていますが、これはポインタに"
"慣れていない受講者にとって理解しやすい説明です。コードでは参照を使用して値に"
"アクセスできますが、その値は元の変数によって「所有」されたままとなります。所"
"有については、コースの 3 日目で詳しく説明します。"

#: src/references/shared.md
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""
"参照はポインタとして実装されます。主な利点は、参照先よりもはるかに小さくでき"
"ることです。C または C++ に精通している受講者は、参照をポインタとして認識でき"
"ます。このコースの後半で、未加工ポインタの使用によるメモリ安全性のバグを "
"Rust で防止する方法について説明します。"

#: src/references/shared.md
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr "Rust は参照を自動的に作成しないため、常に `&` を付ける必要があります。"

#: src/references/shared.md
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.count_ones()`). There is no need for an `->` operator like "
"in C++."
msgstr ""
"Rust は、特にメソッドを呼び出すとき、自動的に逆参照する場合があります（`r."
"count_ones()` を試してください）。C++ のような `->` 演算子は必要ありません。"

#: src/references/shared.md
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""
"この例では、`r` は可変であるため、再代入が可能です（`r = &b`）。これにより "
"`r` が再バインドされ、他の値を参照するようになります。これは、参照に代入する"
"と参照先の値が変更される C++ とは異なります。"

#: src/references/shared.md
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr ""
"共有参照では、値が可変であっても、参照先の値は変更できません。`*r = 'X'` と指"
"定してみてください。"

#: src/references/shared.md
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""
"Rust は、すべての参照のライフタイムを追跡して、十分な存続期間を確保していま"
"す。安全な Rust では、ダングリング参照が発生することはありません。`x_axis` "
"は `point` への参照を返しますが、関数が戻ると `point` の割り当てが解除される"
"ため、コンパイルされません。"

#: src/references/shared.md
msgid "We will talk more about borrowing when we get to ownership."
msgstr "借用については所有権のところで詳しく説明します。"

#: src/references/exclusive.md
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""
"排他参照は可変参照とも呼ばれ、参照先の値を変更できます。型は `&mut T` です。"

#: src/references/exclusive.md
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""
"「排他」とは、この参照のみを使用して値にアクセスできることを意味します。他の"
"参照（共有または排他）が同時に存在することはできず、排他参照が存在する間は参"
"照先の値にアクセスできません。`x_coord` が有効な状態で `&point.0` を作成する"
"か、`point.0` を変更してみてください。"

#: src/references/exclusive.md
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"`let mut x_coord: &i32` と `let x_coord: &mut i32` の違いに注意してください。"
"前者は異なる値にバインドできる共有参照を表すのに対し、後者は可変の値への排他"
"参照を表します。"

#: src/references/exercise.md
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""
"ここでは、点を `[f64;3]` として表現する 3 次元ジオメトリのユーティリティ関数"
"をいくつか作成します。関数シグネチャは任意で指定してください。"

#: src/references/exercise.md
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""
"// 座標の二乗を合計して平方根を取り、\n"
"// ベクターの大きさを計算します。`sqrt()` メソッドを使用して、`v.sqrt()` と同"
"様に\n"
"// 平方根を計算します。\n"

#: src/references/exercise.md
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""
"// 大きさを計算し、すべての座標をその大きさで割ることで\n"
"// ベクターを正規化します。\n"

#: src/references/exercise.md
msgid "// Use the following `main` to test your work.\n"
msgstr "// 次の `main` を使用して処理をテストします。\n"

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of a unit vector: {}\""
msgstr "\"Magnitude of a unit vector: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?}: {}\""
msgstr "\"Magnitude of {v:?}: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr "\"Magnitude of {v:?} after normalization: {}\""

#: src/references/solution.md
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr "/// 指定されたベクターの大きさを計算します。\n"

#: src/references/solution.md
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr "/// 向きを変えずにベクターの大きさを 1.0 に変更します。\n"

#: src/user-defined-types.md
msgid "[Named Structs](./user-defined-types/named-structs.md) (10 minutes)"
msgstr "[名前付き構造体](./user-defined-types/named-structs.md)（10 分）"

#: src/user-defined-types.md
msgid "[Tuple Structs](./user-defined-types/tuple-structs.md) (10 minutes)"
msgstr "[タプル構造体](./user-defined-types/tuple-structs.md)（10 分）"

#: src/user-defined-types.md
msgid "[Enums](./user-defined-types/enums.md) (5 minutes)"
msgstr "[列挙型](./user-defined-types/enums.md)（5 分）"

#: src/user-defined-types.md
msgid ""
"[Static and Const](./user-defined-types/static-and-const.md) (5 minutes)"
msgstr "[static と const](./user-defined-types/static-and-const.md)（5 分）"

#: src/user-defined-types.md
msgid "[Type Aliases](./user-defined-types/aliases.md) (2 minutes)"
msgstr "[型エイリアス](./user-defined-types/aliases.md)（2 分）"

#: src/user-defined-types.md
msgid ""
"[Exercise: Elevator Events](./user-defined-types/exercise.md) (15 minutes)"
msgstr ""
"[演習: エレベーター イベント](./user-defined-types/exercise.md)（15 分）"

#: src/user-defined-types/named-structs.md
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "C や C++ と同様に、Rust はカスタム構造体をサポートしています。"

#: src/user-defined-types/named-structs.md
msgid "\"{} is {} years old\""
msgstr "\"{} is {} years old\""

#: src/user-defined-types/named-structs.md
#: src/android/interoperability/with-c/bindgen.md
msgid "\"Peter\""
msgstr "\"Peter\""

#: src/user-defined-types/named-structs.md
msgid "\"Avery\""
msgstr "\"Avery\""

#: src/user-defined-types/named-structs.md
msgid "\"Jackie\""
msgstr "\"Jackie\""

#: src/user-defined-types/named-structs.md
msgid "Structs work like in C or C++."
msgstr "構造体は、C や C++ においてと同じように機能します。"

#: src/user-defined-types/named-structs.md
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"C++ と同様に、また C とは異なり、型を定義するのに typedef は必要ありません。"

#: src/user-defined-types/named-structs.md
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "C++ とは異なり、構造体間に継承はありません。"

#: src/user-defined-types/named-structs.md
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr "ここで、構造体にはさまざまな型があることを説明しましょう。"

#: src/user-defined-types/named-structs.md
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don’t have any data that you want to store in the "
"value itself."
msgstr ""
"サイズがゼロの構造体（例: `struct Foo;`）は、ある型にトレイトを実装しているも"
"のの、値自体に格納するデータがない場合に使用できます。"

#: src/user-defined-types/named-structs.md
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"次のスライドでは、フィールド名が重要でない場合に使用されるタプル構造体を紹介"
"します。"

#: src/user-defined-types/named-structs.md
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr ""
"適切な名前の変数がすでにある場合は、省略形を使用して構造体を作成できます。"

#: src/user-defined-types/named-structs.md
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"構文 `..avery` を使用すると、明示的にすべてのフィールドを入力しなくても、古い"
"構造体のフィールドの大部分をコピーできます。この構文は、常に最後の要素にする"
"必要があります。"

#: src/user-defined-types/tuple-structs.md
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "フィールド名が重要でない場合は、タプル構造体を使用できます。"

#: src/user-defined-types/tuple-structs.md
msgid "\"({}, {})\""
msgstr "\"({}, {})\""

#: src/user-defined-types/tuple-structs.md
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"これは多くの場合、単一フィールド ラッパー（ニュータイプと呼ばれます）に使用さ"
"れます。"

#: src/user-defined-types/tuple-structs.md
msgid "\"Ask a rocket scientist at NASA\""
msgstr "\"Ask a rocket scientist at NASA\""

#: src/user-defined-types/tuple-structs.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/bare-metal/microcontrollers/type-state.md
#: src/async/pitfalls/cancellation.md
msgid "// ...\n"
msgstr "// ...\n"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"ニュータイプは、プリミティブ型の値に関する追加情報をエンコードする優れた方法"
"です。次に例を示します。"

#: src/user-defined-types/tuple-structs.md
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr "数値はいくつかの単位で測定されます（上記の例では `Newtons`）。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"この値は作成時に検証に合格したため、`PhoneNumber(String)` または "
"`OddNumber(u32)` を使用するたびに再検証する必要はありません。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"ニュータイプの 1 つのフィールドにアクセスして、`Newtons` 型に `f64` の値を追"
"加する方法を示します。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Rust generally doesn’t like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"Rust では通常、不明瞭なこと（自動ラップ解除や、整数としてのブール値の使用な"
"ど）は好まれません。"

#: src/user-defined-types/tuple-structs.md
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "演算子のオーバーロードについては、3 日目（ジェネリクス）で説明します。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"この例は、[マーズ クライメイト オービター](https://en.wikipedia.org/wiki/"
"Mars_Climate_Orbiter)の失敗を参考にしています。"

#: src/user-defined-types/enums.md
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"`enum` キーワードを使用すると、いくつかの異なるバリアントを持つ型を作成できま"
"す。"

#: src/user-defined-types/enums.md
msgid "// Simple variant\n"
msgstr "// 単純なバリアント\n"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "// Tuple variant\n"
msgstr "// 単純なバリアント\n"

#: src/user-defined-types/enums.md
msgid "// Struct variant\n"
msgstr "// 構造体バリアント\n"

#: src/user-defined-types/enums.md
msgid "\"On this turn: {:?}\""
msgstr "\"On this turn: {:?}\""

#: src/user-defined-types/enums.md
msgid "Enumerations allow you to collect a set of values under one type."
msgstr "列挙型を使用すると、1 つの型で一連の値を収集できます。"

#: src/user-defined-types/enums.md
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""
"`Direction` はバリアントを持つ型です。`Direction`には、`Direction::Left` と "
"`Direction::Right` の 2 つの値があります。"

#: src/user-defined-types/enums.md
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""
"`PlayerMove` は、3 つのバリアントを持つ型です。Rust はペイロードに加えて判別"
"式を格納することで、実行時にどのバリアントが `PlayerMove` 値に含まれているか"
"を把握できるようにします。"

#: src/user-defined-types/enums.md
msgid "This might be a good time to compare structs and enums:"
msgstr "ここで構造体と列挙型を比較することをおすすめします。"

#: src/user-defined-types/enums.md
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"どちらでも、フィールドのないシンプルなバージョン（単位構造体）か、さまざまな"
"フィールドがあるバージョン（バリアント ペイロード）を使用できます。"

#: src/user-defined-types/enums.md
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn’t be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"個別の構造体を使用して、列挙型のさまざまなバリアントを実装することもできます"
"が、その場合、それらがすべて列挙型で定義されている場合と同じ型にはなりませ"
"ん。"

#: src/user-defined-types/enums.md
msgid "Rust uses minimal space to store the discriminant."
msgstr "Rust は判別式を保存するために最小限のスペースを使用します。"

#: src/user-defined-types/enums.md
msgid "If necessary, it stores an integer of the smallest required size"
msgstr "必要に応じて、必要最小限のサイズの整数を格納します。"

#: src/user-defined-types/enums.md
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""
"許可されたバリアント値がすべてのビットパターンをカバーしていない場合、無効な"
"ビットパターンを使用して判別式をエンコードします（「ニッチの最適化」）。たと"
"えば、`Option<&u8>` には `None` バリアントに対する整数へのポインタまたは "
"`NULL` が格納されます。"

#: src/user-defined-types/enums.md
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""
"必要に応じて（たとえば C との互換性を確保するために）判別式を制御できます。"

#: src/user-defined-types/enums.md
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"`repr` がない場合、10001 は 2 バイトに収まるため、判別式の型には 2 バイトが使"
"用されます。"

#: src/user-defined-types/enums.md src/user-defined-types/static-and-const.md
#: src/memory-management/review.md src/memory-management/move.md
#: src/smart-pointers/box.md src/borrowing/shared.md
msgid "More to Explore"
msgstr "その他"

#: src/user-defined-types/enums.md
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""
"Rust には、列挙型が占めるスペースを少なくするために使用できる最適化がいくつか"
"あります。"

#: src/user-defined-types/enums.md
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"null ポインタの最適化: [一部の型](https://doc.rust-lang.org/std/option/"
"#representation)で、Rust は `size_of::<T>()` が `size_of::<Option<T>>()` と等"
"しいことを保証します。"

#: src/user-defined-types/enums.md
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"以下のサンプルコードは、ビット単位の表現が実際にどのようになるかを示していま"
"す。コンパイラはこの表現に関して保証しないので、これはまったく安全ではないこ"
"とに注意してください。"

#: src/user-defined-types/static-and-const.md
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program."
msgstr ""
"静的変数と定数変数は、プログラムの実行中に移動または再割り当てできないグロー"
"バル スコープの値を作成するための、2 つの異なる方法です。"

#: src/user-defined-types/static-and-const.md
msgid "`const`"
msgstr "`const`"

#: src/user-defined-types/static-and-const.md
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr ""
"定数変数はコンパイル時に評価され、使用場所にかかわらずその値がインライン化さ"
"れます。"

#: src/user-defined-types/static-and-const.md
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"[Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static.html) "
"によると、定数変数は使用時にインライン化されます。"

#: src/user-defined-types/static-and-const.md
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"コンパイル時に `const` 値を生成するために呼び出せるのは、`const` とマークされ"
"た関数のみです。ただし、`const` 関数は実行時に呼び出すことができます。"

#: src/user-defined-types/static-and-const.md
msgid "`static`"
msgstr "`static`"

#: src/user-defined-types/static-and-const.md
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr "静的変数はプログラムの実行全体を通じて存続するため、移動しません。"

#: src/user-defined-types/static-and-const.md
msgid "\"Welcome to RustOS 3.14\""
msgstr "\"Welcome to RustOS 3.14\""

#: src/user-defined-types/static-and-const.md
msgid "\"{BANNER}\""
msgstr "\"{BANNER}\""

#: src/user-defined-types/static-and-const.md
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"[Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static.html) "
"で説明されているように、静的変数は使用時にインライン化されず、実際の関連する"
"メモリ位置に存在します。これは安全でないコードや埋め込みコードに有用であり、"
"変数はプログラムの実行全体を通じて存続します。グローバル スコープの値にオブ"
"ジェクト ID が必要ない場合は、一般的に `const` が使用されます。"

#: src/user-defined-types/static-and-const.md
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr "`const` は C++ の `constexpr` と意味的によく似ていることを説明します。"

#: src/user-defined-types/static-and-const.md
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"一方、`static` は、C++ の `const` または可変グローバル変数にかなり似ていま"
"す。"

#: src/user-defined-types/static-and-const.md
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static` はオブジェクト ID（メモリ内のアドレス）と、内部可変性を持つ型に必要"
"な状態（`Mutex<T>` など）を提供します。"

#: src/user-defined-types/static-and-const.md
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"実行時に評価される定数が必要になることはあまりありませんが、静的変数を使用す"
"るよりも便利で安全です。"

#: src/user-defined-types/static-and-const.md
msgid "Properties table:"
msgstr "プロパティの表:"

#: src/user-defined-types/static-and-const.md
#: src/chromium/adding-third-party-crates.md
msgid "Property"
msgstr "プロパティ"

#: src/user-defined-types/static-and-const.md
msgid "Static"
msgstr "静的"

#: src/user-defined-types/static-and-const.md
msgid "Constant"
msgstr "定数"

#: src/user-defined-types/static-and-const.md
msgid "Has an address in memory"
msgstr "メモリ内にアドレスがある"

#: src/user-defined-types/static-and-const.md
#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes"
msgstr "はい"

#: src/user-defined-types/static-and-const.md
msgid "No (inlined)"
msgstr "いいえ（インライン化）"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid "Lives for the entire duration of the program"
msgstr "`main`関数はプログラムのエントリーポイントになります。"

#: src/user-defined-types/static-and-const.md
#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "No"
msgstr "いいえ"

#: src/user-defined-types/static-and-const.md
msgid "Can be mutable"
msgstr "変更可能"

#: src/user-defined-types/static-and-const.md
msgid "Yes (unsafe)"
msgstr "はい（安全でない）"

#: src/user-defined-types/static-and-const.md
msgid "Evaluated at compile time"
msgstr "コンパイル時に評価"

#: src/user-defined-types/static-and-const.md
msgid "Yes (initialised at compile time)"
msgstr "はい（コンパイル時に初期化）"

#: src/user-defined-types/static-and-const.md
msgid "Inlined wherever it is used"
msgstr "使用場所にかかわらずインライン化"

#: src/user-defined-types/static-and-const.md
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"`static` 変数はどのスレッドからでもアクセスできるため、`Sync` である必要があ"
"ります。内部の可変性は、[`Mutex`](https://doc.rust-lang.org/std/sync/struct."
"Mutex.html) やアトミックなどの方法で実現できます。"

#: src/user-defined-types/static-and-const.md
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr ""
"マクロ `std::thread_local` を使用して、スレッド ローカルのデータを作成できま"
"す。"

#: src/user-defined-types/aliases.md
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr ""
"型エイリアスは、別の型の名前を作成します。この 2 つの型は同じ意味で使用できま"
"す。"

#: src/user-defined-types/aliases.md
msgid "// Aliases are more useful with long, complex types:\n"
msgstr "// エイリアスは長くて複雑な型に使用すると便利です。\n"

#: src/user-defined-types/aliases.md
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr "C プログラマーは、これを `typedef` と同様のものと考えるでしょう。"

#: src/user-defined-types/exercise.md
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""
"エレベーター制御システムでイベントを表すデータ構造を作成します。さまざまなイ"
"ベントを構築するための型と関数を自由に定義して構いません。`#[derive(Debug)]` "
"を使用して、型を `{:?}` でフォーマットできるようにします。"

#: src/user-defined-types/exercise.md
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""
"この演習に必要なのは、`main` がエラーなしで実行されるように、データ構造を作成"
"して入力することだけです。このコースの次のパートでは、これらの構造からデータ"
"を取得する方法を説明します。"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""
"/// コントローラが反応する必要があるエレベーター システム内のイベント。\n"

#: src/user-defined-types/exercise.md
msgid "// TODO: add required variants\n"
msgstr "// TODO: 必要なバリアントを追加する\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// A direction of travel.\n"
msgstr "/// 運転方向。\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// The car has arrived on the given floor.\n"
msgstr "/// かごが所定の階に到着した。\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// The car doors have opened.\n"
msgstr "/// かごのドアが開いた。\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// The car doors have closed.\n"
msgstr "/// かごのドアが閉まった。\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr "/// 所定の階のエレベーター ロビーで方向ボタンが押された。\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr "/// エレベーターのかごの階数ボタンが押された。\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr "\"A ground floor passenger has pressed the up button: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr "\"The car has arrived on the ground floor: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car door opened: {:?}\""
msgstr "\"The car door opened: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr "\"A passenger has pressed the 3rd floor button: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car door closed: {:?}\""
msgstr "\"The car door closed: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr "\"The car has arrived on the 3rd floor: {:?}\""

#: src/user-defined-types/solution.md
msgid "/// A button was pressed.\n"
msgstr "/// ボタンが押された。\n"

#: src/user-defined-types/solution.md
msgid "/// The car has arrived at the given floor.\n"
msgstr "/// 車両が所定の階に到着した。\n"

#: src/user-defined-types/solution.md
msgid "/// The car's doors have opened.\n"
msgstr "/// かごのドアが開いた。\n"

#: src/user-defined-types/solution.md
msgid "/// The car's doors have closed.\n"
msgstr "/// かごのドアが閉まった。\n"

#: src/user-defined-types/solution.md
msgid "/// A floor is represented as an integer.\n"
msgstr "/// 階は整数として表される。\n"

#: src/user-defined-types/solution.md
msgid "/// A user-accessible button.\n"
msgstr "/// ユーザーがアクセスできるボタン。\n"

#: src/user-defined-types/solution.md
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr "/// 所定の階のエレベーター ロビーにあるボタン。\n"

#: src/user-defined-types/solution.md
msgid "/// A floor button within the car.\n"
msgstr "/// かご内の階数ボタン。\n"

#: src/welcome-day-2.md
msgid "Welcome to Day 2"
msgstr "2日目の講座へようこそ"

#: src/welcome-day-2.md
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr ""
"Rust についてかなり多くのことを学んできましたが、今日は Rust の型システムに焦"
"点を当てます。"

#: src/welcome-day-2.md
msgid "Pattern matching: extracting data from structures."
msgstr "パターン マッチング: 構造からのデータの抽出。"

#: src/welcome-day-2.md
msgid "Methods: associating functions with types."
msgstr "メソッド: 関数と型の関連付け。"

#: src/welcome-day-2.md
msgid "Traits: behaviors shared by multiple types."
msgstr "トレイト: 複数の型で共有される挙動。"

#: src/welcome-day-2.md
msgid "Generics: parameterizing types on other types."
msgstr "ジェネリクス: 他の型での型のパラメータ化。"

#: src/welcome-day-2.md
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr "標準ライブラリの型とトレイト: Rust の豊富な標準ライブラリの紹介。"

#: src/welcome-day-2.md
msgid "[Welcome](./welcome-day-2.md) (3 minutes)"
msgstr "[ようこそ](./welcome-day-2.md)（3 分）"

#: src/welcome-day-2.md
msgid "[Pattern Matching](./pattern-matching.md) (50 minutes)"
msgstr "[パターン マッチング](./pattern-matching.md)（50 分）"

#: src/welcome-day-2.md
#, fuzzy
msgid "[Methods and Traits](./methods-and-traits.md) (55 minutes)"
msgstr "[メソッドとトレイト](./methods-and-train.md)（45 分）"

#: src/welcome-day-2.md
msgid "[Generics](./generics.md) (45 minutes)"
msgstr "[ジェネリクス](./generics.md)（45 分）"

#: src/welcome-day-2.md src/welcome-day-4.md
msgid ""
"Including 10 minute breaks, this session should take about 3 hours and 5 "
"minutes"
msgstr "このセッションの所要時間は、10 分間の休憩を入れて約 3 時間 5 分です。"

#: src/pattern-matching.md
msgid "[Destructuring](./pattern-matching/destructuring.md) (10 minutes)"
msgstr "[デストラクト](./pattern-matching/destructuring.md)（10 分）"

#: src/pattern-matching.md
msgid "[Let Control Flow](./pattern-matching/let-control-flow.md) (10 minutes)"
msgstr ""
"[let による制御フロー](./pattern-matching/let-control-flow.md)（10 分）"

#: src/pattern-matching.md
msgid ""
"[Exercise: Expression Evaluation](./pattern-matching/exercise.md) (30 "
"minutes)"
msgstr "[演習: 式の評価](./pattern-matching/exercise.md)（30 分）"

#: src/pattern-matching/destructuring.md
msgid "Like tuples, structs and enums can also be destructured by matching:"
msgstr ""
"タプルと同様に、構造体と列挙型もパターンマッチによりデストラクトできます。"

#: src/pattern-matching/destructuring.md
msgid "Structs"
msgstr "構造体（structs）"

#: src/pattern-matching/destructuring.md
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr "\"x.0 = 1, b = {b}, y = {y}\""

#: src/pattern-matching/destructuring.md
msgid "\"y = 2, x = {i:?}\""
msgstr "\"y = 2, x = {i:?}\""

#: src/pattern-matching/destructuring.md
msgid "\"y = {y}, other fields were ignored\""
msgstr "\"y = {y}, other fields were ignored\""

#: src/pattern-matching/destructuring.md
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"パターンは、変数を値の一部にバインドするためにも使用できます。以下のようにし"
"て、型の構造を調べることができます。単純な `enum` から始めましょう。"

#: src/pattern-matching/destructuring.md
msgid "\"cannot divide {n} into two equal parts\""
msgstr "\"cannot divide {n} into two equal parts\""

#: src/pattern-matching/destructuring.md
msgid "\"{n} divided in two is {half}\""
msgstr "\"{n} divided in two is {half}\""

#: src/pattern-matching/destructuring.md
msgid "\"sorry, an error happened: {msg}\""
msgstr "\"sorry, an error happened: {msg}\""

#: src/pattern-matching/destructuring.md
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"ここでは、アーム（arm, パターンを並べたもの）を使用して `Result` 値の分解を"
"行っています。最初のアームでは、`half` は `Ok` バリアント内の値にバインドされ"
"ます。2 つ目のアームでは `msg` がエラー メッセージにバインドされます。"

#: src/pattern-matching/destructuring.md
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr "`foo` のリテラル値を他のパターンと一致するように変更します。"

#: src/pattern-matching/destructuring.md
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr ""
"`Foo` に新しいフィールドを追加し、必要に応じてパターンに変更を加えます。"

#: src/pattern-matching/destructuring.md
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"キャプチャと定数式を区別しづらい場合があります。2 つ目のアームの `2` を変数に"
"変更してみて、うまく機能しないことを確認します。これを `const` に変更して、再"
"び動作することを確認します。"

#: src/pattern-matching/destructuring.md
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"`if`/`else` 式は、後で `match` でアンパックされる列挙型を返しています。"

#: src/pattern-matching/destructuring.md
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"列挙型の定義に 3 つ目のバリアント（列挙型の要素のこと）を追加し、コード実行時"
"にエラーを表示してみましょう。コードが網羅されていない箇所を示し、コンパイラ"
"がどのようにヒントを提供しようとしているかを説明します。"

#: src/pattern-matching/destructuring.md
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched."
msgstr ""
"列挙型バリアントの値には、パターンが一致した場合にのみアクセスできます。"

#: src/pattern-matching/destructuring.md
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"検索が網羅的でない場合にどうなるかを示します。すべてのケースが処理されるタイ"
"ミングを確認することで、Rust コンパイラの利点を強調します。"

#: src/pattern-matching/destructuring.md
msgid ""
"Save the result of `divide_in_two` in the `result` variable and `match` it "
"in a loop. That won't compile because `msg` is consumed when matched. To fix "
"it, match `&result` instead of `result`. That will make `msg` a reference so "
"it won't be consumed. This [\"match ergonomics\"](https://rust-lang.github."
"io/rfcs/2005-match-ergonomics.html) appeared in Rust 2018. If you want to "
"support older Rust, replace `msg` with `ref msg` in the pattern."
msgstr ""
"`divide_in_two` の結果を `result` 変数に保存し、ループで `match` します。一致"
"した場合は `msg` が使用されるため、コンパイルされません。これを修正するには、"
"`result` ではなく `&result` でマッチします。これにより、`msg` は参照になるた"
"め、使用されなくなります。この [「マッチエルゴノミクス」](https://rust-lang."
"github.io/rfcs/2005-match-ergonomics.html) は、Rust 2018 で登場しました。古い"
"Rustをサポートする場合は、パターン内の`msg`を`ref msg` に置き換えてください。"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""
"Rust には、他の言語とは異なる制御フロー構造がいくつかあります。これらはパター"
"ン マッチングに使用されます。"

#: src/pattern-matching/let-control-flow.md
msgid "`if let` expressions"
msgstr "`if let` 式"

#: src/pattern-matching/let-control-flow.md
msgid "`while let` expressions"
msgstr "`while let` 式"

#: src/pattern-matching/let-control-flow.md
msgid "`match` expressions"
msgstr "`match` 式"

#: src/pattern-matching/let-control-flow.md
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"[`if let` 式](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions) を使用すると、値がパターンに一致するかどうかに応じて"
"異なるコードを実行できます。"

#: src/pattern-matching/let-control-flow.md
msgid "\"slept for {:?}\""
msgstr "\"slept for {:?}\""

#: src/pattern-matching/let-control-flow.md
msgid "`let else` expressions"
msgstr "`let else` 式"

#: src/pattern-matching/let-control-flow.md
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""
"パターンをマッチして関数から戻るという一般的なケースでは、[`let else`]"
"(https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html) を使用"
"します。「else」ケースは発散する必要があります（`return`、`break`、パニックな"
"ど、ブロックから抜けるもの以外のすべて）。"

#: src/pattern-matching/let-control-flow.md
msgid "\"got None\""
msgstr "\"got None\""

#: src/pattern-matching/let-control-flow.md
msgid "\"got empty string\""
msgstr "\"got empty string\""

#: src/pattern-matching/let-control-flow.md
msgid "\"not a hex digit\""
msgstr "\"not a hex digit\""

#: src/pattern-matching/let-control-flow.md src/pattern-matching/solution.md
msgid "\"result: {:?}\""
msgstr "\"result: {:?}\""

#: src/pattern-matching/let-control-flow.md src/generics/trait-bounds.md
#: src/smart-pointers/solution.md src/testing/googletest.md
#: src/testing/solution.md
msgid "\"foo\""
msgstr "\"foo\""

#: src/pattern-matching/let-control-flow.md
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"`if let` に似た [`while let`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#predicate-pattern-loops) 派生物もあります。これ"
"は、パターンに照らして値をテストします。"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"ここで [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) は、文字列が空になるまで `Some(c)` を返し、その後 "
"`None` を返します。`while let` を使用すると、すべてのアイテムに対して反復処理"
"を続行できます。"

#: src/pattern-matching/let-control-flow.md
msgid "if-let"
msgstr "if-let"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"`match` とは異なり、`if let` ではすべての分岐を網羅する必要はないため、"
"`match` よりも簡潔になります。"

#: src/pattern-matching/let-control-flow.md
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"一般的な使用方法は、`Option` を操作するときに `Some` 値を処理することです。"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"`match` とは異なり、`if let` はパターン マッチングでガード節をサポートしてい"
"ません。"

#: src/pattern-matching/let-control-flow.md
msgid "let-else"
msgstr "let-else"

#: src/pattern-matching/let-control-flow.md
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""
"次に示すように、`if let` は積み重なってしまうことがあります。`let-else` の構"
"成は、このネストされたコードを平坦にする助けとなります。読みづらいバージョン"
"を受講者向けに書き直して、受講者が変化を確認できるようにします。"

#: src/pattern-matching/let-control-flow.md
msgid "The rewritten version is:"
msgstr "書き換えたバージョンは次のとおりです。"

#: src/pattern-matching/let-control-flow.md
msgid "while-let"
msgstr "while-let"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"値がパターンに一致する限り、`while let` ループが繰り返されることを説明しま"
"す。"

#: src/pattern-matching/let-control-flow.md
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"`name.pop()` でunwrapする値がない場合に中断する if ステートメントを使用して、"
"`while let` ループを無限ループに書き換えることができます。`while let` は、上"
"記のシナリオの糖衣構文として使用できます。"

#: src/pattern-matching/exercise.md
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr "演算式用の簡単な再帰エバリュエータを作成してみましょう。"

#: src/pattern-matching/exercise.md
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""
"ここでの `Box` 型はスマート ポインタです。詳細はこの講座で後ほど説明します。"
"テストで見られるように、式は `Box::new` で「ボックス化」できます。ボックス化"
"された式を評価するには、逆参照演算子（`*`）を使用して「ボックス化解除」します"
"（`eval(*boxed_expr)`）。"

#: src/pattern-matching/exercise.md
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""
"一部の式は評価できず、エラーが返されます。標準の [`Result<Value, String>`]"
"(https://doc.rust-lang.org/std/result/enum.Result.html) 型は、成功した値"
"（`Ok(Value)`）またはエラー（`Err(String)`）のいずれかを表す列挙型です。この"
"型については、後ほど詳しく説明します。"

#: src/pattern-matching/exercise.md
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""
"コードをコピーして Rust プレイグラウンドに貼り付け、`eval` の実装を開始しま"
"す。完成したエバリュエータはテストに合格する必要があります。`todo!()` を使用"
"して、テストを 1 つずつ実施することをおすすめします。`#[ignore]` を使用して、"
"テストを一時的にスキップすることもできます。"

#: src/pattern-matching/exercise.md
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""
"早めに終了した場合は、ゼロ除算や整数オーバーフローが発生するテストを記述して"
"みてください。`Result` を使用して、パニックを発生させずにこれを処理するにはど"
"うすればよいでしょうか。"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// An operation to perform on two subexpressions.\n"
msgstr "/// 2 つのサブ式に対して実行する演算。\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// An expression, in tree form.\n"
msgstr "/// ツリー形式の式。\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// An operation on two subexpressions.\n"
msgstr "/// 2 つのサブ式に対する演算。\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// A literal value\n"
msgstr "/// リテラル値\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "\"division by zero\""
msgstr "\"division by zero\""

#: src/pattern-matching/solution.md
msgid "\"expr: {:?}\""
msgstr "\"expr: {:?}\""

#: src/methods-and-traits.md
msgid "[Methods](./methods-and-traits/methods.md) (10 minutes)"
msgstr "[メソッド](./methods-and-train/methods.md)（10 分）"

#: src/methods-and-traits.md
msgid "[Traits](./methods-and-traits/traits.md) (10 minutes)"
msgstr "[トレイト](./methods-and-features/train.md)（10 分）"

#: src/methods-and-traits.md
msgid "[Deriving](./methods-and-traits/deriving.md) (5 minutes)"
msgstr "[導出](./methods-and-train/deriving.md)（5 分）"

#: src/methods-and-traits.md
msgid "[Trait Objects](./methods-and-traits/trait-objects.md) (10 minutes)"
msgstr "[トレイトオブジェクト](./methods-and-features/train.md)（10 分）"

#: src/methods-and-traits.md
msgid ""
"[Exercise: Generic Logger](./methods-and-traits/exercise.md) (20 minutes)"
msgstr "[演習: ジェネリックなロガー](./methods-and-train/exercise.md)（20 分）"

#: src/methods-and-traits.md
msgid "This segment should take about 55 minutes"
msgstr "このセグメントの所要時間は約 55 分です"

#: src/methods-and-traits/methods.md
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Rust を使用すると、関数を新しい型に関連付けることができます。これは `impl` ブ"
"ロックで実行します。"

#: src/methods-and-traits/methods.md
msgid "// No receiver, a static method\n"
msgstr "// レシーバなし、静的メソッド\n"

#: src/methods-and-traits/methods.md
msgid "// Exclusive borrowed read-write access to self\n"
msgstr "// 自身に対する排他的な読み取り / 書き込み借用アクセス\n"

#: src/methods-and-traits/methods.md
msgid "// Shared and read-only borrowed access to self\n"
msgstr "// 自身に対する共有および読み取り専用の借用アクセス\n"

#: src/methods-and-traits/methods.md
msgid "\"Recorded {} laps for {}:\""
msgstr "\"Recorded {} laps for {}:\""

#: src/methods-and-traits/methods.md
msgid "\"Lap {idx}: {lap} sec\""
msgstr "\"Lap {idx}: {lap} sec\""

#: src/methods-and-traits/methods.md
msgid "// Exclusive ownership of self\n"
msgstr "// 自身の排他的所有権\n"

#: src/methods-and-traits/methods.md
msgid "\"Race {} is finished, total lap time: {}\""
msgstr "\"Race {} is finished, total lap time: {}\""

#: src/methods-and-traits/methods.md
msgid "\"Monaco Grand Prix\""
msgstr "\"Monaco Grand Prix\""

#: src/methods-and-traits/methods.md
msgid "// race.add_lap(42);\n"
msgstr "// race.add_lap(42);\n"

#: src/methods-and-traits/methods.md
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"`self` 引数は、「レシーバ」、つまりメソッドが操作するオブジェクトを指定しま"
"す。メソッドの一般的なレシーバは次のとおりです。"

#: src/methods-and-traits/methods.md
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: 共有の不変参照を使用して、呼び出し元からオブジェクトを借用します。こ"
"のオブジェクトは後で再び使用できます。"

#: src/methods-and-traits/methods.md
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: 一意の可変参照を使用して、呼び出し元からオブジェクトを借用しま"
"す。このオブジェクトは後で再び使用できます。"

#: src/methods-and-traits/methods.md
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: オブジェクトの所有権を取得し、呼び出し元から遠ざけます。メソッドがオ"
"ブジェクトの所有者になります。所有権が明示的に送信されない限り、メソッドが戻"
"ると、オブジェクトは破棄（デアロケート）されます。完全な所有権は、必ずしも可"
"変性を意味するわけではありません。"

#: src/methods-and-traits/methods.md
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr "`mut self`: 上記と同じですが、メソッドはオブジェクトを変更できます。"

#: src/methods-and-traits/methods.md
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"レシーバなし: 構造体の静的メソッドになります。通常は、`new` と呼ばれるコンス"
"トラクタを作成するために使用されます。"

#: src/methods-and-traits/methods.md
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "メソッドを関数と比較して紹介するとよいでしょう。"

#: src/methods-and-traits/methods.md
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"メソッドは型（構造体や列挙型など）のインスタンスで呼び出されます。最初のパラ"
"メータはインスタンスを `self` として表します。"

#: src/methods-and-traits/methods.md
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"デベロッパーは、メソッド レシーバ構文でコードを整理する目的で、メソッドを使用"
"することもできます。メソッドを使用することで、すべての実装コードを 1 つの予測"
"可能な場所にまとめることができます。"

#: src/methods-and-traits/methods.md
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr ""
"メソッド レシーバである `self` というキーワードの使用について説明します。"

#: src/methods-and-traits/methods.md
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"`self: Self` の略語であることを示し、構造体名の使用方法についても説明すること"
"をおすすめします。"

#: src/methods-and-traits/methods.md
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"`Self` は `impl` ブロックが存在する型の型エイリアスであり、ブロック内の他の場"
"所で使用できることを説明します。"

#: src/methods-and-traits/methods.md
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"`self` は他の構造体と同様に使用され、ドット表記を使用して個々のフィールドを参"
"照できることを説明します。"

#: src/methods-and-traits/methods.md
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"ここで `finish` を 2 回実行して、`&self` と `self` の違いを示すことをおすすめ"
"します。"

#: src/methods-and-traits/methods.md
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"`self` のバリアント以外にも、レシーバ型として許可されている [特別なラッパー"
"型](https://doc.rust-lang.org/reference/special-types-and-traits.html)"
"（`Box<Self>` など）もあります。"

#: src/methods-and-traits/traits.md
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Rustでは、型に関しての抽象化をトレイトを用いて行うことができます。トレイトは"
"インターフェースに似ています："

#: src/methods-and-traits/traits.md
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr "\"Oh you're a cutie! What's your name? {}\""

#: src/methods-and-traits/traits.md src/methods-and-traits/trait-objects.md
msgid "\"Woof, my name is {}!\""
msgstr "\"Woof, my name is {}!\""

#: src/methods-and-traits/traits.md src/methods-and-traits/trait-objects.md
msgid "\"Miau!\""
msgstr "\"Miau!\""

#: src/methods-and-traits/traits.md src/methods-and-traits/trait-objects.md
msgid "\"Fido\""
msgstr "\"Fido\""

#: src/methods-and-traits/traits.md
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr ""
"トレイトは、そのトレイトを実装するために各型に必要な多数のメソッドを定義しま"
"す。"

#: src/methods-and-traits/traits.md
msgid "Traits are implemented in an `impl <trait> for <type> { .. }` block."
msgstr "トレイトは `impl <trait> for <type> { .. }` ブロックに実装されます。"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"Traits may specify pre-implemented (provided) methods and methods that users "
"are required to implement themselves. Provided methods can rely on required "
"methods. In this case, `greet` is provided, and relies on `talk`."
msgstr ""
"トレイトは予め実装された（デフォルトの）メソッドと、ユーザが自身で実装する必"
"要のあるメソッドを指定することができます。デフォルトの実装のあるメソッドは、"
"その定義を実装必須のメソットに依存することができます。"

#: src/methods-and-traits/deriving.md
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr ""
"サポートされているトレイトは、次のようにカスタム型に自動的に実装できます。"

#: src/methods-and-traits/deriving.md
msgid "// Default trait adds `default` constructor.\n"
msgstr "// デフォルト トレイトで `default` コンストラクタを追加します。\n"

#: src/methods-and-traits/deriving.md
msgid "// Clone trait adds `clone` method.\n"
msgstr "// クローン トレイトで `clone` メソッドを追加します。\n"

#: src/methods-and-traits/deriving.md
msgid "\"EldurScrollz\""
msgstr "\"EldurScrollz\""

#: src/methods-and-traits/deriving.md
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr ""
"// デバッグ トレイトで、`{:?}` を使用した出力のサポートを追加します。\n"

#: src/methods-and-traits/deriving.md
msgid "\"{:?} vs. {:?}\""
msgstr "\"{:?} vs. {:?}\""

#: src/methods-and-traits/deriving.md
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""
"導出はマクロで実装され、多くのクレートには有用な機能を追加するための便利な導"
"出マクロが用意されています。たとえば、`serde` は `#[derive(Serialize)]` を使"
"用して、構造体のシリアル化のサポートを導出できます。"

#: src/methods-and-traits/trait-objects.md
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"トレイトオブジェクトは異なる型の値をひとつのコレクションにまとめることを可能"
"にします："

#: src/methods-and-traits/trait-objects.md
msgid "\"Hello, who are you? {}\""
msgstr "\"Hello, who are you? {}\""

#: src/methods-and-traits/trait-objects.md
msgid "Memory layout after allocating `pets`:"
msgstr "`pets`を割り当てた後のメモリレイアウト："

#: src/methods-and-traits/trait-objects.md
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" スタック                             ヒープ\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/methods-and-traits/trait-objects.md
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"同じトレイトを実装する型であってもそのサイズは異なることがあります。そのた"
"め、上の例でVec<dyn Pet>と書くことはできません。"

#: src/methods-and-traits/trait-objects.md
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet` はコンパイラに、この型が`Pet`トレイトを実装する動的なサイズの型であ"
"ることを伝えます。"

#: src/methods-and-traits/trait-objects.md
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""
"上の例では `pets` はスタックに確保され、ベクターのデータはヒープ上にありま"
"す。二つのベクターの要素は _ファットポインタ_ です："

#: src/methods-and-traits/trait-objects.md
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"ファットポインタはdouble-widthポインタです。これは二つの要素からなります：実"
"際のオブジェクトへのポインタと、そのオブジェクトの`Pet`の実装のための[仮想関"
"数テーブル](https://ja.wikipedia.org/wiki/"
"%E4%BB%AE%E6%83%B3%E9%96%A2%E6%95%B0%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB) "
"(vtable)です。"

#: src/methods-and-traits/trait-objects.md
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""
"\"Fido\"と名付けられた`Dog`のデータは`name` と `age` のフィールドに対応しま"
"す。（訳注: \"Fido\"とはよくある犬の愛称で、日本語でいう「ポチ」のような名前"
"です。）例の`Cat`には`lives` フィールドがあります。（訳注: ここで`Cat`が"
"`lives`というフィールドを持ち、9で初期化しているのは\"A cat has nine lives\" "
"—猫は９つの命を持つ—ということわざに由来します。）"

#: src/methods-and-traits/trait-objects.md
msgid "Compare these outputs in the above example:"
msgstr "上の例において、下のコードによる出力結果を比べてみましょう："

#: src/methods-and-traits/trait-objects.md src/std-traits/closures.md
msgid "\"{} {}\""
msgstr "\"{} {}\""

#: src/methods-and-traits/trait-objects.md src/std-traits/exercise.md
#: src/std-traits/solution.md src/modules/exercise.md src/modules/solution.md
#: src/android/build-rules/library.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/async/pitfalls/cancellation.md
msgid "\"{}\""
msgstr "\"{}\""

#: src/methods-and-traits/exercise.md
msgid ""
"Let's design a simple logging utility, using a trait `Logger` with a `log` "
"method. Code which might log its progress can then take an `&impl Logger`. "
"In testing, this might put messages in the test logfile, while in a "
"production build it would send messages to a log server."
msgstr ""
"トレイト `Logger` と `log` メソッドを使用して、シンプルなロギングユーティリ"
"ティを設計してみましょう。進行状況をログに記録するコードは、その後に `&impl "
"Logger` を受け取ることができます。この場合、テストではテストログファイルに"
"メッセージが書き込まれますが、本番環境ビルドではログサーバーにメッセージが送"
"信されます。"

#: src/methods-and-traits/exercise.md
msgid ""
"However, the `StderrLogger` given below logs all messages, regardless of "
"verbosity. Your task is to write a `VerbosityFilter` type that will ignore "
"messages above a maximum verbosity."
msgstr ""
"ただし、以下の `StderrLogger` は、詳細度(verbosity)に関係なく、すべてのメッ"
"セージをログに記録します。ここでのタスクは、最大の詳細度を超えるメッセージを"
"無視する `VerbosityFilter` 型を作成することです。"

#: src/methods-and-traits/exercise.md
msgid ""
"This is a common pattern: a struct wrapping a trait implementation and "
"implementing that same trait, adding behavior in the process. What other "
"kinds of wrappers might be useful in a logging utility?"
msgstr ""
"これは一般的なパターンです。つまり、トレイト実装をラップして同じトレイトを実"
"装し、その過程で挙動を追加していく構造体です。ロギングユーティリティでは他に"
"どのような種類のラッパーが役立つでしょうか。"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "/// Log a message at the given verbosity level.\n"
msgstr "/// 指定された詳細度レベルでメッセージをログに記録します。\n"

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"verbosity={verbosity}: {message}\""
msgstr "\"verbosity={verbosity}: {message}\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"FYI\""
msgstr "\"FYI\""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"Uhoh\""
msgstr "\"Uhoh\""

#: src/methods-and-traits/exercise.md
msgid "// TODO: Define and implement `VerbosityFilter`.\n"
msgstr "// TODO: `VerbosityFilter` を定義して実装します。\n"

#: src/methods-and-traits/solution.md
msgid "/// Only log messages up to the given verbosity level.\n"
msgstr "/// 指定された詳細度レベルまでのメッセージのみをログに記録。\n"

#: src/generics.md
msgid "[Generic Functions](./generics/generic-functions.md) (5 minutes)"
msgstr "[ジェネリック関数](./generics/generic-functions.md)（5 分）"

#: src/generics.md
msgid "[Generic Data Types](./generics/generic-data.md) (15 minutes)"
msgstr "[ジェネリック データ型](./generics/generic-data.md)（15 分）"

#: src/generics.md
msgid "[Trait Bounds](./generics/trait-bounds.md) (10 minutes)"
msgstr "[トレイト境界](./generics/trait-bounds.md)（10 分）"

#: src/generics.md
msgid "[impl Trait](./generics/impl-trait.md) (5 minutes)"
msgstr "[impl トレイト](./generics/impl-trait.md)（5 分）"

#: src/generics.md
msgid "[Exercise: Generic min](./generics/exercise.md) (10 minutes)"
msgstr "[演習: ジェネリックな min](./generics/exercise.md)（10 分）"

#: src/generics.md src/smart-pointers.md src/iterators.md src/error-handling.md
msgid "This segment should take about 45 minutes"
msgstr "このセグメントの所要時間は約 45 分です"

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rustはジェネリクス（generics）をサポートします。これにより、使用または保存す"
"る型に関してアルゴリズムやデータ構造（ソートアルゴリズムや、二分木など）を抽"
"象化することができます。"

#: src/generics/generic-functions.md
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr "/// `n` の値に応じて `even` または `odd` を選択します。\n"

#: src/generics/generic-functions.md
msgid "\"picked a number: {:?}\""
msgstr "\"picked a number: {:?}\""

#: src/generics/generic-functions.md
msgid "\"picked a tuple: {:?}\""
msgstr "\"picked a tuple: {:?}\""

#: src/generics/generic-functions.md
msgid "\"dog\""
msgstr "\"dog\""

#: src/generics/generic-functions.md
msgid "\"cat\""
msgstr "\"cat\""

#: src/generics/generic-functions.md
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr "Rust は引数と戻り値の型に基づいて T の型を推測します。"

#: src/generics/generic-functions.md
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""
"これは C++ テンプレートに似ていますが、Rust はジェネリック関数を部分的にすぐ"
"にコンパイルするため、その関数は制約に一致するすべての型に対して有効である必"
"要があります。たとえば、`n == 0` の場合は `even + odd` を返すように `pick` を"
"変更してみてください。整数を使用した `pick` インスタンス化のみが使用されてい"
"る場合でも、Rust はそれを無効とみなします。C++ ではこれを行うことができます。"

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"これはゼロコスト抽象化です：抽象化なしに手作業でデータ構造を書いたときと、全"
"く同じ結果を得ることができます。"

#: src/generics/generic-data.md
msgid "You can use generics to abstract over the concrete field type:"
msgstr ""
"ジェネリクスを使って、具体的なフィールドの型を抽象化することができます："

#: src/generics/generic-data.md
msgid "// fn set_x(&mut self, x: T)\n"
msgstr "// fn set_x(&mut self, x: T)\n"

#: src/generics/generic-data.md
msgid "\"{integer:?} and {float:?}\""
msgstr "\"{integer:?} and {float:?}\""

#: src/generics/generic-data.md
msgid "\"coords: {:?}\""
msgstr "\"coords: {:?}\""

#: src/generics/generic-data.md
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"_Q:_ なぜ`T`は２回も `impl<T> Point<T> {}` において指定されたのでしょうか？冗"
"長ではありませんか？"

#: src/generics/generic-data.md
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"なぜなら、これはジェネリクスに対してのジェネリックな実装の箇所だからです。そ"
"れらは独立してジェネリックです。"

#: src/generics/generic-data.md
msgid "It means these methods are defined for any `T`."
msgstr ""
"つまり、そのようなメソッドは任意の`T`に対して定義されるということです。"

#: src/generics/generic-data.md
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "`impl Point<u32> { .. }`のように書くことも可能です。 "

#: src/generics/generic-data.md
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point`はそれでもなおジェネリックであり、 `Point<f64>`を使うことができます。"
"しかし、このブロックでのメソッドは`Point<u32>`に対してのみ利用可能となりま"
"す。"

#: src/generics/generic-data.md
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""
"新しい変数 `let p = Point { x: 5, y: 10.0 };` を宣言してみてください。2 つの"
"変数（`T` と `U` など）を使用して、異なる型の要素を持つポイントを許可するよう"
"にコードを更新します。"

#: src/generics/trait-bounds.md
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"ジェネリクスを用いるとき、あるトレイトのメソッドを呼び出せるように、型がその"
"トレイトを実装していることを要求したいことがよくあります。（脚注：本教材では"
"\"Trait bounds\"を「トレイト制約」と翻訳しましたが、Rustの日本語翻訳コミュニ"
"ティでは「トレイト境界」と呼ぶ流派もあり、どちらの翻訳を採用するかについては"
"[議論がなされています](https://github.com/rust-lang-ja/book-ja/"
"issues/172)。）"

#: src/generics/trait-bounds.md
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "そうしたことは`T: Trait` や `impl Trait`を用いて行えます："

#: src/generics/trait-bounds.md
msgid "// struct NotClonable;\n"
msgstr "// struct NotClonable;\n"

#: src/generics/trait-bounds.md
msgid "\"{pair:?}\""
msgstr "\"{pair:?}\""

#: src/generics/trait-bounds.md
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr "`NonClonable` を作成して`duplicate` に渡してみてください。"

#: src/generics/trait-bounds.md
msgid "When multiple traits are necessary, use `+` to join them."
msgstr "複数のトレイトが必要な場合は、`+` を使って結合します。"

#: src/generics/trait-bounds.md
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"`where` 節の使い方を示しましょう。受講生はコードを読んでいるときに、この"
"`where`節に遭遇します。"

#: src/generics/trait-bounds.md
msgid "It declutters the function signature if you have many parameters."
msgstr ""
"たくさんのパラメタがある場合に、`where`節は関数のシグネチャを整理整頓してくれ"
"ます。"

#: src/generics/trait-bounds.md
msgid "It has additional features making it more powerful."
msgstr "`where`節には更に強力な機能があります。"

#: src/generics/trait-bounds.md
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"誰かに聞かれた場合で良いですが、その機能というのは、\":\" の左側には "
"`Option<T>` のように任意の型を表現できるというものです。"

#: src/generics/trait-bounds.md
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""
"なお、Rust はまだ特化(specialization)をサポートしていません。たとえば、元の "
"`duplicate` がある場合は、特化された `duplicate(a: u32)` を追加することはでき"
"ません。"

#: src/generics/impl-trait.md
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"トレイト境界と似たように、構文 `impl Trait`は関数の引数と返り値においてのみ利"
"用可能です："

#: src/generics/impl-trait.md
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""
"// 以下の糖衣構文:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"

#: src/generics/impl-trait.md
msgid "\"{many}\""
msgstr "\"{many}\""

#: src/generics/impl-trait.md
msgid "\"{many_more}\""
msgstr "\"{many_more}\""

#: src/generics/impl-trait.md
msgid "\"debuggable: {debuggable:?}\""
msgstr "\"debuggable: {debuggable:?}\""

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr "`impl Trait`の意味は、位置によって少し異なります。"

#: src/generics/impl-trait.md
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"パラメタに対しては、`impl Trait`は、トレイト境界を持つ匿名のジェネリックパラ"
"メタのようなものです。"

#: src/generics/impl-trait.md
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"返り値の型に用いる場合は、特定のトレイトを実装する何らかの具象型を返すが、具"
"体的な型名は明示しないということを意味します。このことは公開されるAPIに具象型"
"を晒したくない場合に便利です。"

#: src/generics/impl-trait.md
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"返り値の位置における型推論は困難です。`impl Foo`を返す関数は、それが返す具象"
"型はソースコードに書かれることないまま、具象型を選びます。`collect<B>() -> B`"
"のようなジェネリック型を返す関数は、`B`を満たすどのような型でも返すことがあり"
"ます。 また、関数の呼び出し元はそのような型を一つを選ぶ必要があるかもしれませ"
"ん。 それは、 `let x: Vec<_> = foo.collect()`としたり、turbofishを用いて`foo."
"collect::<Vec<_>>()`とすることで行えます。"

#: src/generics/impl-trait.md
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""
"`debuggable` の型は何でしょうか。`let debuggable: () = ..` を試して、エラー "
"メッセージの内容を確認してください。"

#: src/generics/exercise.md
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using a `LessThan` trait."
msgstr ""
"この短い演習では、`LessThan` トレイトを使用して、2 つの値の最小値を決定する"
"ジェネリックな `min` 関数を実装します。"

#: src/generics/exercise.md src/generics/solution.md
msgid "/// Return true if self is less than other.\n"
msgstr "/// 自身がその他より小さい場合は true を返します。\n"

#: src/generics/exercise.md
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr "// TODO: `main` で使用する `min` 関数を実装します。\n"

#: src/generics/exercise.md src/generics/solution.md
msgid "\"Shapiro\""
msgstr "\"Shapiro\""

#: src/generics/exercise.md src/generics/solution.md
msgid "\"Baumann\""
msgstr "\"Baumann\""

#: src/welcome-day-2-afternoon.md
msgid "[Standard Library Types](./std-types.md) (1 hour and 10 minutes)"
msgstr "[標準ライブラリ型](./std-types.md)（1 時間 10 分）"

#: src/welcome-day-2-afternoon.md
msgid "[Standard Library Traits](./std-traits.md) (1 hour and 40 minutes)"
msgstr "[標準ライブラリ トレイト](./std-train.md)（1 時間 40 分）"

#: src/std-types.md
msgid "[Standard Library](./std-types/std.md) (3 minutes)"
msgstr "[標準ライブラリ](./std-types/std.md)（3 分）"

#: src/std-types.md
msgid "[Documentation](./std-types/docs.md) (5 minutes)"
msgstr "[ドキュメント](./std-types/docs.md)（5 分）"

#: src/std-types.md
msgid "[Option](./std-types/option.md) (10 minutes)"
msgstr "[Option](./std-types/option.md)（10 分）"

#: src/std-types.md
msgid "[Result](./std-types/result.md) (10 minutes)"
msgstr "[Result](./std-types/result.md)（10 分）"

#: src/std-types.md
msgid "[String](./std-types/string.md) (10 minutes)"
msgstr "[String](./std-types/string.md)（10 分）"

#: src/std-types.md
msgid "[Vec](./std-types/vec.md) (10 minutes)"
msgstr "[Vec](./std-types/vec.md)（10 分）"

#: src/std-types.md
msgid "[HashMap](./std-types/hashmap.md) (10 minutes)"
msgstr "[HashMap](./std-types/hashmap.md)（10 分）"

#: src/std-types.md
msgid "[Exercise: Counter](./std-types/exercise.md) (10 minutes)"
msgstr "[演習: カウンタ](./std-types/exercise.md)（10 分）"

#: src/std-types.md src/memory-management.md src/slices-and-lifetimes.md
msgid "This segment should take about 1 hour and 10 minutes"
msgstr "このセグメントの所要時間は約 1 時間 10 分です"

#: src/std-types.md
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""
"このセクションの各スライドでは、時間をかけてドキュメント ページを確認し、より"
"一般的なメソッドをいくつか取り上げてください。"

#: src/std-types/std.md
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust には、Rust のライブラリとプログラムで使用される一般的な型のセットを確立"
"するのに役立つ標準ライブラリが付属しています。2 つのライブラリをスムーズに連"
"携させることができるのは、このように両方とも同じ `String` 型を使用しているた"
"めです。"

#: src/std-types/std.md
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr ""
"実際、Rust には標準ライブラリ（`core`、`alloc`、`std`）の複数のレイヤが含まれ"
"ています。"

#: src/std-types/std.md
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core` には、`libc` やアロケータ、さらにはオペレーティング システムの存在にも"
"依存しない、最も基本的な型と関数が含まれます。"

#: src/std-types/std.md
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc` には、`Vec`、`Box`、`Arc` など、グローバルヒープアロケータを必要とす"
"る型が含まれます。"

#: src/std-types/std.md
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"多くの場合、埋め込みの Rust アプリは `core` のみを使用し、場合によっては "
"`alloc` を使用します。"

#: src/std-types/docs.md
msgid "Rust comes with extensive documentation. For example:"
msgstr "Rust には詳細なドキュメントが用意されています。次に例を示します。"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"ループから早く抜け出したい場合は [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions) を使用してください。"

#: src/std-types/docs.md
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""
"[`u8`](https://doc.rust-lang.org/stable/std/primitive.u8.html) のようなプリミ"
"ティブ型。"

#: src/std-types/docs.md
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"[`Option`](https://doc.rust-lang.org/stable/std/option/enum.Option.html) や "
"[`BinaryHeap`](https://doc.rust-lang.org/stable/std/collections/struct."
"BinaryHeap.html) などの標準ライブラリ型。"

#: src/std-types/docs.md
msgid "In fact, you can document your own code:"
msgstr "実際、独自のコードにドキュメントをつけることができます。"

#: src/std-types/docs.md
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""
"/// 最初の引数が 2 番目の引数で割り切れるかどうかを判定します。\n"
"///\n"
"/// 2 番目の引数がゼロの場合、結果は false になります。\n"

#: src/std-types/docs.md
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"コンテンツはマークダウンとして扱われます。公開されたすべての Rust ライブラリ "
"クレートは、[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc."
"html) ツールを使用して、[`docs.rs`](https://docs.rs) で自動的にドキュメントが"
"まとめられます。このパターンを使用して、すべての公開アイテムを API でドキュメ"
"ント化するのが慣用的です。"

#: src/std-types/docs.md
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""
"アイテム内（モジュール内など）からアイテムをドキュメント化するには、「内部ド"
"キュメントのコメント」と呼ばれる `//!` または `/*! .. */` を使用します。"

#: src/std-types/docs.md
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr "//! このモジュールには、整数の整除に関連する機能が含まれています。\n"

#: src/std-types/docs.md
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"<https://docs.rs/rand> で `rand` クレート用に生成されたドキュメントを受講者に"
"示します。"

#: src/std-types/option.md
msgid "Option"
msgstr "Option"

#: src/std-types/option.md
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""
"`Option<T>` の使用方法についてはすでにいくつか見てきましたが、これは型 `T` の"
"値を格納するか、何も格納しません。たとえば、[`String::find`](https://doc."
"rust-lang.org/stable/std/string/struct.String.html#method.find) は "
"`Option<usize>` を返します。"

#: src/std-types/option.md
msgid "\"Löwe 老虎 Léopard Gepardi\""
msgstr "\"Löwe 老虎 Léopard Gepardi\""

#: src/std-types/option.md
msgid "'é'"
msgstr "'é'"

#: src/std-types/option.md
msgid "\"find returned {position:?}\""
msgstr "\"find returned {position:?}\""

#: src/std-types/option.md
msgid "'Z'"
msgstr "'Z'"

#: src/std-types/option.md
msgid "\"Character not found\""
msgstr "\"Character not found\""

#: src/std-types/option.md
#, fuzzy
msgid "`Option` is widely used, not just in the standard library."
msgstr "標準ライブラリの非同期バージョン。"

#: src/std-types/option.md
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""
"`unwrap` は `Option` 内の値を返すか、パニックになります。`expect` も同様です"
"が、エラーメッセージを受け取ります。"

#: src/std-types/option.md
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr ""
"None でパニックになる場合もありますが、「誤って」None のチェックを忘れること"
"はありません。"

#: src/std-types/option.md
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""
"何かを一緒にハッキングする場合は、あちこちで `unwrap`/`expect` を行うのが一般"
"的ですが、本番環境のコードは通常、`None` をより適切に処理します。"

#: src/std-types/option.md
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr ""
"ニッチな最適化とは、`Option<T>` がメモリ内で `T` と同じサイズであることが多い"
"ということです。"

#: src/std-types/result.md
msgid "Result"
msgstr "Result"

#: src/std-types/result.md
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different type. This is similar to the `Res` defined "
"in the expression exercise, but generic: `Result<T, E>` where `T` is used in "
"the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""
"`Result` は `Option` に似ていますが、オペレーションの成功または失敗を、それぞ"
"れ異なる型で示します。これは式の演習で定義されていた `Res` に似ているものの、"
"汎用的で、`Result<T, E>` の形式を取ります（`T` は `Ok` バリアントで使用され、"
"`E` は `Err` バリアントで使用されます）。"

#: src/std-types/result.md
msgid "\"diary.txt\""
msgstr "\"diary.txt\""

#: src/std-types/result.md
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr "\"Dear diary: {contents} ({bytes} bytes)\""

#: src/std-types/result.md
msgid "\"Could not read file content\""
msgstr "\"Could not read file content\""

#: src/std-types/result.md
msgid "\"The diary could not be opened: {err}\""
msgstr "\"The diary could not be opened: {err}\""

#: src/std-types/result.md
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"`Option` と同様に、成功した値は `Result` の内部にあり、デベロッパーはそれを明"
"示的に抽出する必要があります。これにより、エラーチェックが促進されます。エ"
"ラーが発生してはならない場合は、`unwrap()` または `expect()` を呼び出すことが"
"できます。これもデベロッパーのインテントのシグナルです。"

#: src/std-types/result.md
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"`Result` のドキュメントを読むことをすすめましょう。この講座では取り上げません"
"が、言及する価値があります。このドキュメントには、関数型プログラミングに役立"
"つ便利なメソッドや関数が多数含まれています。"

#: src/std-types/result.md
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr "`Result` は、3 日目で説明するエラー処理を実装する標準型です。"

#: src/std-types/string.md
msgid "String"
msgstr "文字列（String）"

#: src/std-types/string.md
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) は、標準"
"的なヒープ割り当ての拡張可能な UTF-8 文字列バッファです。"

#: src/std-types/string.md src/std-traits/read-and-write.md
#: src/memory-management/review.md src/testing/unit-tests.md
#: src/concurrency/scoped-threads.md
msgid "\"Hello\""
msgstr "\"Hello\""

#: src/std-types/string.md
msgid "\"s1: len = {}, capacity = {}\""
msgstr "\"s1: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "'!'"
msgstr "'!'"

#: src/std-types/string.md
msgid "\"s2: len = {}, capacity = {}\""
msgstr "\"s2: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "\"🇨🇭\""
msgstr "\"🇨🇭\""

#: src/std-types/string.md
msgid "\"s3: len = {}, number of chars = {}\""
msgstr "\"s3: len = {}, number of chars = {}\""

#: src/std-types/string.md
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` は [`Deref<Target = str>`](https://doc.rust-lang.org/std/string/"
"struct.String.html#deref-methods-str) を実装します。つまり、`String` のすべて"
"の `str` メソッドを呼び出すことができます。"

#: src/std-types/string.md
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new` は新しい空の文字列を返します。文字列にプッシュするデータの量が"
"わかっている場合は `String::with_capacity` を使用します。"

#: src/std-types/string.md
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len` は、`String` のサイズをバイト単位で返します（文字数とは異なる場"
"合があります）。"

#: src/std-types/string.md
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars` は、実際の文字のイテレータを返します。[書記素クラスタ]"
"(https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct."
"Graphemes.html)により、`char` は人間が「文字」と見なすものとは異なる場合があ"
"ります。"

#: src/std-types/string.md
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""
"人々が文字列について言及する場合、単に `&str` または `String` のことを話して"
"いる可能性があります。"

#: src/std-types/string.md
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"型が `Deref<Target = T>` を実装している場合、コンパイラにより `T` からメソッ"
"ドを透過的に呼び出せるようになります。"

#: src/std-types/string.md
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr ""
"`Deref` トレイトについてはまだ説明していないため、現時点では主にドキュメント"
"のサイドバーの構造について説明しています。"

#: src/std-types/string.md
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String` は `Deref<Target = str>` を実装し、`str` のメソッドへのアクセスを透"
"過的に許可します。"

#: src/std-types/string.md
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "`let s3 = s1.deref();` と `let s3 = &*s1;` を記述して比較します。"

#: src/std-types/string.md
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String` はバイトのベクターのラッパーとして実装されます。ベクターでサポートさ"
"れているオペレーションの多くは `String` でもサポートされていますが、いくつか"
"の保証が追加されています。"

#: src/std-types/string.md
msgid "Compare the different ways to index a `String`:"
msgstr "`String` にインデックスを付けるさまざまな方法を比較します。"

#: src/std-types/string.md
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"文字には `s3.chars().nth(i).unwrap()` を使用します。ここで `i` は境界内の場合"
"や境界外の場合を表します。"

#: src/std-types/string.md
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"部分文字列には `s3[0..4]` を使用します。このスライスは、文字境界にある場合と"
"ない場合があります。"

#: src/std-types/vec.md
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) は、サイズ変更可能"
"な標準のヒープ割り当てバッファです。"

#: src/std-types/vec.md
msgid "\"v1: len = {}, capacity = {}\""
msgstr "\"v1: len = {}, capacity = {}\""

#: src/std-types/vec.md
msgid "\"v2: len = {}, capacity = {}\""
msgstr "\"v2: len = {}, capacity = {}\""

#: src/std-types/vec.md
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr "// 要素でベクターを初期化する正規マクロ。\n"

#: src/std-types/vec.md
msgid "// Retain only the even elements.\n"
msgstr "// 偶数要素のみを保持します。\n"

#: src/std-types/vec.md
msgid "\"{v3:?}\""
msgstr "\"{v3:?}\""

#: src/std-types/vec.md
msgid "// Remove consecutive duplicates.\n"
msgstr "// 連続する重複を削除します。\n"

#: src/std-types/vec.md
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` は [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/struct."
"Vec.html#deref-methods-%5BT%5D) を実装しているため、`Vec` でスライス メソッド"
"を呼び出すことができます。"

#: src/std-types/vec.md
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec` は、`String` および `HashMap` とともにコレクションの一種です。含まれて"
"いるデータはヒープに格納されるため、コンパイル時にデータ量を把握する必要はあ"
"りません。データ量は実行時に増加または減少する場合があります。"

#: src/std-types/vec.md
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"`Vec<T>` もジェネリック型ですが、`T` を明示的に指定する必要はありません。"
"Rust の型推論でいつも行われるように、最初の `push` 呼び出しで `T` が確立され"
"ています。"

#: src/std-types/vec.md
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]` は `Vec::new()` の代わりに使用する正規のマクロで、ベクターへの初"
"期要素の追加をサポートしています。"

#: src/std-types/vec.md
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"ベクターにインデックスを付けるには `[` `]` を使用しますが、境界外の場合はパ"
"ニックが発生します。または、`get` を使用すると `Option` が返されます。`pop` "
"関数は最後の要素を削除します。"

#: src/std-types/vec.md
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""
"スライスについては 3 日目に説明します。受講者は現時点では、型 `Vec` の値によ"
"り、ドキュメントに記されたすべてのスライスメソッドにアクセスできることだけを"
"知っていれば十分です。"

#: src/std-types/hashmap.md
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "HashDoS 攻撃から保護する標準のハッシュマップ:"

#: src/std-types/hashmap.md
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"Adventures of Huckleberry Finn\""

#: src/std-types/hashmap.md
msgid "\"Grimms' Fairy Tales\""
msgstr "\"Grimms' Fairy Tales\""

#: src/std-types/hashmap.md
msgid "\"Pride and Prejudice\""
msgstr "\"Pride and Prejudice\""

#: src/std-types/hashmap.md
msgid "\"Les Misérables\""
msgstr "\"Les Misérables\""

#: src/std-types/hashmap.md
msgid "\"We know about {} books, but not Les Misérables.\""
msgstr "\"We know about {} books, but not Les Misérables.\""

#: src/std-types/hashmap.md
msgid "\"Alice's Adventure in Wonderland\""
msgstr "\"Alice's Adventure in Wonderland\""

#: src/std-types/hashmap.md
msgid "\"{book}: {count} pages\""
msgstr "\"{book}: {count} pages\""

#: src/std-types/hashmap.md
msgid "\"{book} is unknown.\""
msgstr "\"{book} is unknown.\""

#: src/std-types/hashmap.md
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr ""
"// 何も見つからなかった場合は、.entry() メソッドを使用して値を挿入します。\n"

#: src/std-types/hashmap.md
msgid "\"{page_counts:#?}\""
msgstr "\"{page_counts:#?}\""

#: src/std-types/hashmap.md
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap` はプレリュードで定義されていないため、スコープに含める必要がありま"
"す。"

#: src/std-types/hashmap.md
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"次のコード行を試します。最初の行で、書籍がハッシュマップにあるかどうかを確認"
"し、ない場合は代替値を返します。書籍が見つからなかった場合、2 行目でハッシュ"
"マップに代替値を挿入します。"

#: src/std-types/hashmap.md
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr "\"Harry Potter and the Sorcerer's Stone\""

#: src/std-types/hashmap.md
msgid "\"The Hunger Games\""
msgstr "\"The Hunger Games\""

#: src/std-types/hashmap.md
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr "`vec!` とは異なり、標準の `hashmap!` マクロはありません。"

#: src/std-types/hashmap.md
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"しかし、Rust 1.56 以降では、HashMap は [`From<[(K, V); N]>`](https://doc."
"rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,"
"+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E) を実装しています。これによ"
"り、リテラル配列からハッシュマップを簡単に初期化できます。"

#: src/std-types/hashmap.md
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""
"別の方法として、HashMap は、Key-Value タプルを生成する任意の `Iterator` から"
"作成することもできます。"

#: src/std-types/hashmap.md
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"ここでは `HashMap<String, i32>` を示していますが、例を簡単にするために "
"`&str` をキーとして使用しないようにしています。もちろん、コレクション内で参照"
"を使用することもできますが、それによって借用チェッカーが複雑になる可能性があ"
"ります。"

#: src/std-types/hashmap.md
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"上記の例から `to_string()` を削除して、まだコンパイルできるかどうかを確認しま"
"す。どこで問題が発生するでしょうか。"

#: src/std-types/hashmap.md
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"この型には、`std::collections::hash_map::Keys` などの「メソッド固有の」戻り値"
"の型がいくつかあります。これらの型は、Rust ドキュメントの検索でよく使用されま"
"す。この型のドキュメントと、`keys` メソッドに戻るのに役立つリンクを受講者に示"
"します。"

#: src/std-types/exercise.md
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""
"この演習では、非常にシンプルなデータ構造を汎用的なものにします。[`std::"
"collections::HashMap`](https://doc.rust-lang.org/stable/std/collections/"
"struct.HashMap.html) を使用して、どの値が確認され、各値が何回出現したかを追跡"
"します。"

#: src/std-types/exercise.md
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""
"`Counter` の初期バージョンは、`u32` の値でのみ機能するようにハードコードされ"
"ています。追跡する値の型に対して構造体とそのメソッドをジェネリック化します。"
"これにより、`Counter` であらゆる型の値を追跡できます。"

#: src/std-types/exercise.md
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""
"早めに終わった場合は、[`entry`](https://doc.rust-lang.org/stable/std/"
"collections/struct.HashMap.html#method.entry) メソッドを使用して、`count` メ"
"ソッドの実装に必要なハッシュ ルックアップの回数を半分にしてみましょう。"

#: src/std-types/exercise.md src/std-types/solution.md
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr "/// カウンタは型 T の各値が確認された回数をカウントします。\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "/// Create a new Counter.\n"
msgstr "/// 新しいカウンタを作成します。\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "/// Count an occurrence of the given value.\n"
msgstr "/// 指定された値の発生をカウントします。\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "/// Return the number of times the given value has been seen.\n"
msgstr "/// 指定された値が確認された回数を返します。\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"saw {} values equal to {}\""
msgstr "\"saw {} values equal to {}\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"apple\""
msgstr "\"apple\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"orange\""
msgstr "\"orange\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"got {} apples\""
msgstr "\"got {} apples\""

#: src/std-traits.md
msgid "[Comparisons](./std-traits/comparisons.md) (10 minutes)"
msgstr "[比較](./std-lets/comparisons.md)（10 分）"

#: src/std-traits.md
msgid "[Operators](./std-traits/operators.md) (10 minutes)"
msgstr "[演算子](./std-train/operators.md)（10 分）"

#: src/std-traits.md
msgid "[From and Into](./std-traits/from-and-into.md) (10 minutes)"
msgstr "[From と Into](./std-lets/from-and-into.md)（10 分）"

#: src/std-traits.md
msgid "[Casting](./std-traits/casting.md) (5 minutes)"
msgstr "[キャスト](./std-train/casting.md)（5 分）"

#: src/std-traits.md
msgid "[Read and Write](./std-traits/read-and-write.md) (10 minutes)"
msgstr "[読み取りと書き込み](./std-train/read-and-write.md)（10 分）"

#: src/std-traits.md
msgid "[Default, struct update syntax](./std-traits/default.md) (5 minutes)"
msgstr "[Default、構造体更新記法](./std-lets/default.md)（5 分）"

#: src/std-traits.md
msgid "[Closures](./std-traits/closures.md) (20 minutes)"
msgstr "[クロージャ](./std-lets/closures.md)（20 分）"

#: src/std-traits.md
msgid "[Exercise: ROT13](./std-traits/exercise.md) (30 minutes)"
msgstr "[演習: ROT13](./std-train/exercise.md)（30 分）"

#: src/std-traits.md
msgid "This segment should take about 1 hour and 40 minutes"
msgstr "このセグメントの所要時間は約 1 時間 40 分です"

#: src/std-traits.md
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr ""
"標準ライブラリ型と同様に、時間をかけて各トレイトのドキュメントを確認します。"

#: src/std-traits.md
msgid "This section is long. Take a break midway through."
msgstr "このセクションは長いため、途中で休憩を取ってください。"

#: src/std-traits/comparisons.md
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""
"これらのトレイトは値の比較をサポートします。すべてのトレイトは、これらのトレ"
"イトを実装するフィールドを含む型用に導出できます。"

#: src/std-traits/comparisons.md
msgid "`PartialEq` and `Eq`"
msgstr "`PartialEq` と `Eq`"

#: src/std-traits/comparisons.md
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""
"`PartialEq` は、必須のメソッド `eq` と指定されたメソッド `ne` を持つ部分的な"
"等価関係です。`==` 演算子と `!=` 演算子は、これらのメソッドを呼び出します。"

#: src/std-traits/comparisons.md
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""
"`Eq` は完全な等価関係（反射的、対称的、推移的）であり、`PartialEq` を意味しま"
"す。完全な等価関係を必要とする関数は、トレイト境界として `Eq` を使用します。"

#: src/std-traits/comparisons.md
msgid "`PartialOrd` and `Ord`"
msgstr "`PartialOrd` と `Ord`"

#: src/std-traits/comparisons.md
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""
"`PartialOrd` は `partial_cmp` メソッドを使って部分的な順序を定義します。これ"
"は、`<`、`<=`、`>=`、`>` 演算子を実装するために使用されます。"

#: src/std-traits/comparisons.md
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr "`Ord` は全順序を示し、`cmp` は `Ordering` を返します。"

#: src/std-traits/comparisons.md
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr ""
"`PartialEq` は異なる型の間で実装できますが、`Eq` は反射的であるため、実装でき"
"ません。"

#: src/std-traits/comparisons.md
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr ""
"実際には、これらのトレイトを導出することは一般的ですが、実装するのは一般的で"
"はありません。"

#: src/std-traits/operators.md
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"演算子のオーバーロードは、[`std::ops`](https://doc.rust-lang.org/std/ops/"
"index.html) 内のトレイトを介して実装されます。"

#: src/std-traits/operators.md
msgid "\"{:?} + {:?} = {:?}\""
msgstr "\"{:?} + {:?} = {:?}\""

#: src/std-traits/operators.md src/memory-management/drop.md
msgid "Discussion points:"
msgstr "議論のポイント:"

#: src/std-traits/operators.md
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr ""
"`&Point` に `Add` を実装できます。これはどのような状況で役に立ちますか？"

#: src/std-traits/operators.md
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"回答: `Add:add` は `self` を使用します。演算子をオーバーロードする型 `T` が "
"`Copy` でない場合は、`&T` の演算子もオーバーロードすることを検討する必要があ"
"ります。これにより、呼び出し箇所での不要なクローン作成を回避できます。"

#: src/std-traits/operators.md
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"`Output` が関連型であるのはなぜですか？これをメソッドの型パラメータにできるで"
"しょうか？"

#: src/std-traits/operators.md
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"短い回答: 関数型のパラメータは呼び出し元によって制御されますが、関連型"
"（`Output` など）はトレイトの実装者によって制御されます。"

#: src/std-traits/operators.md
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"2 種類の型に対して `Add` を実装できます。たとえば、`impl Add<(i32, i32)> for "
"Point` は `Point` にタプルを追加します。"

#: src/std-traits/from-and-into.md
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"型は、型変換を容易にする [`From`](https://doc.rust-lang.org/std/convert/"
"trait.From.html) と [`Into`](https://doc.rust-lang.org/std/convert/trait."
"Into.html) を実装しています。"

#: src/std-traits/from-and-into.md
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr "\"{s}, {addr}, {one}, {bigger}\""

#: src/std-traits/from-and-into.md
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) が実装される"
"と、[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) が自動的"
"に実装されます。"

#: src/std-traits/from-and-into.md
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"このように `Into` も実装されるため、型には `From` のみを実装するのが一般的で"
"す。"

#: src/std-traits/from-and-into.md
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"「`String` に変換できるすべて」のような関数引数の入力型を宣言する場合、この"
"ルールは逆となり、`Into`を使用する必要があります。関数は、`From` を実装する型"
"と、`Into` _のみ_ を実装する型を受け入れます。"

#: src/std-traits/casting.md
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""
"Rust には _暗黙的_ な型変換はありませんが、`as` による明示的なキャストはサ"
"ポートされています。これらのキャストは通常、それらが定義されている C セマン"
"ティクスに従います。"

#: src/std-traits/casting.md
msgid "\"as u16: {}\""
msgstr "\"as u16: {}\""

#: src/std-traits/casting.md
msgid "\"as i16: {}\""
msgstr "\"as i16: {}\""

#: src/std-traits/casting.md
msgid "\"as u8: {}\""
msgstr "\"as u8: {}\""

#: src/std-traits/casting.md
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""
"`as` の結果は Rust で _常に_ 定義され、プラットフォーム間で一貫しています。こ"
"れは、正負の符号を変えたり、より小さな型にキャストしたりする際に得られる直感"
"に反しているかもしれません。ドキュメントを確認し、明確にするためにコメントを"
"記述してください。"

#: src/std-traits/casting.md
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""
"`as` を使用したキャストは比較的扱いにくく、誤って使用することが少なくありませ"
"ん。また、将来のメンテナンス作業で、使用される型や型の値の範囲が変更された際"
"に、わかりにくいバグが発生する可能性があります。キャストは、無条件の切り捨て"
"を示すことを目的としている場合にのみ、最適に使用されます（たとえば、上位ビッ"
"トの内容に関係なく、`as u32` で `u64` の下位 32 ビットを選択する場合）。"

#: src/std-traits/casting.md
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""
"絶対に正しいキャスト（例: `u32` から `u64` へのキャスト）では、キャストが実際"
"に完璧であることを確認するために、`as` ではなく `From` または `Into` を使用す"
"ることをおすすめします。正しくない可能性があるキャストについては、絶対に正し"
"いキャストとは異なる方法でそれらを処理したい場合に、`TryFrom` と `TryInto` を"
"使用できます。"

#: src/std-traits/casting.md
msgid "Consider taking a break after this slide."
msgstr "このスライドの後で休憩を取ることを検討してください。"

#: src/std-traits/casting.md
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""
"`as` は C++ の静的キャストに似ています。データが失われる可能性がある状況で "
"`as` を使用することは、一般的に推奨されません。使用する場合は、少なくとも説明"
"のコメントを記述することをおすすめします。"

#: src/std-traits/casting.md
msgid "This is common in casting integers to `usize` for use as an index."
msgstr ""
"これは、整数を`usize` にキャストしてインデックスとして使用する場合に一般的で"
"す。"

#: src/std-traits/read-and-write.md
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) と [`BufRead`]"
"(https://doc.rust-lang.org/std/io/trait.BufRead.html) を使用することで、`u8` "
"ソースを抽象化できます。"

#: src/std-traits/read-and-write.md
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr "b\"foo\\nbar\\nbaz\\n\""

#: src/std-traits/read-and-write.md
msgid "\"lines in slice: {}\""
msgstr "\"lines in slice: {}\""

#: src/std-traits/read-and-write.md
msgid "\"lines in file: {}\""
msgstr "\"lines in file: {}\""

#: src/std-traits/read-and-write.md
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"同様に、[`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) を使用す"
"ると、`u8` シンクを抽象化できます。"

#: src/std-traits/read-and-write.md
msgid "\"\\n\""
msgstr "\"\\n\""

#: src/std-traits/read-and-write.md src/slices-and-lifetimes/str.md
msgid "\"World\""
msgstr "\"World\""

#: src/std-traits/read-and-write.md
msgid "\"Logged: {:?}\""
msgstr "\"Logged: {:?}\""

#: src/std-traits/default.md
msgid "The `Default` Trait"
msgstr "`Default` トレイト"

#: src/std-traits/default.md
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) トレイ"
"トは、型のデフォルト値を生成します。"

#: src/std-traits/default.md
msgid "\"John Smith\""
msgstr "\"John Smith\""

#: src/std-traits/default.md
msgid "\"{default_struct:#?}\""
msgstr "\"{default_struct:#?}\""

#: src/std-traits/default.md
msgid "\"Y is set!\""
msgstr "\"Y is set!\""

#: src/std-traits/default.md
msgid "\"{almost_default_struct:#?}\""
msgstr "\"{almost_default_struct:#?}\""

#: src/std-traits/default.md src/slices-and-lifetimes/exercise.md
#: src/slices-and-lifetimes/solution.md
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/std-traits/default.md
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr "直接実装することも、`#[derive(Default)]` で導出することもできます。"

#: src/std-traits/default.md
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"導出による実装では、すべてのフィールドがデフォルト値に設定された値が生成され"
"ます。"

#: src/std-traits/default.md
msgid "This means all types in the struct must implement `Default` too."
msgstr "つまり、構造体内のすべての型にも `Default` を実装する必要があります。"

#: src/std-traits/default.md
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"標準の Rust 型は多くの場合、妥当な値（`0`、`\"\"` など）の `Default` を実装し"
"ます。"

#: src/std-traits/default.md
msgid "The partial struct initialization works nicely with default."
msgstr "部分的な構造体の初期化は、デフォルトで適切に機能します。"

#: src/std-traits/default.md
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"Rust 標準ライブラリは、型が `Default` を実装できることを認識しており、それを"
"使用するコンビニエンス メソッドを提供しています。"

#: src/std-traits/default.md
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"`..` 構文は、[構造体更新記法](https://doc.rust-lang.org/book/ch05-01-"
"defining-structs.html#creating-instances-from-other-instances-with-struct-"
"update-syntax)と呼ばれています。"

#: src/std-traits/closures.md
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"クロージャやラムダ式には、名前を付けることができない型があります。ただし、こ"
"れらは特別な [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html)、"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html)、[`FnOnce`]"
"(https://doc.rust-lang.org/std/ops/trait.FnOnce.html) トレイトを備えていま"
"す。"

#: src/std-traits/closures.md
msgid "\"Calling function on {input}\""
msgstr "\"Calling function on {input}\""

#: src/std-traits/closures.md
msgid "\"add_3: {}\""
msgstr "\"add_3: {}\""

#: src/std-traits/closures.md
msgid "\"accumulate: {}\""
msgstr "\"accumulate: {}\""

#: src/std-traits/closures.md
msgid "\"multiply_sum: {}\""
msgstr "\"multiply_sum: {}\""

#: src/std-traits/closures.md
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"`Fn`（例: `add_3`）は、キャプチャした値を使用も変更もしないか、または何もキャ"
"プチャしない場合があります。これは同時に複数回呼び出すことができます。"

#: src/std-traits/closures.md
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"`FnMut`（例: `accumulate`）は、キャプチャした値を変更することがあります。複数"
"回呼び出すことはできますが、同時に呼び出すことはできません。"

#: src/std-traits/closures.md
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"`FnOnce`（例: `multiply_sum`）がある場合は、1 回だけ呼び出すことができます。"
"これは、キャプチャした値を使用する場合があります。"

#: src/std-traits/closures.md
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` は `FnOnce` のサブタイプで、`Fn` は `FnMut` と `FnOnce` のサブタイプ"
"です。つまり、`FnOnce` が呼び出される場合は常に `FnMut` を使用でき、`FnMut` "
"または `FnOnce` が呼び出される場合は常に `Fn` を使用できます。"

#: src/std-traits/closures.md
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""
"クロージャを受け取る関数を定義する場合、可能であれば（1 回だけ呼び出す）"
"`FnOnce` を使用し、次に `FnMut`、最後に `Fn` を使用するようにします。これによ"
"り、呼び出し元に最も柔軟に対応できます。"

#: src/std-traits/closures.md
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(it can be passed everywhere), then `FnMut`, and lastly `FnOnce`."
msgstr ""
"一方、クロージャがある場合、最も柔軟性の高い方法は、まず `Fn`（どこでも渡すこ"
"とができるため）、次に `FnMut`、最後に `FnOnce` を使用することです。"

#: src/std-traits/closures.md
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"コンパイラは、クロージャがキャプチャする内容に応じて、`Copy`（例: `add_3`）"
"と `Clone`（例: `multiply_sum`）も推測します。"

#: src/std-traits/closures.md
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"デフォルトでは、可能であれば、クロージャは参照によってキャプチャします。"
"`move` キーワードを使用すると、クロージャは値によってキャプチャします。"

#: src/std-traits/closures.md
msgid "\"Hi\""
msgstr "\"Hi\""

#: src/std-traits/closures.md
msgid "\"there\""
msgstr "\"there\""

#: src/std-traits/exercise.md
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""
"この例では、古典的な [「ROT13」暗号](https://en.wikipedia.org/wiki/ROT13)を実"
"装します。このコードをプレイグラウンドにコピーし、欠落しているビットを実装し"
"てください。結果が有効な UTF-8 のままになるように、ASCII アルファベット文字の"
"みをローテーションします。"

#: src/std-traits/exercise.md
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr "// `RotDecoder` の `Read` トレイトを実装します。\n"

#: src/std-traits/exercise.md src/std-traits/solution.md
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr "\"Gb trg gb gur bgure fvqr!\""

#: src/std-traits/exercise.md src/std-traits/solution.md
msgid "\"To get to the other side!\""
msgstr "\"To get to the other side!\""

#: src/std-traits/exercise.md
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""
"それぞれが 13 文字ずつローテーションされる 2 つの `RotDecoder` インスタンスを"
"連結するとどうなるでしょうか。"

#: src/std-traits/solution.md
msgid "'A'"
msgstr "'A'"

#: src/welcome-day-3.md
msgid "Welcome to Day 3"
msgstr "3 日目のトレーニングにようこそ"

#: src/welcome-day-3.md
msgid "Today, we will cover:"
msgstr "本日の内容:"

#: src/welcome-day-3.md
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr ""
"メモリ管理、ライフタイム、借用チェッカー: Rust がメモリの安全性を確保する仕組"
"み。"

#: src/welcome-day-3.md
msgid "Smart pointers: standard library pointer types."
msgstr "スマートポインタ: 標準ライブラリのポインタ型。"

#: src/welcome-day-3.md
msgid "[Welcome](./welcome-day-3.md) (3 minutes)"
msgstr "[ようこそ](./welcome-day-3.md)（3 分）"

#: src/welcome-day-3.md
msgid "[Memory Management](./memory-management.md) (1 hour and 10 minutes)"
msgstr "[メモリ管理](./memory-management.md)（1 時間 10 分）"

#: src/welcome-day-3.md
msgid "[Smart Pointers](./smart-pointers.md) (45 minutes)"
msgstr "[スマート ポインタ](./smart-pointers.md)（45 分）"

#: src/welcome-day-3.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 15 "
"minutes"
msgstr "このセッションの所要時間は、10 分間の休憩を入れて約 2 時間 15 分です。"

#: src/memory-management.md
msgid "[Review of Program Memory](./memory-management/review.md) (5 minutes)"
msgstr "[プログラム メモリの復習](./memory-management/review.md)（5 分）"

#: src/memory-management.md
msgid ""
"[Approaches to Memory Management](./memory-management/approaches.md) (10 "
"minutes)"
msgstr "[メモリ管理の方法](./memory-management/approaches.md)（10 分）"

#: src/memory-management.md
msgid "[Ownership](./memory-management/ownership.md) (5 minutes)"
msgstr "[所有権](./memory-management/ownership.md)（5 分）"

#: src/memory-management.md
msgid "[Move Semantics](./memory-management/move.md) (10 minutes)"
msgstr "[ムーブ セマンティクス](./memory-management/move.md)（10 分）"

#: src/memory-management.md
msgid "[Clone](./memory-management/clone.md) (2 minutes)"
msgstr "[Clone](./memory-management/clone.md)（2 分）"

#: src/memory-management.md
msgid "[Copy Types](./memory-management/copy-types.md) (5 minutes)"
msgstr "[Copy 型](./memory-management/copy-types.md)（5 分）"

#: src/memory-management.md
msgid "[Drop](./memory-management/drop.md) (10 minutes)"
msgstr "[Drop](./memory-management/drop.md)（10 分）"

#: src/memory-management.md
msgid "[Exercise: Builder Type](./memory-management/exercise.md) (20 minutes)"
msgstr "[演習: ビルダー型](./memory-management/exercise.md)（20 分）"

#: src/memory-management/review.md
msgid "Programs allocate memory in two ways:"
msgstr "プログラムは、次の 2 つの方法でメモリを割り当てます。"

#: src/memory-management/review.md
msgid "Stack: Continuous area of memory for local variables."
msgstr "スタック: ローカル変数用の連続したメモリ領域。"

#: src/memory-management/review.md
msgid "Values have fixed sizes known at compile time."
msgstr "値のサイズは固定されており、コンパイル時に判明しています。"

#: src/memory-management/review.md
msgid "Extremely fast: just move a stack pointer."
msgstr "非常に高速: スタック ポインタを移動するだけです。"

#: src/memory-management/review.md
msgid "Easy to manage: follows function calls."
msgstr "関数呼び出しによって行われるため、管理が容易です。"

#: src/memory-management/review.md
msgid "Great memory locality."
msgstr "メモリ局所性に優れています。"

#: src/memory-management/review.md
msgid "Heap: Storage of values outside of function calls."
msgstr "ヒープ: 関数呼び出しに依存しない値の保持領域。"

#: src/memory-management/review.md
msgid "Values have dynamic sizes determined at runtime."
msgstr "値のサイズは動的で、実行時に決定されます。"

#: src/memory-management/review.md
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "スタックよりやや低速で、何らかののブックキーピングが必要です。"

#: src/memory-management/review.md
msgid "No guarantee of memory locality."
msgstr "メモリの局所性が保証されません。"

#: src/memory-management/review.md
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"`String` を作成すると、スタックには固定サイズのメタデータが配置され、ヒープに"
"はサイズが動的に決定されるデータ（実際の文字列）が配置されます。"

#: src/memory-management/review.md
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"`String` は `Vec` により実現されているため、容量と長さがあり、可変であれば"
"ヒープ上の再割り当てによって拡張できることを説明します。"

#: src/memory-management/review.md
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"受講者から尋ねられた場合は、[システム アロケータ](https://doc.rust-lang.org/"
"std/alloc/struct.System.html)を使用してメモリ領域がヒープから割り当てられるこ"
"と、[Allocator API](https://doc.rust-lang.org/std/alloc/index.html) を使用し"
"てカスタム アロケータを実装できることを説明してください。"

#: src/memory-management/review.md
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"`unsafe` Rust を使用してメモリ レイアウトを調べることが出来ます。ただし、これ"
"は当然ながら安全でないことを指摘する必要があります。"

#: src/memory-management/review.md src/testing/unit-tests.md
msgid "' '"
msgstr "' '"

#: src/memory-management/review.md
msgid "\"world\""
msgstr "\"world\""

#: src/memory-management/review.md
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""
"// 自宅では行わないでください。これは説明のみを目的としています。\n"
"    // String はそのレイアウトを保証しないため、未定義の動作が\n"
"    // 発生する可能性があります。\n"

#: src/memory-management/review.md
msgid "\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\""
msgstr "\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\""

#: src/memory-management/approaches.md
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "伝統的に、言語は大きく 2 つのカテゴリに分類されます。"

#: src/memory-management/approaches.md
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr "手動でのメモリ管理による完全な制御: C、C++、Pascal など"

#: src/memory-management/approaches.md
msgid "Programmer decides when to allocate or free heap memory."
msgstr ""
"プログラマーがヒープメモリを割り当てまたは解放するタイミングを決定します。"

#: src/memory-management/approaches.md
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr ""
"プログラマーは、ポインタがまだ有効なメモリを指しているかどうかを判断する必要"
"があります。"

#: src/memory-management/approaches.md
msgid "Studies show, programmers make mistakes."
msgstr "調査によると、プログラマーは判断を誤ることがあります。"

#: src/memory-management/approaches.md
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"実行時の自動メモリ管理による完全な安全性: Java、Python、Go、Haskell など"

#: src/memory-management/approaches.md
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr ""
"ランタイム システムにより、メモリは参照できなくなるまで解放されません。"

#: src/memory-management/approaches.md
msgid ""
"Typically implemented with reference counting, garbage collection, or RAII."
msgstr ""
"通常、参照カウント、ガベージ コレクション、または RAII を使用して実装されま"
"す。"

#: src/memory-management/approaches.md
msgid "Rust offers a new mix:"
msgstr "Rust ではこの 2 つを融合することで、新たに以下の特徴を提供します。"

#: src/memory-management/approaches.md
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr "コンパイル時の適切なメモリ管理の適用による、完全な制御と安全性。"

#: src/memory-management/approaches.md
msgid "It does this with an explicit ownership concept."
msgstr "これは、明示的な所有権の概念によって実現されます。"

#: src/memory-management/approaches.md
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr ""
"このスライドは、他の言語を習得済みの受講者に、その文脈の中で Rust を理解して"
"もらうことを目的としています。"

#: src/memory-management/approaches.md
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""
"C では、`malloc` と `free` を使用してヒープを手動で管理する必要があります。よ"
"くあるエラーとしては、`free`の呼び出しを忘れる、同じポインタに対して複数回呼"
"び出す、ポイントしているメモリが解放された後にポインタを逆参照する、などがあ"
"ります。"

#: src/memory-management/approaches.md
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""
"C++ にはスマート ポインタ（`unique_ptr`、`shared_ptr` など）のツールがあり、"
"デストラクタの呼び出しに関する言語保証を利用して、関数が戻ったときにメモリが"
"解放されるようにします。これらのツールを誤用して C と同様のバグを作成すること"
"がよくあります。"

#: src/memory-management/approaches.md
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""
"Java、Go、Pythonでは、アクセスできなくなったメモリの特定と破棄をガーベジコレ"
"クタに依存します。これにより、あらゆるポインタの逆参照が可能になり、解放後の"
"使用などのバグがなくなります。ただし、GC (ガーベジコレクション) にはランタイ"
"ムコストがかかり、適切なチューニングが困難です。"

#: src/memory-management/approaches.md
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""
"Rust の所有権と借用モデルは、多くの場合、割り当てオペレーションと解放オペレー"
"ションを正確に必要な場所で行うことにより、ゼロコストで C のパフォーマンスを実"
"現できます。また、C++ のスマートポインタに似たツールも用意されています。必要"
"に応じて、参照カウントなどの他のオプションを利用できます。また、ランタイムガ"
"ベージコレクションをサポートするためのサードパーティのクレートも使用できます"
"（このクラスでは扱いません）。"

#: src/memory-management/ownership.md
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"すべての変数バインディングには有効なスコープがあり、スコープ外で変数を使用す"
"るとエラーになります。"

#: src/memory-management/ownership.md
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr ""
"これを、変数が値を _所有_ していると表現します。すべての Rustの値所有者は常"
"に 1 人です。"

#: src/memory-management/ownership.md
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr ""
"スコープから外れると変数が破棄 _(drop)_ され、データが解放されます。ここでデ"
"ストラクタを実行してリソースを解放できます。"

#: src/memory-management/ownership.md
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""
"ガベージ コレクションの実装に精通している受講者は、ガベージ コレクタが一連の"
"「ルート」から開始して到達可能なすべてのメモリを見つけることを知っています。"
"Rust の「単一オーナー」の原則も、同様の考え方に基づいています。"

#: src/memory-management/move.md
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "代入すると、変数間で _所有権_ が移動します。"

#: src/memory-management/move.md
msgid "\"Hello!\""
msgstr "\"Hello!\""

#: src/memory-management/move.md src/slices-and-lifetimes/str.md
msgid "\"s2: {s2}\""
msgstr "\"s2: {s2}\""

#: src/memory-management/move.md
msgid "// println!(\"s1: {s1}\");\n"
msgstr "// println!(\"s1: {s1}\");\n"

#: src/memory-management/move.md
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "`s1` を `s2` に代入すると、所有権が移動します。"

#: src/memory-management/move.md
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"`s1` がスコープ外になると、何も所有してないからです（何も所有しません）。"

#: src/memory-management/move.md
msgid "When `s2` goes out of scope, the string data is freed."
msgstr "`s2` がスコープ外になると、文字列データは解放されます。"

#: src/memory-management/move.md
msgid "Before move to `s2`:"
msgstr "`s2` に移動する前:"

#: src/memory-management/move.md
msgid "After move to `s2`:"
msgstr "`s2` に移動した後:"

#: src/memory-management/move.md
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" スタック                             ヒープ\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"（アクセス不可）\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/move.md
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"次の例のように、関数に値を渡すと、その値は関数パラメータに代入されます。これ"
"により、所有権が移動します。"

#: src/memory-management/move.md
msgid "\"Hello {name}\""
msgstr "\"Hello {name}\""

#: src/memory-management/move.md src/android/interoperability/java.md
msgid "\"Alice\""
msgstr "\"Alice\""

#: src/memory-management/move.md
msgid "// say_hello(name);\n"
msgstr "// say_hello(name);\n"

#: src/memory-management/move.md
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"これは、`std::move` を使用しない限り（かつムーブ コンストラクタが定義されてい"
"ない限り）値をコピーする、C++ のデフォルトとは逆であることを説明します。"

#: src/memory-management/move.md
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"移動するのは所有権のみです。データ自体を操作するためにマシンコードが生成され"
"るかどうかは最適化の問題であり、そのようなコピーのためのマシンコードは積極的"
"に最適化されてなくなります。"

#: src/memory-management/move.md
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"単純な値（整数など）には `Copy` のマークを付けることができます（後のスライド"
"を参照）。"

#: src/memory-management/move.md
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "Rust では、クローンは明示的に `clone` を使用して行われます。"

#: src/memory-management/move.md
msgid "In the `say_hello` example:"
msgstr "`say_hello` の例の内容は次のとおりです。"

#: src/memory-management/move.md
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"`say_hello` の最初の呼び出しで、`main` は `name` の所有権を放棄します。その後"
"は `main` 内で `name` が使用できなくなります。"

#: src/memory-management/move.md
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"`name` に割り当てられたヒープメモリは、`say_hello` 関数の最後で解放されます。"

#: src/memory-management/move.md
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main` が`name` を参照として渡し（`&name`）、`say_hello` がパラメータとして参"
"照を受け入れる場合、`main` は所有権を保持できます。"

#: src/memory-management/move.md
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"または、`main` が最初の呼び出しで `name` のクローン（`name.clone()`）を渡すこ"
"ともできます。"

#: src/memory-management/move.md
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Rust では、ムーブ セマンティクスをデフォルトにし、クローンをプログラマに明示"
"的に行わせています。これにより、C++ に比べて意図せずコピーを作成するリスクが"
"低減されています。"

#: src/memory-management/move.md
#, fuzzy
msgid "Defensive Copies in Modern C++"
msgstr "現代C++の二重解放"

#: src/memory-management/move.md
msgid "Modern C++ solves this differently:"
msgstr "最新の C++ では、この問題を別の方法で解決します。"

#: src/memory-management/move.md
msgid "\"Cpp\""
msgstr "\"Cpp\""

#: src/memory-management/move.md
msgid "// Duplicate the data in s1.\n"
msgstr "// s1 にデータを複製します。\n"

#: src/memory-management/move.md
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"`s1` からのヒープデータが複製され、`s2` は自身の独立したコピーを取得します。"

#: src/memory-management/move.md
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr "`s1` と `s2` がスコープ外になると、それぞれ自身のメモリを解放します。"

#: src/memory-management/move.md
msgid "Before copy-assignment:"
msgstr "コピー代入前:"

#: src/memory-management/move.md
msgid "After copy-assignment:"
msgstr "コピー代入後:"

#: src/memory-management/move.md
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""
"C++ のアプローチは、Rust とは若干異なります。`=` を使用するとデータがコピーさ"
"れるため、文字列データのクローンを作成する必要があるためです。そうしないと、"
"いずれかの文字列がスコープ外になったときに二重解放が発生します。"

#: src/memory-management/move.md
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""
"C++ には [`std::move`](https://en.cppreference.com/w/cpp/utility/move) もあり"
"ますが、これは値をムーブできるタイミングを示すために使用されます。この例で "
"`s2 = std::move(s1)` となっていた場合は、ヒープ割り当ては行われません。ムーブ"
"後、`s1` は有効であるものの、未指定の状態になります。Rust とは異なり、プログ"
"ラマーは `s1` を引き続き使用できます。"

#: src/memory-management/move.md
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""
"Rust とは異なり、C++ の `=` は、コピーまたは移動される型によって決定される任"
"意のコードを実行できます。"

#: src/memory-management/clone.md
msgid "Clone"
msgstr "複製"

#: src/memory-management/clone.md
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr "値のコピーを作成したい場合は、`Clone` トレイトを使用できます。"

#: src/memory-management/clone.md
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `Vec::new` or `Box::"
"new`."
msgstr ""
"`Clone` はヒープ割当が起きる場所を見つけやすくすることを目的としたものです。"
"`.clone()` のほか、`Vec::new` や `Box::new` などを探してください。"

#: src/memory-management/clone.md
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""
"借用チェッカーが通らない場合に「とりあえずクローンを作成して切り抜けておい"
"て」、あとからクローンのないコードへの最適化を試みるのもよくあることです。"

#: src/memory-management/copy-types.md
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"言語としてのデフォルトはムーブセマンティクスですが、特定の型ではデフォルトで"
"コピーが行われます。"

#: src/memory-management/copy-types.md
msgid "These types implement the `Copy` trait."
msgstr "これらの型は `Copy` トレイトを実装しているからです。"

#: src/memory-management/copy-types.md
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"あなたが定義した独自の型のデフォルトをコピーセマンティクスにすることが出来ま"
"す。"

#: src/memory-management/copy-types.md
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "代入後は、`p1` と `p2` の両方が独自のデータを所有します。"

#: src/memory-management/copy-types.md
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "`p1.clone()` を使用してデータを明示的にコピーすることもできます。"

#: src/memory-management/copy-types.md
msgid "Copying and cloning are not the same thing:"
msgstr "コピーとクローン作成は同じではありません。"

#: src/memory-management/copy-types.md
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"コピーとは、メモリ領域のビット単位コピーのことであり、任意のオブジェクトでは"
"機能しません。"

#: src/memory-management/copy-types.md
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"コピーではカスタムロジックは使用できません（C++ のコピーコンストラクタとは異"
"なります）。"

#: src/memory-management/copy-types.md
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"クローン作成はより一般的なオペレーションであり、`Clone` トレイトを実装するこ"
"とでカスタム動作も可能になります。"

#: src/memory-management/copy-types.md
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr "`Drop` トレイトを実装している型では、コピーは出来ません。"

#: src/memory-management/copy-types.md
msgid "In the above example, try the following:"
msgstr "上記の例で、次の方法を試してください。"

#: src/memory-management/copy-types.md
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"`String` フィールドを`struct Point` に追加します。`String` が `Copy` 型ではな"
"いため、コンパイルできなくなります。"

#: src/memory-management/copy-types.md
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"`derive` 属性から `Copy` を削除します。`p1` の `println!` でコンパイラ エラー"
"が発生します。"

#: src/memory-management/copy-types.md
msgid "Show that it works if you clone `p1` instead."
msgstr "代わりに `p1` のクローンを作成すれば解決できることを示します。"

#: src/memory-management/drop.mdmd
msgid "The `Drop` Trait"
msgstr "`Drop` トレイト"

#: src/memory-management/drop.md
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) を実装している値"
"では、スコープから外れるときに実行するコードを指定できます。"

#: src/memory-management/drop.md
msgid "\"Dropping {}\""
msgstr "\"Dropping {}\""

#: src/memory-management/drop.md src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"a\""
msgstr "\"a\""

#: src/memory-management/drop.md src/testing/googletest.md
msgid "\"b\""
msgstr "\"b\""

#: src/memory-management/drop.md
msgid "\"c\""
msgstr "\"c\""

#: src/memory-management/drop.md
msgid "\"d\""
msgstr "\"d\""

#: src/memory-management/drop.md
msgid "\"Exiting block B\""
msgstr "\"Exiting block B\""

#: src/memory-management/drop.md
msgid "\"Exiting block A\""
msgstr "\"Exiting block A\""

#: src/memory-management/drop.md
msgid "\"Exiting main\""
msgstr "\"Exiting main\""

#: src/memory-management/drop.md
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr "`std::mem::drop` は `std::ops::Drop::drop` と同じではありません。"

#: src/memory-management/drop.md
msgid "Values are automatically dropped when they go out of scope."
msgstr "スコープ外になると、値は自動的にドロップされます。"

#: src/memory-management/drop.md
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""
"値がドロップされる際、`std::ops::Drop` を実装している場合は、その `Drop::"
"drop` 実装が呼び出されます。"

#: src/memory-management/drop.md
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""
"その後、`Drop` を実装しているかどうかにかかわらず、すべてのフィールドもドロッ"
"プされます。"

#: src/memory-management/drop.md
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""
"`std::mem::drop` は、任意の値を受け取る空の関数にすぎません。重要なのは、この"
"関数が値の所有権を取得することで、スコープの最後で値がドロップされることで"
"す。これは、スコープ外になる前に値を明示的にドロップするための便利な方法で"
"す。"

#: src/memory-management/drop.md
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""
"この方法は、`drop` で何らかの処理（ロックの解放、ファイルのクローズなど）を行"
"うオブジェクトに使用すると便利です。"

#: src/memory-management/drop.md
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "`Drop::drop` が `self` をパラメータとして取らないのはなぜですか？"

#: src/memory-management/drop.md
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"短い回答: その場合、ブロックの最後に `std::mem::drop` が呼び出されるため、別"
"の `Drop::drop` が呼び出され、スタック オーバーフローが発生します。"

#: src/memory-management/drop.md
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "`drop(a)` を `a.drop()` に置き換えてみてください。"

#: src/memory-management/exercise.md
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""
"この例では、すべてのデータを持つ複雑なデータ型を実装します。「ビルダー パター"
"ン」で便利な関数を使用して、新しい値を 1 つずつ構築できるようにします。"

#: src/memory-management/exercise.md
msgid "Fill in the missing pieces."
msgstr "抜けている部分を記入してください。"

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// A representation of a software package.\n"
msgstr "/// ソフトウェア パッケージの表現。\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""
"/// このパッケージの表現を依存関係として返し、\n"
"    /// 他のパッケージのビルドに使用します。\n"

#: src/memory-management/exercise.md
msgid "\"1\""
msgstr "\"1\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""
"/// パッケージのビルダー。`build()` を使用して `Package` 自体を作成します。\n"

#: src/memory-management/exercise.md
msgid "\"2\""
msgstr "\"2\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Set the package version.\n"
msgstr "/// パッケージのバージョンを設定します。\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Set the package authors.\n"
msgstr "/// パッケージ作成者を設定します。\n"

#: src/memory-management/exercise.md
msgid "\"3\""
msgstr "\"3\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Add an additional dependency.\n"
msgstr "/// 依存関係を追加します。\n"

#: src/memory-management/exercise.md
msgid "\"4\""
msgstr "\"4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr ""
"/// 言語を設定します。設定しない場合、言語はデフォルトで None になります。\n"

#: src/memory-management/exercise.md
msgid "\"5\""
msgstr "\"5\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"base64\""
msgstr "\"base64\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"0.13\""
msgstr "\"0.13\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"base64: {base64:?}\""
msgstr "\"base64: {base64:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"log\""
msgstr "\"log\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"0.4\""
msgstr "\"0.4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"log: {log:?}\""
msgstr "\"log: {log:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"serde\""
msgstr "\"serde\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"djmitche\""
msgstr "\"djmitche\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"4.0\""
msgstr "\"4.0\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"serde: {serde:?}\""
msgstr "\"serde: {serde:?}\""

#: src/memory-management/solution.md
msgid "\"0.1\""
msgstr "\"0.1\""

#: src/smart-pointers.md
msgid "[Box"
msgstr "[Box"

#: src/smart-pointers.md
msgid "](./smart-pointers/box.md) (10 minutes)"
msgstr "](./smart-pointers/box.md)（10 分）"

#: src/smart-pointers.md
msgid "[Rc](./smart-pointers/rc.md) (5 minutes)"
msgstr "[Rc](./smart-pointers/rc.md)（5 分）"

#: src/smart-pointers.md
msgid "[Exercise: Binary Tree](./smart-pointers/exercise.md) (30 minutes)"
msgstr "[演習: バイナリツリー](./smart-pointers/exercise.md)（30 分）"

#: src/smart-pointers/box.md
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) は、ヒープ上の"
"データへの所有ポインタです。"

#: src/smart-pointers/box.md
msgid "\"five: {}\""
msgstr "\"five: {}\""

#: src/smart-pointers/box.md
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` は `Deref<Target = T>` を実装しているため、[`Box<T>` に対して T のメ"
"ソッドを直接呼び出す](https://doc.rust-lang.org/std/ops/trait.Deref."
"html#more-on-deref-coercion)ことができます。"

#: src/smart-pointers/box.md
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"再帰データ型、またはサイズが動的なデータ型では、`Box` を使用する必要がありま"
"す。"

#: src/smart-pointers/box.md
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr "/// 空でないリスト: 最初の要素とリストの残り。\n"

#: src/smart-pointers/box.md
msgid "/// An empty list.\n"
msgstr "/// 空のリスト。\n"

#: src/smart-pointers/box.md
msgid "\"{list:?}\""
msgstr "\"{list:?}\""

#: src/smart-pointers/box.md
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"

#: src/smart-pointers/box.md
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"`Box` は C++ の `std::unique_ptr` と似ていますが、null ではないことが保証され"
"ている点が異なります。"

#: src/smart-pointers/box.md
msgid "A `Box` can be useful when you:"
msgstr "`Box` は次のような場合に役立ちます。"

#: src/smart-pointers/box.md
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""
"コンパイル時にサイズを把握できない型があるが、Rust コンパイラがその正確なサイ"
"ズを知る必要がある場合。"

#: src/smart-pointers/box.md
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"大量のデータの所有権をムーブしたい場合。スタック上の大量のデータがコピーされ"
"ないようにするには、代わりに`Box` によりヒープ上にデータを格納し、ポインタの"
"みが移動されるようにします。"

#: src/smart-pointers/box.md
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not be able to compute a fixed size for the "
"struct in memory (the `List` would be of infinite size)."
msgstr ""
" 仮に`Box` を使用せずに `List` を `List` に直接埋め込もうとすると、コンパイラ"
"はメモリ内の構造体の固定サイズを計算しようとしません（`List` は無限サイズにな"
"ります）。"

#: src/smart-pointers/box.md
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` がこの問題を解決できるのは、そのサイズが通常のポインタと同じであり、単"
"にヒープ内の List の次の要素を指すだけだけだからです。"

#: src/smart-pointers/box.md
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"List 定義の `Box` を削除して、コンパイラ エラーを表示します。\"Recursive "
"with indirection\" は、値を直接保持するのではなく、Boxや何らかの参照を使用し"
"たら良いことを示唆するものです。"

#: src/smart-pointers/box.md
msgid "Niche Optimization"
msgstr "Niche最適化"

#: src/smart-pointers/box.md
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box` を空にすることはできないため、ポインタは常に有効かつ非 `null` になりま"
"す。これにより、コンパイラがメモリ レイアウトを最適化できます。"

#: src/smart-pointers/box.md
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - -.\n"
":                            :     :                           :\n"
":    list                    :     :                           :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":                            :     :                           :\n"
":                            :     :                           :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - -.\n"
":                            :     :                           :\n"
":    list                    :     :                           :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":                            :     :                           :\n"
":                            :     :                           :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - -'\n"
"```"

#: src/smart-pointers/rc.md
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) は、参照カウントされ"
"た共有ポインタです。複数の場所から同じデータを参照する必要がある場合に使用し"
"ます。"

#: src/smart-pointers/rc.md
msgid "\"a: {a}\""
msgstr "\"a: {a}\""

#: src/smart-pointers/rc.md
msgid "\"b: {b}\""
msgstr "\"b: {b}\""

#: src/smart-pointers/rc.md
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"マルチスレッドのコンテキストに関しては、[`Arc`](../concurrency/shared_state/"
"arc.md) と [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) を"
"ご覧ください。"

#: src/smart-pointers/rc.md
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"共有ポインタを [`Weak`](https://doc.rust-lang.org/std/rc/struct.Weak.html) ポ"
"インタにダウングレード _(downgrade)_ すると、ドロップされるサイクルを作成でき"
"ます。"

#: src/smart-pointers/rc.md
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr "`Rc` のカウントは、参照がある限り有効であることを保証します。"

#: src/smart-pointers/rc.md
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "Rust の `Rc` は C++ の `std::shared_ptr` に似ています。"

#: src/smart-pointers/rc.md
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone`の動作は軽量です。同じ割り当て領域へのポインタを作成し、参照カウン"
"トを増やすだけです。デープクローンを作成しないので、性能上の問題箇所をコード"
"から探す場合には通常無視することが出来ます。"

#: src/smart-pointers/rc.md
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` は、必要に応じて内部の値のクローンを作成し（「clone-on-write」）、"
"可変参照を返します。"

#: src/smart-pointers/rc.md
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "`Rc::strong_count` を使用して参照カウントを確認します。"

#: src/smart-pointers/rc.md
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc::downgrade` は、（多くの場合、`RefCell` と組み合わせて）適切にドロップさ"
"れるサイクルを作成するための弱参照カウント _(weakly reference-counted)_ オブ"
"ジェクトを提供します。"

#: src/smart-pointers/exercise.md
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""
"バイナリツリーは、すべてのノードに 2 つの子（左と右）があるツリー型のデータ構"
"造です。ここでは、各ノードが値を格納するツリーを作成します。ある特定のノード "
"N について、N の左側のサブツリー内のすべてのノードにはより小さい値が含まれ、"
"N の右側のサブツリー内のすべてのノードにはより大きい値が含まれます。"

#: src/smart-pointers/exercise.md
msgid "Implement the following types, so that the given tests pass."
msgstr "次の型を実装して、指定されたテストが通るようにします。"

#: src/smart-pointers/exercise.md
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr "追加の実習: バイナリツリーに値を順番に返すイテレータを実装します。"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid "/// A node in the binary tree.\n"
msgstr "/// バイナリツリーのノード。\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid "/// A possibly-empty subtree.\n"
msgstr "/// 空の可能性のあるサブツリー。\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""
"/// バイナリツリーを使用して一連の値を格納するコンテナ。\n"
"///\n"
"/// 同じ値が複数回追加された場合、その値は 1 回だけ格納される。\n"

#: src/smart-pointers/exercise.md
msgid "// Implement `new`, `insert`, `len`, and `has`.\n"
msgstr "// `new`、`insert`、`len`、`has` を実装します。\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid "// not a unique item\n"
msgstr "// 固有のアイテムではない\n"

#: src/smart-pointers/solution.md src/testing/googletest.md
msgid "\"bar\""
msgstr "\"bar\""

#: src/welcome-day-3-afternoon.md
msgid "[Borrowing](./borrowing.md) (1 hour)"
msgstr "[借用](./borrowing.md)（1 時間）"

#: src/welcome-day-3-afternoon.md
msgid ""
"[Slices and Lifetimes](./slices-and-lifetimes.md) (1 hour and 10 minutes)"
msgstr "[スライスとライフタイム](./slices-and-lifetimes.md)（1 時間 10 分）"

#: src/welcome-day-3-afternoon.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 20 "
"minutes"
msgstr "このセッションの所要時間は、10 分間の休憩を入れて約 2 時間 20 分です。"

#: src/borrowing.md
msgid "[Borrowing a Value](./borrowing/shared.md) (10 minutes)"
msgstr "[値の借用](./borrowing/shared.md)（10 分）"

#: src/borrowing.md
msgid "[Borrow Checking](./borrowing/borrowck.md) (10 minutes)"
msgstr "[借用チェック](./borrowing/borrowck.md)（10 分）"

#: src/borrowing.md
msgid "[Interior Mutability](./borrowing/interior-mutability.md) (10 minutes)"
msgstr "[内部可変性](./borrowing/interior-mutability.md)（10 分）"

#: src/borrowing.md
msgid "[Exercise: Health Statistics](./borrowing/exercise.md) (30 minutes)"
msgstr "[演習: 健康に関する統計情報](./borrowing/exercise.md)（30 分）"

#: src/borrowing/shared.md
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr ""
"前に説明したように、関数を呼び出すときに所有権を移動する代わりに、関数で値を"
"借用できます。"

#: src/borrowing/shared.md
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "`add` 関数は 2 つのポイントを _借用_ し、新しいポイントを返します。"

#: src/borrowing/shared.md
msgid "The caller retains ownership of the inputs."
msgstr "呼び出し元は入力の所有権を保持します。"

#: src/borrowing/shared.md
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""
"このスライドでは、1 日目の参照に関する資料を振り返りですが、少し対象を広げ、"
"関数の引数と戻り値も含めています。"

#: src/borrowing/shared.md
msgid "Notes on stack returns:"
msgstr "スタックの戻り値に関する注意事項:"

#: src/borrowing/shared.md
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"コンパイラはコピー オペレーションを省略できるため、`add` からのリターンはコス"
"トであることを示します。スタック アドレスを出力するように上記のコードを変更"
"し、[Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671)"
"で実行するか、[Godbolt](https://rust.godbolt.org/) のアセンブリを確認します。"
"「DEBUG」最適化レベルではアドレスが変更されますが、「RELEASE」設定に変更した"
"場合はアドレスが変更されません。"

#: src/borrowing/shared.md
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "Rust コンパイラは戻り値の最適化（RVO）を行うことができます。"

#: src/borrowing/shared.md
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"C++ では、コンストラクタが副作用をもたらす可能性があるため、言語仕様でコピー"
"省略を定義する必要があります。Rust では、これはまったく問題になりません。RVO "
"が行われなかった場合でも、Rust は常にシンプルで効率的な `memcpy` コピーを実行"
"します。"

#: src/borrowing/borrowck.md
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr ""
"Rust の _借用チェッカー_ は、値を借用する方法に制限を設けます。任意の値に対し"
"て、常に次の制限が課されます。"

#: src/borrowing/borrowck.md
msgid "You can have one or more shared references to the value, _or_"
msgstr "値への共有参照を 1 つ以上持つことが出来ます。または、"

#: src/borrowing/borrowck.md
msgid "You can have exactly one exclusive reference to the value."
msgstr "値への排他参照を 1 つだけ持つことが出来ます。"

#: src/borrowing/borrowck.md
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""
"要件は、競合する参照が同じ時点に存在しないことです。参照がどこで外されていて"
"も構いません。"

#: src/borrowing/borrowck.md
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"上記のコードは、`a` が `c` を通じて可変として借用されていると同時に、`b` を通"
"じて不変として借用されているため、コンパイルできません。"

#: src/borrowing/borrowck.md
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"`b` の `println!` ステートメントを `c` を導入するスコープの前に移動して、コー"
"ドをコンパイル出来るようにします。"

#: src/borrowing/borrowck.md
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"この変更後、コンパイラは c を通じたa の可変参照よりも前にしかbが使われていな"
"いことを認識します。これは「ノンレキシカル ライフタイム(_\"non-lexical "
"lifetimes\"_)」と呼ばれる借用チェッカーの機能です。"

#: src/borrowing/borrowck.md
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""
"排他参照制約は非常に強力です。Rust はこの制約を使用して、データへの競合が発生"
"しないようにするとともに、コードを最適化しています。たとえば、共有参照を通し"
"て得られる値は、その参照が存続する間、安全にレジスタにキャッシュすることが出"
"来ます"

#: src/borrowing/borrowck.md
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""
"借用チェッカーは、構造体内の異なるフィールドへの排他参照を同時に取得するな"
"ど、多くの一般的なパターンに対応するように設計されています。しかし、状況に"
"よっては借用チェッカーがコードを正しく理解できず、「借用チェッカーとの戦い」"
"に発展することが多くあります。"

#: src/borrowing/interior-mutability.md
msgid ""
"In some situations, it's necessary to modify data behind a shared (read-"
"only) reference. For example, a shared data structure might have an internal "
"cache, and wish to update that cache from read-only methods."
msgstr ""
"場合によっては、共有（読み取り専用）参照の背後にあるデータを変更する必要があ"
"ります。たとえば、共有データ構造に内部キャッシュがあり、そのキャッシュを読み"
"取り専用メソッドから更新する必要がある場合があります。"

#: src/borrowing/interior-mutability.md
msgid ""
"The \"interior mutability\" pattern allows exclusive (mutable) access behind "
"a shared reference. The standard library provides several ways to do this, "
"all while still ensuring safety, typically by performing a runtime check."
msgstr ""
"「内部可変性」パターンは、共有参照を通した排他的（可変）アクセスを可能にしま"
"す。標準ライブラリには、これを安全に行うための方法がいくつか用意されており、"
"通常はランタイム チェックを実行することで安全性を確保します。"

#: src/borrowing/interior-mutability.md
msgid "`RefCell`"
msgstr "`RefCell`"

#: src/borrowing/interior-mutability.md
msgid "\"graph: {root:#?}\""
msgstr "\"graph: {root:#?}\""

#: src/borrowing/interior-mutability.md
msgid "\"graph sum: {}\""
msgstr "\"graph sum: {}\""

#: src/borrowing/interior-mutability.md
msgid "`Cell`"
msgstr "`Cell`"

#: src/borrowing/interior-mutability.md
msgid ""
"`Cell` wraps a value and allows getting or setting the value, even with a "
"shared reference to the `Cell`. However, it does not allow any references to "
"the value. Since there are no references, borrowing rules cannot be broken."
msgstr ""
"`Cell` は、値をラップし、`Cell` の共有参照を通してでもその値を取得または設定"
"可能にしています。ただし、その内包する値への参照は許していません。"

#: src/borrowing/interior-mutability.md
msgid ""
"The main thing to take away from this slide is that Rust provides _safe_ "
"ways to modify data behind a shared reference. There are a variety of ways "
"to ensure that safety, and `RefCell` and `Cell` are two of them."
msgstr ""
"このスライドで重要なのは、Rust には、共有参照の背後にあるデータを変更する安全"
"な方法が用意されているということです。安全性を確保するにはさまざまな方法があ"
"りますが、ここでは `RefCell` と `Cell` を取り上げます。"

#: src/borrowing/interior-mutability.md
msgid ""
"`RefCell` enforces Rust's usual borrowing rules (either multiple shared "
"references or a single exclusive reference) with a runtime check. In this "
"case, all borrows are very short and never overlap, so the checks always "
"succeed."
msgstr ""
"`RefCell` は、ランタイム チェックとともに Rust の通常の借用ルール（複数の共有"
"参照または単一の排他参照）を適用します。この場合、すべての借用は非常に短く、"
"重複しないため、チェックは常に成功します。"

#: src/borrowing/interior-mutability.md
msgid ""
"`Rc` only allows shared (read-only) access to its contents, since its "
"purpose is to allow (and count) many references. But we want to modify the "
"value, so we need interior mutability."
msgstr ""
"`Rc` は多くの参照を許可（およびカウント）することを目的としているため、コンテ"
"ンツへの共有（読み取り専用）アクセスのみを許可します。しかし、ここでは値を変"
"更したいので、内部可変性が必要です。"

#: src/borrowing/interior-mutability.md
msgid ""
"`Cell` is a simpler means to ensure safety: it has a `set` method that takes "
"`&self`. This needs no runtime check, but requires moving values, which can "
"have its own cost."
msgstr ""
"`Cell` は安全性を確保するためのよりシンプルな手段であり、`&self` を受け取る "
"`set` メソッドを備えています。ランタイム チェックは必要ありませんが、値を移動"
"する必要があり、それによってコストが発生することがあります。"

#: src/borrowing/interior-mutability.md
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children`."
msgstr ""
"`subtree.children` に `root` を追加して参照ループを作成できることを示します。"

#: src/borrowing/interior-mutability.md
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""
"実行時のパニックを示すため、`self.value` をインクリメントしてその子に対して同"
"じメソッドを呼び出す `fn inc(&mut self)` を追加します。これは、参照ループがあ"
"るとパニックとなり、`thread 'main' panicked at 'already borrowed: "
"BorrowMutError'` というエラーが出力されます。"

#: src/borrowing/exercise.md
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"健康管理システムの実装の一環として、ユーザーの健康に関する統計情報を追跡する"
"必要があります。"

#: src/borrowing/exercise.md
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"`impl` ブロックのスタブ関数と、`User` 構造体の定義がある状態から開始します。"
"`User` 構造体の `impl` ブロックにおいてスタブ化された関数を実装することです。"

#: src/borrowing/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr ""
"以下のコードを <https://play.rust-lang.org/> にコピーし、実体がないメソッドの"
"中身を実装します。"

#: src/borrowing/exercise.md
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#: src/android/build-rules/library.md src/android/aidl/client.md
msgid "\"Bob\""
msgstr "\"Bob\""

#: src/borrowing/exercise.md src/borrowing/solution.md
msgid "\"I'm {} and my age is {}\""
msgstr "\"I'm {} and my age is {}\""

#: src/slices-and-lifetimes.md
msgid "[Slices: &\\[T\\]](./slices-and-lifetimes/slices.md) (10 minutes)"
msgstr "[Slices: &\\[T\\]](./slices-and-lifetimes/slices.md)（10 分）"

#: src/slices-and-lifetimes.md
msgid "[String References](./slices-and-lifetimes/str.md) (10 minutes)"
msgstr "[文字列参照](./slices-and-lifetimes/str.md)（10 分）"

#: src/slices-and-lifetimes.md
msgid ""
"[Lifetime Annotations](./slices-and-lifetimes/lifetime-annotations.md) (10 "
"minutes)"
msgstr ""
"[ライフタイム アノテーション](./slices-and-lifetimes/lifetime-annotations.md)"
"（10 分）"

#: src/slices-and-lifetimes.md
msgid ""
"[Lifetime Elision](./slices-and-lifetimes/lifetime-elision.md) (5 minutes)"
msgstr ""
"[ライフタイムの省略](./slices-and-lifetimes/lifetime-elision.md)（5 分）"

#: src/slices-and-lifetimes.md
msgid ""
"[Struct Lifetimes](./slices-and-lifetimes/struct-lifetimes.md) (5 minutes)"
msgstr ""
"[構造体のライフタイム](./slices-and-lifetimes/struct-lifetimes.md)（5 分）"

#: src/slices-and-lifetimes.md
msgid ""
"[Exercise: Protobuf Parsing](./slices-and-lifetimes/exercise.md) (30 minutes)"
msgstr "[演習: Protobuf の解析](./slices-and-lifetimes/exercise.md)（30 分）"

#: src/slices-and-lifetimes/slices.md
msgid "Slices"
msgstr "Slices"

#: src/slices-and-lifetimes/slices.md
msgid "A slice gives you a view into a larger collection:"
msgstr "スライスは、より大きなコレクションに対するビューを提供します。"

#: src/slices-and-lifetimes/slices.md
msgid "Slices borrow data from the sliced type."
msgstr "スライスは、スライスされた型からデータを借用します。"

#: src/slices-and-lifetimes/slices.md
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr "質問: `s` を出力する直前に `a[3]` を変更するとどうなるでしょうか？"

#: src/slices-and-lifetimes/slices.md
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"スライスを作成するには、`a` を借用し、開始インデックスと終了インデックスを角"
"かっこで囲んで指定します。"

#: src/slices-and-lifetimes/slices.md
msgid ""
"If the slice starts at index 0, Rust’s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"スライスがインデックス 0 から始まる場合、Rust の範囲構文により開始インデック"
"スを省略できます。つまり、`&a[0..a.len()]` と `&a[..a.len()]` は同じです。"

#: src/slices-and-lifetimes/slices.md
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"最後のインデックスについても同じことが言えるので、`&a[2..a.len()]` と "
"`&a[2..]` は同じです。"

#: src/slices-and-lifetimes/slices.md
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""
"配列全体のスライスを簡単に作成するには、`&a[..]` と書くことが出来ます。"

#: src/slices-and-lifetimes/slices.md
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s` は i32 のスライスへの参照です。`s` の型（`&[i32]`）に配列の長さが含まれな"
"くなったことに注目してください。これにより、さまざまなサイズのスライスに対し"
"て計算を実行できます。"

#: src/slices-and-lifetimes/slices.md
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"スライスは常に別のオブジェクトから借用します。この例では、`a` は少なくともス"
"ライスが存在する間は「存続」 している（スコープ内にある)必要があります。"

#: src/slices-and-lifetimes/slices.md
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"`a[3]` の変更に関する質問は興味深い議論のきっかけになるかもしれませんが、メモ"
"リ安全性上の理由から、この時点では `a` を使用して変更することはできない、とい"
"う回答になります。ただし、`a` と `s` の両方のデータを安全に読み取ることはでき"
"ます。これは、スライスを作成する前と、`println` の後でスライスが使用されなく"
"なったあとであれば、変更することが出来ます。"

#: src/slices-and-lifetimes/str.md
msgid ""
"We can now understand the two string types in Rust: `&str` is almost like "
"`&[char]`, but with its data stored in a variable-length encoding (UTF-8)."
msgstr ""
"これで、Rust の 2 つの文字列型を理解できるようになりました。`&str` は "
"`&[char]` とほぼ同じですが、そのデータは可変長エンコード（UTF-8）で保存されま"
"す。"

#: src/slices-and-lifetimes/str.md
msgid "\"s1: {s1}\""
msgstr "\"s1: {s1}\""

#: src/slices-and-lifetimes/str.md
msgid "\"Hello \""
msgstr "\"Hello \""

#: src/slices-and-lifetimes/str.md
msgid "\"s3: {s3}\""
msgstr "\"s3: {s3}\""

#: src/slices-and-lifetimes/str.md
msgid "Rust terminology:"
msgstr "Rust の用語:"

#: src/slices-and-lifetimes/str.md
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str`: 文字列スライスへの不変の参照。"

#: src/slices-and-lifetimes/str.md
msgid "`String` a mutable string buffer."
msgstr "`String`: 可変の文字列バッファ。"

#: src/slices-and-lifetimes/str.md
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`”Hello”`), are stored in the program’s binary."
msgstr ""
"`&str` は文字列スライスを導入します。これは、メモリブロックに保存されている "
"UTF-8 でエンコードされた文字列データへの不変の参照です。文字列リテラル"
"（`”Hello”`）は、プログラムのバイナリに格納されます。"

#: src/slices-and-lifetimes/str.md
msgid ""
"Rust’s `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"Rust の `String` 型は、バイトのベクターのラッパーです。`Vec<T>` と同様、所有"
"されます。"

#: src/slices-and-lifetimes/str.md
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"他の多くの型と同様に、`String::from()` は文字列リテラルから文字列を作成しま"
"す。`String::new()` は新しい空の文字列を作成します。`push()` メソッドと "
"`push_str()` メソッドを使用して、そこに文字列データを追加できます。"

#: src/slices-and-lifetimes/str.md
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"`format!()` マクロを使用すると、動的な値から所有文字列を簡単に生成できます。"
"これは println!() と同じ形式指定を受け入れます。"

#: src/slices-and-lifetimes/str.md
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""
"`&` を使用して `String` から `&str` スライスを借用し、必要に応じて範囲を選択"
"できます。文字境界に揃えられていないバイト範囲を選択すると、その式でパニック"
"を起こします。`chars` イテレータは文字単位で処理するため、正しい文字境界を取"
"得しようとすることよりも、このイテレータを使用するほうが望ましいです。"

#: src/slices-and-lifetimes/str.md
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"C++ プログラマー向けの説明：`&str` は常にメモリ上の有効な文字列を指しているよ"
"うなC++ の std::string_view と考えられます。Rust の `String` は、C++ の "
"`std::string` とおおむね同等です（主な違いは、UTF-8 でエンコードされたバイト"
"のみを含めることができ、短い文字列に対する最適化が行われないことです）。"

#: src/slices-and-lifetimes/str.md
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr "バイト文字列リテラルを使用すると、`&[u8]` 値を直接作成できます。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""
"参照にはライフタイムがあり、これは参照する値よりも「長く存続」してはなりませ"
"ん。これは借用チェッカーによって検証されます。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""
"これまで見てきたとおり、ライフタイムは暗黙に扱えますが、`&'a Point`、"
"`&'document str` のように明示的に指定することもできます。ライフタイムは `'` "
"で始まり、`'a` が一般的なデフォルト名です。`&'a Point` は、「少なくともライフ"
"タイム `a` の間は有効な、借用した `Point`」とと解釈します。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr ""
"ライフタイムは常にコンパイラによって推測されます。自分でライフタイムを割り当"
"てることはできません。明示的なライフタイム アノテーションを使用すると、あいま"
"いなところに制約を課すことができます。それに対し、コンパイラはその制約を満た"
"すライフタイムを設定できることを検証します。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr ""
"関数に値を渡し、関数から値を返すことを考慮する場合、ライフタイムはより複雑に"
"なります。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid "// What is the lifetime of p3?\n"
msgstr "// p3 のライフタイムは？\n"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid "\"p3: {p3:?}\""
msgstr "\"p3: {p3:?}\""

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"In this example, the compiler does not know what lifetime to infer for `p3`. "
"Looking inside the function body shows that it can only safely assume that "
"`p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, Rust "
"requires explicit annotations of lifetimes on function arguments and return "
"values."
msgstr ""
"この例では、コンパイラは `p3` のライフライムを推測するこが出来ませんん。関数"
"本体の内部を見ると、`p3` のライフタイムは `p1` と `p2` のいずれか短いしかし想"
"定できることがわかります。ただし、型と同様に、Rust では関数の引数や戻り値にラ"
"イフタイムの明示的なアノテーションが必要です。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid "Add `'a` appropriately to `left_most`:"
msgstr "`left_most` に `'a` を適切に追加します。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""
"これは、「p1 と p2 の両方が `'a` より長く存続すると、戻り値は少なくとも `'a` "
"の間存続する」という意味になります。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr ""
"一般的なケースでは、次のスライドで説明するようにライフタイムを省略できます。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "Lifetimes in Function Calls"
msgstr "関数とライフタイム"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"関数の引数や戻り値のライフタイムは完全に指定する必要がありますが、Rust ではほ"
"とんどの場合、[いくつかの簡単なルール](https://doc.rust-lang.org/nomicon/"
"lifetime-elision.html)により、ライフタイムを省略できます。これは推論ではな"
"く、構文の省略形にすぎません。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr ""
"ライフタイム アノテーションが付いていない各引数には、1 つのライフタイムが与え"
"られます。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr ""
"引数のライフタイムが 1 つしかない場合、アノテーションのない戻り値すべてにその"
"ライフタイムが与えられます。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""
"引数のライフタイムが複数あり、最初のライフタイムが `self` である場合、アノ"
"テーションのない戻り値すべてにそのライフタイムが与えられます。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "In this example, `cab_distance` is trivially elided."
msgstr ""
"この例では、`cab_distance` に関するライフタイムの記述は省略されています。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""
"`nearest` 関数は、明示的なアノテーションを必要とする複数の参照を引数に含む関"
"数のもう一つの例です。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr ""
"返されるライフタイムについて嘘のアノテーションを付けるようにシグネチャを調整"
"してみましょう。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""
"そうするとコンパイルが通らなくなります。これは、すなわち、コンパイラがアノ"
"テーションの妥当性をチェックしているということを示すものです。ただし、これは"
"生のポインタ（安全ではない）には当てはまりません。アンセーフRustを使用する場"
"合に、これはよくあるエラーの原因となっています。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""
"ライフタイムをどのような場合に使うべきか、受講者から質問を受けるかもしれませ"
"ん。Rust の借用では常にライフタイムを使用します。ほとんどの場合、省略や型推"
"論 により、ライフタイムを記述する必要はありません。より複雑なケースでは、ライ"
"フタイム アノテーションを使用することであいまいさを解決できます。多くの場合、"
"特にプロトタイピングでは、必要に応じて値をクローニングして所有データを処理す"
"る方が簡単です。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "Lifetimes in Data Structures"
msgstr "データ構造とライフタイム"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"データ型が借用データを内部に保持する場合、ライフタイムアノテーションを付ける"
"必要があります。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"Bye {text}!\""
msgstr "\"Bye {text}!\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr "\"The quick brown fox jumps over the lazy dog.\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "// erase(text);\n"
msgstr "// 消去（テキスト）;\n"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"{fox:?}\""
msgstr "\"{fox:?}\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"{dog:?}\""
msgstr "\"{dog:?}\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"上記の例では、`Highlight` のアノテーションにより、内包される`&str` の参照先の"
"データは、少なくともそのデータを使用する `Highlight` のインスタンスが存在する"
"限り存続しなければならなくなります。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"`fox`（または `dog`）のライフタイムが終了する前に `text` が使用されると、借用"
"チェッカーはエラーをスローします。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"消費したデータが含まれる型では、ユーザーは元のデータを保持せざるを得なくなり"
"ます。これは軽量のビューを作成する場合に便利ですが、一般的には使いにくくなり"
"ます。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "When possible, make data structures own their data directly."
msgstr "可能であれば、データ構造がデータを直接所有できるようにします。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"内部に複数の参照がある構造体には、複数のライフタイム アノテーションが含まれる"
"場合があります。これが必要になるのは、構造体自体のライフタイムだけでなく、参"
"照同士のライフタイムの関係を記述する必要がある場合です。これは非常に高度な"
"ユースケースです。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""
"この演習では、[protobuf バイナリ エンコード](https://protobuf.dev/"
"programming-guides/encoding/)用のパーサーを作成します。見かけよりも簡単ですの"
"で、心配はいりません。これは、データのスライスを渡す一般的な解析パターンを示"
"しています。基になるデータ自体がコピーされることはありません。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""
"protobuf メッセージを完全に解析するには、フィールド番号でインデックス付けされ"
"たフィールドの型を知る必要があります。これは通常、`proto` ファイルで提供され"
"ます。この演習では、フィールドごとに呼び出される関数の `match` ステートメント"
"に、その情報をエンコードします。"

#: src/slices-and-lifetimes/exercise.md
msgid "We'll use the following proto:"
msgstr "次の proto を使用します。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""
"proto メッセージは、連続するフィールドとしてエンコードされます。それぞれが後"
"ろに値を伴う「タグ」として実装されます。タグにはフィールド番号（例: `Person` "
"メッセージの `id` フィールドには `2`）と、バイト ストリームからペイロードがど"
"のように決定されるかを定義するワイヤータイプが含まれます。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""
"タグを含む整数は、VARINT と呼ばれる可変長エンコードで表されます。幸いにも、"
"`parse_varint` は以下ですでに定義されています。また、このコードでは、"
"`Person` フィールドと `PhoneNumber` フィールドを処理し、メッセージを解析して"
"これらのコールバックに対する一連の呼び出しに変換するコールバックも定義してい"
"ます。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""
"残る作業は、`parse_field` 関数と、`Person` および `PhoneNumber` の "
"`ProtoMessage` トレイトを実装するだけです。"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid varint\""
msgstr "\"Invalid varint\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid wire-type\""
msgstr "\"Invalid wire-type\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Unexpected EOF\""
msgstr "\"Unexpected EOF\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid length\""
msgstr "\"Invalid length\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Unexpected wire-type)\""
msgstr "\"Unexpected wire-type)\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid string (not UTF-8)\""
msgstr "\"Invalid string (not UTF-8)\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// A wire type as seen on the wire.\n"
msgstr "/// ワイヤー上で見えるワイヤータイプ。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr "/// Varint WireType は、値が単一の VARINT であることを示します。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""
"//I64、  -- この演習では不要\n"
"    /// Len WireType は、値が VARINT で表され、その後にちょうどそのバイト数"
"が\n"
"    /// 続くものであることを示します。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    /// little-endian order containing a 32-bit signed integer.\n"
msgstr ""
"/// I32 WireType は、値が 32 ビット符号付き整数を含むリトル エンディアン"
"で、\n"
"    /// 正確に 4 バイトであることを示します。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// A field's value, typed based on the wire type.\n"
msgstr "/// ワイヤータイプに基づいて型指定されたフィールドの値。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr "//I64（i64）、  -- この演習では不要\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// A field, containing the field number and its value.\n"
msgstr "/// フィールド番号とその値を含むフィールド。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr "//1 => WireType::I64、  -- この演習では不要\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr "/// VARINT を解析し、解析した値と残りのバイトを返します。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""
"// これは VARINT の最後のバイトであるため、\n"
"            // u64 に変換して返します。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "// More than 7 bytes is invalid.\n"
msgstr "// 7 バイトを超える値は無効です。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr "/// タグをフィールド番号と WireType に変換します。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr "/// フィールドを解析して残りのバイトを返します。\n"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""
"\"ワイヤータイプに応じて、フィールドを構築し、必要な量のバイトを消費しま"
"す。\""

#: src/slices-and-lifetimes/exercise.md
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr "\"フィールドと、未消費のバイトを返します。\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""
"/// 指定されたデータ内のメッセージを解析し、メッセージのフィールドごとに\n"
"/// `T::add_field` を呼び出します。\n"
"///\n"
"/// 入力全体が消費されます。\n"

#: src/slices-and-lifetimes/exercise.md
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr "// TODO: Person と PhoneNumber の ProtoMessage を実装します。\n"

#: src/slices-and-lifetimes/solution.md
msgid "// Unwrap error because `value` is definitely 4 bytes long.\n"
msgstr ""
"// `value` の長さは明らかに 4 バイトであるため、エラーをアンラップします。\n"

#: src/slices-and-lifetimes/solution.md
msgid "// skip everything else\n"
msgstr "// それ以外をすべてスキップ\n"

#: src/slices-and-lifetimes/solution.md
msgid "b\"hello\""
msgstr "b\"hello\""

#: src/welcome-day-4.md
msgid "Welcome to Day 4"
msgstr "4 日目のトレーニングにようこそ"

#: src/welcome-day-4.md
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr ""
"本日は、Rust での大規模なソフトウェアのビルドに関連するトピックを取り上げま"
"す。"

#: src/welcome-day-4.md
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr "イテレータ: `Iterator` トレイトの詳細。"

#: src/welcome-day-4.md
msgid "Modules and visibility."
msgstr "モジュールと可視性。"

#: src/welcome-day-4.md
#, fuzzy
msgid "Testing."
msgstr "テスト"

#: src/welcome-day-4.md
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "エラー処理: パニック、`Result`、try 演算子 `?`。"

#: src/welcome-day-4.md
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr "アンセーフRust: 安全な Rust では記述できない場合の回避策。"

#: src/welcome-day-4.md
msgid "[Welcome](./welcome-day-4.md) (3 minutes)"
msgstr "[ようこそ](./welcome-day-4.md)（3 分）"

#: src/welcome-day-4.md
msgid "[Iterators](./iterators.md) (45 minutes)"
msgstr "[イテレータ](./iterators.md)（45 分）"

#: src/welcome-day-4.md
msgid "[Modules](./modules.md) (40 minutes)"
msgstr "[モジュール](./modules.md)（40 分）"

#: src/welcome-day-4.md
msgid "[Testing](./testing.md) (1 hour and 5 minutes)"
msgstr "[テスト](./testing.md)（1 時間 5 分）"

#: src/iterators.md
msgid "[Iterator](./iterators/iterator.md) (5 minutes)"
msgstr "[Iterator](./iterators/iterator.md)（5 分）"

#: src/iterators.md
msgid "[IntoIterator](./iterators/intoiterator.md) (5 minutes)"
msgstr "[IntoIterator](./iterators/intoiterator.md)（5 分）"

#: src/iterators.md
msgid "[FromIterator](./iterators/fromiterator.md) (5 minutes)"
msgstr "[FromIterator](./iterators/fromiterator.md)（5 分）"

#: src/iterators.md
msgid ""
"[Exercise: Iterator Method Chaining](./iterators/exercise.md) (30 minutes)"
msgstr ""
"[演習: イテレータ メソッドのチェーン化](./iterators/exercise.md)（30 分）"

#: src/iterators/iterator.md
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) トレイト"
"は、コレクション内の一連の要素に対して順番に処理を適用することを可能にしま"
"す。このトレイトはnextメソッドを必要とし、それにより多くのメソッドを提供しま"
"す。多くの標準ライブラリ型で `Iterator` が実装されていますが、自分で実装する"
"こともできます。"

#: src/iterators/iterator.md
msgid "\"fib({i}): {n}\""
msgstr "\"fib({i}): {n}\""

#: src/iterators/iterator.md
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"`Iterator` トレイトは、コレクションに対する多くの一般的な関数型プログラミン"
"グ オペレーション（例: `map`、`filter`、`reduce` など）を実装します。このトレ"
"イトのドキュメントにおいて、これらのすべてのオペレーションに関する説明を確認"
"できます。Rust では、これらの関数により、同等の命令型実装と同じくらい効率的な"
"コードが生成されます。"

#: src/iterators/iterator.md
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` は、forループを実現するためのトレイトです。コレクション型"
"（`Vec<T>` など）と、それらに対する参照（`&Vec<T>`、`&[T]` など）において実装"
"されています。また、範囲を表す型においても実装されています。`for i in "
"some_vec { .. }` を使用してベクターを反復処理できるのに、`some_vec.next()` が"
"存在しないのはこのためです。"

#: src/iterators/intoiterator.md
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"`Iterator` トレイトは、イテレータを作成した後に反復処理を行う方法を示します。"
"関連するトレイト [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait."
"IntoIterator.html) は、ある型に対するイテレータを作成する方法を定義します。こ"
"れは `for` ループによって自動的に使用されます。"

#: src/iterators/intoiterator.md
msgid "\"point = {x}, {y}\""
msgstr "\"point = {x}, {y}\""

#: src/iterators/intoiterator.md
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr ""
"`IntoIterator`のドキュメントをクリックしてご覧ください。`IntoIterator` のすべ"
"ての実装で、次の 2 つの型を宣言する必要があります。"

#: src/iterators/intoiterator.md
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "`Item`: 反復処理する型（`i8` など）。"

#: src/iterators/intoiterator.md
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: `into_iter` メソッドによって返される `Iterator` 型。"

#: src/iterators/intoiterator.md
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"`IntoIter`と`Item`は関連があり、イテレータは`Item`と同じ型を持つ必要がありま"
"す。すなわち、`Option<Item>`を返します。"

#: src/iterators/intoiterator.md
msgid "The example iterates over all combinations of x and y coordinates."
msgstr "この例は、x 座標と y 座標のすべての組み合わせを反復処理しています。"

#: src/iterators/intoiterator.md
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""
"`main` でグリッドを 2 回反復処理してみましょう。これはなぜ失敗するのでしょう"
"か。`IntoIterator::into_iter` は `self` の所有権を取得することに着目してくだ"
"さい。"

#: src/iterators/intoiterator.md
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""
"この問題を修正するには、`&Grid` に `IntoIterator` を実装し、`Grid` への参照"
"を `GridIter` に保存します。"

#: src/iterators/intoiterator.md
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""
"標準ライブラリ型でも同じ問題が発生する可能性があります。`for e in "
"some_vector` は、`some_vector` の所有権を取得し、そのベクターの所有要素を反復"
"処理します。`some_vector` の要素への参照を反復処理するには、代わりに `for e "
"in &some_vector` を使用します。"

#: src/iterators/fromiterator.md
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/fromiterator.md
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"を使用すると、[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html) からコレクションを作成できます。"

#: src/iterators/fromiterator.md
msgid "\"prime_squares: {prime_squares:?}\""
msgstr "\"prime_squares: {prime_squares:?}\""

#: src/iterators/fromiterator.md
msgid "`Iterator` implements"
msgstr "`Iterator` の実装"

#: src/iterators/fromiterator.md
msgid "There are two ways to specify `B` for this method:"
msgstr "このメソッドで `B` を指定するには、次の 2 つの方法があります。"

#: src/iterators/fromiterator.md
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""
"「turbofish」を使用する場合: 例えば、上記における、`some_iterator.collect::"
"<COLLECTION_TYPE>()`。ここで使用されている_ はRustに`Vecの`要素の方を推測させ"
"るためのものです。"

#: src/iterators/fromiterator.md
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""
"型推論を使用する場合: `let prime_squares: Vec<_> = some_iterator.collect()`。"
"この形式を使用するように例を書き換えてください。"

#: src/iterators/fromiterator.md
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"`Vec` や `HashMap` などに `FromIterator` の基本的な実装が用意されています。ま"
"た、`Iterator<Item = Result<V, E>>` を `Result<Vec<V>, E>` に変換できるものな"
"ど、より特化した実装もあります。"

#: src/iterators/exercise.md
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr ""
"この演習では、複雑な計算を実装するために[`Iterator`](https://doc.rust-lang."
"org/std/iter/trait.Iterator.html) トレイトで提供されているメソッドをいくつか"
"を探して使用する必要があります。"

#: src/iterators/exercise.md
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"次のコードを <https://play.rust-lang.org/> にコピーし、テストが通るようにして"
"ください。イテレータ式を使用し、その結果を`collect`することで戻り値を生成しま"
"す。"

#: src/iterators/exercise.md src/iterators/solution.md
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""
"/// `values`において、`offset`だけ離れた要素間の差を計算します。\n"
"/// なお、`values`の末尾要素の次は先頭へ戻ることとします。\n"
"///\n"
"/// 結果の要素 `n` は `values[(n+offset)%len] - values[n]` です。\n"

#: src/modules.md
msgid "[Modules](./modules/modules.md) (5 minutes)"
msgstr "[モジュール](./modules/modules.md)（5 分）"

#: src/modules.md
msgid "[Filesystem Hierarchy](./modules/filesystem.md) (5 minutes)"
msgstr "[ファイル システム階層](./modules/filesystem.md)（5 分）"

#: src/modules.md
msgid "[Visibility](./modules/visibility.md) (5 minutes)"
msgstr "[可視性](./modules/visibility.md)（5 分）"

#: src/modules.md
msgid "[use, super, self](./modules/paths.md) (10 minutes)"
msgstr "[use、super、self](./modules/paths.md)（10 分）"

#: src/modules.md
msgid ""
"[Exercise: Modules for a GUI Library](./modules/exercise.md) (15 minutes)"
msgstr "[演習: GUI ライブラリのモジュール](./modules/exercise.md)（15 分）"

#: src/modules.md
msgid "This segment should take about 40 minutes"
msgstr "このセグメントの所要時間は約 40 分です"

#: src/modules/modules.md
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"`impl` ブロックで関数を型の名前空間に所属させる方法はすでに見てきました。"

#: src/modules/modules.md
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "同様に、`mod` を使用して型と関数の名前空間を指定できます。"

#: src/modules/modules.md
msgid "\"In the foo module\""
msgstr "\"In the foo module\""

#: src/modules/modules.md
msgid "\"In the bar module\""
msgstr "\"In the bar module\""

#: src/modules/modules.md
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"パッケージ(package)は機能を提供するものであり、一つ以上のクレートをビルドする"
"方法を記述した`Cargo.toml` ファイルを含むものです。"

#: src/modules/modules.md
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"バイナリクレートの場合は実行可能ファイルを生成し、ライブラリクレートの場合は"
"ライブラリを生成します。"

#: src/modules/modules.md
msgid "Modules define organization, scope, and are the focus of this section."
msgstr ""
"モジュールによって構成とスコープが定義されます。このセクションではモジュール"
"に焦点を当てます。"

#: src/modules/filesystem.md
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"モジュールの定義内容を省略すると、Rust はそれを別のファイルで探します。"

#: src/modules/filesystem.md
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"これにより、`garden` モジュールの定義内容が `src/garden.rs` にあることを "
"Rust に伝えます。同様に、`garden::vegetables` モジュールは `src/garden/"
"vegetables.rs` にあります。"

#: src/modules/filesystem.md
msgid "The `crate` root is in:"
msgstr "`crate` ルートは以下の場所にあります。"

#: src/modules/filesystem.md
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs`（ライブラリ クレートの場合）"

#: src/modules/filesystem.md
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs`（バイナリ クレートの場合）"

#: src/modules/filesystem.md
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"ファイルで定義されたモジュールに対して、「内部ドキュメント用コメント」を使用"
"して説明を加えることもできます。これらのコメントは、それが含まれるアイテム"
"（この場合はモジュール）に対する説明になります。"

#: src/modules/filesystem.md
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr ""
"//! このモジュールは畑を実装します（パフォーマンスの高い発芽の\n"
"//! 実装を含む）。\n"

#: src/modules/filesystem.md
msgid "// Re-export types from this module.\n"
msgstr "// このモジュールから型を再エクスポートします。\n"

#: src/modules/filesystem.md
msgid "/// Sow the given seed packets.\n"
msgstr "/// 指定された種をまきます。\n"

#: src/modules/filesystem.md
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr "/// 十分に実っている畑で作物を収穫します。\n"

#: src/modules/filesystem.md
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"Rust 2018 より前では、モジュールを `module.rs` ではなく `module/mod.rs` に配"
"置する必要がありました。これは 2018 以降のエディションでも依然としてサポート"
"されています。"

#: src/modules/filesystem.md
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"`filename/mod.rs` の代わりに `filename.rs` が導入された主な理由は、`mod.rs` "
"という名前のファイルが多くあると、それらをIDEで区別するのが難しい場合があるか"
"らです。"

#: src/modules/filesystem.md
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"より深いネストでは、メイン モジュールがファイルであっても、フォルダを使用でき"
"ます。"

#: src/modules/filesystem.md
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""
"Rust がモジュールを検索する場所は、コンパイラ ディレクティブで変更できます。"

#: src/modules/filesystem.md
msgid "\"some/path.rs\""
msgstr "\"some/path.rs\""

#: src/modules/filesystem.md
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"これは、たとえば Go でよく行われているように、`some_module_test.rs` という名"
"前のファイルにモジュールのテストを配置する場合に便利です。"

#: src/modules/visibility.md
msgid "Modules are a privacy boundary:"
msgstr "モジュールはプライバシーの境界です。"

#: src/modules/visibility.md
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"モジュール アイテムはデフォルトでプライベートです（実装の詳細は表示されませ"
"ん）。"

#: src/modules/visibility.md
msgid "Parent and sibling items are always visible."
msgstr "親アイテムと兄弟アイテムは常に見えます。"

#: src/modules/visibility.md
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"言い換えれば、あるアイテムがモジュール `foo` から見える場合、そのアイテムは "
"`foo` のすべての子孫から見えます。"

#: src/modules/visibility.md
msgid "\"outer::private\""
msgstr "\"outer::private\""

#: src/modules/visibility.md
msgid "\"outer::public\""
msgstr "\"outer::public\""

#: src/modules/visibility.md
msgid "\"outer::inner::private\""
msgstr "\"outer::inner::private\""

#: src/modules/visibility.md
msgid "\"outer::inner::public\""
msgstr "\"outer::inner::public\""

#: src/modules/visibility.md
msgid "Use the `pub` keyword to make modules public."
msgstr "モジュールを公開するには `pub` キーワードを使用します。"

#: src/modules/visibility.md
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"また、高度な `pub(...)` 指定子を使用して、公開範囲を制限することもできます。"

#: src/modules/visibility.md
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"[Rust リファレンス](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself) をご覧ください。"

#: src/modules/visibility.md
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "`pub(crate)` の可視性を設定するのは一般的なパターンです。"

#: src/modules/visibility.md
msgid "Less commonly, you can give visibility to a specific path."
msgstr ""
"それほど一般的ではありませんが、特定のパスに対して可視性を指定することが出来"
"ます。"

#: src/modules/visibility.md
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"どのような場合も、祖先モジュール（およびそのすべての子孫）に可視性を与える必"
"要があります。"

#: src/modules/paths.md
msgid "use, super, self"
msgstr "use、super、self"

#: src/modules/paths.md
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"モジュールは、`use` を使用して別のモジュールのシンボルをスコープに取り込むこ"
"とができます。次のような記述はモジュールの先頭においてよく見られます。"

#: src/modules/paths.md
msgid "Paths"
msgstr "パス"

#: src/modules/paths.md
msgid "Paths are resolved as follows:"
msgstr "パスは次のように解決されます。"

#: src/modules/paths.md
msgid "As a relative path:"
msgstr "相対パスの場合:"

#: src/modules/paths.md
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` または `self::foo` は、現在のモジュール内の `foo` を参照します。"

#: src/modules/paths.md
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo` は、親モジュール内の `foo` を参照します。"

#: src/modules/paths.md
msgid "As an absolute path:"
msgstr "絶対パスの場合:"

#: src/modules/paths.md
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` は、現在のクレートのルート内の `foo` を参照します。"

#: src/modules/paths.md
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo` は、`bar` クレート内の `foo` を参照します。"

#: src/modules/paths.md
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""
"シンボルは、より短いパスで「再エクスポート」するのが一般的です。たとえば、ク"
"レート内の最上位の `lib.rs` に、以下のように記述します。"

#: src/modules/paths.md
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""
"これにより、短く使いやすいパスを使用して、`DiskStorage` と `NetworkStorage` "
"を他のクレートで使用できるようになります。"

#: src/modules/paths.md
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""
"ほとんどの場合、`use` を指定する必要があるのはモジュール内で実際に直接使用さ"
"れるアイテムのみです。ただし、あるトレイトを実装する型がすでにスコープに含ま"
"れている場合でも、そのトレイトのメソッドを呼び出すには、そのトレイトがスコー"
"プに含まれている必要があります。たとえば、`Read` トレイトを実装する型で "
"`read_to_string` メソッドを使用するには、`use std::io::Read` という記述が必要"
"になります。"

#: src/modules/paths.md
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""
"`use` ステートメントには `use std::io::*` というようにワイルドカードを含める"
"ことができます。この方法は、どのアイテムがインポートされるのかが明確ではな"
"く、時間の経過とともに変化する可能性があるため、おすすめしません。"

#: src/modules/exercise.md
msgid ""
"In this exercise, you will reorganize a small GUI Library implementation. "
"This library defines a `Widget` trait and a few implementations of that "
"trait, as well as a `main` function."
msgstr ""
"この演習では、小規模な GUI ライブラリ実装を再編成します。このライブラリでは、"
"`Widget` トレイト、そのトレイトのいくつかの実装、`main` 関数を定義していま"
"す。"

#: src/modules/exercise.md
msgid ""
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""
"通常は、各型または密接に関連する型のセットを個別のモジュールに配置するので、"
"ウィジェット タイプごとに独自のモジュールを用意する必要があります。"

#: src/modules/exercise.md
#, fuzzy
msgid "Cargo Setup"
msgstr "セットアップ"

#: src/modules/exercise.md
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""
"Rust プレイグラウンドは 1 つのファイルしかサポートしていないため、ローカル "
"ファイル システムで Cargo プロジェクトを作成する必要があります。"

#: src/modules/exercise.md
msgid ""
"Edit the resulting `src/main.rs` to add `mod` statements, and add additional "
"files in the `src` directory."
msgstr ""
"生成された `src/main.rs` を編集して `mod` ステートメントを追加し、`src` ディ"
"レクトリにファイルを追加します。"

#: src/modules/exercise.md
msgid "Source"
msgstr "ソース"

#: src/modules/exercise.md
msgid "Here's the single-module implementation of the GUI library:"
msgstr "GUI ライブラリの単一モジュール実装は次のとおりです。"

#: src/modules/exercise.md src/modules/solution.md
msgid "/// Natural width of `self`.\n"
msgstr "/// `self` の自然な幅。\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "/// Draw the widget into a buffer.\n"
msgstr "/// ウィジェットをバッファに描画します。\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "/// Draw the widget on standard output.\n"
msgstr "/// ウィジェットを標準出力に描画します。\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"{buffer}\""
msgstr "\"{buffer}\""

#: src/modules/exercise.md
msgid "// Add 4 paddings for borders\n"
msgstr "// 枠線用に 4 つのパディングを追加します。\n"

#: src/modules/exercise.md
msgid ""
"// TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use "
"the\n"
"        // ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: Result<(), std::fmt::Error> を返すように draw_into を変更します。次"
"に、.unwrap() の代わりに\n"
"        // ? 演算子を使用します。\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+-{:-<inner_width$}-+\""
msgstr "\"+-{:-<inner_width$}-+\""

#: src/modules/exercise.md src/modules/solution.md src/testing/unit-tests.md
#: src/testing/solution.md
msgid "\"\""
msgstr "\"\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"| {:^inner_width$} |\""
msgstr "\"| {:^inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+={:=<inner_width$}=+\""
msgstr "\"+={:=<inner_width$}=+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"| {:inner_width$} |\""
msgstr "\"| {:inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
msgid "// add a bit of padding\n"
msgstr "// パディングを少し追加します。\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+{:-<width$}+\""
msgstr "\"+{:-<width$}+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"|{:^width$}|\""
msgstr "\"|{:^width$}|\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"Rust GUI Demo 1.23\""
msgstr "\"Rust GUI Demo 1.23\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"This is a small text GUI demo.\""
msgstr "\"This is a small text GUI demo.\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"Click me!\""
msgstr "\"Click me!\""

#: src/modules/exercise.md
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""
"自分にとって自然な方法でコードを分割し、必要な `mod`、`use`、`pub` 宣言に慣れ"
"るよう受講者に促します。その後、どの構成が最も慣用的であるかについて話し合い"
"ます。"

#: src/modules/solution.md
msgid "// ---- src/widgets.rs ----\n"
msgstr "// ---- src/widgets.rs ----\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/label.rs ----\n"
msgstr "// ---- src/widgets/label.rs ----\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Label-width\n"
msgstr "// ANCHOR_END: Label-width\n"

#: src/modules/solution.md
msgid "// ANCHOR: Label-draw_into\n"
msgstr "// ANCHOR: Label-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr "// ANCHOR_END: Label-draw_into\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/button.rs ----\n"
msgstr "// ---- src/widgets/button.rs ----\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Button-width\n"
msgstr "// ANCHOR_END: Button-width\n"

#: src/modules/solution.md
msgid "// ANCHOR: Button-draw_into\n"
msgstr "// ANCHOR: Button-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr "// ANCHOR_END: Button-draw_into\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/window.rs ----\n"
msgstr "// ---- src/widgets/window.rs ----\n"

#: src/modules/solution.md
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""
"// ANCHOR_END: Window-width\n"
"        // 枠線に 4 つのパディングを追加します。\n"

#: src/modules/solution.md
msgid "// ANCHOR: Window-draw_into\n"
msgstr "// ANCHOR: Window-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr "// ANCHOR_END: Window-draw_into\n"

#: src/modules/solution.md
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: エラー処理について学習した後で、\n"
"        // Result<(), std::fmt::Error> を返すように draw_into を変更できま"
"す。次に、ここで\n"
"        // .unwrap() の代わりに ? 演算子を使用します。\n"

#: src/modules/solution.md
msgid "// ---- src/main.rs ----\n"
msgstr "// ---- src/main.rs ----\n"

#: src/testing.md
msgid "[Test Modules](./testing/unit-tests.md) (5 minutes)"
msgstr "[テスト] モジュール(./testing/unit-tests.md)（5 分）"

#: src/testing.md
msgid "[Other Types of Tests](./testing/other.md) (10 minutes)"
msgstr "[その他の種類のテスト](./testing/other.md)（10 分）"

#: src/testing.md
msgid "[Useful Crates](./testing/useful-crates.md) (3 minutes)"
msgstr "[便利なクレート](./testing/useful-crates.md)（3 分）"

#: src/testing.md
msgid "[GoogleTest](./testing/googletest.md) (5 minutes)"
msgstr "[GoogleTest](./testing/googletest.md)（5 分）"

#: src/testing.md
msgid "[Mocking](./testing/mocking.md) (5 minutes)"
msgstr "[モック](./testing/mocking.md)（5 分）"

#: src/testing.md
msgid "[Compiler Lints and Clippy](./testing/lints.md) (5 minutes)"
msgstr "[コンパイラの リント と Clippy](./testing/lints.md)（5 分）"

#: src/testing.md
msgid "[Exercise: Luhn Algorithm](./testing/exercise.md) (30 minutes)"
msgstr "[演習: Luhn アルゴリズム](./testing/exercise.md)（30 分）"

#: src/testing/unit-tests.md
msgid "Unit Tests"
msgstr "ユニットテスト"

#: src/testing/unit-tests.md
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr ""
"Rust と Cargo には、シンプルな単体テスト フレームワークが付属しています。"

#: src/testing/unit-tests.md
msgid "Unit tests are supported throughout your code."
msgstr "単体テストはコードのあらゆる場所に記述可能です。"

#: src/testing/unit-tests.md
msgid "Integration tests are supported via the `tests/` directory."
msgstr "統合テストは`tests/`ディレクトリ内に記述します。"

#: src/testing/unit-tests.md
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""
"テストには `#[test]` のマークが付きます。多くの場合、単体テストは通常ネストさ"
"れた`tests`モジュールに配置され、`#[cfg(test)]`によりテストのビルド時にのみコ"
"ンパイルされるようになります。"

#: src/testing/unit-tests.md
msgid "\"Hello World\""
msgstr "\"Hello World\""

#: src/testing/unit-tests.md
msgid "This lets you unit test private helpers."
msgstr "これにより、プライベート ヘルパーの単体テストを行えます。"

#: src/testing/unit-tests.md
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"`#[cfg(test)]` 属性が付与されたコードは `cargo test` の実行時にのみ有効になり"
"ます。"

#: src/testing/unit-tests.md
msgid "Run the tests in the playground in order to show their results."
msgstr "結果を表示するには、プレイグラウンドでテストを実行します。"

#: src/testing/other.md
msgid "Integration Tests"
msgstr "インテグレーションテスト"

#: src/testing/other.md
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"ライブラリをクライアントとしてテストする場合は、統合テストを使用します。"

#: src/testing/other.md
msgid "Create a `.rs` file under `tests/`:"
msgstr "`tests/` の下に `.rs` ファイルを作成します。"

#: src/testing/other.md
msgid "// tests/my_library.rs\n"
msgstr "// tests/my_library.rs\n"

#: src/testing/other.md
msgid "These tests only have access to the public API of your crate."
msgstr "これらのテストでは、クレートの公開 API にのみアクセスできます。"

#: src/testing/other.md
msgid "Documentation Tests"
msgstr "ドキュメンテーションテスト"

#: src/testing/other.md
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust には、ドキュメントのテストに関する機能が組み込まれています。"

#: src/testing/other.md
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"/// 指定した長さに文字列を短縮します。\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"

#: src/testing/other.md
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"`///` コメント内のコードブロックは、自動的に Rust コードとみなされます。"

#: src/testing/other.md
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "コードは `cargo test` の一環としてコンパイルされ、実行されます。"

#: src/testing/other.md
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr ""
"コードに `#` を追加すると、ドキュメントには表示されなくなりますが、コンパイル"
"と実行は引き続き行われます。"

#: src/testing/other.md
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"[Rust プレイグラウンド](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0) "
"で上記のコードをテストします。"

#: src/testing/useful-crates.md
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust は、テストを作成するための基本的なサポートのみを提供します。"

#: src/testing/useful-crates.md
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr "テストを作成する際に推奨されるその他のクレートを以下に示します。"

#: src/testing/useful-crates.md
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""
"[googletest](https://docs.rs/googletest): 従来の C++ 向け GoogleTestのような"
"包括的なテスト アサーション ライブラリです。"

#: src/testing/useful-crates.md
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr ""
"[proptest](https://docs.rs/proptest): Rust のプロパティ ベースのテストです。"

#: src/testing/useful-crates.md
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""
"[rstest](https://docs.rs/rstest): フィクスチャとパラメータ化されたテストをサ"
"ポートします。"

#: src/testing/googletest.md
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"[GoogleTest](https://docs.rs/googletest/) クレートにより、マッチャーを使用し"
"た柔軟なテスト アサーションが可能になります。"

#: src/testing/googletest.md
msgid "\"baz\""
msgstr "\"baz\""

#: src/testing/googletest.md
msgid "\"xyz\""
msgstr "\"xyz\""

#: src/testing/googletest.md
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""
"最後の要素を `\"!\"` に変更すると、テストは失敗し、エラー箇所を示す構造化され"
"たエラー メッセージが表示されます。"

#: src/testing/googletest.md
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""
"GoogleTest は Rust プレイグラウンドの一部ではないため、この例はローカル環境で"
"実行する必要があります。`cargo add googletest` を使用して、既存の Cargo プロ"
"ジェクトにすばやく追加します。"

#: src/testing/googletest.md
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""
"`use googletest::prelude::*;` 行は、[一般的に使用されるマクロと型](https://"
"docs.rs/googletest/latest/googletest/prelude/index.html)をインポートします。"

#: src/testing/googletest.md
msgid "This just scratches the surface, there are many builtin matchers."
msgstr ""
"ここで扱っているものはごく一部であり、他にも多くの組み込みマッチャーがありま"
"す。"

#: src/testing/googletest.md
msgid ""
"A particularly nice feature is that mismatches in multi-line strings strings "
"are shown as a diff:"
msgstr "特に便利なのは、複数行の文字列の不一致が差分として表示される機能です。"

#: src/testing/googletest.md
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""

#: src/testing/googletest.md
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""

#: src/testing/googletest.md
msgid "shows a color-coded diff (colors not shown here):"
msgstr "これにより、差分が色分けされます（ここでは色分けされていません）。"

#: src/testing/googletest.md
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""
"このクレートは [GoogleTest for C++](https://google.github.io/googletest/) を"
"Rustに移植したものです。"

#: src/testing/googletest.md
msgid "GoogleTest is available for use in AOSP."
msgstr "GoogleTest は AOSP で使用できます。"

#: src/testing/mocking.md
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""
"モックには、[Mockall](https://docs.rs/mockall/) というライブラリが広く使用さ"
"れています。トレイトを使用するようにコードをリファクタリングする必要がありま"
"す。これにより、すぐにモックできるようになります。"

#: src/testing/mocking.md
msgid ""
"The advice here is for Android (AOSP) where Mockall is the recommended "
"mocking library. There are other [mocking libraries available on crates.io]"
"(https://crates.io/keywords/mock), in particular in the area of mocking HTTP "
"services. The other mocking libraries work in a similar fashion as Mockall, "
"meaning that they make it easy to get a mock implementation of a given trait."
msgstr ""
"ここでは、Mockall が推奨モック ライブラリである Android（AOSP）向けのアドバイ"
"スを行います。特に HTTP サービスのモックに関しては、[crates.io で他のモック "
"ライブラリが公開されています](https://crates.io/keywords/mock)。他のモック ラ"
"イブラリも Mockall と 同様で、特定のトレイトのモック実装を簡単に得ることがで"
"きます。"

#: src/testing/mocking.md
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""
"モックを使用する際は少し注意が必要です。モックを使用すると、テストを依存関係"
"から完全に分離できます。その結果、より高速で安定したテスト実行が可能になりま"
"す。一方、モックが誤って構成され、実際の依存関係の動作とは異なる出力が返され"
"る可能性があります。"

#: src/testing/mocking.md
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""
"可能な限り、実際の依存関係を使用することをおすすめします。たとえば、多くの"
"データベースではインメモリ バックエンドを構成できます。つまり、テストで正しい"
"動作が得られ、しかも高速で、テスト後は自動的にクリーンアップされます。"

#: src/testing/mocking.md
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""
"同様に、多くのウェブ フレームワークでは、`localhost` 上のランダムなポートにバ"
"インドするプロセス内サーバーを起動できます。このような構成は実際の環境でコー"
"ドをテストすることを可能にするので、フレームワークをモックすることよりも常に"
"優先して利用しましょう。"

#: src/testing/mocking.md
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""
"Mockall は Rust プレイグラウンドの一部ではないため、この例はローカル環境で実"
"行する必要があります。`cargo add mockall` を使用して、Mockall を既存の Cargo "
"プロジェクトにすばやく追加します。"

#: src/testing/mocking.md
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""
"Mockall にはさらに多くの機能があります。特に、渡される引数に応じて期待値を設"
"定できます。ここでは、最後に餌を与えてらえてから 3 時間後に空腹になる猫をモッ"
"クするためにこれを使用します。"

#: src/testing/mocking.md
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""
"`.times(n)` を使用すると、モックメソッドが呼び出される回数を`n` に制限できま"
"す。これが満たされない場合、モックはドロップ時に自動的にパニックになります。"

#: src/testing/lints.md
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""
"Rust コンパイラは、読みやすいエラーおよびlintメッセージを生成します。[Clippy]"
"(https://doc.rust-lang.org/clippy/) では、さらに多くの lint がグループにまと"
"められており、プロジェクトごとに有効にできます。"

#: src/testing/lints.md
msgid "\"X probably fits in a u16, right? {}\""
msgstr "\"X probably fits in a u16, right? {}\""

#: src/testing/lints.md
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""
"コードサンプルを実行してエラー メッセージを確認します。ここにも lint が表示さ"
"れていますが、コードのコンパイルが一度コンパイル出来ると表示されなくなりま"
"す。これらの lint を表示するには、プレイグラウンド サイトに切り替えます。"

#: src/testing/lints.md
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""
"lint を解決した後、プレイグラウンド サイトで `clippy` を実行して、Clippy の警"
"告を表示します。Clippy には、lint に関する広範なドキュメントがあり、新しい "
"lint（デフォルトでエラーになるリント を含む）が常に追加されています。"

#: src/testing/lints.md
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""
"`help: ...` が付くエラーや警告は、`cargo fix` またはエディタを使用して修正で"
"きます。"

#: src/testing/exercise.md
msgid "Luhn Algorithm"
msgstr "Luhnアルゴリズム"

#: src/testing/exercise.md
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[Luhn アルゴリズム](https://en.wikipedia.org/wiki/Luhn_algorithm) は、クレ"
"ジット カード番号の検証に使用されます。このアルゴリズムは文字列を入力として受"
"け取り、以下の処理を行ってクレジット カード番号を検証します。"

#: src/testing/exercise.md
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr "すべてのスペースを無視し、2 桁未満の番号を拒否します。"

#: src/testing/exercise.md
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"**右から左に**見ていきながら、それぞれ2桁目の数字を 2 倍にします。数値 "
"`1234` の場合、`3` と `1` を 2 倍にします。数値 `98765` の場合、`6` と `8` "
"を 2 倍にします。"

#: src/testing/exercise.md
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"桁を 2 倍にした後、結果が 9 より大きい場合はその桁を合計します。したがって、"
"`7` を 2 倍すると `14` になり、`1 + 4 = 5` になります。"

#: src/testing/exercise.md
msgid "Sum all the undoubled and doubled digits."
msgstr "2 倍にしていない数字と 2 倍にした数字をすべて合計します。"

#: src/testing/exercise.md
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "クレジット カード番号は、合計が `0` で終わる場合に有効です。"

#: src/testing/exercise.md
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most the algorithm is "
"implemented correctly."
msgstr ""
"提供されているコードでは、luhn アルゴリズムのバグのある実装と、ほとんどのアル"
"ゴリズムが正しく実装されていることを確認する 2 つの基本的な単体テストを提供し"
"ています。"

#: src/testing/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"以下のコードを <https://play.rust-lang.org/> にコピーし、提供された実装のバグ"
"を発見するための追加のテストを記述し、見つけたバグを修正してください。"

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4263 9826 4026 9299\""
msgstr "\"4263 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4539 3195 0343 6467\""
msgstr "\"4539 3195 0343 6467\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"7992 7398 713\""
msgstr "\"7992 7398 713\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4223 9826 4026 9299\""
msgstr "\"4223 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4539 3195 0343 6476\""
msgstr "\"4539 3195 0343 6476\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"8273 1232 7352 0569\""
msgstr "\"8273 1232 7352 0569\""

#: src/testing/solution.md
msgid "// This is the buggy version that appears in the problem.\n"
msgstr "// これは問題に記述されているバグのあるバージョンです。\n"

#: src/testing/solution.md
msgid "// This is the solution and passes all of the tests below.\n"
msgstr "// これは解答で、以下のすべてのテストに合格します。\n"

#: src/testing/solution.md
msgid "\"1234 5678 1234 5670\""
msgstr "\"1234 5678 1234 5670\""

#: src/testing/solution.md
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr "\"Is {cc_number} a valid credit card number? {}\""

#: src/testing/solution.md
msgid "\"yes\""
msgstr "\"yes\""

#: src/testing/solution.md
msgid "\"no\""
msgstr "\"no\""

#: src/testing/solution.md
msgid "\"foo 0 0\""
msgstr "\"foo 0 0\""

#: src/testing/solution.md
msgid "\" \""
msgstr "\" \""

#: src/testing/solution.md
msgid "\"  \""
msgstr "\"  \""

#: src/testing/solution.md
msgid "\"    \""
msgstr "\"    \""

#: src/testing/solution.md
msgid "\"0\""
msgstr "\"0\""

#: src/testing/solution.md
msgid "\" 0 0 \""
msgstr "\" 0 0 \""

#: src/welcome-day-4-afternoon.md
msgid "[Error Handling](./error-handling.md) (45 minutes)"
msgstr "[エラー処理](./error-handling.md)（45 分）"

#: src/welcome-day-4-afternoon.md
msgid "[Unsafe Rust](./unsafe-rust.md) (1 hour and 5 minutes)"
msgstr "[アンセーフRust](./unsafe-rust.md)（1 時間 5 分）"

#: src/welcome-day-4-afternoon.md
msgid "Including 10 minute breaks, this session should take about 2 hours"
msgstr "このセッションの所要時間は、10 分間の休憩を入れて約 2 時間です。"

#: src/error-handling.md
msgid "[Panics](./error-handling/panics.md) (3 minutes)"
msgstr "[パニック](./error-handling/panics.md)（3 分）"

#: src/error-handling.md
msgid "[Try Operator](./error-handling/try.md) (5 minutes)"
msgstr "[try 演算子](./error-handling/try.md)（5 分）"

#: src/error-handling.md
msgid "[Try Conversions](./error-handling/try-conversions.md) (5 minutes)"
msgstr "[try 変換](./error-handling/try-conversions.md)（5 分）"

#: src/error-handling.md
msgid "[Error Trait](./error-handling/error.md) (5 minutes)"
msgstr "[エラートレイト](./error-handling/error.md)（5 分）"

#: src/error-handling.md
msgid ""
"[thiserror and anyhow](./error-handling/thiserror-and-anyhow.md) (5 minutes)"
msgstr ""
"[thiserror と anyhow](./error-handling/thiserror-and-anyhow.md)（5 分）"

#: src/error-handling.md
msgid ""
"[Exercise: Rewriting with Result](./error-handling/exercise.md) (20 minutes)"
msgstr ""
"[演習: Result を使用した書き換え](./error-handling/exercise.md)（20 分）"

#: src/error-handling/panics.md
msgid "Rust handles fatal errors with a \"panic\"."
msgstr "Rust は「パニック」を使用して致命的なエラーを処理します。"

#: src/error-handling/panics.md
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "実行時に致命的なエラーが発生すると、Rust はパニックをトリガーします。"

#: src/error-handling/panics.md
msgid "\"v[100]: {}\""
msgstr "\"v[100]: {}\""

#: src/error-handling/panics.md
msgid "Panics are for unrecoverable and unexpected errors."
msgstr ""
"パニックは、回復不能なエラーや予期しないエラーに使用するためのものです。"

#: src/error-handling/panics.md
msgid "Panics are symptoms of bugs in the program."
msgstr "パニックはプログラムにバグがあることの兆候です。"

#: src/error-handling/panics.md
msgid "Runtime failures like failed bounds checks can panic"
msgstr ""
"ランタイム エラー（境界チェックの失敗など）は、パニックになる場合があります。"

#: src/error-handling/panics.md
msgid "Assertions (such as `assert!`) panic on failure"
msgstr "アサーション（`assert!` など）は失敗時にパニックになります。"

#: src/error-handling/panics.md
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr ""
"特定の目的でパニックさせてあい場合には、`panic!` マクロを使用できます。"

#: src/error-handling/panics.md
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr ""
"パニックが発生すると、スタックが「アンワインド」され、関数がリターンされたか"
"のように値がドロップされます。"

#: src/error-handling/panics.md
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"クラッシュが許容されない場合は、パニックが発生しない API（`Vec::get` など）を"
"使用します。"

#: src/error-handling/panics.md
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"デフォルトでは、パニックが発生するとスタックはアンワインドされます。アンワイ"
"ンドは以下のようにキャッチできます。"

#: src/error-handling/panics.md
msgid "\"No problem here!\""
msgstr "\"No problem here!\""

#: src/error-handling/panics.md
msgid "\"{result:?}\""
msgstr "\"{result:?}\""

#: src/error-handling/panics.md
msgid "\"oh no!\""
msgstr "\"oh no!\""

#: src/error-handling/panics.md
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr ""
"キャッチは一般的ではないため、`catch_unwind` を使用して例外処理を実装しようと"
"しないでください。"

#: src/error-handling/panics.md
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"これは、1 つのリクエストがクラッシュした場合でも実行し続ける必要があるサー"
"バーで有用です。"

#: src/error-handling/panics.md
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"これは、`Cargo.toml` で `panic = 'abort'` が設定されている場合は機能しませ"
"ん。"

#: src/error-handling/try.md
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"connection-refused や file-not-found などのランタイム エラーは `Result` 型で"
"処理されますが、すべての呼び出しでこの型を照合するのは面倒な場合があります。"
"try 演算子 `?` は、呼び出し元にエラーを返すのに使用されます。これにより、一般"
"的な以下のコードを、はるかにシンプルなコードに変換できます。"

#: src/error-handling/try.md
msgid "into the much simpler"
msgstr "変換後のコード:"

#: src/error-handling/try.md
msgid "We can use this to simplify our error handling code:"
msgstr "この演算子を使用することで、エラー処理コードを簡素化できます。"

#: src/error-handling/try.md
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"alice\").unwrap();\n"

#: src/error-handling/try.md src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
msgid "\"config.dat\""
msgstr "\"config.dat\""

#: src/error-handling/try.md src/error-handling/try-conversions.md
msgid "\"username or error: {username:?}\""
msgstr "\"username or error: {username:?}\""

#: src/error-handling/try.md
msgid "Simplify the `read_username` function to use `?`."
msgstr "? を使用して `read_username` 関数を簡素化します。"

#: src/error-handling/try.md
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr ""
"`username` 変数は、`Ok(string)` または `Err(error)` のいずれかになります。"

#: src/error-handling/try.md
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"`fs::write` 呼び出しを使用して、さまざまなシナリオ（ファイルがない、空のファ"
"イル、ユーザー名のあるファイルなど）をテストします。"

#: src/error-handling/try.md
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process:Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""
"なお、`main` は `std::process:Termination` を実装している限り、Result<(), "
"E>` を返すことができます。つまり、実際には `E` が`Debug` を実装していることを"
"意味します。この実行可能ファイルはエラー発生時にErrバリアントを出力し、ゼロ以"
"外の終了ステータスを返します。"

#: src/error-handling/try-conversions.md
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr "`?` を実際に展開すると、前述のコードよりも少し複雑なコードになります。"

#: src/error-handling/try-conversions.md
msgid "works the same as"
msgstr "上のコードは、以下と同じように動作します。"

#: src/error-handling/try-conversions.md
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"ここでの `From::from` 呼び出しは、エラー型を関数が返す型に変換しようとしてい"
"ることを意味します。これにより、エラーを上位レベルのエラーに簡単にカプセル化"
"できます。"

#: src/error-handling/try-conversions.md
msgid "\"IO error: {e}\""
msgstr "\"IO error: {e}\""

#: src/error-handling/try-conversions.md
msgid "\"Found no username in {path}\""
msgstr "\"Found no username in {path}\""

#: src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/try-conversions.md
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""
"`?` 演算子は、関数の戻り値の型と互換性のある値を返す必要があります。つまり、"
"`Result` の場合、エラー型に互換性がなければなりません。`Result<T, "
"ErrorOuter>` を返す関数は、`ErrorOuter` と `ErrorInner` が同じ型であるか、"
"`ErrorOuter` が `From<ErrorInner>` を実装している場合にのみ、型 `Result<U, "
"ErrorInner>` の値に `?` を使用できます。"

#: src/error-handling/try-conversions.md
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""
"特に変換が 1 か所でのみ発生する場合は、`From` を実装する代わりに Result::"
"map_err を使用するのが一般的です。"

#: src/error-handling/try-conversions.md
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""
"`Option`には互換性の要件はありません。`Option<T>`を返す関数は、任意のT型とU型"
"に対して、?演算子をOption<T>に適用できます。"

#: src/error-handling/try-conversions.md
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""
"`Result` を返す関数では `Option` に `?` を使用できません。その逆も同様です。"
"ただし、`Option::ok_or` は `Option` を `Result` に変換でき、`Result::ok` は "
"`Result` を `Option` に変換できます。"

#: src/error-handling/error.md
msgid "Dynamic Error Types"
msgstr "動的なエラー型"

#: src/error-handling/error.md
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"さまざまな可能性をカバーする独自の列挙型を記述することなく、あらゆる種類のエ"
"ラーを返せるようにしたい場合があります。`std::error::Error` トレイトを使用す"
"ると、あらゆるエラーを含めることができるトレイト オブジェクトを簡単に作成でき"
"ます。"

#: src/error-handling/error.md
msgid "\"count.dat\""
msgstr "\"count.dat\""

#: src/error-handling/error.md
msgid "\"1i3\""
msgstr "\"1i3\""

#: src/error-handling/error.md
msgid "\"Count: {count}\""
msgstr "\"Count: {count}\""

#: src/error-handling/error.md
msgid "\"Error: {err}\""
msgstr "\"Error: {err}\""

#: src/error-handling/error.md
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""
"`read_count` 関数は、`std::io::Error`（ファイル オペレーションから）または "
"`std::num::ParseIntError`（`String::parse` から）を返すことができます。"

#: src/error-handling/error.md
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"エラーをボックス化することでコードを節約できますが、プログラムで異なるエラー"
"ケースを異なる方法で適切に処理する機能が失われます。そのため、ライブラリの公"
"開 API で `Box<dyn Error>` を使用することは通常おすすめしませんが、エラー "
"メッセージをどこかに表示したいだけのプログラムでは適切な選択肢となりえます。"

#: src/error-handling/error.md
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""
"カスタムのエラー型を定義する際は、必ず `std::error::Error` トレイトを実装し、"
"ボックス化できるようにしてください。ただし `no_std` 属性をサポートする必要が"
"ある場合は、`std::error::Error` トレイトは現在、[ナイトリー](https://github."
"com/rust-lang/rust/issues/103765) においてのみ`no_std`と互換性があることに注"
"意してください。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling."
msgstr ""
"[`thiserror`](https://docs.rs/thiserror/) クレートと [`anyhow`](https://docs."
"rs/anyhow/) クレートは、エラー処理を簡素化するために広く使用されています。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`thiserror` is often used in libraries to create custom error types that "
"implement `From<T>`."
msgstr ""
"`thiserror`は、`From<T>` を実装するカスタムのエラー型を作成するためにライブラ"
"リで頻繁に使用されます。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow` is often used by applications to help with error handling in "
"functions, including adding contextual information to your errors."
msgstr ""
"`anyhow` は、エラーにコンテキスト情報を追加するなど、関数内でのエラー処理のた"
"めにアプリでよく使用されます。"

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Found no username in {0}\""
msgstr "\"Found no username in {0}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Failed to open {path}\""
msgstr "\"Failed to open {path}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Failed to read\""
msgstr "\"Failed to read\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Username: {username}\""
msgstr "\"Username: {username}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Error: {err:?}\""
msgstr "\"Error: {err:?}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror`"
msgstr "`thiserror`"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""
"`Error` 導出マクロは `thiserror` によって提供されます。このマクロには、エラー"
"型を簡潔に定義するのに役立つ属性が数多く用意されています。"

#: src/error-handling/thiserror-and-anyhow.md
msgid "The `std::error::Error` trait is derived automatically."
msgstr "`std::error::Error` トレイトは自動的に導出されます。"

#: src/error-handling/thiserror-and-anyhow.md
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr ""
"`#[error]` からのメッセージは、`Display` トレイトを導出するために使用されま"
"す。"

#: src/error-handling/thiserror-and-anyhow.md
msgid "`anyhow`"
msgstr "`anyhow`"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error` は基本的に `Box<dyn Error>` のラッパーとなっています。そのた"
"め、ライブラリの公開 API としては一般的には適していませんが、アプリでは広く使"
"用されています。"

#: src/error-handling/thiserror-and-anyhow.md
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr "`anyhow::Result<V>` は `Result<V, anyhow::Error>` の型エイリアスです。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr "必要に応じて、内部の実際のエラー型を抽出して調べることができます。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"`anyhow::Result<T>` が提供する機能は、Go の `(T, error)` と同様の使用パターン"
"とエルゴノミクスを備えているため、Go デベロッパーにはなじみがあるかもしれませ"
"ん。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""
"`anyhow::Context` は、標準の `Result` 型と `Option` 型に実装されたトレイトで"
"す。これらの型で `.context()` と `.with_context()` を有効にするには、`use "
"anyhow::Context` が必要です。"

#: src/error-handling/exercise.md
msgid "Exercise: Rewriting with Result"
msgstr "演習: Result を使用した書き換え"

#: src/error-handling/exercise.md
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""
"ここでは、式を表す言語の非常にシンプルなパーサーを実装します。ただし、エラー"
"に対してはパニックしています。代わりに慣用的なエラー処理を使用し、`main` から"
"の戻り値にエラーを伝播するように書き換えてください。`thiserror` と `anyhow`を"
"自由に使用してかまいません。"

#: src/error-handling/exercise.md
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""
"ヒント: まず、`parse` 関数のエラー処理を修正します。それができたら"
"`Iterator<Item=Result<Token, TokenizerError>>` を実装するように`Tokenizer` を"
"更新し、その結果をパーサーで処理するようにしてください。"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// An arithmetic operator.\n"
msgstr "/// 算術演算子。\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A token in the expression language.\n"
msgstr "/// 式言語のトークン\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// An expression in the expression language.\n"
msgstr "/// 式言語の式\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A reference to a variable.\n"
msgstr "/// 変数への参照。\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A literal number.\n"
msgstr "/// リテラル数値。\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A binary operation.\n"
msgstr "/// バイナリ演算。\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'z'"
msgstr "'z'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'_'"
msgstr "'_'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'+'"
msgstr "'+'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'-'"
msgstr "'-'"

#: src/error-handling/exercise.md
msgid "\"Unexpected character {c}\""
msgstr "\"Unexpected character {c}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"Unexpected end of input\""
msgstr "\"Unexpected end of input\""

#: src/error-handling/exercise.md
msgid "\"Invalid 32-bit integer'\""
msgstr "\"Invalid 32-bit integer'\""

#: src/error-handling/exercise.md
msgid "\"Unexpected token {tok:?}\""
msgstr "\"Unexpected token {tok:?}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr "// バイナリ演算が存在する場合はパースします。\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"10+foo+20-30\""
msgstr "\"10+foo+20-30\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"{expr:?}\""
msgstr "\"{expr:?}\""

#: src/error-handling/solution.md
msgid "\"Unexpected character '{0}' in input\""
msgstr "\"Unexpected character '{0}' in input\""

#: src/error-handling/solution.md
msgid "\"Tokenizer error: {0}\""
msgstr "\"Tokenizer error: {0}\""

#: src/error-handling/solution.md
msgid "\"Unexpected token {0:?}\""
msgstr "\"Unexpected token {0:?}\""

#: src/error-handling/solution.md
msgid "\"Invalid number\""
msgstr "\"Invalid number\""

#: src/unsafe-rust.md
msgid "[Unsafe](./unsafe-rust/unsafe.md) (5 minutes)"
msgstr "[アンセーフRust](./unsafe-rust/unsafe.md)（5 分）"

#: src/unsafe-rust.md
msgid ""
"[Dereferencing Raw Pointers](./unsafe-rust/dereferencing.md) (10 minutes)"
msgstr "[未加工ポインタの参照外し](./unsafe-rust/dereferencing.md)（10 分）"

#: src/unsafe-rust.md
msgid "[Mutable Static Variables](./unsafe-rust/mutable-static.md) (5 minutes)"
msgstr "[可変の静的変数](./unsafe-rust/mutable-static.md)（5 分）"

#: src/unsafe-rust.md
msgid "[Unions](./unsafe-rust/unions.md) (5 minutes)"
msgstr "[共用体](./unsafe-rust/unions.md)（5 分）"

#: src/unsafe-rust.md
msgid "[Unsafe Functions](./unsafe-rust/unsafe-functions.md) (5 minutes)"
msgstr "[アンセーフな関数](./unsafe-rust/unsafe-functions.md)（5 分）"

#: src/unsafe-rust.md
msgid "[Unsafe Traits](./unsafe-rust/unsafe-traits.md) (5 minutes)"
msgstr "[アンセーフなトレイト](./unsafe-rust/unsafe-traits.md)（5 分）"

#: src/unsafe-rust.md
msgid "[Exercise: FFI Wrapper](./unsafe-rust/exercise.md) (30 minutes)"
msgstr "[演習: FFI ラッパー](./unsafe-rust/exercise.md)（30 分）"

#: src/unsafe-rust/unsafe.md
msgid "The Rust language has two parts:"
msgstr "Rust 言語は 2 つの部分で構成されています。"

#: src/unsafe-rust/unsafe.md
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr "**安全な Rust:** メモリセーフで、未定義の動作は起こりえません。"

#: src/unsafe-rust/unsafe.md
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**アンセーフRust:** 前提条件に違反した場合、未定義の動作がトリガーされる可能"
"性があります。"

#: src/unsafe-rust/unsafe.md
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"このコースでは主に安全な Rust を見てきましたが、安全でない Rust とは何かを理"
"解しておくことが重要です。"

#: src/unsafe-rust/unsafe.md
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"アンセーフなコードは通常、小規模で分離されており、その正確性は慎重に文書化さ"
"れている必要があります。通常は安全な抽象化レイヤでラップされています。"

#: src/unsafe-rust/unsafe.md
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "アンセーフRustでは、次の 5 つの新機能を利用できます。"

#: src/unsafe-rust/unsafe.md
msgid "Dereference raw pointers."
msgstr "生ポインタの参照外し。"

#: src/unsafe-rust/unsafe.md
msgid "Access or modify mutable static variables."
msgstr "可変の静的変数へのアクセスまたは変更。"

#: src/unsafe-rust/unsafe.md
msgid "Access `union` fields."
msgstr "`union` フィールドへのアクセス。"

#: src/unsafe-rust/unsafe.md
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "`extern` 関数を含む `unsafe` 関数の呼び出し。"

#: src/unsafe-rust/unsafe.md
msgid "Implement `unsafe` traits."
msgstr "`unsafe` トレイトの実装。"

#: src/unsafe-rust/unsafe.md
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"次に、安全でない機能について簡単に説明します。詳しくは、[Rust Book の第 19.1 "
"章](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)と、"
"[Rustonomicon](https://doc.rust-lang.org/nomicon/) をご覧ください。"

#: src/unsafe-rust/unsafe.md
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"アンセーフRustは、コードが正しくないことを意味するものではありません。デベ"
"ロッパーが一部のコンパイラ安全性機能をオフにし、自分で正しいコードを記述しな"
"ければならないことを意味します。また、コンパイラがRustのメモリ安全性に関する"
"ルールを強制しなくなるということを意味します。"

#: src/unsafe-rust/dereferencing.md
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "ポインタの作成は安全ですが、参照外しには `unsafe` が必要です。"

#: src/unsafe-rust/dereferencing.md
msgid "\"careful!\""
msgstr "\"careful!\""

#: src/unsafe-rust/dereferencing.md
msgid ""
"// Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
msgstr ""
"// 次の理由により安全: r1 と r2 は参照から取得されており、\n"
"    // 非 null で適切にアラインされていることが保証されています。\n"
"    // 取得元である参照の基になるオブジェクトは、\n"
"    // アンセーフブロック全体を通じて存続します。参照を介したアクセスや、\n"
"    // 他のポインタを介した同時アクセスは行われません。\n"

#: src/unsafe-rust/dereferencing.md
msgid "\"r1 is: {}\""
msgstr "\"r1 is: {}\""

#: src/unsafe-rust/dereferencing.md
msgid "\"uhoh\""
msgstr "\"uhoh\""

#: src/unsafe-rust/dereferencing.md
msgid "\"r2 is: {}\""
msgstr "\"r2 is: {}\""

#: src/unsafe-rust/dereferencing.md
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""
"// 安全でないため、NOT SAFE。このような記述をしないでください。\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"

#: src/unsafe-rust/dereferencing.md
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"`unsafe`ブロックごとにコメントを記述し、そのブロック内のコードが行うアンセー"
"フな操作がどのように安全性要件を満たしているのかを記述することをおすすめしま"
"す（Android Rust スタイルガイドでも必須とされています）。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"ポインタ参照外しの場合、これはポインタが [_valid_](https://doc.rust-lang.org/"
"std/ptr/index.html#safety) でなければならないことを意味します。つまり、次のよ"
"うになります。"

#: src/unsafe-rust/dereferencing.md
msgid "The pointer must be non-null."
msgstr "ポインタは null 以外でなければならないこと。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"ポインタは、（割り当てられた単一のオブジェクトの境界内で）参照外し可能でなけ"
"ればならない。"

#: src/unsafe-rust/dereferencing.md
msgid "The object must not have been deallocated."
msgstr "オブジェクトが解放されていないこと。"

#: src/unsafe-rust/dereferencing.md
msgid "There must not be concurrent accesses to the same location."
msgstr "同じロケーションに同時アクセスすることがないこと。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"参照をキャストしてポインタを取得した場合、基になるオブジェクトが存続しなけれ"
"ばならず、他のいかなる参照を通してもそのメモリにアクセスがないこと"

#: src/unsafe-rust/dereferencing.md
msgid "In most cases the pointer must also be properly aligned."
msgstr "ほとんどの場合、ポインタも適切にアラインされる必要があります。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""
"\"NOT SAFE\"というコメントがあるところは、よくあるUBバグの例を示しています。"
"`*r1` のライフタイムは `'static` であるため、`r3` の型は `&'static String` と"
"なり、`s` より長く存続します。ポインタからの参照の作成には細心の注意が必要で"
"す。"

#: src/unsafe-rust/mutable-static.md
msgid "It is safe to read an immutable static variable:"
msgstr "不変の静的変数は安全に読み取ることができます。"

#: src/unsafe-rust/mutable-static.md
msgid "\"Hello, world!\""
msgstr "\"Hello, world!\""

#: src/unsafe-rust/mutable-static.md
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr "\"HELLO_WORLD: {HELLO_WORLD}\""

#: src/unsafe-rust/mutable-static.md
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"ただし、データ競合が発生する可能性があるため、可変静的変数の読み取りと書き込"
"みは安全ではありません。"

#: src/unsafe-rust/mutable-static.md
msgid "\"COUNTER: {COUNTER}\""
msgstr "\"COUNTER: {COUNTER}\""

#: src/unsafe-rust/mutable-static.md
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"このプログラムはシングルスレッドなので安全です。しかし、Rust コンパイラは保守"
"的で、最悪の事態を想定します。`unsafe` を削除すると、複数のスレッドから静的変"
"数を変更することは未定義の動作であることを説明するメッセージがコンパイラによ"
"り表示されるはずです。"

#: src/unsafe-rust/mutable-static.md
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"一般的に、可変静的変数を使用することはおすすめしませんが、ヒープ アロケータの"
"実装や一部の C API の操作など、低レベルの `no_std` コードでは適している場合も"
"あります。"

#: src/unsafe-rust/unions.md
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"共用体は列挙型に似ていますが、アクティブ フィールドを自分でトラッキングする必"
"要があります。"

#: src/unsafe-rust/unions.md
msgid "\"int: {}\""
msgstr "\"int: {}\""

#: src/unsafe-rust/unions.md
msgid "\"bool: {}\""
msgstr "\"bool: {}\""

#: src/unsafe-rust/unions.md
msgid "// Undefined behavior!\n"
msgstr "// 未定義の動作\n"

#: src/unsafe-rust/unions.md
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"Rust では、通常は列挙型を使用できるため、共用体はほとんど必要ありません。共用"
"体は、C ライブラリ API とのやり取りで必要になることがあります。"

#: src/unsafe-rust/unions.md
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"バイトを別の型として再解釈したい場合は、[`std::mem::transmute`](https://doc."
"rust-lang.org/stable/std/mem/fn.transmute.html) か、[`zerocopy`](https://"
"crates.io/crates/zerocopy) クレートのような安全なラッパーを使用することをおす"
"すめします。"

#: src/unsafe-rust/unsafe-functions.md
msgid "Calling Unsafe Functions"
msgstr "Unsafe関数の呼び出し"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"未定義の動作を回避するために満たす必要がある追加の前提条件がある関数またはメ"
"ソッドは、`unsafe` とマークできます。"

#: src/unsafe-rust/unsafe-functions.md src/unsafe-rust/exercise.md
#: src/unsafe-rust/solution.md src/android/interoperability/with-c.md
#: src/android/interoperability/with-c/rust.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/exercises/chromium/build-rules.md src/bare-metal/aps/inline-assembly.md
#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"C\""
msgstr "\"C\""

#: src/unsafe-rust/unsafe-functions.md
msgid "\"🗻∈🌏\""
msgstr "\"🗻∈🌏\""

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"// Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""
"// インデックスが正しい順序で文字列スライスの境界内にあり、\n"
"    // UTF-8 シーケンスの境界上にあるため、安全です。\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"emoji: {}\""
msgstr "\"emoji: {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid "\"char count: {}\""
msgstr "\"char count: {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid "// Undefined behavior if abs misbehaves.\n"
msgstr "// abs 誤動作の場合の動作は未定義。\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"Absolute value of -3 according to C: {}\""
msgstr "\"Absolute value of -3 according to C: {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""
"// UTF-8 エンコード要件を満たさない場合、メモリの安全性が損なわれます。\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "Writing Unsafe Functions"
msgstr "Unsafe関数の書き方"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"未定義の動作を回避するために特定の条件が必要な場合は、独自の関数を `unsafe` "
"とマークできます。"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""
"/// 指定されたポインタが指す値をスワップします。\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// ポインタが有効で、適切にアラインされている必要があります。\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "// Safe because ...\n"
msgstr "// 安全です。理由は...\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"a = {}, b = {}\""
msgstr "\"a = {}, b = {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"`get_unchecked` は多くの`_unchecked` 関数と同様に、範囲が正しくない場合に UB "
"となる可能性があるため、安全ではありません。また、`abs`が安全でないのは、外部"
"関数（FFI）であるからです。通常、外部関数の呼び出しが問題になるのポインタを使"
"用してRustのメモリモデルに違反する処理を行う場合のみです。しかし、一般的に C "
"関数には任意の状況下で未定義の動作が含まれる可能性があります。"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"この例の `\"C\"` は ABI です（[他の ABI も使用できます](https://doc.rust-"
"lang.org/reference/items/external-blocks.html)）。"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr ""
"実際には、`swap` 関数ではポインタは使用しません。これは参照を使用することで安"
"全に実行できます。"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"アンセーフな関数内では、アンセーフなコードを`unsafe`ブロックなしに記述するこ"
"とができます。これは `#[deny(unsafe_op_in_unsafe_fn)]` で禁止できます。追加す"
"るとどうなるか見てみましょう。これは、今後の Rust エディションで変更される可"
"能性があります。"

#: src/unsafe-rust/unsafe-traits.md
msgid "Implementing Unsafe Traits"
msgstr "Unsafeなトレイトの実装"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"関数と同様に、未定義の動作を回避するために実装で特定の条件を保証する必要があ"
"る場合は、トレイトを `unsafe` としてマークできます。"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"たとえば、`zerocopy` クレートには [このような](https://docs.rs/zerocopy/"
"latest/zerocopy/trait.AsBytes.html) 安全でないトレイトがあります。"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""
"/// ...\n"
"/// # Safety\n"
"/// 型には定義された表現が必要で、パディングがあってはなりません。\n"

#: src/unsafe-rust/unsafe-traits.md
msgid "// Safe because u32 has a defined representation and no padding.\n"
msgstr "// u32 には定義された表現があり、パディングがないため、安全です。\n"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Rustdoc には、トレイトを安全に実装するための要件について説明した `# Safety` "
"セクションが必要です。"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr "`AsBytes` の実際の安全性セクションはより長く、複雑です。"

#: src/unsafe-rust/unsafe-traits.md
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "組み込みの `Send` トレイトと `Sync` トレイトはアンセーフです。"

#: src/unsafe-rust/exercise.md
msgid "Safe FFI Wrapper"
msgstr "安全なFFIラッパ"

#: src/unsafe-rust/exercise.md
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"Rust は、外部関数インターフェース（FFI）を介した関数呼び出しを強力にサポート"
"しています。これを使用して、ディレクトリ内のファイル名を読み取るために Cプロ"
"グラムで使用する `libc` 関数の安全なラッパーを作成します。"

#: src/unsafe-rust/exercise.md
msgid "You will want to consult the manual pages:"
msgstr "以下のマニュアル ページをご覧ください。"

#: src/unsafe-rust/exercise.md
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"[`std::ffi`](https://doc.rust-lang.org/std/ffi/) モジュールも参照してくださ"
"い。ここには、この演習で必要な文字列型が多数掲載されています。"

#: src/unsafe-rust/exercise.md
msgid "Encoding"
msgstr "エンコード"

#: src/unsafe-rust/exercise.md
msgid "Use"
msgstr "使う"

#: src/unsafe-rust/exercise.md
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) と [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md
msgid "UTF-8"
msgstr "UTF-8"

#: src/unsafe-rust/exercise.md
msgid "Text processing in Rust"
msgstr "Rust でのテキスト処理"

#: src/unsafe-rust/exercise.md
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) と [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md
msgid "NUL-terminated"
msgstr "NUL終端文字列"

#: src/unsafe-rust/exercise.md
msgid "Communicating with C functions"
msgstr "C 関数との通信"

#: src/unsafe-rust/exercise.md
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) と "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md
msgid "OS-specific"
msgstr "OS 固有"

#: src/unsafe-rust/exercise.md
msgid "Communicating with the OS"
msgstr "OS との通信"

#: src/unsafe-rust/exercise.md
msgid "You will convert between all these types:"
msgstr "以下のすべての型間で変換を行います。"

#: src/unsafe-rust/exercise.md
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"`&str` から `CString`: 末尾の `\\0` 文字にも領域を割り当てる必要があります。"

#: src/unsafe-rust/exercise.md
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr "`CString` から `*const i8`: C 関数を呼び出すためのポインタが必要です。"

#: src/unsafe-rust/exercise.md
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"`*const i8` から `&CStr`: 末尾の `\\0` 文字を検出できるものが必要です。"

#: src/unsafe-rust/exercise.md
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr` から `&[u8]`: バイトのスライスは「不明なデータ」用の汎用的な インター"
"フェースです。"

#: src/unsafe-rust/exercise.md
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"`&[u8]` から `&OsStr`: `&OsStr` は `OsString` に変換するための中間ステップで"
"あり、[`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt."
"html) を使用して作成します。"

#: src/unsafe-rust/exercise.md
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"`&OsStr`内のデータを返し、さらに再びreaddirを呼び出せるようにするためには"
"`&OsStr`内のデータをクローンする必要があります。"

#: src/unsafe-rust/exercise.md
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) にも、FFI に関する有益"
"な章があります。"

#: src/unsafe-rust/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"以下のコードを <https://play.rust-lang.org/> にコピーし、不足している関数とメ"
"ソッドを記入します。"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"macos\""
msgstr "\"macos\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr ""
"// オペーク型。https://doc.rust-lang.org/nomicon/ffi.html をご覧ください。\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""
"// readdir(3) の Linux マニュアル ページに沿ったレイアウト。ino_t と\n"
"    // off_t は\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h} の定義に"
"従って解決されます。\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr "// macOSマニュアル ページのdir(5)に沿ったレイアウト。\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""
"// https://github.com/rust-lang/libc/issues/414、および  macOS 版マニュアル "
"ページのstat(2)における\n"
"        // _DARWIN_FEATURE_64_BIT_INODE に関するセクションをご覧ください。\n"
"        //\n"
"        // 「これらのアップデートが利用可能になる前に存在していたプラット"
"フォーム(\"Platforms that existed before these updates were available\")」と"
"は、\n"
"        // Intel および PowerPC 上の macOS（iOS / wearOS などではない）を指し"
"ます。\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"readdir$INODE64\""
msgstr "\"readdir$INODE64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""
"// opendir を呼び出し、成功した場合は Ok 値を返し、\n"
"        // それ以外の場合はメッセージとともに Err を返します。\n"

#: src/unsafe-rust/exercise.md
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr "// NULL ポインタが返されるまで readdir を呼び出し続けます。\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "// Call closedir as needed.\n"
msgstr "// 必要に応じて closedir を呼び出します。\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#: src/android/interoperability/with-c/rust.md
msgid "\".\""
msgstr "\".\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"files: {:#?}\""
msgstr "\"files: {:#?}\""

#: src/unsafe-rust/solution.md
msgid "\"Invalid path: {err}\""
msgstr "\"Invalid path: {err}\""

#: src/unsafe-rust/solution.md
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr "// SAFETY: path.as_ptr()がNULLであることはありません。\n"

#: src/unsafe-rust/solution.md
msgid "\"Could not open {:?}\""
msgstr "\"Could not open {:?}\""

#: src/unsafe-rust/solution.md
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""
"// NULL ポインタが返されるまで readdir を呼び出し続けます。\n"
"        // SAFETY: self.dir は決して NULL になりません。\n"

#: src/unsafe-rust/solution.md
msgid "// We have reached the end of the directory.\n"
msgstr "// ディレクトリの最後に到達しました。\n"

#: src/unsafe-rust/solution.md
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""
"// 安全: dirent は NULL ではなく、dirent.d_name は NUL\n"
"        // 文字終端されています。\n"

#: src/unsafe-rust/solution.md
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr "// 安全: self.dir は NULL ではありません。\n"

#: src/unsafe-rust/solution.md
msgid "\"Could not close {:?}\""
msgstr "\"Could not close {:?}\""

#: src/unsafe-rust/solution.md
msgid "\"no-such-directory\""
msgstr "\"no-such-directory\""

#: src/unsafe-rust/solution.md
msgid "\"Non UTF-8 character in path\""
msgstr "\"Non UTF-8 character in path\""

#: src/unsafe-rust/solution.md
msgid "\"..\""
msgstr "\"..\""

#: src/unsafe-rust/solution.md
msgid "\"foo.txt\""
msgstr "\"foo.txt\""

#: src/unsafe-rust/solution.md
msgid "\"The Foo Diaries\\n\""
msgstr "\"The Foo Diaries\\n\""

#: src/unsafe-rust/solution.md
msgid "\"bar.png\""
msgstr "\"bar.png\""

#: src/unsafe-rust/solution.md
msgid "\"<PNG>\\n\""
msgstr "\"<PNG>\\n\""

#: src/unsafe-rust/solution.md
msgid "\"crab.rs\""
msgstr "\"crab.rs\""

#: src/unsafe-rust/solution.md
msgid "\"//! Crab\\n\""
msgstr "\"//! Crab\\n\""

#: src/android.md
msgid "Welcome to Rust in Android"
msgstr "Android での Rust へようこそ"

#: src/android.md
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"Rust は Android のシステム ソフトウェアでサポートされています。つまり、新しい"
"サービス、ライブラリ、ドライバ、さらにはファームウェアを Rust で作成できます"
"（または、必要に応じて既存のコードを改善できます）。"

#: src/android.md
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"本日は、皆さんのプロジェクトの一つから Rust を呼び出してみたいと思います。"
"コードベースの小さな隅を見つけて、数行のコードを Rust に書き換えてみましょ"
"う。依存関係が少なく、「珍しい」型がよいでしょう。未加工のバイトを解析するも"
"のが理想的です。"

#: src/android.md
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr ""
"Android で Rust が使用されることが増えているため、次のいずれかに言及すること"
"をおすすめします。"

#: src/android.md
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""
"サービスの例: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"

#: src/android.md
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""
"ライブラリ: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"

#: src/android.md
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""
"カーネル ドライバ: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"

#: src/android.md
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""
"ファームウェア: [pKVM ファームウェア](https://security.googleblog."
"com/2023/10/bare-metal-rust-in-android.html)"

#: src/android/setup.md
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"コードのテストのためにCuttlefish Android Virtual Device を使用します。既存の"
"Deviceがあればそれにアクセスできることを確認し、そうでなければ以下のコマンド"
"により作成しておいてください。"

#: src/android/setup.md
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"詳しくは、[Android デベロッパー Codelab](https://source.android.com/docs/"
"setup/start) をご覧ください。"

#: src/android/setup.md
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""
"Cuttlefish は、一般的な Linux デスクトップで動作するように設計されたリファレ"
"ンス Android デバイスです。macOS のサポートも予定されています。"

#: src/android/setup.md
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""
"Cuttlefish システム イメージは、実際のデバイスに対する高い忠実度を維持してい"
"るため、多くの Rust ユースケースを実行するのに理想的なエミュレータです。"

#: src/android/build-rules.md
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"Android ビルドシステム（Soong）は、さまざまなモジュールを通じて Rust をサポー"
"トしています。"

#: src/android/build-rules.md
msgid "Module Type"
msgstr "モジュール タイプ"

#: src/android/build-rules.md
msgid "Description"
msgstr "説明"

#: src/android/build-rules.md
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md
msgid "Produces a Rust binary."
msgstr "Rust バイナリを生成します。"

#: src/android/build-rules.md
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""
"Rust ライブラリを生成し、`rlib` と `dylib` の両方のバリアントを提供します。"

#: src/android/build-rules.md
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""
"`cc` モジュールで使用できる Rust C ライブラリを生成し、静的バリアントと共有バ"
"リアントの両方を提供します。"

#: src/android/build-rules.md
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"`proc-macro` Rust ライブラリを生成します。これらはコンパイラ プラグインに似て"
"います。"

#: src/android/build-rules.md
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr "標準の Rust テストハーネスを使用する Rust テストバイナリを生成します。"

#: src/android/build-rules.md
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "`libfuzzer` を利用して、Rust ファズバイナリを生成します。"

#: src/android/build-rules.md
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"ソースを生成し、特定の protobuf 用のインターフェースを提供する Rust ライブラ"
"リを生成します。"

#: src/android/build-rules.md
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"ソースを生成し、C ライブラリへの Rust バインディングを含む Rust ライブラリを"
"生成します。"

#: src/android/build-rules.md
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "次に `rust_binary` と `rust_library` を見ていきます。"

#: src/android/build-rules.md
msgid "Additional items speaker may mention:"
msgstr "追加で次の項目に言及することをおすすめします。"

#: src/android/build-rules.md
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr ""
"Cargo は多言語リポジトリ用に最適化されていません。また、インターネットから"
"パッケージをダウンロードします。"

#: src/android/build-rules.md
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""
"コンプライアンスおよびパフォーマンス上の理由から、Android ではクレートをツ"
"リー内に配置する必要があります。また、C /C++ / Java コードとの相互運用性も必"
"要です。Soong を使用することで、そのギャップを埋めることができます。"

#: src/android/build-rules.md
msgid ""
"Soong has many similarities to Bazel, which is the open-source variant of "
"Blaze (used in google3)."
msgstr ""
"Soong には、Blaze（google3 で使用）のオープンソース版である Bazel と多くの類"
"似点があります。"

#: src/android/build-rules.md
msgid ""
"There is a plan to transition [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) to Bazel."
msgstr ""
"[Android](https://source.android.com/docs/setup/build/bazel/introduction)、"
"[ChromeOS](https://chromium.googlesource.com/chromiumos/bazel/)、[Fuchsia]"
"(https://source.android.com/docs/setup/build/bazel/introduction) を Bazel に"
"移行する計画があります。"

#: src/android/build-rules.md
msgid "Learning Bazel-like build rules is useful for all Rust OS developers."
msgstr ""
"Bazel のようなビルドルールを学ぶことは、すべての Rust OS デベロッパーに役立ち"
"ます。"

#: src/android/build-rules.md
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr ""
"豆知識: スタートレックの「データ」は、スン（Soong）型アンドロイドです。"

#: src/android/build-rules/binary.md
msgid "Rust Binaries"
msgstr "Rust バイナリ"

#: src/android/build-rules/binary.md
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"簡単なアプリから始めましょう。AOSP チェックアウトのルートで、次のファイルを作"
"成します。"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md
msgid "\"hello_rust\""
msgstr "\"hello_rust\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#: src/android/logging.md
msgid "\"src/main.rs\""
msgstr "\"src/main.rs\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "//! Rust demo.\n"
msgstr "//! Rust のデモ。\n"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "/// Prints a greeting to standard output.\n"
msgstr "/// 挨拶を標準出力に出力します。\n"

#: src/android/build-rules/binary.md src/exercises/chromium/build-rules.md
msgid "\"Hello from Rust!\""
msgstr "\"Hello from Rust!\""

#: src/android/build-rules/binary.md
msgid "You can now build, push, and run the binary:"
msgstr "これで、バイナリをビルド、push、実行できます。"

#: src/android/build-rules/binary.md
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"

#: src/android/build-rules/library.md
msgid "Rust Libraries"
msgstr "Rust ライブラリ"

#: src/android/build-rules/library.md
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"`rust_library` を使用して、Android 用の新しい Rust ライブラリを作成します。"

#: src/android/build-rules/library.md
msgid "Here we declare a dependency on two libraries:"
msgstr "ここでは、2 つのライブラリへの依存関係を宣言します。"

#: src/android/build-rules/library.md
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`: 以下で定義します。"

#: src/android/build-rules/library.md
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`: すでに[`external/rust/crates/`](https://cs.android.com/"
"android/platform/superproject/+/master:external/rust/crates/) に取り込まれて"
"いるクレートです。"

#: src/android/build-rules/library.md
msgid "\"hello_rust_with_dep\""
msgstr "\"hello_rust_with_dep\""

#: src/android/build-rules/library.md
msgid "\"libgreetings\""
msgstr "\"libgreetings\""

#: src/android/build-rules/library.md
msgid "\"libtextwrap\""
msgstr "\"libtextwrap\""

#: src/android/build-rules/library.md
msgid "// Need this to avoid dynamic link error.\n"
msgstr "// ダイナミック リンク エラーを回避するために必要です。\n"

#: src/android/build-rules/library.md
msgid "\"greetings\""
msgstr "\"greetings\""

#: src/android/build-rules/library.md src/android/aidl/implementation.md
#: src/android/interoperability/java.md
msgid "\"src/lib.rs\""
msgstr "\"src/lib.rs\""

#: src/android/build-rules/library.md
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md
msgid "//! Greeting library.\n"
msgstr "//! 挨拶ライブラリ。\n"

#: src/android/build-rules/library.md
msgid "/// Greet `name`.\n"
msgstr "/// `name` に挨拶します。\n"

#: src/android/build-rules/library.md
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr "\"Hello {name}, it is very nice to meet you!\""

#: src/android/build-rules/library.md
msgid "You build, push, and run the binary like before:"
msgstr "前と同じようにバイナリをビルド、push、実行します。"

#: src/android/build-rules/library.md
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"

#: src/android/aidl.md
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Rust では [Android インターフェース定義言語（AIDL）](https://developer."
"android.com/guide/components/aidl) がサポートされています。"

#: src/android/aidl.md
msgid "Rust code can call existing AIDL servers,"
msgstr "Rust コードは既存の AIDL サーバーを呼び出すことができます。"

#: src/android/aidl.md
msgid "You can create new AIDL servers in Rust."
msgstr "Rust では新しい AIDL サーバーを作成できます。"

#: src/android/aidl/interface.md
msgid "AIDL Interfaces"
msgstr "AIDL インターフェース"

#: src/android/aidl/interface.md
msgid "You declare the API of your service using an AIDL interface:"
msgstr "サービスの API を宣言するには、AIDL インターフェースを使用します。"

#: src/android/aidl/interface.md
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md src/android/aidl/changing.md
msgid "/** Birthday service interface. */"
msgstr "/** 誕生日サービスのインターフェース。*/"

#: src/android/aidl/interface.md src/android/aidl/changing.md
msgid "/** Generate a Happy Birthday message. */"
msgstr "/** 「お誕生日おめでとう」というメッセージを生成します。*/"

#: src/android/aidl/interface.md
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md
msgid "\"com.example.birthdayservice\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/interface.md
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr "\"com/example/birthdayservice/*.aidl\""

#: src/android/aidl/interface.md
msgid "// Rust is not enabled by default\n"
msgstr "// Rust はデフォルトでは無効です。\n"

#: src/android/aidl/interface.md
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"AIDL ファイルがベンダー パーティション内のバイナリで使用されている場合は、"
"`vendor_available: true` を追加します。"

#: src/android/aidl/implementation.md
msgid "Service Implementation"
msgstr "サービスの実装"

#: src/android/aidl/implementation.md
msgid "We can now implement the AIDL service:"
msgstr "次に、AIDL サービスを実装します。"

#: src/android/aidl/implementation.md
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md
msgid "//! Implementation of the `IBirthdayService` AIDL interface.\n"
msgstr "//! `IBirthdayService` AIDL インターフェースの実装。\n"

#: src/android/aidl/implementation.md
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "/// `IBirthdayService` の実装。\n"

#: src/android/aidl/implementation.md
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr "\"Happy Birthday {name}, congratulations with the {years} years!\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md src/android/aidl/server.md
msgid "\"libbirthdayservice\""
msgstr "\"libbirthdayservice\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
msgid "\"birthdayservice\""
msgstr "\"birthdayservice\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
msgid "\"com.example.birthdayservice-rust\""
msgstr "\"com.example.birthdayservice-rust\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
msgid "\"libbinder_rs\""
msgstr "\"libbinder_rs\""

#: src/android/aidl/server.md
msgid "AIDL Server"
msgstr "AIDL サーバー"

#: src/android/aidl/server.md
msgid "Finally, we can create a server which exposes the service:"
msgstr "次に、サービスを公開するサーバーを作成します。"

#: src/android/aidl/server.md
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md src/android/aidl/client.md
msgid "//! Birthday service.\n"
msgstr "//! 誕生日サービス。\n"

#: src/android/aidl/server.md
msgid "/// Entry point for birthday service.\n"
msgstr "/// 誕生日サービスのエントリ ポイント。\n"

#: src/android/aidl/server.md
msgid "\"Failed to register service\""
msgstr "\"Failed to register service\""

#: src/android/aidl/server.md
msgid "\"birthday_server\""
msgstr "\"birthday_server\""

#: src/android/aidl/server.md
msgid "\"src/server.rs\""
msgstr "\"src/server.rs\""

#: src/android/aidl/server.md src/android/aidl/client.md
msgid "// To avoid dynamic link error.\n"
msgstr "// ダイナミック リンク エラーを回避するためです。\n"

#: src/android/aidl/deploy.md
msgid "We can now build, push, and start the service:"
msgstr "次に、サービスをビルド、push、開始します。"

#: src/android/aidl/deploy.md
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md
msgid "In another terminal, check that the service runs:"
msgstr "別のターミナルで、サービスが実行されていることを確認します。"

#: src/android/aidl/deploy.md
msgid "You can also call the service with `service call`:"
msgstr "`service call` を使用してサービスを呼び出すこともできます。"

#: src/android/aidl/client.md
msgid "AIDL Client"
msgstr "AIDL クライアント"

#: src/android/aidl/client.md
msgid "Finally, we can create a Rust client for our new service."
msgstr "ようやくここで、新しいサービス用の Rust クライアントを作成します。"

#: src/android/aidl/client.md
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md
msgid "/// Connect to the BirthdayService.\n"
msgstr "/// BirthdayService に接続します。\n"

#: src/android/aidl/client.md
msgid "/// Call the birthday service.\n"
msgstr "/// 誕生日サービスを呼び出します。\n"

#: src/android/aidl/client.md
msgid "\"Failed to connect to BirthdayService\""
msgstr "\"Failed to connect to BirthdayService\""

#: src/android/aidl/client.md
msgid "\"{msg}\""
msgstr "\"{msg}\""

#: src/android/aidl/client.md
msgid "\"birthday_client\""
msgstr "\"birthday_client\""

#: src/android/aidl/client.md
msgid "\"src/client.rs\""
msgstr "\"src/client.rs\""

#: src/android/aidl/client.md
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr ""
"クライアントが `libbirthdayservice` に依存していないことに注目してください。"

#: src/android/aidl/client.md
msgid "Build, push, and run the client on your device:"
msgstr "デバイスでクライアントをビルド、push、実行します。"

#: src/android/aidl/client.md
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"

#: src/android/aidl/changing.md
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"APIを拡張して、クライアントが誕生日カードに追加する複数行のメッセージを指定で"
"きるようにします。"

#: src/android/logging.md
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"`log` クレートを使用して、自動的に （デバイス上では）`logcat` または （ホスト"
"上では）`stdout`にログを記録するようにします。"

#: src/android/logging.md
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md
msgid "\"hello_rust_logs\""
msgstr "\"hello_rust_logs\""

#: src/android/logging.md
msgid "\"liblog_rust\""
msgstr "\"liblog_rust\""

#: src/android/logging.md
msgid "\"liblogger\""
msgstr "\"liblogger\""

#: src/android/logging.md
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md
msgid "//! Rust logging demo.\n"
msgstr "//! Rust ロギングのデモ。\n"

#: src/android/logging.md
msgid "/// Logs a greeting.\n"
msgstr "/// 挨拶をログに記録します。\n"

#: src/android/logging.md
msgid "\"rust\""
msgstr "\"rust\""

#: src/android/logging.md
msgid "\"Starting program.\""
msgstr "\"Starting program.\""

#: src/android/logging.md
msgid "\"Things are going fine.\""
msgstr "\"Things are going fine.\""

#: src/android/logging.md
msgid "\"Something went wrong!\""
msgstr "\"Something went wrong!\""

#: src/android/logging.md src/android/interoperability/with-c/bindgen.md
#: src/android/interoperability/with-c/rust.md
msgid "Build, push, and run the binary on your device:"
msgstr "デバイスでバイナリをビルド、push、実行します。"

#: src/android/logging.md
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md
msgid "The logs show up in `adb logcat`:"
msgstr "`adb logcat` でログを表示できます。"

#: src/android/interoperability.md
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr "Rust は他の言語との相互運用性に優れているため、次のことが可能です。"

#: src/android/interoperability.md
msgid "Call Rust functions from other languages."
msgstr "他の言語から Rust 関数を呼び出す。"

#: src/android/interoperability.md
msgid "Call functions written in other languages from Rust."
msgstr "Rust から他の言語で記述された関数を呼び出す。"

#: src/android/interoperability.md
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"他の言語の関数を呼び出す場合は、外部関数インターフェース（FFI: _foreign "
"function interface_）を使用します。"

#: src/android/interoperability/with-c.md
msgid "Interoperability with C"
msgstr "C との相互運用性"

#: src/android/interoperability/with-c.md
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust は、C の呼び出し規則によるオブジェクト ファイルのリンクを完全にサポート"
"しています。同様に、Rust 関数をエクスポートして C から呼び出すことができま"
"す。"

#: src/android/interoperability/with-c.md
msgid "You can do it by hand if you want:"
msgstr "これは手動で行うこともできます。"

#: src/android/interoperability/with-c.md
msgid "\"{x}, {abs_x}\""
msgstr "\"{x}, {abs_x}\""

#: src/android/interoperability/with-c.md
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"これは、[安全な FFI ラッパーの演習](../../exercises/day-3/safe-ffi-wrapper."
"md)ですでに取り扱いました。"

#: src/android/interoperability/with-c.md
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"これは、ターゲット プラットフォームを完全に理解していることを前提としていま"
"す。本番環境での使用推奨されません。"

#: src/android/interoperability/with-c.md
msgid "We will look at better options next."
msgstr "次に、より良い選択肢を見ていきます。"

#: src/android/interoperability/with-c/bindgen.md
msgid "Using Bindgen"
msgstr "Bindgen の使用"

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) ツール"
"を使用すると、C ヘッダー ファイルからバインディングを自動生成できます。"

#: src/android/interoperability/with-c/bindgen.md
msgid "First create a small C library:"
msgstr "まず、小さな C ライブラリを作成します。"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "<stdio.h>"
msgstr "<stdio.h>"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday.h\""
msgstr "\"libbirthday.h\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"+--------------\\n\""
msgstr "\"+--------------\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"| Happy Birthday %s!\\n\""
msgstr "\"| Happy Birthday %s!\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"| Congratulations with the %i years!\\n\""
msgstr "\"| Congratulations with the %i years!\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "Add this to your `Android.bp` file:"
msgstr "これを `Android.bp` ファイルに追加します。"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperability/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday\""
msgstr "\"libbirthday\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday.c\""
msgstr "\"libbirthday.c\""

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"ライブラリのラッパー ヘッダー ファイルを作成します（この例では必須ではありま"
"せん）。"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "You can now auto-generate the bindings:"
msgstr "これで、バインディングを自動生成できます。"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday_bindgen\""
msgstr "\"libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"birthday_bindgen\""
msgstr "\"birthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday_wrapper.h\""
msgstr "\"libbirthday_wrapper.h\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"bindings\""
msgstr "\"bindings\""

#: src/android/interoperability/with-c/bindgen.md
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "これで、Rust プログラムでバインディングを使用できます。"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"print_birthday_card\""
msgstr "\"print_birthday_card\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"main.rs\""
msgstr "\"main.rs\""

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "//! Bindgen demo.\n"
msgstr "//! Bindgen のデモ。\n"

#: src/android/interoperability/with-c/bindgen.md
msgid "// SAFETY: `print_card` is safe to call with a valid `card` pointer.\n"
msgstr ""
"// SAFETY: `print_card` は有効な `card` ポインタで安全に呼び出せます。\n"

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"これで、自動生成されたテストを実行して、バインディングが機能していることを確"
"認できます。"

#: src/android/interoperability/with-c/bindgen.md
msgid "\"libbirthday_bindgen_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\":libbirthday_bindgen\""
msgstr "\":libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"general-tests\""
msgstr "\"general-tests\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"none\""
msgstr "\"none\""

#: src/android/interoperability/with-c/bindgen.md
msgid "// Generated file, skip linting\n"
msgstr "// 生成されたファイル、lint チェックをスキップ\n"

#: src/android/interoperability/with-c/rust.md
msgid "Calling Rust"
msgstr "Rust の呼び出し"

#: src/android/interoperability/with-c/rust.md
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Rust の関数と型は、C に簡単にエクスポートできます。"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md
msgid "//! Rust FFI demo.\n"
msgstr "//! Rust FFI のデモ。\n"

#: src/android/interoperability/with-c/rust.md
msgid "/// Analyze the numbers.\n"
msgstr "/// 数値を分析します。\n"

#: src/android/interoperability/with-c/rust.md
msgid "\"x ({x}) is smallest!\""
msgstr "\"x ({x}) is smallest!\""

#: src/android/interoperability/with-c/rust.md
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr "\"y ({y}) is probably larger than x ({x})\""

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"libanalyze_ffi\""
msgstr "\"libanalyze_ffi\""

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze_ffi\""
msgstr "\"analyze_ffi\""

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze.rs\""
msgstr "\"analyze.rs\""

#: src/android/interoperability/with-c/rust.md
msgid "We can now call this from a C binary:"
msgstr "これで、これを C バイナリから呼び出せるようになりました。"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze.h\""
msgstr "\"analyze.h\""

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze_numbers\""
msgstr "\"analyze_numbers\""

#: src/android/interoperability/with-c/rust.md
msgid "\"main.c\""
msgstr "\"main.c\""

#: src/android/interoperability/with-c/rust.md
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` により Rust の通常の名前のマングリングが無効になるため、エクス"
"ポートされたシンボルは単に関数の名前になります。`#[export_name = "
"\"some_name\"]` を使用して任意の名前を指定することもできます。"

#: src/android/interoperability/cpp.md
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX クレート](https://cxx.rs/)を使用すると、Rust と C++ の間で安全な相互運用"
"性を確保できます。"

#: src/android/interoperability/cpp.md
msgid "The overall approach looks like this:"
msgstr "全体的なアプローチは次のようになります。"

#: src/android/interoperability/cpp/bridge.md
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""
"CXX は、各言語から他の言語に公開される関数シグネチャの記述に依存します。この"
"記述は、`#[cxx::bridge]` 属性マクロでアノテーションされた Rust モジュール内"
"の extern ブロックを使用して指定します。"

#: src/android/interoperability/cpp/bridge.md
msgid "\"org::blobstore\""
msgstr "\"org::blobstore\""

#: src/android/interoperability/cpp/bridge.md
msgid "// Shared structs with fields visible to both languages.\n"
msgstr "// 両方の言語からアクセスできるフィールドを持つ共有構造体。\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
msgid "// Rust types and signatures exposed to C++.\n"
msgstr "// C++ に公開される Rust の型とシグネチャ。\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#: src/android/interoperability/cpp/rust-result.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "\"Rust\""
msgstr "\"Rust\""

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr "// Rust に公開される C++ の型とシグネチャ。\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/android/interoperability/cpp/cpp-exception.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "\"C++\""
msgstr "\"C++\""

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"include/blobstore.h\""
msgstr "\"include/blobstore.h\""

#: src/android/interoperability/cpp/bridge.md
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr "ブリッジは通常、クレート内の `ffi` モジュールで宣言します。"

#: src/android/interoperability/cpp/bridge.md
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""
"ブリッジ モジュールで行われた宣言から、CXX はマッチする Rust と C++ の型 / 関"
"数の定義を生成し、これらのアイテムを両方の言語に公開します。"

#: src/android/interoperability/cpp/bridge.md
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""
"生成された Rust コードを表示するには、[cargo-expand](https://github.com/"
"dtolnay/cargo-expand) を使用して、展開された proc マクロを表示します。ほとん"
"どの例では、`cargo expand ::ffi` を使用して `ffi` モジュールのみを展開します"
"（ただし、これは Android プロジェクトには当てはまりません）。"

#: src/android/interoperability/cpp/bridge.md
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr "生成された C++ コードを表示するには、`target/cxxbridge` を確認します。"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "Rust Bridge Declarations"
msgstr "Rust のブリッジ宣言"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "// Opaque type\n"
msgstr "// オペーク型\n"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "// Method on `MyType`\n"
msgstr "// `MyType` のメソッド\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Free function\n"
msgstr "関数"

#: src/android/interoperability/cpp/rust-bridge.md
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""
"親モジュールのスコープ内にある `extern \"Rust\"` 参照アイテムで宣言されたアイ"
"テム。"

#: src/android/interoperability/cpp/rust-bridge.md
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""
"CXX コード ジェネレータは、`extern \"Rust\"` セクションを使用して、対応する "
"C++ 宣言を含む C++ ヘッダー ファイルを生成します。生成されるヘッダーのパス"
"は、rs.hというファイル拡張子部分を除き、ブリッジを含む Rust ソースファイルと"
"同じになります。"

#: src/android/interoperability/cpp/generated-cpp.md
msgid "Results in (roughly) the following C++:"
msgstr "おおよそ次のような C++ が生成されます。"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "C++ Bridge Declarations"
msgstr "C++ のブリッジ宣言"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "Results in (roughly) the following Rust:"
msgstr "おおよそ次のような Rust が生成されます。"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr "\"org$blobstore$cxxbridge1$new_blobstore_client\""

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""

#: src/android/interoperability/cpp/cpp-bridge.md
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""
"プログラマーは、入力したシグネチャが正確であることを保証する必要はありませ"
"ん。CXX は、シグネチャが C++ で宣言されたものと完全に対応するということを静的"
"に保証します。"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""
"`unsafe extern` ブロックを使用すると、Rust から安全に呼び出せる C++ 関数を宣"
"言できます。"

#: src/android/interoperability/cpp/shared-types.md
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr "// A=1、J=11、Q=12、K=13\n"

#: src/android/interoperability/cpp/shared-types.md
msgid "Only C-like (unit) enums are supported."
msgstr "C のような（単位）列挙型のみがサポートされています。"

#: src/android/interoperability/cpp/shared-types.md
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""
"共有型の `#[derive()]` では、サポートされるトレイトの数が限られています。対応"
"する機能は C++ コードでも生成されます。たとえば、`Hash` を導出すると、対応す"
"る C++ 型の `std::hash` の実装も生成されます。"

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated Rust:"
msgstr "生成された Rust:"

#: src/android/interoperability/cpp/shared-enums.md
msgid "Generated C++:"
msgstr "生成された C++:"

#: src/android/interoperability/cpp/shared-enums.md
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""
"Rust 側では、共有列挙型に対して生成されるコードは、実際には数値をラップした構"
"造体です。これは、列挙型クラスがリストされたすべてのバリアントとは異なる値を"
"保持することは C++ では UB ではなく、Rust 表現は同じ動作をする必要があるため"
"です。"

#: src/android/interoperability/cpp/rust-result.md
msgid "\"fallible1 requires depth > 0\""
msgstr "\"fallible1 requires depth > 0\""

#: src/android/interoperability/cpp/rust-result.md
msgid "\"Success!\""
msgstr "\"Success!\""

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr "`Result` を返す Rust 関数は、C++ 側で例外に変換されます。"

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""
"スローされる例外は常に `rust::Error` 型で、主にエラー メッセージの文字列を取"
"得する手段を提供します。エラー メッセージは、エラー型の `Display` の実装から"
"取得されます。"

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""
"Rust から C++ にパニック アンワインドを行うと、プロセスは必ず直ちに終了しま"
"す。"

#: src/android/interoperability/cpp/cpp-exception.md
msgid "\"example/include/example.h\""
msgstr "\"example/include/example.h\""

#: src/android/interoperability/cpp/cpp-exception.md
msgid "\"Error: {}\""
msgstr "\"Error: {}\""

#: src/android/interoperability/cpp/cpp-exception.md
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""
"`Result` を返すように宣言された C++ 関数は、C++ 側でスローされたあらゆる例外"
"をキャッチし、呼び出し元の Rust 関数に `Err` 値として返します。"

#: src/android/interoperability/cpp/cpp-exception.md
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""
"CXX ブリッジでResultを返すように宣言されていないextern \"C++\"関数から例外が"
"スローされると、`Result`が返されると、プログラムは C++ の`std::terminate`を呼"
"び出します。この動作は、同じ例外が`noexcept` C++ 関数でスローされた場合と同等"
"です。"

#: src/android/interoperability/cpp/type-mapping.md
msgid "Rust Type"
msgstr "Rust 型"

#: src/android/interoperability/cpp/type-mapping.md
msgid "C++ Type"
msgstr "C++ 型"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::String`"
msgstr "`rust::String`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Str`"
msgstr "`rust::Str`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxString`"
msgstr "`CxxString`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`std::string`"
msgstr "`std::string`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&[T]`/`&mut [T]`"
msgstr "`&[T]`/`&mut [T]`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Slice`"
msgstr "`rust::Slice`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Box<T>`"
msgstr "`rust::Box<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`UniquePtr<T>`"
msgstr "`UniquePtr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`std::unique_ptr<T>`"
msgstr "`std::unique_ptr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`Vec<T>`"
msgstr "`Vec<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`rust::Vec<T>`"
msgstr "`rust::Vec<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`CxxVector<T>`"
msgstr "`CxxVector<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`std::vector<T>`"
msgstr "`std::vector<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""
"これらの型は、共有構造体のフィールドと、extern 関数の引数と戻り値で使用できま"
"す。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""
"Rust の `String` は `std::string` に直接マッピングされません。これには次のよ"
"うな理由があります。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr "`std::string` は、`String` が必要とする UTF-8 不変条件を満たしません。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""
"この 2 つの型はメモリ内のレイアウトが異なるため、言語間で直接渡すことはできま"
"せん。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""
"`std::string` は、Rust のムーブ セマンティクスと一致しないムーブコンストラク"
"タを必要とするため、`std::string` を Rust に値で渡すことはできません。"

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "Building in Android"
msgstr "Android 向けのビルド"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""
"`cc_library_static` を作成して、CXX で生成されたヘッダーとソースファイルを含"
"む C++ ライブラリをビルドします。"

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"libcxx_test_cpp\""
msgstr "\"libcxx_test_cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid "\"cxx_test.cpp\""
msgstr "\"cxx_test.cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid "\"cxx-bridge-header\""
msgstr "\"cxx-bridge-header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"libcxx_test_bridge_header\""
msgstr "\"libcxx_test_bridge_header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"libcxx_test_bridge_code\""
msgstr "\"libcxx_test_bridge_code\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""
"`libcxx_test_bridge_header` と `libcxx_test_bridge_code` が、CXX CXXにより生"
"成される C++ バインディングに対する依存関係であることを説明します。次のスライ"
"ドで、これらがどのような記述になっているかを説明します。"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""
"また、一般的な CXX 定義を取得するためには、`cxx-bridge-header` ライブラリに依"
"存する必要があることにも注意してください。"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""
"Android で CXX を使用するための詳細なドキュメントについては、[Android のド"
"キュメント](https://source.android.com/docs/setup/build/rust/building-rust-"
"modules/android-rust-patterns#rust-cpp-interop-using-cxx)をご覧ください。その"
"リンクをクラスと共有して、受講者が後で手順を確認できるようにすることをおすす"
"めします。"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""
"genrule を 2 つ作成します。1 つは CXX ヘッダーの生成用、もう 1 つは CXX ソー"
"スファイルの生成用です。これらは `cc_library_static` への入力として使用されま"
"す。"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""
"// lib.rs にある Rustからエクスポートされた関数に対する\n"
"// C++ バインディングを含む C++ ヘッダーを生成します。\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"cxxbridge\""
msgstr "\"cxxbridge\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr "\"$(location cxxbridge) $(in) --header > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"lib.rs\""
msgstr "\"lib.rs\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"lib.rs.h\""
msgstr "\"lib.rs.h\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr "// Rust が呼び出す C++ コードを生成します。\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr "\"$(location cxxbridge) $(in) > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"lib.rs.cc\""
msgstr "\"lib.rs.cc\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""
"`cxxbridge` ツールは、ブリッジ モジュールの C++ 側を生成するスタンドアロン "
"ツールです。Android に組み込まれており、Soong ツールとして利用できます。"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""
"慣例として、Rust ソースファイルが `lib.rs` の場合、ヘッダー ファイルの名前は "
"`lib.rs.h`、ソースファイルの名前は `lib.rs.cc` となります。ただし、この命名規"
"則は強制ではありません。"

#: src/android/interoperability/cpp/android-build-rust.md
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr "`libcxx` と `cc_library_static`に依存する `rust_binary` を作成します。"

#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"cxx_test\""
msgstr "\"cxx_test\""

#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"libcxx\""
msgstr "\"libcxx\""

#: src/android/interoperability/java.md
msgid "Interoperability with Java"
msgstr "Java との相互運用性"

#: src/android/interoperability/java.md
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java では、[Java Native Interface（JNI）](https://en.wikipedia.org/wiki/"
"Java_Native_Interface) を介して共有オブジェクトを読み込むことができます。"
"[`jni` クレート](https://docs.rs/jni/) を使用すると、互換性のあるライブラリを"
"作成できます。"

#: src/android/interoperability/java.md
msgid "First, we create a Rust function to export to Java:"
msgstr "まず、Java にエクスポートする Rust 関数を作成します。"

#: src/android/interoperability/java.md
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md
msgid "//! Rust <-> Java FFI demo.\n"
msgstr "//! Rust <-> Java FFI のデモ。\n"

#: src/android/interoperability/java.md
msgid "/// HelloWorld::hello method implementation.\n"
msgstr "/// HelloWorld::hello メソッドの実装。\n"

#: src/android/interoperability/java.md
msgid "\"system\""
msgstr "\"system\""

#: src/android/interoperability/java.md
msgid "\"Hello, {input}!\""
msgstr "\"Hello, {input}!\""

#: src/android/interoperability/java.md
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md
msgid "\"libhello_jni\""
msgstr "\"libhello_jni\""

#: src/android/interoperability/java.md
msgid "\"hello_jni\""
msgstr "\"hello_jni\""

#: src/android/interoperability/java.md
msgid "\"libjni\""
msgstr "\"libjni\""

#: src/android/interoperability/java.md
msgid "We then call this function from Java:"
msgstr "次に、Java からこの関数を呼び出します。"

#: src/android/interoperability/java.md
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md
msgid "\"helloworld_jni\""
msgstr "\"helloworld_jni\""

#: src/android/interoperability/java.md
msgid "\"HelloWorld.java\""
msgstr "\"HelloWorld.java\""

#: src/android/interoperability/java.md
msgid "\"HelloWorld\""
msgstr "\"HelloWorld\""

#: src/android/interoperability/java.md
msgid "Finally, you can build, sync, and run the binary:"
msgstr "最後に、バイナリをビルド、同期、実行します。"

#: src/exercises/android/morning.md
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"これはグループ演習です。皆さんが取り組んでいるプロジェクトの一つを題材に、そ"
"こに Rust を統合してみましょう。以下にヒントを示します。"

#: src/exercises/android/morning.md
msgid "Call your AIDL service with a client written in Rust."
msgstr "Rust で記述されたクライアントを使用して AIDL サービスを呼び出します。"

#: src/exercises/android/morning.md
msgid "Move a function from your project to Rust and call it."
msgstr "プロジェクトから Rust に関数を移動して呼び出します。"

#: src/exercises/android/morning.md
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"この演習は自由回答形式であるため、解答は用意されていません。クラスの誰かが"
"コードを持っていて、その場で Rust に変換できることを前提としています。"

#: src/chromium.md
msgid "Welcome to Rust in Chromium"
msgstr ""

#: src/chromium.md
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""

#: src/chromium.md
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""

#: src/chromium/setup.md
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""

#: src/chromium/setup.md
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr ""

#: src/chromium/setup.md
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""

#: src/chromium/setup.md
msgid "It's also recommended that you have Visual Studio code installed."
msgstr ""

#: src/chromium/setup.md
msgid "About the exercises"
msgstr ""

#: src/chromium/setup.md
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Rust community typically uses `cargo` and libraries from [crates.io](https://"
"crates.io/). Chromium is built using `gn` and `ninja` and a curated set of "
"dependencies."
msgstr ""

#: src/chromium/cargo.md
msgid "When writing code in Rust, your choices are:"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""

#: src/chromium/cargo.md
#, fuzzy
msgid "Mini exercise"
msgstr "練習問題"

#: src/chromium/cargo.md
msgid "Split into small groups and:"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""

#: src/chromium/cargo.md
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""

#: src/chromium/cargo.md
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""

#: src/chromium/cargo.md
msgid "Fontations libraries like `font-types`"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain.)"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, by `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""

#: src/chromium/cargo.md
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""

#: src/chromium/cargo.md
msgid "`cargo`, `rustfmt`, etc."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""

#: src/chromium/cargo.md
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr ""

#: src/chromium/cargo.md
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""

#: src/chromium/cargo.md
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr ""

#: src/chromium/policy.md
msgid "Chromium Rust policy"
msgstr ""

#: src/chromium/policy.md
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""

#: src/chromium/policy.md
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""

#: src/chromium/policy.md
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""

#: src/chromium/policy.md
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""

#: src/chromium/policy.md
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""

#: src/chromium/policy.md
msgid "Because of this, today's course will be heavily focused on:"
msgstr ""

#: src/chromium/policy.md
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr ""

#: src/chromium/policy.md
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr ""

#: src/chromium/policy.md
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr ""

#: src/chromium/build-rules.md
#, fuzzy
msgid "Build rules"
msgstr "ビルドのルール"

#: src/chromium/build-rules.md
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""

#: src/chromium/build-rules.md
msgid "Adding Rust code to Chromium"
msgstr ""

#: src/chromium/build-rules.md
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr ""

#: src/chromium/build-rules.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules.md
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""

#: src/chromium/build-rules.md
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""

#: src/chromium/build-rules.md
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""

#: src/chromium/build-rules.md
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""

#: src/chromium/build-rules/unsafe.md
msgid "Including `unsafe` Rust Code"
msgstr ""

#: src/chromium/build-rules/unsafe.md
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""

#: src/chromium/build-rules/unsafe.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules/depending.md
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr ""

#: src/chromium/build-rules/depending.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **type annotations** (there are quote a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""

#: src/chromium/build-rules/vscode.md
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid "Build rules exercise"
msgstr "ビルドのルール"

#: src/exercises/chromium/build-rules.md
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to to allow unsafe code in your `gn` "
"target."
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""

#: src/exercises/chromium/build-rules.md
#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Where to find help"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""

#: src/exercises/chromium/build-rules.md
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""

#: src/chromium/testing.md
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""

#: src/chromium/testing.md
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""

#: src/chromium/testing.md
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr ""

#: src/chromium/testing.md
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""

#: src/chromium/testing.md
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""

#: src/chromium/testing.md
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""

#: src/chromium/testing.md
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""

#: src/chromium/testing.md
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""

#: src/chromium/testing.md
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""

#: src/chromium/testing.md
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid "Example:"
msgstr "例"

#: src/chromium/testing/build-gn.md
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""

#: src/chromium/testing/build-gn.md
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/build-gn.md
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""

#: src/chromium/testing/build-gn.md
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid "\"//ui/base:my_rust_lib\""
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid "Under the covers the macro expands to something similar to:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Testing exercise"
msgstr "練習問題"

#: src/exercises/chromium/testing.md
msgid "Time for another exercise!"
msgstr ""

#: src/exercises/chromium/testing.md
msgid "In your Chromium build:"
msgstr ""

#: src/exercises/chromium/testing.md
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""

#: src/exercises/chromium/testing.md
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr ""

#: src/exercises/chromium/testing.md
msgid "Add the new tests to `BUILD.gn`."
msgstr ""

#: src/exercises/chromium/testing.md
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid "The tool and the library can handle a set of core types - for example:"
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "\"example/include/blobstore.h\""
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "// Definitions of Rust types and functions go here\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Point out:"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for Rust slices in C++"
msgstr "組み込みのテストサポート。"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "CXX fundamentally suits cases where:"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Function pointers are awkward to use."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "The `T` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "A primitive type (like `u32` or `usize`)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "The `E` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid "CXX Error Handling: QR Example"
msgstr "エラー処理"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid "\"qr_code_generator\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data can’t be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "CXX Error Handling: PNG Example"
msgstr "エラー処理"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "\"gfx::rust_bindings\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "Using cxx in Chromium"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Exercise: Interoperability with C++"
msgstr "相互運用性"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part one"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Modify your `gn` target to build these bindings."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Build and run!"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part two"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Some things to try:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Call back into C++ from Rust. You will need:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Pass a C++ string from C++ into Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Pass a reference to a C++ object into Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part three"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Some of the questions you may encounter:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "C++ library"
msgstr "ライブラリ"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Rust crate"
msgstr "便利クレート"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Build system"
msgstr "ビルドのルール"

#: src/chromium/adding-third-party-crates.md
msgid "Lots"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "Consistent: `Cargo.toml`"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "Typical library size"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "Large-ish"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "Small"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "Transitive dependencies"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "Few"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "For a Chromium engineer, this has pros and cons:"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "We'll discuss:"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "How to put a crate in the Chromium source code tree"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "How to make `gn` build rules for it"
msgstr ""

#: src/chromium/adding-third-party-crates.md
msgid "How to audit its source code for sufficient safety."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "For instance,"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "To start, download the crate you want like this:"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "This `vendor` command may download:"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "Your crate"
msgstr "便利クレート"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Direct and transitive dependencies"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Now run `git status`. You should find:"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "An appropriate `README.chromium`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)（ワー"
"クスペース）"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "build script effect"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Supported by our gn templates"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Work required by you"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Checking rustc version to configure features on and off"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "None"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Checking platform or CPU to configure features on and off"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Generating code"
msgstr "ジェネリクス（generics）"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes - specify in `gnrt_config.toml`"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Building C/C++"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Patch around it"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Arbitrary other actions"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "So, your options are:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Avoid these crates"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Apply a patch to the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Specifically,"
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Auditing Third Party Crates"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Check each crate seems to be reasonably well maintained"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Check for any use of `fs` or `net` APIs"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Checking Crates into Chromium Source Code"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "`git status` should reveal:"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Please also add an `OWNERS` file in the latter location."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""

#: src/exercises/chromium/third-party.md
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""

#: src/exercises/chromium/third-party.md
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "Students will need to download lots of transitive dependencies."
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "The total crates needed are:"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`instant`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`lock_api`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`parking_lot`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`parking_lot_core`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`redox_syscall`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`scopeguard`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`smallvec`, and"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`uwuify`."
msgstr ""

#: src/exercises/chromium/third-party.md
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""

#: src/exercises/chromium/third-party.md
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid "Bringing It Together --- Exercise"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid "The Brief from Product Management"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid "Steps"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""

#: src/exercises/chromium/solutions.md
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""

#: src/bare-metal.md
msgid "Welcome to Bare Metal Rust"
msgstr "ベアメタルRustへようこそ"

#: src/bare-metal.md
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"こちらはベアメタルRustに関する独立した１日コースです。対象としているのは、"
"Rustの基本的な部分に関しては習得済みな人で（例えば、本講座で）、Cなどの他の言"
"語でベアメタル開発の経験があると理想的です。"

#: src/bare-metal.md
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"今日、取り扱うのは、ベアメタルRustです。すなわち、OSなしでRustのコードを実行"
"します。この章は以下のような構成になります:"

#: src/bare-metal.md
msgid "What is `no_std` Rust?"
msgstr "`no_std` Rustとは?"

#: src/bare-metal.md
msgid "Writing firmware for microcontrollers."
msgstr "マイクロコントローラ向けのファームウェア開発。"

#: src/bare-metal.md
msgid "Writing bootloader / kernel code for application processors."
msgstr "アプリケーションプロセッサ向けのブートローダ／カーネル開発。"

#: src/bare-metal.md
msgid "Some useful crates for bare-metal Rust development."
msgstr "ベアメタルRust開発に役立つクレートの紹介。"

#: src/bare-metal.md
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"マイクロコントローラ向けの学習では[BBC micro:bit](https://microbit.org/) v2を"
"題材として使います。これは、Nordic nRF51822マイコンベースの[開発ボード]"
"(https://tech.microbit.org/hardware/) で、いくつかのLEDやボタンスイッチ、I2C"
"接続の加速度センサやコンパス、そしてオンボードSWDデバッガを搭載しています。"

#: src/bare-metal.md
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"まずはじめに、後ほど必要となるいくつかのツールをインストールします。gLinuxま"
"たはDebianの場合は以下のようになります:"

#: src/bare-metal.md
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"さらに、`plugdev`グループにmicro:bitプログラム用デバイスへのアクセスを付与し"
"ます:"

#: src/bare-metal.md src/bare-metal/microcontrollers/debugging.md
msgid "On MacOS:"
msgstr "MacOSの場合は以下のようになります:"

#: src/bare-metal/no_std.md
msgid "`core`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`std`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "Slices, `&str`, `CStr`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`NonZeroU8`..."
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Option`, `Result`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Display`, `Debug`, `write!`..."
msgstr ""

#: src/bare-metal/no_std.md
msgid "`panic!`, `assert_eq!`..."
msgstr ""

#: src/bare-metal/no_std.md
msgid "`NonNull` and all the usual pointer-related functions"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Future` and `async`/`await`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Duration`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`String`, `CString`, `format!`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Error`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`File` and the rest of `fs`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Path`, `OsString`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`net`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`Command`, `Child`, `ExitCode`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`SystemTime`, `Instant`"
msgstr ""

#: src/bare-metal/no_std.md
msgid "`HashMap` depends on RNG."
msgstr "`HashMap`はRNGに依存します。"

#: src/bare-metal/no_std.md
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std`は`core`と`alloc`の両方を再エクスポートします。"

#: src/bare-metal/minimal.md
msgid "A minimal `no_std` program"
msgstr "最小限の`no_std`プログラム"

#: src/bare-metal/minimal.md
msgid "This will compile to an empty binary."
msgstr "このコードは空のバイナリにコンパイルされます。"

#: src/bare-metal/minimal.md
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"パニックハンドラは`std`が提供するので、それを使わない場合は自分で提供する必要"
"があります。"

#: src/bare-metal/minimal.md
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr ""
"あるいは、`panic-halt`のような別のクレートが提供するパニックハンドラを利用す"
"ることもできます。"

#: src/bare-metal/minimal.md
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"ターゲットによっては、`eh_personality`に関するエラーを回避するために`panic = "
"\"abort\"`を指定してコンパイルする必要があります。"

#: src/bare-metal/minimal.md
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"なお、`main`のようなプログラムの規定エントリポイントはないので、自分でエント"
"リポイントを定義する必要があります。通常、Rustコードを実行できるようにするた"
"めには、リンカスクリプトとある程度のアセンブリコードを必要とします。"

#: src/bare-metal/alloc.md
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"`alloc`を使うためには、[グローバル（ヒープ）アロケータ](https://doc.rust-"
"lang.org/stable/std/alloc/trait.GlobalAlloc.html)を実装しなければなりません。"

#: src/bare-metal/alloc.md
msgid ""
"// Safe because `HEAP` is only used here and `entry` is only called once.\n"
msgstr ""

#: src/bare-metal/alloc.md
msgid "// Give the allocator some memory to allocate.\n"
msgstr ""

#: src/bare-metal/alloc.md
msgid "// Now we can do things that require heap allocation.\n"
msgstr ""

#: src/bare-metal/alloc.md
msgid "\"A string\""
msgstr ""

#: src/bare-metal/alloc.md
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator`はサードパーティのクレートで、単純なバディシステムア"
"ロケータです。その他にも利用できるクレートはありますし、自前で実装したり、別"
"のアロケータに自分のコードをフックすることも可能です。"

#: src/bare-metal/alloc.md
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"パラメータ定数`LockedHeap`はアロケータの最大オーダを示します。この場合、"
"2\\*\\*32バイトの領域を確保することが可能です。"

#: src/bare-metal/alloc.md
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"もし依存関係にあるクレートが`alloc`に依存する場合、必ずバイナリファイルあたり"
"一つだけのグローバルなアロケータが存在するようにしなければなりません。通常、"
"これはトップレベルのバイナリを生成するクレートにより制御されます。"

#: src/bare-metal/alloc.md
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`extern crate panic_halt as _` という部分は、`panic_halt`クレートを確実にリン"
"クし、パニックハンドラを利用可能にするために必要です。"

#: src/bare-metal/alloc.md
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"この例で示したコードはビルドできますが、エントリポイントがないので実行するこ"
"とはできません。"

#: src/bare-metal/microcontrollers.md
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"`cortex_m_rt`クレートはCortex Mマイクロコントローラ向けのリセットハンドラ（と"
"その他もろもろ）を提供します。"

#: src/bare-metal/microcontrollers.md
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"次は、抽象度の低いレベルから順に周辺I/Oにアクセスする方法について見ていきま"
"す。"

#: src/bare-metal/microcontrollers.md
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"リセットハンドラはリターンしないので、`cortex_m_rt::entry`マクロは対象関数が"
"`fn() -> !`という型であることを要求します。"

#: src/bare-metal/microcontrollers.md
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "この例は`cargo embed --bin minimal`により実行します"

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"大半のマイクロコントローラはメモリマップドRIO空間を通して周辺I/Oにアクセスし"
"ます。micro:bitのLEDを光らせてみましょう:"

#: src/bare-metal/microcontrollers/mmio.md
msgid "/// GPIO port 0 peripheral address\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md
msgid "// GPIO peripheral offsets\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md
msgid "// PIN_CNF fields\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"// Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"GPIO 0のピン21はマトリクスLEDの一番目の列に、ピン28は最初の行に接続されていま"
"す。"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#: src/bare-metal/microcontrollers/board-support.md
msgid "Run the example with:"
msgstr "例の実行方法:"

#: src/bare-metal/microcontrollers/pacs.md
msgid "Peripheral Access Crates"
msgstr "周辺I/Oへアクセスするためのクレート（PACs）"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) は[CMSIS-SVD](https://www."
"keil.com/pack/doc/CMSIS/SVD/html/index.html) ファイルから、メモリマップされた"
"周辺I/Oに対するほぼ安全（mostly-safe）なRustラッパーを生成します。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"SVD (System View Description)ファイルはXMLファイルでデバイスのメモリマップを"
"記述したものであり、通常シリコンベンダにより提供されます。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"周辺I/Oごとに、レジスタ、フィールドと値、名前、説明、アドレスなどにより構成さ"
"れています。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"SVDファイルにはよく誤りがあり、また情報が不足していることも多いので、様々なプ"
"ロジェクトがそれを修正・追加し、クレートとして公開しています。"

#: src/bare-metal/microcontrollers/pacs.md
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt`はベクタテーブルも提供します。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"もし`cargo install cargo-binutils`を実行していれば、`cargo objdump --bin pac "
"-- -d --no-show-raw-insn`を実行することにより生成されたバイナリの中身を見るこ"
"とができます。"

#: src/bare-metal/microcontrollers/hals.md
msgid "HAL crates"
msgstr "HALクレート"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"多くのマイクロコントローラに対する[HALクレート](https://github.com/rust-"
"embedded/awesome-embedded-rust#hal-implementation-crates)が様々な周辺I/Oに対"
"するラッパーを提供しています。これらのクレートの多くは[`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)が定義するトレイトを実装しています。"

#: src/bare-metal/microcontrollers/hals.md
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low`と`set_high`は`embedded_hal`の`OutputPin`トレイトの定義するメソッド"
"です。"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"Cortex-MやRISC-Vの多くのデバイスに対してHALクレートが存在し、これらには"
"STM32、GD32、nRF、NXP、MSP430、AVR、PICマイクロコントローラなどが含まれます。"

#: src/bare-metal/microcontrollers/board-support.md
msgid "Board support crates"
msgstr "ボードサポートクレート"

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"ボードサポートクレードは特定のボードに対して更に利便性を向上させるラッパーを"
"提供します。"

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"この例では、ボードサポートクレートは単に分かりやすい名前を提供し、少しの初期"
"化を実施しているだけです。"

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"マイクロコントローラの外に実装されたオンボードデバイスに対するドライバも提供"
"されていることがあります。"

#: src/bare-metal/microcontrollers/board-support.md
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "`microbit-v2`はマトリクスLEDに対する簡単なドライバを含んでいます。"

#: src/bare-metal/microcontrollers/type-state.md
msgid "The type state pattern"
msgstr "タイプステートパターン"

#: src/bare-metal/microcontrollers/type-state.md
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"この例では、ピンを表すタイプは`Copy`も`Clone`も実装していません。そのため、た"
"だ一つのインスタンスだけが存在可能です。ピンがポート構造体からムーブされる"
"と、他の誰もそのピンにアクセスすることはできなくなります。"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can’t keep use the old instance afterwards."
msgstr ""
"ピンの設定を変更することは古いピンのインスタンスを消費することになります。そ"
"のため、それ以降は古いインスタンスを使い続けることはできなくなります。"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"変数の型はその状態を表すようになっています。例えば、この例では型がGPIOピンの"
"状態を表しています。このようにステートマシンをタイプシステムに織り込むこと"
"で、正しい設定をせずにピンを使ってしまうことがなくなります。不正な状態遷移に"
"関してはコンパイル時に発見されるようになります。"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"インプットピンに対して`is_high`を呼び出すことは可能で、アウトプットピンに対し"
"て`set_high`を呼び出すことも可能です。しかし、その逆の組み合わせは不可能で"
"す。"

#: src/bare-metal/microcontrollers/type-state.md
msgid "Many HAL crates follow this pattern."
msgstr "多くのHALクレートがこのパターンを用いています。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""
"[`embedded-hal`](https://crates.io/crates/embedded-hal)クレートはマイクロコン"
"トローラの周辺I/Oに関して共通に必要とされる多くのトレイトを提供します。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "GPIO"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "ADC"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "I2C, SPI, UART, CAN"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "RNG"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "Timers"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "Watchdogs"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"多くのクレートはこれらのトレイトに対応することで[ドライバ](https://github."
"com/rust-embedded/awesome-embedded-rust#driver-crates)を実装します。例えば、"
"加速度センサのドライバにはI2CやSPIバスの実装が必要かもしれません。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"多くのマイクロコントローラに対する実装に加えて、Raspberry Pi上のLinux向けの実"
"装も存在します。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""
"`embedded-hal`の`async`バージョンも開発中ですが、まだ安定してはいません。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/)は組み込み向けデバッグに有用なツールセットです。"
"これはOpenOCDのようなものですが、より高度に統合されています。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr ""
"SWD (Serial Wire Debug) やCMSIS-DAP経由のJTAG、 ST-LinkやJ-Linkプローブ"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr "GDBスタブやMicrosoft DAP (Debug Adapter Protocol)サーバ"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "Cargo integration"
msgstr "Cargoとのインテグレーション"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
"`cargo-embed`はcargoのサブコマンドであり、バイナリをビルドしたり、フラッシュ"
"したり、RTT（Real Time Transfers）の出力ログを取得したり、GDBに接続するための"
"ものです。設定は対象とするプロジェクトディレクトリにおける`Embed.toml`ファイ"
"ルにより行います。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) はUSB"
"上のARM標準プロトコルで、インサーキット・デバッガが様々なArm Cortexプロセッサ"
"のコアサイト・デバッグ・アクセスポートにアクセスするためのものです。BBC "
"micro:bit のオンボード・デバッガもこれを利用しています。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link はST Microelectronicsによるインサーキット・デバッガの総称で、 J-Link"
"はSEGGERによるインサーキット・デバッガの総称です。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"デバッグ・アクセスポートは通常５ピンのJTAGインタフェースか、2ピンのシリアルワ"
"イヤデバッグです。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rsは自分で独自のツールを統合したい場合に利用できるライブラリです。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-"
"protocol/) はVSCodeや他のIDEから、サポートされたマイクロコントローラ上で実行"
"されているコードをデバッグすることを可能にします。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embedはprobe-rsライブラリを利用して生成されたバイナリです。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT (Real Time Transfers)はデバッグホストとターゲット間のデータを多くのリング"
"バッファを介してやりとりするためのメカニズムです。"

#: src/bare-metal/microcontrollers/debugging.md
msgid "_Embed.toml_:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr ""
"ひとつのターミナルで、`src/bare-metal/microcontrollers/examples/`において下記"
"を実行:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "In another terminal in the same directory:"
msgstr "別のターミナルで、同じディレクトリで下記を実行:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "On gLinux or Debian:"
msgstr "gLinuxまたはDebianの場合:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "In GDB, try running:"
msgstr "GDBで下記を実行してみてください:"

#: src/bare-metal/microcontrollers/other-projects.md
#: src/bare-metal/aps/other-projects.md
msgid "Other projects"
msgstr "他のプロジェクト"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[RTIC](https://rtic.rs/)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"Real-Time Interrupt-driven Concurrency\"の略"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""
"共有リソース管理、メッセージパッシング、タスクスケジューリング、タイマキュー"
"を提供"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Embassy](https://embassy.dev/)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "優先度付き`async` エグゼキュータ、タイマ、ネットワーク、USB"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""
"セキュリティに焦点をあてたRTOSで、プリエンプティブ・スケジューリングとMemory "
"Protection Unitをサポート"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Oxide Computer CompanyによるマイクロカーネルのRTOSでメモリ保護、非特権ドライ"
"バ、IPCを提供"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr ""
"[FreeRTOSに対するRustバインディング](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"いくつかのプラットフォームでは `std`の実装あり、例えば [esp-idf](https://esp-"
"rs.github.io/book/overview/using-the-standard-library.html)。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr ""
"RTICはRTOSとして捉えることもできますし、並行実行のフレームワークとして捉える"
"こともできます。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "It doesn't include any HALs."
msgstr "他のHALを全く含んでいません。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"スケジューリングはカーネルではなく、Cortex-M NVIC (Nested Virtual Interrupt "
"Controller)を利用して行います。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "Cortex-M only."
msgstr "Cortex-Mのみの対応です。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"GoogleはTockOSをTitanセキュリティキーのHavenマイクロコントローラで利用してい"
"ます。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOS はほとんどCで書かれていますが、アプリケーションを開発するためのRust"
"バインディングが存在します。"

#: src/exercises/bare-metal/morning.md
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""
"I2C接続のコンパスから方位を読み取り、その結果をシリアルポートに出力します。"

#: src/exercises/bare-metal/morning.md src/exercises/concurrency/morning.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"練習問題に取り組んだあとは、 [解答](solutions-morning.md)をみても構いません。"

#: src/exercises/bare-metal/compass.md
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"I2C接続のコンパスから方位を読み取り、その結果をシリアルポートに出力します。も"
"し時間があれば、LEDやボタンをなんとか利用して方位を出力してみてください。"

#: src/exercises/bare-metal/compass.md
msgid "Hints:"
msgstr "ヒント:"

#: src/exercises/bare-metal/compass.md
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"[`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) クレートと "
"[`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/)クレートのドキュ"
"メント、ならびに[micro:bitハードウェア仕様](https://tech.microbit.org/"
"hardware/)を確認してみてください。"

#: src/exercises/bare-metal/compass.md
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr "LSM303AGR慣性計測器は内部のI2Cバスに接続されています。"

#: src/exercises/bare-metal/compass.md
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr "TWIはI2Cの別名なので、I2CマスタはTWIMという名前になっています。"

#: src/exercises/bare-metal/compass.md
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"LSM303AGRドライバは`embedded_hal::blocking::i2c::WriteRead`を実装するものを必"
"要とします。 [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/"
"microbit/hal/struct.Twim.html)構造体がこれを実装しています。"

#: src/exercises/bare-metal/compass.md
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"様々なピンや周辺I/Oのための [`microbit::Board`](https://docs.rs/microbit-v2/"
"latest/microbit/struct.Board.html)という構造体があります。"

#: src/exercises/bare-metal/compass.md
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"[nRF52833データシート](https://infocenter.nordicsemi.com/pdf/"
"nRF52833_PS_v1.5.pdf)を見ることもできますが、この練習問題のためには必要ないは"
"ずです。"

#: src/exercises/bare-metal/compass.md
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"[練習問題のテンプレート](../../comprehensive-rust-exercises.zip) をダウンロー"
"ドして、`compass`というディレクトリの中にある下記のファイルを見てください。"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_src/main.rs_:"
msgstr ""

#: src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "// Configure serial port.\n"
msgstr ""

#: src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "// Use the system timer as a delay provider.\n"
msgstr ""

#: src/exercises/bare-metal/compass.md
msgid ""
"// Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
msgstr ""

#: src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "\"Ready.\""
msgstr ""

#: src/exercises/bare-metal/compass.md
msgid ""
"// Read compass data and log it to the serial port.\n"
"        // TODO\n"
msgstr ""

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr "_Cargo.toml_ (変更は不要なはずです):"

#: src/exercises/bare-metal/compass.md
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr "_Embed.toml_ (変更は不要なはずです):"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr "_.cargo/config.toml_ (変更は不要なはずです):"

#: src/exercises/bare-metal/compass.md
msgid "See the serial output on Linux with:"
msgstr "Linuxではシリアルポート出力を下記のコマンドで確認します:"

#: src/exercises/bare-metal/compass.md
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr "Mac OSではこんな感じになります（デバイス名が少し違うかもしれません）:"

#: src/exercises/bare-metal/compass.md
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "Ctrl+A Ctrl+Q でpicocomを終了します。"

#: src/exercises/bare-metal/solutions-morning.md
msgid "Bare Metal Rust Morning Exercise"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid "([back to exercise](compass.md))"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"Setting up IMU...\""
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Set up display and timer.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Read compass data and log it to the serial port.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"{},{},{}\\t{},{},{}\""
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""

#: src/bare-metal/aps.md
msgid "Application processors"
msgstr "アプリケーションプロセッサ"

#: src/bare-metal/aps.md
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"ここまではArm Cortex-Mシリーズのようなマイクロコントローラについて見てきまし"
"た。今度はCortex-Aを対象として何かを書いてみましょう。簡単化のために、ここで"
"は（本物のハードウェアではなく）QEMUのaarch64 ['virt'](https://qemu-project."
"gitlab.io/qemu/system/arm/virt.html)ボードを利用します。"

#: src/bare-metal/aps.md
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"大まかに言って、マイクロコントローラがMMUや複数の特権レベル（Arm CPUにおける"
"例外レベル、x86におけるリング）を持たないのに対し、アプリケーションプロセッサ"
"はこれらを持っています。"

#: src/bare-metal/aps.md
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU は個々のアーキテクチャに対して様々な異なるマシンやボードモデルをサポート"
"しています。今回使う 'virt' ボードは特定の本物のハードウェアに対応したもので"
"はなく、純粋に仮想マシンとして設計されたものです。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr "Rustのコードを実行できるようになる前にいくつかの初期化が必要です。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"この初期化内容はCの場合と同じになります。プロセッサ状態を初期化して、BSSをゼ"
"ロ埋めして、スタックポインタを設定します。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"BSS（歴史的な理由によりblock starting symbolと呼ばれているもの）はオブジェク"
"トファイルにおいてゼロ初期化される静的な変数を含む部分です。この部分はゼロに"
"よる領域の浪費を避けるためにイメージからは除外されています。コンパイラはロー"
"ダがこの領域をゼロ初期化することを想定しているのです。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"メモリの初期化方法やイメージのロード方法によってはBSSはすでにゼロ埋めされてい"
"ることがありますが、ここでは念の為にゼロ埋めしています。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""
"いかなるメモリのreadやwriteよりも前にMMUとキャッシュを有効化する必要がありま"
"す。それをしないと："

#: src/bare-metal/aps/entry-point.md
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"アラインされていないアクセスがフォールトになります。我々はコンパイラがアライ"
"ンされていないアクセスを生成しないように`+strict-align`オプション を設定する"
"`aarch64-unknown-none` ターゲット向けにRustコードをビルドします。そのためここ"
"では問題にはなりませんが、一般的にはそうとは言えません。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"もしVM上で実行していたとすると、キャッシュコヒーレンシーの問題を起こすことが"
"あります。問題なのはVMがキャッシュを無効化したまま直接メモリにアクセスしてい"
"るのに対し、ホストは同じメモリに対してキャッシュ可能なエイリアスを持ってしま"
"うということです。ホストが仮に明示的にメモリにアクセスしないとしても、投機的"
"なアクセスによりキャッシュフィルが起きることがあります。そうなると、ホストが"
"キャッシュをフラッシュするかVMがキャッシュを有効化したときに、VMかホストのど"
"ちらかによる変更が失われてしまいます。（キャッシュは仮想アドレスやIPAではなく"
"物理アドレスをキーとしてアクセスされます）"

#: src/bare-metal/aps/entry-point.md
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"単純化のために、ハードコードしたページテーブル（`idmap.S`参照）を利用します。"
"このページテーブルは最初の1GiBをデバイス用に、次の1GiBをDRAM用に、次の1GiBを"
"さらなるデバイス用に透過的にマップします。これはQEMUのメモリレイアウトに合致"
"します。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""
"例外ベクタ（`vbar_el1`）も設定します。これに関しては後ほど詳しく見ます。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"今日の午後に扱うすべての例は例外レベル１（EL1）で実行されることを想定していま"
"す。もし、別の例外レベルで実行する必要がある場合には、`entry.S`をそれに合わせ"
"て変更する必要があります。"

#: src/bare-metal/aps/inline-assembly.md
msgid "Inline assembly"
msgstr "インラインアセンブリ"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"時折Rustコードでは書けないことを行うためにアセンブリ言語を使う必要がありま"
"す。例えば、電源を落とすためにファームウェアに対してHVC（ハイパーバイザコー"
"ル）を発行する場合です："

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"// Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"hvc #0\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w0\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w1\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w2\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w3\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w4\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w5\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w6\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w7\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"（もし実際に電源を落とすプログラムを書きたい場合は、これらのすべての機能に対"
"するラッパーを提供している[`smccc`](https://crates.io/crates/smccc)を使うと良"
"いでしょう。）"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI はArmのPower State Coordination Interfaceのことであり、これはシステムや"
"CPU電力状態管理の機能を含む標準的なセットです。これは多くのシステムでEL3"
"ファームウェアとハイパーバイザにより実装されています。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"`0 => _` というシンタックスは、インラインアセンブリを実行する前にレジスタをゼ"
"ロで初期化し、実行後はその値は気にしないということを示しています。`in`ではな"
"く`inout`を使う必要があるのは、この実行でレジスタの値を上書きしてしまう可能性"
"があるからです。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"この `main` 関数は`entry.S`にあるエントリポイントから呼ばれるため、"
"`#[no_mangle]`と`extern \"C\"`を必要とします。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"`_x0`–`_x3` are the values of registers `x0`–`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`–`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`–`_x3`はレジスタ`x0`–`x3`の値であり、慣習的にブートロードがデバイスツ"
"リーなどへのポインタを渡すのに利用されています。（`extern \"C\"`により指定さ"
"れた）aarch64 の関数コール規約ではレジスタ`x0`–`x7`は最初の８個の引数を関数に"
"渡すのに利用されることになっているため、`entry.S` はこれらの値を変更しないよ"
"うにする以外の特別なことをする必要はありません。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"この例を`src/bare-metal/aps/examples`において`make qemu_psci`とすることでQEMU"
"により実行してみましょう。"

#: src/bare-metal/aps/mmio.md
msgid "Volatile memory access for MMIO"
msgstr "MMIOに対するvolatileアクセス"

#: src/bare-metal/aps/mmio.md
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "`pointer::read_volatile`と`pointer::write_volatile`を使います。"

#: src/bare-metal/aps/mmio.md
msgid "Never hold a reference."
msgstr "絶対に参照を保持してはいけません。"

#: src/bare-metal/aps/mmio.md
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!`を用いると、中間的な参照を作らずに構造体のフィールドにアクセスする"
"ことができます。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"Volatileアクセス：MMIO領域に対するreadやwriteは副作用があることがあるので、コ"
"ンパイラやハードウェアが実行順序を変更したり、複製したり、省略したりできない"
"ようにするためのものです。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"通常は、例えばある可変参照に対してライトしリードすると、コンパイラはライトし"
"たのと同じ値がリードで読み出されると想定し、実際にメモリをリードする必要はな"
"いと判断します。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"ハードウェアへのvolatileアクセスを行うための既存のクレートには参照を保持する"
"ものがありますが、これは健全ではありません。参照が存在する間はいつでもコンパ"
"イラがその参照を外して（MMIO領域にアクセスして）しまう可能性があります。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"構造体のポインタからそのフィールドへのポインタを得るには`addr_of!` マクロを"
"使ってください。"

#: src/bare-metal/aps/uart.md
msgid "Let's write a UART driver"
msgstr "UARTドライバを書いてみましょう"

#: src/bare-metal/aps/uart.md
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"QEMUの'virt' マシンには[PL011](https://developer.arm.com/documentation/"
"ddi0183/g)というUARTがあるので、それに対するドライバを書いてみましょう。"

#: src/bare-metal/aps/uart.md
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "/// Writes a single byte to the UART.\n"
msgstr ""

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "// Wait until there is room in the TX buffer.\n"
msgstr ""

#: src/bare-metal/aps/uart.md
msgid ""
"// Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "// Write to the TX buffer.\n"
msgstr ""

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "// Wait until the UART is no longer busy.\n"
msgstr ""

#: src/bare-metal/aps/uart.md
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"`Uart::new`がアンセーフでその他のメソッドがセーフであるということに注目してく"
"ださい。これは、`Uart::new`の安全性要求が満たされている（すなわち特定のUARTに"
"対して一つしかドライバのインスタンスが存在せず、そのアドレス空間に対してエイ"
"リアスが全く存在しない）ことをその呼び出し元が保証する限り、それ以降は必要な"
"事前条件が満たされていると想定することができ`write_byte`を常に安全に呼び出す"
"ことができるようになることが理由です。"

#: src/bare-metal/aps/uart.md
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"逆に（`new`をセーフにして、`write_byte` をアンセーフに）することもできました"
"が、そうすると`write_byte`の全呼び出し箇所において安全性を考慮しなければなら"
"なくなり、利便性が低下します"

#: src/bare-metal/aps/uart.md
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"これはアンセーフなコードに対してセーフなラッパーを構築する場合の共通パターン"
"です：健全性に関する証明に関する労力を多数の場所から少数の場所に集約します。"

#: src/bare-metal/aps/uart/traits.md
msgid "More traits"
msgstr "他のトレイト"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""
"ここでは`Debug`トレイトを導出しました。この他にもいくつかのトレイトを実装する"
"と良いでしょう。"

#: src/bare-metal/aps/uart/traits.md src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""

#: src/bare-metal/aps/uart/traits.md
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"`Write`を実装すると、`Uart` タイプに対して `write!`と`writeln!`マクロが利用で"
"きるようになります。"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"この例を`src/bare-metal/aps/examples`において`make qemu_minimal`とすること"
"で、QEMUにより実行してみましょう。"

#: src/bare-metal/aps/better-uart.md
msgid "A better UART driver"
msgstr "UARTドライバの改善"

#: src/bare-metal/aps/better-uart.md
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"実際のところPL011には[もっと多くのレジスタ](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers)があり、それら"
"にアクセスするためにオフセットを足してポインタを得ることは間違えになりやす"
"く、可読性を低下させます。さらに、いくつかはビットフィールドなので、構造化さ"
"れた方法でアクセスできたほうが良いでしょう。"

#: src/bare-metal/aps/better-uart.md
msgid "Offset"
msgstr "オフセット"

#: src/bare-metal/aps/better-uart.md
msgid "Register name"
msgstr "レジスタ名"

#: src/bare-metal/aps/better-uart.md
msgid "Width"
msgstr "幅"

#: src/bare-metal/aps/better-uart.md
msgid "0x00"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "DR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "12"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x04"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "RSR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x18"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "FR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "9"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x20"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "ILPR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x24"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "IBRD"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "16"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x28"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "FBRD"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x2c"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "LCR_H"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x30"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "CR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x34"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "IFLS"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x38"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "IMSC"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "11"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x3c"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "RIS"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x40"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "MIS"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x44"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "ICR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "0x48"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "DMACR"
msgstr ""

#: src/bare-metal/aps/better-uart.md
msgid "There are also some ID registers which have been omitted for brevity."
msgstr "いくつかのIDレジスタは簡単化のための省略しています。"

#: src/bare-metal/aps/better-uart/bitflags.md
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"[`bitflags`](https://crates.io/crates/bitflags) クレートはビットフラグを扱う"
"のに便利です。"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Flags from the UART flag register.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Clear to send.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Data set ready.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Data carrier detect.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// UART busy transmitting data.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Receive FIFO is empty.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Transmit FIFO is full.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Receive FIFO is full.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Transmit FIFO is empty.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Ring indicator.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"`bitflags!`マクロは`Flags(u16)`のような新しいタイプを生成し、フラグを読み書き"
"するための多くのメソッド実装を一緒に提供します。"

#: src/bare-metal/aps/better-uart/registers.md
msgid "Multiple registers"
msgstr "複数のレジスタ"

#: src/bare-metal/aps/better-uart/registers.md
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""
"構造体を使ってUARTのレジスタのメモリレイアウトを表現することができます。"

#: src/bare-metal/aps/better-uart/registers.md
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) はコンパイラに対して、Cと同じ規則に従って構造体のフィールドを"
"定義されている順番で配置することを指示します。これは構造体のレイアウトを予測"
"可能にするために必要です。なぜならば、Rust標準の表現はコンパイラがフィールド"
"を好きなように並び替えること（他にも色々とありますが）を許しているからです。"

#: src/bare-metal/aps/better-uart/driver.md
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "新しく定義した`Registers` 構造体を我々のドライバで使ってみましょう。"

#: src/bare-metal/aps/better-uart/driver.md
msgid "/// Driver for a PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md src/exercises/bare-metal/rtc.md
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md src/exercises/bare-metal/rtc.md
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md src/exercises/bare-metal/rtc.md
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"`addr_of!`と`addr_of_mut!` を使用して個々のフィールドに対するポインタを取得す"
"ることで、不健全となってしまう中間的な参照を作らずに済んでいることに注目して"
"ください。"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
msgid "Using it"
msgstr "使用例"

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""
"我々のドライバを使って、シリアルコンソールにライトし、そして入力されたバイト"
"をエコーする小さなプログラムを書いてみましょう。"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Base address of the primary PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr ""

#: src/bare-metal/aps/better-uart/using.md
msgid "b'\\r'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md src/async/pitfalls/cancellation.md
msgid "b'\\n'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md
msgid "b'q'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md
msgid "\"Bye!\""
msgstr ""

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"[インラインアセンブリ](../inline-assembly.md) の例と同じように、この`main`関"
"数は`entry.S`におけるエントリポイントから呼び出されます。詳細はそちらの"
"speaker notesを参照してください。"

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"この例を`src/bare-metal/aps/examples`において`make qemu`とすることでQEMUによ"
"り実行してみましょう。"

#: src/bare-metal/aps/logging.md
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"[`log`](https://crates.io/crates/log) クレートが提供するログ用マクロを使える"
"と良いでしょう。これは`Log`トレイトを実装することで可能になります。"

#: src/bare-metal/aps/logging.md src/exercises/bare-metal/rtc.md
msgid "\"[{}] {}\""
msgstr ""

#: src/bare-metal/aps/logging.md src/exercises/bare-metal/rtc.md
msgid "/// Initialises UART logger.\n"
msgstr ""

#: src/bare-metal/aps/logging.md
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"`LOGGER` を`set_logger`を呼び出す前に初期化しているので、log` におけるunwrap"
"はセーフです。"

#: src/bare-metal/aps/logging/using.md
msgid "We need to initialise the logger before we use it."
msgstr "使用前にloggerを初期化する必要があります。"

#: src/bare-metal/aps/logging/using.md src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"{info}\""
msgstr ""

#: src/bare-metal/aps/logging/using.md
msgid "Note that our panic handler can now log details of panics."
msgstr ""
"我々のパニックハンドラがパニックの詳細についてログ出力できるようになったこと"
"に注目してください。"

#: src/bare-metal/aps/logging/using.md
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"この例を`src/bare-metal/aps/examples`において`make qemu_logger`とすることで"
"QEMUにより実行してみましょう。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"AArch64は16エントリを持つ例外ベクターテーブルを定義しており、これらは４つのス"
"テート（現在のELでSP0利用、現在のELでSPx利用、低位のELでAArch64、低位のELで"
"AArch32）における４つのタイプの例外（同期、IRQ、FIQ、SError）に対応します。こ"
"こではRustコードの呼び出し前に揮発レジスタの値をスタックに退避するためにベク"
"ターテーブルをアセンブリ言語で実装しています："

#: src/bare-metal/aps/exceptions.md
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""
"ELは例外レベルです。本日の午後に扱ったすべての例はEL1で実行されています。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"簡単化のために、ここでは現在のEL例外におけるSP0とSPｘの違い、低位のELレベルに"
"おけるAArch32とAArch64の違いを区別していません。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""
"ここではこれらの例外が発生しないはずなので、ただ例外に関するログを出力し、電"
"源を落としています。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"例外ハンドラとメインの実行コンテキストは異なるスレッドのようなものだと考える"
"ことができます。ちょうどスレッド間の共有と同じように、[`Send`と`Sync`](../../"
"concurrency/send-sync.md)により何を共有するかを制御することができます。例え"
"ば、例外ハンドラとプログラムの他のコンテキストでとある値を共有したい場合に、"
"もしそれが `Send`であり`Sync`でなければ、`Mutex` のようなものでラップして、"
"staticに定義しなければなりません。"

#: src/bare-metal/aps/other-projects.md
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr ""

#: src/bare-metal/aps/other-projects.md
msgid "\"coreboot without the C\""
msgstr "\"Cのない（つまり、C言語を使わない）coreboot\""

#: src/bare-metal/aps/other-projects.md
msgid "Supports x86, aarch64 and RISC-V."
msgstr "アーキテクチャはx86、aarch64ならびにRISC-Vをサポート。"

#: src/bare-metal/aps/other-projects.md
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "自身で多くのドライバを抱えずにLinuxBootに依存。"

#: src/bare-metal/aps/other-projects.md
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""

#: src/bare-metal/aps/other-projects.md
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"初期化、UARTドライバ、単純なブートローダ、JTAG、例外レベル、例外ハンドラ、"
"ページテーブル"

#: src/bare-metal/aps/other-projects.md
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"キャッシュメンテナンスとRustの初期化に関してちょっと疑わしいところがあるの"
"で、製品コードで真似するには必ずしも良い例ではありません。"

#: src/bare-metal/aps/other-projects.md
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr ""

#: src/bare-metal/aps/other-projects.md
msgid "Static analysis to determine maximum stack usage."
msgstr "スタックの最大使用量に関する静的解析。"

#: src/bare-metal/aps/other-projects.md
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"RaspberryPi OS チュートリアルはMMUやキャッシュを有効化する前にRustコードを実"
"行しています。これにより、例えばスタックメモリをreadしたりwriteしたりすること"
"になります。しかし："

#: src/bare-metal/aps/other-projects.md
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"MMUとキャッシュを有効化していないと、アラインされていないアクセスはフォールト"
"を引き起こします。そのチュートリアルでは、コンパイラがアラインされていないア"
"クセスを生成しない`+strict-align`オプションをセットする`aarch64-unknown-none`"
"をターゲットとしてビルドしているので大丈夫なはずですが、一般的には大丈夫とは"
"限りません。"

#: src/bare-metal/aps/other-projects.md
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"もしVM上で実行していたとすると、キャッシュコヒーレンシーの問題を起こすことが"
"あります。問題なのはVMがキャッシュを無効化したまま直接メモリにアクセスしてい"
"るのに対し、ホストは同じメモリに対してキャッシュ可能なエイリアスを持ってしま"
"うということです。ホストが仮に明示的にメモリにアクセスしないとしても、投機的"
"なアクセスによりキャッシュフィルが起きることがあり、そうなるとVMかホストのど"
"ちらかによる変更が失われてしまいます。この（ハイパーバイザなしで直接ハード"
"ウェアで実行する）場合には問題にはなりませんが、一般的には良くないパターンで"
"す。"

#: src/bare-metal/useful-crates.md
msgid "Useful crates"
msgstr "便利クレート"

#: src/bare-metal/useful-crates.md
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"ベアメタルプログラミングにおいて共通に発生する問題に対する解を与えるクレート"
"についていくつか紹介します。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"（Fuchsiaの）[`zerocopy`](https://docs.rs/zerocopy/)クレートはバイトシーケン"
"スとその他の型の変換を安全に行うためのトレイトやマクロを提供します。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"これは（volatile read、writeを使用していないため）MMIOには適してませんが、例"
"えばDMAのようなハードウェアと共有するデータ構造あるいは外部インタフェースを通"
"して送信するデータ構造を扱うに場合には有用です。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"`FromBytes`はいかなるバイトパターンも有効な値となる型に対して実装することがで"
"き、信用できないバイトシーケンスからの安全な変換を可能にします。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"`RequestType`はu32型のすべての値を有効なenum値として定義していないので、すべ"
"てのバイトパターンが有効とはならず、これらに対する`FromBytes`の導出はフェール"
"するでしょう。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder`はバイトオーダを気にする数値プリミティブに関する型を提供"
"します。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"この例を`src/bare-metal/useful-crates/zerocopy-example/`において`cargo run`と"
"とすることで実行してみましょう。（Playgroundではこの例が依存するクレートを利"
"用できないため実行できません）"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"[`aarch64-paging`](https://crates.io/crates/aarch64-paging)クレートはAArch64"
"仮想メモリシステムアーキテクチャに則ったページテーブルの生成を可能にします。"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid "// Create a new page table with identity mapping.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"現時点ではEL1しかサポートされていませんが、他の例外レベルのサポートも簡単に追"
"加できるはずです。"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"これはAndroidで[Protected VM Firmware](https://cs.android.com/android/"
"platform/superproject/+/master:packages/modules/Virtualization/pvmfw/)のため"
"に利用されています。"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"この例は本物のハードウェアかQEMUを必要とするので、簡単には実行できません。"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"はサードパーティのクレートで、基本的なバディシステムアローケータを実装してい"
"ます。このクレートは[`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/"
"trait.GlobalAlloc.html) を実装する [`LockedHeap`](https://docs.rs/"
"buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html) "
"により（ [以前](../alloc.md)見たように）標準の`alloc` クレートを利用可能にす"
"るために使えますし、別のアドレス空間をアロケートするためにも使えます。例え"
"ば、PCI BARに対するMMIO領域をアロケートしたい場合には以下のようにできます："

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "PCI BARs always have alignment equal to their size."
msgstr "PCI BARは常にサイズと同じアラインになります。"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"この例を`src/bare-metal/useful-crates/allocator-example/`において `cargo run`"
"とすることで実行してみましょう。（Playgroundではこの例が依存するクレートを利"
"用できないため実行できません）"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"時には`Vec`のようにリサイズできる領域をヒープを使わずに確保したいと思うことが"
"あります。[`tinyvec`](https://crates.io/crates/tinyvec)は静的に確保、またはス"
"タック上に確保した配列またはスライスを割当領域とするベクタを提供します。この"
"実装では、いくつの要素が使われているかが管理され、確保された以上に使おうとす"
"るとパニックします。"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec` は初期化のために要素となるタイプが`Default`を実装することを必要とし"
"ます。"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"Rust Playgroundは`tinyvec`を内包しているので、オンラインでこの例を実行するこ"
"とができます。"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync`が提供する`std::sync::Mutex` とその他の同期プリミティブは`core`ま"
"たは`alloc`では利用できません。となると、例えば異なるCPU間での状態共有のため"
"の、同期や内部可変性はどのように実現したら良いのでしょうか？"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"[`spin`](https://crates.io/crates/spin) クレートはこれらの多くのプリミティブ"
"と等価なスピンロックベースのものを提供します。"

#: src/bare-metal/useful-crates/spin.md
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"割り込みハンドラでロックを取得する場合にはデッドロックを引き起こさないように"
"気をつけてください。"

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"`spin` はチケットロックのミューテックス実装も持っています。これは`std::sync`"
"における`RwLock`, `Barrier`、`Once` と等価であり、またレイジー初期化の観点で"
"は`Lazy`と等価なものです。"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"[`once_cell`](https://crates.io/crates/once_cell) クレートも`spin::once::"
"Once`とは少し異なるアプローチの遅延初期化のための有用な型をいくつか持っていま"
"す。"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"Rust Playgroundは`spin`を内包しているので、この例はオンラインで実行できます。"

#: src/bare-metal/android.md
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"AOSPにおいてベアメタルRustバイナリをビルドするためには、Rustコードをビルドす"
"るための`rust_ffi_static`というSoongルール、リンカスクリプトとそれを使ってバ"
"イナリを生成するための`cc_binary`というルール、さらにELFを実行可能な形式の生"
"バイナリに変換する`raw_binary`というルールが必要です。"

#: src/bare-metal/android/vmbase.md
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"[vmbase](https://android.googlesource.com/platform/packages/modules/"
"Virtualization/+/refs/heads/master/vmbase/)というライブラリは、aarch64上の"
"crosvm下で実行されるVMに対して、エントリポイント、UARTコンソールロギングなど"
"に加えて、リンカスクリプトと有用なデフォルトビルドルールを提供してくれます。"

#: src/bare-metal/android/vmbase.md
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""
"`main!`というマクロはメイン関数を指定するもので、指定された関数は`vmbase`のエ"
"ントリポイントから呼び出されることになります。"

#: src/bare-metal/android/vmbase.md
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"`vmbase`のエントリポイントはコンソールの初期化を行い、メイン関数がリターンし"
"た場合にはPSCI_SYSTEM_OFF を発行しVMをシャットダウンします。"

#: src/exercises/bare-metal/afternoon.md
msgid "We will write a driver for the PL031 real-time clock device."
msgstr ""

#: src/exercises/bare-metal/afternoon.md src/exercises/concurrency/afternoon.md
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "RTC driver"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Base addresses of the GICv3.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// TODO: Create instance of RTC driver and print current time.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// TODO: Wait for 3 seconds.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"sync_exception_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"irq_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"No pending interrupt\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"IRQ {intid:?}\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"fiq_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"serr_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"sync_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"irq_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"fiq_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"serr_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR: main\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR: Flags\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR_END: Flags\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"/// Flags from the UART Receive Status Register / Error Clear Register.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "/// Framing error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "/// Parity error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "/// Break error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "/// Overrun error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR: Registers\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR_END: Registers\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR_END: Uart\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"linux\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"CROSS_COMPILE\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"aarch64-linux-gnu\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"aarch64-none-elf\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"entry.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"exceptions.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"idmap.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "\"empty\""
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "# Copyright 2023 Google LLC"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "$(shell uname -s)"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "aarch64-linux-gnu"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "stdio -display none -kernel $< -s"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "cargo clean"
msgstr ""

#: src/exercises/bare-metal/rtc.md
msgid "Run the code in QEMU with `make qemu`."
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "Bare Metal Rust Afternoon"
msgstr "ベアメタルRust PM"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "([back to exercise](rtc.md))"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "_main.rs_:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Base address of the PL031 RTC.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"RTC: {time}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"Waiting for {}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"matched={}, interrupt_pending={}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"Finished waiting\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "_pl031.rs_:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Data register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Match register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Load register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Control register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Raw Interrupt Status\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Masked Interrupt Status\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Interrupt Clear Register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Reads the current RTC value.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Clears a pending interrupt, if any.\n"
msgstr ""

#: src/concurrency.md
msgid "Welcome to Concurrency in Rust"
msgstr "Rustでの並行性へようこそ"

#: src/concurrency.md
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Rustはミューテックスとチャネルを用いてOSスレッドを扱う並行性を十分にサポート"
"しています。"

#: src/concurrency.md
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Rustの型システムは多くの並行性にまつわるバグをコンパイル時のバグにとどめると"
"いう点で、重要な役割を果たします。これは時に _fearless concurrency_ （「怖く"
"ない並行性」） と呼ばれます。なぜなら、コンパイラに実行時での正しさを保証する"
"ことをまかせてよいためです。"

#: src/concurrency/threads.md
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Rustのスレッドは他の言語のスレッドと似た挙動をします:"

#: src/concurrency/threads.md
msgid "\"Count in thread: {i}!\""
msgstr "\"Count in thread: {i}!\""

#: src/concurrency/threads.md
msgid "\"Main thread: {i}\""
msgstr "\"Main thread: {i}\""

#: src/concurrency/threads.md
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr ""
"スレッドはすべてデーモンスレッドで、メインスレッドはそれらを待ちません。"

#: src/concurrency/threads.md
msgid "Thread panics are independent of each other."
msgstr "スレッドパニックは互いに独立です。"

#: src/concurrency/threads.md
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"パニックはペイロードを保持していることがあり、それは`downcast_ref`で展開可能"
"です。"

#: src/concurrency/threads.md
#, fuzzy
msgid ""
"Notice that the thread is stopped before it reaches 10 --- the main thread "
"is not waiting."
msgstr ""
"スレッドはカウントが10に到達するまでに止められます。メインのスレッドは待機し"
"ません。"

#: src/concurrency/threads.md
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"`let handle = thread::spawn(…)`と後に`handle.join()`を使って、スレッドが完了"
"するのを待ってみてください。"

#: src/concurrency/threads.md
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr ""
"スレッド内でパニックを引き起こしてみて、それがどのように`main`に影響しないか"
"を観察してみてください。"

#: src/concurrency/threads.md
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"`handle.join()`の返り値の`Result`を使って、パニックペイロードへのアクセスを得"
"てみてください。 これは[`Any`](https://doc.rust-lang.org/std/any/index.html)"
"について話すのに良いタイミングです。"

#: src/concurrency/scoped-threads.md
msgid "Normal threads cannot borrow from their environment:"
msgstr "通常のスレッドはそれらの環境から借用することはできません:"

#: src/concurrency/scoped-threads.md
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"しかし、そのために[スコープ付きスレッド](https://doc.rust-lang.org/std/"
"thread/fn.scope.html)を使うことができます:"

#: src/concurrency/scoped-threads.md
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"この理由は、関数`thread::scope`が完了するとき、全てのスレッドはjoinされること"
"が保証されているので、スレッドが借用したデータを返すことができるためです。"

#: src/concurrency/scoped-threads.md
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"通常のRustの借用のルールが適用されます:　一つのスレッドがミュータブルで借用す"
"ること、または任意の数のスレッドからイミュータブルで借用すること。"

#: src/concurrency/channels.md
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Rustのチャネルには二つの部品があります： `Sender<T>` と`Receiver<T>`です。こ"
"の２つの部品はチャネルによって繋がっていますが、見ることができるのはエンドポ"
"イントだけです。"

#: src/concurrency/channels.md
msgid "\"Received: {:?}\""
msgstr "\"Received: {:?}\""

#: src/concurrency/channels.md
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` は Multi-Producer, Single-Consumerの略称です。 `Sender`と`SyncSender`"
"は`Clone`を実装している（よって複数のproducerが作成可能）のですが、`Receiver`"
"についてはそうではありません。"

#: src/concurrency/channels.md
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()`と`recv()`は`Result`を返します。もし`Err`が返された場合、これは、対応"
"する`Sender`か`Receiver`のいずれかがドロップされ、チャンネルが閉じられたこと"
"を意味します。"

#: src/concurrency/channels/unbounded.md
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Unboundedで非同期的なチャネルは`mpsc::channel()`によって得られます："

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"Message {i}\""
msgstr "\"Message {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr "\"{thread_id:?}: sent Message {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"{thread_id:?}: done\""
msgstr "\"{thread_id:?}: done\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"Main: got {msg}\""
msgstr "\"Main: got {msg}\""

#: src/concurrency/channels/bounded.md
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr ""
"Bounded（かつ同期的）なチャネルを用いたとき、`send`は現在のスレッドをブロック"
"することがあります："

#: src/concurrency/channels/bounded.md
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"`send`を呼んだときにチャネルに空きがなければ、現在のスレッドはブロックされま"
"す。もし誰もチャネルから値を読み取らない場合は、このスレッドは無期限にブロッ"
"クされることがあります。"

#: src/concurrency/channels/bounded.md
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"もしもチャネルが閉じられた場合、`send`の呼び出しはエラーとともに中断します。"
"（`send`が`Result`を返すのはこのためです。）受け取り側がドロップされたとき"
"に、チャネルは閉じられます。"

#: src/concurrency/channels/bounded.md
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""
"サイズが０のBoundedチャネルは「ランデブーチャネル」と呼ばれます。別のスレッド"
"が`read`を呼ぶまでは、それぞれのsendは現在のスレッドをブロックします。"

#: src/concurrency/send-sync.md
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"Rustはどのようにスレッド間での値の共有アクセスを禁止するのでしょうか？その答"
"えとなるのが、以下の２つのトレイトです："

#: src/concurrency/send-sync.md
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): スレッド境界"
"をまたいでの型`T`のムーブが安全に行える場合、型`T`は`Send`である。"

#: src/concurrency/send-sync.md
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): スレッド境界"
"をまたいで`&T`のムーブが安全に行える場合、型`T`は`Sync`である。"

#: src/concurrency/send-sync.md
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Send`と`Sync`は[unsafeなトレイト](../unsafe/unsafe-traits.md)です。 あなたが"
"新たに定義する型が`Send`と`Sync`の型のみを含む場合、コンパイラはその新しい型"
"に対して`Send`と`Sync`を自動的に導出します。そうでなくても妥当であるならば"
"`Send`と`Sync`を自分自身で実装することもできます。"

#: src/concurrency/send-sync.md
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"これらのトレイトは、ある型が特定のスレッドセーフの特性を持っていることを示す"
"マーカーと考えることもできます。"

#: src/concurrency/send-sync.md
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"これらは通常のトレイトと同じように、ジェネリック境界の中で利用することができ"
"ます。"

#: src/concurrency/send-sync/send.md
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"型`T`の値を安全に別のスレッドにムーブできる場合、型`T`は[`Send`](https://doc."
"rust-lang.org/std/marker/trait.Send.html)である。"

#: src/concurrency/send-sync/send.md
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"所有権を別のスレットにムーブするということは、_デストラクタ_ がそのスレッドで"
"実行されるということです。つまり、あるスレッドでアロケートされた値を別のス"
"レッドで解放しても良いかというのが判断基準になります。"

#: src/concurrency/send-sync/send.md
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"例を挙げると、SQLiteライブラリへのコネクションは、一つのスレッドからのみアク"
"セスされる必要があります。"

#: src/concurrency/send-sync/sync.md
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"型`T`の値を複数のスレッドから同時にアクセスしても安全な場合、型`T`は [`Sync`]"
"(https://doc.rust-lang.org/std/marker/trait.Sync.html) である。"

#: src/concurrency/send-sync/sync.md
msgid "More precisely, the definition is:"
msgstr "より正確には、以下のような定義です："

#: src/concurrency/send-sync/sync.md
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`&T`が`Send`である場合、かつその場合に限り、`T`は`Sync`である"

#: src/concurrency/send-sync/sync.md
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"これはつまり、「ある型の共有がスレッドセーフであれば、その参照をスレッド間で"
"受け渡すこともスレッドセーフである」ということを手短に表したものです。"

#: src/concurrency/send-sync/sync.md
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"なぜなら、ある型がSyncである場合、データ競合や他の同期の問題などのリスクなし"
"にその型を複数のスレッド間で共有でき、その型を別のスレッドにムーブしても安全"
"だからです。また、型への参照は別のスレッドにムーブしても安全です。それは、そ"
"れが参照するデータは任意のスレッドから安全にアクセスすることができるからで"
"す。"

#: src/concurrency/send-sync/examples.md
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md
msgid "Most types you come across are `Send + Sync`:"
msgstr "見かけるほとんどの型は`Send + Sync`です："

#: src/concurrency/send-sync/examples.md
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`、`f32`、`bool`、`char`、`&str` など"

#: src/concurrency/send-sync/examples.md
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`、`[T; N]`、`&[T]`、`struct { x: T }` など"

#: src/concurrency/send-sync/examples.md
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`、`Option<T>`、`Vec<T>`、`Box<T>` など"

#: src/concurrency/send-sync/examples.md
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr "`Arc<T>`: アトミック参照カウントにより、明示的にスレッドセーフ。"

#: src/concurrency/send-sync/examples.md
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr "`Mutex<T>`: 内部ロックにより明示的にスレッドセーフ。"

#: src/concurrency/send-sync/examples.md
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr "`AtomicBool`, `AtomicU8`, …: 特別なアトミック命令を利用。"

#: src/concurrency/send-sync/examples.md
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"ジェネリクスは、型パラメタが`Send + Sync`であるとき、通常は`Send + Sync`で"
"す。"

#: src/concurrency/send-sync/examples.md
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"これらの型は別のスレッドにムーブすることができますが、このようなムーブはス"
"レッドセーフではありません。通常は内部可変性がその原因です："

#: src/concurrency/send-sync/examples.md
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`Cell<T>`"
msgstr "`Cell<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"このような型はスレッドセーフですが、別のスレッドにムーブすることはできませ"
"ん："

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T>`: プリミティブを作成したスレッド自身により、割り当てを解除され"
"るべきであるようなOSレベルのプリミティブを利用。"

#: src/concurrency/send-sync/examples.md
msgid "`!Send + !Sync`"
msgstr "`!Send + !Sync`"

#: src/concurrency/send-sync/examples.md
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"このような型はスレッドセーフではないため、別のスレッドにムーブすることはでき"
"ません："

#: src/concurrency/send-sync/examples.md
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: それぞれの `Rc<T>` は`RcBox<T>`への参照を持っています。これは、アト"
"ミックでない参照カウントを持っています。"

#: src/concurrency/send-sync/examples.md
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: Rust は、生ポインターは同時実行性に関する特別な考慮事項"
"がある可能性があることを仮定しています。"

#: src/concurrency/shared_state.md
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"Rustは共有データを確実に同期するために型システムを利用します。これは主に2つの"
"型により行われます："

#: src/concurrency/shared_state.md
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T` : スレッド間の共有を扱い、最後の参照がドロップされたと"
"き `T` をデアロケートすることを担当する、"

#: src/concurrency/shared_state.md
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): `T`型の値"
"への相互排他的なアクセスを保証する。"

#: src/concurrency/shared_state/arc.md
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) は読み取り専用"
"の共有アクセスを`Arc::clone`により可能にします："

#: src/concurrency/shared_state/arc.md
msgid "\"{thread_id:?}: {v:?}\""
msgstr "\"{thread_id:?}: {v:?}\""

#: src/concurrency/shared_state/arc.md src/concurrency/shared_state/example.md
msgid "\"v: {v:?}\""
msgstr "\"v: {v:?}\""

#: src/concurrency/shared_state/arc.md
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc` は\"Atomic Reference Counted\"の略で、アトミック操作を利用するという点"
"で、`Rc`がスレッド安全になったバージョンのようなものです。"

#: src/concurrency/shared_state/arc.md
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`Arc<T>` は `Clone` を実装します。このことは`T`が`Clone`を実装するしないに関"
"係ありません。`T`が`Send`と`Sync`の両方を実装している場合で、かつその場合に限"
"り、`Arc<T>` は両者を実装します。"

#: src/concurrency/shared_state/arc.md
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()`にはアトミック操作のコストがかかります。ただ、その後は、`T`の利"
"用に関するコストはかかりません。"

#: src/concurrency/shared_state/arc.md
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"参照サイクルに気をつけてください。`Arc` には参照サイクルを検知するためのガ"
"ベージコレクタはありません。"

#: src/concurrency/shared_state/arc.md
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` が役立ちます。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface (another form of [interior mutability](../../borrowing/interior-"
"mutability)):"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) は相互排他"
"を保証し、 _かつ_ 読み取り専用のインターフェースの裏側で `T` へのミュータブル"
"なアクセスを可能にします："

#: src/concurrency/shared_state/mutex.md
msgid "\"v: {:?}\""
msgstr "\"v: {:?}\""

#: src/concurrency/shared_state/mutex.md
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"[`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-lang.org/std/sync/"
"struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) のブランケット実装があることに"
"注目してください。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"Rustにおける`Mutex`とは、保護されるデータである、たった一つの要素から構成され"
"たコレクションのようなものです。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"保護されたデータにアクセスする前に、ミューテックスを確保し忘れることはありま"
"せん。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"`&Mutex<T>` からロックを取得することで、`&mut T`を得ることができます。この"
"`MutexGuard`は`&mut T`が保持されているロックよりも長く存続しないことを保証し"
"ます。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`T`が`Send`を実装している場合で、かつその場合に限り、`Mutex<T>` は`Send`と"
"`Sync`の両方を実装します。"

#: src/concurrency/shared_state/mutex.md
msgid "A read-write lock counterpart: `RwLock`."
msgstr "読み書きのロックの場合に対応するものがあります： `RwLock`。"

#: src/concurrency/shared_state/mutex.md
msgid "Why does `lock()` return a `Result`?"
msgstr "なぜ`lock()`は`Result`を返すのでしょう？"

#: src/concurrency/shared_state/mutex.md
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"Mutex`を保持したスレッドがパニックを起こした場合、保護すべきデータが整合性の"
"欠けた状態にある可能性を伝えるため、`Mutex`は「ポイゾンされた」"
"（\"poisoned\"）状態になります。ポイゾンされたMutexに対して `lock()` をコール"
"すると、[`PoisonError`](https://doc.rust-lang.org/std/sync/struct."
"PoisonError.html)とともに失敗します。`into_inner()` を用いることで、そのエ"
"ラーにおいて、とりあえずデータを回復することはできます。"

#: src/concurrency/shared_state/example.md
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "`Arc` と `Mutex` の動作を見てみましょう："

#: src/concurrency/shared_state/example.md
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr "// use std::sync::{Arc, Mutex};\n"

#: src/concurrency/shared_state/example.md
msgid "Possible solution:"
msgstr "考えられる対処法："

#: src/concurrency/shared_state/example.md
msgid "Notable parts:"
msgstr "注目するとよい箇所："

#: src/concurrency/shared_state/example.md
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v`は `Arc` と `Mutex`の両方でラップされています。なぜなら、それらの関心は互"
"いに独立なものであるからです。"

#: src/concurrency/shared_state/example.md
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"`Mutex`を`Arc`でラップすることは、スレッド間でミュータブルな状態を共有するた"
"めによく見られるパターンです。"

#: src/concurrency/shared_state/example.md
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>`は別のスレッドにムーブされる前に、`v2`としてクローンされる必要があ"
"ります。`move` がラムダ式に追加されたことに注意してください。"

#: src/concurrency/shared_state/example.md
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"ブロックは`LockGuard`のスコープを可能な限り狭めるために導入されています。"

#: src/exercises/concurrency/morning.md
msgid "Let us practice our new concurrency skills with"
msgstr "次の演習を行い、並行性に関する新しいスキルを獲得しましょう。"

#: src/exercises/concurrency/morning.md
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "食事する哲学者：並行性に関する古典的な問題。"

#: src/exercises/concurrency/morning.md
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"マルチスレッド リンク チェッカー: Cargo を使用して依存関係をダウンロードし、"
"リンクを同時にチェックする大規模なプロジェクト。"

#: src/exercises/concurrency/dining-philosophers.md
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "食事する哲学者の問題は、並行性に関する古典的な問題です。"

#: src/exercises/concurrency/dining-philosophers.md
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"5 人の哲学者が同じテーブルで食事をしています。それぞれの哲学者がテーブルの定"
"位置に座り、皿の間にはフォークが 1 本置かれています。提供される料理はスパゲッ"
"ティで、2 本のフォークで食べる必要があります。哲学者は思索と食事を交互に繰り"
"返すことしかできません。さらに、哲学者は左右両方のフォークを持っている場合に"
"のみ、スパゲッティを食べることができます。したがって、2 つのフォークは、両隣"
"の哲学者が食べるのではなく考えている場合にのみ使用できます。それぞれの哲学者"
"は、食べ終わった後、両方のフォークを置きます。"

#: src/exercises/concurrency/dining-philosophers.md
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"この演習では、ローカルの [Cargo インストール](../../cargo/running-locally.md)"
"が必要です。以下のコードを `src/main.rs` というファイルにコピーし、空欄を埋め"
"て、`cargo run` がデッドロックしないことを確認します。"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Eureka! {} has a new idea!\""
msgstr "\"Eureka! {} has a new idea!\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Pick up forks...\n"
msgstr "// Pick up forks...\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"{} is eating...\""
msgstr "\"{} is eating...\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Socrates\""
msgstr "\"Socrates\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Hypatia\""
msgstr "\"Hypatia\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Plato\""
msgstr "\"Plato\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Aristotle\""
msgstr "\"Aristotle\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Pythagoras\""
msgstr "\"Pythagoras\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Create forks\n"
msgstr "// フォークを作成する\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Create philosophers\n"
msgstr "// 哲学者を作成する\n"

#: src/exercises/concurrency/dining-philosophers.md
msgid "// Make each of them think and eat 100 times\n"
msgstr "// それぞれの哲学者が思索と食事を 100 回行うようにする\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Output their thoughts\n"
msgstr "// 哲学者の思索を出力する\n"

#: src/exercises/concurrency/dining-philosophers.md
msgid "You can use the following `Cargo.toml`:"
msgstr "次の `Cargo.toml` を使用できます。"

#: src/exercises/concurrency/dining-philosophers.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"新たに身に付けた知識を活かして、マルチスレッド リンク チェッカーを作成しま"
"しょう。まず、ウェブページ上のリンクが有効かどうかを確認する必要があります。"
"同じドメインの他のページを再帰的にチェックし、すべてのページの検証が完了する"
"までこの処理を繰り返します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"そのためには、[`reqwest`](https://docs.rs/reqwest/) などの HTTP クライアント"
"が必要です。次のコマンドで新しい Cargo プロジェクトを作成し、依存関係として "
"`reqwest` を追加します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"`cargo add` が `error: no such subcommand` で失敗する場合は、`Cargo.toml` "
"ファイルを手動で編集してください。下記の依存関係を追加します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr ""
"また、リンクを見つける方法も必要です。これには [`scraper`](https://docs.rs/"
"scraper/) を使用します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"最後に、エラーを処理する方法が必要になります。これには [`thiserror`](https://"
"docs.rs/thiserror/) を使用します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"`cargo add` の呼び出しにより、`Cargo.toml` ファイルは次のように更新されます。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/concurrency/link-checker.md
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"これで、スタートページをダウンロードできるようになりました。`https://www."
"google.org/` のような小規模なサイトで試してみましょう。"

#: src/exercises/concurrency/link-checker.md
msgid "Your `src/main.rs` file should look something like this:"
msgstr "`src/main.rs` ファイルは次のようになります。"

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"request error: {0}\""
msgstr "\"request error: {0}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"bad http response: {0}\""
msgstr "\"bad http response: {0}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"Checking {:#}\""
msgstr "\"Checking {:#}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"href\""
msgstr "\"href\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"https://www.google.org\""
msgstr "\"https://www.google.org\""

#: src/exercises/concurrency/link-checker.md
msgid "\"Links: {links:#?}\""
msgstr "\"Links: {links:#?}\""

#: src/exercises/concurrency/link-checker.md
msgid "\"Could not extract links: {err:#}\""
msgstr "\"Could not extract links: {err:#}\""

#: src/exercises/concurrency/link-checker.md
msgid "Run the code in `src/main.rs` with"
msgstr "`src/main.rs` 内のコードを、次のコマンドで実行します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"スレッドを使用してリンクを同時にチェックします。つまり、チェックする URL を"
"チャンネルに送信し、いくつかのスレッドで同時に URL を確認します。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"これを拡張して、`www.google.org` ドメインのすべてのページからリンクを再帰的に"
"抽出します。サイトがブロックされないように、ページ数の上限を 100 程度に設定し"
"ます。"

#: src/exercises/concurrency/solutions-morning.md
msgid "Concurrency Morning Exercise"
msgstr "並行性に関する午前のエクササイズ"

#: src/exercises/concurrency/solutions-morning.md
msgid "([back to exercise](dining-philosophers.md))"
msgstr "（[演習に戻る](dining-philosophers.md)）"

#: src/exercises/concurrency/solutions-morning.md
msgid "\"{} is trying to eat\""
msgstr "\"{} is trying to eat\""

#: src/exercises/concurrency/solutions-morning.md
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""
"// デッドロックを避けるために、どこかで対称性を\n"
"        // 崩す必要があります。下記のコードでは、\n"
"        // 領域を開放することなく2つのフォークを交換します。\n"

#: src/exercises/concurrency/solutions-morning.md
msgid "\"{thought}\""
msgstr "\"{thought}\""

#: src/exercises/concurrency/solutions-morning.md
#, fuzzy
msgid "Link Checker"
msgstr "マルチスレッド・リンクチェッカー"

#: src/exercises/concurrency/solutions-morning.md
msgid "([back to exercise](link-checker.md))"
msgstr "（[演習に戻る](link-checker.md)）"

#: src/exercises/concurrency/solutions-morning.md
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr "/// 指定されたページ内のリンクを抽出するかどうかを決定します。\n"

#: src/exercises/concurrency/solutions-morning.md
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""
"/// 指定されたページを訪問済みとしてマークし、すでに訪問済みであれば\n"
"    /// false を返します。\n"

#: src/exercises/concurrency/solutions-morning.md
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr "// 送信者がドロップされました。今後コマンドは受信されません。\n"

#: src/exercises/concurrency/solutions-morning.md
msgid "\"Got crawling error: {:#}\""
msgstr "\"Got crawling error: {:#}\""

#: src/exercises/concurrency/solutions-morning.md
msgid "\"Bad URLs: {:#?}\""
msgstr "\"Bad URLs: {:#?}\""

#: src/async.md
msgid "Async Rust"
msgstr "Asyncの基礎"

#: src/async.md
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"「Async」は複数のタスクが並行処理される並行性モデルです。それぞれのタスクはブ"
"ロックされるまで実行され、そして次に進むことのできる他のタスクに切り替えるこ"
"とにより実現されます。このモデルは限られた数のスレッド上でより多くのタスクを"
"実行することを可能にします。なぜなら、タスクごとのオーバーヘッドは通常はとて"
"も低く、効率的に実行可能なI/Oを特定するために必要なプリミティブをOSが提供して"
"くれるからです。"

#: src/async.md
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Rustの非同期的な操作は「future」に基づいていて、これは将来に完了するかもしれ"
"ない作業を表しています。Futureは、タスクが完了したことを知らせるシグナルが得"
"られるまでポーリングされます。"

#: src/async.md
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"Futureは非同期的なランタイムによりポーリングされます。ランタイムにはいくつか"
"の選択肢があります。"

#: src/async.md
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"Pythonには似たようなモデルが`asyncio`として搭載されています。しかし、ここでの"
"`Future`型はコールバックに基づくものであって、ポーリングによるものではありま"
"せん。Pythonの非同期プログラムは「ループ」を必要とし、Rustのランタイムに似て"
"います。"

#: src/async.md
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"JavaScriptの`Promise`は似ているものの、これもまたもやコールバックに基づきま"
"す。 この言語のランタイムはイベントループにより実装されているため、多くの"
"Promise解決の詳細は隠されています。"

#: src/async/async-await.md
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"おおまかには、Rustの非同期コードはほとんど「通常の」逐次的なコードのように見"
"えます:"

#: src/async/async-await.md
msgid "\"Count is: {i}!\""
msgstr "\"Count is: {i}!\""

#: src/async/async-await.md
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"これは構文を示すための単純化された例であることに注意してください。長く実行さ"
"れうる操作や本物の並行処理はここには含まれません。"

#: src/async/async-await.md
msgid "What is the return type of an async call?"
msgstr "非同期の呼び出しの返り値の型は？"

#: src/async/async-await.md
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"型を知るために`main`で`let future: () = async_main(10);`を使ってみてくださ"
"い。"

#: src/async/async-await.md
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr ""
"「async」キーワードは糖衣構文です。コンパイラは返り値をfutureに置き換えます。"

#: src/async/async-await.md
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"コンパイラに対して、返されたfutureの値をその後どう扱うべきかという、追加の指"
"示を含めない限り、`main`をasyncにすることはできません。"

#: src/async/async-await.md
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"非同期のコードを実行するためには、エグゼキュータが必要です。`block_on`は、与"
"えられたfutureが最後まで実行されるまで、現在のスレッドをブロックします。"

#: src/async/async-await.md
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await`は非同期的に他の操作の完了を待ちます。`block_on`とは異なり、`.await`"
"は現在のスレッドをブロックしません。"

#: src/async/async-await.md
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr ""
"`.await`はasync関数(またはasync ブロック)の中でのみ利用できます。(async関数・"
"ブロックについては後ほど紹介します。)"

#: src/async/futures.md
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)はトレイト"
"であり、まだ完了してないかもしれない操作を表現するオブジェクトにより実装され"
"ます。Futureはポーリングされることがあり、`poll`は[`Poll`](https://doc.rust-"
"lang.org/std/task/enum.Poll.html)を返します。"

#: src/async/futures.md
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"非同期の関数は`impl Future`を返します。自分で定義した型に対して`Future`を実装"
"することも（あまりないことですが）可能です。例えば、`tokio::spawn`から返され"
"る`JoinHandle`は`Future`を実装することにより、joinすることを可能にしていま"
"す。"

#: src/async/futures.md
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"Futureに適用される`.await`キーワードは、そのFutureの準備ができるまで、現在の"
"非同期の関数の一時停止を起こし、そしてその出力を評価します。"

#: src/async/futures.md
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"`Future`と`Poll`の型はまさに示されたように実装されます; ドキュメントの具体的"
"な実装を見るにはリンクをクリックしてください。"

#: src/async/futures.md
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"`Pin`と`Context`については詳しくは扱いません。なぜなら、新しく非同期のプリミ"
"ティブを作るよりも、非同期のコードを書くことに我々は重点を置くつもりだからで"
"す。簡潔には以下で説明されます："

#: src/async/futures.md
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context`は、特定のイベントが発生した時に、Futureが自分自身を再びポーリングさ"
"れるようにスケジュールすることを可能にします。"

#: src/async/futures.md
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"`Pin`はfutureへのポインタが有効であり続けるために、Futureがメモリの中で移動さ"
"れないことを確実にします。これは、参照が`.await`の後に有効であり続けるために"
"必要です。"

#: src/async/runtimes.md
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"\\_runtime_は非同期な演算（_reactor_）のサポートを提供し、また、futureを実行"
"すること（_executor_）を担当しています。Rustには「ビルトイン」のランタイムは"
"ありませんが、いくつかのランタイムの選択肢があります: "

#: src/async/runtimes.md
#, fuzzy
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/) - パフォーマンスが高い。HTTP向けの[Hyper](https://"
"hyper.rs/)やgRPC向けの[Tonic](https://github.com/hyperium/tonic)のような発達"
"したエコシステムも持っている"

#: src/async/runtimes.md
#, fuzzy
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/) - 「async」のための「std」であることを目指した"
"もの。また、`async::task`に基本的なランタイムを含む。"

#: src/async/runtimes.md
#, fuzzy
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/) - シンプルで軽量"

#: src/async/runtimes.md
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"いくつかのより巨大なアプリケーションは、独自のランタイムを備えています。例え"
"ば[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/"
"lib/fuchsia-async/src/lib.rs)はそのようなものをすでに備えています。"

#: src/async/runtimes.md
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"上で挙げられたランタイムのうち、TokioのみがRustプレイグラウンドでサポートされ"
"ています。このプレイグラウンドではいかなる入出力操作も許可されていないため、"
"大抵の興味深い非同期のあれこれは、プレイグラウンドで実行することはできませ"
"ん。"

#: src/async/runtimes.md
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Futureは、ポーリングを行うエグゼキュータの存在なしには何も行わない（入出力操"
"作さえ始めない）という点で「怠惰」です。例えば、これは、エグゼキュータがなく"
"とも最後まで実行されるJavaScriptのPromiseとは異なります。"

#: src/async/runtimes/tokio.md
#, fuzzy
msgid "Tokio provides:"
msgstr "Tokioは以下を提供します: "

#: src/async/runtimes/tokio.md
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr "非同期のコードを実行するためのマルチスレッドのランタイム。"

#: src/async/runtimes/tokio.md
msgid "An asynchronous version of the standard library."
msgstr "標準ライブラリの非同期バージョン。"

#: src/async/runtimes/tokio.md
msgid "A large ecosystem of libraries."
msgstr "大きなライブラリのエコシステム。"

#: src/async/runtimes/tokio.md
msgid "\"Count in task: {i}!\""
msgstr "\"Count in task: {i}!\""

#: src/async/runtimes/tokio.md
msgid "\"Main task: {i}\""
msgstr "\"Main task: {i}\""

#: src/async/runtimes/tokio.md
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr "`tokio::main`のマクロにより、`main`の非同期処理を作ることができます。"

#: src/async/runtimes/tokio.md
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "`spawn`関数は新しい並行の「タスク」を作成します。"

#: src/async/runtimes/tokio.md
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"注意：`spawn`は`Future`を引数に取るため、`count_to`に対して`.await`を呼ぶこと"
"はありません。"

#: src/async/runtimes/tokio.md
msgid "**Further exploration:**"
msgstr "**さらなる探求:**"

#: src/async/runtimes/tokio.md
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"どうして`count_to`は（通常は）10に辿り着かないのでしょうか？これは非同期処理"
"のキャンセルの例です。 `tokio::spawn`は完了まで待機するためのハンドラを返しま"
"す。"

#: src/async/runtimes/tokio.md
msgid "Try `count_to(10).await` instead of spawning."
msgstr ""
"プロセスを新しく作る代わりに、`count_to(10).await`を試してみてください。"

#: src/async/runtimes/tokio.md
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "`tokio::spawn`から返されたタスクを待機してみてください。"

#: src/async/tasks.md
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust には、軽量のスレッド形式の一種であるタスクシステムがあります。"

#: src/async/tasks.md
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"タスクには、単一のトップレベルのfutureがあり、これはエグゼキュータが先に進む"
"ためにポーリングする対象となります。そのfutureには一つまたは複数のfutureがネ"
"ストされていることもあり、トップレベルのfutureの`poll`メソッドがポーリングす"
"ることになり、大まかにはコールスタックに対応すると言えます。タスクにおける並"
"行処理は、例えば競合タイマーや入出力操作など、複数の子のfutureをポーリングす"
"ることにより可能になります。"

#: src/async/tasks.md
msgid "\"127.0.0.1:0\""
msgstr "\"127.0.0.1:0\""

#: src/async/tasks.md
msgid "\"listening on port {}\""
msgstr "\"listening on port {}\""

#: src/async/tasks.md
msgid "\"connection from {addr:?}\""
msgstr "\"connection from {addr:?}\""

#: src/async/tasks.md
msgid "b\"Who are you?\\n\""
msgstr "b\"Who are you?\\n\""

#: src/async/tasks.md
msgid "\"socket error\""
msgstr "\"socket error\""

#: src/async/tasks.md
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr "\"Thanks for dialing in, {name}!\\n\""

#: src/async/tasks.md src/async/control-flow/join.md
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"この例を準備した`src/main.rs`にコピーして、そこから実行してみましょう。"

#: src/async/tasks.md
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""
"[nc](https://www.unix.com/man-page/linux/1/nc/) や [telnet](https://www.unix."
"com/man-page/linux/1/telnet/) などの TCP 接続ツールを使用して接続してみてくだ"
"さい。"

#: src/async/tasks.md
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"例のサーバーがどのような状態の時に、いくつかのクライアントと接続された状態に"
"あるのかを、可視化するように受講者に指示してください。どんなタスクが存在して"
"いますか？それらのfutureは何ですか？"

#: src/async/tasks.md
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"私たちが`async`ブロックを見かけるのは初めてですね。これはクロージャと似ていま"
"すが、何も引数は取りません。この返り値はFutureであり、`async fn`と似ていま"
"す。"

#: src/async/tasks.md
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"mainのasyncブロックを関数にリファクタして、`?`を使ったエラーハンドリングを改"
"善してみましょう。"

#: src/async/channels.md
#, fuzzy
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"いくつかのクレートは`async`/`await`をサポートしています。例えば、`tokio`チャ"
"ネルは:"

#: src/async/channels.md
msgid "\"Received {count} pings so far.\""
msgstr "\"Received {count} pings so far.\""

#: src/async/channels.md
msgid "\"ping_handler complete\""
msgstr "\"ping_handler complete\""

#: src/async/channels.md
msgid "\"Failed to send ping.\""
msgstr "\"Failed to send ping.\""

#: src/async/channels.md
msgid "\"Sent {} pings so far.\""
msgstr "\"Sent {} pings so far.\""

#: src/async/channels.md
msgid "\"Something went wrong in ping handler task.\""
msgstr "\"Something went wrong in ping handler task.\""

#: src/async/channels.md
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""
"チャネルサイズを `3`に変えてみて、これがどのように処理に影響するか確認してみ"
"ましょう。"

#: src/async/channels.md
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"一般的に、このインターフェースは、[朝の講座](concurrency/channels.md)で見られ"
"たような`sync`チャネルに似ています。"

#: src/async/channels.md
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr ""
"`std::mem::drop`の呼び出しを除いてみましょう。何か起こるでしょうか？それはな"
"ぜでしょうか？"

#: src/async/channels.md
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"[Flume](https://docs.rs/flume/latest/flume/)クレートには`sync`と`async`や"
"`send`と`recv`の両方を実装するチャネルがあります。 これは入出力と重いCPUの処"
"理のタスクの両方を含む、複雑なアプリケーションで便利です。"

#: src/async/channels.md
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"`async`チャネルを扱うことを好ましくするのは、チャネルと繋げるためにや、複雑な"
"コントロールフローを作るために、チャネルを他の`future`と繋げられることです。"

#: src/async/control-flow.md
msgid "Futures Control Flow"
msgstr "Futureの制御フロー"

#: src/async/control-flow.md
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""
"並行計算フローグラフを生成するために、futureを組み合わせることができます。す"
"でに独立したスレッドとして機能するタスクを見てきました。"

#: src/async/control-flow.md
msgid "[Join](control-flow/join.md)"
msgstr "[結合](control-flow/join.md)"

#: src/async/control-flow.md
msgid "[Select](control-flow/select.md)"
msgstr "[選択](control-flow/select.md)"

#: src/async/control-flow/join.md
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"Joinという操作では、futureの集合の準備が整うまで待機し、その後に結果をまとめ"
"て返します。これはJavaScriptにおける `Promise.all` やPythonにおける`asyncio."
"gather`に似ています。"

#: src/async/control-flow/join.md
msgid "\"https://google.com\""
msgstr "\"https://google.com\""

#: src/async/control-flow/join.md
msgid "\"https://httpbin.org/ip\""
msgstr "\"https://httpbin.org/ip\""

#: src/async/control-flow/join.md
msgid "\"https://play.rust-lang.org/\""
msgstr "\"https://play.rust-lang.org/\""

#: src/async/control-flow/join.md
msgid "\"BAD_URL\""
msgstr "\"BAD_URL\""

#: src/async/control-flow/join.md
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"複数の互いに素な型のfutureに対しては、`std::future::join!`を利用できます。し"
"かし、いくつのfutureがコンパイル時に存在しているのかを把握しておく必要があり"
"ます。これは現在`futures`クレートにありますが、近いうちに`std::future`に統合"
"される予定です。"

#: src/async/control-flow/join.md
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"`join`のリスクは、複数のfutureのうちの１つでも解決されないとプログラムがス"
"トールしてしまうということです。 "

#: src/async/control-flow/join.md
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"また、`join_all`と`join!`を組み合わせることもできます。それは、例えばデータ"
"ベースのクエリと一緒にhttpサービスへの全てのリクエストをjoinする場合です。"
"futureに`futures::join!`を用いて、`tokio::time::sleep`を追加してみてくださ"
"い。これは（次のチャプターで説明する、`select!`を必要とする）タイムアウトでは"
"ありませんが、`join!`の良い実演となっています。"

#: src/async/control-flow/select.md
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"Selectという操作では、futureの集合のうち、いずれか１つの準備が整うまで待機"
"し、そのfutureが提供する結果に対して応答します。これはJavaScriptにおける"
"`Promise.race`に似ています。また、Pythonにおける `asyncio.wait(task_set, "
"return_when=asyncio.FIRST_COMPLETED)`と比べることができます。"

#: src/async/control-flow/select.md
#, fuzzy
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When a `future` is ready, "
"its return value is destructured by the `pattern`. The `statement` is then "
"run with the resulting variables. The `statement` result becomes the result "
"of the `select!` macro."
msgstr ""
"Matchステートメントのように、`select!`の本体にはいくつかの 「腕」があり、それ"
"ぞれは`pattern = future => statement`の形をとっています。 `future`の準備が"
"整った時、その`statement`は`future`の結果に紐づく`pattern`の変数を用いて実行"
"されます。"

#: src/async/control-flow/select.md
msgid "\"Felix\""
msgstr "\"Felix\""

#: src/async/control-flow/select.md
msgid "\"Failed to send cat.\""
msgstr "\"Failed to send cat.\""

#: src/async/control-flow/select.md
msgid "\"Rex\""
msgstr "\"Rex\""

#: src/async/control-flow/select.md
msgid "\"Failed to send dog.\""
msgstr "\"Failed to send dog.\""

#: src/async/control-flow/select.md
msgid "\"Failed to receive winner\""
msgstr "\"Failed to receive winner\""

#: src/async/control-flow/select.md
msgid "\"Winner is {winner:?}\""
msgstr "\"Winner is {winner:?}\""

#: src/async/control-flow/select.md
#, fuzzy
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"この例では、猫と犬のレースを扱っています。`first_animal_to_finish_race`は両方"
"のチャネルをリッスンし、先に到着した方を選びます。犬は到着まで50msかかるの"
"で、500msかかる猫に勝ちます。"

#: src/async/control-flow/select.md
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"この例では`oneshot`チャネルを使うこともできます。なぜなら、チャネルは一回きり"
"の`send`を受け取ることになっているからです。"

#: src/async/control-flow/select.md
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"レースに制限時間を追加することによって、違う種類のfutureをselectすることを実"
"演してみてください。"

#: src/async/control-flow/select.md
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"`select!`はマッチしなかったブランチをドロップすることに注意してください。これ"
"は、そうしたブランチのfutureがキャンセルされることにつながります。`select!`を"
"毎回実行する際に新たなfutureが作成されるときに、`select!`を使うのが最も簡単で"
"す。"

#: src/async/control-flow/select.md
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""
"Futureそのものでなく、`&mut future`を渡すという代替案もあります。しかし、これ"
"は問題につながることもあります。このことはPinに関するスライドで詳細に議論しま"
"す。"

#: src/async/pitfalls.md
msgid "Pitfalls of async/await"
msgstr "async / await の注意点"

#: src/async/pitfalls.md
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"async / await は、同時実行非同期プログラミングのための便利で効率的な抽象化を"
"提供します。しかし、Rust の async / await モデルには、注意点や誤用されやすい"
"機能もいくつかあるため、この章ではその点について説明します。"

#: src/async/pitfalls.md
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr "[エグゼキュータのブロック](pitfalls/blocking-executor.md)"

#: src/async/pitfalls.md
msgid "[Pin](pitfalls/pin.md)"
msgstr "[Pin](pitfalls/pin.md)"

#: src/async/pitfalls.md
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr "[Async トレイト](pitfalls/async-traits.md)"

#: src/async/pitfalls.md
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr "[キャンセル](pitfalls/cancellation.md)"

#: src/async/pitfalls/blocking-executor.md
msgid "Blocking the executor"
msgstr "エグゼキュータのブロック"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"ほとんどの非同期ランタイムは、IO タスクの同時実行のみを許可します。つまり、"
"CPU ブロックタスクはエグゼキュータをブロックし、他のタスクの実行を妨げます。"
"簡単な回避策は、可能であれば非同期の同等のメソッドを使用することです。"

#: src/async/pitfalls/blocking-executor.md
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr "\"future {id} slept for {duration_ms}ms, finished after {}ms\""

#: src/async/pitfalls/blocking-executor.md
msgid "\"current_thread\""
msgstr "\"current_thread\""

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"コードを続けて、スリープが同時ではなく連続して発生することを確認します。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"`\"current_thread\"` フレーバーは、すべてのタスクを 1 つのスレッドに配置しま"
"す。これにより、影響はより明確になりますが、バグはまだマルチスレッド フレー"
"バーに存在します。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"`std::thread::sleep` を `tokio::time::sleep` に切り替えて、その結果を待ちま"
"す。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"もう 1 つの修正策は、`tokio::task::spawn_blocking` を使用することです。これ"
"は、実際のスレッドを生成し、エグゼキュータをブロックせずにそのハンドルを "
"Future に変換します。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"タスクは OS スレッドとはみなすべきではありません。これらは 1 対 1 に対応して"
"おらず、ほとんどのエグゼキュータは、単一の OS スレッドで多くのタスクを実行す"
"ることを許可します。これは、FFI を介して他のライブラリとやり取りする場合に特"
"に問題となります。FFI では、そのライブラリはスレッド ローカル ストレージに依"
"存しているか、特定の OS スレッド（CUDA など）にマッピングされている可能性があ"
"るためです。そのような場合は `tokio::task::spawn_blocking` を使用することをお"
"すすめします。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"同期ミューテックスは慎重に使用してください。`.await` でミューテックスを保持す"
"ると、別のタスクがブロックされ、そのタスクが同じスレッドで実行される可能性が"
"あります。"

#: src/async/pitfalls/pin.md
msgid ""
"Async blocks and functions return types implementing the `Future` trait. The "
"type returned is the result of a compiler transformation which turns local "
"variables into data stored inside the future."
msgstr ""
"非同期ブロックと関数は、`Future` トレイトを実装する型を返します。返される型"
"は、ローカル変数を Future の内部に格納されるデータに変換するコンパイラ変換の"
"結果です。"

#: src/async/pitfalls/pin.md
msgid ""
"Some of those variables can hold pointers to other local variables. Because "
"of that, the future should never be moved to a different memory location, as "
"it would invalidate those pointers."
msgstr ""
"これらの変数の一部は、他のローカル変数へのポインタを保持できます。これらのポ"
"インタが無効になるため、Futureを別のメモリ位置に移動しないでください。"

#: src/async/pitfalls/pin.md
msgid ""
"To prevent moving the future type in memory, it can only be polled through a "
"pinned pointer. `Pin` is a wrapper around a reference that disallows all "
"operations that would move the instance it points to into a different memory "
"location."
msgstr ""
"メモリ内の Future 型が移動するのを防ぐには、固定されたポインタのみを介して"
"ポーリングするようにします。`Pin` は参照のラッパーで、参照先のインスタンスを"
"別のメモリ位置に移動するオペレーションをすべて禁止します。"

#: src/async/pitfalls/pin.md
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""
"// 作業アイテム。この場合、指定された時間だけスリープし、\n"
"// `respond_on` チャンネルでメッセージを返します。\n"

#: src/async/pitfalls/pin.md
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr "// キュー上の処理をリッスンして実行するワーカー。\n"

#: src/async/pitfalls/pin.md
msgid "// Pretend to work.\n"
msgstr "// Pretend to work.\n"

#: src/async/pitfalls/pin.md
msgid "\"failed to send response\""
msgstr "\"failed to send response\""

#: src/async/pitfalls/pin.md
msgid "// TODO: report number of iterations every 100ms\n"
msgstr "// TODO: 100 ミリ秒ごとの反復処理の回数をレポート\n"

#: src/async/pitfalls/pin.md
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr "// 処理をリクエストし、処理が完了するまで待機するリクエスト元。\n"

#: src/async/pitfalls/pin.md
msgid "\"failed to send on work queue\""
msgstr "\"failed to send on work queue\""

#: src/async/pitfalls/pin.md
msgid "\"failed waiting for response\""
msgstr "\"failed waiting for response\""

#: src/async/pitfalls/pin.md
msgid "\"work result for iteration {i}: {resp}\""
msgstr "\"work result for iteration {i}: {resp}\""

#: src/async/pitfalls/pin.md
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"これはアクターのパターンの一例です。アクターは通常、ループ内で `select!` を呼"
"び出します。"

#: src/async/pitfalls/pin.md
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""
"これはこれまでのレッスンの一部をまとめたものですので、時間をかけて復習してく"
"ださい。"

#: src/async/pitfalls/pin.md
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"`_ = sleep(Duration::from_millis(100)) => { println!(..) }` を `select!` に追"
"加しただけでは、実行されません。なぜでしょうか？"

#: src/async/pitfalls/pin.md
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"代わりに、`loop` の外側で、その Future を含む `timeout_fut` を追加します。"

#: src/async/pitfalls/pin.md
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"これでもうまくいきません。コンパイルエラーにあるように、`select!` 内の "
"`timeout_fut` に `&mut` を追加して移動を回避してから、`Box::pin` を使用しま"
"す。"

#: src/async/pitfalls/pin.md
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"これはコンパイルされますが、タイムアウトになると、すべての反復処理で `Poll::"
"Ready` になります（融合された Future がこれに役立ちます）。期限が切れるたび"
"に `timeout_fut` をリセットするように更新します。"

#: src/async/pitfalls/pin.md
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box でヒープに割り当てます。場合によっては `std::pin::pin!`（最近安定化された"
"ばかりで、古いコードでは多くの場合に `tokio::pin!` を使用します）も使用できま"
"すが、再割り当てされる Future に使用することは困難です。"

#: src/async/pitfalls/pin.md
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"別の方法としては、`pin` をまったく使用せずに、100 ミリ秒ごとに `oneshot` チャ"
"ネルに送信する別のタスクを生成するという方法もあります。"

#: src/async/pitfalls/pin.md
msgid ""
"Data that contains pointers to itself is called self-referential. Normally, "
"the Rust borrow checker would prevent self-referential data from being "
"moved, as the references cannot outlive the data they point to. However, the "
"code transformation for async blocks and functions is not verified by the "
"borrow checker."
msgstr ""
"それ自体へのポインタを含むデータは、自己参照と呼ばれます。通常、Rust 借用"
"チェッカーは、参照が参照先のデータより長く存続できないため、自己参照データの"
"移動を防ぎます。ただし、非同期ブロックと関数のコード変換は、借用チェッカーに"
"よって検証されません。"

#: src/async/pitfalls/pin.md
msgid ""
"`Pin` is a wrapper around a reference. An object cannot be moved from its "
"place using a pinned pointer. However, it can still be moved through an "
"unpinned pointer."
msgstr ""
"`Pin` は参照のラッパーです。固定されたポインタを使用して、オブジェクトをその"
"場所から移動することはできません。ただし、固定されていないポインタを介して移"
"動することは可能です。"

#: src/async/pitfalls/pin.md
msgid ""
"The `poll` method of the `Future` trait uses `Pin<&mut Self>` instead of "
"`&mut Self` to refer to the instance. That's why it can only be called on a "
"pinned pointer."
msgstr ""
"`Future` トレイトの `poll` メソッドは、`&mut Self` ではなく `Pin<&mut Self>` "
"を使用してインスタンスを参照します。固定されたポインタでのみ呼び出すことがで"
"きるのはこのためです。"

#: src/async/pitfalls/async-traits.md
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"トレイトの非同期メソッドは、Stable チャンネルではまだサポートされていません"
"（[試験運用版の機能はナイトリーに存在するため、中期的には安定するはずです。]"
"(https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly."
"html)）"

#: src/async/pitfalls/async-traits.md
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"クレート [async_trait](https://docs.rs/async-trait/latest/async_trait/) は、"
"マクロによる回避策を提供します。"

#: src/async/pitfalls/async-traits.md
msgid "\"running all sleepers..\""
msgstr "\"running all sleepers..\""

#: src/async/pitfalls/async-traits.md
msgid "\"slept for {}ms\""
msgstr "\"slept for {}ms\""

#: src/async/pitfalls/async-traits.md
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait` は簡単に使用できますが、ヒープ割り当てを使用してこれを実現して"
"います。このヒープ割り当てには、パフォーマンス オーバーヘッドが伴います。"

#: src/async/pitfalls/async-traits.md
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"`async trait` の言語サポートにおける課題は、Rust の中でも難解な部類に入るた"
"め、ここでは詳しく説明する必要はないでしょう。Niko Matsakis が [こちらの投稿]"
"(https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-"
"are-hard/) で詳しく説明していますので、深く掘り下げたい方はご覧ください。"

#: src/async/pitfalls/async-traits.md
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"ランダムな時間スリープする新しいスリーパー構造体を作成し、Vec に追加してみま"
"しょう。"

#: src/async/pitfalls/cancellation.md
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"Future をドロップすると、その Future を再度ポーリングすることはできません。こ"
"れはキャンセルと呼ばれ、どの `await` ポイントでも発生する可能性があります。そ"
"のため、Future がキャンセルされた場合でも、システムが正常に動作するようにして"
"おく必要があります。たとえば、デッドロックやデータの消失があってはなりませ"
"ん。"

#: src/async/pitfalls/cancellation.md
msgid "\"not UTF-8\""
msgstr "\"not UTF-8\""

#: src/async/pitfalls/cancellation.md
msgid "\"hi\\nthere\\n\""
msgstr "\"hi\\nthere\\n\""

#: src/async/pitfalls/cancellation.md
msgid "\"tick!\""
msgstr "\"tick!\""

#: src/async/pitfalls/cancellation.md
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"コンパイラではキャンセル安全性を確保できません。API ドキュメントを読み、"
"`async fn` が保持する状態を考慮する必要があります。"

#: src/async/pitfalls/cancellation.md
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""
"`panic` や `?`とは異なり、キャンセルは（エラー処理ではなく）通常の制御フロー"
"の一部です。"

#: src/async/pitfalls/cancellation.md
msgid "The example loses parts of the string."
msgstr "この例では、文字列の一部が失われています。"

#: src/async/pitfalls/cancellation.md
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""
"`tick()` 分岐が先に終了するたびに、`next()` とその `buf` がドロップされます。"

#: src/async/pitfalls/cancellation.md
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""
"`buf` を構造体の一部にすることで、`LinesReader` にキャンセル安全性を持たせる"
"ことができます。"

#: src/async/pitfalls/cancellation.md
msgid "// prefix buf and bytes with self.\n"
msgstr "// buf と bytes の先頭に self を付加します。\n"

#: src/async/pitfalls/cancellation.md
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) は、ティックが「配信済み」かどうかを追跡しているため、安全"
"にキャンセルできます。"

#: src/async/pitfalls/cancellation.md
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) は、データを返すか、データを読み取らないかのい"
"ずれかであるため、安全にキャンセルできます。"

#: src/async/pitfalls/cancellation.md
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) はこの例と類似しており、安全にキャンセ"
"ルできません。詳細と代替方法については、ドキュメントをご覧ください。"

#: src/exercises/concurrency/afternoon.md
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr "非同期 Rust のスキルを磨くため、ここでも 2 つの演習を行います。"

#: src/exercises/concurrency/afternoon.md
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""
"食事する哲学者: この問題は午前の部ですでに取り上げましたが、今回は非同期 "
"Rust を使用してこれを実装します。"

#: src/exercises/concurrency/afternoon.md
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr ""
"ブロードキャスト チャット アプリ: より高度な非同期 Rust 機能をテストできる大"
"規模なプロジェクトです。"

#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "食事する哲学者"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""
"この問題の詳細については、[食事する哲学者](dining-philosophers.md) をご覧くだ"
"さい。"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"前と同様に、この演習でもローカルの [Cargo インストール](../../cargo/running-"
"locally.md) が必要です。以下のコードを `src/main.rs` というファイルにコピー"
"し、空欄を埋めて、`cargo run` がデッドロックしないことを確認します。"

#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Make them think and eat\n"
msgstr "// 哲学者が思索と食事を行うようにする\n"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"今回は非同期 Rust を使用するため、`tokio` 依存関係が必要になります。次の "
"`Cargo.toml` を使用できます。"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""
"また、今度は `tokio` クレートの `Mutex` モジュールと `mpsc` モジュールを使用"
"する必要があることにも注意してください。"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid "Can you make your implementation single-threaded?"
msgstr "実装をシングルスレッドにできますか？"

#: src/exercises/concurrency/chat-app.md
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"この演習では、新たに身に付けた知識を活かしてブロードキャスト チャット アプリ"
"を実装します。クライアントが接続してメッセージを公開するチャット サーバーがあ"
"ります。クライアントは標準入力からユーザー メッセージを読み取り、サーバーに送"
"信します。チャット サーバーは受信した各メッセージをすべてのクライアントにブ"
"ロードキャストします。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""
"このために、サーバー上の [ブロードキャスト チャンネル](https://docs.rs/tokio/"
"latest/tokio/sync/broadcast/fn.channel.html) を使用し、クライアントとサーバー"
"間の通信には [`tokio_websockets`](https://docs.rs/tokio-websockets/) を使用し"
"ます。"

#: src/exercises/concurrency/chat-app.md
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "新しい Cargo プロジェクトを作成し、次の依存関係を追加します。"

#: src/exercises/concurrency/chat-app.md
msgid "_Cargo.toml_:"
msgstr "_Cargo.toml_:"

#: src/exercises/concurrency/chat-app.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.0.0\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.5.1\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.0.0\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.5.1\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"

#: src/exercises/concurrency/chat-app.md
msgid "The required APIs"
msgstr "必要な API"

#: src/exercises/concurrency/chat-app.md
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""
"`tokio` と [`tokio_websockets`](https://docs.rs/tokio-websockets/) の以下の関"
"数が必要になります。少し時間をかけて API に対する理解を深めてください。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"`WebSocketStream` によって実装された [StreamExt::next()](https://docs.rs/"
"futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next): "
"Websocket Stream からのメッセージを非同期で読み取ります。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"`WebSocketStream` によって実装された [SinkExt::send()](https://docs.rs/"
"futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send): "
"Websocket Stream 上でメッセージを非同期で送信します。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): 標準入力からのユーザー メッセージを非同期で読み取りま"
"す。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): ブロードキャスト チャンネルをサブスクラ"
"イブします。"

#: src/exercises/concurrency/chat-app.md
msgid "Two binaries"
msgstr "2 つのバイナリ"

#: src/exercises/concurrency/chat-app.md
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""
"通常、Cargo プロジェクトに含めることができるのは 1 つのバイナリと 1 つの "
"`src/main.rs` ファイルのみです。このプロジェクトには 2 つのバイナリが必要で"
"す。1 つはクライアント用、もう 1 つはサーバー用です。2 つの独立した Cargo プ"
"ロジェクトを作成することもできますが、ここでは 1 つの Cargo プロジェクトに 2 "
"つのバイナリを入れます。そのためには、クライアントとサーバーのコードを `src/"
"bin` に配置する必要があります（[ドキュメント](https://doc.rust-lang.org/"
"cargo/reference/cargo-targets.html#binaries) をご覧ください）。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""
"次のサーバーとクライアントのコードを、それぞれ`src/bin/server.rs` と `src/"
"bin/client.rs` にコピーします。ここでのタスクは、以下で説明するように、これら"
"のファイルを完成させることです。"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "_src/bin/server.rs_:"
msgstr "_src/bin/server.rs_:"

#: src/exercises/concurrency/chat-app.md
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr "// TODO: ヒントについては、以下のタスクの説明をご覧ください。\n"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"127.0.0.1:2000\""
msgstr "\"127.0.0.1:2000\""

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"listening on port 2000\""
msgstr "\"listening on port 2000\""

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"New connection from {addr:?}\""
msgstr "\"New connection from {addr:?}\""

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr "// 未加工の TCP ストリームを WebSocket にラップします。\n"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "_src/bin/client.rs_:"
msgstr "_src/bin/client.rs_:"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"ws://127.0.0.1:2000\""
msgstr "\"ws://127.0.0.1:2000\""

#: src/exercises/concurrency/chat-app.md
msgid "Running the binaries"
msgstr "バイナリの実行"

#: src/exercises/concurrency/chat-app.md
msgid "Run the server with:"
msgstr "次のコマンドでサーバーを実行します。"

#: src/exercises/concurrency/chat-app.md
msgid "and the client with:"
msgstr "次のコマンドでクライアントを実行します。"

#: src/exercises/concurrency/chat-app.md
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "`src/bin/server.rs` に `handle_connection` 関数を実装します。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"ヒント: 2 つのタスクを連続ループで同時に実行するには、`tokio::select!` を使用"
"します。1 つのタスクは、クライアントからメッセージを受信してブロードキャスト"
"します。もう 1 つのタスクは、サーバーで受信したメッセージをクライアントに送信"
"します。"

#: src/exercises/concurrency/chat-app.md
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "`src/bin/client.rs` のメイン関数を完成させます。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"ヒント: 前の例と同様に、`tokio::select!` を連続ループで使用し、（1）標準入力"
"からユーザー メッセージを読み取ってサーバーに送信するタスクと、（2）サーバー"
"からメッセージを受信してユーザーに表示するタスクを同時に実行します。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""
"省略可: 完了したら、メッセージの送信者以外のすべてのクライアントにメッセージ"
"をブロードキャストするようにコードを変更します。"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "Concurrency Afternoon Exercise"
msgstr "午後の同時実行のエクササイズ"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "（[演習に戻る](dining-philosophers-async.md)）"

#: src/exercises/concurrency/solutions-afternoon.md
msgid ""
"// Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"
msgstr ""
"// 実行を別のタスクに転送できるよう、2 番目のフォークを選択する前に\n"
"        // 遅延を追加します。\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "// The locks are dropped here\n"
msgstr "// ここでロックがドロップされます。\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
msgstr ""
"// デッドロックを避けるために、どこかで対称性を\n"
"            // 崩す必要があります。これにより、いずれのフォークも初期化解除す"
"ることなく、フォークが\n"
"            // スワップされます。\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr ""
"// tx はここでドロップされるので、後で明示的に削除する必要はありません。\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Here is a thought: {thought}\""
msgstr "\"Here is a thought: {thought}\""

#: src/exercises/concurrency/solutions-afternoon.md
msgid "([back to exercise](chat-app.md))"
msgstr "（[演習に戻る](chat-app.md)）"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Welcome to chat! Type a message\""
msgstr "\"Welcome to chat! Type a message\""

#: src/exercises/concurrency/solutions-afternoon.md
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""
"// (1) `ws_stream` からメッセージを受信してブロードキャストするタスクと、\n"
"    // （2）`bcast_rx` でメッセージを受信してクライアントに送信しするタスク"
"を\n"
"    // 同時に実行するための連続ループ。\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"From client {addr:?} {text:?}\""
msgstr "\"From client {addr:?} {text:?}\""

#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr "// メッセージの同時送受信のための継続的なループ。\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"From server: {}\""
msgstr "\"From server: {}\""

#: src/thanks.md
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and "
"that it was useful."
msgstr "Comprehensive Rust 🦀! を受講いただきありがとうございました。"

#: src/thanks.md
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"ここまで多くのことを学んできましたが、このコースは完璧ではないため、間違いを"
"見つけた場合や改善のアイデアがある場合は [GitHub でお知らせください](https://"
"github.com/google/comprehensive-rust/discussions)。皆さんからのフィードバック"
"をお待ちしています。"

#: src/glossary.md
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""
"以下は、Rust の多くの用語を簡単に定義することを目的とした用語集です。翻訳時に"
"用語を英語の原文に関連付けるのにも役立ちます。"

#: src/glossary.md
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""
"割り当て（allocate）:  \n"
"[ヒープ](memory-management/stack-vs-heap.md) での動的メモリ割り当て。"

#: src/glossary.md
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""
"引数（argument）:  \n"
"関数またはメソッドに渡される情報。"

#: src/glossary.md
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""
"ベアメタル Rust（Bare-metal Rust）:  \n"
"低レベルの Rust 開発。多くの場合、オペレーティング システムのないシステムにデ"
"プロイされます。[ベアメタル Rust](bare-metal.md) をご覧ください。"

#: src/glossary.md
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""
"ブロック（block）:  \n"
"[ブロック](control-flow/blocks.md) とスコープをご覧ください。"

#: src/glossary.md
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""
"借用（borrow）:  \n"
"[借用](ownership/borrowing.md) をご覧ください。"

#: src/glossary.md
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""
"借用チェッカー（borrow checker）:  \n"
"Rust コンパイラの一部。すべての借用が有効かどうかをチェックします。"

#: src/glossary.md
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""
"中かっこ（brace）:  \n"
"`{` and `}`。ブロックを区切ります。"

#: src/glossary.md
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""
"ビルド（build）:  \n"
"ソースコードを実行可能なコードまたは使用可能なプログラムに変換するプロセス。"

#: src/glossary.md
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""
"呼び出し（call）:  \n"
"関数またはメソッドを呼び出します。"

#: src/glossary.md
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""
"チャンネル（channel）:  \n"
"[スレッド間](concurrency/channels.md) でメッセージを安全に渡すために使用され"
"ます。"

#: src/glossary.md
msgid ""
"Comprehensive Rust 🦀:  \n"
"The courses here are jointly called Comprehensive Rust 🦀."
msgstr ""
"Comprehensive Rust 🦀:  \n"
"このコースは、まとめて Comprehensive Rust 🦀 と呼びます。"

#: src/glossary.md
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""
"同時実行（concurrency）:  \n"
"複数のタスクまたはプロセスを同時に実行することを指します。"

#: src/glossary.md
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr ""
"Rust での同時実行（Concurrency in Rust）:  \n"
"[Rust での同時実行](concurrency.md) をご覧ください。"

#: src/glossary.md
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""
"定数（constant）:  \n"
"プログラムの実行中に変更されない値。"

#: src/glossary.md
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""
"制御フロー（control flow）:  \n"
"個々のステートメントまたは命令がプログラム内で実行される順序。"

#: src/glossary.md
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""
"クラッシュ（crash）:  \n"
"予期しない制御不能なエラーまたは終了。"

#: src/glossary.md
msgid ""
"enumeration:  \n"
"A data type that holds one of several named constants, possibly with an "
"associated tuple or struct."
msgstr ""
"列挙型（enumeration）:  \n"
"複数の名前付き定数のうちの 1 つを保持するデータ型。関連するタプルまたは構造体"
"を伴う場合があります。"

#: src/glossary.md
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""
"エラー（error）:  \n"
"想定された動作から逸脱した、予期しない条件または結果。"

#: src/glossary.md
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""
"エラー処理（error handling）:  \n"
"プログラムの実行中に発生するエラーを管理し、それに対応するプロセス。"

#: src/glossary.md
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""
"演習（exercise:）:  \n"
"プログラミング スキルの向上とテストを目的としたタスクまたは問題。"

#: src/glossary.md
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""
"関数（function）:  \n"
"特定のタスクを実行する再利用可能なコードブロック。"

#: src/glossary.md
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""
"ガベージ コレクタ（garbage collector）:  \n"
"使用されなくなったオブジェクトが占有していたメモリを自動的に解放するメカニズ"
"ム。"

#: src/glossary.md
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""
"ジェネリクス（generics）:  \n"
"型のプレースホルダを使用してコードを記述し、さまざまなデータ型でコードを再利"
"用できるようにする機能。"

#: src/glossary.md
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""
"不変（immutable）:  \n"
" 作成後に変更できないこと。"

#: src/glossary.md
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""
"統合テスト（integration test）:  \n"
"システムのさまざまな部分やコンポーネント間の相互作用を検証するテストの一種。"

#: src/glossary.md
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""
"キーワード（keyword）:  \n"
"特定の意味を持ち、識別子として使用できない、プログラミング言語の予約語。"

#: src/glossary.md
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""
"ライブラリ（library）:  \n"
"プログラムで使用できるプリコンパイル済みのルーチンまたはコードのコレクショ"
"ン。"

#: src/glossary.md
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""
"マクロ（macro）:  \n"
"Rust マクロは名前に `!` を含めることで認識できます。マクロは、通常の関数では"
"不十分な場合に使用されます。典型的な例が `format!` です。これは可変長引数を取"
"りますが、Rust 関数ではサポートされていません。"

#: src/glossary.md
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""
"`main` 関数（`main` function）:  \n"
"Rust プログラムの実行は `main` 関数で開始されます。"

#: src/glossary.md
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""
"一致（match）:  \n"
"式の値に対するパターン マッチングを可能にする、Rust の制御フロー構造。"

#: src/glossary.md
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""
"メモリリーク（memory leak）:  \n"
"プログラムで不要になったメモリの解放に失敗し、メモリ使用量が徐々に増加する状"
"況。"

#: src/glossary.md
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""
"メソッド（method）:  \n"
"Rust のオブジェクトまたは型に関連付けられた関数。"

#: src/glossary.md
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""
"モジュール（module）:  \n"
"関数、型、トレイトなどの定義を含む名前空間。Rust でコードを整理するために使用"
"されます。"

#: src/glossary.md
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""
"移動（move）:  \n"
"Rust である変数から別の変数に値の所有権を移動すること。"

#: src/glossary.md
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""
"可変（mutable）:  \n"
"宣言後の変数の変更を可能にする Rust のプロパティ。"

#: src/glossary.md
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""
"所有権（ownership）:  \n"
"値に関連付けられたメモリの管理をコードのどの部分が担うかを定義する Rust の概"
"念。"

#: src/glossary.md
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""
"パニック（panic）:  \n"
"プログラムの終了を引き起こす、Rust の回復不能なエラー状態。"

#: src/glossary.md
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""
"パラメータ（parameter）:  \n"
"関数またはメソッドが呼び出されたときに渡される値。"

#: src/glossary.md
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""
"パターン（pattern）:  \n"
"Rust の式と照合できる値、リテラル、構造体の組み合わせ。"

#: src/glossary.md
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""
"ペイロード（payload）:  \n"
"メッセージ、イベント、またはデータ構造体で保持されるデータまたは情報。"

#: src/glossary.md
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""
"プログラム（program）:  \n"
"特定のタスクを実行したり、特定の問題を解決したりするためにコンピュータが実行"
"できる一連の命令。"

#: src/glossary.md
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""
"プログラミング言語（programming language）:  \n"
"コンピュータに命令を伝えるために使用される正式なシステム（Rust など）。"

#: src/glossary.md
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""
"レシーバ（receiver）:  \n"
"メソッドが呼び出されたインスタンスを表す Rust メソッドの最初のパラメータ。"

#: src/glossary.md
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""
"参照カウント（reference counting）:  \n"
"オブジェクトへの参照の数をトラッキングし、カウントがゼロになるとオブジェクト"
"の割り当てを解除するメモリ管理技術。"

#: src/glossary.md
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""
"戻り値（return）:  \n"
"関数から返される値を示すために使用される Rust のキーワード。"

#: src/glossary.md
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""
"Rust:  \n"
"安全性、パフォーマンス、同時実行に重点を置いたシステム プログラミング言語。"

#: src/glossary.md
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 3 of this course."
msgstr ""
"Rust の基礎（Rust Fundamentals）:  \n"
"このコースの 1～3 日目。"

#: src/glossary.md
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""
"Android での Rust（Rust in Android）:  \n"
"[Android での Rust](android.md) をご覧ください。"

#: src/glossary.md
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr ""
"Chromium での Rust（Rust in Chromium）:  \n"
"[Chromium での Rust](chromium.md) をご覧ください。"

#: src/glossary.md
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""
"安全（safe）:  \n"
"Rust の所有権と借用に関するルールに従って、メモリ関連のエラーを防止するコード"
"を指します。"

#: src/glossary.md
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""
"スコープ（scope）:  \n"
"変数が有効かつ使用可能なプログラムの領域。"

#: src/glossary.md
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""
"標準ライブラリ（standard library）:  \n"
"Rust の必須機能を提供するモジュールのコレクション。"

#: src/glossary.md
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""
"静的（static）:  \n"
"静的な変数や `'static` ライフタイムを持つアイテムを定義するために使用される "
"Rust のキーワード。"

#: src/glossary.md
msgid ""
"string:  \n"
"A data type storing textual data. See [`String` vs `str`](basic-syntax/"
"string-slices.html) for more."
msgstr ""
"文字列（string）:  \n"
"テキストデータを格納するデータ型。詳しくは、[`String` と `str`](basic-syntax/"
"string-slices.html) をご覧ください。"

#: src/glossary.md
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""
"構造体（struct）:  \n"
"異なる型の変数を 1 つの名前でグループ化する Rust の複合データ型。"

#: src/glossary.md
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""
"テスト（test）:  \n"
"他の関数の正しさをテストする関数を含む Rust モジュール。"

#: src/glossary.md
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""
"スレッド（thread）:  \n"
"同時実行を可能にする、プログラム内の独立した実行シーケンス。"

#: src/glossary.md
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""
"スレッドセーフ（thread safety）:  \n"
"マルチスレッド環境で正しい動作を保証するプログラムの特性。"

#: src/glossary.md
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""
"トレイト（trait）:  \n"
"未知の型に対して定義されたメソッドのコレクション。Rust でポリモーフィズムを実"
"現する方法を提供します。"

#: src/glossary.md
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""
"トレイト境界（trait bound）:  \n"
"特定のトレイトを実装するために型を要求できる抽象化。"

#: src/glossary.md
msgid ""
"tuple:  \n"
"A composite data type that contains variables of different types. Tuple "
"fields have no names, and are accessed by their ordinal numbers."
msgstr ""
"タプル（tuple）:  \n"
"さまざまな型の変数を含む複合データ型。タプル フィールドには名前がなく、序数で"
"アクセスします。"

#: src/glossary.md
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""
"型（type）:  \n"
"Rust の特定の種類の値に対してどのオペレーションを実行できるかを指定する分類。"

#: src/glossary.md
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""
"型推論（type inference）:  \n"
"変数または式の型を推測する Rust コンパイラの機能。"

#: src/glossary.md
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""
"未定義の動作（undefined behavior）:  \n"
"結果が指定されていない Rust のアクションまたは条件。多くの場合、プログラムの"
"予測不能な動作を引き起こします。"

#: src/glossary.md
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""
"共用体（union）:  \n"
"異なる型の値を一度に 1 つだけ保持できるデータ型。"

#: src/glossary.md
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""
"単体テスト（unit test）:  \n"
"Rust には、小規模な単体テストと大規模な統合テストを実行するための組み込みサ"
"ポートが付属しています。[単体テスト](testing/unit-tests.html) をご覧くださ"
"い。"

#: src/glossary.md
msgid ""
"unit type:  \n"
"Type that holds no data, written as a tuple with no members."
msgstr ""
"ユニット型（unit type）:  \n"
"データを保持しない型。メンバーのないタプルとして記述されます。"

#: src/glossary.md
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe.html)."
msgstr ""
"安全でない（unsafe）:  \n"
"未定義の動作をトリガーできる Rust のサブセット。[安全でない Rust](unsafe."
"html) をご覧ください。"

#: src/glossary.md
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""
"変数（variable）:  \n"
"データを格納するメモリの場所。変数はスコープ内で有効です。"

#: src/other-resources.md
msgid "Other Rust Resources"
msgstr "Rust のその他のリソース"

#: src/other-resources.md
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"Rust コミュニティは、高品質な無料のリソースをオンラインで多数提供しています。"

#: src/other-resources.md
msgid "Official Documentation"
msgstr "正式なドキュメント"

#: src/other-resources.md
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"Rust プロジェクトは多くのリソースをホストしており、これらは Rust 全般に対応し"
"ています。"

#: src/other-resources.md
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): Rust の標準"
"的な書籍で、無料で利用できます。Rust について詳しく説明されているほか、ビルド"
"できるプロジェクトがいくつか含まれています。"

#: src/other-resources.md
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): さまざまな構造"
"を示す一連のサンプルを使用して、Rust の構文を解説しています。小規模な演習がい"
"くつか用意されており、そこでサンプルのコードを拡張するよう求められます。"

#: src/other-resources.md
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): Rust の標準ライブラ"
"リの完全なドキュメントです。"

#: src/other-resources.md
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): Rust の文法とメモ"
"リモデルについて説明している未完成の書籍です。"

#: src/other-resources.md
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Rust の公式サイトでホストされている、より専門的なガイド:"

#: src/other-resources.md
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): 未加工のポインタの操"
"作や、他の言語（FFI）とのやり取りなど、安全でない Rust について説明していま"
"す。"

#: src/other-resources.md
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"Rust Book の執筆後に導入された新しい非同期プログラミング モデルについて説明し"
"ています。"

#: src/other-resources.md
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): オ"
"ペレーティング システムのない組み込みデバイスで Rust を使用する方法を紹介して"
"います。"

#: src/other-resources.md
msgid "Unofficial Learning Material"
msgstr "非公式の学習教材"

#: src/other-resources.md
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "Rust に関するその他のガイドとチュートリアル:"

#: src/other-resources.md
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): 高度な知識を"
"持たない C プログラマーの視点で Rust を解説しています。"

#: src/other-resources.md
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): ファームウェアを C で記述するデベロッパーの観点から Rust を解説"
"しています。"

#: src/other-resources.md
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): 他の"
"言語（C、C++、Java、JavaScript、Python など）と並べて比較しながら、Rust の構"
"文について説明しています。"

#: src/other-resources.md
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): Rust の学習に役立つ "
"100 以上の演習が用意されています。"

#: src/other-resources.md
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): Rust 言語の基本的な部分と高度な部分の両方をカバーした、"
"一連のコンパクトなプレゼンテーションです。WebAssembly、async / await などの他"
"のトピックも扱っています。"

#: src/other-resources.md
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust](https://docs.microsoft.com/ja-jp/shows/beginners-"
"series-to-rust/) および [Take your first steps with Rust](https://docs."
"microsoft. com/en-us/learn/paths/rust-first-steps/): 初心者のデベロッパーを対"
"象とした 2 つの Rust ガイドです。1 つ目は 35 個の動画で構成され、2 つ目は "
"Rust の構文と基本的な構造を説明する 11 のモジュールで構成されています。"

#: src/other-resources.md
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): いくつかの異なるタイプのリスト構造の実装を通じ"
"て、Rust のメモリ管理ルールを深く掘り下げています。"

#: src/other-resources.md
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"Rust に関するその他の書籍については、[Little Book of Rust Books](https://"
"lborb.github.io/book/) をご覧ください。"

#: src/credits.md
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"ここで紹介する教材は、多くの優れた Rust ドキュメントのソースに基づいていま"
"す。役立つリソースの一覧については、[その他のリソース](other-resources.md) の"
"ページをご覧ください。"

#: src/credits.md
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Comprehensive Rust の教材は、Apache 2.0 ライセンスの規約により使用が許諾され"
"ています。詳細については、[`LICENSE`](https://github.com/google/"
"comprehensive-rust/blob/main/LICENSE) をご覧ください。"

#: src/credits.md
msgid "Rust by Example"
msgstr "Rust by Example"

#: src/credits.md
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"一部の例と演習は、[Rust by Example](https://doc.rust-lang.org/rust-by-"
"example/) からコピーして編集したものです。ライセンス規約などの詳細について"
"は、`third_party/rust-by-example/` ディレクトリを参照してください。"

#: src/credits.md
msgid "Rust on Exercism"
msgstr "Rust on Exercism"

#: src/credits.md
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"一部の演習は、[Rust on Exercism](https://exercism.org/tracks/rust) をコピーし"
"て編集したものです。ライセンス規約などの詳細については、`third_party/rust-on-"
"exercism/` ディレクトリを参照してください。"

#: src/credits.md
msgid "CXX"
msgstr "CXX"

#: src/credits.md
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"[C++ との相互運用性](android/interoperability/cpp.md) セクションでは、[CXX]"
"(https://cxx.rs/) の画像を使用しています。ライセンス規約などの詳細について"
"は、`third_party/cxx/` ディレクトリを参照してください。"

#, fuzzy
#~ msgid "With C++)"
#~ msgstr "C++"

#~ msgid "Small Example"
#~ msgstr "プログラムの例"

#, fuzzy
#~ msgid "An Example in C"
#~ msgstr "例"

#~ msgid "Compile Time Guarantees"
#~ msgstr "コンパイル時の保証"

#~ msgid "Runtime Guarantees"
#~ msgstr "実行時の保証"

#~ msgid "Modern Features"
#~ msgstr "現代的な機能"

#~ msgid "String vs str"
#~ msgstr "文字列（String） vs 文字列スライス（str）"

#~ msgid "Rustdoc"
#~ msgstr "Rustdoc"

#~ msgid "Overloading"
#~ msgstr "オーバーロード"

#~ msgid "Arrays and for Loops"
#~ msgstr "配列とforループ"

#~ msgid "if expressions"
#~ msgstr "if式"

#~ msgid "for expressions"
#~ msgstr "for式"

#~ msgid "while expressions"
#~ msgstr "while式"

#~ msgid "break & continue"
#~ msgstr "break & continue"

#~ msgid "loop expressions"
#~ msgstr "loop式"

#~ msgid "Variant Payloads"
#~ msgstr "列挙子のペイロード"

#~ msgid "Enum Sizes"
#~ msgstr "列挙型のサイズ"

#, fuzzy
#~ msgid "Novel Control Flow"
#~ msgstr "制御フロー"

#~ msgid "if let expressions"
#~ msgstr "if let式"

#~ msgid "while let expressions"
#~ msgstr "while let式"

#~ msgid "match expressions"
#~ msgstr "match式"

#~ msgid "Destructuring Structs"
#~ msgstr "構造体編"

#~ msgid "Destructuring Arrays"
#~ msgstr "配列編"

#~ msgid "Match Guards"
#~ msgstr "マッチガード"

#~ msgid "Stack vs Heap"
#~ msgstr "スタック vs ヒープ"

#~ msgid "Stack Memory"
#~ msgstr "スタックメモリ"

#~ msgid "Manual Memory Management"
#~ msgstr "手動でのメモリ管理"

#~ msgid "Scope-Based Memory Management"
#~ msgstr "スコープに基づくメモリ管理"

#~ msgid "Garbage Collection"
#~ msgstr "ガベージコレクション"

#~ msgid "Moved Strings in Rust"
#~ msgstr "文字列のムーブ"

#~ msgid "Double Frees in Modern C++"
#~ msgstr "現代C++の二重解放"

#~ msgid "Moves in Function Calls"
#~ msgstr "関数とムーブ"

#~ msgid "Copying and Cloning"
#~ msgstr "コピーとクローン"

#~ msgid "Shared and Unique Borrows"
#~ msgstr "共有参照と固有参照"

#~ msgid "Field Shorthand Syntax"
#~ msgstr "フィールドの省略"

#~ msgid "Method Receiver"
#~ msgstr "メソッドレシーバ"

#, fuzzy
#~ msgid "Storing Books"
#~ msgstr "文字列（String）"

#~ msgid "Option and Result"
#~ msgstr "OptionとResult"

#~ msgid "Vec"
#~ msgstr "ベクタ（Vec）"

#~ msgid "HashMap"
#~ msgstr "ハッシュマップ（HashMap）"

#~ msgid "Box"
#~ msgstr "ボックス（Box）"

#~ msgid "Rc"
#~ msgstr "Rc"

#~ msgid "Iterators and Ownership"
#~ msgstr "イテレータと所有権"

#~ msgid "Strings and Iterators"
#~ msgstr "文字列とイテレータ"

#~ msgid "Generic Methods"
#~ msgstr "ジェネリックメソッド"

#~ msgid "Monomorphization"
#~ msgstr "単相化"

#~ msgid "Default Methods"
#~ msgstr "デフォルトメソッド"

#~ msgid "impl Trait"
#~ msgstr "impl Trait"

#~ msgid "Important Traits"
#~ msgstr "重要なトレイト"

#~ msgid "From and Into"
#~ msgstr "FromとInto"

#~ msgid "Default"
#~ msgstr "Default"

#~ msgid "Operators: Add, Mul, ..."
#~ msgstr "演算子： Add, Mul, …"

#~ msgid "Closures: Fn, FnMut, FnOnce"
#~ msgstr "クロージャ：Fn, FnMut, FnOnce"

#~ msgid "Points and Polygons"
#~ msgstr "ポイントとポリゴン"

#~ msgid "Catching Stack Unwinding"
#~ msgstr "スタックの巻き戻し"

#~ msgid "Structured Error Handling"
#~ msgstr "構造化されたエラー処理"

#~ msgid "Propagating Errors with ?"
#~ msgstr "？でエラーを伝播する"

#~ msgid "Converting Error Types"
#~ msgstr "エラーの型変換"

#~ msgid "Deriving Error Enums"
#~ msgstr "列挙型エラーの導出"

#~ msgid "Adding Context to Errors"
#~ msgstr "コンテキストをエラーに追加"

#~ msgid "no_std"
#~ msgstr "no_std"

#~ msgid "alloc"
#~ msgstr "alloc"

#~ msgid "embedded-hal"
#~ msgstr "embedded-hal"

#~ msgid "zerocopy"
#~ msgstr "zerocopy"

#~ msgid "aarch64-paging"
#~ msgstr "aarch64-paging"

#~ msgid "buddy_system_allocator"
#~ msgstr "buddy_system_allocator"

#~ msgid "tinyvec"
#~ msgstr "tinyvec"

#~ msgid "spin"
#~ msgstr "spin"

#~ msgid "Send and Sync"
#~ msgstr "SendとSync"

#~ msgid "Send"
#~ msgstr "Send"

#~ msgid "Sync"
#~ msgstr "Sync"

#~ msgid "Arc"
#~ msgstr "Arc"

#~ msgid "Mutex"
#~ msgstr "Mutex"

#~ msgid "async/await"
#~ msgstr "async/await"

#~ msgid "Pin"
#~ msgstr "Pin"

#~ msgid "Day 1 Morning"
#~ msgstr "Day 1 AM"

#~ msgid "Day 1 Afternoon"
#~ msgstr "Day 1 PM"

#~ msgid "Day 2 Morning"
#~ msgstr "Day 2 AM"

#~ msgid "Day 2 Afternoon"
#~ msgstr "Day 2 PM"

#~ msgid "Day 3 Morning"
#~ msgstr "Day 3 AM"

#~ msgid "Day 3 Afternoon"
#~ msgstr "Day 3 PM"

#~ msgid "Bare Metal Rust Morning"
#~ msgstr "ベアメタルRust AM"

#~ msgid "Concurrency Morning"
#~ msgstr "並行性 AM"

#~ msgid "Concurrency Afternoon"
#~ msgstr "並行性 PM"

#, fuzzy
#~ msgid ""
#~ "Day 2: Memory management, ownership, compound data types, and the "
#~ "standard library."
#~ msgstr "Day 2： 複合データ型、パターンマッチング、標準ライブラリ"

#, fuzzy
#~ msgid "Day 3: Generics, traits, error handling, testing, and unsafe Rust."
#~ msgstr "Day 3： トレイトとジェネリクス、エラー処理、テスト、unsafe Rust"

#~ msgid ""
#~ "The idea for the first day is to show _just enough_ of Rust to be able to "
#~ "speak about the famous borrow checker. The way Rust handles memory is a "
#~ "major feature and we should show students this right away."
#~ msgstr ""
#~ "本日の目的は、Rust特有の借用チェッカーについて話ができるように、Rustについ"
#~ "て最低限の情報提供を行う事です。Rustがメモリをどのように扱うかは重要な機能"
#~ "であり、なるべく早く受講生に説明すべき内容です。"

#~ msgid ""
#~ "If you're teaching this in a classroom, this is a good place to go over "
#~ "the schedule. We suggest splitting the day into two parts (following the "
#~ "slides):"
#~ msgstr ""
#~ "この時点でスケジュール確認を行なってください。以下のように1日を２パートに"
#~ "分けて実施する事を推奨しています："

#~ msgid "Morning: 9:00 to 12:00,"
#~ msgstr "AM： 9:00 ~ 12:00"

#~ msgid "Afternoon: 13:00 to 16:00."
#~ msgstr "PM： 13:00 ~ 16:00"

#~ msgid ""
#~ "You can of course adjust this as necessary. Please make sure to include "
#~ "breaks, we recommend a break every hour!"
#~ msgstr ""
#~ "必要に応じて調整してください。また、1時間ごとに休憩を取る事をおすすめしま"
#~ "す！"

#~ msgid "Here is a small example program in Rust:"
#~ msgstr "ここでは、Rustによる小さなサンプルプログラムを紹介します："

#~ msgid "// Program entry point\n"
#~ msgstr "// プログラムのエントリーポイント\n"

#~ msgid "// Macro for printing, like printf\n"
#~ msgstr "// printfのような、出力用マクロ\n"

#~ msgid "// No parenthesis around expression\n"
#~ msgstr "// 式を囲む括弧は不要\n"

#~ msgid ""
#~ "The code implements the Collatz conjecture: it is believed that the loop "
#~ "will always end, but this is not yet proved. Edit the code and play with "
#~ "different inputs."
#~ msgstr ""
#~ "この例はCollatz予想を実装したものです： このループは必ず終了すると言われて"
#~ "いますが、まだ証明はされていません。コードを編集して、異なる入力値で試して"
#~ "みてください。"

#~ msgid ""
#~ "Explain that all variables are statically typed. Try removing `i32` to "
#~ "trigger type inference. Try with `i8` instead and trigger a runtime "
#~ "integer overflow."
#~ msgstr ""
#~ "すべての変数が静的型付けされている事を説明してください。`i32`を削除して型"
#~ "推論を試してください。代わりに`i8`を使用して、実行時に整数オーバーフローを"
#~ "引き起こしてみてください。"

#~ msgid "Change `let mut x` to `let x`, discuss the compiler error."
#~ msgstr ""
#~ "`let mut x`を`let x`に変更し、コンパイルエラーについて説明してください。"

#~ msgid ""
#~ "Show how `print!` gives a compilation error if the arguments don't match "
#~ "the format string."
#~ msgstr ""
#~ "`print!`の引数がフォーマット文字列と一致しない場合、コンパイルエラーが発生"
#~ "する事を実演してください。"

#~ msgid ""
#~ "Show how you need to use `{}` as a placeholder if you want to print an "
#~ "expression which is more complex than just a single variable."
#~ msgstr ""
#~ "単一の変数よりも複雑な式を表示したい場合は、`{}`をプレースホルダとして使用"
#~ "する必要がある事を実演してください。"

#~ msgid ""
#~ "Show the students the standard library, show them how to search for `std::"
#~ "fmt` which has the rules of the formatting mini-language. It's important "
#~ "that the students become familiar with searching in the standard library."
#~ msgstr ""
#~ "受講生に標準ライブラリを紹介し、`std::fmt`の検索方法を説明してください。"
#~ "`std::fmt`には、フォーマット機能のルールや構文が説明されています。受講者が"
#~ "標準ライブラリの検索に慣れておく事は重要です。"

#~ msgid "Compile time memory safety."
#~ msgstr "コンパイル時のメモリ安全性。"

#~ msgid "Lack of undefined runtime behavior."
#~ msgstr "未定義の実行時動作がない。"

#~ msgid "Modern language features."
#~ msgstr "現代的な言語機能。"

#~ msgid "Static memory management at compile time:"
#~ msgstr "コンパイル時の静的メモリの管理："

#~ msgid "No memory leaks (_mostly_, see notes)."
#~ msgstr "メモリリークの心配が（ほとんど）ない (ノートを参照)。"

#~ msgid ""
#~ "It is possible to produce memory leaks in (safe) Rust. Some examples are:"
#~ msgstr ""
#~ "SafeなRustの範囲内でメモリリークを引き起こすことは可能です。例として以下の"
#~ "ような手段があります："

#, fuzzy
#~ msgid ""
#~ "You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
#~ "html#method.leak) to leak a pointer. A use of this could be to get "
#~ "runtime-initialized and runtime-sized static variables"
#~ msgstr ""
#~ "[`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method."
#~ "leak)を使ってポインタをリークさせることができます。この関数は実行時に初期"
#~ "化され、実行時にサイズが決まるstatic変数の取得などに使われます。"

#, fuzzy
#~ msgid ""
#~ "You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn."
#~ "forget.html) to make the compiler \"forget\" about a value (meaning the "
#~ "destructor is never run)."
#~ msgstr ""
#~ "[`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget.html)を"
#~ "使って、コンパイラに値を忘れさせることができます (つまり、デストラクタが実"
#~ "行されない)。"

#, fuzzy
#~ msgid ""
#~ "You can also accidentally create a [reference cycle](https://doc.rust-"
#~ "lang.org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
#~ msgstr ""
#~ "`Rc`や`Arc`を使って\\[循環参照（reference cycle）\\]を誤って作成することが"
#~ "あります。"

#, fuzzy
#~ msgid ""
#~ "In fact, some will consider infinitely populating a collection a memory "
#~ "leak and Rust does not protect from those."
#~ msgstr ""
#~ "コレクションを無限に拡張し続けることをメモリリークと見なす場合があり、Rust"
#~ "にはこれを防ぐ機能はありません。"

#~ msgid ""
#~ "For the purpose of this course, \"No memory leaks\" should be understood "
#~ "as \"Pretty much no _accidental_ memory leaks\"."
#~ msgstr ""
#~ "本講座での「メモリリークが起きない」は「\\_意図しない_メモリリークはほとん"
#~ "ど起きない」と解釈すべきです。"

#~ msgid "No undefined behavior at runtime:"
#~ msgstr "実行時に未定義の動作はありません："

#, fuzzy
#~ msgid ""
#~ "Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
#~ "lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
#~ "flag. If enabled, the program will panic (a controlled crash of the "
#~ "program), otherwise you get wrap-around semantics. By default, you get "
#~ "panics in debug mode (`cargo build`) and wrap-around in release mode "
#~ "(`cargo build --release`)."
#~ msgstr ""
#~ "整数オーバーフローは、コンパイル時のフラグで定義されます。選択肢として、パ"
#~ "ニック（プログラムの制御されたクラッシュ）またはラップアラウンドのセマン"
#~ "ティクスがあります。デフォルトとして、デバッグモード（`cargo build`）では"
#~ "パニックが発生し、リリースモード（`cargo build —release`）ではラップアラウ"
#~ "ンドが行われます。"

#~ msgid ""
#~ "Bounds checking cannot be disabled with a compiler flag. It can also not "
#~ "be disabled directly with the `unsafe` keyword. However, `unsafe` allows "
#~ "you to call functions such as `slice::get_unchecked` which does not do "
#~ "bounds checking."
#~ msgstr ""
#~ "境界チェックは、コンパイル時のフラグで無効にすることはできません。また、"
#~ "`unsafe`のキーワードを使って直接無効にすることもできません。しかし、"
#~ "`unsafe`を使って境界チェックを行わない`slice::get_unchecked`のような関数を"
#~ "呼び出すことができます。"

#, fuzzy
#~ msgid "Rust is built with all the experience gained in the last decades."
#~ msgstr "Rustは過去40年間の経験を基に構築されています。"

#~ msgid "Language Features"
#~ msgstr "言語の特徴"

#~ msgid ""
#~ "Zero-cost abstractions, similar to C++, means that you don't have to "
#~ "'pay' for higher-level programming constructs with memory or CPU. For "
#~ "example, writing a loop using `for` should result in roughly the same low "
#~ "level instructions as using the `.iter().fold()` construct."
#~ msgstr ""
#~ "C++と同様に、ゼロコスト抽象化とは、より高水準なプログラミング構造の利用に"
#~ "メモリやCPUのコストを支払う必要がないことを意味します。例えば、`for`を使っ"
#~ "たループの場合、`iter().fold()`構文を使った場合とおおよそ同じ低水準の処理"
#~ "になります。"

#~ msgid ""
#~ "It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
#~ "also known as 'sum types', which allow the type system to express things "
#~ "like `Option<T>` and `Result<T, E>`."
#~ msgstr ""
#~ "Rustの列挙型は「代数的データ型」であり、「直和型」と呼ばれます。"
#~ "`Option<T>`や`Result<T, E>`のような要素を表現することができます。"

#~ msgid ""
#~ "Remind people to read the errors --- many developers have gotten used to "
#~ "ignore lengthy compiler output. The Rust compiler is significantly more "
#~ "talkative than other compilers. It will often provide you with "
#~ "_actionable_ feedback, ready to copy-paste into your code."
#~ msgstr ""
#~ "エラーをちゃんと確認するよう注意してください。多くの開発者は、長いコンパイ"
#~ "ラ出力を無視することに慣れてしまっています。Rustのコンパイラは他のコンパイ"
#~ "ラよりもわかりやすく実用的なフィードバックを提供してくれます。そして多くの"
#~ "場合、コードにそのままコピペできるようなフィードバックが提供されます。"

#~ msgid ""
#~ "The Rust standard library is small compared to languages like Java, "
#~ "Python, and Go. Rust does not come with several things you might consider "
#~ "standard and essential:"
#~ msgstr ""
#~ "Rustの標準ライブラリは、Java、Python、Goなどのそれと比べると小規模です。"
#~ "Rustには標準的かつ必須と思われるいくつかの機能が含まれていません："

#~ msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
#~ msgstr "乱数生成器。[rand](https://docs.rs/rand/)を確認してください。"

#~ msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
#~ msgstr ""
#~ "SSLやTLSのサポート。[rusttls](https://docs.rs/rustls/)を確認してください。"

#~ msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
#~ msgstr ""
#~ "JSONのサポート。[serde_json](https://docs.rs/serde_json/)を確認してくださ"
#~ "い。 "

#~ msgid ""
#~ "The reasoning behind this is that functionality in the standard library "
#~ "cannot go away, so it has to be very stable. For the examples above, the "
#~ "Rust community is still working on finding the best solution --- and "
#~ "perhaps there isn't a single \"best solution\" for some of these things."
#~ msgstr ""
#~ "この理由は、標準ライブラリの機能は消えることがなく、非常に安定したものでな"
#~ "ければならないからです。上記の例については、Rustコミュニティが未だに最適な"
#~ "解決策を探し続けています。そもそも、これらに対する「最適解」は一つであると"
#~ "は限らないのです。"

#~ msgid ""
#~ "Rust comes with a built-in package manager in the form of Cargo and this "
#~ "makes it trivial to download and compile third-party crates. A "
#~ "consequence of this is that the standard library can be smaller."
#~ msgstr ""
#~ "Rustには、Cargoという外部クレートのダウンロードからコンパイルまでを簡単に"
#~ "行ってくれるパッケージマネージャが組み込まれています。これにより、標準ライ"
#~ "ブラリを小規模に保つことができています。"

#~ msgid ""
#~ "Discovering good third-party crates can be a problem. Sites like <https://"
#~ "lib.rs/> help with this by letting you compare health metrics for crates "
#~ "to find a good and trusted one."
#~ msgstr ""
#~ "良い外部クレートを見つけるのは難しいときがあります。<https://lib.rs/>のよ"
#~ "うなサイトを使うことで、クレートの評価基準を参考にしながら比較を行うことが"
#~ "できます。"

#~ msgid ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
#~ "implementation used in major IDEs and text editors."
#~ msgstr ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/)は、主要IDEやテキストエ"
#~ "ディタで使用できる、サポートが充実しているLSPの実装です。"

#~ msgid ""
#~ "As we have seen, `if` is an expression in Rust. It is used to "
#~ "conditionally evaluate one of two blocks, but the blocks can have a value "
#~ "which then becomes the value of the `if` expression. Other control flow "
#~ "expressions work similarly in Rust."
#~ msgstr ""
#~ "今まで見てきたように、Rust において `if` は式です。`if` 式のブロックは値を"
#~ "持っており、条件判定の結果に応じて評価されたブロックの値が `if` 式の値とな"
#~ "ります。Rust では他の制御フローの式も同様の動作をします。"

#~ msgid ""
#~ "The same rule is used for functions: the value of the function body is "
#~ "the return value:"
#~ msgstr ""
#~ "同じルールが関数についても適用されます。関数の body ブロックの値が、その関"
#~ "数の返り値となります。"

#~ msgid ""
#~ "The point of this slide is to show that blocks have a type and value in "
#~ "Rust. "
#~ msgstr ""
#~ "このスライドのポイントは、Rust におけるブロックは型と値を持つということで"
#~ "す。"

#~ msgid ""
#~ "The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is "
#~ "closely related to the [`while let` loop](while-let-expressions.md). It "
#~ "will automatically call `into_iter()` on the expression and then iterate "
#~ "over it:"
#~ msgstr ""
#~ "[`for` loop](https://doc.rust-lang.org/std/keyword.for.html) は、[`while "
#~ "let` loop](while-let-expressions.md) とよく似ています。`for` ループは "
#~ "`in` キーワードの右側にある式に対して自動的に `into_iter()` を呼び出し、そ"
#~ "の結果生成されたイテレータを用いて走査を行います。"

#~ msgid "You can use `break` and `continue` here as usual."
#~ msgstr ""
#~ "`for` ループの中では、いつも通り `break` や `continue` を使うことができま"
#~ "す。"

#~ msgid "Index iteration is not a special syntax in Rust for just that case."
#~ msgstr ""
#~ "Rust では、インデックスによる反復処理のために特別な構文は提供されていませ"
#~ "ん。"

#~ msgid "`(0..10)` is a range that implements an `Iterator` trait. "
#~ msgstr "`(0..10)` は Range 型であり、`Iterator` トレイトを実装しています。"

#~ msgid ""
#~ "`step_by` is a method that returns another `Iterator` that skips every "
#~ "other element. "
#~ msgstr ""
#~ "`step_by` は、元のイテレータとは別の、各要素をスキップする `Iterator` を返"
#~ "すメソッドです。"

#~ msgid ""
#~ "Modify the elements in the vector and explain the compiler errors. Change "
#~ "vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
#~ msgstr ""
#~ "ベクタ内の要素を変更してみて、その結果生じるコンパイルエラーについて説明し"
#~ "てください。また、ベクタ `v` をミュータブルに、for ループを `for x in v."
#~ "iter_mut()` に変更してみましょう。"

#~ msgid "`loop` expressions"
#~ msgstr "`loop` 式"

#~ msgid ""
#~ "Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
#~ "expressions/loop-expr.html#infinite-loops) which creates an endless loop."
#~ msgstr ""
#~ "最後に、無限ループを作る [`loop` キーワード](https://doc.rust-lang.org/"
#~ "reference/expressions/loop-expr.html#infinite-loops) について説明します。"

#~ msgid "Here you must either `break` or `return` to stop the loop:"
#~ msgstr ""
#~ "下の例で、ループから抜けるためには `break` あるいは `return` を使う必要が"
#~ "あります。"

#~ msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
#~ msgstr ""
#~ "例えば `break 8` のようにループを値と共に抜け、それを print してみましょ"
#~ "う。"

#, fuzzy
#~ msgid "The Luhn algorithm,"
#~ msgstr "Luhnアルゴリズム"

#, fuzzy
#~ msgid "An exercise on pattern matching."
#~ msgstr "列挙型とパターンマッチング"

#~ msgid ""
#~ "Memory management: stack vs heap, manual memory management, scope-based "
#~ "memory management, and garbage collection."
#~ msgstr ""
#~ "メモリ管理： スタック vs ヒープ、手動でのメモリ管理、スコープに基づくメモ"
#~ "リ管理、ガベージコレクション。"

#~ msgid ""
#~ "Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
#~ msgstr ""
#~ "所有権： ムーブセマンティクス、コピーとクローン、借用、ライフタイム。"

#, fuzzy
#~ msgid "Structs and methods."
#~ msgstr "文字列とイテレータ"

#, fuzzy
#~ msgid "Stack and Heap Example"
#~ msgstr "スタック vs ヒープ"

#~ msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
#~ msgstr ""
#~ "次のような新しい変数を宣言してみてください `let p = Point { x: 5, y: "
#~ "10.0 };`."

#~ msgid "Fix the code to allow points that have elements of different types."
#~ msgstr "異なる型の要素を持つ点を許容するように、コードを修正してください。"

#~ msgid "You can declare a generic type on your `impl` block:"
#~ msgstr "`impl`に対して、ジェネリックな型を宣言することもできます："

#~ msgid ""
#~ "Generic code is turned into non-generic code based on the call sites:"
#~ msgstr ""
#~ "ジェネリクスのコードは呼び出し箇所に基づいて、ジェネリックでないコードに変"
#~ "換されます："

#~ msgid "behaves as if you wrote"
#~ msgstr "上のコードは、次のように書いた時と同じように動作します"

#~ msgid ""
#~ "Rust derive macros work by automatically generating code that implements "
#~ "the specified traits for a data structure."
#~ msgstr ""
#~ "Rustのderiveマクロは、データ構造体に対して、指定されたトレイトを実装する"
#~ "コードを自動的に生成します。"

#~ msgid "You can let the compiler derive a number of traits as follows:"
#~ msgstr ""
#~ "コンパイラには、以下のような多くのトレイトを導出させることができます："

#~ msgid "Traits can implement behavior in terms of other trait methods:"
#~ msgstr ""
#~ "トレイトでは、別のトレイトメソッドを用いて挙動を定義することが可能です："

#~ msgid "Move method `not_equals` to a new trait `NotEquals`."
#~ msgstr ""
#~ "メソッド `not_equals` を新しいトレイト `NotEquals` に移してみましょう。"

#~ msgid "Make `Equals` a super trait for `NotEquals`."
#~ msgstr "`Equals` を `NotEquals` のスーパートレイトにしてみましょう。"

#~ msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
#~ msgstr "`Equals`に対する`NotEquals`のブランケット実装を示してみましょう。"

#~ msgid ""
#~ "With the blanket implementation, you no longer need `Equals` as a super "
#~ "trait for `NotEqual`."
#~ msgstr ""
#~ "ブランケット実装を用いれば、`Equals` を`NotEqual`のスーパートレイトとする"
#~ "必要はなくなります。"

#~ msgid "`impl Trait` allows you to work with types which you cannot name."
#~ msgstr ""
#~ "`impl Trait`を用いれば、型名を明示せずに型を限定することができます。"

#~ msgid ""
#~ "This example is great, because it uses `impl Display` twice. It helps to "
#~ "explain that nothing here enforces that it is _the same_ `impl Display` "
#~ "type. If we used a single  `T: Display`, it would enforce the constraint "
#~ "that input `T` and return `T` type are the same type. It would not work "
#~ "for this particular function, as the type we expect as input is likely "
#~ "not what `format!` returns. If we wanted to do the same via `: Display` "
#~ "syntax, we'd need two independent generic parameters."
#~ msgstr ""
#~ "この例は素晴らしい例です。なぜなら、 `impl Display`を２回用いているからで"
#~ "す。 ここでは `impl Display` の型が同一になることを強制するものはない、と"
#~ "いう説明をするのに役立ちます。もし単一の`T: Display`を用いた場合、入力の"
#~ "`T`と返り値の`T`が同一の型であることが強制されてしまいます。例で示した関数"
#~ "ではうまくいかないでしょう。なぜなら、我々が期待する入力の型は、`format!`"
#~ "が返すものではおそらくないからです。もしも同じことを`: Display`の構文で行"
#~ "いたい場合、２つの独立したジェネリックなパラメタが必要となるでしょう。"

#, fuzzy
#~ msgid "Drawing A Simple GUI"
#~ msgstr "GUIライブラリ"

#, fuzzy
#~ msgid "concurrency:"
#~ msgstr "並行性"

#, fuzzy
#~ msgid "control flow:"
#~ msgstr "制御フロー"

#, fuzzy
#~ msgid "enumeration:"
#~ msgstr "実装"

#, fuzzy
#~ msgid "error handling:"
#~ msgstr "エラー処理"

#, fuzzy
#~ msgid "garbage collector:"
#~ msgstr "ガベージコレクション"

#, fuzzy
#~ msgid "generics:"
#~ msgstr "ジェネリクス（generics）"

#, fuzzy
#~ msgid "integration test:"
#~ msgstr "インテグレーションテスト"

#, fuzzy
#~ msgid "main function:"
#~ msgstr "Unsafe関数の呼び出し"

#, fuzzy
#~ msgid "method:"
#~ msgstr "メソッド"

#, fuzzy
#~ msgid "module:"
#~ msgstr "モジュール"

#, fuzzy
#~ msgid "ownership:"
#~ msgstr "所有権"

#, fuzzy
#~ msgid "panic:"
#~ msgstr "パニック（panic）"

#, fuzzy
#~ msgid "receiver:"
#~ msgstr "ドライバ"

#, fuzzy
#~ msgid "standard library:"
#~ msgstr "標準ライブラリ"

#, fuzzy
#~ msgid "struct:"
#~ msgstr "構造体（structs）"

#, fuzzy
#~ msgid "thread:"
#~ msgstr "スレッド"

#, fuzzy
#~ msgid "trait:"
#~ msgstr "トレイト（trait）"

#, fuzzy
#~ msgid "undefined behavior:"
#~ msgstr "実行時に未定義の動作はありません："

#, fuzzy
#~ msgid "union:"
#~ msgstr "共用体"

#, fuzzy
#~ msgid "unit test:"
#~ msgstr "ユニットテスト"

#, fuzzy
#~ msgid "variable:\\"
#~ msgstr "変数"

#, fuzzy
#~ msgid "Pattern matching"
#~ msgstr "パターンマッチング"

#~ msgid "Designing a Library"
#~ msgstr "ライブラリをデザイン"
