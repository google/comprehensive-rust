msgid ""
msgstr ""
"Project-Id-Version: [한국어]Comprehensive Rust 🦀\n"
"POT-Creation-Date: 2024-01-04T08:58:44-08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3 src/index.md:1
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "Comprehensive Rust에 오신 것을 환영합니다 🦀"

#: src/SUMMARY.md:5 src/running-the-course.md:1
msgid "Running the Course"
msgstr "강의 진행"

#: src/SUMMARY.md:6 src/running-the-course/course-structure.md:1
msgid "Course Structure"
msgstr "강의 구성"

#: src/SUMMARY.md:7 src/running-the-course/keyboard-shortcuts.md:1
msgid "Keyboard Shortcuts"
msgstr "단축키"

#: src/SUMMARY.md:8 src/running-the-course/translations.md:1
msgid "Translations"
msgstr "다른 언어들"

#: src/SUMMARY.md:9 src/cargo.md:1
msgid "Using Cargo"
msgstr "카고 사용하기"

#: src/SUMMARY.md:10
msgid "Rust Ecosystem"
msgstr "러스트 생태계"

#: src/SUMMARY.md:11
msgid "Code Samples"
msgstr "코드 샘플"

#: src/SUMMARY.md:12
msgid "Running Cargo Locally"
msgstr "카고(Cargo) 수행하기"

#: src/SUMMARY.md:16
msgid "Day 1: Morning"
msgstr "1일차 오전"

#: src/SUMMARY.md:18 src/SUMMARY.md:44 src/SUMMARY.md:70 src/SUMMARY.md:93
#: src/SUMMARY.md:119 src/SUMMARY.md:138 src/SUMMARY.md:158 src/SUMMARY.md:184
#: src/SUMMARY.md:207 src/SUMMARY.md:244 src/SUMMARY.md:286 src/SUMMARY.md:337
msgid "Welcome"
msgstr "개요"

#: src/SUMMARY.md:19 src/SUMMARY.md:21 src/hello-world.md:1
#: src/hello-world/hello-world.md:1
#, fuzzy
msgid "Hello, World"
msgstr "Hello World!"

#: src/SUMMARY.md:20 src/hello-world/what-is-rust.md:1
msgid "What is Rust?"
msgstr "러스트란?"

#: src/SUMMARY.md:22 src/hello-world/benefits.md:1
msgid "Benefits of Rust"
msgstr ""

#: src/SUMMARY.md:23 src/hello-world/playground.md:1
msgid "Playground"
msgstr ""

#: src/SUMMARY.md:24 src/types-and-values.md:1
msgid "Types and Values"
msgstr ""

#: src/SUMMARY.md:25 src/types-and-values/variables.md:1
msgid "Variables"
msgstr "변수"

#: src/SUMMARY.md:26 src/types-and-values/values.md:1
msgid "Values"
msgstr ""

#: src/SUMMARY.md:27 src/types-and-values/arithmetic.md:1
msgid "Arithmetic"
msgstr ""

#: src/SUMMARY.md:28 src/types-and-values/strings.md:1
msgid "Strings"
msgstr "문자열"

#: src/SUMMARY.md:29 src/types-and-values/inference.md:1
msgid "Type Inference"
msgstr "타입 추론"

#: src/SUMMARY.md:30 src/types-and-values/exercise.md:1
msgid "Exercise: Fibonacci"
msgstr ""

#: src/SUMMARY.md:31 src/SUMMARY.md:40 src/SUMMARY.md:51 src/SUMMARY.md:56
#: src/SUMMARY.md:64 src/SUMMARY.md:75 src/SUMMARY.md:82 src/SUMMARY.md:89
#: src/SUMMARY.md:103 src/SUMMARY.md:113 src/SUMMARY.md:129 src/SUMMARY.md:134
#: src/SUMMARY.md:144 src/SUMMARY.md:152 src/SUMMARY.md:164 src/SUMMARY.md:171
#: src/SUMMARY.md:180 src/SUMMARY.md:192 src/SUMMARY.md:201
#: src/types-and-values/solution.md:1 src/control-flow-basics/solution.md:1
#: src/tuples-and-arrays/solution.md:1 src/references/solution.md:1
#: src/user-defined-types/solution.md:1 src/pattern-matching/solution.md:1
#: src/methods-and-traits/solution.md:1 src/generics/solution.md:1
#: src/std-types/solution.md:1 src/std-traits/solution.md:1
#: src/memory-management/solution.md:1 src/smart-pointers/solution.md:1
#: src/borrowing/solution.md:1 src/slices-and-lifetimes/solution.md:1
#: src/iterators/solution.md:1 src/modules/solution.md:1
#: src/testing/solution.md:1 src/error-handling/solution.md:1
#: src/unsafe-rust/solution.md:1
#, fuzzy
msgid "Solution"
msgstr "해답"

#: src/SUMMARY.md:32 src/control-flow-basics.md:1
#, fuzzy
msgid "Control Flow Basics"
msgstr "흐름 제어"

#: src/SUMMARY.md:33 src/control-flow-basics/conditionals.md:1
msgid "Conditionals"
msgstr ""

#: src/SUMMARY.md:34 src/control-flow-basics/loops.md:1
#, fuzzy
msgid "Loops"
msgstr "배열과 `for` 반복문"

#: src/SUMMARY.md:35 src/control-flow-basics/break-continue.md:1
msgid "`break` and `continue`"
msgstr "`break`와 `continue`"

#: src/SUMMARY.md:36 src/control-flow-basics/blocks-and-scopes.md:1
msgid "Blocks and Scopes"
msgstr ""

#: src/SUMMARY.md:37 src/control-flow-basics/functions.md:1
msgid "Functions"
msgstr "함수"

#: src/SUMMARY.md:38 src/control-flow-basics/macros.md:1
msgid "Macros"
msgstr ""

#: src/SUMMARY.md:39 src/control-flow-basics/exercise.md:1
msgid "Exercise: Collatz Sequence"
msgstr ""

#: src/SUMMARY.md:42
msgid "Day 1: Afternoon"
msgstr "1일차 오후"

#: src/SUMMARY.md:45 src/SUMMARY.md:46 src/tuples-and-arrays.md:1
#: src/tuples-and-arrays/tuples-and-arrays.md:1
msgid "Tuples and Arrays"
msgstr ""

#: src/SUMMARY.md:47 src/tuples-and-arrays/iteration.md:1
#, fuzzy
msgid "Array Iteration"
msgstr "Cargo에 통합됨"

#: src/SUMMARY.md:48 src/SUMMARY.md:71 src/tuples-and-arrays/match.md:1
#: src/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "패턴 매칭"

#: src/SUMMARY.md:49 src/SUMMARY.md:72 src/tuples-and-arrays/destructuring.md:1
#: src/pattern-matching/destructuring.md:1
#, fuzzy
msgid "Destructuring"
msgstr "열거형 분해(역구조화)"

#: src/SUMMARY.md:50 src/tuples-and-arrays/exercise.md:1
msgid "Exercise: Nested Arrays"
msgstr ""

#: src/SUMMARY.md:52 src/references.md:1
msgid "References"
msgstr "참조"

#: src/SUMMARY.md:53 src/references/shared.md:1
#, fuzzy
msgid "Shared References"
msgstr "참조"

#: src/SUMMARY.md:54 src/references/exclusive.md:1
#, fuzzy
msgid "Exclusive References"
msgstr "허상(dangling) 참조"

#: src/SUMMARY.md:55 src/references/exercise.md:1
msgid "Exercise: Geometry"
msgstr ""

#: src/SUMMARY.md:57 src/user-defined-types.md:1
msgid "User-Defined Types"
msgstr ""

#: src/SUMMARY.md:58 src/user-defined-types/named-structs.md:1
#, fuzzy
msgid "Named Structs"
msgstr "구조체"

#: src/SUMMARY.md:59 src/user-defined-types/tuple-structs.md:5
msgid "Tuple Structs"
msgstr "튜플"

#: src/SUMMARY.md:60 src/user-defined-types/enums.md:1
#: src/pattern-matching/destructuring.md:24
#: src/pattern-matching/destructuring.md:66
msgid "Enums"
msgstr "열거형"

#: src/SUMMARY.md:61 src/user-defined-types/static-and-const.md:1
#, fuzzy
msgid "Static and Const"
msgstr "정적변수(static)와 상수(const)"

#: src/SUMMARY.md:62 src/user-defined-types/aliases.md:1
msgid "Type Aliases"
msgstr ""

#: src/SUMMARY.md:63 src/user-defined-types/exercise.md:1
msgid "Exercise: Elevator Events"
msgstr ""

#: src/SUMMARY.md:68
msgid "Day 2: Morning"
msgstr "2일차 오전"

#: src/SUMMARY.md:73 src/pattern-matching/let-control-flow.md:1
#, fuzzy
msgid "Let Control Flow"
msgstr "흐름 제어"

#: src/SUMMARY.md:74 src/pattern-matching/exercise.md:1
msgid "Exercise: Expression Evaluation"
msgstr ""

#: src/SUMMARY.md:76 src/methods-and-traits.md:1
#, fuzzy
msgid "Methods and Traits"
msgstr "Read와 Write"

#: src/SUMMARY.md:77 src/methods-and-traits/methods.md:1
msgid "Methods"
msgstr "메서드"

#: src/SUMMARY.md:78 src/methods-and-traits/traits.md:1
msgid "Traits"
msgstr "트레잇(Trait)"

#: src/SUMMARY.md:79 src/methods-and-traits/deriving.md:1
#, fuzzy
msgid "Deriving"
msgstr "트레잇 상속하기"

#: src/SUMMARY.md:80 src/methods-and-traits/trait-objects.md:1
msgid "Trait Objects"
msgstr "트레잇 객체"

#: src/SUMMARY.md:81 src/methods-and-traits/exercise.md:1
#, fuzzy
msgid "Exercise: GUI Library"
msgstr "간단한 GUI 라이브러리"

#: src/SUMMARY.md:83 src/generics.md:1
msgid "Generics"
msgstr "제네릭"

#: src/SUMMARY.md:84 src/generics/generic-functions.md:1
#, fuzzy
msgid "Generic Functions"
msgstr "외부(다른언어) 함수들"

#: src/SUMMARY.md:85 src/generics/generic-data.md:1
msgid "Generic Data Types"
msgstr "제네릭 데이터 타입"

#: src/SUMMARY.md:86 src/generics/trait-bounds.md:1
msgid "Trait Bounds"
msgstr "제네릭 타입 제한(트레잇 경계)"

#: src/SUMMARY.md:87 src/generics/impl-trait.md:1
msgid "`impl Trait`"
msgstr "트레잇 구현하기(`impl Trait`)"

#: src/SUMMARY.md:88 src/generics/exercise.md:1
msgid "Exercise: Generic `min`"
msgstr ""

#: src/SUMMARY.md:91
msgid "Day 2: Afternoon"
msgstr "2일차 오후"

#: src/SUMMARY.md:94 src/std-types.md:1
#, fuzzy
msgid "Standard Library Types"
msgstr "표준 라이브러리"

#: src/SUMMARY.md:95 src/std-types/std.md:1
msgid "Standard Library"
msgstr "표준 라이브러리"

#: src/SUMMARY.md:96 src/std-types/docs.md:1
#, fuzzy
msgid "Documentation"
msgstr "문서화주석 테스트"

#: src/SUMMARY.md:97
#, fuzzy
msgid "`Option`"
msgstr "`Duration`"

#: src/SUMMARY.md:98
#, fuzzy
msgid "`Result`"
msgstr "`Option`, `Result`"

#: src/SUMMARY.md:99 src/android/interoperability/cpp/type-mapping.md:5
#, fuzzy
msgid "`String`"
msgstr "String"

#: src/SUMMARY.md:100 src/std-types/vec.md:1
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md:101 src/std-types/hashmap.md:1 src/bare-metal/no_std.md:46
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md:102 src/std-types/exercise.md:1
#, fuzzy
msgid "Exercise: Counter"
msgstr "연습문제"

#: src/SUMMARY.md:104 src/std-traits.md:1
#, fuzzy
msgid "Standard Library Traits"
msgstr "표준 라이브러리"

#: src/SUMMARY.md:105 src/std-traits/comparisons.md:1 src/async.md:17
#, fuzzy
msgid "Comparisons"
msgstr "비교"

#: src/SUMMARY.md:106 src/std-traits/operators.md:1
#, fuzzy
msgid "Operators"
msgstr "Iterators"

#: src/SUMMARY.md:107 src/std-traits/from-and-into.md:1
msgid "`From` and `Into`"
msgstr "`From`과 `Into`"

#: src/SUMMARY.md:108 src/std-traits/casting.md:1
#, fuzzy
msgid "Casting"
msgstr "테스트"

#: src/SUMMARY.md:109 src/std-traits/read-and-write.md:1
msgid "`Read` and `Write`"
msgstr "`Read`와 `Write`"

#: src/SUMMARY.md:110
msgid "`Default`, struct update syntax"
msgstr ""

#: src/SUMMARY.md:111 src/std-traits/closures.md:1
msgid "Closures"
msgstr "클로저(Closure)"

#: src/SUMMARY.md:112 src/std-traits/exercise.md:1
#, fuzzy
msgid "Exercise: ROT13"
msgstr "연습문제"

#: src/SUMMARY.md:117
msgid "Day 3: Morning"
msgstr "3일차 오전"

#: src/SUMMARY.md:120 src/memory-management.md:1
msgid "Memory Management"
msgstr "메모리 관리"

#: src/SUMMARY.md:121 src/memory-management/review.md:1
msgid "Review of Program Memory"
msgstr ""

#: src/SUMMARY.md:122 src/memory-management/approaches.md:1
#, fuzzy
msgid "Approaches to Memory Management"
msgstr "자동 메모리 관리"

#: src/SUMMARY.md:123 src/memory-management/ownership.md:1
msgid "Ownership"
msgstr "소유권"

#: src/SUMMARY.md:124 src/memory-management/move.md:1
msgid "Move Semantics"
msgstr "Move 문법"

#: src/SUMMARY.md:125
msgid "`Clone`"
msgstr ""

#: src/SUMMARY.md:126 src/memory-management/copy-types.md:5
#, fuzzy
msgid "Copy Types"
msgstr "복합 타입"

#: src/SUMMARY.md:127
#, fuzzy
msgid "`Drop`"
msgstr "Drop"

#: src/SUMMARY.md:128 src/memory-management/exercise.md:1
msgid "Exercise: Builder Type"
msgstr ""

#: src/SUMMARY.md:130 src/smart-pointers.md:1
msgid "Smart Pointers"
msgstr ""

#: src/SUMMARY.md:131 src/smart-pointers/box.md:1
#: src/android/interoperability/cpp/type-mapping.md:9
#, fuzzy
msgid "`Box<T>`"
msgstr "`Box`"

#: src/SUMMARY.md:132 src/smart-pointers/rc.md:1
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md:133 src/smart-pointers/exercise.md:1
msgid "Exercise: Binary Tree"
msgstr ""

#: src/SUMMARY.md:136
msgid "Day 3: Afternoon"
msgstr "3일차 오후"

#: src/SUMMARY.md:139 src/borrowing.md:1
msgid "Borrowing"
msgstr "빌림"

#: src/SUMMARY.md:140 src/borrowing/shared.md:1
#, fuzzy
msgid "Borrowing a Value"
msgstr "빌림"

#: src/SUMMARY.md:141 src/borrowing/borrowck.md:1
#, fuzzy
msgid "Borrow Checking"
msgstr "빌림"

#: src/SUMMARY.md:142 src/borrowing/interior-mutability.md:5
#, fuzzy
msgid "Interior Mutability"
msgstr "상호운용성"

#: src/SUMMARY.md:143 src/borrowing/exercise.md:1
#, fuzzy
msgid "Exercise: Health Statistics"
msgstr "건강상태 모니터링 시스템"

#: src/SUMMARY.md:145 src/slices-and-lifetimes.md:1
#, fuzzy
msgid "Slices and Lifetimes"
msgstr "수명"

#: src/SUMMARY.md:146
#, fuzzy
msgid "Slices: `&[T]`"
msgstr "슬라이스"

#: src/SUMMARY.md:147 src/slices-and-lifetimes/str.md:5
#, fuzzy
msgid "String References"
msgstr "허상(dangling) 참조"

#: src/SUMMARY.md:148 src/slices-and-lifetimes/lifetime-annotations.md:1
#, fuzzy
msgid "Lifetime Annotations"
msgstr "함수 호출에서의 수명"

#: src/SUMMARY.md:149
#, fuzzy
msgid "Lifetime Elision"
msgstr "수명"

#: src/SUMMARY.md:150
#, fuzzy
msgid "Struct Lifetimes"
msgstr "수명"

#: src/SUMMARY.md:151 src/slices-and-lifetimes/exercise.md:1
msgid "Exercise: Protobuf Parsing"
msgstr ""

#: src/SUMMARY.md:156
#, fuzzy
msgid "Day 4: Morning"
msgstr "1일차 오전"

#: src/SUMMARY.md:159 src/iterators.md:1
msgid "Iterators"
msgstr "Iterators"

#: src/SUMMARY.md:160 src/iterators/iterator.md:5 src/bare-metal/no_std.md:28
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md:161 src/iterators/intoiterator.md:1
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md:162
#, fuzzy
msgid "`FromIterator`"
msgstr "FromIterator"

#: src/SUMMARY.md:163 src/iterators/exercise.md:1
msgid "Exercise: Iterator Method Chaining"
msgstr ""

#: src/SUMMARY.md:165 src/SUMMARY.md:166 src/modules.md:1
#: src/modules/modules.md:1
msgid "Modules"
msgstr "모듈"

#: src/SUMMARY.md:167 src/modules/filesystem.md:1
msgid "Filesystem Hierarchy"
msgstr "파일시스템 계층"

#: src/SUMMARY.md:168 src/modules/visibility.md:1
msgid "Visibility"
msgstr "가시성"

#: src/SUMMARY.md:169
msgid "`use`, `super`, `self`"
msgstr ""

#: src/SUMMARY.md:170 src/modules/exercise.md:1
msgid "Exercise: Modules for the GUI Library"
msgstr ""

#: src/SUMMARY.md:172 src/SUMMARY.md:253 src/testing.md:1
#: src/chromium/testing.md:1
msgid "Testing"
msgstr "테스트"

#: src/SUMMARY.md:173
msgid "Test Modules"
msgstr "테스트 모듈"

#: src/SUMMARY.md:174 src/testing/other.md:1
#, fuzzy
msgid "Other Types of Tests"
msgstr "다른 프로젝트"

#: src/SUMMARY.md:175 src/SUMMARY.md:321 src/testing/useful-crates.md:1
msgid "Useful Crates"
msgstr "유용한 크레이트"

#: src/SUMMARY.md:176 src/testing/googletest.md:1
msgid "GoogleTest"
msgstr ""

#: src/SUMMARY.md:177 src/testing/mocking.md:1
msgid "Mocking"
msgstr ""

#: src/SUMMARY.md:178 src/testing/lints.md:1
msgid "Compiler Lints and Clippy"
msgstr ""

#: src/SUMMARY.md:179 src/testing/exercise.md:1
#, fuzzy
msgid "Exercise: Luhn Algorithm"
msgstr "룬 알고리즘"

#: src/SUMMARY.md:182
#, fuzzy
msgid "Day 4: Afternoon"
msgstr "1일차 오후"

#: src/SUMMARY.md:185 src/error-handling.md:1
msgid "Error Handling"
msgstr "오류처리"

#: src/SUMMARY.md:186 src/error-handling/panics.md:1
msgid "Panics"
msgstr "패닉"

#: src/SUMMARY.md:187 src/error-handling/try.md:1
#, fuzzy
msgid "Try Operator"
msgstr "Iterator"

#: src/SUMMARY.md:188 src/error-handling/try-conversions.md:1
#, fuzzy
msgid "Try Conversions"
msgstr "묵시적 형변환"

#: src/SUMMARY.md:189
#, fuzzy
msgid "`Error` Trait"
msgstr "`Error`"

#: src/SUMMARY.md:190 src/error-handling/thiserror-and-anyhow.md:1
#, fuzzy
msgid "`thiserror` and `anyhow`"
msgstr "`From`과 `Into`"

#: src/SUMMARY.md:191
#, fuzzy
msgid "Exercise: Rewriting with `Result`"
msgstr "`Result`를 이용한 구조화된 오류처리"

#: src/SUMMARY.md:193 src/unsafe-rust.md:1 src/unsafe-rust/unsafe.md:1
msgid "Unsafe Rust"
msgstr "안전하지 않은 러스트"

#: src/SUMMARY.md:194
#, fuzzy
msgid "Unsafe"
msgstr "안전하지 않은 러스트"

#: src/SUMMARY.md:195 src/unsafe-rust/dereferencing.md:1
msgid "Dereferencing Raw Pointers"
msgstr "원시 포인터 역참조(따라가기)"

#: src/SUMMARY.md:196 src/unsafe-rust/mutable-static.md:1
msgid "Mutable Static Variables"
msgstr "정적 가변 변수"

#: src/SUMMARY.md:197 src/unsafe-rust/unions.md:1
msgid "Unions"
msgstr "Unions"

#: src/SUMMARY.md:198 src/unsafe-rust/unsafe-functions.md:1
#, fuzzy
msgid "Unsafe Functions"
msgstr "안전하지 않은 함수 호출"

#: src/SUMMARY.md:199
#, fuzzy
msgid "Unsafe Traits"
msgstr "안전하지 않은 트레잇 구현하기"

#: src/SUMMARY.md:200
#, fuzzy
msgid "Exercise: FFI Wrapper"
msgstr "FFI래퍼"

#: src/SUMMARY.md:203 src/SUMMARY.md:327 src/bare-metal/android.md:1
msgid "Android"
msgstr "안드로이드"

#: src/SUMMARY.md:208 src/SUMMARY.md:245 src/android/setup.md:1
#: src/chromium/setup.md:1
msgid "Setup"
msgstr "설치"

#: src/SUMMARY.md:209 src/SUMMARY.md:248 src/android/build-rules.md:1
msgid "Build Rules"
msgstr "빌드 규칙"

#: src/SUMMARY.md:210
msgid "Binary"
msgstr "바이너리"

#: src/SUMMARY.md:211
msgid "Library"
msgstr "라이브러리"

#: src/SUMMARY.md:212 src/android/aidl.md:1
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:213
msgid "Interface"
msgstr "AIDL 인터페이스"

#: src/SUMMARY.md:214
msgid "Implementation"
msgstr "서비스 구현"

#: src/SUMMARY.md:215
msgid "Server"
msgstr "AIDL 서버"

#: src/SUMMARY.md:216 src/android/aidl/deploy.md:1
msgid "Deploy"
msgstr "배포"

#: src/SUMMARY.md:217
msgid "Client"
msgstr "클라이언트"

#: src/SUMMARY.md:218 src/android/aidl/changing.md:1
msgid "Changing API"
msgstr "API 수정"

#: src/SUMMARY.md:219 src/SUMMARY.md:317 src/android/logging.md:1
#: src/bare-metal/aps/logging.md:1
msgid "Logging"
msgstr "로깅"

#: src/SUMMARY.md:220 src/android/interoperability.md:1
msgid "Interoperability"
msgstr "상호운용성"

#: src/SUMMARY.md:221
msgid "With C"
msgstr "C와의 상호운용성"

#: src/SUMMARY.md:222
msgid "Calling C with Bindgen"
msgstr "Bindgen을 사용한 C호출"

#: src/SUMMARY.md:223
msgid "Calling Rust from C"
msgstr "C에서 러스트 호출"

#: src/SUMMARY.md:224
#, fuzzy
msgid "With C++)"
msgstr "C++와의 상호운용성"

#: src/SUMMARY.md:225 src/android/interoperability/cpp/bridge.md:1
#, fuzzy
msgid "The Bridge Module"
msgstr "테스트 모듈"

#: src/SUMMARY.md:226
#, fuzzy
msgid "Rust Bridge"
msgstr "러스트 바이너리"

#: src/SUMMARY.md:227 src/android/interoperability/cpp/generated-cpp.md:1
msgid "Generated C++"
msgstr ""

#: src/SUMMARY.md:228
msgid "C++ Bridge"
msgstr ""

#: src/SUMMARY.md:229 src/android/interoperability/cpp/shared-types.md:1
#, fuzzy
msgid "Shared Types"
msgstr "스칼라 타입"

#: src/SUMMARY.md:230 src/android/interoperability/cpp/shared-enums.md:1
msgid "Shared Enums"
msgstr ""

#: src/SUMMARY.md:231 src/android/interoperability/cpp/rust-result.md:1
#, fuzzy
msgid "Rust Error Handling"
msgstr "오류처리"

#: src/SUMMARY.md:232 src/android/interoperability/cpp/cpp-exception.md:1
#, fuzzy
msgid "C++ Error Handling"
msgstr "오류처리"

#: src/SUMMARY.md:233 src/android/interoperability/cpp/type-mapping.md:1
msgid "Additional Types"
msgstr ""

#: src/SUMMARY.md:234
msgid "Building for Android: C++"
msgstr ""

#: src/SUMMARY.md:235
msgid "Building for Android: Genrules"
msgstr ""

#: src/SUMMARY.md:236
msgid "Building for Android: Rust"
msgstr ""

#: src/SUMMARY.md:237
msgid "With Java"
msgstr "Java와의 상호운용성"

#: src/SUMMARY.md:238 src/SUMMARY.md:300 src/SUMMARY.md:329 src/SUMMARY.md:351
#: src/SUMMARY.md:373 src/exercises/android/morning.md:1
#: src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1
#: src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
msgid "Exercises"
msgstr "연습문제"

#: src/SUMMARY.md:240
msgid "Chromium"
msgstr ""

#: src/SUMMARY.md:246 src/chromium/cargo.md:1
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr ""

#: src/SUMMARY.md:247
msgid "Policy"
msgstr ""

#: src/SUMMARY.md:249
#, fuzzy
msgid "Unsafe Code"
msgstr "안전하지 않은 러스트"

#: src/SUMMARY.md:250 src/chromium/build-rules/depending.md:1
msgid "Depending on Rust Code from Chromium C++"
msgstr ""

#: src/SUMMARY.md:251 src/chromium/build-rules/vscode.md:1
msgid "Visual Studio Code"
msgstr ""

#: src/SUMMARY.md:252 src/SUMMARY.md:257 src/SUMMARY.md:265 src/SUMMARY.md:278
#: src/exercises/chromium/third-party.md:1
#, fuzzy
msgid "Exercise"
msgstr "연습문제"

#: src/SUMMARY.md:254 src/chromium/testing/rust-gtest-interop.md:1
msgid "`rust_gtest_interop` Library"
msgstr ""

#: src/SUMMARY.md:255 src/chromium/testing/build-gn.md:1
msgid "GN Rules for Rust Tests"
msgstr ""

#: src/SUMMARY.md:256 src/chromium/testing/chromium-import-macro.md:1
msgid "`chromium::import!` Macro"
msgstr ""

#: src/SUMMARY.md:258 src/chromium/interoperability-with-cpp.md:1
#, fuzzy
msgid "Interoperability with C++"
msgstr "C와의 상호운용성"

#: src/SUMMARY.md:259
#: src/chromium/interoperability-with-cpp/example-bindings.md:1
#, fuzzy
msgid "Example Bindings"
msgstr "예제"

#: src/SUMMARY.md:260
#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:1
msgid "Limitations of CXX"
msgstr ""

#: src/SUMMARY.md:261
#: src/chromium/interoperability-with-cpp/error-handling.md:1
#, fuzzy
msgid "CXX Error Handling"
msgstr "오류처리"

#: src/SUMMARY.md:262
#, fuzzy
msgid "Error Handling: QR Example"
msgstr "오류처리"

#: src/SUMMARY.md:263
#, fuzzy
msgid "Error Handling: PNG Example"
msgstr "오류처리"

#: src/SUMMARY.md:264
msgid "Using CXX in Chromium"
msgstr ""

#: src/SUMMARY.md:266 src/chromium/adding-third-party-crates.md:1
msgid "Adding Third Party Crates"
msgstr ""

#: src/SUMMARY.md:267
msgid "Configuring Cargo.toml"
msgstr ""

#: src/SUMMARY.md:268
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:1
msgid "Configuring `gnrt_config.toml`"
msgstr ""

#: src/SUMMARY.md:269
#: src/chromium/adding-third-party-crates/downloading-crates.md:1
msgid "Downloading Crates"
msgstr ""

#: src/SUMMARY.md:270
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:1
msgid "Generating `gn` Build Rules"
msgstr ""

#: src/SUMMARY.md:271
#: src/chromium/adding-third-party-crates/resolving-problems.md:1
msgid "Resolving Problems"
msgstr ""

#: src/SUMMARY.md:272
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:1
msgid "Build Scripts Which Generate Code"
msgstr ""

#: src/SUMMARY.md:273
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:1
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr ""

#: src/SUMMARY.md:274
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:1
msgid "Depending on a Crate"
msgstr ""

#: src/SUMMARY.md:275
msgid "Reviews and Audits"
msgstr ""

#: src/SUMMARY.md:276
msgid "Checking into Chromium Source Code"
msgstr ""

#: src/SUMMARY.md:277
#: src/chromium/adding-third-party-crates/keeping-up-to-date.md:1
msgid "Keeping Crates Up to Date"
msgstr ""

#: src/SUMMARY.md:279
msgid "Bringing It Together - Exercise"
msgstr ""

#: src/SUMMARY.md:280 src/exercises/chromium/solutions.md:1
#, fuzzy
msgid "Exercise Solutions"
msgstr "해답"

#: src/SUMMARY.md:282
msgid "Bare Metal: Morning"
msgstr "Bare Metal 오전"

#: src/SUMMARY.md:287 src/bare-metal/no_std.md:1
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md:288
msgid "A Minimal Example"
msgstr "작은 예제"

#: src/SUMMARY.md:289 src/bare-metal/no_std.md:12 src/bare-metal/alloc.md:1
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md:290 src/bare-metal/microcontrollers.md:1
msgid "Microcontrollers"
msgstr "마이크로컨트롤러"

#: src/SUMMARY.md:291 src/bare-metal/microcontrollers/mmio.md:1
msgid "Raw MMIO"
msgstr "원시 MMIO"

#: src/SUMMARY.md:292
msgid "PACs"
msgstr "PAC"

#: src/SUMMARY.md:293
msgid "HAL Crates"
msgstr "HAL 크레이트"

#: src/SUMMARY.md:294
msgid "Board Support Crates"
msgstr "보드 지원 크레이트"

#: src/SUMMARY.md:295
msgid "The Type State Pattern"
msgstr "Type State 패턴"

#: src/SUMMARY.md:296 src/bare-metal/microcontrollers/embedded-hal.md:1
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md:297 src/bare-metal/microcontrollers/probe-rs.md:1
#, fuzzy
msgid "`probe-rs` and `cargo-embed`"
msgstr "`probe-rs`, `cargo-embed`"

#: src/SUMMARY.md:298 src/bare-metal/microcontrollers/debugging.md:1
msgid "Debugging"
msgstr "디버깅"

#: src/SUMMARY.md:299 src/SUMMARY.md:320
msgid "Other Projects"
msgstr "다른 프로젝트"

#: src/SUMMARY.md:301 src/exercises/bare-metal/compass.md:1
#: src/exercises/bare-metal/solutions-morning.md:3
msgid "Compass"
msgstr "나침반"

#: src/SUMMARY.md:302 src/SUMMARY.md:331 src/SUMMARY.md:354 src/SUMMARY.md:376
msgid "Solutions"
msgstr "해답"

#: src/SUMMARY.md:304
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal 오후"

#: src/SUMMARY.md:306
msgid "Application Processors"
msgstr "애플리케이션 프로세서"

#: src/SUMMARY.md:307 src/bare-metal/aps/entry-point.md:1
msgid "Getting Ready to Rust"
msgstr "Rust 수행 준비"

#: src/SUMMARY.md:308
msgid "Inline Assembly"
msgstr "인라인 어셈블리"

#: src/SUMMARY.md:309
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md:310
msgid "Let's Write a UART Driver"
msgstr "UART 드라이버 작성"

#: src/SUMMARY.md:311
msgid "More Traits"
msgstr "더 많은 트레잇"

#: src/SUMMARY.md:312
msgid "A Better UART Driver"
msgstr "더 나은 UART 드라이버"

#: src/SUMMARY.md:313 src/bare-metal/aps/better-uart/bitflags.md:1
msgid "Bitflags"
msgstr "비트플래그"

#: src/SUMMARY.md:314
msgid "Multiple Registers"
msgstr "더 많은 레지스터"

#: src/SUMMARY.md:315 src/bare-metal/aps/better-uart/driver.md:1
msgid "Driver"
msgstr "드라이버"

#: src/SUMMARY.md:316 src/SUMMARY.md:318
msgid "Using It"
msgstr "사용해 보기"

#: src/SUMMARY.md:319 src/bare-metal/aps/exceptions.md:1
msgid "Exceptions"
msgstr "예외"

#: src/SUMMARY.md:322 src/bare-metal/useful-crates/zerocopy.md:1
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md:323 src/bare-metal/useful-crates/aarch64-paging.md:1
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md:324 src/bare-metal/useful-crates/buddy_system_allocator.md:1
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/SUMMARY.md:325 src/bare-metal/useful-crates/tinyvec.md:1
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md:326 src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "`spin`"
msgstr "회전"

#: src/SUMMARY.md:328
#, fuzzy
msgid "`vmbase`"
msgstr "vmbase"

#: src/SUMMARY.md:330
msgid "RTC Driver"
msgstr "RTC 드라이버"

#: src/SUMMARY.md:333
msgid "Concurrency: Morning"
msgstr "동시성 오전"

#: src/SUMMARY.md:338 src/concurrency/threads.md:1
msgid "Threads"
msgstr "스레드"

#: src/SUMMARY.md:339 src/concurrency/scoped-threads.md:1
msgid "Scoped Threads"
msgstr "범위 스레드(Scoped Threads)"

#: src/SUMMARY.md:340 src/concurrency/channels.md:1
msgid "Channels"
msgstr "채널"

#: src/SUMMARY.md:341 src/concurrency/channels/unbounded.md:1
msgid "Unbounded Channels"
msgstr "무경계 채널"

#: src/SUMMARY.md:342 src/concurrency/channels/bounded.md:1
msgid "Bounded Channels"
msgstr "경계 채널"

#: src/SUMMARY.md:343 src/concurrency/send-sync.md:1
msgid "`Send` and `Sync`"
msgstr "`Send`와 `Sync`"

#: src/SUMMARY.md:344 src/concurrency/send-sync/send.md:1
msgid "`Send`"
msgstr "`Send`"

#: src/SUMMARY.md:345 src/concurrency/send-sync/sync.md:1
msgid "`Sync`"
msgstr "`Sync`"

#: src/SUMMARY.md:346 src/concurrency/send-sync/examples.md:1
msgid "Examples"
msgstr "예제"

#: src/SUMMARY.md:347 src/concurrency/shared_state.md:1
msgid "Shared State"
msgstr "상태 공유"

#: src/SUMMARY.md:348 src/concurrency/shared_state/arc.md:1
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md:349 src/concurrency/shared_state/mutex.md:1
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/SUMMARY.md:350 src/memory-management/review.md:16
#: src/error-handling/try-conversions.md:23
#: src/concurrency/shared_state/example.md:1
msgid "Example"
msgstr "예제"

#: src/SUMMARY.md:352 src/SUMMARY.md:374
#: src/exercises/concurrency/dining-philosophers.md:1
#: src/exercises/concurrency/solutions-morning.md:3
msgid "Dining Philosophers"
msgstr "식사하는 철학자들"

#: src/SUMMARY.md:353 src/exercises/concurrency/link-checker.md:1
msgid "Multi-threaded Link Checker"
msgstr "멀티스레드 링크 검사기"

#: src/SUMMARY.md:356
msgid "Concurrency: Afternoon"
msgstr "동시성 오후"

#: src/SUMMARY.md:358
msgid "Async Basics"
msgstr "비동기 관련 기본사항"

#: src/SUMMARY.md:359 src/async/async-await.md:1
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/SUMMARY.md:360 src/async/futures.md:1
msgid "Futures"
msgstr "Future"

#: src/SUMMARY.md:361 src/async/runtimes.md:1
msgid "Runtimes"
msgstr "비동기 런타임들"

#: src/SUMMARY.md:362 src/async/runtimes/tokio.md:1
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md:363 src/exercises/concurrency/link-checker.md:127
#: src/async/tasks.md:1 src/exercises/concurrency/chat-app.md:143
msgid "Tasks"
msgstr "태스크"

#: src/SUMMARY.md:364 src/async/channels.md:1
msgid "Async Channels"
msgstr "비동기 채널"

#: src/SUMMARY.md:365
msgid "Control Flow"
msgstr "흐름 제어"

#: src/SUMMARY.md:366 src/async/control-flow/join.md:1
msgid "Join"
msgstr "Join"

#: src/SUMMARY.md:367 src/async/control-flow/select.md:1
msgid "Select"
msgstr "Select"

#: src/SUMMARY.md:368
msgid "Pitfalls"
msgstr "함정"

#: src/SUMMARY.md:369
msgid "Blocking the Executor"
msgstr "Executor 블로킹 하기"

#: src/SUMMARY.md:370 src/async/pitfalls/pin.md:1
msgid "`Pin`"
msgstr ""

#: src/SUMMARY.md:371 src/async/pitfalls/async-traits.md:1
msgid "Async Traits"
msgstr "비동기 트레잇"

#: src/SUMMARY.md:372 src/async/pitfalls/cancellation.md:1
msgid "Cancellation"
msgstr "취소"

#: src/SUMMARY.md:375 src/exercises/concurrency/chat-app.md:1
#: src/exercises/concurrency/solutions-afternoon.md:95
msgid "Broadcast Chat Application"
msgstr "채팅 애플리케이션"

#: src/SUMMARY.md:378
msgid "Final Words"
msgstr "끝으로..."

#: src/SUMMARY.md:382 src/thanks.md:1
msgid "Thanks!"
msgstr "감사인사"

#: src/SUMMARY.md:383 src/glossary.md:1
msgid "Glossary"
msgstr ""

#: src/SUMMARY.md:384
msgid "Other Resources"
msgstr "러스트 참고 자료"

#: src/SUMMARY.md:385 src/credits.md:1
msgid "Credits"
msgstr "도와주신 분들"

#: src/index.md:3
#, fuzzy
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors)"

#: src/index.md:7
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"이 강의는 무료이며, Google의 Android 팀이 만들었습니다. 기본 문법부터 제네"
"릭, 에러 핸들링과 같은 고급주제까지 러스트의 모든 것을 포함합니다."

#: src/index.md:11
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""

#: src/index.md:15
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"강의는 당신이 러스트에 대해서 아무것도 모른다고 가정하고 아래의 목표를 가지"
"고 있습니다:"

#: src/index.md:18
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "러스트 구문과 언어에 대한 포괄적인 이해를 제공합니다."

#: src/index.md:19
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr "기존 프로그램을 수정하고 러스트에서 새 프로그램을 작성할 수 있습니다."

#: src/index.md:20
msgid "Show you common Rust idioms."
msgstr "일반적인 러스트 관용구를 보여줍니다."

#: src/index.md:22
#, fuzzy
msgid "We call the first four course days Rust Fundamentals."
msgstr "강의의 첫 3일 동안에는 Rust의 기초를 다집니다."

#: src/index.md:24
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr "그 후에는, 아래와 같은 개별 주제를 심화해서 공부할 수 있습니다:"

#: src/index.md:26
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md): Android 플랫폼 개발(AOSP) 시 Rust 사용에 관한 반나절 "
"과정입니다. 여기에는 C, C++, Java와의 상호 운용성이 포함됩니다."

#: src/index.md:28
#, fuzzy
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[Android](android.md): Android 플랫폼 개발(AOSP) 시 Rust 사용에 관한 반나절 "
"과정입니다. 여기에는 C, C++, Java와의 상호 운용성이 포함됩니다."

#: src/index.md:31
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md): bare-metal(임베디드) 개발 시 Rust 사용에 관한 종"
"일 과정입니다. 마이크로컨트롤러와 애플리케이션 프로세서를 모두 다룹니다."

#: src/index.md:34
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[동시성](concurrency.md): Rust의 동시성에 관한 종일 과정입니다. 여기서는 고전"
"적인 동시성(스레드와 뮤텍스를 사용하여 선점형 스케줄링을 하는 것)과 async/"
"await 동시성(future를 사용하는 협력적인 멀티태스킹)을 모두 다룹니다."

#: src/index.md:38
msgid "Non-Goals"
msgstr "제외사항"

#: src/index.md:40
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"러스트는 며칠만에 모든 것을 다루기에는 너무 큰 언어입니다. 그래서 아래와 같은"
"것을 목표로 하지 않습니다:"

#: src/index.md:43
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"매크로 만들기: 매크로와 관련한 자세한 내용은 [러스트 프로그래밍 언어, 19.1절]"
"(https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)과 [Rustonomicon]"
"(https://doc.rust-lang.org/nomicon/)를 참조하세요."

#: src/index.md:48
msgid "Assumptions"
msgstr "독자 수준에 대한 가정"

#: src/index.md:50
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"본 강의는 여러분이 프로그래밍 자체에 대해서는 알고 있다고 가정합니다. 러스트"
"는 정적타입 언어이며, 강좌에서는 C/C++ 와의 비교, 대조를 통해 러스트를 설명"
"할 것입니다."

#: src/index.md:54
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"C/C++을 모르더라도 동적 타입 언어(Python이나 JavaScript 등) 프로그래밍 경험"
"이 있다면 따라오는데 큰 문제는 없을 것입니다."

#: src/index.md:59
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"이것은 \"발표자 노트\"의 예제입니다. 이 부분을 이용해서 추가 정보를 제공합니"
"다. 주로 강의실에서 제기되는 일반적인 질문에 대한 답변과 강사가 다루어야 할 "
"키 포인트일 수 있습니다."

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "This page is for the course instructor."
msgstr "강사를 위한 안내 페이지입니다."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"다음은 구글 내부에서 이 과정을 어떤식으로 운영해왔는지에 대한 배경 정보입니"
"다."

#: src/running-the-course.md:8
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""

#: src/running-the-course.md:13
msgid "Before you run the course, you will want to:"
msgstr "강의를 실행하기 위한 준비:"

#: src/running-the-course.md:15
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"강의 자료를 숙지합니다. 주요 요점을 강조하기 위해 강의 참조 노트를 포함하였습"
"니다. (추가적인 노트를 작성하여 제공해 주시면 감사하겠습니다.) 강의 참조 노트"
"의 링크를 누르면 별도의 팝업으로 분리가 되며, 메인 화면에서는 사라집니다. 깔"
"끔한 화면으로 강의를 진행할 수 있습니다."

#: src/running-the-course.md:21
#, fuzzy
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"강의 날짜를 정합니다. 최소 3일에 걸쳐서 진행이 되기 때문에, 두 주에 걸쳐서 스"
"케줄을 잡는 것을 권합니다. 기존 강의 수강생들의 피드백에 따르면, 연달아서 강"
"의를 진행하는 것 보다, 강의를 띄엄띄엄 하는 것이 강의 내용을 소화하는데 더 도"
"움이 되었다고 합니다."

#: src/running-the-course.md:26
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"충분한 공간을 확보합니다. 15에서 20명 규모의 공간을 추천합니다. 수강생과 강사"
"가 질의를 하기에 충분한 시간과 공간이어야 합니다. 강사나 수강생 모두 \\_책상_"
"을 사용할 수 있는 강의실이면 좋습니다. 강의 중에 강사가 라이브 코딩을 하게 "
"될 경우가 많으며, 이때 자리에 앉아 노트북을 사용하는 것이 도움이 됩니다."

#: src/running-the-course.md:34
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"강의 당일 조금 일찍 와서 준비합니다. 강사 노트북에서 `mdbook serve`를 이용해 "
"직접 프레젠테이션 하면 페이지 이동 시의 지연이 없습니다.([설치 방법](https://"
"github.com/google/comprehensive-rust#building)을 참조하세요.) 또한, 그렇게 하"
"면 강의 도중 오타를 발견했을 때 그 자리에서 바로 수정 가능하다는 장점도 있습"
"니다."

#: src/running-the-course.md:40
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"수강생들이 직접 (개별 혹은 그룹으로) 연습문제를 풀도록 합니다. 대체로 오전, "
"오후에 각각 30-45분 정도를 연습문제에 할당합니다 (이는 해답을 보고 설명하는 "
"시간까지 포함합니다). 막혀 도움을 필요로 하는 수강생이 없는지 수시로 확인합니"
"다. 만약 같은 문제를 여러 사람이 겪고 있다면, 그 문제를 강의실 전체 인원에게 "
"알리고 해결책을 제시합니다. 예를 들어 표준 라이브러리 어디에 가면 그 문제에 "
"대한 해답을 찾을 수 있는지 알려 줍니다."

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"이제 준비는 끝났습니다. 우리가 그랬듯이 여러분들도 이 강의를 즐기시길 바랍니"
"다!"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"강의를 계속 개선할 수 있도록 [피드백](https://github.com/google/"
"comprehensive-rust/discussions/86)을 제공해 주십시오. 우리는 무엇이 좋았고, "
"무엇이 모자랐는지 듣고 싶습니다. 수강생들로 부터의 [피드백](https://github."
"com/google/comprehensive-rust/discussions/100)도 환영합니다!"

#: src/running-the-course/course-structure.md:5
#, fuzzy
msgid "Rust Fundamentals"
msgstr "러스트 바이너리"

#: src/running-the-course/course-structure.md:7
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""

#: src/running-the-course/course-structure.md:10
msgid "{{%course outline Fundamentals}}"
msgstr ""

#: src/running-the-course/course-structure.md:12
msgid "Deep Dives"
msgstr "심화 학습"

#: src/running-the-course/course-structure.md:14
#, fuzzy
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr "Rust 기초에 관한 3일 과정 이후에는, 다음과 같은 전문 주제를 다룹니다:"

#: src/running-the-course/course-structure.md:17
#, fuzzy
msgid "Rust in Android"
msgstr "1일차 개요"

#: src/running-the-course/course-structure.md:19
#, fuzzy
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Android 심화 학습](../android.md)는 Android 플랫폼 개발 시 Rust 사용에 관한 "
"반나절 과정입니다. 여기에는 C, C++, Java와의 상호 운용성이 포함됩니다."

#: src/running-the-course/course-structure.md:23
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"[AOSP 코드](https://source.android.com/docs/setup/download/downloading)를 여"
"러분의 컴퓨터에 체크아웃해야 합니다. 그런 다음, 그 컴퓨터에서 [과정 저장소]"
"(https://github.com/google/comprehensive-rust)를 체크아웃하고 `src/android/` "
"디렉터리를 AOSP 코드의 루트로 이동합니다. 이렇게 하면 안드로이드 빌드 시스템"
"에서 과제용으로 추가된 `Android.bp`파일을 인식할 수 있습니다."

#: src/running-the-course/course-structure.md:28
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"`adb sync` 명렁어가 에뮬레이터 혹은 실제 장치와 작동하는지 확인합니다. 그리"
"고 `src/android/build_all.sh`를 수행해서 모든 안드로이드 예제를 미리 빌드해 "
"보세요. 그 쉘 스크립트를 읽고, 그 안에서 수행되는 명령어들을 확인한 후 각 명"
"령어들을 수동으로 실행해도 잘 되는지 확인하세요."

#: src/running-the-course/course-structure.md:35
#, fuzzy
msgid "Rust in Chromium"
msgstr "Rust on Exercism"

#: src/running-the-course/course-structure.md:37
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""

#: src/running-the-course/course-structure.md:42
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""

#: src/running-the-course/course-structure.md:46
#, fuzzy
msgid "Bare-Metal Rust"
msgstr "Bare-Metal"

#: src/running-the-course/course-structure.md:48
#, fuzzy
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[Bare-Metal 심화 학습](../bare-metal.md): bare-metal(임베디드) 개발 시 Rust "
"사용에 관한 종일 과정입니다. 마이크로컨트롤러와 애플리케이션 프로세서를 모두 "
"다룹니다."

#: src/running-the-course/course-structure.md:52
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"마이크로컨트롤러 파트를 진행하기 위해서는 [BBC micro:bit](https://microbit."
"org/) v2 개발 보드를 미리 구매해야 합니다. 모든 사용자는 [시작 페이지](../"
"bare-metal.md)에 설명된 대로 각종 패키지를 설치해야 합니다."

#: src/running-the-course/course-structure.md:57
#, fuzzy
msgid "Concurrency in Rust"
msgstr "Welcome to Comprehensive Rust 🦀"

#: src/running-the-course/course-structure.md:59
#, fuzzy
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[동시성 심화학습](../concurrency.md)은 고전적인 동시성 및 `async`/`await` 동"
"시성을 다루는 종일 과정입니다."

#: src/running-the-course/course-structure.md:62
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"새 크레이트를 설정하고 몇 가지 의존성을 다운로드해 두어야 합니다. 그런 다음 "
"예제를 `src/main.rs`에 복사/붙여넣기 하여 테스트 해 볼 수 있습니다:"

#: src/running-the-course/course-structure.md:73
msgid "Format"
msgstr "강의 형식"

#: src/running-the-course/course-structure.md:75
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"이 강의는 강사와 수강생이 양방향으로 소통하면서 진행하도록 디자인 되었습니"
"다. 다양한 질문을 통해 러스트의 여러 부분을 탐험할 수 있도록 하세요!"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "다음은, mdBook 시스템(현 사이트)에서 유용한 단축키들 입니다:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid "Arrow-Left"
msgstr "왼쪽 화살표"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ": Navigate to the previous page."
msgstr ": 이전 페이지로 이동합니다."

#: src/running-the-course/keyboard-shortcuts.md:6
msgid "Arrow-Right"
msgstr "오른쪽 화살표"

#: src/running-the-course/keyboard-shortcuts.md:6
msgid ": Navigate to the next page."
msgstr ": 다음 페이지로 이동합니다."

#: src/running-the-course/keyboard-shortcuts.md:7 src/cargo/code-samples.md:19
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md:7
msgid ": Execute the code sample that has focus."
msgstr ": 현재 포커스를 받은 코드 샘플 블록을 실행합니다."

#: src/running-the-course/keyboard-shortcuts.md:8
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md:8
msgid ": Activate the search bar."
msgstr ""
": 검색창을 활성화합니다.(mdBook 문제로 23.01.19 기준 영어로만 가능합니다.)"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"이 과정은 다른 언어로도 제공됩니다. 괄호 안은 번역에 도움 주신 분들입니다:"

#: src/running-the-course/translations.md:6
#, fuzzy
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[브라질 포르투갈어](https://google.github.io/comprehensive-rust/pt-BR/): "
"[@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) 그리고 "
"[@henrif75](https://github.com/henrif75)가 제공."

#: src/running-the-course/translations.md:8
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""

#: src/running-the-course/translations.md:10
#, fuzzy
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[브라질 포르투갈어](https://google.github.io/comprehensive-rust/pt-BR/): "
"[@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) 그리고 "
"[@henrif75](https://github.com/henrif75)가 제공."

#: src/running-the-course/translations.md:12
#, fuzzy
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""
"[한국어](https://google.github.io/comprehensive-rust/ko/): [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) 그리고 "
"[@jooyunghan](https://github.com/jooyunghan)가 제공."

#: src/running-the-course/translations.md:13
#, fuzzy
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[벵갈어](https://google.github.io/comprehensive-rust/bn/): [@raselmandol]"
"(https://github.com/raselmandol) 제공."

#: src/running-the-course/translations.md:15
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr "페이지 오른쪽 위의 메뉴를 통해 다른 언어로 전환할 수 있습니다."

#: src/running-the-course/translations.md:17
msgid "Incomplete Translations"
msgstr "번역 문제"

#: src/running-the-course/translations.md:19
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"진행 중인 번역이 많습니다. 최근에 업데이트된 번역본으로 연결되는 링크는 다음"
"과 같습니다:"

#: src/running-the-course/translations.md:22
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[벵갈어](https://google.github.io/comprehensive-rust/bn/): [@raselmandol]"
"(https://github.com/raselmandol) 제공."

#: src/running-the-course/translations.md:23
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""
"[프랑스어](https://google.github.io/comprehensive-rust/fr/): [@KookaS]"
"(https://github.com/KookaS) 및 [@vcaen](https://github.com/vcaen) 제공."

#: src/running-the-course/translations.md:24
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[독일어](https://google.github.io/comprehensive-rust/de/): [@Throvn](https://"
"github.com/Throvn) 및 [@ronaldfw](https://github.com/ronaldfw) 제공."

#: src/running-the-course/translations.md:25
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[일본어](https://google.github.io/comprehensive-rust/ja/): [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) 및 [@momotaro1105](https://github.com/"
"momotaro1105) 제공."

#: src/running-the-course/translations.md:27
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"이 과정의 번역 작업에 도움을 주고 싶다면 [여기](https://github.com/google/"
"comprehensive-rust/blob/main/TRANSLATIONS.md) 설명된 내용을 참고하세요. 진행 "
"중인 번역 작업에 대한 내용은 [이슈 트래커](https://github.com/google/"
"comprehensive-rust/issues/282)를 참고하세요."

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"러스트를 시작하려고하면 당신은 곧 [Cargo](https://doc.rust-lang.org/cargo/)라"
"는, 러스트 생태계에서 사용하는 표준 빌드/실행 도구를 만날 것 입니다. 여기서"
"는 카고가 무엇인지, 그리고 카고가 러스트 생태계에서 어떤 역할을 하는지, 그리"
"고 이 강의에서 어떻게 사용될 지에 대해 간략히 설명하겠습니다."

#: src/cargo.md:9
msgid "Installation"
msgstr "설치하기"

#: src/cargo.md:11
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**<https://rustup.rs/>의 설치 방법을 따르세요.**"

#: src/cargo.md:13
#, fuzzy
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"위 설치 방법을 따르면, 빌드 시스템인 카고(`cargo`)와 러스트 컴파일러(`rustc`)"
"가 설치됩니다. 이와 함께, `rustup`도 설치되는데 이 툴은 툴체인을 설치하고, 다"
"른 툴체인으로 전환하고, 크로스 컴파일 설정을 하는 일을 담당하는 커맨드 라인 "
"유틸리티 입니다."

#: src/cargo.md:17
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""

#: src/cargo.md:25
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"데비안/우분투 시스템에서는 `apt`를 이용해서 카고, 러스트 소스, [러스트 포매"
"터](https://github.com/rust-lang/rustfmt)를 설치할 수 있습니다. 그러나 이 방"
"법을 따를 경우 최신 버전이 아닌 러스트를 사용게되며, 그 결과 예상치 못한 문제"
"를 겪을 수도 있습니다. 설치 명령어는 아래와 같습니다:"

#: src/cargo/rust-ecosystem.md:1
msgid "The Rust Ecosystem"
msgstr "러스트 생태계"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"러스트의 생태계는 여러가지 도구들로 구성되어 있으며, 그 중 중요한 것들은 아래"
"와 같습니다:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: `.rs` 확장자 파일을 바이너리 혹은 다른 중간 형식으로 변환해주는 "
"Rust 컴파일러입니다."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: 러스트 의존성 관리자이자 빌드 시스템 입니다. 여러분의 프로젝트에 명"
"시된 의존성들을 <https://crates.io>에서 자동으로 다운로드 받고, 그 소스코드"
"를 `rustc`로 전달하여 빌드를 시킵니다. 또한 유닛 테스트를 실행하는 테스트 러"
"너를 내장하고 있습니다."

#: src/cargo/rust-ecosystem.md:13
#, fuzzy
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: 러스트 툴체인 설치 프로그램이자 업데이트 프로그램 입니다. 이 도구"
"는 새 버전의 러스트가 출시될 때 `rustc` 및 `cargo` 설치하고 업데이트하는 데 "
"사용됩니다. 또한 `rustup`은 표준 라이브러리에 대한 문서를 다운로드할 수도 있"
"습니다. 한 번에 여러 버전의 러스트를 설치할 수 있으며 `rustup`을 이용해서 실"
"제로 사용할 버전을 변경할 수 있습니다."

#: src/cargo/rust-ecosystem.md:21 src/hello-world/hello-world.md:25
#: src/tuples-and-arrays/tuples-and-arrays.md:38 src/references/exclusive.md:19
#: src/pattern-matching/destructuring.md:68 src/memory-management/move.md:152
#: src/error-handling/try.md:52 src/android/setup.md:18
#: src/concurrency/threads.md:30 src/async/async-await.md:25
msgid "Key points:"
msgstr "키 포인트:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"러스트는 6주마다 새로운 릴리즈가 발표되며 이전 릴리즈와의 호환성을 유지하고 "
"있습니다."

#: src/cargo/rust-ecosystem.md:27
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"릴리즈는 3가지 버전으로 제공됩니다: \"stable\", \"beta\" 그리고 \"nightly\"."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"새로운 기능은 \"nightly\" -> \"beta\" -(6주 후)-> \"stable\" 로 변경됩니다."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"의존성은 다양한 [저장소](registries), git 프로젝트, 디렉터리 등에서 제공될 "
"수 있습니다."

#: src/cargo/rust-ecosystem.md:35
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"러스트는 [에디션](https://doc.rust-lang.org/edition-guide/)으로 구분됩니다. "
"현재는 Rust 2021 에디션입니다. 이 전 에디션으로 Rust 2015와 Rust 2018이 있습"
"니다."

#: src/cargo/rust-ecosystem.md:38
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr "에디션은 이전 에디션과 호환이 되지 않을 수 있습니다."

#: src/cargo/rust-ecosystem.md:41
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"에디션이 바뀌면서 프로그램이 의도치 않게 깨지는 문제를 막기 위해, 각 프로그램"
"은 자신이 빌드될 에디션을 명시적으로 `Cargo.toml`에 지정해야 합니다."

#: src/cargo/rust-ecosystem.md:44
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"러스트 생태계가 에디션 별로 파편회 되는 것을 막기 위해, 러스트 컴파일러는 서"
"로 다른 에디션에서 작성된 코드들을 하나의 바이너리로 묶을 수 있습니다."

#: src/cargo/rust-ecosystem.md:47
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"`cargo`를 사용하지 않고 컴파일러를 직접 사용하는 경우는 거의 없음을 언급해 주"
"시기 바랍니다."

#: src/cargo/rust-ecosystem.md:50
#, fuzzy
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr ""
"카고 자체가 매우 강력하고 포괄적인 도구임을 적극적으로 알리세요. 카고는 다음"
"과 같은 다양한 고급 기능을 제공합니다: "

#: src/cargo/rust-ecosystem.md:53
msgid "Project/package structure"
msgstr "프로젝트/패키지 구조화"

#: src/cargo/rust-ecosystem.md:54
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[워크스페이스](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md:55
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "개발/런타임 종속성 관리 및 캐싱"

#: src/cargo/rust-ecosystem.md:56
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[빌드 스크립트](https://doc.rust-lang.org/cargo/reference/build-scripts.html)"

#: src/cargo/rust-ecosystem.md:57
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[전역 설치](https://doc.rust-lang.org/cargo/commands/cargo-install.html)"

#: src/cargo/rust-ecosystem.md:58
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"[cargo clippy](https://github.com/rust-lang/rust-clippy)와 같은 하위 플러그인"
"으로 확장 가능."

#: src/cargo/rust-ecosystem.md:60
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"[공식 Cargo Book](https://doc.rust-lang.org/cargo/)에서 자세한 사항을 확인하"
"시기 바랍니다."

#: src/cargo/code-samples.md:1
msgid "Code Samples in This Training"
msgstr "강의에서의 코드 샘플"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"이 강의자료에 있는 모든 예제는 브라우저에서 바로 수행 가능합니다. 이렇게 한 "
"이유는, 준비 과정을 단순화 시키고, 모두가 같은 환경에서 작업할 수 있도록 하"
"기 위함입니다."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"그럼에도 불구하고, 카고(cargo)를 직접 설치하는 것을 강력 권장합니다. 이게 과"
"제 작성에 더 도움이 될겁니다. 또한, 마지막 날에는 의존성이 있는 예제를 작업하"
"게 될 텐데, 그 때에는 어차피 카고가 필요합니다."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "이 강의 자료의 코드 블록들은 전부 인터엑티브 합니다:"

#: src/cargo/code-samples.md:15 src/cargo/running-locally.md:46
msgid "\"Edit me!\""
msgstr ""

#: src/cargo/code-samples.md:19
msgid "You can use "
msgstr "코드 블록에 포커스를 두고 "

#: src/cargo/code-samples.md:19
msgid " to execute the code when focus is in the text box."
msgstr " 를 눌러 실행해 볼 수 있습니다."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"강의에서 대부분의 코드 샘플은 위와 같이 수정할수 있지만 일부 코드는 다음과 같"
"은 이유로 수정할 수 없습니다:"

#: src/cargo/code-samples.md:27
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"유닛 테스트는 내장 플레이그라운드에서 실행이 안됩니다. 외부 플레이그라운드 사"
"이트에 붙여넣어 테스트를 실행하시기 바랍니다."

#: src/cargo/code-samples.md:30
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"내장된 플레이그라운드에서는 페이지 이동시 작성된 모든 내용이 사라집니다. 따라"
"서 로컬 환경이나 외부 플레이그라운드 사이트에서 연습문제를 해결하는 것이 좋습"
"니다."

#: src/cargo/running-locally.md:1
msgid "Running Code Locally with Cargo"
msgstr "로컬 환경의 카고"

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"만약 개인용 컴퓨터에서 코드를 실행해보려면 먼저 러스트를 설치해야 합니다. "
"[Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html)의 지침"
"에 따라 `rustc`와 `cargo`를 함께 설치 하시기 바랍니다. 설치 후 아래 커맨드를 "
"통해 각 툴의 버전을 확인 할 수 있습니다:"

#: src/cargo/running-locally.md:16
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"이 버전보다 더 최신의 버전이어도 상관 없습니다. 러스트는 하위 호환성을 지원합"
"니다."

#: src/cargo/running-locally.md:18
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"정상적으로 설치가 되었으면, 강의 예제중 하나를 러스트 바이너리로 빌드해 봅시"
"다:"

#: src/cargo/running-locally.md:21
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "예시 블록에 있는 \"Copy to clipboard\" 버튼을 클릭해서 복사합니다."

#: src/cargo/running-locally.md:23
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"터미널에서 `cargo new exercise`를 입력해서 새로운 `exercise/` 폴더를 만듭니"
"다:"

#: src/cargo/running-locally.md:30
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr "`exercise/` 폴더로 이동한 후, `cargo run` 커맨드로 코드를 실행합니다:"

#: src/cargo/running-locally.md:41
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"`src/main.rs`에 코드를 작성합니다. 예를 들어 이전 페이지의 소스를 아래와 같"
"이 `src/main.rs`에 작성합니다"

#: src/cargo/running-locally.md:50
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "`cargo run`커맨드로 소스를 빌드하고 실행합니다:"

#: src/cargo/running-locally.md:60
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"`cargo check`커맨드는 빠르게 에러를 확인할 수 있습니다. `cargo build`는 실행"
"없이 컴파일만 합니다. 이 경우에 `target/debug/`폴더에서 output을 확인 할 수 "
"있습니다. `cargo build --release`커맨드는 릴리즈 버전용 최적화를 켜서 컴파일"
"하며 `target/release/`폴더에서 확인 할 수 있습니다."

#: src/cargo/running-locally.md:65
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"`Cargo.toml`파일에는 의존성 패키지를 추가할 수 있습니다. `cargo`커맨드를 실행"
"하면 자동으로 의존성 패키지를 다운로드하고 컴파일 까지 해 줍니다."

#: src/cargo/running-locally.md:73
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"수강생들이 카고를 설치하고 로컬 편집기를 이용하도록 독려하세요. 조금 귀찮을 "
"수도 있지만, 이렇게 해야만 좀 더 실제와 가까운 개발환경을 갖추게 되는 것입니"
"다."

#: src/welcome-day-1.md:1
msgid "Welcome to Day 1"
msgstr "1일차 개요"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr "강의 첫 날입니다. 오늘 배울 것이 참 많습니다:"

#: src/welcome-day-1.md:5
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"러스트 기본 문법: 변수, 스칼라 / 복합 타입, 열거형, 구조체, 참조형, 함수와 메"
"서드."

#: src/welcome-day-1.md:7
#, fuzzy
msgid "Types and type inference."
msgstr "타입 추론"

#: src/welcome-day-1.md:8
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr ""

#: src/welcome-day-1.md:9
msgid "User-defined types: structs and enums."
msgstr ""

#: src/welcome-day-1.md:10
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr "패턴 매칭: 열거형, 구조체 그리고 배열 분해."

#: src/welcome-day-1.md:12 src/welcome-day-2.md:12 src/welcome-day-3.md:9
#: src/welcome-day-4.md:11
msgid "Schedule"
msgstr ""

#: src/welcome-day-1.md:14 src/welcome-day-1-afternoon.md:3
#: src/welcome-day-2.md:14 src/welcome-day-2-afternoon.md:3
#: src/welcome-day-3.md:11 src/welcome-day-3-afternoon.md:3
#: src/welcome-day-4.md:13 src/welcome-day-4-afternoon.md:3
msgid "{{%session outline}}"
msgstr ""

#: src/welcome-day-1.md:18
msgid "Please remind the students that:"
msgstr "학생들에게 다음을 상기시켜 주시기 바랍니다:"

#: src/welcome-day-1.md:20
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr "궁금한 점이 있으면 주저하지 말고 질문 해야 합니다."

#: src/welcome-day-1.md:21
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr "이 수업은 상호작용이 요합니다. 토론을 망설이지 마세요!"

#: src/welcome-day-1.md:22
#, fuzzy
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"강사로서 토론이 옆길로 새지 않게 주의하세요. 예를 들어 러스트와 다른 언어들"
"을 비교한다든지 하는 것은 좋습니다. 적절한 균형을 찾기 애매한 경우라면 토론"
"을 허용하는 쪽이 일방적인 강의보다는 더 많은 사람들의 참여를 이끌어 낼 수 있"
"습니다."

#: src/welcome-day-1.md:26
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr "질문이 슬라이드보다 앞서가도 괜찮습니다."

#: src/welcome-day-1.md:27
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"학습에 있어서 반복은 매우 중요합니다. 슬라이드는 그저 도움을 줄 뿐, 원하는 대"
"로 건너띄어도 됩니다."

#: src/welcome-day-1.md:31
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""

#: src/welcome-day-1.md:35
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""

#: src/hello-world.md:3 src/types-and-values.md:3 src/control-flow-basics.md:3
#: src/tuples-and-arrays.md:3 src/references.md:3 src/user-defined-types.md:3
#: src/pattern-matching.md:3 src/methods-and-traits.md:3 src/generics.md:3
#: src/std-types.md:3 src/std-traits.md:3 src/memory-management.md:3
#: src/smart-pointers.md:3 src/borrowing.md:3 src/slices-and-lifetimes.md:3
#: src/iterators.md:3 src/modules.md:3 src/testing.md:3 src/error-handling.md:3
#: src/unsafe-rust.md:3
msgid "{{%segment outline}}"
msgstr ""

#: src/hello-world/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"러스트는 2015년에 [버전 1.0](https://blog.rust-lang.org/2015/05/15/Rust-1.0."
"html)을 릴리즈 한 새로운 프로그램 언어입니다:"

#: src/hello-world/what-is-rust.md:5
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "러스트는 C++와 유사한 정적 컴파일 언어입니다"

#: src/hello-world/what-is-rust.md:6
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc`는 LLVM을 백엔드로 사용합니다."

#: src/hello-world/what-is-rust.md:7
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr "러스트는 다양한 플랫폼과 아키텍쳐를 지원합니다:"

#: src/hello-world/what-is-rust.md:9
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/hello-world/what-is-rust.md:10
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/hello-world/what-is-rust.md:11
msgid "Rust is used for a wide range of devices:"
msgstr "러스트는 다양한 장치에서 사용될 수 있습니다:"

#: src/hello-world/what-is-rust.md:12
msgid "firmware and boot loaders,"
msgstr "펌웨어와 부트로더(임베디드)"

#: src/hello-world/what-is-rust.md:13
msgid "smart displays,"
msgstr "스마트 디스플레이,"

#: src/hello-world/what-is-rust.md:14
msgid "mobile phones,"
msgstr "스마트폰,"

#: src/hello-world/what-is-rust.md:15
msgid "desktops,"
msgstr "데스크탑,"

#: src/hello-world/what-is-rust.md:16
msgid "servers."
msgstr "서버."

#: src/hello-world/what-is-rust.md:20
msgid "Rust fits in the same area as C++:"
msgstr "러스트는 C++가 사용되는 대부분의 곳에서 사용 가능합니다:"

#: src/hello-world/what-is-rust.md:22
msgid "High flexibility."
msgstr "높은 유연성."

#: src/hello-world/what-is-rust.md:23
msgid "High level of control."
msgstr "높은 수준의 제어."

#: src/hello-world/what-is-rust.md:24
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr "마이크로컨트롤러 같은 매우 제한된 장치로 스케일 다운 가능."

#: src/hello-world/what-is-rust.md:25
msgid "Has no runtime or garbage collection."
msgstr "별도의 런타임을 필요로 하지 않으며, 가비지 컬렉션도 없음."

#: src/hello-world/what-is-rust.md:26
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr "성능을 타협하지 않으면서도 안정성과 안전에 중점을 둠."

#: src/hello-world/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"가장 간단한 러스트 프로그램으로써, 고전적인 Hello World 를 작성해 보겠습니다:"

#: src/hello-world/hello-world.md:8
msgid "\"Hello 🌍!\""
msgstr ""

#: src/hello-world/hello-world.md:12
msgid "What you see:"
msgstr "확인할 수 있는 것들:"

#: src/hello-world/hello-world.md:14
msgid "Functions are introduced with `fn`."
msgstr "함수는 `fn`으로 선언합니다."

#: src/hello-world/hello-world.md:15
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "C/C++ 와 마찬가지로 중괄호`{}`로 블록을 표시합니다."

#: src/hello-world/hello-world.md:16
msgid "The `main` function is the entry point of the program."
msgstr "`main` 함수는 프로그램 진입점입니다."

#: src/hello-world/hello-world.md:17
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr ""
"러스트는 똑똑한 매크로(hygienic macros) 시스템을 가지고 있습니다. `println!`"
"는 그 예시입니다."

#: src/hello-world/hello-world.md:18
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"러스트의 문자열은 UTF-8로 인코딩되며 이모지와 같은 유니코드 문자를 포함할 수 "
"있습니다."

#: src/hello-world/hello-world.md:22
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"이 슬라이드는 학생들이 러스트 코드에 익숙해지기 위해 작성되었습니다. 앞으로 3"
"일 동안 많은 코드를 접할 것이기 때문에 우선 친숙한 코드부터 시작합니다."

#: src/hello-world/hello-world.md:27
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"러스트는 C/C++/Java와 같은 전통적인 다른 언어와 매우 유사합니다. 러스트는 절"
"차적 언어입니다. 정말로 필요한 경우가 아니라면, 러스트는 이미 존재하는 것을 "
"새로 구현하려고 하지 않습니다."

#: src/hello-world/hello-world.md:30
msgid "Rust is modern with full support for things like Unicode."
msgstr "러스트는 유니코드 지원과 같은 현대 언어의 특징을 전부 지원합니다."

#: src/hello-world/hello-world.md:32
#, fuzzy
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"러스트는 인자의 개수를 사전에 지정할 수 없는 상황에서 함수 [오버로딩](basic-"
"syntax/functions-interlude.md)대신 매크로를 사용합니다."

#: src/hello-world/hello-world.md:35
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"똑똑한 매크로(hygienic macro)는 매크로가 사용되는 스코프에서 의도치 않게 변수"
"를 가로채지 않습니다. 사실 러스트 매크로는 완전히 hygenic하지는 않습니다. [링"
"크](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)를 참"
"고하세요."

#: src/hello-world/hello-world.md:39
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"러스트는 멀티 패러다임 언어입니다. 예를 들어 강력한 [객체 지향 프로그래밍 기"
"능](https://doc.rust-lang.org/book/ch17-00-oop.html)을 지원하기도 하며, 함수"
"형 언어로 분류되지는 않지만 폭넓은 범위의 [함수형 컨셉](https://doc.rust-"
"lang.org/book/ch13-00-functional-features.html)을 지원합니다."

#: src/hello-world/benefits.md:3
msgid "Some unique selling points of Rust:"
msgstr "러스트만의 독특한 세일즈 포인트(장점):"

#: src/hello-world/benefits.md:5
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr ""

#: src/hello-world/benefits.md:7
msgid "No uninitialized variables."
msgstr "초기화되지 않는 변수가 없습니다."

#: src/hello-world/benefits.md:8
msgid "No double-frees."
msgstr "메모리 이중 해제가 원천적으로 불가능 합니다."

#: src/hello-world/benefits.md:9
msgid "No use-after-free."
msgstr "메모리 해제 후 사용이 원천적으로 불가능 합니다."

#: src/hello-world/benefits.md:10
msgid "No `NULL` pointers."
msgstr "`NULL`포인터는 없습니다."

#: src/hello-world/benefits.md:11
msgid "No forgotten locked mutexes."
msgstr "뮤텍스를 잠궈 놓고 여는 것을 잊는 실수를 할 수 없습니다."

#: src/hello-world/benefits.md:12
msgid "No data races between threads."
msgstr "스레드간 데이터 레이스를 막아줍니다."

#: src/hello-world/benefits.md:13
msgid "No iterator invalidation."
msgstr "반복자가 갑자기 무효화 되는 경우가 없습니다."

#: src/hello-world/benefits.md:15
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr ""

#: src/hello-world/benefits.md:17
msgid "Array access is bounds checked."
msgstr "배열 접근시 경계 체크."

#: src/hello-world/benefits.md:18
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "정수형 타입의 변수에서 오버플로우 발생시 동작이 잘 정의되어있습니다."

#: src/hello-world/benefits.md:20
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr ""

#: src/hello-world/benefits.md:22
msgid "Enums and pattern matching."
msgstr "열거형과 패턴 매칭."

#: src/hello-world/benefits.md:23
msgid "Generics."
msgstr "제네릭."

#: src/hello-world/benefits.md:24
msgid "No overhead FFI."
msgstr "FFI 런타임 오버헤드 없음."

#: src/hello-world/benefits.md:25
msgid "Zero-cost abstractions."
msgstr "비용이 들지 않는 추상화."

#: src/hello-world/benefits.md:26
msgid "Great compiler errors."
msgstr "친절한 컴파일러 오류메시지."

#: src/hello-world/benefits.md:27
msgid "Built-in dependency manager."
msgstr "내장 종속성 관리자."

#: src/hello-world/benefits.md:28
msgid "Built-in support for testing."
msgstr "내장 테스트 지원."

#: src/hello-world/benefits.md:29
msgid "Excellent Language Server Protocol support."
msgstr "LSP (Language Server Protocol, 언어 서버 프로토콜) 지원이 잘되어 있음."

#: src/hello-world/benefits.md:33
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr ""

#: src/hello-world/benefits.md:36
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"수강생들에게 어떤 프로그래밍 언어를 사용했는지 물어보시기 바랍니다. 어떤 언어"
"를 사용했느냐에 따라 러스트에서 어떤 점을 강조해야 할지를 고민해 보세요:"

#: src/hello-world/benefits.md:39
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"C/C++: 러스트는 '빌림'검사기를 통해서 수행중에 발생할 수 있는 모든 에러를 제"
"거합니다. 러스트는 C와 C++과 비슷한 수준의 성능을 보여주면서도, 그 언어들에"
"서 종종 발생하는 메모리 관련 오류가 없습니다. 또한, 패턴 매칭이나, 기본적으"
"로 제공되는 종속성 관리와 같은 현대적인 언어의 기능들을 제공합니다."

#: src/hello-world/benefits.md:44
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Java, Go, Python, JavaScript: 이 언어들과 동일한 메모리 안정성과 함께, '하이"
"레벨'언어의 느낌을 느낄 수 있습니다. 거기에 더해, 가비지 컬렉터가 없는 C/C+"
"+와 유사한 수준의 빠르고 예측 가능한 성능을 기대할 수 있습니다. 그리고 필요"
"한 경우 저수준 하드웨어를 다루는 코드로 작성할 수 있습니다."

#: src/hello-world/playground.md:3
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""

#: src/hello-world/playground.md:8
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr ""

#: src/hello-world/playground.md:11
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""

#: src/hello-world/playground.md:15
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr ""

#: src/hello-world/playground.md:20
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""

#: src/types-and-values/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr ""
"러스트는 정적 타이핑을 통해 타입 안전성을 제공합니다. 변수는 기본적으로 불변"
"(immutable)합니다:"

#: src/types-and-values/variables.md:9 src/control-flow-basics/loops.md:30
#: src/control-flow-basics/break-continue.md:34
#: src/control-flow-basics/blocks-and-scopes.md:16
msgid "\"x: {x}\""
msgstr ""

#: src/types-and-values/variables.md:10
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""

#: src/types-and-values/variables.md:17
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""

#: src/types-and-values/variables.md:20
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""

#: src/types-and-values/values.md:3
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr ""

#: src/types-and-values/values.md:6
#: src/tuples-and-arrays/tuples-and-arrays.md:7 src/unsafe-rust/exercise.md:16
msgid "Types"
msgstr "타입"

#: src/types-and-values/values.md:6
#: src/tuples-and-arrays/tuples-and-arrays.md:7
msgid "Literals"
msgstr "리터럴 값"

#: src/types-and-values/values.md:8
msgid "Signed integers"
msgstr "부호있는 정수"

#: src/types-and-values/values.md:8
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/types-and-values/values.md:8
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`, `0`, `1_000`, `123_i64`"

#: src/types-and-values/values.md:9
msgid "Unsigned integers"
msgstr "부호없는 정수"

#: src/types-and-values/values.md:9
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/types-and-values/values.md:9
msgid "`0`, `123`, `10_u16`"
msgstr "`0`, `123`, `10_u16`"

#: src/types-and-values/values.md:10
msgid "Floating point numbers"
msgstr "부동소수"

#: src/types-and-values/values.md:10
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/types-and-values/values.md:10
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`, `-10.0e20`, `2_f32`"

#: src/types-and-values/values.md:11
msgid "Unicode scalar values"
msgstr "유니코드 문자"

#: src/types-and-values/values.md:11
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md:11
msgid "`'a'`, `'α'`, `'∞'`"
msgstr "`'a'`, `'α'`, `'∞'`"

#: src/types-and-values/values.md:12
msgid "Booleans"
msgstr "불리언"

#: src/types-and-values/values.md:12
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md:12
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/types-and-values/values.md:14
msgid "The types have widths as follows:"
msgstr "각 타입의 크기는 다음과 같습니다:"

#: src/types-and-values/values.md:16
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`, `fN`은 모두 _N_비트 입니다."

#: src/types-and-values/values.md:17
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` 와 `usize` 는 포인터와 같은 크기입니다,"

#: src/types-and-values/values.md:18
msgid "`char` is 32 bits wide,"
msgstr "`char` 32 비트 입니다,"

#: src/types-and-values/values.md:19
msgid "`bool` is 8 bits wide."
msgstr "`bool`은 8 비트 입니다."

#: src/types-and-values/values.md:23
msgid "There are a few syntaxes which are not shown above:"
msgstr "위에 표시되지 않은 몇 가지 문법이 있습니다:"

#: src/types-and-values/values.md:25
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."

#: src/types-and-values/arithmetic.md:9
msgid "\"result: {}\""
msgstr ""

#: src/types-and-values/arithmetic.md:15
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""

#: src/types-and-values/arithmetic.md:19
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr ""

#: src/types-and-values/arithmetic.md:21
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do different things on different platforms or "
"compilers. In Rust, it's defined."
msgstr ""

#: src/types-and-values/arithmetic.md:25
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""

#: src/types-and-values/arithmetic.md:30
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""

#: src/types-and-values/strings.md:3
msgid ""
"Rust has two types to represent strings, both of which will be covered in "
"more depth later. Both _always_ store UTF-8 encoded strings."
msgstr ""

#: src/types-and-values/strings.md:6
#, fuzzy
msgid "`String` - a modifiable, owned string."
msgstr "`String`은 문자열을 담을 수 있는 버퍼입니다."

#: src/types-and-values/strings.md:7
msgid "`&str` - a read-only string. String literals have this type."
msgstr ""

#: src/types-and-values/strings.md:11
msgid "\"Greetings\""
msgstr ""

#: src/types-and-values/strings.md:12
msgid "\"🪐\""
msgstr ""

#: src/types-and-values/strings.md:15
msgid "\", \""
msgstr ""

#: src/types-and-values/strings.md:17
msgid "\"final sentence: {}\""
msgstr ""

#: src/types-and-values/strings.md:18 src/async/control-flow/join.md:30
msgid "\"{:?}\""
msgstr ""

#: src/types-and-values/strings.md:19
msgid "//println!(\"{:?}\", &sentence[12..13]);\n"
msgstr ""

#: src/types-and-values/strings.md:25
msgid ""
"This slide introduces strings. Everything here will be covered in more depth "
"later, but this is enough for subsequent slides and exercises to use strings."
msgstr ""

#: src/types-and-values/strings.md:28
msgid "Invalid UTF-8 in a string is UB, and this not allowed in safe Rust."
msgstr ""

#: src/types-and-values/strings.md:30
msgid ""
"`String` is a user-defined type with a constructor (`::new()`) and methods "
"like `s.push_str(..)`."
msgstr ""

#: src/types-and-values/strings.md:33
msgid ""
"The `&` in `&str` indicates that this is a reference. We will cover "
"references later, so for now just think of `&str` as a unit meaning \"a read-"
"only string\"."
msgstr ""

#: src/types-and-values/strings.md:36
msgid ""
"The commented-out line is indexing into the string by byte position. "
"`12..13` does not end on a character boundary, so the program panics. Adjust "
"it to a range that does, based on the error message."
msgstr ""

#: src/types-and-values/strings.md:40
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"

#: src/types-and-values/inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "러스트는 변수가 어떻게 사용되는지를 보고 그 변수의 타입을 추론합니다:"

#: src/types-and-values/inference.md:28
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"이 슬라이드는, 러스트 컴파일러가 변수가 어떻게 선언되어 있고, 어떻게 사용되는"
"지를 제약 조건으로 삼아서 변수의 타입을 추론하는 모습을 보여줍니다."

#: src/types-and-values/inference.md:31
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"여기서 중요한 것은, 이렇게 명시적인 타입을 생략하고 선언되었다고 해서 \"어떤 "
"타입\"이라도 다 담을 수 있는 타입이 되는 것은 아니라는 점입니다. 명시적인 타"
"입 선언이 있던 없던, 컴파일러가 생성한 머신코드는 동일합니다. 컴파일러는 단"
"지 타입 선언을 생략할 수 있도록 해서 프로그래머가 더 간결한 코드를 쓸 수 있도"
"록 도와줄 뿐입니다."

#: src/types-and-values/inference.md:36
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""

#: src/types-and-values/inference.md:45
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr ""

#: src/types-and-values/exercise.md:3
msgid ""
"The first and second Fibonacci numbers are both `1`. For n>2, the n'th "
"Fibonacci number is calculated recursively as the sum of the n-1'th and "
"n-2'th Fibonacci numbers."
msgstr ""

#: src/types-and-values/exercise.md:7
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr ""

#: src/types-and-values/exercise.md:13
msgid "// The base case.\n"
msgstr ""

#: src/types-and-values/exercise.md:14 src/types-and-values/exercise.md:17
#: src/control-flow-basics/exercise.md:27
#: src/control-flow-basics/exercise.md:31
#, fuzzy
msgid "\"Implement this\""
msgstr "서비스 구현"

#: src/types-and-values/exercise.md:16
msgid "// The recursive case.\n"
msgstr ""

#: src/types-and-values/exercise.md:23 src/types-and-values/solution.md:14
msgid "\"fib(n) = {}\""
msgstr ""

#: src/control-flow-basics/conditionals.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "대부분의 러스트 문법은 C/C++/Java 와 유사합니다:"

#: src/control-flow-basics/conditionals.md:5
#, fuzzy
msgid "Blocks are delimited by curly braces."
msgstr "블록과 범위는 중괄호`{}`로 표현합니다."

#: src/control-flow-basics/conditionals.md:6
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr "인라인 주석은 `//`, 블록 주석은 `/* ... */`로 사용합니다."

#: src/control-flow-basics/conditionals.md:8
msgid "Keywords like `if` and `while` work the same."
msgstr "`if`나 `while`같은 키워드도 동일합니다."

#: src/control-flow-basics/conditionals.md:9
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr "변수 할당은 `=`, 비교는 `==`를 사용합니다."

#: src/control-flow-basics/conditionals.md:11
msgid "`if` expressions"
msgstr "`if` 표현식"

#: src/control-flow-basics/conditionals.md:13
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"다른 언어의 `if` 문과 똑같이 [`if` 표현식](https://doc.rust-lang.org/"
"reference/expressions/if-expr.html#if-expressions)을 사용합니다:"

#: src/control-flow-basics/conditionals.md:21
#: src/control-flow-basics/conditionals.md:36
msgid "\"small\""
msgstr ""

#: src/control-flow-basics/conditionals.md:23
msgid "\"biggish\""
msgstr ""

#: src/control-flow-basics/conditionals.md:25
msgid "\"huge\""
msgstr ""

#: src/control-flow-basics/conditionals.md:30
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"게다가 `if`는 표현식으로 사용할 수도 있습니다. 아래 코드는 위와 동일합니다:"

#: src/control-flow-basics/conditionals.md:36
msgid "\"large\""
msgstr ""

#: src/control-flow-basics/conditionals.md:37
msgid "\"number size: {}\""
msgstr ""

#: src/control-flow-basics/conditionals.md:43
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"`if`는 표현식이고 타입을 가져야 하므로 분기 블록은 모두 같은 타입을 가져야 합"
"니다. 두번째 예시의 `x / 2` 뒤에 `;`를 추가하여 어떻게 되는지 확인해 보시기 "
"바랍니다."

#: src/control-flow-basics/conditionals.md:47
msgid ""
"When `if` is used in an expression, the expression must have a `;` to "
"separate it from the next statement. Remove the `;` before `println!` to see "
"the compiler error."
msgstr ""

#: src/control-flow-basics/loops.md:3
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr ""

#: src/control-flow-basics/loops.md:5
#, fuzzy
msgid "`while`"
msgstr "`while` 반복문"

#: src/control-flow-basics/loops.md:7
#, fuzzy
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"[`while` 키워드](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#predicate-loops)는 다른 언어와 매우 비슷하게 작동합니다:"

#: src/control-flow-basics/loops.md:18
msgid "\"Final x: {x}\""
msgstr ""

#: src/control-flow-basics/loops.md:22
#, fuzzy
msgid "`for`"
msgstr "배열과 `for` 반복문"

#: src/control-flow-basics/loops.md:24
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values:"
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 트레잇은 소멸자 "
"정의에 사용됩니다."

#: src/control-flow-basics/loops.md:35
msgid "`loop`"
msgstr ""

#: src/control-flow-basics/loops.md:37
#, fuzzy
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 트레잇은 소멸자 "
"정의에 사용됩니다."

#: src/control-flow-basics/loops.md:45
msgid "\"{i}\""
msgstr ""

#: src/control-flow-basics/loops.md:55
msgid ""
"We will discuss iteration later; for now, just stick to range expressions."
msgstr ""

#: src/control-flow-basics/loops.md:56
msgid ""
"Note that the `for` loop only iterates to `4`. Show the `1..=5` syntax for "
"an inclusive range."
msgstr ""

#: src/control-flow-basics/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). For "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"루프를 조기에 종료하려면 [`break`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#break-expressions)를 사용합니다,"

#: src/control-flow-basics/break-continue.md:8
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"다음 반복을 즉시 시작하려면 [`continue`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#continue-expressions)를 사용합니다."

#: src/control-flow-basics/break-continue.md:24
msgid "\"{result}\""
msgstr ""

#: src/control-flow-basics/break-continue.md:28
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"루프를 빠져나가려면 `break`를, 다음 반복으로 넘어가기 위해서는 `continue`를 "
"사용합니다. 중첩 루프에서는 레이블과 함께 사용할 수 있습니다:"

#: src/control-flow-basics/break-continue.md:37
msgid "\"x: {x}, i: {i}\""
msgstr ""

#: src/control-flow-basics/break-continue.md:47
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"위 예제는 내부의 `while` 루프를 3회 반복한 후 바깥 루프를 빠져나갑니다."

#: src/control-flow-basics/break-continue.md:51
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"`loop`는 non-trivial 값을 반환하는 유일한 반복문입니다. 이는 `while` 및 "
"`for` 반복문과 달리 최소한 한 번은 루프문을 수행하는 것이 보장되기 때문입니"
"다."

#: src/control-flow-basics/blocks-and-scopes.md:3
msgid "Blocks"
msgstr "블록"

#: src/control-flow-basics/blocks-and-scopes.md:5
msgid ""
"A block in Rust contains a sequence of expressions. Each block has a value "
"and a type, which are those of the last expression of the block:"
msgstr ""
"러스트에서 블록은 값과 타입을 갖습니다. 블록의 마지막 표현식이 블록의 값이 됩"
"니다:"

#: src/control-flow-basics/blocks-and-scopes.md:13
msgid "\"y: {y}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:20
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"위의 `main` 함수는 마지막 표현식이 `;`로 끝나기 때문에 반환되는 값과 타입이 "
"`()`입니다."

#: src/control-flow-basics/blocks-and-scopes.md:22
msgid "Scopes and Shadowing"
msgstr "범위(Scopes)와 쉐도잉(Shadowing)"

#: src/control-flow-basics/blocks-and-scopes.md:24
msgid "A variable's scope is limited to the enclosing block."
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:26
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"현재 범위에 있는 변수와, 바깥 범위에 있는 변수 모두 가릴(쉐도잉)수 있습니다:"

#: src/control-flow-basics/blocks-and-scopes.md:32
msgid "\"before: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:34
#: src/std-traits/from-and-into.md:7 src/std-traits/from-and-into.md:19
#: src/slices-and-lifetimes/solution.md:225
msgid "\"hello\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:35
msgid "\"inner scope: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:38
msgid "\"shadowed in inner scope: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:41
msgid "\"after: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:47
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"블록 마지막 줄을 수정하면서 블록의 값이 어떻게 바뀌는지 보여주세요. 예를 들"
"어, 세미콜론을 넣거나 뺀다든지, 아니면 `return`을 사용해 보세요."

#: src/control-flow-basics/blocks-and-scopes.md:49
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:51
#, fuzzy
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variable's memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"쉐도잉은 기존 변수에 새로운 값을 할당하는 것이 아닙니다. 쉐도잉을 하면 새로"
"운 변수가 생기며, 이전 변수와 새 변수는 메모리의 서로 다른 위치에 존재합니"
"다. 그 두 변수는 단지 이름이 같은 뿐이며, 코드 중 어디에서 그 이름이 사용되었"
"느냐에 따라 어떤 변수를 지칭하는 지가 결정됩니다. "

#: src/control-flow-basics/blocks-and-scopes.md:54
#, fuzzy
msgid "A shadowing variable can have a different type."
msgstr "쉐도잉 시 타입을 바꿀 수 있습니다. "

#: src/control-flow-basics/blocks-and-scopes.md:55
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"처음에 쉐도잉을 보면 코드를 더 모호하게 만든다고 생각할 수 도 있습니다. 그러"
"나 실제로 쉐도잉을 이용하면, 어떤 변수에서 `.unwrap()` 된 값을 새로운 변수에 "
"담을 경우 새로운 이름을 지을 필요 없이 기존 이름을 유지할 수 있어서 편리합니"
"다."

#: src/control-flow-basics/functions.md:21
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"매개변수를 선언할 때에는 이름을 먼저 쓰고, 타입을 나중에 씁니다. 이름과 타입"
"은 `:` 로 구분합니다. 이는 일부 언어(예를 들어 C)와 반대임에 유의하시기 바랍"
"니다. 마찬가지로, 리턴 타입도 함수의 시작이 아닌 가장 뒷부분에 선언합니다."

#: src/control-flow-basics/functions.md:23
#, fuzzy
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"함수 본문의 마지막 표현식은 반환 값이 됩니다. 간단히, 식 끝에 있는 `;`를 생략"
"하면 됩니다."

#: src/control-flow-basics/functions.md:27
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"반환값이 없는 함수의 경우, 유닛 타입 `()`을 반환합니다. `-> ()`가 생략된 경"
"우 컴파일러는 이를 추론합니다."

#: src/control-flow-basics/functions.md:29
#, fuzzy
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr "개별함수는 단일 구현만 갖습니다:"

#: src/control-flow-basics/functions.md:30
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr ""

#: src/control-flow-basics/functions.md:32
#, fuzzy
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr "파라매터들의 타입은 항상 고정되어 있습니다."

#: src/control-flow-basics/macros.md:3
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""

#: src/control-flow-basics/macros.md:7
#, fuzzy
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr "연산자 오버로드는 `std::ops`에 있는 다양한 트레잇들을 통해 구현됩니다:"

#: src/control-flow-basics/macros.md:9
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""

#: src/control-flow-basics/macros.md:11
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr ""

#: src/control-flow-basics/macros.md:12
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr ""

#: src/control-flow-basics/macros.md:14
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""

#: src/control-flow-basics/macros.md:32
msgid "\"{n}! = {}\""
msgstr ""

#: src/control-flow-basics/macros.md:38
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""

#: src/control-flow-basics/macros.md:42
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr ""

#: src/control-flow-basics/exercise.md:3
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n"
msgstr ""

#: src/control-flow-basics/exercise.md:4 src/control-flow-basics/exercise.md:10
#, fuzzy
msgid "1"
msgstr "12"

#: src/control-flow-basics/exercise.md:4
msgid " greater than zero:"
msgstr ""

#: src/control-flow-basics/exercise.md:6 src/control-flow-basics/exercise.md:7
#: src/control-flow-basics/exercise.md:8
msgid "If _n"
msgstr ""

#: src/control-flow-basics/exercise.md:6 src/control-flow-basics/exercise.md:7
#: src/control-flow-basics/exercise.md:8
msgid "i"
msgstr ""

#: src/control-flow-basics/exercise.md:6
msgid "_ is 1, then the sequence terminates at _n"
msgstr ""

#: src/control-flow-basics/exercise.md:6
msgid "_."
msgstr ""

#: src/control-flow-basics/exercise.md:7
msgid "_ is even, then _n"
msgstr ""

#: src/control-flow-basics/exercise.md:7 src/control-flow-basics/exercise.md:8
msgid "i+1"
msgstr ""

#: src/control-flow-basics/exercise.md:7
msgid " = n"
msgstr ""

#: src/control-flow-basics/exercise.md:7
msgid " / 2_."
msgstr ""

#: src/control-flow-basics/exercise.md:8
msgid "_ is odd, then _n"
msgstr ""

#: src/control-flow-basics/exercise.md:8
msgid " = 3 * n"
msgstr ""

#: src/control-flow-basics/exercise.md:8
msgid " + 1_."
msgstr ""

#: src/control-flow-basics/exercise.md:10
msgid "For example, beginning with _n"
msgstr ""

#: src/control-flow-basics/exercise.md:10
msgid "_ = 3:"
msgstr ""

#: src/control-flow-basics/exercise.md:12
msgid "3 is odd, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:12
#, fuzzy
msgid "2"
msgstr "12"

#: src/control-flow-basics/exercise.md:12
msgid "_ = 3 * 3 + 1 = 10;"
msgstr ""

#: src/control-flow-basics/exercise.md:13
msgid "10 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:13 src/bare-metal/aps/better-uart.md:22
msgid "3"
msgstr "3"

#: src/control-flow-basics/exercise.md:13
msgid "_ = 10 / 2 = 5;"
msgstr ""

#: src/control-flow-basics/exercise.md:14
msgid "5 is odd, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:14 src/bare-metal/aps/better-uart.md:10
msgid "4"
msgstr "4"

#: src/control-flow-basics/exercise.md:14
msgid "_ = 3 * 15 + 1 = 16;"
msgstr ""

#: src/control-flow-basics/exercise.md:15
msgid "16 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:15
msgid "5"
msgstr ""

#: src/control-flow-basics/exercise.md:15
msgid "_ = 16 / 2 = 8;"
msgstr ""

#: src/control-flow-basics/exercise.md:16
msgid "8 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:16 src/bare-metal/aps/better-uart.md:14
#: src/bare-metal/aps/better-uart.md:17
msgid "6"
msgstr "6"

#: src/control-flow-basics/exercise.md:16
msgid "_ = 8 / 2 = 4;"
msgstr ""

#: src/control-flow-basics/exercise.md:17
msgid "4 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:17
msgid "7"
msgstr ""

#: src/control-flow-basics/exercise.md:17
msgid "_ = 4 / 2 = 2;"
msgstr ""

#: src/control-flow-basics/exercise.md:18
msgid "2 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:18 src/bare-metal/aps/better-uart.md:12
#: src/bare-metal/aps/better-uart.md:15
msgid "8"
msgstr "8"

#: src/control-flow-basics/exercise.md:18
msgid "_ = 1; and"
msgstr ""

#: src/control-flow-basics/exercise.md:19
msgid "the sequence terminates."
msgstr ""

#: src/control-flow-basics/exercise.md:21
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr ""

#: src/control-flow-basics/exercise.md:25 src/control-flow-basics/solution.md:4
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr ""

#: src/control-flow-basics/solution.md:20 src/concurrency/scoped-threads.md:11
#: src/concurrency/scoped-threads.md:30
msgid "\"Length: {}\""
msgstr ""

#: src/welcome-day-1-afternoon.md:1 src/welcome-day-2-afternoon.md:1
#: src/welcome-day-3-afternoon.md:1 src/welcome-day-4-afternoon.md:1
#, fuzzy
msgid "Welcome Back"
msgstr "개요"

#: src/tuples-and-arrays/tuples-and-arrays.md:3
msgid ""
"Tuples and arrays are the first \"compound\" types we have seen. All "
"elements of an array have the same type, while tuples can accommodate "
"different types. Both types have a size fixed at compile time."
msgstr ""

#: src/tuples-and-arrays/tuples-and-arrays.md:9
#: src/tuples-and-arrays/destructuring.md:27
msgid "Arrays"
msgstr "배열"

#: src/tuples-and-arrays/tuples-and-arrays.md:9
msgid "`[T; N]`"
msgstr "`[T; N]`"

#: src/tuples-and-arrays/tuples-and-arrays.md:9
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr "`[20, 30, 40]`, `[0; 3]`"

#: src/tuples-and-arrays/tuples-and-arrays.md:10
#: src/tuples-and-arrays/destructuring.md:9
msgid "Tuples"
msgstr "튜플"

#: src/tuples-and-arrays/tuples-and-arrays.md:10
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr "`()`, `(T,)`, `(T1, T2)`, ..."

#: src/tuples-and-arrays/tuples-and-arrays.md:10
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr "`()`, `('x',)`, `('x', 1.2)`, ..."

#: src/tuples-and-arrays/tuples-and-arrays.md:12
msgid "Array assignment and access:"
msgstr "배열 선언과 접근:"

#: src/tuples-and-arrays/tuples-and-arrays.md:24
msgid "Tuple assignment and access:"
msgstr "튜플 선언과 접근:"

#: src/tuples-and-arrays/tuples-and-arrays.md:40
msgid "Arrays:"
msgstr "배열:"

#: src/tuples-and-arrays/tuples-and-arrays.md:42
#, fuzzy
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"배열은, 같은 타입 `T`의 값이 `N`개 있는 것입니다. 여기서 `N`은 컴파일 타임에 "
"결정된 값이어야 합니다. 이 길이도 타입의 일부입니다. 따라서, `[u8; 3]`와 "
"`[u8; 4]`은 서로 다른 타입입니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:48
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""

#: src/tuples-and-arrays/tuples-and-arrays.md:52
msgid "We can use literals to assign values to arrays."
msgstr "리터럴을 사용하여 배열에 값을 할당할 수 있습니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:54
#, fuzzy
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"포매팅 문자열에서 `?`는 디버깅 출력을 의미합니다. `{}`는 기본 출력이며, `{:?}"
"`는 디버깅 출력입니다. `{a}`, `{a:?}`와 같이 출력할 변수 이름을 포매팅 문자열"
"에 포함시킬 수도 있으며, 이 경우 인자 `a`는 별도의 인자로 추가하지 않습니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:59
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"`#`을 추가하면(`{a:#?}`) 좀 더 읽기 쉬운 \"이쁜\" 형태로 출력이 됩니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:62
msgid "Tuples:"
msgstr "튜플:"

#: src/tuples-and-arrays/tuples-and-arrays.md:64
msgid "Like arrays, tuples have a fixed length."
msgstr "배열과 마찬가지로 튜플은 고정 길이를 갖습니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:66
msgid "Tuples group together values of different types into a compound type."
msgstr "튜플은 서로 다른 타입의 값들을 하나의 복합 타입으로 묶습니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:68
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr "튜플에 속한 값은 `t.0`, `t.1`과 같이 인덱스로 접근할 수 있습니다."

#: src/tuples-and-arrays/tuples-and-arrays.md:71
#, fuzzy
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type --- that is to say both the type and "
"its value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide."
msgstr ""
"비어있는 튜플`()`은 단위 타입(unit type)이라고도 합니다. 이는 타입이면서 해"
"당 타입의 유일하며 유효한 값입니다. 즉 타입과 값이 모두 `()`입니다. 예를 들"
"어 함수나 식에서 반환 값이 없음을 나타낼 때 사용합니다. "

#: src/tuples-and-arrays/tuples-and-arrays.md:75
#, fuzzy
msgid ""
"You can think of it as `void` that can be familiar to you from other "
"programming languages."
msgstr "다른 언어에서 익숙한 `void` 개념으로 생각할 수 있습니다."

#: src/tuples-and-arrays/iteration.md:3
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr ""

#: src/tuples-and-arrays/iteration.md:18
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr ""

#: src/tuples-and-arrays/iteration.md:21
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked while, debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""

#: src/tuples-and-arrays/match.md:3
#, fuzzy
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"`match`키워드는 값을 여러 형태의 패턴과 매치시킬 수 있습니다. 맨 위 패턴부터 "
"하나씩 매치되는지 검사하며, 처음으로 매치되는 패턴이 선택됩니다."

#: src/tuples-and-arrays/match.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "C/C++의 `switch`와 비슷하게 값을 패턴으로 사용할 수도 있습니다:"

#: src/tuples-and-arrays/match.md:11
msgid "'x'"
msgstr ""

#: src/tuples-and-arrays/match.md:13
msgid "'q'"
msgstr ""

#: src/tuples-and-arrays/match.md:13
msgid "\"Quitting\""
msgstr ""

#: src/tuples-and-arrays/match.md:14 src/std-traits/solution.md:16
#: src/error-handling/exercise.md:62 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:62 src/error-handling/solution.md:64
msgid "'a'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "'s'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "'w'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "'d'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "\"Moving around\""
msgstr ""

#: src/tuples-and-arrays/match.md:15 src/error-handling/exercise.md:54
#: src/error-handling/exercise.md:56 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:54 src/error-handling/solution.md:56
#: src/error-handling/solution.md:64
msgid "'0'"
msgstr ""

#: src/tuples-and-arrays/match.md:15 src/error-handling/exercise.md:54
#: src/error-handling/exercise.md:56 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:54 src/error-handling/solution.md:56
#: src/error-handling/solution.md:64
msgid "'9'"
msgstr ""

#: src/tuples-and-arrays/match.md:15
msgid "\"Number input\""
msgstr ""

#: src/tuples-and-arrays/match.md:16
msgid "\"Lowercase: {key}\""
msgstr ""

#: src/tuples-and-arrays/match.md:17
msgid "\"Something else\""
msgstr ""

#: src/tuples-and-arrays/match.md:22
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be irrefutable, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""

#: src/tuples-and-arrays/match.md:26
#, fuzzy
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"`if let`과 마찬가지로 매치의 모든 팔(arm)은 같은 타입이어야 합니다. 팔이 블록"
"이라면 블록의 마지막 표현식이 그 타입이 됩니다. 위의 예제에서 매치 표현식의 "
"타입은 `()`입니다."

#: src/tuples-and-arrays/match.md:30
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr ""

#: src/tuples-and-arrays/match.md:33
msgid "A match guard causes the arm to match only if the condition is true."
msgstr ""

#: src/tuples-and-arrays/match.md:37 src/user-defined-types/named-structs.md:34
#: src/user-defined-types/enums.md:28 src/methods-and-traits/methods.md:68
msgid "Key Points:"
msgstr "키 포인트:"

#: src/tuples-and-arrays/match.md:39
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr "패턴에서 사용되는 특수 문자들을 알려주세요"

#: src/tuples-and-arrays/match.md:41
msgid "`|` as an `or`"
msgstr "`|`: or 기호입니다"

#: src/tuples-and-arrays/match.md:42
msgid "`..` can expand as much as it needs to be"
msgstr "`..`: 필요한 만큼 확장합니다"

#: src/tuples-and-arrays/match.md:43
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5`: 끝 값(여기서는 5)을 포함하는 범위를 나타냅니다"

#: src/tuples-and-arrays/match.md:44
msgid "`_` is a wild card"
msgstr "`_`: 와일드카드입니다"

#: src/tuples-and-arrays/match.md:46
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"매치 가드는 별도의 문법 요소로서 패턴 자체만으로 표현하기 어려운 복잡한 경우"
"를 간결하게 표현하고자 할 때 유용합니다."

#: src/tuples-and-arrays/match.md:48
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"매치의 각 팔(혹은 가지) 안에 따로 `if`를 사용한 것과 다릅니다. 매치 가지의 "
"`=>` 뒤에 사용된 `if` 표현식은 해당 가지가 선택된 다음에 실행됩니다. 따라서 "
"여기서 `if` 조건이 실패하더라도 원래 `match`의 다른 가지는 고려되지 않습니다."

#: src/tuples-and-arrays/match.md:52
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr "가드에 정의된 조건은 `|` 를 포함하는 패턴의 모든 표현식에 적용됩니다."

#: src/tuples-and-arrays/destructuring.md:3
msgid ""
"Destructuring is a way of extracting data from a data structure by writing a "
"pattern that is matched up to the data structure, binding variables to "
"subcomponents of the data structure."
msgstr ""

#: src/tuples-and-arrays/destructuring.md:7
#, fuzzy
msgid "You can destructure tuples and arrays by matching on their elements:"
msgstr ""
"배열이나 튜플, 슬라이스도 그 요소들에 대해 패턴 매칭으로 분해할 수 있습니다:"

#: src/tuples-and-arrays/destructuring.md:18
msgid "\"on Y axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:19
msgid "\"on X axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:20
msgid "\"left of Y axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:21
msgid "\"below X axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:22
msgid "\"first quadrant\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:33
msgid "\"Tell me about {triple:?}\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:35
msgid "\"First is 0, y = {y}, and z = {z}\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:36
msgid "\"First is 1 and the rest were ignored\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:37
msgid "\"All elements were ignored\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:44
#, fuzzy
msgid "Create a new array pattern using `_` to represent an element."
msgstr "`_`를 사용하여 요소를 매칭하는 패턴을 추가해보세요. "

#: src/tuples-and-arrays/destructuring.md:45
msgid "Add more values to the array."
msgstr "배열에 값을 더 추가해보세요."

#: src/tuples-and-arrays/destructuring.md:46
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr "`..`가 요소 개수에 상관없이 매치될 수 있음을 알려주세요."

#: src/tuples-and-arrays/destructuring.md:48
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""
"`[.., b]`나 `[a@.., b]`와 같은 패턴으로 꼬리 부분을 매칭하는 것을 보여주세요"

#: src/tuples-and-arrays/exercise.md:3
msgid "Arrays can contain other arrays:"
msgstr ""

#: src/tuples-and-arrays/exercise.md:9
#, fuzzy
msgid "What is the type of this variable?"
msgstr "매 루프에서 `word`의 타입은 무엇입니까?"

#: src/tuples-and-arrays/exercise.md:11
#, fuzzy
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"위 코드를 이용해서, 행렬을 예쁘게 출력하는 `pretty_print`함수와, 행렬을 전치"
"(행과 열을 서로 바꾸는)시키는 `transpose`함수를 작성해 보시기 바랍니다:"

#: src/tuples-and-arrays/exercise.md:22
msgid "Hard-code both functions to operate on 3 × 3 matrices."
msgstr "두 함수 모두 행렬의 크기는 3 x 3 으로 하드코딩 합니다."

#: src/tuples-and-arrays/exercise.md:24
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"아래 코드를 <https://play.rust-lang.org/>에 복사해서 구현하시면 됩니다:"

#: src/tuples-and-arrays/exercise.md:28 src/methods-and-traits/exercise.md:20
#: src/borrowing/exercise.md:14 src/unsafe-rust/exercise.md:51
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr ""

#: src/tuples-and-arrays/exercise.md:37 src/tuples-and-arrays/solution.md:34
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr ""

#: src/tuples-and-arrays/exercise.md:42 src/tuples-and-arrays/solution.md:39
msgid "\"matrix: {:#?}\""
msgstr ""

#: src/tuples-and-arrays/exercise.md:44 src/tuples-and-arrays/solution.md:41
msgid "\"transposed: {:#?}\""
msgstr ""

#: src/tuples-and-arrays/solution.md:17 src/tuples-and-arrays/solution.md:25
msgid "//\n"
msgstr ""

#: src/references/shared.md:3
msgid ""
"A reference provides a way to access another value without taking "
"responsibility for the value, and is also called \"borrowing\". Shared "
"references are read-only, and the referenced data cannot change."
msgstr ""

#: src/references/shared.md:20
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""

#: src/references/shared.md:24
msgid "Rust will statically forbid dangling references:"
msgstr "러스트는 허상(dangling) 참조를 컴파일러 단계에서 찾아내고 금지합니다:"

#: src/references/shared.md:37
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""

#: src/references/shared.md:42
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""

#: src/references/shared.md:47
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr ""

#: src/references/shared.md:50
#, fuzzy
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.count_ones()`). There is no need for an `->` operator like "
"in C++."
msgstr ""
"러스트는 특정한 경우(메서드 호출)에 자동으로 역참조를 합니다.(`ref_x."
"count_one()`을 하면 `*ref_x`가 `count_one`의 인자로 전달됩니다.)"

#: src/references/shared.md:53
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""

#: src/references/shared.md:57
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr ""

#: src/references/shared.md:60
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""

#: src/references/shared.md:65
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"소유권에 대한 주제를 다룰 때 이 빌림에 대해 더 자세히 이야기 하겠습니다."

#: src/references/exclusive.md:3
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""

#: src/references/exclusive.md:21
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""

#: src/references/exclusive.md:26
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"`let mut ref_x: &i32`와 `let ref_x: &mut i32`의 차이점에 주의 하시기 바랍니"
"다. 첫번째 값은 다른 값에 바인딩 될 수 있는 가변 참조이고, 두번째 값은 가변 "
"값에 대한 참조입니다."

#: src/references/exercise.md:3
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""

#: src/references/exercise.md:7
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""

#: src/references/exercise.md:15
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""

#: src/references/exercise.md:23
msgid "// Use the following `main` to test your work.\n"
msgstr ""

#: src/references/exercise.md:27 src/references/solution.md:22
msgid "\"Magnitude of a unit vector: {}\""
msgstr ""

#: src/references/exercise.md:30 src/references/solution.md:25
msgid "\"Magnitude of {v:?}: {}\""
msgstr ""

#: src/references/exercise.md:32 src/references/solution.md:27
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr ""

#: src/references/solution.md:4
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr ""

#: src/references/solution.md:12
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr ""

#: src/user-defined-types/named-structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "C/C++ 와 마찬가지로 러스트는 커스텀 구조체를 지원합니다:"

#: src/user-defined-types/named-structs.md:12
msgid "\"{} is {} years old\""
msgstr ""

#: src/user-defined-types/named-structs.md:16
#: src/android/interoperability/with-c/bindgen.md:87
msgid "\"Peter\""
msgstr ""

#: src/user-defined-types/named-structs.md:22
msgid "\"Avery\""
msgstr ""

#: src/user-defined-types/named-structs.md:27
msgid "\"Jackie\""
msgstr ""

#: src/user-defined-types/named-structs.md:36
msgid "Structs work like in C or C++."
msgstr "구조체는 C/C++ 와 유사합니다."

#: src/user-defined-types/named-structs.md:37
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"C++ 와 같지만 C와는 달리 타입을 정의하기 위해 'typedef'가 필요하지 않습니다."

#: src/user-defined-types/named-structs.md:38
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "C++ 와 달리 구조체 간 상속은 없습니다."

#: src/user-defined-types/named-structs.md:39
#, fuzzy
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr ""
"사람들에게 다른 종류의 구조체가 있음을 알게 하기에 좋은 시간일 것입니다. "

#: src/user-defined-types/named-structs.md:41
#, fuzzy
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don’t have any data that you want to store in the "
"value itself."
msgstr ""
"0 크기 구조체(예: `struct Foo;`)는 데이터를 가지고 있지 않지만 특정 타입의 트"
"레잇을 구현할 때 유용합니다. "

#: src/user-defined-types/named-structs.md:44
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"다음 슬라이드에서는 필드 이름이 덜 중요할 때 사용할 수 있는 튜플 구조체를 소"
"개합니다."

#: src/user-defined-types/named-structs.md:46
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr ""
"구조체 필드와 동일한 이름의 변수가 있다면 아래와 같이 \"짧은 문법\"으로 구조"
"체를 생성할 수 있습니다:"

#: src/user-defined-types/named-structs.md:48
#, fuzzy
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"`..peter` 문법은 한 구조체에서 다른 구조체로 대부분의 값을 복사하려고 하는 경"
"우에 하나하나 타이핑하는 수고를 덜어줍니다. 반드시 맨 마지막에 와야 합니다."

#: src/user-defined-types/tuple-structs.md:7
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "각 필드 이름이 중요하지 않다면 튜플 구조체를 사용할 수 있습니다:"

#: src/user-defined-types/tuple-structs.md:14
msgid "\"({}, {})\""
msgstr ""

#: src/user-defined-types/tuple-structs.md:18
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"튜플 구조체는 종종 단일 필드의 래퍼(wrapper, 러스트에서 뉴타입(newtype)이라"
"고 부름)로 사용됩니다:"

#: src/user-defined-types/tuple-structs.md:25
msgid "\"Ask a rocket scientist at NASA\""
msgstr ""

#: src/user-defined-types/tuple-structs.md:29
#: src/android/interoperability/cpp/cpp-bridge.md:50
#: src/bare-metal/microcontrollers/type-state.md:14
#: src/async/pitfalls/cancellation.md:98 src/async/pitfalls/cancellation.md:101
msgid "// ...\n"
msgstr ""

#: src/user-defined-types/tuple-structs.md:40
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"뉴타입은 기본 타입에 부가적인 의미를 더하는 좋은 방법입니다. 예를 들어:"

#: src/user-defined-types/tuple-structs.md:42
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr "숫자값에 단위를 표시할 수 있음: 위에서 `Newtons`이 그 예입니다."

#: src/user-defined-types/tuple-structs.md:43
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"값이 생성될 때 이미 유효성 검사를 통과 했으므로 추가적인 검사가 필요없습니"
"다: `PhoneNumber(String)`또는 `OddNumber(u32)`."

#: src/user-defined-types/tuple-structs.md:46
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr "`Newtons` 타입의 값에 `f64` 값을 더하는 방법을 보여주세요."

#: src/user-defined-types/tuple-structs.md:48
msgid ""
"Rust generally doesn’t like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"러스트는 분명하지 않은 것을 싫어합니다. 예를 들면 자동으로 unwrap하거나 불리"
"언 값을 정수 값으로 사용하는 것들이 그렇습니다."

#: src/user-defined-types/tuple-structs.md:50
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "연산자 재정의는 3일차 제네릭 부분에서 다룹니다."

#: src/user-defined-types/tuple-structs.md:51
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"이는 [화성 기후 궤도선 (Mars Climate Orbiter)](https://en.wikipedia.org/wiki/"
"Mars_Climate_Orbiter)의 실패 원인으로 지목된 도량형 입력 오류를 보여줍니다."

#: src/user-defined-types/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr "`enum` 키워드는 몇가지 유형(variant)으로 표현되는 타입을 생성합니다:"

#: src/user-defined-types/enums.md:15
msgid "// Simple variant\n"
msgstr ""

#: src/user-defined-types/enums.md:16
msgid "// Tuple variant\n"
msgstr ""

#: src/user-defined-types/enums.md:17
msgid "// Struct variant\n"
msgstr ""

#: src/user-defined-types/enums.md:22
msgid "\"On this turn: {:?}\""
msgstr ""

#: src/user-defined-types/enums.md:30
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type."
msgstr "열거형은 값들의 집합을 하나의 타입으로 표현할 수 있게 합니다"

#: src/user-defined-types/enums.md:31
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""

#: src/user-defined-types/enums.md:33
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""

#: src/user-defined-types/enums.md:36
#, fuzzy
msgid "This might be a good time to compare structs and enums:"
msgstr "구조체와 열거형을 비교해 보겠습니다:"

#: src/user-defined-types/enums.md:37
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"구조체나 열거형 모두, 필드가 하나도 없는 단순한 형태도 가능 하고, 여러 타입"
"의 필드를 가질 수도 있습니다. "

#: src/user-defined-types/enums.md:39
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn’t be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"열거형 타입의 각 variant를 별도의 구조체로 정의할 수도 있지만, 그러면 열거형"
"을 사용했을 때처럼 하나의 타입으로 취급할 수 없습니다. "

#: src/user-defined-types/enums.md:42
msgid "Rust uses minimal space to store the discriminant."
msgstr ""

#: src/user-defined-types/enums.md:43
msgid "If necessary, it stores an integer of the smallest required size"
msgstr ""

#: src/user-defined-types/enums.md:44
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""

#: src/user-defined-types/enums.md:48
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr "C와의 연동을 위해 식별자 값을 직접 지정할 수도 있습니다:"

#: src/user-defined-types/enums.md:66
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"`repr` 속성이 없다면 10001이 2 바이트로 표현가능하기 때문에 식별자의 타입 크"
"기는 2 바이트가 됩니다."

#: src/user-defined-types/enums.md:69
#: src/user-defined-types/static-and-const.md:75
#: src/memory-management/review.md:50 src/memory-management/move.md:99
#: src/smart-pointers/box.md:83 src/borrowing/shared.md:32
msgid "More to Explore"
msgstr ""

#: src/user-defined-types/enums.md:71
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""

#: src/user-defined-types/enums.md:73
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"널포인터 최적화: [어떤 타입들](https://doc.rust-lang.org/std/option/"
"#representation)에 대해서 러스트는 `size_of::<T>()`가 `size_of::"
"<Option<T>>()`와 같은 것을 보장합니다."

#: src/user-defined-types/enums.md:77
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"실제로 널포인터 최적화가 적용된 것을 확인하고 싶다면 아래의 예제코드를 사용하"
"세요. 주의할 점은, 여기에서 보여주는 비트 패턴이 컴파일러가 보장해 주는 것은 "
"아니라는 점입니다. 여기에 의존하는 것은 완전히 unsafe합니다."

#: src/user-defined-types/static-and-const.md:3
#, fuzzy
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program."
msgstr ""
"정적 변수와 상수는 전역 스코프에서 값을 생성하는 두 가지 방법입니다. 전역 스"
"코프에 생성된 값은 프로그램 수행 도중에 다른 값으로 이동되지 않으며, 메모리 "
"상에서 그 위치가 변하지 않습니다. "

#: src/user-defined-types/static-and-const.md:6
msgid "`const`"
msgstr "상수(`const`)"

#: src/user-defined-types/static-and-const.md:8
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr ""
"상수는 컴파일 할 때 그 값이 정해집니다. 그리고 그 값은 그 상수가 사용되는 모"
"든 부분에서 인라인 됩니다:"

#: src/user-defined-types/static-and-const.md:31
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"[Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static.html)"
"에 따르면 상수는, 그 상수가 사용되는 곳에 인라인 됩니다."

#: src/user-defined-types/static-and-const.md:33
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"`const` 값을 생성할 때에는 `const`로 마킹된 함수만이 호출 가능하며, 이 함수들"
"은 컴파일 시에 호출이 됩니다. 물론 `const`함수들을 런타임에 호출하는 것도 가"
"능합니다."

#: src/user-defined-types/static-and-const.md:36
msgid "`static`"
msgstr "정적변수(`static`)"

#: src/user-defined-types/static-and-const.md:38
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"정적 변수는 프로그램이 수행되는 동안 유지가 됩니다. 그러므로 다른 변수로 이동"
"(move)되지 않습니다:"

#: src/user-defined-types/static-and-const.md:42
#, fuzzy
msgid "\"Welcome to RustOS 3.14\""
msgstr "1일차 개요"

#: src/user-defined-types/static-and-const.md:45
msgid "\"{BANNER}\""
msgstr ""

#: src/user-defined-types/static-and-const.md:49
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"[Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static.html)에"
"서 언급한 바와 같이, 정적 변수는 별도의 메모리 공간을 가지며, 인라인 되지 않"
"습니다. 정적 변수는 안전하지 않은(unsafe) 러스트와 임베디드 시스템용 코드에"
"서 유용합니다. 이들의 수명은 프로그램이 수행되는 전체 시간과 동일합니다. 전"
"역 스코프를 가진 어떤 값이, 메모리 상에 단 하나만 존재해야 한다는 요구조건이 "
"없다면, 정적 변수 대신 `const`를 쓰는 것이 옳습니다."

#: src/user-defined-types/static-and-const.md:57
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr "러스트의 `const`는 C++의 `constexpr`과 매우 비슷합니다."

#: src/user-defined-types/static-and-const.md:58
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"반면에 러스트의 `static`은 C++의 `const`나 가변 정적 변수(mutable global "
"variable)와 훨씬 더 유사합니다."

#: src/user-defined-types/static-and-const.md:60
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static`은 객체에 정체성을 부여합니다. 정체정이란 메모리 상에서의 주소, 그리"
"고 내부 상태를 의미합니다."

#: src/user-defined-types/static-and-const.md:62
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"프로그램 수행시 그 값이 정해지는 상수가 필요한 경우는 드뭅니다. 그러나 그렇다"
"고 해도, 정적 변수를 사용하는 것 보다는 더 유용하고 안전합니다."

#: src/user-defined-types/static-and-const.md:65
msgid "Properties table:"
msgstr "속성 비교 테이블:"

#: src/user-defined-types/static-and-const.md:67
#: src/chromium/adding-third-party-crates.md:6
msgid "Property"
msgstr "속성"

#: src/user-defined-types/static-and-const.md:67
msgid "Static"
msgstr "정적(static) 변수"

#: src/user-defined-types/static-and-const.md:67
msgid "Constant"
msgstr "상수(constant)"

#: src/user-defined-types/static-and-const.md:69
msgid "Has an address in memory"
msgstr "메모리 상에 주소가 있는가"

#: src/user-defined-types/static-and-const.md:69
#: src/user-defined-types/static-and-const.md:70
#: src/user-defined-types/static-and-const.md:72
#: src/user-defined-types/static-and-const.md:73
#: src/chromium/adding-third-party-crates/resolving-problems.md:12
#: src/chromium/adding-third-party-crates/resolving-problems.md:13
#: src/chromium/adding-third-party-crates/resolving-problems.md:14
msgid "Yes"
msgstr "예"

#: src/user-defined-types/static-and-const.md:69
msgid "No (inlined)"
msgstr "아니오(인라인 됨)"

#: src/user-defined-types/static-and-const.md:70
msgid "Lives for the entire duration of the program"
msgstr "프로그램이 수행되는 동안 계속 살아 있는가"

#: src/user-defined-types/static-and-const.md:70
#: src/user-defined-types/static-and-const.md:71
#: src/user-defined-types/static-and-const.md:73
#: src/chromium/adding-third-party-crates/resolving-problems.md:15
#: src/chromium/adding-third-party-crates/resolving-problems.md:16
msgid "No"
msgstr "아니오"

#: src/user-defined-types/static-and-const.md:71
msgid "Can be mutable"
msgstr "변경 가능한가"

#: src/user-defined-types/static-and-const.md:71
msgid "Yes (unsafe)"
msgstr "예 (그러나 안전하지 않음)"

#: src/user-defined-types/static-and-const.md:72
msgid "Evaluated at compile time"
msgstr "컴파일시 그 값이 결정되는가"

#: src/user-defined-types/static-and-const.md:72
msgid "Yes (initialised at compile time)"
msgstr "예 (컴파일시 초기화 됨)"

#: src/user-defined-types/static-and-const.md:73
msgid "Inlined wherever it is used"
msgstr "사용되는 곳에 인라인 되는가"

#: src/user-defined-types/static-and-const.md:77
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"`static`변수들은 어떤 스레드에서도 접근 가능하기 때문에, `Sync`트레잇을 구현"
"해야 합니다. 이 변수를 읽고 쓰려면 [`Mutex`](https://doc.rust-lang.org/std/"
"sync/struct.Mutex.html)로 감싸거나, atomic 연산을 써야 합니다. `static` 변수"
"를 mutable하게 선언할 수도 있지만, 이 경우 동기화 작업을 수동으로 해 주어야 "
"합니다. 그래서 그러한 변수를 접근하는 코드는`unsafe`로 명시적으로 표시가 되어"
"야 합니다. \"안전하지 않은 러스트\"를 배울 때 [mutable statics](../unsafe/"
"mutable-static-variables.md) 부분에서 좀 더 자세히 다루겠습니다."

#: src/user-defined-types/static-and-const.md:82
#, fuzzy
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr ""
"`thread_local` 데이터는 `std::thread_local` 매크로를 이용하여 생성할 수 있습"
"니다."

#: src/user-defined-types/aliases.md:3
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr ""

#: src/user-defined-types/aliases.md:13
msgid "// Aliases are more useful with long, complex types:\n"
msgstr ""

#: src/user-defined-types/aliases.md:22
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr ""

#: src/user-defined-types/exercise.md:3
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""

#: src/user-defined-types/exercise.md:7
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""

#: src/user-defined-types/exercise.md:12 src/user-defined-types/solution.md:4
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""

#: src/user-defined-types/exercise.md:15
msgid "// TODO: add required variants\n"
msgstr ""

#: src/user-defined-types/exercise.md:17 src/user-defined-types/solution.md:22
msgid "/// A direction of travel.\n"
msgstr ""

#: src/user-defined-types/exercise.md:24 src/user-defined-types/solution.md:39
msgid "/// The car has arrived on the given floor.\n"
msgstr ""

#: src/user-defined-types/exercise.md:29 src/user-defined-types/solution.md:44
msgid "/// The car doors have opened.\n"
msgstr ""

#: src/user-defined-types/exercise.md:34 src/user-defined-types/solution.md:49
msgid "/// The car doors have closed.\n"
msgstr ""

#: src/user-defined-types/exercise.md:39 src/user-defined-types/solution.md:54
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr ""

#: src/user-defined-types/exercise.md:44 src/user-defined-types/solution.md:59
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr ""

#: src/user-defined-types/exercise.md:52 src/user-defined-types/solution.md:67
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:55 src/user-defined-types/solution.md:70
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:56 src/user-defined-types/solution.md:71
msgid "\"The car door opened: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:58 src/user-defined-types/solution.md:73
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:61 src/user-defined-types/solution.md:76
msgid "\"The car door closed: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:62 src/user-defined-types/solution.md:77
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr ""

#: src/user-defined-types/solution.md:7
msgid "/// A button was pressed.\n"
msgstr ""

#: src/user-defined-types/solution.md:10
msgid "/// The car has arrived at the given floor.\n"
msgstr ""

#: src/user-defined-types/solution.md:13
msgid "/// The car's doors have opened.\n"
msgstr ""

#: src/user-defined-types/solution.md:16
msgid "/// The car's doors have closed.\n"
msgstr ""

#: src/user-defined-types/solution.md:19
msgid "/// A floor is represented as an integer.\n"
msgstr ""

#: src/user-defined-types/solution.md:29
msgid "/// A user-accessible button.\n"
msgstr ""

#: src/user-defined-types/solution.md:33
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr ""

#: src/user-defined-types/solution.md:36
msgid "/// A floor button within the car.\n"
msgstr ""

#: src/welcome-day-2.md:1
msgid "Welcome to Day 2"
msgstr "2일차 개요"

#: src/welcome-day-2.md:3
#, fuzzy
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr "상당한 분량의 러스트에 대해 보았고, 이어서 오늘 강의를 진행하겠습니다:"

#: src/welcome-day-2.md:6
#, fuzzy
msgid "Pattern matching: extracting data from structures."
msgstr "패턴 매칭: 열거형, 구조체 그리고 배열 분해."

#: src/welcome-day-2.md:7
msgid "Methods: associating functions with types."
msgstr ""

#: src/welcome-day-2.md:8
msgid "Traits: behaviors shared by multiple types."
msgstr ""

#: src/welcome-day-2.md:9
msgid "Generics: parameterizing types on other types."
msgstr ""

#: src/welcome-day-2.md:10
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr ""

#: src/pattern-matching/destructuring.md:3
msgid "Like tuples, structs and enums can also be destructured by matching:"
msgstr ""

#: src/pattern-matching/destructuring.md:5
#: src/pattern-matching/destructuring.md:58
msgid "Structs"
msgstr "구조체"

#: src/pattern-matching/destructuring.md:17
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr ""

#: src/pattern-matching/destructuring.md:18
msgid "\"y = 2, x = {i:?}\""
msgstr ""

#: src/pattern-matching/destructuring.md:19
msgid "\"y = {y}, other fields were ignored\""
msgstr ""

#: src/pattern-matching/destructuring.md:26
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"구조체나 열거형 값의 일부를 패턴 매치를 통해 변수에 바인딩할 수 있습니다. 간"
"단한 `enum` 타입을 먼저 살펴보겠습니다:"

#: src/pattern-matching/destructuring.md:39
msgid "\"cannot divide {n} into two equal parts\""
msgstr ""

#: src/pattern-matching/destructuring.md:46
msgid "\"{n} divided in two is {half}\""
msgstr ""

#: src/pattern-matching/destructuring.md:47
msgid "\"sorry, an error happened: {msg}\""
msgstr ""

#: src/pattern-matching/destructuring.md:52
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"`match`구문에서 `divide_in_two`함수에서 반환되는 `Result` 값을 두 개의 팔(혹"
"은 가지)로 _분해(destructure)_ 하였습니다. 첫번째 팔에서 `half`는 `Ok` "
"variant에 담긴 값으로 바인딩됩니다. 두번째 팔에서 `msg`는 오류 메시지 문자열"
"에 바인딩됩니다."

#: src/pattern-matching/destructuring.md:60
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr "`foo`의 리터럴 값을 다른 패턴과 일치하도록 변경합니다."

#: src/pattern-matching/destructuring.md:61
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr "`Foo`에 새 필드를 추가하고 필요에 따라 패턴을 변경합니다."

#: src/pattern-matching/destructuring.md:62
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"캡처와 상수 표현식은 구분하기 어려울 수 있습니다. 두 번째 부문의 `2`를 변수"
"로 변경해 보고 작동하지 않는 것을 확인하세요. `const`로 변경하고 다시 작동하"
"는지 확인합니다."

#: src/pattern-matching/destructuring.md:70
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"`if`/`else` 표현식은 열거형을 반환하고, 이 값은 나중에 `match`로 분해됩니다."

#: src/pattern-matching/destructuring.md:72
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"열거형에 세번째 variant를 추가하고 코드를 실행하여 오류를 표시해보세요. 코드 "
"어느 부분에 누락이 있는지, 그리고 컴파일러가 어떤 식으로 힌트를 주는지 같이 "
"살펴보세요."

#: src/pattern-matching/destructuring.md:75
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`."
msgstr ""
"열거형 안의 값은 패턴 매칭이 되고 난 이후에만 접근 가능합니다. 그 값에 대한 "
"레퍼런스는 `=>` 이후에 사용가능합니다."

#: src/pattern-matching/destructuring.md:78
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"매칭 패턴들이 불충분 하다면 어떤 일이 일어나는지 설명하세요. 러스트 컴파일러"
"는 모든 가능한 케이스들이 핸들링 되는지 체크한다는 점을 상기시키세요. "

#: src/pattern-matching/let-control-flow.md:3
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""

#: src/pattern-matching/let-control-flow.md:6
#: src/pattern-matching/let-control-flow.md:10
msgid "`if let` expressions"
msgstr "`if let` 표현식"

#: src/pattern-matching/let-control-flow.md:7
#, fuzzy
msgid "`while let` expressions"
msgstr "while let 표현식"

#: src/pattern-matching/let-control-flow.md:8
msgid "`match` expressions"
msgstr "`match` 표현식"

#: src/pattern-matching/let-control-flow.md:12
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"[`if let` 표현식](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions)을 사용하면 값이 패턴과 일치하는지에 따라 다른 코드"
"를 실행할 수 있습니다:"

#: src/pattern-matching/let-control-flow.md:24
msgid "\"slept for {:?}\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:33
#, fuzzy
msgid "`let else` expressions"
msgstr "`if let` 표현식"

#: src/pattern-matching/let-control-flow.md:35
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""

#: src/pattern-matching/let-control-flow.md:45
#: src/pattern-matching/let-control-flow.md:107
msgid "\"got None\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:51
#: src/pattern-matching/let-control-flow.md:111
msgid "\"got empty string\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:57
#: src/pattern-matching/let-control-flow.md:115
msgid "\"not a hex digit\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:62
#: src/pattern-matching/solution.md:113
msgid "\"result: {:?}\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:62
#: src/methods-and-traits/exercise.md:114
#: src/methods-and-traits/exercise.md:115
#: src/methods-and-traits/exercise.md:116 src/generics/trait-bounds.md:16
#: src/smart-pointers/solution.md:87 src/smart-pointers/solution.md:90
#: src/testing/googletest.md:11 src/testing/googletest.md:12
#: src/testing/solution.md:83
msgid "\"foo\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:66
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"마지막으로, 무한 루프를 만드는 [`loop` 키워드](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#infinite-loops)가 있습니다:"

#: src/pattern-matching/let-control-flow.md:82
#, fuzzy
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"`v.into_iter()`가 반환한 반복자는 `next()`가 호출될 때마다 `Option<i32>`를 반"
"환합니다. 반복자가 완료될 때까지는 `Some(x)`를 반환하고 마지막엔 `None`을 반"
"환합니다. `while let`을 통해 반복자의 모든 아이템을 확인할 수 있습니다."

#: src/pattern-matching/let-control-flow.md:89
msgid "if-let"
msgstr ""

#: src/pattern-matching/let-control-flow.md:91
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"`if let`이 `match`보다 더 간결할 수 있습니다(예: 한가지 브랜치만 흥미로운 경"
"우). 이와 달리 `match`에서는 모든 브랜치가 처리되어야 합니다."

#: src/pattern-matching/let-control-flow.md:93
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr "일반적 사용법은 `Option`을 사용할 때 `Some` 값을 처리하는 것입니다."

#: src/pattern-matching/let-control-flow.md:94
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"`match`와 달리 `if let`은 패턴 일치를 위한 보호 절을 지원하지 않습니다."

#: src/pattern-matching/let-control-flow.md:96
msgid "let-else"
msgstr ""

#: src/pattern-matching/let-control-flow.md:98
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""

#: src/pattern-matching/let-control-flow.md:102
msgid "The rewritten version is:"
msgstr ""

#: src/pattern-matching/let-control-flow.md:122
#, fuzzy
msgid "while-let"
msgstr "`while let` 반복문"

#: src/pattern-matching/let-control-flow.md:124
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr "`while let`은 값이 패턴에 매치되는 동안 계속됩니다."

#: src/pattern-matching/let-control-flow.md:126
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"`while let` 루프 대신 무한 루프를 사용하고 `iter.next()`가 빈 값을 반환할 때 "
"루프를 빠져나오도록 작성할수도 있습니다. `while let`은 그러한 경우를 위한 문"
"법적 편의를 제공합니다."

#: src/pattern-matching/exercise.md:3
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr ""

#: src/pattern-matching/exercise.md:5
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""

#: src/pattern-matching/exercise.md:10
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""

#: src/pattern-matching/exercise.md:15
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""

#: src/pattern-matching/exercise.md:26
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""

#: src/pattern-matching/exercise.md:30 src/pattern-matching/solution.md:4
msgid "/// An operation to perform on two subexpressions.\n"
msgstr ""

#: src/pattern-matching/exercise.md:38 src/pattern-matching/solution.md:12
msgid "/// An expression, in tree form.\n"
msgstr ""

#: src/pattern-matching/exercise.md:42 src/pattern-matching/solution.md:16
msgid "/// An operation on two subexpressions.\n"
msgstr ""

#: src/pattern-matching/exercise.md:45 src/pattern-matching/solution.md:19
msgid "/// A literal value\n"
msgstr ""

#: src/pattern-matching/exercise.md:104 src/pattern-matching/solution.md:40
#: src/pattern-matching/solution.md:102
msgid "\"division by zero\""
msgstr ""

#: src/pattern-matching/solution.md:112
msgid "\"expr: {:?}\""
msgstr ""

#: src/methods-and-traits/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"러스트에서 선언된 타입에 대해 `impl`블록에 함수를 선언하여 메서드를 연결 할 "
"수 있습니다:"

#: src/methods-and-traits/methods.md:14
msgid "// No receiver, a static method\n"
msgstr ""

#: src/methods-and-traits/methods.md:19
msgid "// Exclusive borrowed read-write access to self\n"
msgstr ""

#: src/methods-and-traits/methods.md:24
msgid "// Shared and read-only borrowed access to self\n"
msgstr ""

#: src/methods-and-traits/methods.md:26
msgid "\"Recorded {} laps for {}:\""
msgstr ""

#: src/methods-and-traits/methods.md:28
msgid "\"Lap {idx}: {lap} sec\""
msgstr ""

#: src/methods-and-traits/methods.md:32
msgid "// Exclusive ownership of self\n"
msgstr ""

#: src/methods-and-traits/methods.md:35
msgid "\"Race {} is finished, total lap time: {}\""
msgstr ""

#: src/methods-and-traits/methods.md:40
msgid "\"Monaco Grand Prix\""
msgstr ""

#: src/methods-and-traits/methods.md:47
msgid "// race.add_lap(42);\n"
msgstr ""

#: src/methods-and-traits/methods.md:51
#, fuzzy
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"`&self`는 메서드가 객체를 불변하게 빌려옴을 나타냅니다. 메서드의 리시버는 다"
"음의 형태들이 가능합니다:"

#: src/methods-and-traits/methods.md:54
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: 호출자로부터 공유가능한 불변 참조 방식으로 객체를 빌려옴을 나타냅니"
"다. 객체는 메소드 호출 뒤에도 사용될 수 있습니다."

#: src/methods-and-traits/methods.md:56
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: 호출자로부터 유일한 가변 참조 방식으로 객체를 빌려옴을 나타냅니"
"다. 객체는 메소드 호출 뒤에도 사용될 수 있습니다."

#: src/methods-and-traits/methods.md:58
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: 호출자로부터 객체의 소유권을 가져오고 객체는 호출자로부터 메소드로 이"
"동됩니다. 메소드가 객체를 소유하게 되며 따라서 명시적으로 소유권을 다른 곳으"
"로 전달하지 않는다면 메서드 종료와 함께 객체는 drop(해제)됩니다."

#: src/methods-and-traits/methods.md:62
#, fuzzy
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr ""
"`mut self`: 위와 동일하지만 메서드가 객체의 소유권을 가지면서 동시에 객체를 "
"수정할 수도 있습니다. 소유권을 가지는 것이 수정할 수 있음을 의미하는 것은 아"
"닙니다. "

#: src/methods-and-traits/methods.md:63
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"리시버 없음: 구조체의 정적 메서드가 됩니다. 주로 생성자를 만들때 사용하게 되"
"며, 생성자는 흔히 `new`라고 이름붙입니다."

#: src/methods-and-traits/methods.md:70
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "메서드를 함수와 비교하여 소개하는 것도 도움이 될 수 있습니다."

#: src/methods-and-traits/methods.md:71
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"메서드는 구조체나 열거형과 같은 타입의 인스턴스에서 호출 되며, 첫번째 매개변"
"수(파라메터)는 인스턴스를 `self`로 표기합니다."

#: src/methods-and-traits/methods.md:73
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"메서드를 이용하면 receiver 문법을 사용할 수 있고 코드를 좀더 체계적으로 정리"
"할 수 있습니다. 메서드들이 예측 가능한 위치에 모여 있으니 찾기 쉽습니다."

#: src/methods-and-traits/methods.md:76
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "메서드 receiver인 `self` 키워드 사용을 언급해 주시기 바랍니다."

#: src/methods-and-traits/methods.md:77
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"예제의 경우 `self: &Self`의 줄인 버전임을 알려주고, 구조체의 이름을 직접 사용"
"하면 어떻게 되는지 보여주는 것도 좋습니다."

#: src/methods-and-traits/methods.md:79
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"`impl` 블록 내부에서는 `Self`가 해당 타입의 이름 대용으로 사용될 수 있음을 알"
"려주세요."

#: src/methods-and-traits/methods.md:81
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"구조체의 필드를 접근할 때 점 표기를 사용하듯이 `self`에 점 표기를 사용하여 개"
"별 필드들을 접근할 수 있습니다."

#: src/methods-and-traits/methods.md:83
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"`say_hello` 함수가 두 번 호출되도록 코드를 수정하여 `&self`와 `self`가 어떻"
"게 다른지 보여주는 것도 좋습니다."

#: src/methods-and-traits/methods.md:85
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"`self`를 사용하는 이같은 변형들 외에도 `Box<Self>`와 같이 리시버 타입으로 허"
"용되는 [특별한 래퍼 타입](https://doc.rust-lang.org/reference/special-types-"
"and-traits.html)이 있습니다."

#: src/methods-and-traits/traits.md:3
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "트레잇은 타입을 추상화 하는데 사용됩니다. 인터페이스와 비슷합니다:"

#: src/methods-and-traits/traits.md:18
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr ""

#: src/methods-and-traits/traits.md:24
#: src/methods-and-traits/trait-objects.md:20
msgid "\"Woof, my name is {}!\""
msgstr ""

#: src/methods-and-traits/traits.md:30
#: src/methods-and-traits/trait-objects.md:26
msgid "\"Miau!\""
msgstr ""

#: src/methods-and-traits/traits.md:36
#: src/methods-and-traits/trait-objects.md:33
msgid "\"Fido\""
msgstr ""

#: src/methods-and-traits/traits.md:45
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr ""

#: src/methods-and-traits/traits.md:48
msgid "Traits are implemented in an `impl <trait> for <type> { .. }` block."
msgstr ""

#: src/methods-and-traits/traits.md:50
#, fuzzy
msgid ""
"Traits may specify pre-implemented (provided) methods and methods that users "
"are required to implement themselves. Provided methods can rely on required "
"methods. In this case, `greet` is provided, and relies on `talk`."
msgstr ""
"트레잇은, 그 트레잇이 정의된 위치에서 직접 구현되는 디폴트 메서드와, 거기에서"
"는 선언만 존재하고 그 트레잇을 구현하는 타입에서 구현해야 하는, 두 종류의 메"
"서드를 가질 수 있습니다. 디폴트 메서드를 구현할 때에는, 두 종류의 메서드 모"
"두 사용(호출)할 수 있습니다."

#: src/methods-and-traits/deriving.md:3
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr ""

#: src/methods-and-traits/deriving.md:15
msgid "// Default trait adds `default` constructor.\n"
msgstr ""

#: src/methods-and-traits/deriving.md:16
msgid "// Clone trait adds `clone` method.\n"
msgstr ""

#: src/methods-and-traits/deriving.md:17
msgid "\"EldurScrollz\""
msgstr ""

#: src/methods-and-traits/deriving.md:18
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr ""

#: src/methods-and-traits/deriving.md:19
msgid "\"{:?} vs. {:?}\""
msgstr ""

#: src/methods-and-traits/deriving.md:25
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""

#: src/methods-and-traits/trait-objects.md:3
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"트레잇 객체는 타입이 다른 값(예를 들어 컬렉션에 속한 각 값)들을 가질 수 있습"
"니다:"

#: src/methods-and-traits/trait-objects.md:36
msgid "\"Hello, who are you? {}\""
msgstr ""

#: src/methods-and-traits/trait-objects.md:41
msgid "Memory layout after allocating `pets`:"
msgstr "`pets`를 할당한 이후의 메모리 레이아웃:"

#: src/methods-and-traits/trait-objects.md:43
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" 스택                             힙\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    "
"pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------"
"+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  "
"|           :\n"
":                           :     :     | |   |     +---------------"
"+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                 :\n"
"                                  :     | |   |     +----------------------"
"+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    : \n"
"                                  :     | "
"|                                     : \n"
"                                  :     | |   +-"
"+                               :   \n"
"                                  :     | '-->|"
"\\|                               :     \n"
"                                  :     |     +-"
"+                               :    \n"
"                                  :     "
"|                                       : \n"
"                                  :     |     +----------------------"
"+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" "
"|          : \n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"\n"
"```"

#: src/methods-and-traits/trait-objects.md:77
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"여러 타입이 같은 트레잇을 구현하더라도 그 크기는 서로 다를 수 있습니다. 그래"
"서 `Vec<Greeet>`같은 것은 불가능합니다."

#: src/methods-and-traits/trait-objects.md:79
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet`이라고 하면이 타입의 크기는 동적이며 `Pet`을 구현하고 있다고 컴파일"
"러에게 알려주는 것입니다."

#: src/methods-and-traits/trait-objects.md:81
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""

#: src/methods-and-traits/trait-objects.md:83
#, fuzzy
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"예제에서 `pets`는 `Pet`을 구현하는 객체들의 _Fat 포인터_를 담고 있습니다. "
"Fat 포인터는 실제 객체에 대한 포인터와 그 객체가 `Pet`을 구현하고 있는 가상 "
"함수 테이블에 대한 포인터를 가집니다."

#: src/methods-and-traits/trait-objects.md:86
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""

#: src/methods-and-traits/trait-objects.md:88
msgid "Compare these outputs in the above example:"
msgstr "아래 코드의 결과와 비교해보세요:"

#: src/methods-and-traits/trait-objects.md:90
#: src/methods-and-traits/trait-objects.md:91 src/std-traits/closures.md:62
msgid "\"{} {}\""
msgstr ""

#: src/methods-and-traits/trait-objects.md:92
#: src/methods-and-traits/trait-objects.md:93
#: src/methods-and-traits/solution.md:112 src/std-traits/exercise.md:23
#: src/std-traits/solution.md:29 src/modules/solution.md:78
#: src/android/build-rules/library.md:44
#: src/android/interoperability/cpp/rust-bridge.md:17
#: src/async/pitfalls/cancellation.md:59
msgid "\"{}\""
msgstr ""

#: src/methods-and-traits/exercise.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and "
"trait objects. We'll only implement the drawing of it (as text) for "
"simplicity."
msgstr ""
"이번 연습문제에서는 트레잇와 트레잇 객체에 대해 배운것을 활용하여 고전적인 "
"GUI 라이브러리를 설계할 것입니다."

#: src/methods-and-traits/exercise.md:6
msgid "We will have a number of widgets in our library:"
msgstr "라이브러리에는 몇 가지 위젯이 있습니다:"

#: src/methods-and-traits/exercise.md:8
msgid "`Window`: has a `title` and contains other widgets."
msgstr ""
"`Window`: `title` 속성을 가지고 있으며, 다른 위젯들을 포함할 수 있습니다."

#: src/methods-and-traits/exercise.md:9
msgid ""
"`Button`: has a `label`. In reality, it would also take a callback function "
"to allow the program to do something when the button is clicked but we won't "
"include that since we're only drawing the GUI."
msgstr ""

#: src/methods-and-traits/exercise.md:12
msgid "`Label`: has a `label`."
msgstr "`Label`: `label` 속성을 가지고 있습니다."

#: src/methods-and-traits/exercise.md:14
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "위젯들은 모두 `Widget` 트레잇을 구현합니다. 아래 코드를 참조하세요."

#: src/methods-and-traits/exercise.md:16
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"아래 코드를 <https://play.rust-lang.org/>에 복사하고 누락된 `draw_into`메서드"
"를 채워 넣어 `Widget` 트레잇을 완성해봅시다:"

#: src/methods-and-traits/exercise.md:24 src/methods-and-traits/solution.md:5
#: src/modules/solution.md:36
msgid "/// Natural width of `self`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:27 src/methods-and-traits/solution.md:8
#: src/modules/solution.md:39
msgid "/// Draw the widget into a buffer.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:30 src/methods-and-traits/solution.md:11
#: src/modules/solution.md:42
msgid "/// Draw the widget on standard output.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:34 src/methods-and-traits/solution.md:15
#: src/modules/solution.md:46
msgid "\"{buffer}\""
msgstr ""

#: src/methods-and-traits/exercise.md:79
msgid "// TODO: Implement `Widget` for `Label`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:81
msgid "// TODO: Implement `Widget` for `Button`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:83
msgid "// TODO: Implement `Widget` for `Window`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:87 src/methods-and-traits/solution.md:117
#: src/modules/solution.md:183
msgid "\"Rust GUI Demo 1.23\""
msgstr ""

#: src/methods-and-traits/exercise.md:88 src/methods-and-traits/solution.md:118
#: src/modules/solution.md:185
msgid "\"This is a small text GUI demo.\""
msgstr ""

#: src/methods-and-traits/exercise.md:89 src/methods-and-traits/solution.md:119
#: src/modules/solution.md:186
msgid "\"Click me!\""
msgstr ""

#: src/methods-and-traits/exercise.md:94
msgid "The output of the above program can be something simple like this:"
msgstr "위 프로그램의 출력은 아래와 같습니다:"

#: src/methods-and-traits/exercise.md:106
msgid ""
"If you want to draw aligned text, you can use the [fill/alignment](https://"
"doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting operators. In "
"particular, notice how you can pad with different characters (here a `'/'`) "
"and how you can control alignment:"
msgstr ""
"텍스트를 줄맞춤 해서 그리려면 [fill/alignment](https://doc.rust-lang.org/std/"
"fmt/index.html#fillalignment)를 참조하시기 바랍니다. 특수 문자(여기서는 "
"`'/'`)로 패딩을 주는 방법과 정렬을 제어하는 방법을 확인하시기 바랍니다:"

#: src/methods-and-traits/exercise.md:114
msgid "\"left aligned:  |{:/<width$}|\""
msgstr ""

#: src/methods-and-traits/exercise.md:115
msgid "\"centered:      |{:/^width$}|\""
msgstr ""

#: src/methods-and-traits/exercise.md:116
msgid "\"right aligned: |{:/>width$}|\""
msgstr ""

#: src/methods-and-traits/exercise.md:120
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr "위의 정렬 트릭을 사용하여 다음과 같은 출력을 생성할 수 있습니다:"

#: src/methods-and-traits/solution.md:63
msgid "// Add 4 paddings for borders\n"
msgstr ""

#: src/methods-and-traits/solution.md:75 src/modules/solution.md:162
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""

#: src/methods-and-traits/solution.md:78 src/methods-and-traits/solution.md:84
#: src/modules/solution.md:165 src/modules/solution.md:171
msgid "\"+-{:-<inner_width$}-+\""
msgstr ""

#: src/methods-and-traits/solution.md:78 src/methods-and-traits/solution.md:80
#: src/methods-and-traits/solution.md:84 src/methods-and-traits/solution.md:98
#: src/methods-and-traits/solution.md:102 src/modules/solution.md:110
#: src/modules/solution.md:114 src/modules/solution.md:165
#: src/modules/solution.md:167 src/modules/solution.md:171
#: src/testing/unit-tests.md:27 src/testing/solution.md:89
msgid "\"\""
msgstr ""

#: src/methods-and-traits/solution.md:79 src/modules/solution.md:166
msgid "\"| {:^inner_width$} |\""
msgstr ""

#: src/methods-and-traits/solution.md:80 src/modules/solution.md:167
msgid "\"+={:=<inner_width$}=+\""
msgstr ""

#: src/methods-and-traits/solution.md:82 src/modules/solution.md:169
msgid "\"| {:inner_width$} |\""
msgstr ""

#: src/methods-and-traits/solution.md:90 src/modules/solution.md:100
msgid "// add a bit of padding\n"
msgstr ""

#: src/methods-and-traits/solution.md:98 src/methods-and-traits/solution.md:102
#: src/modules/solution.md:110 src/modules/solution.md:114
msgid "\"+{:-<width$}+\""
msgstr ""

#: src/methods-and-traits/solution.md:100 src/modules/solution.md:112
msgid "\"|{:^width$}|\""
msgstr ""

#: src/generics/generic-functions.md:3
#, fuzzy
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"러스트는 제네릭을 지원합니다. 이를 이용하면 알고리즘(정렬과 같은)이나 데이터 "
"구조(이진 트리 같은)를 추상화 하여 특정 타입에 의존하지 않도록 할 수 있습니"
"다."

#: src/generics/generic-functions.md:7
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr ""

#: src/generics/generic-functions.md:17
msgid "\"picked a number: {:?}\""
msgstr ""

#: src/generics/generic-functions.md:18
msgid "\"picked a tuple: {:?}\""
msgstr ""

#: src/generics/generic-functions.md:18
msgid "\"dog\""
msgstr ""

#: src/generics/generic-functions.md:18
msgid "\"cat\""
msgstr ""

#: src/generics/generic-functions.md:24
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr ""

#: src/generics/generic-functions.md:26
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""

#: src/generics/generic-functions.md:32
#, fuzzy
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"이것이 바로 비용이 들지 않는 (zero-cost) 추상화 입니다: 러스트의 제네릭은 추"
"상화를 거치지 않고 직접 구체적인 타입을 써서 코딩한 것과 정확히 동일한 결과"
"를 보여줍니다."

#: src/generics/generic-data.md:3
msgid "You can use generics to abstract over the concrete field type:"
msgstr "제네릭을 사용하여 필드의 타입을 추상화 할 수 있습니다:"

#: src/generics/generic-data.md:17
msgid "// fn set_x(&mut self, x: T)\n"
msgstr ""

#: src/generics/generic-data.md:23
msgid "\"{integer:?} and {float:?}\""
msgstr ""

#: src/generics/generic-data.md:24
msgid "\"coords: {:?}\""
msgstr ""

#: src/generics/generic-data.md:30
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr "_질문:_ `impl<T> Point<T> {}`에서 `T`가 왜 두 번 사용됩니까?"

#: src/generics/generic-data.md:32
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"제네릭 타입에 대한 제네릭 구현 이기 때문입니다. 이 두 제네릭은 서로 독립적입"
"니다."

#: src/generics/generic-data.md:34
msgid "It means these methods are defined for any `T`."
msgstr ""
"이는 임의의 모든 `T`에 대해서 이 메소드들이 정의된다는 것을 의미합니다."

#: src/generics/generic-data.md:35
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "`impl Point<u32> { .. }`와 같이 작성하는 것도 가능합니다. "

#: src/generics/generic-data.md:36
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point`는 여전히 제네릭이며 `Point<f64>`를 사용할 수도 있지만 이 블록의 메서"
"드는 `Point<u32>`만 쓸 수 있습니다."

#: src/generics/generic-data.md:39
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""

#: src/generics/trait-bounds.md:3
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"제네릭을 이용하다 보면 타입이 어떤 트레잇을 구현하고 있어야 하는 경우가 있습"
"니다. 그래야 그 트레잇의 메서드를 호출할 수 있기 때문입니다."

#: src/generics/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "`T: Trait` 혹은 `impl Trait`를 사용하면 됩니다:"

#: src/generics/trait-bounds.md:12
msgid "// struct NotClonable;\n"
msgstr ""

#: src/generics/trait-bounds.md:18
msgid "\"{pair:?}\""
msgstr ""

#: src/generics/trait-bounds.md:24
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr ""

#: src/generics/trait-bounds.md:26
msgid "When multiple traits are necessary, use `+` to join them."
msgstr ""

#: src/generics/trait-bounds.md:28
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"`where` 문법을 사용할 수도 있습니다. 수강생들도 코드를 읽다가 그 문법을 마주"
"할 수 있습니다."

#: src/generics/trait-bounds.md:39
msgid "It declutters the function signature if you have many parameters."
msgstr ""
"이를 이용하면 타입 파라메터가 많은 경우 함수 시그니처를 간결하게 정리하는 데 "
"도움이 됩니다."

#: src/generics/trait-bounds.md:40
msgid "It has additional features making it more powerful."
msgstr "좀 더 강력한 추가 기능도 제공합니다."

#: src/generics/trait-bounds.md:41
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr "`:` 왼쪽에 임의의 타입(예를 들어 `Option<T>`)을 사용할 수 있습니다."

#: src/generics/trait-bounds.md:44
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""

#: src/generics/impl-trait.md:3
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"트레잇 바운드와 유사하게 `impl Trait` 문법은 함수의 인자와 반환값에도 적용 가"
"능합니다:"

#: src/generics/impl-trait.md:7
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""

#: src/generics/impl-trait.md:19
msgid "\"{many}\""
msgstr ""

#: src/generics/impl-trait.md:21
msgid "\"{many_more}\""
msgstr ""

#: src/generics/impl-trait.md:23
msgid "\"debuggable: {debuggable:?}\""
msgstr ""

#: src/generics/impl-trait.md:29
#, fuzzy
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr "`impl Trait`는 어디에 사용되었느냐에 따라 의미가 조금씩 다릅니다."

#: src/generics/impl-trait.md:32
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"함수 인자의 타입으로 사용되었을 경우에는 `impl Trait`는 트레잇 경계가 있는 익"
"명의 제네릭 타입을 의미합니다."

#: src/generics/impl-trait.md:35
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"리턴 타입으로 사용되었을 경우에는, 그 트레잇을 구현하는 구체적인 타입인데, 타"
"입 이름을 프로그래머가 짓지 않았다는 것을 의미합니다. 이는 그 구체적인 타입 "
"이름을 API로 공개하고 싶지 않은 경우에 유용합니다."

#: src/generics/impl-trait.md:39
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"함수가 리턴되는 곳에서의 타입 추론은 어렵습니다. 어떤 함수의 리턴 타입이 "
"`impl Foo`로 선언되어 있을 경우, 그 함수가 실제로 리턴하는 타입은 소스 코드 "
"상 어디에도 나타나 있지 않습니다. `collect<B<() -> B`와 같이 제너릭 타입을 리"
"턴하는 함수는 `B`를 만족하는 어떤 타입도 리턴할 수 있습니다. 이 경우, 호출하"
"는 측에서는 `let x: Vec<_> = foo.collect()`나 터보피시 문법을 써서 `foo."
"collect::<Vec<_>>()`와 같이 리턴 타입을 명시적으로 써 주어야 할 수도 있습니"
"다."

#: src/generics/impl-trait.md:46
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""

#: src/generics/exercise.md:3
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using a `LessThan` trait."
msgstr ""

#: src/generics/exercise.md:8 src/generics/solution.md:5
msgid "/// Return true if self is less than other.\n"
msgstr ""

#: src/generics/exercise.md:29
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr ""

#: src/generics/exercise.md:33 src/generics/solution.md:36
msgid "\"Shapiro\""
msgstr ""

#: src/generics/exercise.md:34 src/generics/exercise.md:35
#: src/generics/solution.md:37 src/generics/solution.md:38
msgid "\"Baumann\""
msgstr ""

#: src/std-types.md:7
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""

#: src/std-types/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"러스트에서 제공하는 표준 라이브러리는 러스트로 라이브러리나 프로그램을 작성"
"할 때 공통적으로 사용할 수 있는 여러 타입들을 포함하고 있습니다. 이를 통해 서"
"로 다른 두 라이브러리라 하더라도 함께 사용하는데 큰 어려움이 없게 됩니다. 예"
"를 들면 두 라이브러리 모두 같은 `String` 타입을 사용하기 때문입니다."

#: src/std-types/std.md:7
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr ""
"사실, 러스트의 표준 라이브러리는 `core`, `alloc`, `std`와 같이 계층(layer)으"
"로 나눠집니다. "

#: src/std-types/std.md:10
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core`는 `libc`나 할당자(allocator), 심지어 OS에도 의존하지 않는 가장 기본적"
"인 함수와 타입을 포함합니다. "

#: src/std-types/std.md:12
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc`은 `Vec`, `Box`, `Arc`와 같이 전역 힙 할당이 필요한 타입을 포함합니다."

#: src/std-types/std.md:14
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"임베디드 러스트 응용프로그램은 주로 `core`만 사용하거나 가끔 `alloc`을 함께 "
"사용합니다."

#: src/std-types/docs.md:3
msgid "Rust comes with extensive documentation. For example:"
msgstr ""

#: src/std-types/docs.md:5
#, fuzzy
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"루프를 조기에 종료하려면 [`break`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#break-expressions)를 사용합니다,"

#: src/std-types/docs.md:7
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""

#: src/std-types/docs.md:9
#, fuzzy
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html)과 [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/std-types/docs.md:13
msgid "In fact, you can document your own code:"
msgstr ""

#: src/std-types/docs.md:16
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""

#: src/std-types/docs.md:27
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"콘텐츠는 마크다운으로 처리됩니다. 게시된 모든 Rust 라이브러리 크레이트는 "
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) 도구를 사용"
"하여 [`docs.rs`](https://docs.rs)에 자동으로 문서화됩니다. 일반적으로 API의 "
"모든 공개 항목은 이 패턴을 사용하여 문서화됩니다."

#: src/std-types/docs.md:32
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""

#: src/std-types/docs.md:36
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr ""

#: src/std-types/docs.md:41
#, fuzzy
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"[`docs.rs/rand`](https://docs.rs/rand)에서 `rand` 크레이트용으로 생성된 문서"
"를 보여줍니다."

#: src/std-types/option.md:1
#, fuzzy
msgid "Option"
msgstr "예외"

#: src/std-types/option.md:3
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""

#: src/std-types/option.md:10
msgid "\"Löwe 老虎 Léopard Gepardi\""
msgstr ""

#: src/std-types/option.md:11
msgid "'é'"
msgstr ""

#: src/std-types/option.md:12 src/std-types/option.md:15
msgid "\"find returned {position:?}\""
msgstr ""

#: src/std-types/option.md:14
msgid "'Z'"
msgstr ""

#: src/std-types/option.md:16
msgid "\"Character not found\""
msgstr ""

#: src/std-types/option.md:22
#, fuzzy
msgid "`Option` is widely used, not just in the standard library."
msgstr ""
"`Option`과 `Result`는 표준 라이브러리뿐만아니라 매우 광범위하게 사용되는 타입"
"입니다."

#: src/std-types/option.md:23
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""

#: src/std-types/option.md:25
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr ""

#: src/std-types/option.md:27
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""

#: src/std-types/option.md:29
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr ""

#: src/std-types/result.md:1
msgid "Result"
msgstr ""

#: src/std-types/result.md:3
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different type. This is similar to the `Res` defined "
"in the expression exercise, but generic: `Result<T, E>` where `T` is used in "
"the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""

#: src/std-types/result.md:13
msgid "\"diary.txt\""
msgstr ""

#: src/std-types/result.md:18
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr ""

#: src/std-types/result.md:20
msgid "\"Could not read file content\""
msgstr ""

#: src/std-types/result.md:24
msgid "\"The diary could not be opened: {err}\""
msgstr ""

#: src/std-types/result.md:32
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"`Option`와 마찬가지로, 성공한 경우의 값은 `Result` 내부에 있습니다. 그래서, "
"개발자는 명시적으로 이를 추출하여야 합니다. 이렇게 함으로써 값을 읽기 전에 오"
"류 발생 여부를 반드시 체크하도록 유도하고 있습니다. 만일 오류가 절대 발생하"
"지 않는 경우라면 `unwrap()`이나 `expect()`를 사용할 수 있으며, 이는 개발자의 "
"의도(_역주_: 오류가 발생할 수 없음)을 명시적으로 나타내는 방법이기도 합니다."

#: src/std-types/result.md:36
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"수업중엔 아니지만 `Result`의 API 레퍼런스를 읽는 것을 권장합니다. 함수형 프로"
"그래밍 스타일에 도움이 되는 편리한 메서드와 함수를 많이 배울 수 있습니다. "

#: src/std-types/result.md:39
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr ""
"`Result`는 오류 처리를 위한 표준 타입입니다. 3일차 과정에서 살펴봅니다."

#: src/std-types/string.md:1
msgid "String"
msgstr "String"

#: src/std-types/string.md:3
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html)은 힙에 할"
"당되고 가변 길이의 표준 UTF-8 문자열 버퍼입니다:"

#: src/std-types/string.md:8 src/std-traits/read-and-write.md:35
#: src/memory-management/review.md:23 src/memory-management/review.md:57
#: src/testing/unit-tests.md:32 src/testing/unit-tests.md:37
#: src/concurrency/scoped-threads.md:9 src/concurrency/scoped-threads.md:26
msgid "\"Hello\""
msgstr ""

#: src/std-types/string.md:9
msgid "\"s1: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/string.md:13
msgid "'!'"
msgstr ""

#: src/std-types/string.md:14
msgid "\"s2: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/string.md:16
msgid "\"🇨🇭\""
msgstr ""

#: src/std-types/string.md:17
msgid "\"s3: len = {}, number of chars = {}\""
msgstr ""

#: src/std-types/string.md:21
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String`은 [`Deref<Target = str>`](https://doc.rust-lang.org/std/string/"
"struct.String.html#deref-methods-str)을 구현합니다. 이는 , `String` 값에 대해"
"서도 `str`의 모든 메서드를 호출 할 수 있다는 의미 입니다."

#: src/std-types/string.md:29
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new`는 새로운 빈 문자열을 반환합니다. `String::with_capacity`는 새"
"로 만들 문자열 버퍼에 넣을 데이터 크기를 알고 있는 경우에 사용할 수 있습니다."

#: src/std-types/string.md:31
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len`은 `String`의 바이트 크기를 반환합니다. (실제 문자 개수와는 다"
"를 수 있습니다.)"

#: src/std-types/string.md:33
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars`는 실제 문자(character)들에 대한 이터레이터를 반환합니다. "
"`char`로 표현되는 문자는 우리가 실제로 인식하고 사용하는 문자와는 다를 수 있"
"습니다. 자소 결합으로 문자를 표현하는 경우가 있기 때문입니다. 이에 대해서는 "
"[Grapheme Cluster](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)를 참고하세요."

#: src/std-types/string.md:36
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr "사람들이 문자열이라고 말할 때에는 `&str`이거나 `String`일 수 있습니다."

#: src/std-types/string.md:38
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"어떤 타입이 `Deref<Target = T>`를 구현하고 있으면, 컴파일러는 여러분이 `T`의 "
"메소드들을 호출할 수 있게 도와줍니다."

#: src/std-types/string.md:40
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr ""

#: src/std-types/string.md:42
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String`은 `Deref<Target = str>`을 구현하고 있기 때문에 `String`에 대해서도 "
"`str` 메소드들을 호출할 수 있습니다."

#: src/std-types/string.md:44
#, fuzzy
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "`let s3 = s1.deref();`와 `let s3 = &*s1;`을 비교해보세요."

#: src/std-types/string.md:45
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String`은 바이트 벡터의 래퍼로 구현되어 있습니다. 벡터가 지원하는 여러가지 "
"연산들을 `String`도 지원합니다. 다만 `String`은 몇가지 보장 내용이 더 있습니"
"다."

#: src/std-types/string.md:48
msgid "Compare the different ways to index a `String`:"
msgstr "`String`을 인덱스로 접근하는 방법들을 비교해보세요:"

#: src/std-types/string.md:49
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"`s3.chars().nth(i).unwrap()`를 이용하여 한 문자를 선택하는 경우, `i`값이 범위"
"를 벗어날 때, 벗어나지 않을 때 동작을 설명하세요."

#: src/std-types/string.md:51
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"`s3[0..4]`를 이용해서 문자열의 일부를 선택하는데, 슬라이스가 유니코드 문자열 "
"경계에 딱 맞지 않을 경우 어떻게 되는지 설명하세요."

#: src/std-types/vec.md:3
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) 는 힙에 할당된 표"
"준 가변 크기 버퍼입니다:"

#: src/std-types/vec.md:9
msgid "\"v1: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/vec.md:14
msgid "\"v2: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/vec.md:16
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr ""

#: src/std-types/vec.md:19
msgid "// Retain only the even elements.\n"
msgstr ""

#: src/std-types/vec.md:21 src/std-types/vec.md:25
msgid "\"{v3:?}\""
msgstr ""

#: src/std-types/vec.md:23
msgid "// Remove consecutive duplicates.\n"
msgstr ""

#: src/std-types/vec.md:29
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec`은 [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#deref-methods-%5BT%5D)를 구현합니다. 이는 `Vec`에서 슬라이스 메서드를 호"
"출 할 수 있다는 의미입니다."

#: src/std-types/vec.md:37
#, fuzzy
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec`은 `String`이나 `HashMap`과 같은 컬렉션 타입입니다. 벡터는 데이터를 힙"
"에 저장합니다. 이는 컴파일 시점에 데이터 크기를 알 필요가 없다는 의미고, 런타"
"임에 더 커질 수도 작아질 수도 있습니다."

#: src/std-types/vec.md:40
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"`Vec<T>`는 제네릭 타입이기도 합니다. 하지만 `T`를 꼭 지정해줄 필요는 없습니"
"다. 이 경우, 러스트 타입 추론이 벡터에 처음 `push`하는 데이터로 `T`를 알 수 "
"있었습니다."

#: src/std-types/vec.md:43
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]`는 `Vec::new()` 대신 쓸 수 있는 표준 매크로로서, 초기 데이터를 추"
"가한 벡터를 생성할 수 있습니다."

#: src/std-types/vec.md:45
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"벡터는 `[` `]`를 사용하여 인덱스로 접근할 수 있습니다. 하지만 범위를 벗어나"
"면 패닉이 발생합니다. 대신 `get`을 사용하면 `Option`을 반환합니다. `pop` 함수"
"는 마지막 요소를 제거합니다."

#: src/std-types/vec.md:48
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""

#: src/std-types/hashmap.md:3
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "HashDoS 공격으로부터 보호되는 표준 해시 맵입니다:"

#: src/std-types/hashmap.md:10
msgid "\"Adventures of Huckleberry Finn\""
msgstr ""

#: src/std-types/hashmap.md:11
msgid "\"Grimms' Fairy Tales\""
msgstr ""

#: src/std-types/hashmap.md:12 src/std-types/hashmap.md:21
#: src/std-types/hashmap.md:29
msgid "\"Pride and Prejudice\""
msgstr ""

#: src/std-types/hashmap.md:14
msgid "\"Les Misérables\""
msgstr ""

#: src/std-types/hashmap.md:16
msgid "\"We know about {} books, but not Les Misérables.\""
msgstr ""

#: src/std-types/hashmap.md:21 src/std-types/hashmap.md:29
msgid "\"Alice's Adventure in Wonderland\""
msgstr ""

#: src/std-types/hashmap.md:23
msgid "\"{book}: {count} pages\""
msgstr ""

#: src/std-types/hashmap.md:24
msgid "\"{book} is unknown.\""
msgstr ""

#: src/std-types/hashmap.md:28
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr ""

#: src/std-types/hashmap.md:34
msgid "\"{page_counts:#?}\""
msgstr ""

#: src/std-types/hashmap.md:40
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap`은 prelude에 정의되어 있지 않기 때문에 명시적으로 추가해줘야 합니다."

#: src/std-types/hashmap.md:41
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"아래 코드를 테스트해보세요. 첫 문장에서는 해시맵에 책이 있는지 검사하여, 없으"
"면 디폴트 값을 반환합니다. 두번 째 문장에서는 해시맵에 해당 책이 없는 경우, "
"지정한 값을 해시맵에 추가한 뒤 그 값을 반환합니다."

#: src/std-types/hashmap.md:47 src/std-types/hashmap.md:59
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr ""

#: src/std-types/hashmap.md:50 src/std-types/hashmap.md:60
msgid "\"The Hunger Games\""
msgstr ""

#: src/std-types/hashmap.md:53
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr "안타깝지만 `hashmap!`같은 매크로가 없습니다."

#: src/std-types/hashmap.md:54
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"러스트 1.56부터는 `HashMap`이 [`From<[(K, V); N]>`](https://doc.rust-lang."
"org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);"
"+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E)을 구현하기 때문에 배열 리터럴을 "
"이용하여 쉽게 해시맵을 초기화할 수 있습니다:"

#: src/std-types/hashmap.md:64
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr "키-값 쌍에 대한 `Iterator`로 해시맵을 만들 수도 있습니다."

#: src/std-types/hashmap.md:66
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"예제 코드에서는 편의상 해시맵의 키로 `&str`를 사용하지 않았습니다. 물론 컬렉"
"션에 참조를 사용할 수도 있습니다. 다만 참조를 사용하게 되면 빌림 검사기 때문"
"에 복잡해 질 수 있습니다."

#: src/std-types/hashmap.md:69
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"예제 코드에서 `to_string()`을 없애도 컴파일에 문제가 없는지 확인해보세요. 어"
"떤 문제에 부딪힐까요?"

#: src/std-types/hashmap.md:72
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"해시맵의 몇 몇 메서드는 해시맵 내부의 특별한 타입(예를 들어 `std::"
"collections::hash_map::Keys`)들을 리턴합니다. 이러한 타입들은 Rust 문서에서"
"도 검색할 수 있습니다. 수강생들에게 이 타입들에 대한 문서를 보여주고, 이 문서"
"에 `keys` 메서드로의 역 링크가 있음을 알려주세요."

#: src/std-types/exercise.md:3
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""

#: src/std-types/exercise.md:9
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""

#: src/std-types/exercise.md:13
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""

#: src/std-types/exercise.md:20 src/std-types/solution.md:6
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr ""

#: src/std-types/exercise.md:27 src/std-types/solution.md:13
msgid "/// Create a new Counter.\n"
msgstr ""

#: src/std-types/exercise.md:34 src/std-types/solution.md:18
msgid "/// Count an occurrence of the given value.\n"
msgstr ""

#: src/std-types/exercise.md:43 src/std-types/solution.md:23
msgid "/// Return the number of times the given value has been seen.\n"
msgstr ""

#: src/std-types/exercise.md:59 src/std-types/solution.md:39
msgid "\"saw {} values equal to {}\""
msgstr ""

#: src/std-types/exercise.md:63 src/std-types/exercise.md:65
#: src/std-types/exercise.md:66 src/std-types/solution.md:43
#: src/std-types/solution.md:45 src/std-types/solution.md:46
msgid "\"apple\""
msgstr ""

#: src/std-types/exercise.md:64 src/std-types/solution.md:44
msgid "\"orange\""
msgstr ""

#: src/std-types/exercise.md:66 src/std-types/solution.md:46
msgid "\"got {} apples\""
msgstr ""

#: src/std-traits.md:7
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr ""

#: src/std-traits.md:10
msgid "This section is long. Take a break midway through."
msgstr ""

#: src/std-traits/comparisons.md:3
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""

#: src/std-traits/comparisons.md:6
msgid "`PartialEq` and `Eq`"
msgstr ""

#: src/std-traits/comparisons.md:8
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""

#: src/std-traits/comparisons.md:23
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""

#: src/std-traits/comparisons.md:27
#, fuzzy
msgid "`PartialOrd` and `Ord`"
msgstr "`Read`와 `Write`"

#: src/std-traits/comparisons.md:29
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""

#: src/std-traits/comparisons.md:49
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr ""

#: src/std-traits/comparisons.md:53
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr ""

#: src/std-traits/comparisons.md:68
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr ""

#: src/std-traits/operators.md:3
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr "연산자 오버로드는 `std::ops`에 있는 다양한 트레잇들을 통해 구현됩니다:"

#: src/std-traits/operators.md:23
msgid "\"{:?} + {:?} = {:?}\""
msgstr ""

#: src/std-traits/operators.md:29 src/memory-management/drop.md:47
msgid "Discussion points:"
msgstr "논의점:"

#: src/std-traits/operators.md:31
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr ""
"`&Point`가 `Add`를 구현하도록 할 수도 있습니다. 이게 어떤 경우에 유용할까요? "

#: src/std-traits/operators.md:32
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"답: `Add:add`는 `self`를 소모합니다. 만약 타입 `T`가 `Copy`트레잇을 구현하고 "
"있지 않다면 `&T`에 대해서도 연산자 오버로딩을 고려해야 합니다. 이렇게 하면 호"
"출부에서 불필요한 복사를 피할 수 있습니다."

#: src/std-traits/operators.md:35
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr "왜 `Output`이 연관된 타입인가요? 타입 파라메터로 만들 수 있을까요?"

#: src/std-traits/operators.md:37
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"답: 타입 파라메터를 호출하는 쪽에서 결정합니다. 반면 연관된 타입(`Output`같"
"은) 은 트레잇을 구현하는 쪽에서 제어 가능합니다."

#: src/std-traits/operators.md:40
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"`Add`를 이용해서 서로 다른 두 개의 타입을 더할 수도 있습니다. 예를 들어 "
"`impl Add<(i32, i32)> for Point`는 튜플을 `Point`에 더할 수 있게 해 줍니다."

#: src/std-traits/from-and-into.md:3
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"타입은 용이한 형변환을 위해 [`From`](https://doc.rust-lang.org/std/convert/"
"trait.From.html)과 [`Into`](https://doc.rust-lang.org/std/convert/trait.Into."
"html)를 구현합니다:"

#: src/std-traits/from-and-into.md:11 src/std-traits/from-and-into.md:23
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr ""

#: src/std-traits/from-and-into.md:15
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html)이 구현되면 "
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) 역시 자동으"
"로 구현됩니다:"

#: src/std-traits/from-and-into.md:29
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"그렇기 때문에 사용자 정의 타입의 경우에도 `From` 만 구현하는 것이 일반적입니"
"다."

#: src/std-traits/from-and-into.md:31
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"\"`String`으로 변환할 수 있는 모든 것\"과 같은 함수의 인수 타입을 선언할 때에"
"는 `Into`를 사용해야 함을 조심하세요. 그래야만, 함수는 `From`을 구현한 타입"
"과 `Into` _만_ 구현한 타입 모두를 인자로 받을 수 있습니다."

#: src/std-traits/casting.md:3
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""

#: src/std-traits/casting.md:9
msgid "\"as u16: {}\""
msgstr ""

#: src/std-traits/casting.md:10
msgid "\"as i16: {}\""
msgstr ""

#: src/std-traits/casting.md:11
msgid "\"as u8: {}\""
msgstr ""

#: src/std-traits/casting.md:15
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""

#: src/std-traits/casting.md:19
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""

#: src/std-traits/casting.md:25
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""

#: src/std-traits/casting.md:32
msgid "Consider taking a break after this slide."
msgstr ""

#: src/std-traits/casting.md:34
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""

#: src/std-traits/casting.md:37
msgid "This is common in casting integers to `usize` for use as an index."
msgstr ""

#: src/std-traits/read-and-write.md:3
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html)와 [`BufRead`]"
"(https://doc.rust-lang.org/std/io/trait.BufRead.html)를 사용하면 `u8` 타입의 "
"데이터 스트림을 읽을 수 있습니다:"

#: src/std-traits/read-and-write.md:14
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr ""

#: src/std-traits/read-and-write.md:15
msgid "\"lines in slice: {}\""
msgstr ""

#: src/std-traits/read-and-write.md:18
msgid "\"lines in file: {}\""
msgstr ""

#: src/std-traits/read-and-write.md:23
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr "이와 비슷하게, `Write`를 사옹하면 `u8` 타입의 데이터를 쓸 수 있습니다:"

#: src/std-traits/read-and-write.md:30
msgid "\"\\n\""
msgstr ""

#: src/std-traits/read-and-write.md:36 src/slices-and-lifetimes/str.md:12
msgid "\"World\""
msgstr ""

#: src/std-traits/read-and-write.md:37
msgid "\"Logged: {:?}\""
msgstr ""

#: src/std-traits/default.md:1
msgid "The `Default` Trait"
msgstr "`Default` 트레잇"

#: src/std-traits/default.md:3
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) 트레잇"
"은 어떤 타입에 대한 기본값을 제공합니다."

#: src/std-traits/default.md:18
msgid "\"John Smith\""
msgstr ""

#: src/std-traits/default.md:24
msgid "\"{default_struct:#?}\""
msgstr ""

#: src/std-traits/default.md:27
msgid "\"Y is set!\""
msgstr ""

#: src/std-traits/default.md:28
msgid "\"{almost_default_struct:#?}\""
msgstr ""

#: src/std-traits/default.md:31 src/slices-and-lifetimes/exercise.md:211
#: src/slices-and-lifetimes/solution.md:214
msgid "\"{:#?}\""
msgstr ""

#: src/std-traits/default.md:37
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"트레잇을 직접 구현하거나 `#[derive(Default)]`를 붙여서 컴파일러에게 구현을 맡"
"길 수 있습니다."

#: src/std-traits/default.md:38
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"컴파일러가 제공하는 자동 구현의 경우 모든 필드에 대해 기본 값을 설정한 새 인"
"스턴스를 반환합니다."

#: src/std-traits/default.md:40
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"이는 구조체의 각 필드 타입들이 모두 `Default` 트레잇을 구현해야 함을 의미합니"
"다."

#: src/std-traits/default.md:41
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"러스트 표준 타입들은 대부분 `Default`를 구현하고 있으며, 기본 값은 `0`이나 "
"`\"\"`처럼 예상 가능한 값들입니다."

#: src/std-traits/default.md:43
#, fuzzy
msgid "The partial struct initialization works nicely with default."
msgstr ""
"구조체의 일부분만 복사하고 싶을 때 `default`를 편리하게 사용할 수 있습니다."

#: src/std-traits/default.md:44
#, fuzzy
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"러스트 표준 라이브러리는 `Default` 트레잇을 구현한 타입을 위한 편의 메서드를 "
"제공하기도 합니다."

#: src/std-traits/default.md:46
#, fuzzy
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"이 `..` 문법은 [구조체 업데이트 문법(struct update syntax)](https://doc.rust-"
"lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-"
"instances-with-struct-update-syntax)라고 합니다"

#: src/std-traits/closures.md:3
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"클로저 혹은 람다표현식은 익명타입입니다. 이들은 [`Fn`](https://doc.rust-lang."
"org/std/ops/trait.Fn.html),[`FnMut`](https://doc.rust-lang.org/std/ops/trait."
"FnMut.html), [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) "
"라는 특별한 트레잇을 구현합니다:"

#: src/std-traits/closures.md:10
#, fuzzy
msgid "\"Calling function on {input}\""
msgstr "안전하지 않은 함수 호출"

#: src/std-traits/closures.md:16 src/std-traits/closures.md:17
msgid "\"add_3: {}\""
msgstr ""

#: src/std-traits/closures.md:24 src/std-traits/closures.md:25
msgid "\"accumulate: {}\""
msgstr ""

#: src/std-traits/closures.md:28
msgid "\"multiply_sum: {}\""
msgstr ""

#: src/std-traits/closures.md:34
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"`Fn`(예를 들어 `add_3`)은 캡처된 값을 소모도 변경도 하지 않고, 혹은 어떤 것"
"도 캡쳐하지 않았을 수도 있기 때문에 동시에 여러번 호출할 수 있습니다."

#: src/std-traits/closures.md:37
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"`FnMut`(예를 들어 `accumulate`)는 캡처된 값을 변경할 수 있으므로 여러 번 호출"
"은 가능하지만 동시에 호출 할 수는 없습니다."

#: src/std-traits/closures.md:40
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"`FnOnce` (예를 들어 `multiply_sum`)는 한번만 호출되며 캡처된 값을 소모합니다."

#: src/std-traits/closures.md:43
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` 는 `FnOnce`의 하위타입입니다. `Fn`은 `FnMut`과 `FnOnce`의 하위 타입입"
"니다. 즉, `FnMut`는 `FnOnce`가 호출되는 곳이면 어디서나 사용 할 수 있고 `Fn`"
"은 `FnMut`와 `FnOnce`가 호출되는 곳이면 어디든 사용할 수 있습니다."

#: src/std-traits/closures.md:47
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""

#: src/std-traits/closures.md:51
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(it can be passed everywhere), then `FnMut`, and lastly `FnOnce`."
msgstr ""

#: src/std-traits/closures.md:54
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"컴파일러는 클로저가 무엇을 캡쳐하는지에 따라 `Copy`(예를 들어 `add_3`)과 "
"`Clone`(예를 들어 `multiply_sum`)을 알아서 추론합니다."

#: src/std-traits/closures.md:57
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"기본적으로 클로져는, 가능하다면, 참조를 사용하여 캡쳐를 합니다. `move` 키워드"
"를 쓰면 값으로 캡쳐가 됩니다."

#: src/std-traits/closures.md:66
msgid "\"Hi\""
msgstr ""

#: src/std-traits/closures.md:67
msgid "\"there\""
msgstr ""

#: src/std-traits/exercise.md:3
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""

#: src/std-traits/exercise.md:15
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr ""

#: src/std-traits/exercise.md:20 src/std-traits/exercise.md:33
#: src/std-traits/solution.md:26 src/std-traits/solution.md:39
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr ""

#: src/std-traits/exercise.md:36 src/std-traits/solution.md:42
msgid "\"To get to the other side!\""
msgstr ""

#: src/std-traits/exercise.md:55
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""

#: src/std-traits/solution.md:16
msgid "'A'"
msgstr ""

#: src/welcome-day-3.md:1
msgid "Welcome to Day 3"
msgstr "3일차 개요"

#: src/welcome-day-3.md:3
msgid "Today, we will cover:"
msgstr ""

#: src/welcome-day-3.md:5
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr ""

#: src/welcome-day-3.md:7
msgid "Smart pointers: standard library pointer types."
msgstr ""

#: src/memory-management/review.md:3
msgid "Programs allocate memory in two ways:"
msgstr ""

#: src/memory-management/review.md:5
msgid "Stack: Continuous area of memory for local variables."
msgstr "스택: 로컬 변수를 위한 연속적인 메모리 영역."

#: src/memory-management/review.md:6
msgid "Values have fixed sizes known at compile time."
msgstr "여기 저장되는 값은 컴파일 시 결정되는 고정 크기를 갖습니다."

#: src/memory-management/review.md:7
msgid "Extremely fast: just move a stack pointer."
msgstr ""
"매우 빠름: 메모리 할당/반환이 단지 스택 포인터의 이동만으로 구현됩니다."

#: src/memory-management/review.md:8
msgid "Easy to manage: follows function calls."
msgstr "관리가 쉬움: 함수가 호출되면 할당되고, 리턴하면 반환됩니다."

#: src/memory-management/review.md:9
msgid "Great memory locality."
msgstr "스택에 있는 값들은 매우 높은 메모리 인접성을 가집니다."

#: src/memory-management/review.md:11
msgid "Heap: Storage of values outside of function calls."
msgstr "힙: 함수 호출/리턴과 상관 없이 유지되는 값이 저장되는 곳."

#: src/memory-management/review.md:12
msgid "Values have dynamic sizes determined at runtime."
msgstr "여기 저장되는 값은 프로그램 수행시 그 크기가 결정됩니다."

#: src/memory-management/review.md:13
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "스택 보다는 느림: 메모리 할당/반환시 해야 할 일이 좀 더 있습니다."

#: src/memory-management/review.md:14
msgid "No guarantee of memory locality."
msgstr "메모리 인접성을 보장하지 않습니다."

#: src/memory-management/review.md:18
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"`String`을 하나 만들게 되면, 스택에는 고정된 크기의 메타 데이터가 생성되고, "
"힙에는 가변 크기의 데이터, 즉, 실제 문자열, 이 생성됩니다:"

#: src/memory-management/review.md:43
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"문자열(`String`)은 실제로는 `Vec`입니다. 크기(capacity)와 현재 길이(length) "
"정보를 가지며, 더 큰 크기가 필요할 경우 힙에서 재 할당을 합니다."

#: src/memory-management/review.md:46
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"힙은 기본적으로 [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html)를 통해 할당됩니다. 그리고 [Allocator API](https://doc."
"rust-lang.org/std/alloc/index.html)를 이용해서 커스텀 메모리 할당자를 만들 수"
"도 있습니다."

#: src/memory-management/review.md:52
#, fuzzy
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"아래와 같은 `unsafe` 코드로 메모리 레이아웃을 살펴볼 수 있습니다. 물론 이 코"
"드가 안전하지 않다는 점을 알려주세요!"

#: src/memory-management/review.md:58 src/testing/unit-tests.md:15
msgid "' '"
msgstr ""

#: src/memory-management/review.md:59
msgid "\"world\""
msgstr ""

#: src/memory-management/review.md:60
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""

#: src/memory-management/review.md:65
msgid "\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\""
msgstr ""

#: src/memory-management/approaches.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "전통적으로, 두 종류의 프로그래밍 언어가 있습니다:"

#: src/memory-management/approaches.md:5
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr ""
"메모리 관리가 프로그래머의 완전한 통제하에 있지만 수동(그래서 안전하지 않을 "
"수 있는)인 언어: C, C++, Pascal, ..."

#: src/memory-management/approaches.md:6
msgid "Programmer decides when to allocate or free heap memory."
msgstr ""

#: src/memory-management/approaches.md:7
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr ""

#: src/memory-management/approaches.md:8
msgid "Studies show, programmers make mistakes."
msgstr ""

#: src/memory-management/approaches.md:9
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"메모리 관리가 런타임에 의해 되므로 안전하지만 자동(그래서 프로그래머가 개입"
"할 여지가 적거나 없는)인 언어: Java, Python, Go, Haskell, ..."

#: src/memory-management/approaches.md:11
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr ""

#: src/memory-management/approaches.md:13
msgid ""
"Typically implemented with reference counting, garbage collection, or RAII."
msgstr ""

#: src/memory-management/approaches.md:15
msgid "Rust offers a new mix:"
msgstr "러스트는 이 둘을 혼합한 새로운 형태의 메모리 관리 기법을 제공합니다:"

#: src/memory-management/approaches.md:17
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"컴파일 시 올바른 메모리 관리를 강제함으로써 완전한 통제와 안전성 _모두_ 제공."

#: src/memory-management/approaches.md:20
msgid "It does this with an explicit ownership concept."
msgstr "이를 가능하게 하는 러스트의 컨셉은 명시적인 소유권입니다."

#: src/memory-management/approaches.md:24
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr ""

#: src/memory-management/approaches.md:27
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""

#: src/memory-management/approaches.md:31
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""

#: src/memory-management/approaches.md:36
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""

#: src/memory-management/approaches.md:41
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""

#: src/memory-management/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"모든 변수 바인딩은 유효한 \"범위(스코프)\"를 가지며, 범위 밖에서 변수 사용하"
"면 에러가 발생합니다:"

#: src/memory-management/ownership.md:20
#, fuzzy
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr "이것을 두고 변수가 값을 \"소유\"한다고 표현합니다."

#: src/memory-management/ownership.md:23
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr ""
"스코프가 종료되면 변수는 \"삭제(drop)\"되었다고 하며 그 변수의 데이터는 메모"
"리에서 해제됩니다."

#: src/memory-management/ownership.md:28
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""

#: src/memory-management/move.md:3
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "(변수의) 할당은 \\_소유권_을 변수 간에 이동시킵니다:"

#: src/memory-management/move.md:7
#, fuzzy
msgid "\"Hello!\""
msgstr "Hello World!"

#: src/memory-management/move.md:9 src/slices-and-lifetimes/str.md:16
#: src/slices-and-lifetimes/str.md:18
msgid "\"s2: {s2}\""
msgstr ""

#: src/memory-management/move.md:10
msgid "// println!(\"s1: {s1}\");\n"
msgstr ""

#: src/memory-management/move.md:14
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "`s1`을 `s2`에 할당하여 소유권을 이전시킵니다."

#: src/memory-management/move.md:15
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"`s1`의 스코프가 종료되면 아무 일도 없습니다: 왜냐하면 `s1`은 아무런 소유권이 "
"없기 때문입니다."

#: src/memory-management/move.md:16
msgid "When `s2` goes out of scope, the string data is freed."
msgstr "`s2`의 스코프가 종료되면 문자열 데이터는 해제됩니다."

#: src/memory-management/move.md:18
msgid "Before move to `s2`:"
msgstr "`s2`로 이동 전 메모리:"

#: src/memory-management/move.md:35
msgid "After move to `s2`:"
msgstr "`s2`로 이동 후 메모리:"

#: src/memory-management/move.md:37
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/move.md:58
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"값을 함수에 전달할때, 그 값은 매개변수에 할당됩니다. 이때 소유권의 이동이 일"
"어납니다:"

#: src/memory-management/move.md:63
msgid "\"Hello {name}\""
msgstr ""

#: src/memory-management/move.md:67 src/android/interoperability/java.md:57
#, fuzzy
msgid "\"Alice\""
msgstr "슬라이스"

#: src/memory-management/move.md:69
msgid "// say_hello(name);\n"
msgstr ""

#: src/memory-management/move.md:75
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"이는 C++과 정반대 임을 설명하세요. C++에서는 복사가 기본이고, `std::move` 를 "
"이용해야만 (그리고 이동 생성자가 정의되어 있어야만!) 소유권 이전이 됩니다."

#: src/memory-management/move.md:78
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"실제로 이동되는 것은 소유권일 뿐입니다. 머신 코드 레벨에서 데이터 복사가 일어"
"날 지 말 지에 대한 것은 컴파일러 내부에서 일어나는 최적화 문제입니다. 이런 복"
"사는 최적화 과정에서 제거가 됩니다."

#: src/memory-management/move.md:82
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"정수와 같은 간단한 값들은 `Copy` (뒤에 설명합니다)로 마킹될 수 있습니다."

#: src/memory-management/move.md:84
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "러스트에서는 복사할때에는 명시적으로 `clone`을 사용합니다."

#: src/memory-management/move.md:86
msgid "In the `say_hello` example:"
msgstr ""

#: src/memory-management/move.md:88
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"`say_hello`함수의 첫번째 호출시 `main`함수는 자신이 가진 `name`에 대한 소유권"
"을 포기하므로, 이후 `main`함수에서는 `name`을 사용할 수 없습니다."

#: src/memory-management/move.md:90
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr "`name`에 할당되있는 힙 메모리는 `say_hello`함수의 끝에서 해제됩니다."

#: src/memory-management/move.md:92
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main`함수에서 `name`을 참조로 전달(빌림)하고(`&name`), `say_hello`에서 매개"
"변수를 참조형으로 수정한다면 `main`함수는 `name`의 소유권을 유지할 수 있습니"
"다."

#: src/memory-management/move.md:94
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"또는 첫번째 호출 시 `main`함수에서 `name`을 복제하여 전달할 수도 있습니다."
"(`name.clone()`)"

#: src/memory-management/move.md:96
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"러스트는 이동을 기본으로 하고 복제를 명시적으로 선언하도록 만듬으로, 의도치 "
"않게 복사본을 만드는 것이 C++에서보다 어렵습니다."

#: src/memory-management/move.md:101
#, fuzzy
msgid "Defensive Copies in Modern C++"
msgstr "Modern C++에서 이중해제 문제"

#: src/memory-management/move.md:103
msgid "Modern C++ solves this differently:"
msgstr "Modern C++은 이 문제를 다르게 해결합니다:"

#: src/memory-management/move.md:106
msgid "\"Cpp\""
msgstr ""

#: src/memory-management/move.md:107
msgid "// Duplicate the data in s1.\n"
msgstr ""

#: src/memory-management/move.md:110
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr "`s1`의 힙 데이터는 복제되고, `s2`는 독립적인 복사본을 얻습니다."

#: src/memory-management/move.md:111
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr "`s1` 와 `s2`의 스코프가 종료되면 각각의 메모리가 해제됩니다."

#: src/memory-management/move.md:113
msgid "Before copy-assignment:"
msgstr "복사 전:"

#: src/memory-management/move.md:129
msgid "After copy-assignment:"
msgstr "복사 후:"

#: src/memory-management/move.md:154
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""

#: src/memory-management/move.md:158
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""

#: src/memory-management/move.md:163
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""

#: src/memory-management/clone.md:1
msgid "Clone"
msgstr ""

#: src/memory-management/clone.md:3
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr ""

#: src/memory-management/clone.md:23
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `Vec::new` or `Box::"
"new`."
msgstr ""

#: src/memory-management/clone.md:26
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""

#: src/memory-management/copy-types.md:7
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr "이동이 기본 설정이지만, 특정 타입은 복사됩니다:"

#: src/memory-management/copy-types.md:20
msgid "These types implement the `Copy` trait."
msgstr "이러한 타입들은 `Copy` 트레잇을 구현합니다."

#: src/memory-management/copy-types.md:22
msgid "You can opt-in your own types to use copy semantics:"
msgstr "직접 만든 타입들도 `Copy`트레잇을 구현하여 복사를 할 수 있습니다:"

#: src/memory-management/copy-types.md:38
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "할당 후, `p1`와 `p2`는 자신의 데이터를 소유합니다."

#: src/memory-management/copy-types.md:39
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "명시적으로 `p1.clone()`를 사용하여 데이터를 복사할 수 있습니다."

#: src/memory-management/copy-types.md:43
msgid "Copying and cloning are not the same thing:"
msgstr "복사(copy)와 복제(clone)는 같지 않습니다:"

#: src/memory-management/copy-types.md:45
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"복사는 메모리의 내용을 그대로 한 벌 더 만드는 것을 의미하며, 아무 객체에서나 "
"다 지원하지는 않습니다."

#: src/memory-management/copy-types.md:47
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"복사는 커스터마이즈 할 수 없습니다. (C++에서 복사 생성자를 통해 복사 동작을 "
"임의로 구현할 수 있는 것과 비교가 됩니다.)"

#: src/memory-management/copy-types.md:48
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"복제는 보다 일반적인 작업이며, `Clone`트레잇을 구현하여 복제시 동작을 커스터"
"마이즈 할 수 있습니다."

#: src/memory-management/copy-types.md:50
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr "`Drop` 트레잇을 구현한 타입은 복사되지 않습니다."

#: src/memory-management/copy-types.md:52
msgid "In the above example, try the following:"
msgstr "위의 예시에서 다음을 시도해 보시기 바랍니다:"

#: src/memory-management/copy-types.md:54
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"`Point`구조체에 `String`필드를 추가하세요. 컴파일 되지 않을 것입니다. 왜냐하"
"면 `String`은 `Copy`트레잇을 구현하고 있지 않기 때문입니다."

#: src/memory-management/copy-types.md:56
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"`derive` 속성에서 `Copy`를 제거해 보세요. `p1`을 `println!` 할 때 컴파일 에러"
"가 발생할 것입니다."

#: src/memory-management/copy-types.md:58
msgid "Show that it works if you clone `p1` instead."
msgstr "`p1`을 복제하면 잘 동작함을 확인해 보세요."

#: src/memory-management/drop.md:1
msgid "The `Drop` Trait"
msgstr "`Drop` 트레잇"

#: src/memory-management/drop.md:3
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html)트레잇을 구현하"
"면, 그 값이 스코프 밖으로 나갈 때 실행될 코드를 작성할 수 있습니다:"

#: src/memory-management/drop.md:13
msgid "\"Dropping {}\""
msgstr ""

#: src/memory-management/drop.md:18
#: src/exercises/concurrency/link-checker.md:93
#: src/exercises/concurrency/solutions-morning.md:125
msgid "\"a\""
msgstr ""

#: src/memory-management/drop.md:20 src/testing/googletest.md:12
msgid "\"b\""
msgstr ""

#: src/memory-management/drop.md:22
msgid "\"c\""
msgstr ""

#: src/memory-management/drop.md:23
msgid "\"d\""
msgstr ""

#: src/memory-management/drop.md:24
msgid "\"Exiting block B\""
msgstr ""

#: src/memory-management/drop.md:26
msgid "\"Exiting block A\""
msgstr ""

#: src/memory-management/drop.md:29
msgid "\"Exiting main\""
msgstr ""

#: src/memory-management/drop.md:35
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr ""

#: src/memory-management/drop.md:36
msgid "Values are automatically dropped when they go out of scope."
msgstr ""

#: src/memory-management/drop.md:37
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""

#: src/memory-management/drop.md:39
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""

#: src/memory-management/drop.md:40
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""

#: src/memory-management/drop.md:44
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""

#: src/memory-management/drop.md:49
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "`Drop::drop`은 왜 `self`를 인자로 받지 않습니까?"

#: src/memory-management/drop.md:50
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"짧은 대답: 만약 그렇게 된다면 `std::mem::drop`이 블록의 끝에서 호출되고, 다"
"시 `Drop::drop`을 호출하게 되어, 스택 오버플로가 발생합니다!"

#: src/memory-management/drop.md:52
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "`drop(a)`를 `a.drop()`로 변경해 보시기 바랍니다."

#: src/memory-management/exercise.md:3
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""

#: src/memory-management/exercise.md:7
msgid "Fill in the missing pieces."
msgstr ""

#: src/memory-management/exercise.md:22 src/memory-management/solution.md:16
msgid "/// A representation of a software package.\n"
msgstr ""

#: src/memory-management/exercise.md:34 src/memory-management/solution.md:28
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""

#: src/memory-management/exercise.md:37
msgid "\"1\""
msgstr ""

#: src/memory-management/exercise.md:40 src/memory-management/solution.md:37
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""

#: src/memory-management/exercise.md:46
msgid "\"2\""
msgstr ""

#: src/memory-management/exercise.md:49 src/memory-management/solution.md:52
msgid "/// Set the package version.\n"
msgstr ""

#: src/memory-management/exercise.md:55 src/memory-management/solution.md:58
msgid "/// Set the package authors.\n"
msgstr ""

#: src/memory-management/exercise.md:57
msgid "\"3\""
msgstr ""

#: src/memory-management/exercise.md:60 src/memory-management/solution.md:64
msgid "/// Add an additional dependency.\n"
msgstr ""

#: src/memory-management/exercise.md:62
msgid "\"4\""
msgstr ""

#: src/memory-management/exercise.md:65 src/memory-management/solution.md:70
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr ""

#: src/memory-management/exercise.md:67
msgid "\"5\""
msgstr ""

#: src/memory-management/exercise.md:76 src/memory-management/solution.md:82
msgid "\"base64\""
msgstr ""

#: src/memory-management/exercise.md:76 src/memory-management/solution.md:82
msgid "\"0.13\""
msgstr ""

#: src/memory-management/exercise.md:77 src/memory-management/solution.md:83
msgid "\"base64: {base64:?}\""
msgstr ""

#: src/memory-management/exercise.md:79 src/memory-management/solution.md:85
msgid "\"log\""
msgstr ""

#: src/memory-management/exercise.md:79 src/memory-management/solution.md:85
msgid "\"0.4\""
msgstr ""

#: src/memory-management/exercise.md:80 src/memory-management/solution.md:86
msgid "\"log: {log:?}\""
msgstr ""

#: src/memory-management/exercise.md:81 src/memory-management/solution.md:87
msgid "\"serde\""
msgstr ""

#: src/memory-management/exercise.md:82 src/memory-management/solution.md:88
msgid "\"djmitche\""
msgstr ""

#: src/memory-management/exercise.md:83 src/memory-management/solution.md:89
msgid "\"4.0\""
msgstr ""

#: src/memory-management/exercise.md:87 src/memory-management/solution.md:93
msgid "\"serde: {serde:?}\""
msgstr ""

#: src/memory-management/solution.md:45
msgid "\"0.1\""
msgstr ""

#: src/smart-pointers/box.md:3
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html)는 힙 데이터에 대"
"한 소유 포인터입니다:"

#: src/smart-pointers/box.md:9
msgid "\"five: {}\""
msgstr ""

#: src/smart-pointers/box.md:26
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>`은 [`Deref<Target = T>`](https://doc.rust-lang.org/std/ops/trait."
"Deref.html#more-on-deref-coercion)를 구현합니다. 이는 [`Box<T>`에서 `T` 메서"
"드를 직접 호출](https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-"
"deref-coercion) 할 수 있다는 의미입니다."

#: src/smart-pointers/box.md:30
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "재귀 데이터나 동적크기의 데이터 타입은 `Box`타입을 사용해야 합니다:"

#: src/smart-pointers/box.md:35
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr ""

#: src/smart-pointers/box.md:37
msgid "/// An empty list.\n"
msgstr ""

#: src/smart-pointers/box.md:44 src/smart-pointers/box.md:97
msgid "\"{list:?}\""
msgstr ""

#: src/smart-pointers/box.md:48
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
"  스택                             힙\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/box.md:63
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"`Box`는 C++의 `std::unique_ptr`과 비슷합니다. 차이라면 `Box`는 널이 아님을 보"
"장한다는 점입니다. "

#: src/smart-pointers/box.md:65
msgid "A `Box` can be useful when you:"
msgstr "`Box`는 아래의 경우에 유용합니다:"

#: src/smart-pointers/box.md:66
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr "타입 크기를 컴파일 시점에 알 수 없는 경우."

#: src/smart-pointers/box.md:68
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"아주 큰 데이터의 소유권을 전달하고 싶은 경우. 스택에 있는 큰 데이터를 복사하"
"는 대신 `Box`를 이용하여 데이터는 힙에 저장하고 포인터만 이동하면 됩니다."

#: src/smart-pointers/box.md:72
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not compute a fixed size of the struct in memory "
"(`List` would be of infinite size)."
msgstr ""
"만일 `Box`를 사용하지 않고 `List`에 직접 `List`를 포함하려고 시도한다면, 컴파"
"일러는 구조체의 고정 크기를 계산할 수 없습니다. 컴파일러가 보기에 무한대의 크"
"기로 보일 것입니다."

#: src/smart-pointers/box.md:76
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box`는 일반 포인터와 크기가 같기 때문에 크기를 계산하는 데 문제가 없습니다. "
"다만 힙에 위치한 `List`의 다음 요소를 가리킬 뿐입니다."

#: src/smart-pointers/box.md:79
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"`List` 정의에서 `Box`를 제거하면 어떤 컴파일러 에러가 나오는지 같이 살펴보세"
"요. “Recursive with indirection”라는 메시지를 보면, 값을 직접 저장하는 대신 "
"`Box`나 비슷한 다른 종류의 참조 타입이 필요하다는 힌트를 얻을 수 있습니다."

#: src/smart-pointers/box.md:85
msgid "Niche Optimization"
msgstr "니치(틈새) 최적화(Niche Optimization)"

#: src/smart-pointers/box.md:101
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box`는 비어있을 수 없습니다. 따라서 포인터는 항상 유효하며 `null`이 아닙니"
"다. 이는 컴파일러가 메모리 레이아웃을 최적화 할 수 있게 해줍니다:"

#: src/smart-pointers/box.md:104
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - -.\n"
":                            :     :                           :\n"
":    list                    :     :                           :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":                            :     :                           :\n"
":                            :     :                           :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/smart-pointers/rc.md:3
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html)는 참조 카운팅 공유 포"
"인터입니다. 여러 위치에서 동일한 데이터를 참조해야할 경우 사용합니다:"

#: src/smart-pointers/rc.md:13
msgid "\"a: {a}\""
msgstr ""

#: src/smart-pointers/rc.md:14
msgid "\"b: {b}\""
msgstr ""

#: src/smart-pointers/rc.md:18
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"멀티스레드 환경에서 작업하는 경우 [`Arc`](../concurrency/shared_state/arc.md)"
"와 [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)를 참조하세"
"요."

#: src/smart-pointers/rc.md:19
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"drop 가능한 순환 구조를 만들기 위해 공유 포인터를 [`Weak`](https://doc.rust-"
"lang.org/std/rc/struct.Weak.html) 포인터로 _다운그레이드_할 수도 있습니다."

#: src/smart-pointers/rc.md:29
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"`Rc`는 참조 카운트를 통해 참조가 있는 동안은 `Rc`가 가리키고 있는 값이 메모리"
"에서 해제되지 않음을 보장합니다."

#: src/smart-pointers/rc.md:31
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "C++의 `std::shared_ptr`와 유사합니다."

#: src/smart-pointers/rc.md:32
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`clone`은 비용이 거의 들지 않습니다. 같은 곳을 가리키는 포인터를 하나 더 만들"
"고, 참조 카운트를 늘립니다. 포인터가 가리키는 값 자체가 복제(깊은 복제)되지"
"는 않으며, 그래서 코드에서 성능 문제가 있는지 검토할 때 일반적으로 `Rc`를 "
"`clone`하는 것은 무시할 수 있습니다."

#: src/smart-pointers/rc.md:35
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut`는 실제로 필요한 경우에 내부 값을 복제하고(\"clone-on-write\") 가"
"변 참조를 반환합니다."

#: src/smart-pointers/rc.md:37
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "참조 카운트를 확인하려면 `Rc::strong_count`를 사용하세요."

#: src/smart-pointers/rc.md:38
#, fuzzy
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc`는 `downgrade()`로 다운그레이드하여 _약하게 참조 카운트되는(weekly "
"reference-counted)_ 객체가 될 있습니다. 그러면 순환구조라 하더라도 drop이 가"
"능합니다. (아마도 `RefCell` 을 함께 사용해야 할 것입니다.)"

#: src/smart-pointers/exercise.md:3
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""

#: src/smart-pointers/exercise.md:8
msgid "Implement the following types, so that the given tests pass."
msgstr ""

#: src/smart-pointers/exercise.md:10
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr ""

#: src/smart-pointers/exercise.md:14 src/smart-pointers/solution.md:5
msgid "/// A node in the binary tree.\n"
msgstr ""

#: src/smart-pointers/exercise.md:21 src/smart-pointers/solution.md:13
msgid "/// A possibly-empty subtree.\n"
msgstr ""

#: src/smart-pointers/exercise.md:25 src/smart-pointers/solution.md:17
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""

#: src/smart-pointers/exercise.md:33
msgid "// Implement `new`, `insert`, `len`, and `has`.\n"
msgstr ""

#: src/smart-pointers/exercise.md:48 src/smart-pointers/solution.md:105
msgid "// not a unique item\n"
msgstr ""

#: src/smart-pointers/solution.md:89 src/testing/googletest.md:11
msgid "\"bar\""
msgstr ""

#: src/borrowing/shared.md:3
#, fuzzy
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr ""
"함수 호출시 값의 소유권을 이동하는 대신의 함수가 값을 _빌려올 수_ 있습니다:"

#: src/borrowing/shared.md:24
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr ""
"`add` 함수는 두 `Point` 객체 값을 \\_빌려_와서 새로운 `Point` 객체를 반환합니"
"다."

#: src/borrowing/shared.md:25
msgid "The caller retains ownership of the inputs."
msgstr "`p1`과 `p2`의 소유권은 여전히 호출자(`main`함수)에 있습니다."

#: src/borrowing/shared.md:29
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""

#: src/borrowing/shared.md:34
msgid "Notes on stack returns:"
msgstr "스택에 할당된 값을 리턴하는 것에 대한 참고:"

#: src/borrowing/shared.md:36
#, fuzzy
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"`add`에서 값을 반환하는 것은 매우 값이 싸다는 것을 설명하세요. 왜냐하면, 컴파"
"일러가 복사 과정을 생략할 수 있기 때문입니다. 위 코드를 스택 주소를 출력하도"
"록 수정하고 [Playground](https://play.rust-lang.org/)에서 수행해 보세요. 또"
"는 [Godbolt](https://rust.godbolt.org/)에서 어셈블리를 확인해 보세요. 최적화 "
"레벨이 \"DEBUG\" 일 때에는 주소가 바뀌지만, \"RELEASE\" 레벨에서는 바뀌지 않"
"습니다:"

#: src/borrowing/shared.md:62
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "러스트 컴파일러는 반환값 최적화(RVO)를 수행할 수 있습니다."

#: src/borrowing/shared.md:63
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"C++에서 copy elision은 생성자의 부수효과 가능성이 있어 언어레벨의 정의가 필요"
"하지만 러스트에서는 문제가 되지 않습니다. 만약 RVO가 발생하지 않으면 러스트"
"는 항상 간단하고 효율적인 `memcpy`복사를 수행할 것입니다."

#: src/borrowing/borrowck.md:3
#, fuzzy
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr "러스트에서는 값을 빌릴 때 다음과 같은 제약조건이 있습니다:"

#: src/borrowing/borrowck.md:6
#, fuzzy
msgid "You can have one or more shared references to the value, _or_"
msgstr "한번에 하나 이상의 `&T` 값을 가지거나, _또는_"

#: src/borrowing/borrowck.md:7
#, fuzzy
msgid "You can have exactly one exclusive reference to the value."
msgstr "정확히 하나의 `&mut T` 값만을 가질 수 있습니다."

#: src/borrowing/borrowck.md:28
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""

#: src/borrowing/borrowck.md:30
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"위 코드 컴파일 되지 않습니다. 왜냐하면 `c`는 `a`를 가변 변수로 빌렸고, 이와 "
"동시에 `b`는 `a`를 불변 변수로 빌렸기 때문입니다."

#: src/borrowing/borrowck.md:32
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"`b`에 대한 `println!` 구분을 `c`가 있는 스코프 앞으로 이동하면 컴파일이 됩니"
"다."

#: src/borrowing/borrowck.md:34
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"이렇게 바꾸면, 컴파일러는 `c`가 `a`를 가변 변수로 빌리기 전에만 `b`가 사용된"
"다는 것을 확인할 수 있습니다. 빌림 검사기의 이러한 기능을 \"non-lexical "
"lifetime\" 이라고 합니다."

#: src/borrowing/borrowck.md:37
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""

#: src/borrowing/borrowck.md:41
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""

#: src/borrowing/interior-mutability.md:7
msgid ""
"Rust provides a few safe means of modifying a value given only a shared "
"reference to that value. All of these replace compile-time checks with "
"runtime checks."
msgstr ""

#: src/borrowing/interior-mutability.md:11
msgid "`Cell` and `RefCell`"
msgstr "`Cell`과 `RefCell`"

#: src/borrowing/interior-mutability.md:13
#, fuzzy
msgid ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) and [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implement what Rust "
"calls _interior mutability:_ mutation of values in an immutable context."
msgstr ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html 과 [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html)은 러스트에서 _내적 "
"가변성(interior mutability)_이라고 부르는 것을 구현합니다. 이를 이용하면 불변"
"인 객체의 값을 수정할 수 있습니다."

#: src/borrowing/interior-mutability.md:18
msgid ""
"`Cell` is typically used for simple types, as it requires copying or moving "
"values. More complex interior types typically use `RefCell`, which tracks "
"shared and exclusive references at runtime and panics if they are misused."
msgstr ""
"`Cell`은 간단한 타입에 대해서 주로 사용됩니다. 왜냐하면 `Cell`에 있는 값을 읽"
"거나 쓸때에는 복사 혹은 이동을 해야만 하기 때문입니다. 복잡한 타입이라면 "
"`RefCell`이 더 보편적입니다. 이를 이용하면 참조를 통해 값을 읽거나 쓰게 해 주"
"는 대신, 그 참조들이 올바른지를 런타임에 체크하고, 제대로 사용되지 않을 경우 "
"패닉을 발생시킵니다."

#: src/borrowing/interior-mutability.md:50
msgid "\"graph: {root:#?}\""
msgstr ""

#: src/borrowing/interior-mutability.md:51
msgid "\"graph sum: {}\""
msgstr ""

#: src/borrowing/interior-mutability.md:57
msgid ""
"If we were using `Cell` instead of `RefCell` in this example, we would have "
"to move the `Node` out of the `Rc` to push children, then move it back in. "
"This is safe because there's always one, un-referenced value in the cell, "
"but it's not ergonomic."
msgstr ""
"이 예제에서 `RefCell`대신 `Cell`을 썼었다면, `Node`에 자식 노느를 추가하기 위"
"해서, `Node`를 `Rc`밖으로 이동시킨 다음, 자식 노드를 추가하고, 다시 `Rc`안으"
"로 이동시켜야 했을 겁니다. 이렇게 해야만 하는 이유는 안전 때문입니다. Cell 내"
"부의 그 값이 오직 하나 존재하며, 그 값에 대한 참조가 없다는 것이 보장되기 때"
"문입니다. 물론 편리하지는 않습니다."

#: src/borrowing/interior-mutability.md:61
msgid ""
"To do anything with a Node, you must call a `RefCell` method, usually "
"`borrow` or `borrow_mut`."
msgstr ""
"노드를 이동하거나 복사하지 않고 그대로 사용하기 위해서는 `RefCell`로 감싼다"
"음 `borrow`나 `borrow_mut`메서드를 이용해야 합니다."

#: src/borrowing/interior-mutability.md:63
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children` (don't try to print it!)."
msgstr ""
"`root`를 `subtree.children`에 추가해서 순환 참조가 생길 수 있음을 보여주세요 "
"(그래프를 출력하지는 마세요!)."

#: src/borrowing/interior-mutability.md:65
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""
"`self.value`를 증가시키는 메서드인`fn inc(&mut self)`를 추가하고 그 메서드를 "
"자식노드에서 호출하세요. 그러면 `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'` 런타임 패닉이 발생함을 보이세요."

#: src/borrowing/exercise.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"당신은 건강 상태를 모니터링하는 시스템을 구현하는 일을 하고 있습니다. 그 일환"
"으로 당신은 사용자의 건강 상태 통계를 추적해야합니다."

#: src/borrowing/exercise.md:6
#, fuzzy
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"당신의 목표는 `User` 구조체의 `impl` 블록의 빈 함수를 구현하는 것입니다."

#: src/borrowing/exercise.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr ""
"아래 코드를 <https://play.rust-lang.org/>에 복사해서 빠진 메서드를 구현하면 "
"됩니다:"

#: src/borrowing/exercise.md:51
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr ""

#: src/borrowing/exercise.md:56 src/borrowing/exercise.md:62
#: src/borrowing/exercise.md:68 src/borrowing/solution.md:58
#: src/borrowing/solution.md:64 src/borrowing/solution.md:70
#: src/android/build-rules/library.md:44 src/android/aidl/client.md:22
msgid "\"Bob\""
msgstr ""

#: src/borrowing/exercise.md:57 src/borrowing/solution.md:59
msgid "\"I'm {} and my age is {}\""
msgstr ""

#: src/slices-and-lifetimes/slices.md:1
msgid "Slices"
msgstr "슬라이스"

#: src/slices-and-lifetimes/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "슬라이스는 큰 컬랙션의 일부(혹은 전체)를 보여주는 뷰(view)입니다:"

#: src/slices-and-lifetimes/slices.md:18
msgid "Slices borrow data from the sliced type."
msgstr "슬라이스는 다른(슬라이스 된) 타입으로부터 데이터를 '빌려'옵니다."

#: src/slices-and-lifetimes/slices.md:19
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr "질문: `s`를 출력하기 전에 `a[3]`을 수정하면 무슨 일이 있어날까요?"

#: src/slices-and-lifetimes/slices.md:23
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"슬라이스는 우선 `a`를 빌린다음, 시작과 끝 인덱스를 브래킷(`[]`)안에 지정해서 "
"만듭니다."

#: src/slices-and-lifetimes/slices.md:26
msgid ""
"If the slice starts at index 0, Rust’s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"슬라이스가 인덱스 0부터 시작한다면 시작 인덱스는 생략 가능합니다. 즉 `&a[0.."
"a.len()]`와 `&a[..a.len()]` 는 동일합니다."

#: src/slices-and-lifetimes/slices.md:30
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"마지막 인덱스도 생략 가능합니다. 그래서 `&a[2..a.len()]` 와 `&a[2..]`는 동일"
"합니다."

#: src/slices-and-lifetimes/slices.md:33
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "따라서 전체 배열에 대한 슬라이스는 `&a[..]`가 됩니다."

#: src/slices-and-lifetimes/slices.md:35
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s`는 `i32`들로 이루어진 슬라이스에 대한 참조입니다. `s`의 타입(`&[i32]`)에 "
"배열의 크기가 빠져있음에 주목하시기 바랍니다. 즉, 슬라이스를 이용하면 다양한 "
"길이의 데이터를 다룰 수 있습니다."

#: src/slices-and-lifetimes/slices.md:39
#, fuzzy
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"슬라이스는 항상 다른 객체로부터 '빌려' 옵니다. 이 예시에서 객체 `a`는 슬라이"
"스 `s`보다 더 오래 살아 있어야만 합니다. "

#: src/slices-and-lifetimes/slices.md:42
#, fuzzy
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"`a[3]`의 값을 바꿀 수 있냐는 질문은 좋은 질문입니다. 여기에 대한 답은 `a`와 "
"`s`를 통해 데이터를 읽을 수는 있지만 수정할 수는 없으며, 이는 메모리 안전을 "
"위해서라는 것입니다. 그런데, 슬라이스가 사용되지 않을 때, 즉 슬라이스를 만들"
"기 전이나, 혹은 `println`이후에는 `a[3]`을 바꿀 수 있습니다. 왜 그런지에 대"
"한 좀더 구체적인 답은 빌림 검사 부분에서 자세히 설명합니다."

#: src/slices-and-lifetimes/str.md:7
msgid ""
"We can now understand the two string types in Rust: `&str` is almost like "
"`&[char]`, but with its data stored in a variable-length encoding (UTF-8)."
msgstr ""

#: src/slices-and-lifetimes/str.md:13
msgid "\"s1: {s1}\""
msgstr ""

#: src/slices-and-lifetimes/str.md:15
#, fuzzy
msgid "\"Hello \""
msgstr "Hello World!"

#: src/slices-and-lifetimes/str.md:21
msgid "\"s3: {s3}\""
msgstr ""

#: src/slices-and-lifetimes/str.md:25
msgid "Rust terminology:"
msgstr "러스트 용어:"

#: src/slices-and-lifetimes/str.md:27
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str`은 문자열 슬라이스에 대한 (불변) 참조입니다."

#: src/slices-and-lifetimes/str.md:28
msgid "`String` a mutable string buffer."
msgstr "`String`은 문자열을 담을 수 있는 버퍼입니다."

#: src/slices-and-lifetimes/str.md:32
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`”Hello”`), are stored in the program’s binary."
msgstr ""
"`&str`은 문자열 슬라이스입니다. 문자열 슬라이스는 UTF-8로 인코딩된 문자열 데"
"이터를 의미합니다. 문자열 리터럴(`\"Hello\"`)은 프로그램 바이너리에 저장됩니"
"다."

#: src/slices-and-lifetimes/str.md:36
msgid ""
"Rust’s `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"러스트의 `String`타입은 실제로는 문자열을 이루는 바이트에 대한 백터"
"(`Vec<u8>`)입니다. `Vec<T>`가 `T`를 소유하고 있듯이, `String`이 가리키고 있"
"는 문자열은 `String`의 소유입니다."

#: src/slices-and-lifetimes/str.md:39
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"다른 많은 타입들처럼 `String::from`는 문자열 리터럴로부터 문자열을 생성합니"
"다. `String::new()`는 새로운 빈 문자열을 생성합니다. `push()`와 `push_str()`"
"메서드를 사용하여 문자열 데이터를 추가 할 수 있습니다."

#: src/slices-and-lifetimes/str.md:43
#, fuzzy
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"`format!()` 매크로는 변수의 값을 문자열로 변환하는 편리한 방법입니다. 이 매크"
"로는 `println!()` 매크로와 동일한 포맷팅 형식을 지원합니다."

#: src/slices-and-lifetimes/str.md:46
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""

#: src/slices-and-lifetimes/str.md:51
#, fuzzy
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"당신이 C++ 프로그래머 라면: `&str`는 C++의 `const char*`와 유사하지만 항상 유"
"효한 문자열을 가리킨다는 점이 다릅니다. 러스트의 `String`은 C++의 `std::"
"string` 과 대략 거의 동일합니다. (주요 차이점: 러스트의 `String`은 UTF-8 인코"
"딩 바이트만 포함할 수 있으며 작은 문자열 최적화(small-string optimization)는 "
"구현하지 않습니다."

#: src/slices-and-lifetimes/str.md:56
#, fuzzy
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr "Byte strings allow you to create a `&[u8]` value directly:"

#: src/slices-and-lifetimes/lifetime-annotations.md:3
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:6
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:11
#, fuzzy
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr ""
"수명 표기(`'`)은 수명 추론시 제약조건이 됩니다. 컴파일러는 이 제약조건을 만족"
"시키는 유요한 수명을 추론할 수 있는지 검사를 합니다."

#: src/slices-and-lifetimes/lifetime-annotations.md:15
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:36
msgid "// What is the lifetime of p3?\n"
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:37
msgid "\"p3: {p3:?}\""
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:43
msgid ""
"In this example, the the compiler does not know what lifetime to infer for "
"`p3`. Looking inside the function body shows that it can only safely assume "
"that `p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, "
"Rust requires explicit annotations of lifetimes on function arguments and "
"return values."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:49
msgid "Add `'a` appropriately to `left_most`:"
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:55
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:58
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:1
msgid "Lifetimes in Function Calls"
msgstr "함수 호출에서의 수명"

#: src/slices-and-lifetimes/lifetime-elision.md:3
#, fuzzy
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"원래, 함수의 인자와 리턴값에는 수명을 설정해야 합니다. 그러나 [몇 가지 조건]"
"(https://doc.rust-lang.org/nomicon/lifetime-elision.html)을 만족하는 대부분"
"의 경우에는 생략할 수 있습니다."

#: src/slices-and-lifetimes/lifetime-elision.md:8
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:9
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:11
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:52
msgid "In this example, `cab_distance` is trivially elided."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:54
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:57
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:63
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:67
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:1
msgid "Lifetimes in Data Structures"
msgstr "구조체에서의 수명"

#: src/slices-and-lifetimes/struct-lifetimes.md:3
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"어떤 타입이 빌려온 데이터를 저장하고 있다면, 반드시 수명을 표시해야 합니다:"

#: src/slices-and-lifetimes/struct-lifetimes.md:10
msgid "\"Bye {text}!\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:14
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:17
msgid "// erase(text);\n"
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:18
msgid "\"{fox:?}\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:19
msgid "\"{dog:?}\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:25
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"위의 예제에서 `Highlight`의 어노테이션(`<'doc>`)은 적어도 `Highlight` 인스턴"
"스가 살아있는 동안에는 그 내부의 `&str`가 가리키는 데이터 역시 살아있어야 한"
"다는 것을 의미합니다."

#: src/slices-and-lifetimes/struct-lifetimes.md:28
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"만약 `text`가 `fox` (혹은 `dog`)의 수명이 다하기 전에 `erase`함수 호출 등으"
"로 사라지게 된다면 빌림 검사기가 에러를 발생합니다."

#: src/slices-and-lifetimes/struct-lifetimes.md:30
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"빌린 데이터를 가지고 있는 타입은 사용자로 하여금 원본 데이터를 유지하도록 강"
"제합니다. 이런 타입은 경량 뷰(lightweight view)를 만드는데 유용하지만, 이 제"
"약 조건 때문에 이런 타입을 사용하는 것이 쉽지만은 않습니다."

#: src/slices-and-lifetimes/struct-lifetimes.md:33
msgid "When possible, make data structures own their data directly."
msgstr ""
"따라서, 가능하다면, 구조체가 자신의 데이터를 직접 소유하도록 하는 것이 좋습니"
"다."

#: src/slices-and-lifetimes/struct-lifetimes.md:34
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"한 구조체안에 여러 참조가 있으면서, 이 참조들의 수명이 서로 다르게 지정되는 "
"경우도 있습니다. 이는 참조와 그 구조체 간의 관계 뿐만이 아니라, 그 참조들 사"
"이의 수명 관계를 설명해야 할 경우에 필요합니다. 매우 고급 기술입니다."

#: src/slices-and-lifetimes/exercise.md:3
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:8
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:13
msgid "We'll use the following proto:"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:28
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:33
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:38
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:49
#: src/slices-and-lifetimes/solution.md:11
msgid "\"Invalid varint\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:51
#: src/slices-and-lifetimes/solution.md:13
msgid "\"Invalid wire-type\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:53
#: src/slices-and-lifetimes/solution.md:15
msgid "\"Unexpected EOF\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:55
#: src/slices-and-lifetimes/solution.md:17
msgid "\"Invalid length\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:57
#: src/slices-and-lifetimes/solution.md:19
msgid "\"Unexpected wire-type)\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:59
#: src/slices-and-lifetimes/solution.md:21
msgid "\"Invalid string (not UTF-8)\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:62
#: src/slices-and-lifetimes/solution.md:24
msgid "/// A wire type as seen on the wire.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:65
#: src/slices-and-lifetimes/solution.md:27
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:67
#: src/slices-and-lifetimes/solution.md:29
msgid ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:71
#: src/slices-and-lifetimes/solution.md:33
msgid ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    /// little-endian order containing a 32-bit signed integer.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:76
#: src/slices-and-lifetimes/solution.md:38
msgid "/// A field's value, typed based on the wire type.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:80
#: src/slices-and-lifetimes/solution.md:42
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:85
#: src/slices-and-lifetimes/solution.md:47
msgid "/// A field, containing the field number and its value.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:102
#: src/slices-and-lifetimes/solution.md:64
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:132
#: src/slices-and-lifetimes/solution.md:94
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:140
#: src/slices-and-lifetimes/solution.md:102
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:150
#: src/slices-and-lifetimes/solution.md:112
msgid "// More than 7 bytes is invalid.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:153
#: src/slices-and-lifetimes/solution.md:115
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:161
#: src/slices-and-lifetimes/solution.md:122
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:167
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:169
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:171
#: src/slices-and-lifetimes/solution.md:153
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:198
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md:146
msgid "// Unwrap error because `value` is definitely 4 bytes long.\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md:187
#: src/slices-and-lifetimes/solution.md:198
msgid "// skip everything else\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md:225
#: src/slices-and-lifetimes/solution.md:232
#: src/slices-and-lifetimes/solution.md:239
msgid "b\"hello\""
msgstr ""

#: src/welcome-day-4.md:1
#, fuzzy
msgid "Welcome to Day 4"
msgstr "1일차 개요"

#: src/welcome-day-4.md:3
#, fuzzy
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr "오늘은 몇 가지 고급 주제를 다룹니다:"

#: src/welcome-day-4.md:5
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr ""

#: src/welcome-day-4.md:6
msgid "Modules and visibility."
msgstr ""

#: src/welcome-day-4.md:7
#, fuzzy
msgid "Testing."
msgstr "테스트"

#: src/welcome-day-4.md:8
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "오류처리(에러 핸들링): 패닉, `Result`, `?` 연산자."

#: src/welcome-day-4.md:9
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr ""

#: src/iterators/iterator.md:7
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""

#: src/iterators/iterator.md:31
msgid "\"fib({i}): {n}\""
msgstr ""

#: src/iterators/iterator.md:38
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"`Iterator` 트레잇은 컬렉션에 대한 여러 일반적인 함수 프로그래밍 작업(예: "
"`map`, `filter`, `reduce` 등)을 구현합니다. 이는 관련 문서를 모두 찾을 수 있"
"는 트레잇입니다. Rust에서는 이러한 함수가, 이와 동일한 일을 하는 명령형 구현"
"만큼 효율적인 코드를 생성합니다."

#: src/iterators/iterator.md:43
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator`는 루프를 작동하게 만드는 트레잇입니다. 이는 `Vec<T>`와 같은 컬"
"렉션 유형과 `&Vec<T>` 및 `&[T]`와 같은 이에 대한 참조에 의해 구현됩니다. 범위"
"도 이를 구현합니다. 이런 이유로 `for i in some_vec { .. }`를 사용하여 벡터를 "
"반복할 수 있지만 `some_vec.next()`는 존재하지 않습니다."

#: src/iterators/intoiterator.md:3
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"`Iterator` 트레잇은 생성된 반복자를 _사용_하는 방법을 알려줍니다. 반면 "
"`IntoIterator` 트레잇은 반복자를 _생성_하는 방법을 알려줍니다:"

#: src/iterators/intoiterator.md:49
msgid "\"point = {x}, {y}\""
msgstr ""

#: src/iterators/intoiterator.md:56
#, fuzzy
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr "`IntoIterator`의 모든 구현은 반드시 다음의 두 타입을 선언해야합니다:"

#: src/iterators/intoiterator.md:59
#, fuzzy
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "`Item`: `i8`과 같이 반복되는 값의 타입,"

#: src/iterators/intoiterator.md:60
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: `into_iter` 메서드에서 반환되는 `Iterator`타입."

#: src/iterators/intoiterator.md:62
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"`IntoIter`에는 `Item`이 연결되어 있음을 주목하세요. `IntoIter` 반복자는 "
"`Item` 타입의 데이터를 가리켜야 합니다. 즉, 반복자는 `Option<Item>`을 리턴합"
"니다"

#: src/iterators/intoiterator.md:65
msgid "The example iterates over all combinations of x and y coordinates."
msgstr ""

#: src/iterators/intoiterator.md:67
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""

#: src/iterators/intoiterator.md:70
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""

#: src/iterators/intoiterator.md:73
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""

#: src/iterators/fromiterator.md:1
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/fromiterator.md:3
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"어떤 컬렉션이 [`FromIterator`](https://doc.rust-lang.org/std/iter/trait."
"FromIterator.html)를 구현하고 있다면 [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)로부터 그 컬렉션을 만들 수 있습니다."

#: src/iterators/fromiterator.md:9
msgid "\"prime_squares: {prime_squares:?}\""
msgstr ""

#: src/iterators/fromiterator.md:15
#, fuzzy
msgid "`Iterator` implements"
msgstr "`Iterator`"

#: src/iterators/fromiterator.md:24
msgid "There are two ways to specify `B` for this method:"
msgstr ""

#: src/iterators/fromiterator.md:26
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""

#: src/iterators/fromiterator.md:28
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""

#: src/iterators/fromiterator.md:31
#, fuzzy
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"`Iterator<Item = Result<V, E>>`을 `Result<Vec<V>, E>`로 변환할 수 있는 멋진 "
"기능들도 구현되어 있습니다."

#: src/iterators/exercise.md:3
#, fuzzy
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr "`Iterator`트레잇을 여러분이 정의한 타입에서 구현해 보겠습니다:"

#: src/iterators/exercise.md:6
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"아래 코드를 <https://play.rust-lang.org/>에 복사하고 테스트를 통과해 보시기 "
"바랍니다. 중간 결과값을 `Vec`에 할당하지 않도록 주의 하시기 바랍니다:"

#: src/iterators/exercise.md:11 src/iterators/solution.md:4
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""

#: src/modules/modules.md:3
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr "`impl`블록은 해당 타입의 함수들에 대한 네임스페이스를 제공합니다."

#: src/modules/modules.md:5
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "마찬가지로, `mod`는 타입과 함수들에 대해 네임스페이스를 제공합니다:"

#: src/modules/modules.md:10
msgid "\"In the foo module\""
msgstr ""

#: src/modules/modules.md:16
msgid "\"In the bar module\""
msgstr ""

#: src/modules/modules.md:28
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"패키지는 기능을 제공하며 하나의 대표 `Cargo.toml` 파일을 포함합니다. 패키지"
"를 구성하는 크레이트들을 빌드하는 방법이 이 파일에 기술됩니다."

#: src/modules/modules.md:30
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"크레이트는 모듈의 트리입니다. 바이너리 크레이트는 실행파일로 빌드되고, 라이브"
"러리 크레이트는 라이브러리로 빌드됩니다."

#: src/modules/modules.md:32
msgid "Modules define organization, scope, and are the focus of this section."
msgstr "모듈은 코드를 조직화하고 스코프를 정의하는 단위입니다."

#: src/modules/filesystem.md:3
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"모듈의 내용을 기술하지 않으면, 러스트는 다른 파일에서 그 내용을 읽습니다:"

#: src/modules/filesystem.md:9
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"위 코드는 러스트로 하여금 `garden`모듈의 내용을 `src/garden.rs`에서 찾도록 합"
"니다. 비슷하게, `garden::vegetables` 모듈은 `src/garden/vegetables.rs`에서 찾"
"습니다."

#: src/modules/filesystem.md:13
msgid "The `crate` root is in:"
msgstr "`crate(크레이트)`의 루트는 아래 경로 입니다:"

#: src/modules/filesystem.md:15
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (라이브러리 크레이트)"

#: src/modules/filesystem.md:16
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (바이너리 크레이트)"

#: src/modules/filesystem.md:18
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"모듈도 \"내부 문서 주석\"을 사용하여 문서화할 수 있습니다. 이러한 모듈은 모듈"
"이 포함된 항목(이 경우에는 모듈)을 문서화합니다."

#: src/modules/filesystem.md:22
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr ""

#: src/modules/filesystem.md:24
msgid "// Re-export types from this module.\n"
msgstr ""

#: src/modules/filesystem.md:28
msgid "/// Sow the given seed packets.\n"
msgstr ""

#: src/modules/filesystem.md:33
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr ""

#: src/modules/filesystem.md:42
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"`module/mod.rs`를 `module.rs`로 바꾼다 하더라도 Rust 2018에서는 하위 모듈을 "
"사용할 수 있습니다."

#: src/modules/filesystem.md:45
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"`filename.rs`를 `filename/mod.rs`대신 사용할 수 있도록 하는 주된 이유는, "
"`mod.rs`라는 이름을 가진 파일이 많을 경우 IDE에서 이들을 서로 구별하는게 힘들"
"기 때문입니다."

#: src/modules/filesystem.md:48
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"폴더를 이용해서 더 깊은 계층 구조를 구현할 수 있습니다. 심지어는 메인 모듈이 "
"파일이더라도요:"

#: src/modules/filesystem.md:58
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr "러스트가 어디서 모듈들을 찾을지는 컴파일러 디렉티브로 변경 가능합니다:"

#: src/modules/filesystem.md:61
msgid "\"some/path.rs\""
msgstr ""

#: src/modules/filesystem.md:65
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"이는 Go언어 에서처럼 어떤 모듈의 테스트를 `some_module_test.rs` 같은 파일에 "
"두고 싶은 경우에 유용합니다."

#: src/modules/visibility.md:3
msgid "Modules are a privacy boundary:"
msgstr "모듈의 타입이나 함수는 기본적으로 바깥에 노출되지 않습니다:"

#: src/modules/visibility.md:5
msgid "Module items are private by default (hides implementation details)."
msgstr "따라서 모듈의 세부 구현 내용이 감춰집니다."

#: src/modules/visibility.md:6
msgid "Parent and sibling items are always visible."
msgstr "부모와 이웃 항목은 언제나 접근 가능합니다."

#: src/modules/visibility.md:7
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"즉, 모듈 `foo`에서 접근 가능한 항목이라면 `foo` 아래의 모든 모듈에서 접근가능"
"합니다."

#: src/modules/visibility.md:13
msgid "\"outer::private\""
msgstr ""

#: src/modules/visibility.md:17
msgid "\"outer::public\""
msgstr ""

#: src/modules/visibility.md:22
msgid "\"outer::inner::private\""
msgstr ""

#: src/modules/visibility.md:26
msgid "\"outer::inner::public\""
msgstr ""

#: src/modules/visibility.md:39
msgid "Use the `pub` keyword to make modules public."
msgstr "`pub` 키워드는 모듈에도 사용할 수 있습니다."

#: src/modules/visibility.md:41
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"또한, 고급 기능으로 `pub(...)` 지정자를 사용하여 공개 범위를 제한할 수 있습니"
"다."

#: src/modules/visibility.md:44
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"[공식 문서](https://doc.rust-lang.org/reference/visibility-and-privacy."
"html#pubin-path-pubcrate-pubsuper-and-pubself)를 참고하세요."

#: src/modules/visibility.md:46
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "`pub(crate)`로 가시성을 지정하는 것이 자주 쓰입니다."

#: src/modules/visibility.md:47
msgid "Less commonly, you can give visibility to a specific path."
msgstr "자주 쓰이진 않지만 특정 경로에 대해서만 가시성을 부여할 수 있습니다."

#: src/modules/visibility.md:48
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"어떤 경우이든 가시성이 부여되면 해당 모듈을 포함하여 하위의 모든 모듈이 적용"
"받습니다."

#: src/modules/paths.md:1
msgid "use, super, self"
msgstr ""

#: src/modules/paths.md:3
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"모듈은 `use`를 사용하여 다른 모듈의 심볼을 내 스코프로 가져올 수 있습니다. 일"
"반적으로 각 모듈의 상단에 다음과 같은 내용이 옵니다:"

#: src/modules/paths.md:11
msgid "Paths"
msgstr "경로"

#: src/modules/paths.md:13
msgid "Paths are resolved as follows:"
msgstr "경로는 아래와 같이 구분합니다:"

#: src/modules/paths.md:15
msgid "As a relative path:"
msgstr "상대 경로:"

#: src/modules/paths.md:16
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` 또는 `self::foo`는 현재 모듈 내부의 `foo`를 가리킵니다,"

#: src/modules/paths.md:17
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo`는 부모 모듈의 `foo`를 가리킵니다."

#: src/modules/paths.md:19
msgid "As an absolute path:"
msgstr "절대 경로:"

#: src/modules/paths.md:20
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo`는 현재 크레이트 루트의 `foo`를 가리킵니다,"

#: src/modules/paths.md:21
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo`는 `bar`크레이트의 `foo`를 가리킵니다."

#: src/modules/paths.md:25
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""

#: src/modules/paths.md:35
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""

#: src/modules/paths.md:38
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""

#: src/modules/paths.md:44
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""

#: src/modules/exercise.md:3
msgid ""
"In this exercise, you will reorganize the GUI Library exercise from the "
"\"Methods and Traits\" segment of the course into a collection of modules. "
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""

#: src/modules/exercise.md:8
msgid ""
"If you no longer have your version, that's fine - refer back to the "
"[provided solution](../methods-and-traits/solution.html)."
msgstr ""

#: src/modules/exercise.md:11
#, fuzzy
msgid "Cargo Setup"
msgstr "설치"

#: src/modules/exercise.md:13
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""

#: src/modules/exercise.md:22
msgid ""
"Edit `src/main.rs` to add `mod` statements, and add additional files in the "
"`src` directory."
msgstr ""

#: src/modules/exercise.md:27
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""

#: src/modules/solution.md:30
msgid "// ---- src/widgets.rs ----\n"
msgstr ""

#: src/modules/solution.md:56
msgid "// ---- src/widgets/label.rs ----\n"
msgstr ""

#: src/modules/solution.md:71
msgid "// ANCHOR_END: Label-width\n"
msgstr ""

#: src/modules/solution.md:75
msgid "// ANCHOR: Label-draw_into\n"
msgstr ""

#: src/modules/solution.md:77
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr ""

#: src/modules/solution.md:84
msgid "// ---- src/widgets/button.rs ----\n"
msgstr ""

#: src/modules/solution.md:99
msgid "// ANCHOR_END: Button-width\n"
msgstr ""

#: src/modules/solution.md:103
msgid "// ANCHOR: Button-draw_into\n"
msgstr ""

#: src/modules/solution.md:105
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr ""

#: src/modules/solution.md:120
msgid "// ---- src/widgets/window.rs ----\n"
msgstr ""

#: src/modules/solution.md:147
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""

#: src/modules/solution.md:152
msgid "// ANCHOR: Window-draw_into\n"
msgstr ""

#: src/modules/solution.md:154
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr ""

#: src/modules/solution.md:177
msgid "// ---- src/main.rs ----\n"
msgstr ""

#: src/testing/unit-tests.md:1
msgid "Unit Tests"
msgstr "단위 테스트"

#: src/testing/unit-tests.md:3
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr ""
"러스트와 카고(cargo)는 간단한 단위 테스트 프레임워크와 함께 제공됩니다:"

#: src/testing/unit-tests.md:5
msgid "Unit tests are supported throughout your code."
msgstr "단위 테스트는 코드 전반에서 지원됩니다."

#: src/testing/unit-tests.md:7
msgid "Integration tests are supported via the `tests/` directory."
msgstr "통합 테스트는 `tests/` 디렉터리를 통해 지원됩니다."

#: src/testing/unit-tests.md:9
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""

#: src/testing/unit-tests.md:37
#, fuzzy
msgid "\"Hello World\""
msgstr "Hello World!"

#: src/testing/unit-tests.md:42
msgid "This lets you unit test private helpers."
msgstr ""
"이렇게 서브 모듈로 테스트를 만들면 private한 헬퍼 함수에 대한 단위 테스트도 "
"가능합니다."

#: src/testing/unit-tests.md:43
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"`#[cfg(test)]` 어트리뷰트가 추가된 항목은 `cargo test`를 수행했을 경우에만 동"
"작합니다."

#: src/testing/unit-tests.md:47
msgid "Run the tests in the playground in order to show their results."
msgstr ""

#: src/testing/other.md:3
msgid "Integration Tests"
msgstr "통합 테스트"

#: src/testing/other.md:5
msgid "If you want to test your library as a client, use an integration test."
msgstr "라이브러리를 사용자 입장에서 테스트 하려면, 통합 테스트를 해야 합니다."

#: src/testing/other.md:7
msgid "Create a `.rs` file under `tests/`:"
msgstr "`test/`디렉터리 아래에 `.rs`파일을 하나 만드세요:"

#: src/testing/other.md:10
msgid "// tests/my_library.rs\n"
msgstr ""

#: src/testing/other.md:19
msgid "These tests only have access to the public API of your crate."
msgstr "이 테스트는 크레이트의 공개 API에만 접근할 수 있습니다."

#: src/testing/other.md:21
msgid "Documentation Tests"
msgstr "문서화주석 테스트"

#: src/testing/other.md:23
msgid "Rust has built-in support for documentation tests:"
msgstr "러스트는 문서화주석에 대한 테스트를 내장하여 제공합니다:"

#: src/testing/other.md:26
#, fuzzy
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"

#: src/testing/other.md:38
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr "`///` 주석안의 코드 블록은 자동으로 러스트 코드로 인식됩니다."

#: src/testing/other.md:39
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "이 코드 블록은 `cargo test` 호출하면 자동으로 컴파일되고 실행됩니다."

#: src/testing/other.md:40
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr ""

#: src/testing/other.md:42
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"위 코드를 [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)"
"에서 테스트 해 보시기 바랍니다."

#: src/testing/useful-crates.md:3
msgid "Rust comes with only basic support for writing tests."
msgstr "러스트는 테스트 작성과 관련해서는 기본적인 기능만 지원합니다."

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr "다음은 테스트를 작성할 때 권장되는 추가 크레이트입니다:"

#: src/testing/useful-crates.md:7
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""
"[googletest](https://docs.rs/googletest): C++용 GoogleTest의 방식을 따르는 테"
"스트 라이브러리 입니다."

#: src/testing/useful-crates.md:9
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr "[proptest](https://docs.rs/proptest): Rust용 속성 기반 테스트입니다."

#: src/testing/useful-crates.md:10
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""
"[rstest](https://docs.rs/rstest): 픽스처 및 매개변수화된 테스트를 지원합니다."

#: src/testing/googletest.md:3
#, fuzzy
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"[googletest](https://docs.rs/googletest): C++용 GoogleTest의 방식을 따르는 테"
"스트 라이브러리 입니다."

#: src/testing/googletest.md:11
msgid "\"baz\""
msgstr ""

#: src/testing/googletest.md:12
msgid "\"xyz\""
msgstr ""

#: src/testing/googletest.md:16
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""

#: src/testing/googletest.md:36
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""

#: src/testing/googletest.md:40
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""

#: src/testing/googletest.md:43
msgid "This just scratches the surface, there are many builtin matchers."
msgstr ""

#: src/testing/googletest.md:45
msgid ""
"A particularly nice feature is that mismatches in multi-line strings strings "
"are shown as a diff:"
msgstr ""

#: src/testing/googletest.md:51
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""

#: src/testing/googletest.md:56
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""

#: src/testing/googletest.md:63
msgid "shows a color-coded diff (colors not shown here):"
msgstr ""

#: src/testing/googletest.md:80
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""

#: src/testing/googletest.md:85
msgid "GoogleTest is available for use in AOSP."
msgstr ""

#: src/testing/mocking.md:3
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""

#: src/testing/mocking.md:26
msgid ""
"The advice here is for Android (AOSP) where Mockall is the recommended "
"mocking library. There are other [mocking libraries available on crates.io]"
"(https://crates.io/keywords/mock), in particular in the area of mocking HTTP "
"services. The other mocking libraries work in a similar fashion as Mockall, "
"meaning that they make it easy to get a mock implementation of a given trait."
msgstr ""

#: src/testing/mocking.md:33
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""

#: src/testing/mocking.md:38
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""

#: src/testing/mocking.md:43
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""

#: src/testing/mocking.md:47
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""

#: src/testing/mocking.md:51
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""

#: src/testing/mocking.md:69
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""

#: src/testing/lints.md:3
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""

#: src/testing/lints.md:14
msgid "\"X probably fits in a u16, right? {}\""
msgstr ""

#: src/testing/lints.md:20
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""

#: src/testing/lints.md:24
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""

#: src/testing/lints.md:28
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""

#: src/testing/exercise.md:3
msgid "Luhn Algorithm"
msgstr "룬 알고리즘"

#: src/testing/exercise.md:5
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[룬(Luhn) 알고리즘](https://ko.wikipedia.org/wiki/"
"%EB%A3%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)은 신용카드 번호 검증에 사용되"
"는 알고리즘 입니다. 이 알고리즘은 신용카드 번호를 `문자열`로 입력받고, 아래"
"의 순서에 따라 신용카드 번호의 유효성을 확인합니다:"

#: src/testing/exercise.md:9
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr "모든 공백을 무시합니다. 2자리 미만 숫자는 무시합니다."

#: src/testing/exercise.md:11
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"**오른쪽에서 왼쪽으로** 이동하며 2번째 자리마다 숫자를 2배 증가시킵니다. 예"
"를 들어 `1234`에서 `3`과 `1`에 각각 2를 곱합니다."

#: src/testing/exercise.md:14
#, fuzzy
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"두배로 만든 숫자가 2자리라면 각 자리 숫자를 더합니다. 예를 들어, `7`은 두배"
"로 만들면 `14`이므로 `5`가 됩니다."

#: src/testing/exercise.md:17
msgid "Sum all the undoubled and doubled digits."
msgstr "모든 자리의 숫자를 더합니다."

#: src/testing/exercise.md:19
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "합계의 끝자리가 `0`인 경우 유효한 신용카드 번호입니다."

#: src/testing/exercise.md:21
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most the algorithm is "
"implemented correctly."
msgstr ""

#: src/testing/exercise.md:25
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"아래 코드를 <https://play.rust-lang.org/>에 복사하고 빠진 함수와 메서드를 채"
"워봅니다:"

#: src/testing/exercise.md:57 src/testing/solution.md:69
msgid "\"4263 9826 4026 9299\""
msgstr ""

#: src/testing/exercise.md:58 src/testing/solution.md:70
msgid "\"4539 3195 0343 6467\""
msgstr ""

#: src/testing/exercise.md:59 src/testing/solution.md:71
msgid "\"7992 7398 713\""
msgstr ""

#: src/testing/exercise.md:64 src/testing/solution.md:76
msgid "\"4223 9826 4026 9299\""
msgstr ""

#: src/testing/exercise.md:65 src/testing/solution.md:77
msgid "\"4539 3195 0343 6476\""
msgstr ""

#: src/testing/exercise.md:66 src/testing/solution.md:78
msgid "\"8273 1232 7352 0569\""
msgstr ""

#: src/testing/solution.md:4
msgid "// This is the buggy version that appears in the problem.\n"
msgstr ""

#: src/testing/solution.md:27
msgid "// This is the solution and passes all of the tests below.\n"
msgstr ""

#: src/testing/solution.md:56
msgid "\"1234 5678 1234 5670\""
msgstr ""

#: src/testing/solution.md:58
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr ""

#: src/testing/solution.md:59
msgid "\"yes\""
msgstr ""

#: src/testing/solution.md:59
msgid "\"no\""
msgstr ""

#: src/testing/solution.md:84
msgid "\"foo 0 0\""
msgstr ""

#: src/testing/solution.md:90
msgid "\" \""
msgstr ""

#: src/testing/solution.md:91
msgid "\"  \""
msgstr ""

#: src/testing/solution.md:92
msgid "\"    \""
msgstr ""

#: src/testing/solution.md:97
msgid "\"0\""
msgstr ""

#: src/testing/solution.md:102
msgid "\" 0 0 \""
msgstr ""

#: src/error-handling/panics.md:3
msgid "Rust handles fatal errors with a \"panic\"."
msgstr ""

#: src/error-handling/panics.md:5
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "러스트는 수행 중 치명적인 오류를 만나면 패닉을 발생할 것입니다:"

#: src/error-handling/panics.md:10
msgid "\"v[100]: {}\""
msgstr ""

#: src/error-handling/panics.md:14
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "패닉은 복구할 수 없고 예상치 못한 오류입니다."

#: src/error-handling/panics.md:15
msgid "Panics are symptoms of bugs in the program."
msgstr "패닉은 프로그램에 버그가 있다는 것을 나타냅니다."

#: src/error-handling/panics.md:16
msgid "Runtime failures like failed bounds checks can panic"
msgstr ""

#: src/error-handling/panics.md:17
msgid "Assertions (such as `assert!`) panic on failure"
msgstr ""

#: src/error-handling/panics.md:18
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr ""

#: src/error-handling/panics.md:19
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr ""

#: src/error-handling/panics.md:21
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"충돌(크래시)을 허용하지 않아야 하는 경우, 패닉을 유발하지 않는 API(`Vec::get`"
"등)를 사용하면 됩니다."

#: src/error-handling/panics.md:25
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"기본적으로, 패닉이 발생하면 스택 되감기를 합니다. 스택 되감기는 다음과 같이 "
"캐치가 가능합니다:"

#: src/error-handling/panics.md:31
msgid "\"No problem here!\""
msgstr ""

#: src/error-handling/panics.md:32 src/error-handling/panics.md:37
msgid "\"{result:?}\""
msgstr ""

#: src/error-handling/panics.md:35
msgid "\"oh no!\""
msgstr ""

#: src/error-handling/panics.md:41
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr ""

#: src/error-handling/panics.md:43
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"이것은 단일 요청이 크래시 되더라도 프로그램이 계속 실행되야 하는 서버에 유용"
"합니다."

#: src/error-handling/panics.md:45
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"만약 `Cargo.toml`설정파일에 `panic = abort`을 설정했다면 크래시를 캐치할 수 "
"없습니다."

#: src/error-handling/try.md:3
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""

#: src/error-handling/try.md:15
msgid "into the much simpler"
msgstr "이렇게 짧게 쓸 수 있습니다"

#: src/error-handling/try.md:21
msgid "We can use this to simplify our error handling code:"
msgstr "이제 우리 예제에 적용해 보겠습니다:"

#: src/error-handling/try.md:42
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr ""

#: src/error-handling/try.md:43 src/error-handling/try-conversions.md:65
#: src/error-handling/thiserror-and-anyhow.md:33
msgid "\"config.dat\""
msgstr ""

#: src/error-handling/try.md:44 src/error-handling/try-conversions.md:66
msgid "\"username or error: {username:?}\""
msgstr ""

#: src/error-handling/try.md:50
msgid "Simplify the `read_username` function to use `?`."
msgstr ""

#: src/error-handling/try.md:54
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "`username` 변수는 `Ok(string)`이거나 `Err(error)`일 수 있습니다."

#: src/error-handling/try.md:55
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"`fs::write` 메서드를 사용하여 파일이 없거나, 비었거나, 중복되는 경우 등을 테"
"스트해 봅니다."

#: src/error-handling/try.md:57
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process:Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""

#: src/error-handling/try-conversions.md:3
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr "실제로 `?`가 적용되는 과정은 아까 설명한 것 보다 좀 더 복잡합니다:"

#: src/error-handling/try-conversions.md:10
msgid "works the same as"
msgstr "위 표현은 아래와 같습니다"

#: src/error-handling/try-conversions.md:19
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"`From::from`을 통해 원래의 에러 타입을 이 함수가 반환하는 에러 타입으로 변환"
"하고 있습니다:"

#: src/error-handling/try-conversions.md:42
msgid "\"IO error: {e}\""
msgstr ""

#: src/error-handling/try-conversions.md:43
msgid "\"Found no username in {path}\""
msgstr ""

#: src/error-handling/try-conversions.md:64
#: src/error-handling/thiserror-and-anyhow.md:32
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr ""

#: src/error-handling/try-conversions.md:72
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""

#: src/error-handling/try-conversions.md:78
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""

#: src/error-handling/try-conversions.md:81
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""

#: src/error-handling/try-conversions.md:85
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""

#: src/error-handling/error.md:1
msgid "Dynamic Error Types"
msgstr "동적인 에러 타입"

#: src/error-handling/error.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"때때로 우리는, 발생 가능한 모든 에러를 일일히 열거하지 않고, 어떤 종류의 에러"
"라도 상관없이 리턴하고 싶을 때가 있습니다. `std::error::Error`를 이용하면 쉽"
"습니다."

#: src/error-handling/error.md:20 src/error-handling/error.md:21
msgid "\"count.dat\""
msgstr ""

#: src/error-handling/error.md:20
msgid "\"1i3\""
msgstr ""

#: src/error-handling/error.md:22
msgid "\"Count: {count}\""
msgstr ""

#: src/error-handling/error.md:23
msgid "\"Error: {err}\""
msgstr ""

#: src/error-handling/error.md:30
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""

#: src/error-handling/error.md:33
#, fuzzy
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"이렇게 하면 코드의 양을 줄일 수 있습니다. 그러나 서로 다른 종류의 에러를 구별"
"하여 다르게 처리하는 것이 불가능해 집니다. 때문에, `Box<dyn Error>`를 라이브"
"러리의 API로 노출하는게 좋은 디자인은 아닙니다. 에러 발생 시, 그저 에러 메시"
"지를 출력하고 싶은 경우와 같이 제한된 상황에서는 유용할 수 있습니다."

#: src/error-handling/error.md:39
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:3
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling. `thiserror` "
"helps create custom error types that implement `From<T>`. `anyhow` helps "
"with error handling in functions, including adding contextual information to "
"your errors."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:16
msgid "\"Found no username in {0}\""
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:22
msgid "\"Failed to open {path}\""
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:24
msgid "\"Failed to read\""
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:34
msgid "\"Username: {username}\""
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:35
msgid "\"Error: {err:?}\""
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:42
#, fuzzy
msgid "`thiserror`"
msgstr "`Error`"

#: src/error-handling/thiserror-and-anyhow.md:44
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:46
msgid "The `std::error::Error` trait is derived automatically."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:47
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:49
msgid "`anyhow`"
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:51
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error`는 `Box<dyn Error>`의 래퍼 타입이라 할 수 있습니다. 따라서 라"
"이브러리의 공개 API로서 사용하기에 부적합하다고 할 수 있지만 많은 애플리케이"
"션에 널리 사용되고 있습니다."

#: src/error-handling/thiserror-and-anyhow.md:54
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"`anyhow::Result<V>`는 `Result<V, anyhow::Error>`의 타입 앨리어스(alias)입니"
"다."

#: src/error-handling/thiserror-and-anyhow.md:55
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"필요하다면 `anyhow::Error`에 저장된 진짜 에러 타입을 꺼내어 검사할 수도 있습"
"니다."

#: src/error-handling/thiserror-and-anyhow.md:56
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"`anyhow::Result<T>`가 제공하는 기능들이 Go 언어 개발자들에게는 익숙할 것입니"
"다. Go언어에서 반환 값으로 사용하는 `(T, error)` 패턴과 비슷하기 때문입니다."

#: src/error-handling/thiserror-and-anyhow.md:59
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""

#: src/error-handling/exercise.md:1
msgid "Exercise: Rewriting with Result"
msgstr ""

#: src/error-handling/exercise.md:3
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""

#: src/error-handling/exercise.md:8
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""

#: src/error-handling/exercise.md:15 src/error-handling/solution.md:9
msgid "/// An arithmetic operator.\n"
msgstr ""

#: src/error-handling/exercise.md:22 src/error-handling/solution.md:16
msgid "/// A token in the expression language.\n"
msgstr ""

#: src/error-handling/exercise.md:30 src/error-handling/solution.md:24
msgid "/// An expression in the expression language.\n"
msgstr ""

#: src/error-handling/exercise.md:34 src/error-handling/solution.md:28
msgid "/// A reference to a variable.\n"
msgstr ""

#: src/error-handling/exercise.md:36 src/error-handling/solution.md:30
msgid "/// A literal number.\n"
msgstr ""

#: src/error-handling/exercise.md:38 src/error-handling/solution.md:32
msgid "/// A binary operation.\n"
msgstr ""

#: src/error-handling/exercise.md:62 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:62 src/error-handling/solution.md:64
msgid "'z'"
msgstr ""

#: src/error-handling/exercise.md:64 src/error-handling/solution.md:64
msgid "'_'"
msgstr ""

#: src/error-handling/exercise.md:70 src/error-handling/solution.md:70
msgid "'+'"
msgstr ""

#: src/error-handling/exercise.md:71 src/error-handling/solution.md:71
msgid "'-'"
msgstr ""

#: src/error-handling/exercise.md:72
msgid "\"Unexpected character {c}\""
msgstr ""

#: src/error-handling/exercise.md:82 src/error-handling/solution.md:81
msgid "\"Unexpected end of input\""
msgstr ""

#: src/error-handling/exercise.md:86
msgid "\"Invalid 32-bit integer'\""
msgstr ""

#: src/error-handling/exercise.md:90 src/error-handling/exercise.md:100
msgid "\"Unexpected token {tok:?}\""
msgstr ""

#: src/error-handling/exercise.md:92 src/error-handling/solution.md:104
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr ""

#: src/error-handling/exercise.md:108 src/error-handling/solution.md:121
msgid "\"10+foo+20-30\""
msgstr ""

#: src/error-handling/exercise.md:109 src/error-handling/solution.md:122
msgid "\"{expr:?}\""
msgstr ""

#: src/error-handling/solution.md:42
msgid "\"Unexpected character '{0}' in input\""
msgstr ""

#: src/error-handling/solution.md:79
msgid "\"Tokenizer error: {0}\""
msgstr ""

#: src/error-handling/solution.md:83
msgid "\"Unexpected token {0:?}\""
msgstr ""

#: src/error-handling/solution.md:85
msgid "\"Invalid number\""
msgstr ""

#: src/unsafe-rust/unsafe.md:3
msgid "The Rust language has two parts:"
msgstr "러스트로 작성된 프로그램은 크게 두 부분으로 나뉩니다:"

#: src/unsafe-rust/unsafe.md:5
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr ""
"**안전한 러스트:** 메모리 관련 오류 발생 불가능, 정의되지 않은 동작 없음."

#: src/unsafe-rust/unsafe.md:6
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**안전하지 않은 러스트:** 특별한 조건을 만족하지 않은채로 사용되면 정의되지 "
"않은 동작을 유발할 수 있음."

#: src/unsafe-rust/unsafe.md:8
#, fuzzy
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"이 강의는 대부분 안전한 러스트에 대해 다루지만 안전하지 않은 러스트가 무엇인"
"지는 알아 두어야 합니다."

#: src/unsafe-rust/unsafe.md:11
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"보통, 안전하지 않은 러스트 코드는 크기가 작으며, 독립적으로 존재합니다. 그리"
"고 코드가 왜 잘 작동하는지에 대해 세밀하게 문서화가 되어 있습니다. 그리고, 많"
"은 경우 안전한 러스트 코드를 통해서 추상화를 시킨 후 사용하게 됩니다."

#: src/unsafe-rust/unsafe.md:14
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr ""
"안전하지 않은 러스트를 이용하면 다음과 같은 다섯 가지 것들이 가능해 집니다:"

#: src/unsafe-rust/unsafe.md:16
msgid "Dereference raw pointers."
msgstr "원시 포인터 역참조(따라가기)"

#: src/unsafe-rust/unsafe.md:17
msgid "Access or modify mutable static variables."
msgstr "정적 가변변수 접근 및 수정."

#: src/unsafe-rust/unsafe.md:18
msgid "Access `union` fields."
msgstr "`union` 필드 접근."

#: src/unsafe-rust/unsafe.md:19
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "`extern` 함수를 포함한 `unsafe` 함수 호출."

#: src/unsafe-rust/unsafe.md:20
msgid "Implement `unsafe` traits."
msgstr "`unsafe` 트레잇 구현."

#: src/unsafe-rust/unsafe.md:22
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"위 기능들에 대해 간략히 살펴보겠습니다. 자세한 내용은 [러스트 프로그래밍 언"
"어, 19.1절](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)과 "
"[Rustonomicon](https://doc.rust-lang.org/nomicon/)를 참조하세요."

#: src/unsafe-rust/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"안전하지 않은 러스트라고 해서 코드가 부정확 하다는 뜻은 아닙니다. 여기서 안전"
"하지 않다의 의미는 컴파일러가 제공해주는 안전 장치들이 꺼진 상태이며, 개발자"
"가 스스로 정확하고 안전한 코드를 작성해야 함을 의미합니다. 이는 컴파일러가 "
"더 이상 러스트의 메모리 안전과 관련된 규칙들을 적용하지 않는다는 것입니다."

#: src/unsafe-rust/dereferencing.md:3
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"포인터를 만드는 것은 안전합니다. 하지만 역참조(따라가기)할 경우 `unsafe`가 필"
"요합니다:"

#: src/unsafe-rust/dereferencing.md:7
msgid "\"careful!\""
msgstr ""

#: src/unsafe-rust/dereferencing.md:12
#, fuzzy
msgid ""
"// Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe-rust/dereferencing.md:18
msgid "\"r1 is: {}\""
msgstr ""

#: src/unsafe-rust/dereferencing.md:19
msgid "\"uhoh\""
msgstr ""

#: src/unsafe-rust/dereferencing.md:20
msgid "\"r2 is: {}\""
msgstr ""

#: src/unsafe-rust/dereferencing.md:23
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""

#: src/unsafe-rust/dereferencing.md:34
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"모든 `unsafe` 블록에 대해 왜 그 코드가 안전한지에 대한 설명을 주석으로 다는 "
"것은 좋은 습관입니다(사실 안드로이드의 러스트 스타일 가이드에서는 이게 필수입"
"니다)."

#: src/unsafe-rust/dereferencing.md:38
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"포인터 역참조를 할 경우, 포인터가 [_유효_](https://doc.rust-lang.org/std/ptr/"
"index.html#safety)해야 합니다. 예를 들어:"

#: src/unsafe-rust/dereferencing.md:41
msgid "The pointer must be non-null."
msgstr "포인터는 null이면 안됩니다."

#: src/unsafe-rust/dereferencing.md:42
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"포인터는 따라가기가 가능해야 합니다 (객체의 어느 한 부분을 가리키고 있어야 합"
"니다)."

#: src/unsafe-rust/dereferencing.md:44
msgid "The object must not have been deallocated."
msgstr "이미 반환된 객체를 가리키면 안됩니다."

#: src/unsafe-rust/dereferencing.md:45
msgid "There must not be concurrent accesses to the same location."
msgstr "같은 위치에 대해 동시적인 접근이 있으면 안됩니다."

#: src/unsafe-rust/dereferencing.md:46
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"참조를 캐스팅 해서 포인터를 만들었다면, 그 참조가 가리키는 객체는 살아 있어"
"야 하며, 그 객체의 메모리를 접근하는 참조가 하나도 없어야 합니다."

#: src/unsafe-rust/dereferencing.md:49
msgid "In most cases the pointer must also be properly aligned."
msgstr "대부분의 경우 포인터는 align되어 있어야 합니다."

#: src/unsafe-rust/dereferencing.md:51
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""

#: src/unsafe-rust/mutable-static.md:3
msgid "It is safe to read an immutable static variable:"
msgstr "불변 정적변수를 읽는 것은 안전합니다:"

#: src/unsafe-rust/mutable-static.md:6
#, fuzzy
msgid "\"Hello, world!\""
msgstr "Hello World!"

#: src/unsafe-rust/mutable-static.md:9
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr ""

#: src/unsafe-rust/mutable-static.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"하지만, 데이터 레이스가 발생할 수 있으므로 정적 가변변수를 읽고 쓰는 것은 안"
"전하지 않습니다:"

#: src/unsafe-rust/mutable-static.md:29
msgid "\"COUNTER: {COUNTER}\""
msgstr ""

#: src/unsafe-rust/mutable-static.md:36
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""

#: src/unsafe-rust/mutable-static.md:41
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"일반적으로 이야기 해서, 정적 가변 변수를 쓰는 것은 좋은 아이디어가 아닙니다. "
"그러나 `no_std`와 같은 저수준 코딩을 할 경우에는 필요하기도 합니다. 예를 들"
"어 힙 할당기를 구현하거나, C API를 사용하는 게 그런 경우입니다."

#: src/unsafe-rust/unions.md:3
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"유니온 타입은 열거형(enum)과 비슷하지만, 어떤 필드에 해당하는 값을 가지고 있"
"는지 여부를 프로그래머가 수동으로 추적해야 합니다:"

#: src/unsafe-rust/unions.md:14
msgid "\"int: {}\""
msgstr ""

#: src/unsafe-rust/unions.md:15
msgid "\"bool: {}\""
msgstr ""

#: src/unsafe-rust/unions.md:15
#, fuzzy
msgid "// Undefined behavior!\n"
msgstr "런타임 시 정의되지 않음(undefined) 동작 없음:"

#: src/unsafe-rust/unions.md:21
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"러스트에는 열거형이 있기 때문에 유니온이 필요한 경우는 극히 드뭅니다. 유니온"
"은 C 라이브러리 API를 사용할 때 가끔 필요합니다."

#: src/unsafe-rust/unions.md:24
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"바이트들을 특정 타입으로 재해석 하고 싶다면 [`std::mem::transmute`](https://"
"doc.rust-lang.org/stable/std/mem/fn.transmute.html)나 좀 더 안전한 "
"[`zerocopy`](https://crates.io/crates/zerocopy) 크레이트를 사용하세요."

#: src/unsafe-rust/unsafe-functions.md:3 src/unsafe-rust/unsafe-functions.md:74
msgid "Calling Unsafe Functions"
msgstr "안전하지 않은 함수 호출"

#: src/unsafe-rust/unsafe-functions.md:5
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"함수나 메서드가 정의되지 않은 동작으로 빠지지 않게 하기 위해서 만족해야 하는 "
"전제 조건이 있는 경우, 그 함수나 메서드를 `unsafe`로 표시할 수 있습니다:"

#: src/unsafe-rust/unsafe-functions.md:9 src/unsafe-rust/exercise.md:91
#: src/unsafe-rust/solution.md:41 src/android/interoperability/with-c.md:9
#: src/android/interoperability/with-c/rust.md:15
#: src/android/interoperability/with-c/rust.md:30
#: src/android/interoperability/cpp/cpp-bridge.md:29
#: src/android/interoperability/cpp/cpp-bridge.md:38
#: src/exercises/chromium/build-rules.md:8
#: src/exercises/chromium/build-rules.md:21
#: src/bare-metal/aps/inline-assembly.md:19
#: src/bare-metal/aps/better-uart/using.md:24
#: src/bare-metal/aps/logging/using.md:23 src/exercises/bare-metal/rtc.md:49
#: src/exercises/bare-metal/rtc.md:104 src/exercises/bare-metal/rtc.md:110
#: src/exercises/bare-metal/rtc.md:118 src/exercises/bare-metal/rtc.md:124
#: src/exercises/bare-metal/rtc.md:130 src/exercises/bare-metal/rtc.md:136
#: src/exercises/bare-metal/rtc.md:142 src/exercises/bare-metal/rtc.md:148
#: src/exercises/bare-metal/solutions-afternoon.md:43
msgid "\"C\""
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:14
msgid "\"🗻∈🌏\""
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:16
msgid ""
"// Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:19
#: src/unsafe-rust/unsafe-functions.md:20
#: src/unsafe-rust/unsafe-functions.md:21
msgid "\"emoji: {}\""
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:24
msgid "\"char count: {}\""
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:27
#, fuzzy
msgid "// Undefined behavior if abs misbehaves.\n"
msgstr "런타임 시 정의되지 않음(undefined) 동작 없음:"

#: src/unsafe-rust/unsafe-functions.md:28
msgid "\"Absolute value of -3 according to C: {}\""
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:31
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:42
#: src/unsafe-rust/unsafe-functions.md:86
msgid "Writing Unsafe Functions"
msgstr "안전하지 않은 함수 작성하기"

#: src/unsafe-rust/unsafe-functions.md:44
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"여러분이 작성한 함수를 사용할 때 어떤 특별한 조건을 만족해야 한다면, `unsafe`"
"로 마킹할 수 있습니다."

#: src/unsafe-rust/unsafe-functions.md:48
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:63
msgid "// Safe because ...\n"
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:68
msgid "\"a = {}, b = {}\""
msgstr ""

#: src/unsafe-rust/unsafe-functions.md:76
#, fuzzy
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"이게 문제가 되는 경우는 대부분 외부 함수가 러스트의 메모리 모델을 위반하고 있"
"을 경우입니다. 그러나 어떤 C함수라도 어떤 임의의 상황에서는 정의되지 않은 동"
"작을 할 수 있기 때문에, 엄밀히 말해서는 모든 외부 함수에 대해서 문제입니다."

#: src/unsafe-rust/unsafe-functions.md:83
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"위 예제 코드에서 `\"C\"`는 ABI를 의미합니다. [다른 ABI도 있습니다.](https://"
"doc.rust-lang.org/reference/items/external-blocks.html)"

#: src/unsafe-rust/unsafe-functions.md:88
#, fuzzy
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr ""
"참조를 사용하면 안전하게 구현할 수 있기 때문에, 실제로 포인터를 사용할 필요"
"는 없습니다."

#: src/unsafe-rust/unsafe-functions.md:91
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"안전하지 않은(unsafe) 코드가 안전하지 않은(unsafe) 함수의 내부에서 호출될 경"
"우에는 `unsafe`블록을 지정하지 않아도 됩니다. `unsafe`블록을 항상 지정하도록 "
"하고 싶다면 `#[deny(unsafe_op_in_unsafe_fn)]`를 이용하세요. 이 어트리뷰트를 "
"추가해 보고 어떤 일이 일어나는지 확인해 보세요."

#: src/unsafe-rust/unsafe-traits.md:1
msgid "Implementing Unsafe Traits"
msgstr "안전하지 않은 트레잇 구현하기"

#: src/unsafe-rust/unsafe-traits.md:3
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"함수에서와 마찬가지로 트레잇도 `unsafe`로 마킹 가능합니다. 만약 그 트레잇을 "
"구현할 때 정의되지 않은 동작을 피하기 위해 특별한 조건이 필요하다면 말이지요."

#: src/unsafe-rust/unsafe-traits.md:6
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"예를 들어 `zerocopy` 크레이트에는 [안전하지 않은 트레잇](https://docs.rs/"
"zerocopy/latest/zerocopy/trait.AsBytes.html)이 있습니다:"

#: src/unsafe-rust/unsafe-traits.md:12
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""

#: src/unsafe-rust/unsafe-traits.md:26
msgid "// Safe because u32 has a defined representation and no padding.\n"
msgstr ""

#: src/unsafe-rust/unsafe-traits.md:33
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"안전하지 않은 트레잇을 만들 때에는 주석에 `# Safety` 항목이 있어서 이 트레잇"
"을 안전하게 구현하려면 어떤 요구사항들을 만족해야 하는지를 설명해야 합니다."

#: src/unsafe-rust/unsafe-traits.md:36
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"`AsBytes`에서 지켜야 할 안전성에 대한 실제 설명은 좀 더 길고 복잡합니다."

#: src/unsafe-rust/unsafe-traits.md:38
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "빌트인 트레잇인 `Send`와 `Sync`는 안전하지 않은 트레잇 입니다."

#: src/unsafe-rust/exercise.md:1
msgid "Safe FFI Wrapper"
msgstr "FFI래퍼"

#: src/unsafe-rust/exercise.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"러스트는 \\_외부 기능 호출(FFI)\\_을 지원합니다. 우리는 이를 이용하여 디렉터"
"리에서 파일 이름을 읽어오는 `libc` 함수에 대한 안전한 래퍼를 만들 것입니다."

#: src/unsafe-rust/exercise.md:7
msgid "You will want to consult the manual pages:"
msgstr "아래 리눅스 메뉴얼 문서들을 참조하시기 바랍니다:"

#: src/unsafe-rust/exercise.md:9
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md:10
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md:11
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md:13
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"아마 [`std::ffi`](https://doc.rust-lang.org/std/ffi/)모듈을 참조할 필요가 있"
"을 것입니다. 거기에는 이번 예제를 수행하는데 필요한 다양한 종류의 문자열 타입"
"들이 소개되어 있습니다:"

#: src/unsafe-rust/exercise.md:16
msgid "Encoding"
msgstr "인코딩"

#: src/unsafe-rust/exercise.md:16
msgid "Use"
msgstr "사용"

#: src/unsafe-rust/exercise.md:18
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html)과 [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md:18
msgid "UTF-8"
msgstr "UTF-8"

#: src/unsafe-rust/exercise.md:18
msgid "Text processing in Rust"
msgstr "러스트에서의 문자열 처리"

#: src/unsafe-rust/exercise.md:19
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html)과 [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md:19
msgid "NUL-terminated"
msgstr "널(NUL)로 끝남"

#: src/unsafe-rust/exercise.md:19
msgid "Communicating with C functions"
msgstr "C함수와 연동하기"

#: src/unsafe-rust/exercise.md:20
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html)와 [`OsString`]"
"(https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md:20
msgid "OS-specific"
msgstr "OS가 정의함"

#: src/unsafe-rust/exercise.md:20
msgid "Communicating with the OS"
msgstr "OS와 연동하기 위한 문자열"

#: src/unsafe-rust/exercise.md:22
msgid "You will convert between all these types:"
msgstr "이 타입들 간의 변환은 다음과 같습니다:"

#: src/unsafe-rust/exercise.md:24
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"`&str`에서 `CString`으로의 변환: 맨 마지막의 `\\0` 문자를 저장하기 위한 공간"
"을 할당해야 합니다,"

#: src/unsafe-rust/exercise.md:25
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"`CString`에서 `*const i8`로의 변환: C함수를 호출하기 위해서는 포인터가 필요합"
"니다,"

#: src/unsafe-rust/exercise.md:26
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"`*const i8`에서 `&CStr`로의 변환: 주어진 바이트 시퀀스가 `\\0`로 끝나는지 확"
"인하고 싶은 경우,"

#: src/unsafe-rust/exercise.md:28
#, fuzzy
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr`에서 `&[u8]`로의 변환: 바이트 슬라이스는 \"알수없는 데이터\"에 대한 일"
"반적인 인터페이스입니다,"

#: src/unsafe-rust/exercise.md:30
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"`&[u8]`에서 `&OsStr`로의 변환: `&OsStr`는 `OsString`으로 가기 위한 중간 단계 "
"입니다. [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait."
"OsStrExt.html)를 사용해서  `OsStr`를 생성하세요,"

#: src/unsafe-rust/exercise.md:33
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"`&OsStr`에서 `OsString`으로의 변환: `&OsStr`이 가리키고 있는 데이터를 복사함"
"으로써, 이 데이터를 리턴하고, `readdir`함수를 호출할 때 사용할 수 있게 해 줍"
"니다."

#: src/unsafe-rust/exercise.md:36
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html)에 FFI와 관련한 아주 유"
"용한 챕터가 있습니다."

#: src/unsafe-rust/exercise.md:47
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"아래 코드를 <https://play.rust-lang.org/>에 복사하고 빠진 함수와 메서드를 채"
"워봅니다:"

#: src/unsafe-rust/exercise.md:56 src/unsafe-rust/exercise.md:69
#: src/unsafe-rust/exercise.md:80 src/unsafe-rust/exercise.md:94
#: src/unsafe-rust/exercise.md:102 src/unsafe-rust/solution.md:6
#: src/unsafe-rust/solution.md:19 src/unsafe-rust/solution.md:30
#: src/unsafe-rust/solution.md:44 src/unsafe-rust/solution.md:52
msgid "\"macos\""
msgstr ""

#: src/unsafe-rust/exercise.md:59 src/unsafe-rust/solution.md:9
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr ""

#: src/unsafe-rust/exercise.md:66 src/unsafe-rust/solution.md:16
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""

#: src/unsafe-rust/exercise.md:79 src/unsafe-rust/solution.md:29
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr ""

#: src/unsafe-rust/exercise.md:94 src/unsafe-rust/exercise.md:102
#: src/unsafe-rust/solution.md:44 src/unsafe-rust/solution.md:52
msgid "\"x86_64\""
msgstr ""

#: src/unsafe-rust/exercise.md:97 src/unsafe-rust/solution.md:47
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""

#: src/unsafe-rust/exercise.md:103 src/unsafe-rust/solution.md:53
msgid "\"readdir$INODE64\""
msgstr ""

#: src/unsafe-rust/exercise.md:121 src/unsafe-rust/solution.md:71
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""

#: src/unsafe-rust/exercise.md:130
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr ""

#: src/unsafe-rust/exercise.md:137 src/unsafe-rust/solution.md:105
msgid "// Call closedir as needed.\n"
msgstr ""

#: src/unsafe-rust/exercise.md:143 src/unsafe-rust/solution.md:116
#: src/unsafe-rust/solution.md:140 src/unsafe-rust/solution.md:155
#: src/android/interoperability/with-c/rust.md:44
msgid "\".\""
msgstr ""

#: src/unsafe-rust/exercise.md:144 src/unsafe-rust/solution.md:117
msgid "\"files: {:#?}\""
msgstr ""

#: src/unsafe-rust/solution.md:74
msgid "\"Invalid path: {err}\""
msgstr ""

#: src/unsafe-rust/solution.md:75
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr ""

#: src/unsafe-rust/solution.md:78
msgid "\"Could not open {:?}\""
msgstr ""

#: src/unsafe-rust/solution.md:88
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""

#: src/unsafe-rust/solution.md:92
msgid "// We have reached the end of the directory.\n"
msgstr ""

#: src/unsafe-rust/solution.md:95
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""

#: src/unsafe-rust/solution.md:107
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr ""

#: src/unsafe-rust/solution.md:109
msgid "\"Could not close {:?}\""
msgstr ""

#: src/unsafe-rust/solution.md:128
msgid "\"no-such-directory\""
msgstr ""

#: src/unsafe-rust/solution.md:136 src/unsafe-rust/solution.md:151
msgid "\"Non UTF-8 character in path\""
msgstr ""

#: src/unsafe-rust/solution.md:140 src/unsafe-rust/solution.md:155
msgid "\"..\""
msgstr ""

#: src/unsafe-rust/solution.md:147 src/unsafe-rust/solution.md:155
msgid "\"foo.txt\""
msgstr ""

#: src/unsafe-rust/solution.md:147
msgid "\"The Foo Diaries\\n\""
msgstr ""

#: src/unsafe-rust/solution.md:148 src/unsafe-rust/solution.md:155
msgid "\"bar.png\""
msgstr ""

#: src/unsafe-rust/solution.md:148
msgid "\"<PNG>\\n\""
msgstr ""

#: src/unsafe-rust/solution.md:149 src/unsafe-rust/solution.md:155
msgid "\"crab.rs\""
msgstr ""

#: src/unsafe-rust/solution.md:149
msgid "\"//! Crab\\n\""
msgstr ""

#: src/android.md:1
#, fuzzy
msgid "Welcome to Rust in Android"
msgstr "1일차 개요"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"러스트는 안드로이드 네이티브 플랫폼 개발을 지원합니다. 기존의 OS 서비스를 확"
"장하거나, 새로운 서비스를 만드는데 러스트를 쓸 수 있습니다."

#: src/android.md:7
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"우리는 오늘 여러분의 프로젝트에서 러스트 코드를 호출해볼 것입니다. 그 프로젝"
"트에서 러스트로 옮길만 한 작은 부분을 정하세요. 의존성이 적고 \"특이한\" 타입"
"이 적을 수록 좋습니다. 바이트 몇 개를 파싱하는 코드라면 완벽합니다."

#: src/android.md:14
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr ""

#: src/android.md:17
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""

#: src/android.md:20
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""

#: src/android.md:23
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""

#: src/android.md:26
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"안드로이드 가상 디바이스(Android Virtual Device)를 사용하여 여러분의 코드를 "
"수행할 겁니다. 새로운 가상 디바이스를 생성하려면 아래의 명령어를 사용하세요:"

#: src/android/setup.md:12
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"자세한 내용은 [Android Developer Codelab](https://source.android.com/docs/"
"setup/start)을 참조하십시오."

#: src/android/setup.md:20
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""

#: src/android/setup.md:23
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"안드로이드 빌드 시스템(Soong)은 다음과 같은 여러 모듈을 통해 러스트를 지원합"
"니다:"

#: src/android/build-rules.md:5
msgid "Module Type"
msgstr "Module Type"

#: src/android/build-rules.md:5
msgid "Description"
msgstr "Description"

#: src/android/build-rules.md:7
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md:7
msgid "Produces a Rust binary."
msgstr "러스트 바이너리를 생성합니다."

#: src/android/build-rules.md:8
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md:8
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr "러스트 라이브러리(rlib혹은 dylib)를 생성합니다."

#: src/android/build-rules.md:9
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md:9
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr "cc 모듈에서 사용할 수 있는 C library (정적 혹은 동적)를 생성합니다."

#: src/android/build-rules.md:10
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md:10
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"`proc-macro`를 구현하는 러스트 라이브러리를 생성합니다. 컴파일러의 플러그인으"
"로 생각해도 좋습니다."

#: src/android/build-rules.md:11
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md:11
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr "표준 러스트 테스트 러너를 사용하는 테스트 바이너리를 생성합니다."

#: src/android/build-rules.md:12
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md:12
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "`libfuzzer`를 사용하여 fuzz 바이너리를 생성합니다."

#: src/android/build-rules.md:13
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md:13
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"프로토버프(protobuf) 인터페이스를 제공하는 러스트 라이브러리를 생성합니다."

#: src/android/build-rules.md:14
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md:14
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"C 라이브러리에 대한 러스트 바인딩을 제공하는 러스트 라이브러리를 생성합니다."

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "다음은 `rust_binary`와 `rust_library`를 살펴봅니다."

#: src/android/build-rules.md:20
msgid "Additional items speaker may mention:"
msgstr ""

#: src/android/build-rules.md:22
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr ""

#: src/android/build-rules.md:25
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""

#: src/android/build-rules.md:28
msgid ""
"Soong has many similarities to Bazel, which is the open-source variant of "
"Blaze (used in google3)."
msgstr ""

#: src/android/build-rules.md:31
msgid ""
"There is a plan to transition [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) to Bazel."
msgstr ""

#: src/android/build-rules.md:37
msgid "Learning Bazel-like build rules is useful for all Rust OS developers."
msgstr ""

#: src/android/build-rules.md:39
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr ""

#: src/android/build-rules/binary.md:1
msgid "Rust Binaries"
msgstr "러스트 바이너리"

#: src/android/build-rules/binary.md:3
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"간단한 응용 프로그램으로 시작해 보겠습니다. AOSP 체크아웃의 루트에서 다음 파"
"일을 생성합니다:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:10 src/android/build-rules/binary.md:11
msgid "\"hello_rust\""
msgstr ""

#: src/android/build-rules/binary.md:12 src/android/build-rules/library.md:19
#: src/android/logging.md:12
#, fuzzy
msgid "\"src/main.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:19 src/android/build-rules/library.md:37
msgid "//! Rust demo.\n"
msgstr ""

#: src/android/build-rules/binary.md:20 src/android/build-rules/library.md:41
msgid "/// Prints a greeting to standard output.\n"
msgstr ""

#: src/android/build-rules/binary.md:23 src/exercises/chromium/build-rules.md:9
msgid "\"Hello from Rust!\""
msgstr ""

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "그런 다음, 이 바이너리를 빌드하고, 가상 디바이스에 넣고, 실행합니다:"

#: src/android/build-rules/binary.md:29
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/build-rules/library.md:1
msgid "Rust Libraries"
msgstr "러스트 라이브러리"

#: src/android/build-rules/library.md:3
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"`rust_library`를 사용하여 안드로이드용 새 러스트 라이브러리를 만듭니다."

#: src/android/build-rules/library.md:5
msgid "Here we declare a dependency on two libraries:"
msgstr "여기서 두 개의 라이브러리에 대한 의존성을 선언합니다:"

#: src/android/build-rules/library.md:7
msgid "`libgreeting`, which we define below,"
msgstr "아래에 정의한 `libgreeting`."

#: src/android/build-rules/library.md:8
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"[`external/rust/crates/`](https://cs.android.com/android/platform/"
"superproject/+/master:external/rust/crates/)에 존재하는 `libtextwrap`."

#: src/android/build-rules/library.md:17 src/android/build-rules/library.md:18
msgid "\"hello_rust_with_dep\""
msgstr ""

#: src/android/build-rules/library.md:21 src/android/build-rules/library.md:28
msgid "\"libgreetings\""
msgstr ""

#: src/android/build-rules/library.md:22
msgid "\"libtextwrap\""
msgstr ""

#: src/android/build-rules/library.md:24
msgid "// Need this to avoid dynamic link error.\n"
msgstr ""

#: src/android/build-rules/library.md:29
msgid "\"greetings\""
msgstr ""

#: src/android/build-rules/library.md:30 src/android/aidl/implementation.md:29
#: src/android/interoperability/java.md:39
#, fuzzy
msgid "\"src/lib.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:51
msgid "//! Greeting library.\n"
msgstr ""

#: src/android/build-rules/library.md:52
msgid "/// Greet `name`.\n"
msgstr ""

#: src/android/build-rules/library.md:55
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr ""

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "이전처럼, 빌드하고, 가상 디바이스로 넣고, 실행합니다:"

#: src/android/build-rules/library.md:61
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"

#: src/android/aidl.md:3
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"러스트는 [안드로이드 인터페이스 정의 언어(AIDL)](https://developer.android."
"com/guide/components/aidl)를 지원합니다:"

#: src/android/aidl.md:8
msgid "Rust code can call existing AIDL servers,"
msgstr "러스트 코드에서 기존 AIDL 서버를 호출 할 수 있습니다. "

#: src/android/aidl.md:9
msgid "You can create new AIDL servers in Rust."
msgstr "러스트에서 새로운 AIDL 서버를 생성할 수 있습니다."

#: src/android/aidl/interface.md:1
msgid "AIDL Interfaces"
msgstr "AIDL 인터페이스"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "AIDL 인터페이스를 이용해서 서비스의 API를 선언합니다:"

#: src/android/aidl/interface.md:5
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:9 src/android/aidl/changing.md:8
msgid "/** Birthday service interface. */"
msgstr ""

#: src/android/aidl/interface.md:12 src/android/aidl/changing.md:11
msgid "/** Generate a Happy Birthday message. */"
msgstr ""

#: src/android/aidl/interface.md:17
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md:21
msgid "\"com.example.birthdayservice\""
msgstr ""

#: src/android/aidl/interface.md:22
#, fuzzy
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:25
msgid "// Rust is not enabled by default\n"
msgstr ""

#: src/android/aidl/interface.md:32
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"AIDL 파일이 벤더 파티션에 있는 바이너리에서 사용될 경우 `vendor_available: "
"true`를 추가합니다."

#: src/android/aidl/implementation.md:1
msgid "Service Implementation"
msgstr "서비스 구현"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "이제 AIDL서비스를 구현할 수 있습니다:"

#: src/android/aidl/implementation.md:5
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:8
msgid "//! Implementation of the `IBirthdayService` AIDL interface.\n"
msgstr ""

#: src/android/aidl/implementation.md:11
#, fuzzy
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "서비스 구현"

#: src/android/aidl/implementation.md:19
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr ""

#: src/android/aidl/implementation.md:24 src/android/aidl/server.md:28
#: src/android/aidl/client.md:36
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md:28 src/android/aidl/server.md:38
#, fuzzy
msgid "\"libbirthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:30 src/android/aidl/server.md:13
#: src/android/aidl/client.md:12
#, fuzzy
msgid "\"birthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:32 src/android/aidl/server.md:36
#: src/android/aidl/client.md:44
msgid "\"com.example.birthdayservice-rust\""
msgstr ""

#: src/android/aidl/implementation.md:33 src/android/aidl/server.md:37
#: src/android/aidl/client.md:45
msgid "\"libbinder_rs\""
msgstr ""

#: src/android/aidl/server.md:1
msgid "AIDL Server"
msgstr "AIDL 서버"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "마지막으로 서비스를 제공하는 서버를 만들 수 있습니다:"

#: src/android/aidl/server.md:5
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md:8 src/android/aidl/client.md:8
msgid "//! Birthday service.\n"
msgstr ""

#: src/android/aidl/server.md:14
msgid "/// Entry point for birthday service.\n"
msgstr ""

#: src/android/aidl/server.md:23
msgid "\"Failed to register service\""
msgstr ""

#: src/android/aidl/server.md:32 src/android/aidl/server.md:33
#, fuzzy
msgid "\"birthday_server\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/server.md:34
#, fuzzy
msgid "\"src/server.rs\""
msgstr "서버."

#: src/android/aidl/server.md:40 src/android/aidl/client.md:47
msgid "// To avoid dynamic link error.\n"
msgstr ""

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "서비스를 빌드하고, 가상 디바이스에 넣고, 시작 할 수 있습니다:"

#: src/android/aidl/deploy.md:5
#, fuzzy
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md:12
msgid "In another terminal, check that the service runs:"
msgstr "다른 터미널을 띄워서 서비스가 잘 수행되고 있는지 확인합니다:"

#: src/android/aidl/deploy.md:22
msgid "You can also call the service with `service call`:"
msgstr "`service call`명렁어로 서비스를 호출할 수도 있습니다:"

#: src/android/aidl/client.md:1
msgid "AIDL Client"
msgstr "AIDL 클라이언트"

#: src/android/aidl/client.md:3
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"마지막으로, 아까 추가한 서비스에 대한 클라이언트를 러스트로 만들겠습니다."

#: src/android/aidl/client.md:5
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:13
msgid "/// Connect to the BirthdayService.\n"
msgstr ""

#: src/android/aidl/client.md:19
msgid "/// Call the birthday service.\n"
msgstr ""

#: src/android/aidl/client.md:29
msgid "\"Failed to connect to BirthdayService\""
msgstr ""

#: src/android/aidl/client.md:31
msgid "\"{msg}\""
msgstr ""

#: src/android/aidl/client.md:40 src/android/aidl/client.md:41
#, fuzzy
msgid "\"birthday_client\""
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:42
#, fuzzy
msgid "\"src/client.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/aidl/client.md:51
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "클라이언트는 `libbirthdayservice`에 의존하지 않음에 주목하세요."

#: src/android/aidl/client.md:53
msgid "Build, push, and run the client on your device:"
msgstr "빌드하고, 가상 디바이스로 넣고, 실행합니다:"

#: src/android/aidl/client.md:55
#, fuzzy
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/changing.md:3
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"API를 확장하여 더 많은 기능을 제공해 봅시다. 클라이언트가 생일 카드에 담길 내"
"용을 지정할 수 있도록 하겠습니다:"

#: src/android/logging.md:3
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"`log` 크레이트를 사용하면 안드로이드 디바이스 안에서 수행될 때에는 `logcat`으"
"로, 호스트에서 수행될 때에는 `stdout`으로 로그가 자동으로 출력이 되도록 할 "
"수 있습니다:"

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:10 src/android/logging.md:11
#, fuzzy
msgid "\"hello_rust_logs\""
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:14
msgid "\"liblog_rust\""
msgstr ""

#: src/android/logging.md:15
msgid "\"liblogger\""
msgstr ""

#: src/android/logging.md:21
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid "//! Rust logging demo.\n"
msgstr ""

#: src/android/logging.md:27
msgid "/// Logs a greeting.\n"
msgstr ""

#: src/android/logging.md:32
msgid "\"rust\""
msgstr ""

#: src/android/logging.md:35
msgid "\"Starting program.\""
msgstr ""

#: src/android/logging.md:36
msgid "\"Things are going fine.\""
msgstr ""

#: src/android/logging.md:37
msgid "\"Something went wrong!\""
msgstr ""

#: src/android/logging.md:41 src/android/interoperability/with-c/bindgen.md:96
#: src/android/interoperability/with-c/rust.md:72
msgid "Build, push, and run the binary on your device:"
msgstr "빌드하고, 가상 디바이스에 넣고, 실행합니다:"

#: src/android/logging.md:43
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md:49
msgid "The logs show up in `adb logcat`:"
msgstr "`adb logcat`커맨드로 로그를 확인합니다:"

#: src/android/interoperability.md:3
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr "러스트는 다음과 같이 다른 언어와의 상호운용성을 훌륭히 지원합니다:"

#: src/android/interoperability.md:6
msgid "Call Rust functions from other languages."
msgstr "타 언어에서 러스트 함수를 호출합니다."

#: src/android/interoperability.md:7
msgid "Call functions written in other languages from Rust."
msgstr "타 언어의 함수를 러스트에서 호출합니다."

#: src/android/interoperability.md:9
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"타 언어의 함수를 호출해서 사용하는 것을 FFI(foreign function interface)라고 "
"합니다."

#: src/android/interoperability/with-c.md:1
msgid "Interoperability with C"
msgstr "C와의 상호운용성"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"러스트는 C 호출규약을 따르는 오브젝트 파일과 링킹할 수 있습니다. 또한, 반대"
"로 러스트 함수를 내보내서 C에서 호출 할 수 도 있습니다."

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "원한다면 아래와 같이 수동으로 코딩할 수 있습니다:"

#: src/android/interoperability/with-c.md:16
msgid "\"{x}, {abs_x}\""
msgstr ""

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"우리는 이미 [Safe FFI 래퍼 연습문제](../../exercises/day-3/safe-ffi-wrapper."
"md)에서 이를 다루었습니다."

#: src/android/interoperability/with-c.md:23
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"이러한 방법은 타겟 플랫폼의 모든 부분을 사전에 알고 있다는 전제를 깔고 있습니"
"다. 상용 프로젝트에서는 권장하지 않습니다."

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "좀 더 나은 옵션을 살펴보겠습니다."

#: src/android/interoperability/with-c/bindgen.md:1
msgid "Using Bindgen"
msgstr "Bindgen 사용하기"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)는 C 헤"
"더파일에서 러스트 바인딩을 자동으로 생성하는 도구입니다."

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "먼저 작은 C라이브러리를 만들어 보겠습니다:"

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:22
msgid "<stdio.h>"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:23
#: src/android/interoperability/with-c/bindgen.md:50
msgid "\"libbirthday.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:26
#: src/android/interoperability/with-c/bindgen.md:29
msgid "\"+--------------\\n\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:27
msgid "\"| Happy Birthday %s!\\n\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:28
msgid "\"| Congratulations with the %i years!\\n\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr "`Android.bp` 파일에 아래를 추가합니다:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:106
msgid "_interoperability/bindgen/Android.bp_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:39
#: src/android/interoperability/with-c/bindgen.md:63
msgid "\"libbirthday\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:40
msgid "\"libbirthday.c\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"라이브러리에 대한 헤더 파일을 만듭니다(이 예시에서는 반드시 필요한 것은 아닙"
"니다.):"

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "이제 바인딩을 자동으로 생성할 수 있습니다:"

#: src/android/interoperability/with-c/bindgen.md:59
#: src/android/interoperability/with-c/bindgen.md:75
msgid "\"libbirthday_bindgen\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:60
#, fuzzy
msgid "\"birthday_bindgen\""
msgstr "`rust_bindgen`"

#: src/android/interoperability/with-c/bindgen.md:61
msgid "\"libbirthday_wrapper.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:62
msgid "\"bindings\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "마침내, 러스트 프로그램에서 바인딩을 사용할 수 있습니다:"

#: src/android/interoperability/with-c/bindgen.md:73
msgid "\"print_birthday_card\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:74
#, fuzzy
msgid "\"main.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:82
msgid "//! Bindgen demo.\n"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:89
msgid "// SAFETY: `print_card` is safe to call with a valid `card` pointer.\n"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:98
#, fuzzy
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:104
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"마지막으로, 바인딩이 잘 작동하는지 확인하기 위해, 자동 생성된 테스트를 실행"
"해 보겠습니다:"

#: src/android/interoperability/with-c/bindgen.md:110
#: src/android/interoperability/with-c/bindgen.md:112
msgid "\"libbirthday_bindgen_test\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:111
msgid "\":libbirthday_bindgen\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:113
msgid "\"general-tests\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:115
#: src/android/interoperability/with-c/bindgen.md:116
msgid "\"none\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:115
msgid "// Generated file, skip linting\n"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
msgid "Calling Rust"
msgstr "C에서 러스트 호출"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "러스트에서 타입과 함수를 C로 내보내는 것은 간단합니다:"

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:8
msgid "//! Rust FFI demo.\n"
msgstr ""

#: src/android/interoperability/with-c/rust.md:12
msgid "/// Analyze the numbers.\n"
msgstr ""

#: src/android/interoperability/with-c/rust.md:17
msgid "\"x ({x}) is smallest!\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:19
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:41
#: src/android/interoperability/with-c/rust.md:68
msgid "\"libanalyze_ffi\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:42
msgid "\"analyze_ffi\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:43
msgid "\"analyze.rs\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "이제 이 러스트 함수를 C바이너리에서 호출할 수 있습니다:"

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:53
msgid "\"analyze.h\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:66
msgid "\"analyze_numbers\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:67
msgid "\"main.c\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:74
#, fuzzy
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/interoperability/with-c/rust.md:82
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]`은 러스트의 네임 맹글링(name mangling)을 비활성화하므로 외부로 "
"노출되는 심볼의 이름은 함수의 이름 그대로가 됩니다. 심볼 이름을 바꾸고 싶다"
"면 `#[export_name = \"some_name\"]`을 사용합니다."

#: src/android/interoperability/cpp.md:1
msgid "With C++"
msgstr "C++와의 상호운용성"

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX 크레이트](https://cxx.rs/)는 러스트와 C++ 사이의 안전한 상호운용성을 가"
"능하게 해줍니다."

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "전체적인 접근 방법은 다음과 같습니다:"

#: src/android/interoperability/cpp/bridge.md:3
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:9
msgid "\"org::blobstore\""
msgstr ""

#: src/android/interoperability/cpp/bridge.md:11
msgid "// Shared structs with fields visible to both languages.\n"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:17
#: src/android/interoperability/cpp/generated-cpp.md:6
msgid "// Rust types and signatures exposed to C++.\n"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:18
#: src/android/interoperability/cpp/rust-bridge.md:6
#: src/android/interoperability/cpp/generated-cpp.md:7
#: src/android/interoperability/cpp/rust-result.md:6
#: src/chromium/interoperability-with-cpp/example-bindings.md:9
#: src/chromium/interoperability-with-cpp/error-handling-qr.md:10
#: src/chromium/interoperability-with-cpp/error-handling-png.md:9
#, fuzzy
msgid "\"Rust\""
msgstr "Rustdoc"

#: src/android/interoperability/cpp/bridge.md:24
#: src/android/interoperability/cpp/cpp-bridge.md:6
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:25
#: src/android/interoperability/cpp/cpp-bridge.md:7
#: src/android/interoperability/cpp/cpp-exception.md:6
#: src/chromium/interoperability-with-cpp/example-bindings.md:15
msgid "\"C++\""
msgstr ""

#: src/android/interoperability/cpp/bridge.md:26
#: src/android/interoperability/cpp/cpp-bridge.md:8
msgid "\"include/blobstore.h\""
msgstr ""

#: src/android/interoperability/cpp/bridge.md:40
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:41
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:44
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:47
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:1
msgid "Rust Bridge Declarations"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:7
msgid "// Opaque type\n"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:8
msgid "// Method on `MyType`\n"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:9
#, fuzzy
msgid "// Free function\n"
msgstr "함수"

#: src/android/interoperability/cpp/rust-bridge.md:28
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:30
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""

#: src/android/interoperability/cpp/generated-cpp.md:15
msgid "Results in (roughly) the following C++:"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:1
msgid "C++ Bridge Declarations"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:20
msgid "Results in (roughly) the following Rust:"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:30
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:39
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:56
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:59
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:9
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:23
msgid "Only C-like (unit) enums are supported."
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:24
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""

#: src/android/interoperability/cpp/shared-enums.md:15
#, fuzzy
msgid "Generated Rust:"
msgstr "안전하지 않은 러스트"

#: src/android/interoperability/cpp/shared-enums.md:33
msgid "Generated C++:"
msgstr ""

#: src/android/interoperability/cpp/shared-enums.md:46
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:13
msgid "\"fallible1 requires depth > 0\""
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:16
msgid "\"Success!\""
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:22
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:24
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:27
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:7
msgid "\"example/include/example.h\""
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:14
msgid "\"Error: {}\""
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:22
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:24
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:3
#, fuzzy
msgid "Rust Type"
msgstr "Rust by Example"

#: src/android/interoperability/cpp/type-mapping.md:3
#, fuzzy
msgid "C++ Type"
msgstr "C++ 예제"

#: src/android/interoperability/cpp/type-mapping.md:5
#, fuzzy
msgid "`rust::String`"
msgstr "`rust_bindgen`"

#: src/android/interoperability/cpp/type-mapping.md:6
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md:6
#, fuzzy
msgid "`rust::Str`"
msgstr "`rust_test`"

#: src/android/interoperability/cpp/type-mapping.md:7
#, fuzzy
msgid "`CxxString`"
msgstr "String"

#: src/android/interoperability/cpp/type-mapping.md:7
msgid "`std::string`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:8
msgid "`&[T]`/`&mut [T]`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:8
#, fuzzy
msgid "`rust::Slice`"
msgstr "`rust_ffi`"

#: src/android/interoperability/cpp/type-mapping.md:9
msgid "`rust::Box<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:10
msgid "`UniquePtr<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:10
msgid "`std::unique_ptr<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:11
#, fuzzy
msgid "`Vec<T>`"
msgstr "`Vec`"

#: src/android/interoperability/cpp/type-mapping.md:11
#, fuzzy
msgid "`rust::Vec<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md:12
#, fuzzy
msgid "`CxxVector<T>`"
msgstr "`Cell<T>`"

#: src/android/interoperability/cpp/type-mapping.md:12
#, fuzzy
msgid "`std::vector<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md:16
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:18
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:20
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:21
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:23
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:1
#: src/android/interoperability/cpp/android-cpp-genrules.md:1
#: src/android/interoperability/cpp/android-build-rust.md:1
msgid "Building in Android"
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:3
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:8
#: src/android/interoperability/cpp/android-build-rust.md:10
msgid "\"libcxx_test_cpp\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:9
msgid "\"cxx_test.cpp\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:11
msgid "\"cxx-bridge-header\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:12
#: src/android/interoperability/cpp/android-cpp-genrules.md:10
msgid "\"libcxx_test_bridge_header\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:14
#: src/android/interoperability/cpp/android-cpp-genrules.md:19
msgid "\"libcxx_test_bridge_code\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:20
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:23
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:25
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:3
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:7
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:11
#: src/android/interoperability/cpp/android-cpp-genrules.md:20
msgid "\"cxxbridge\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:12
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:13
#: src/android/interoperability/cpp/android-cpp-genrules.md:22
#: src/android/interoperability/cpp/android-build-rust.md:8
msgid "\"lib.rs\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:14
msgid "\"lib.rs.h\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:16
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:21
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:23
msgid "\"lib.rs.cc\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:29
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:31
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:3
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:7
msgid "\"cxx_test\""
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:9
msgid "\"libcxx\""
msgstr ""

#: src/android/interoperability/java.md:1
msgid "Interoperability with Java"
msgstr "Java와의 상호운용성"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"자바는 [Java Native Interface(JNI)](https://en.wikipedia.org/wiki/"
"Java_Native_Interface)를 통해 공유 라이브러리를 로드할 수 있습니다. [`jni` 크"
"레이트](https://docs.rs/jni/)를 사용하여 JNI 라이브러리를 만들 수 있습니다."

#: src/android/interoperability/java.md:8
msgid "First, we create a Rust function to export to Java:"
msgstr "먼저, 자바로 내보낼 러스트 함수를 생성합니다:"

#: src/android/interoperability/java.md:10
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md:13
msgid "//! Rust <-> Java FFI demo.\n"
msgstr ""

#: src/android/interoperability/java.md:18
msgid "/// HelloWorld::hello method implementation.\n"
msgstr ""

#: src/android/interoperability/java.md:21
msgid "\"system\""
msgstr ""

#: src/android/interoperability/java.md:27
msgid "\"Hello, {input}!\""
msgstr ""

#: src/android/interoperability/java.md:33
#: src/android/interoperability/java.md:63
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md:37
#: src/android/interoperability/java.md:70
msgid "\"libhello_jni\""
msgstr ""

#: src/android/interoperability/java.md:38
#: src/android/interoperability/java.md:53
msgid "\"hello_jni\""
msgstr ""

#: src/android/interoperability/java.md:40
msgid "\"libjni\""
msgstr ""

#: src/android/interoperability/java.md:44
msgid "Finally, we can call this function from Java:"
msgstr "자바에서 이 함수를 호출 할 수 있습니다:"

#: src/android/interoperability/java.md:46
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:67
msgid "\"helloworld_jni\""
msgstr ""

#: src/android/interoperability/java.md:68
#, fuzzy
msgid "\"HelloWorld.java\""
msgstr "Hello World!"

#: src/android/interoperability/java.md:69
#, fuzzy
msgid "\"HelloWorld\""
msgstr "Hello World!"

#: src/android/interoperability/java.md:74
msgid "Finally, you can build, sync, and run the binary:"
msgstr "마지막으로 바이너리를 빌드, 싱크, 실행합니다:"

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"마지막 연습문제는 여러분이 작업하고 있는 프로젝트 중 하나를 FFI로 러스트와 연"
"계 해보는 것입니다. 몇 가지 예시입니다:"

#: src/exercises/android/morning.md:6
msgid "Call your AIDL service with a client written in Rust."
msgstr "당신의 AIDL서비스를 러스트 클라이언트에서 호출해봅니다."

#: src/exercises/android/morning.md:8
msgid "Move a function from your project to Rust and call it."
msgstr "당신의 프로젝트의 함수를 러스트로 옮기고 호출해봅니다."

#: src/exercises/android/morning.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"이 연습문제는 열려있기 때문에 해답이 제공되지 않습니다. 클래스에서 제출된 코"
"드에 의존합니다."

#: src/chromium.md:1
#, fuzzy
msgid "Welcome to Rust in Chromium"
msgstr "1일차 개요"

#: src/chromium.md:3
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""

#: src/chromium.md:6
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""

#: src/chromium/setup.md:3
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""

#: src/chromium/setup.md:13
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr ""

#: src/chromium/setup.md:16
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""

#: src/chromium/setup.md:21
msgid "It's also recommended that you have Visual Studio code installed."
msgstr ""

#: src/chromium/setup.md:23
msgid "About the exercises"
msgstr ""

#: src/chromium/setup.md:25
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""

#: src/chromium/cargo.md:3
msgid ""
"Rust community typically uses `cargo` and libraries from [crates.io](https://"
"crates.io/). Chromium is built using `gn` and `ninja` and a curated set of "
"dependencies."
msgstr ""

#: src/chromium/cargo.md:6
msgid "When writing code in Rust, your choices are:"
msgstr ""

#: src/chromium/cargo.md:8
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""

#: src/chromium/cargo.md:11
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""

#: src/chromium/cargo.md:13
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""

#: src/chromium/cargo.md:16
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""

#: src/chromium/cargo.md:20
#, fuzzy
msgid "Mini exercise"
msgstr "연습문제"

#: src/chromium/cargo.md:22
msgid "Split into small groups and:"
msgstr ""

#: src/chromium/cargo.md:24
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr ""

#: src/chromium/cargo.md:26
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""

#: src/chromium/cargo.md:31
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""

#: src/chromium/cargo.md:35
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr ""

#: src/chromium/cargo.md:38
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""

#: src/chromium/cargo.md:44
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""

#: src/chromium/cargo.md:46
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""

#: src/chromium/cargo.md:49
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""

#: src/chromium/cargo.md:56
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""

#: src/chromium/cargo.md:57
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr ""

#: src/chromium/cargo.md:59
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr ""

#: src/chromium/cargo.md:61
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""

#: src/chromium/cargo.md:66
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""

#: src/chromium/cargo.md:71
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr ""

#: src/chromium/cargo.md:72
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""

#: src/chromium/cargo.md:74
msgid "Fontations libraries like `font-types`"
msgstr ""

#: src/chromium/cargo.md:75
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""

#: src/chromium/cargo.md:77
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain.)"
msgstr ""

#: src/chromium/cargo.md:80
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, by `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""

#: src/chromium/cargo.md:84
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr ""

#: src/chromium/cargo.md:87
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""

#: src/chromium/cargo.md:90
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""

#: src/chromium/cargo.md:92
msgid "`cargo`, `rustfmt`, etc."
msgstr ""

#: src/chromium/cargo.md:93
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""

#: src/chromium/cargo.md:95
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr ""

#: src/chromium/cargo.md:96
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""

#: src/chromium/cargo.md:98
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr ""

#: src/chromium/policy.md:1
msgid "Chromium Rust policy"
msgstr ""

#: src/chromium/policy.md:3
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""

#: src/chromium/policy.md:7
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""

#: src/chromium/policy.md:12
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""

#: src/chromium/policy.md:15
#, fuzzy
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
"  스택                            힙\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/chromium/policy.md:30
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""

#: src/chromium/policy.md:33
msgid "Because of this, today's course will be heavily focused on:"
msgstr ""

#: src/chromium/policy.md:35
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr ""

#: src/chromium/policy.md:36
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr ""

#: src/chromium/policy.md:38
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr ""

#: src/chromium/build-rules.md:1
#, fuzzy
msgid "Build rules"
msgstr "빌드 규칙"

#: src/chromium/build-rules.md:3
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""

#: src/chromium/build-rules.md:7
msgid "Adding Rust code to Chromium"
msgstr ""

#: src/chromium/build-rules.md:9
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr ""

#: src/chromium/build-rules.md:11
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules.md:20
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""

#: src/chromium/build-rules.md:25
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""

#: src/chromium/build-rules.md:31
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""

#: src/chromium/build-rules.md:34
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""

#: src/chromium/build-rules/unsafe.md:1
msgid "Including `unsafe` Rust Code"
msgstr ""

#: src/chromium/build-rules/unsafe.md:3
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""

#: src/chromium/build-rules/unsafe.md:7
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules/depending.md:3
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr ""

#: src/chromium/build-rules/depending.md:5
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules/vscode.md:3
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""

#: src/chromium/build-rules/vscode.md:6
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""

#: src/chromium/build-rules/vscode.md:8
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr ""

#: src/chromium/build-rules/vscode.md:10
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr ""

#: src/chromium/build-rules/vscode.md:16
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""

#: src/chromium/build-rules/vscode.md:19
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""

#: src/chromium/build-rules/vscode.md:22
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr ""

#: src/chromium/build-rules/vscode.md:23
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""

#: src/chromium/build-rules/vscode.md:25
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""

#: src/chromium/build-rules/vscode.md:27
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""

#: src/chromium/build-rules/vscode.md:29
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""

#: src/chromium/build-rules/vscode.md:32
msgid ""
"Demo **type annotations** (there are quote a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""

#: src/chromium/build-rules/vscode.md:35
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""

#: src/exercises/chromium/build-rules.md:1
#, fuzzy
msgid "Build rules exercise"
msgstr "빌드 규칙"

#: src/exercises/chromium/build-rules.md:3
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""

#: src/exercises/chromium/build-rules.md:13
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to to allow unsafe code in your `gn` "
"target."
msgstr ""

#: src/exercises/chromium/build-rules.md:16
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""

#: src/exercises/chromium/build-rules.md:24
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""

#: src/exercises/chromium/build-rules.md:28
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""

#: src/exercises/chromium/build-rules.md:32
#: src/exercises/chromium/interoperability-with-cpp.md:48
msgid "Where to find help"
msgstr ""

#: src/exercises/chromium/build-rules.md:34
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""

#: src/exercises/chromium/build-rules.md:35
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""

#: src/exercises/chromium/build-rules.md:36
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""

#: src/exercises/chromium/build-rules.md:37
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""

#: src/exercises/chromium/build-rules.md:38
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""

#: src/exercises/chromium/build-rules.md:44
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""

#: src/exercises/chromium/build-rules.md:48
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""

#: src/exercises/chromium/build-rules.md:52
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""

#: src/chromium/testing.md:3
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""

#: src/chromium/testing.md:17
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""

#: src/chromium/testing.md:22
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr ""

#: src/chromium/testing.md:24
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""

#: src/chromium/testing.md:26
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""

#: src/chromium/testing.md:29
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""

#: src/chromium/testing.md:35
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""

#: src/chromium/testing.md:39
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""

#: src/chromium/testing.md:42
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""

#: src/chromium/testing.md:47
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:3
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:5
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:7
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:10
#, fuzzy
msgid "Example:"
msgstr "예제"

#: src/chromium/testing/build-gn.md:3
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""

#: src/chromium/testing/build-gn.md:6
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/build-gn.md:14
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""

#: src/chromium/testing/build-gn.md:17
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:3
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:12
msgid "\"//ui/base:my_rust_lib\""
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:18
msgid "Under the covers the macro expands to something similar to:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:26
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:31
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""

#: src/exercises/chromium/testing.md:1
#, fuzzy
msgid "Testing exercise"
msgstr "Rust on Exercism"

#: src/exercises/chromium/testing.md:3
msgid "Time for another exercise!"
msgstr ""

#: src/exercises/chromium/testing.md:5
msgid "In your Chromium build:"
msgstr ""

#: src/exercises/chromium/testing.md:7
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""

#: src/exercises/chromium/testing.md:10
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr ""

#: src/exercises/chromium/testing.md:11
msgid "Add the new tests to `BUILD.gn`."
msgstr ""

#: src/exercises/chromium/testing.md:12
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:3
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:6
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:12
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""
"사용하는 방법에 대해서는[CXX 튜토리얼](https://cxx.rs/tutorial.html) 를 참조"
"합니다."

#: src/chromium/interoperability-with-cpp.md:19
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:23
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:27
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:31
msgid "The tool and the library can handle a set of core types - for example:"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:32
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:37
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:41
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:3
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:16
msgid "\"example/include/blobstore.h\""
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:24
msgid "// Definitions of Rust types and functions go here\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:30
msgid "Point out:"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:32
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:36
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:37
#, fuzzy
msgid "Native support for Rust slices in C++"
msgstr "내장 테스트 지원."

#: src/chromium/interoperability-with-cpp/example-bindings.md:38
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:39
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:41
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:3
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:5
msgid "CXX fundamentally suits cases where:"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:7
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:8
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:11
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:14
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:26
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:28
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:29
msgid "Function pointers are awkward to use."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:3
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:6
msgid "The `T` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:7
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:9
msgid "A primitive type (like `u32` or `usize`)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:10
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:12
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:16
msgid "The `E` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:17
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:19
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:1
#, fuzzy
msgid "CXX Error Handling: QR Example"
msgstr "오류처리"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:3
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:8
msgid "\"qr_code_generator\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:23
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:27
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:32
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data can’t be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:1
#, fuzzy
msgid "CXX Error Handling: PNG Example"
msgstr "오류처리"

#: src/chromium/interoperability-with-cpp/error-handling-png.md:3
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:7
msgid "\"gfx::rust_bindings\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:10
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:14
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:21
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:32
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:37
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:1
msgid "Using cxx in Chromium"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:3
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:7
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:13
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:16
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:19
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:22
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:27
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:29
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:36
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:1
#, fuzzy
msgid "Exercise: Interoperability with C++"
msgstr "C와의 상호운용성"

#: src/exercises/chromium/interoperability-with-cpp.md:3
msgid "Part one"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:5
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:8
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:10
msgid "Modify your `gn` target to build these bindings."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:11
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:13
msgid "Build and run!"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:15
msgid "Part two"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:17
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:20
#, fuzzy
msgid "Some things to try:"
msgstr "참고사항:"

#: src/exercises/chromium/interoperability-with-cpp.md:22
msgid "Call back into C++ from Rust. You will need:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:23
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:25
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:27
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:29
msgid "Pass a C++ string from C++ into Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:30
msgid "Pass a reference to a C++ object into Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:31
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:33
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:35
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:37
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:39
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:40
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:42
msgid "Part three"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:44
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:50
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:51
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:57
msgid "Some of the questions you may encounter:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:59
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:62
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""

#: src/chromium/adding-third-party-crates.md:3
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""

#: src/chromium/adding-third-party-crates.md:6
#, fuzzy
msgid "C++ library"
msgstr "라이브러리"

#: src/chromium/adding-third-party-crates.md:6
#, fuzzy
msgid "Rust crate"
msgstr "러스트 생태계"

#: src/chromium/adding-third-party-crates.md:8
#, fuzzy
msgid "Build system"
msgstr "러스트 생태계"

#: src/chromium/adding-third-party-crates.md:8
#: src/chromium/adding-third-party-crates.md:10
msgid "Lots"
msgstr ""

#: src/chromium/adding-third-party-crates.md:8
msgid "Consistent: `Cargo.toml`"
msgstr ""

#: src/chromium/adding-third-party-crates.md:9
msgid "Typical library size"
msgstr ""

#: src/chromium/adding-third-party-crates.md:9
msgid "Large-ish"
msgstr ""

#: src/chromium/adding-third-party-crates.md:9
msgid "Small"
msgstr ""

#: src/chromium/adding-third-party-crates.md:10
msgid "Transitive dependencies"
msgstr ""

#: src/chromium/adding-third-party-crates.md:10
msgid "Few"
msgstr ""

#: src/chromium/adding-third-party-crates.md:12
msgid "For a Chromium engineer, this has pros and cons:"
msgstr ""

#: src/chromium/adding-third-party-crates.md:14
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""

#: src/chromium/adding-third-party-crates.md:16
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr ""

#: src/chromium/adding-third-party-crates.md:19
msgid "We'll discuss:"
msgstr ""

#: src/chromium/adding-third-party-crates.md:21
msgid "How to put a crate in the Chromium source code tree"
msgstr ""

#: src/chromium/adding-third-party-crates.md:22
msgid "How to make `gn` build rules for it"
msgstr ""

#: src/chromium/adding-third-party-crates.md:23
msgid "How to audit its source code for sufficient safety."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:1
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:3
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:6
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:14
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:18
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:3
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:6
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:15
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:15
msgid "For instance,"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:22
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:25
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:3
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:6
msgid "To start, download the crate you want like this:"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:13
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:17
msgid "This `vendor` command may download:"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:19
#, fuzzy
msgid "Your crate"
msgstr "유용한 크레이트"

#: src/chromium/adding-third-party-crates/downloading-crates.md:20
msgid "Direct and transitive dependencies"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:21
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:24
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:3
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:9
msgid "Now run `git status`. You should find:"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:11
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:13
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:15
msgid "An appropriate `README.chromium`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:17
#, fuzzy
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"자세한 사항은 [공식문서](https://doc.rust-lang.org/reference/type-layout."
"html)를 확인하세요."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:19
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:23
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:3
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:8
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:10
msgid "build script effect"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:10
msgid "Supported by our gn templates"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:10
msgid "Work required by you"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:12
msgid "Checking rustc version to configure features on and off"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:12
#: src/chromium/adding-third-party-crates/resolving-problems.md:13
msgid "None"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:13
msgid "Checking platform or CPU to configure features on and off"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:14
#, fuzzy
msgid "Generating code"
msgstr "제네릭"

#: src/chromium/adding-third-party-crates/resolving-problems.md:14
msgid "Yes - specify in `gnrt_config.toml`"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:15
msgid "Building C/C++"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:15
#: src/chromium/adding-third-party-crates/resolving-problems.md:16
msgid "Patch around it"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:16
msgid "Arbitrary other actions"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:18
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:3
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:6
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:11
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:17
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:3
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:8
msgid "So, your options are:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:10
msgid "Avoid these crates"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:11
msgid "Apply a patch to the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:13
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:3
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:7
#, fuzzy
msgid "Specifically,"
msgstr "OS가 정의함"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:9
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:17
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:1
msgid "Auditing Third Party Crates"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:3
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:9
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:11
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:13
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:17
msgid "Check each crate seems to be reasonably well maintained"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:18
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:21
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:22
msgid "Check for any use of `fs` or `net` APIs"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:23
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:27
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:1
msgid "Checking Crates into Chromium Source Code"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:3
msgid "`git status` should reveal:"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:5
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:6
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:9
msgid "Please also add an `OWNERS` file in the latter location."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:11
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:14
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:17
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md:3
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""

#: src/exercises/chromium/third-party.md:3
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""

#: src/exercises/chromium/third-party.md:7
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""

#: src/exercises/chromium/third-party.md:13
msgid "Students will need to download lots of transitive dependencies."
msgstr ""

#: src/exercises/chromium/third-party.md:15
msgid "The total crates needed are:"
msgstr ""

#: src/exercises/chromium/third-party.md:17
#, fuzzy
msgid "`instant`,"
msgstr "상수(constant)"

#: src/exercises/chromium/third-party.md:18
msgid "`lock_api`,"
msgstr ""

#: src/exercises/chromium/third-party.md:19
msgid "`parking_lot`,"
msgstr ""

#: src/exercises/chromium/third-party.md:20
msgid "`parking_lot_core`,"
msgstr ""

#: src/exercises/chromium/third-party.md:21
msgid "`redox_syscall`,"
msgstr ""

#: src/exercises/chromium/third-party.md:22
msgid "`scopeguard`,"
msgstr ""

#: src/exercises/chromium/third-party.md:23
msgid "`smallvec`, and"
msgstr ""

#: src/exercises/chromium/third-party.md:24
msgid "`uwuify`."
msgstr ""

#: src/exercises/chromium/third-party.md:26
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""

#: src/exercises/chromium/third-party.md:29
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:1
msgid "Bringing It Together --- Exercise"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:3
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:6
msgid "The Brief from Product Management"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:8
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:11
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:13
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:17
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:19
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:22
msgid "Steps"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:24
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:28
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:36
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:39
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:42
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:49
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:52
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""

#: src/exercises/chromium/solutions.md:3
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""

#: src/bare-metal.md:1
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "Welcome to Comprehensive Rust 🦀"

#: src/bare-metal.md:3
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"이 과정은 Rust에 대해 어느정도 경험이 있고 (아마도 Comprehensive Rust 과정을 "
"통해) C와 같은 다른 언어로 bare-metal 프로그래밍을 해 본 사용자를 대상으로 하"
"는 bare-metal Rust에 관한 독립적인 1일 과정입니다."

#: src/bare-metal.md:8
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"오늘은 OS를 사용하지 않고 Rust 코드를 실행하는 'bare-metal' Rust에 관해 알아"
"봅니다. 본 강의의 구성은 다음과 같습니다."

#: src/bare-metal.md:11
msgid "What is `no_std` Rust?"
msgstr "`no_std` Rust란 무엇인가요?"

#: src/bare-metal.md:12
msgid "Writing firmware for microcontrollers."
msgstr "마이크로컨트롤러용 펌웨어 작성"

#: src/bare-metal.md:13
msgid "Writing bootloader / kernel code for application processors."
msgstr "애플리케이션 프로세서를 위한 부트로더 / 커널 코드 작성"

#: src/bare-metal.md:14
msgid "Some useful crates for bare-metal Rust development."
msgstr "bare-metal Rust 개발을 위한 유용한 크레이트"

#: src/bare-metal.md:16
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"이 강의에서는 [BBC micro:bit](https://microbit.org/) v2마이크로컨트롤러를 사"
"용합니다. 이 마이크로컨트롤러는 Nordic nRF51822 마이크로컨트롤러에 기반한 [개"
"발 보드](https://tech.microbit.org/hardware/)로써, LED와 버튼, I2C 연결 가속"
"도계 및 나침반, 온보드 SWD 디버거를 포함하고 있습니다."

#: src/bare-metal.md:22
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"시작하기전에, 앞으로 사용할 도구를 설치해야 합니다. gLinux 또는 Debian를 사용"
"하고 있다면 아래와 같이 하세요."

#: src/bare-metal.md:34
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"`plugdev` 그룹의 사용자에게 micro:bit 프로그래머 장치에 대한 액세스 권한을 부"
"여합니다."

#: src/bare-metal.md:44 src/bare-metal/microcontrollers/debugging.md:33
msgid "On MacOS:"
msgstr "MacOS에서:"

#: src/bare-metal/no_std.md:7
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md:17
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md:24
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md:25
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md:26
msgid "`Option`, `Result`"
msgstr "`Option`, `Result`"

#: src/bare-metal/no_std.md:27
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md:29
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md:30
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` 및 모든 일반적인 포인터 관련 함수"

#: src/bare-metal/no_std.md:31
msgid "`Future` and `async`/`await`"
msgstr "`Future` and `async`/`await`"

#: src/bare-metal/no_std.md:32
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md:33
msgid "`Duration`"
msgstr "`Duration`"

#: src/bare-metal/no_std.md:38
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md:39
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md:40
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md:45
msgid "`Error`"
msgstr "`Error`"

#: src/bare-metal/no_std.md:47
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md:48
msgid "`File` and the rest of `fs`"
msgstr "`File` 및 나머지 `fs`"

#: src/bare-metal/no_std.md:49
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`, `Read`, `Write`, `Stdin`, `Stdout` 및 나머지 `io`"

#: src/bare-metal/no_std.md:50
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md:51
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md:52
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md:53
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`, `sleep` 및 나머지 `thread`"

#: src/bare-metal/no_std.md:54
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md:62
msgid "`HashMap` depends on RNG."
msgstr "`HashMap`은 RNG에 의존합니다."

#: src/bare-metal/no_std.md:63
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std`는 `core` 및 `alloc`를 포함합니다."

#: src/bare-metal/minimal.md:1
msgid "A minimal `no_std` program"
msgstr "최소한의 `no_std` 프로그램"

#: src/bare-metal/minimal.md:19
msgid "This will compile to an empty binary."
msgstr "이 코드는 빈 바이너리로 컴파일됩니다."

#: src/bare-metal/minimal.md:20
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"`std`는 패닉 핸들러를 제공하지만, 우리는 자체적으로 핸들러를 만들어야합니다."

#: src/bare-metal/minimal.md:21
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "패닉 핸들러는 `panic-halt`와 같은 크레이트를 통해서 만들수도 있습니다."

#: src/bare-metal/minimal.md:22
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"타겟에 따라 `panic = \"abort\"`로 컴파일해야 할 수 있습니다. 이는 "
"`eh_personality`에 관한 오류를 방지하기 위함입니다."

#: src/bare-metal/minimal.md:24
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"`main` 과 같은 프로그램 진입점이 없습니다. 개발자가 자체적으로 진입점을 정의"
"해야 합니다. 진입점을 정의하는 작업은, 일반적으로 링커 스크립트와 어셈블리 코"
"드를 필요로 합니다."

#: src/bare-metal/alloc.md:3
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"`alloc`을 사용하려면 [전역 (힙) 할당자](https://doc.rust-lang.org/stable/std/"
"alloc/trait.GlobalAlloc.html)를 구현해야 합니다."

#: src/bare-metal/alloc.md:23
msgid ""
"// Safe because `HEAP` is only used here and `entry` is only called once.\n"
msgstr ""

#: src/bare-metal/alloc.md:25
msgid "// Give the allocator some memory to allocate.\n"
msgstr ""

#: src/bare-metal/alloc.md:29
msgid "// Now we can do things that require heap allocation.\n"
msgstr ""

#: src/bare-metal/alloc.md:31
#, fuzzy
msgid "\"A string\""
msgstr "String"

#: src/bare-metal/alloc.md:37
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator`는 간단한 버디 시스템 할당자를 구현하는 서드 파티 크"
"레이트입니다. 이 외에도, 다른 크레이트를 사용하거나, 직접 할당자를 만들거나, "
"이미 존재하는 다른 할당자에 후킹할 수 있습니다."

#: src/bare-metal/alloc.md:40
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"`LockHeap` 타입의 const 매개변수는 할당자의 최대 크기를 2진수로 표현했을 때"
"의 자릿수입니다. 즉, 이 경우처럼 32인 경우 최대 2\\*\\*32바이트 크기의 영역"
"을 다룰 수 있습니다."

#: src/bare-metal/alloc.md:42
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"한 바이너리에서 `alloc`에 의존하는 크레이트가 하나라도 있다면 바이너리 전체에"
"서 전역 할당자가 반드시 하나 존재해야 합니다. 일반적으로 전역 할당자를 선언하"
"는 작업은 최상위 바이너리 크레이트에서 이루어집니다."

#: src/bare-metal/alloc.md:45
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`panic_halt` 크레이트가 연결되어 패닉 핸들러를 가져오도록 하려면 `extern "
"crate panic_halt as _`가 필요합니다."

#: src/bare-metal/alloc.md:47
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"이 예시 코드는 빌드는 되지만, 진입점이 없기 때문에 실행되지는 않습니다."

#: src/bare-metal/microcontrollers.md:3
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"'cortex_m_rt' 크레이트는 Cortex M 마이크로컨트롤러를 초기화 하는 핸들러를 제"
"공합니다."

#: src/bare-metal/microcontrollers.md:24
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"이제, 주변장치에 액세스하는 방법을 알아보겠습니다. 가장 기계에 가까운 낮은 단"
"계에서 시작해서 점점 추상화 수준을 올리겠습니다."

#: src/bare-metal/microcontrollers.md:29
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"`cortex_m_rt::entry` 매크로는 진입점으로 사용되는 함수가`fn() -> !` 타입(즉, "
"리턴하지 않는)임을 요구합니다. 만약, 리턴하게 되면, 프로그램 수행 후 리셋 핸"
"들러로 돌아가게 되는 것인데 이는 말이 되지 않기 때문입니다."

#: src/bare-metal/microcontrollers.md:31
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "`cargo embed --bin minimal`을 사용하여 예시를 실행합니다."

#: src/bare-metal/microcontrollers/mmio.md:3
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"대부분의 마이크로컨트롤러는 메모리 매핑 IO를 통해 주변기기에 액세스합니다. "
"micro:bit에서 LED를 켜보겠습니다."

#: src/bare-metal/microcontrollers/mmio.md:16
msgid "/// GPIO port 0 peripheral address\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:19
msgid "// GPIO peripheral offsets\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:24
msgid "// PIN_CNF fields\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:34
#: src/bare-metal/microcontrollers/pacs.md:21
#: src/bare-metal/microcontrollers/hals.md:26
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:37
#: src/bare-metal/microcontrollers/mmio.md:59
msgid ""
"// Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:56
#: src/bare-metal/microcontrollers/pacs.md:39
#: src/bare-metal/microcontrollers/hals.md:30
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:72
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"GPIO 0 핀 21은 LED 매트릭스의 첫 번째 열에 연결되고 핀 28은 첫 번째 행에 연결"
"됩니다."

#: src/bare-metal/microcontrollers/mmio.md:75
#: src/bare-metal/microcontrollers/pacs.md:61
#: src/bare-metal/microcontrollers/hals.md:44
#: src/bare-metal/microcontrollers/board-support.md:37
msgid "Run the example with:"
msgstr "아래 명령어로 예제 코드를 실행하세요."

#: src/bare-metal/microcontrollers/pacs.md:1
msgid "Peripheral Access Crates"
msgstr "주변기기 액세스 크레이트"

#: src/bare-metal/microcontrollers/pacs.md:3
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) 크레이트를 이용하면 메모리 매"
"핑된 주변장치를 기술하는 [CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html) 파일로부터 Rust 래퍼를 생성할 수 있습니다."

#: src/bare-metal/microcontrollers/pacs.md:49
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"SVD(System View Description) 파일은 일반적으로 실리콘 공급업체에서 제공하는 "
"XML 파일로, 기기의 메모리 맵을 기술합니다."

#: src/bare-metal/microcontrollers/pacs.md:51
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"주변기기, 레지스터, 필드, 값으로 구성되며 이름, 설명, 주소 등이 포함됩니다."

#: src/bare-metal/microcontrollers/pacs.md:53
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"SVD 파일에는 버그가 있을 수 있고 불완전하기 때문에, 이러한 문제들을 패치하는 "
"다양한 프로젝트들이 있습니다."

#: src/bare-metal/microcontrollers/pacs.md:56
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt`는 무엇보다도 벡터 테이블을 제공합니다."

#: src/bare-metal/microcontrollers/pacs.md:57
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"`cargo install cargo-binutils`을 실행한 후, `cargo objdump --bin pac -- -d --"
"no-show-raw-insn`을 실행하여 생성된 바이너리의 내용을 확인할 수 있습니다."

#: src/bare-metal/microcontrollers/hals.md:1
msgid "HAL crates"
msgstr "HAL 크레이트들"

#: src/bare-metal/microcontrollers/hals.md:3
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"다양한 주변 장치에 대한 래퍼를 제공하는 [HAL 크레이트](https://github.com/"
"rust-embedded/awesome-embedded-rust#hal-implementation-crates)들이 있습니다. "
"이 크레이트들은 일반적으로 [`embedded-hal`](https://crates.io/crates/"
"embedded-hal)의 트레잇을 구현합니다."

#: src/bare-metal/microcontrollers/hals.md:23
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:40
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low` 및 `set_high`는 `embedded_hal` `OutputPin` 트레잇의 메서드입니다."

#: src/bare-metal/microcontrollers/hals.md:41
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"다양한 STM32, GD32, nRF, NXP, MSP430, AVR, PIC 마이크로컨트롤러를 비롯한 많"
"은 Cortex-M 및 RISC-V 기기를 위한 HAL 크레이트가 있습니다"

#: src/bare-metal/microcontrollers/board-support.md:1
#, fuzzy
msgid "Board support crates"
msgstr "보드 지원 크레이트"

#: src/bare-metal/microcontrollers/board-support.md:3
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"보드 지원 크레이트들은, 특정 보드를 더 손쉽게 사용할 수 있게 해 주는 더 높은 "
"수준의 추상화를 제공합니다."

#: src/bare-metal/microcontrollers/board-support.md:31
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"이 경우 보드 지원 크레이트는 좀 더 직관적인 이름들과 적당한 수준의 초기화를 "
"제공합니다."

#: src/bare-metal/microcontrollers/board-support.md:33
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"이 크레이트는 마이크로컨트롤 밖에 있는 (즉, 보드에 설치된) 장치에 대한 드라이"
"버도 포함할 수 있습니다."

#: src/bare-metal/microcontrollers/board-support.md:35
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr ""
"`microbit-v2`에는 LED 매트릭스를 위한 간단한 드라이버가 포함되어 있습니다."

#: src/bare-metal/microcontrollers/type-state.md:1
msgid "The type state pattern"
msgstr "타입 상태 패턴"

#: src/bare-metal/microcontrollers/type-state.md:11
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:19
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:33
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"핀은 `Copy` 또는 `Clone`을 구현하지 않으므로 각각 하나의 인스턴스만 존재할 "
"수 있습니다. 핀을 포트 구조체 밖으로 이동하면 아무도 사용할 수 없습니다."

#: src/bare-metal/microcontrollers/type-state.md:35
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can’t keep use the old instance afterwards."
msgstr ""
"핀 구성을 변경하면 이전 핀 인스턴스가 사용되므로 이후에 이전 인스턴스를 계속 "
"사용할 수 없습니다."

#: src/bare-metal/microcontrollers/type-state.md:37
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"값 유형은 현재 상태를 나타냅니다. 예를 들어 이 경우에는 GPIO 핀의 구성 상태입"
"니다. 이렇게 하면 상태 머신이 유형 시스템으로 인코딩되며, 먼저 올바르게 구성"
"한 후 특정 방식으로 핀을 사용하도록 합니다. 잘못된 상태 전환은 컴파일 시간에 "
"포착됩니다."

#: src/bare-metal/microcontrollers/type-state.md:42
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"입력 핀에서 `is_high`를 호출하고 출력 핀에서 `set_high`를 호출할 수 있지만 "
"그 반대로는 안 됩니다."

#: src/bare-metal/microcontrollers/type-state.md:44
msgid "Many HAL crates follow this pattern."
msgstr "많은 HAL 크레이트들이 이 패턴을 따릅니다."

#: src/bare-metal/microcontrollers/embedded-hal.md:3
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""
"[`embedded-hal`](https://crates.io/crates/embedded-hal) 크레이트는 다양한 마"
"이크로컨트롤러에서 공통적으로 찾아볼 수 있는 주변기기를 추상회 하는 다양한 트"
"레잇을 제공합니다."

#: src/bare-metal/microcontrollers/embedded-hal.md:6
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md:7
msgid "ADC"
msgstr "ADC"

#: src/bare-metal/microcontrollers/embedded-hal.md:8
msgid "I2C, SPI, UART, CAN"
msgstr "I2C, SPI, UART, CAN"

#: src/bare-metal/microcontrollers/embedded-hal.md:9
msgid "RNG"
msgstr "RNG"

#: src/bare-metal/microcontrollers/embedded-hal.md:10
msgid "Timers"
msgstr "타이머"

#: src/bare-metal/microcontrollers/embedded-hal.md:11
msgid "Watchdogs"
msgstr "워치독"

#: src/bare-metal/microcontrollers/embedded-hal.md:13
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"그러면 다른 크레이트는 이 트레잇들을 활용하여 [드라이버](https://github.com/"
"rust-embedded/awesome-embedded-rust#driver-crates)를 구현합니다. 예를 들어 가"
"속도계 드라이버를 구현할 떄 I2C 또는 SPI 버스 구현을 사용할 수 있습니다."

#: src/bare-metal/microcontrollers/embedded-hal.md:20
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"라스베리 파이에서 돌아가는 리눅스 같은 플랫폼 뿐만 아니라 다른 여러 마이크로"
"컨트롤러에 대한 구현이 있습니다."

#: src/bare-metal/microcontrollers/embedded-hal.md:22
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""
"`embedded-hal`의 'async' 버전에 관한 작업이 진행 중이지만 아직 안정적이지 않"
"습니다."

#: src/bare-metal/microcontrollers/probe-rs.md:3
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/)는 임베디드 시스템을 위한 도구 모임입니다. "
"OpenOCD와 비슷하지만, Rust에 더 잘 통합되어 있습니다."

#: src/bare-metal/microcontrollers/probe-rs.md:6
#, fuzzy
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr " 및 JTAG(CMSIS-DAP, ST-Link, J-Link 프로브를 통함)"

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:8
msgid "Cargo integration"
msgstr "Cargo에 통합됨"

#: src/bare-metal/microcontrollers/probe-rs.md:10
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
" 출력을 기록하고, GDB를 연결해 줍니다. 이 명령어의 세부 동작은 프로젝트 디렉"
"터리의 `Embed.toml` 파일을 통해 설정합니다."

#: src/bare-metal/microcontrollers/probe-rs.md:16
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html)는 Arm"
"에서 정의한 프로토콜로, USB를 통해 Arm Cortex 프로세서의 CoreSight 디버그 액"
"세스 포트에 접근할 수 있게 해 줍니다. BBC micro:bit에 있는 온보드 디버거도 "
"이  프로토콜을 지원합니다."

#: src/bare-metal/microcontrollers/probe-rs.md:20
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-Link는 ST Microelectronics사에서 만든 in-circuit 디버거들이며, J-Link는 "
"SEGGER사의 in-circuit 디버거들입니다."

#: src/bare-metal/microcontrollers/probe-rs.md:22
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"디버그 액세스 포트의 물리적인 구성은 일반적으로 5핀 JTAG 인터페이스 혹은, 2"
"핀 Serial Wire Debug 인터페이스 입니다."

#: src/bare-metal/microcontrollers/probe-rs.md:24
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rs는 라이브러리로 구현되어 있어서, 다른 도구들에 통합되기가 쉽습니다."

#: src/bare-metal/microcontrollers/probe-rs.md:26
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[Microsoft 디버그 어댑터 프로토콜](https://microsoft.github.io/debug-adapter-"
"protocol/)을 사용하면 VSCode나 다른 IDE 상에서 마이크로컨트롤러에서 수행중인 "
"코드를 디버깅 할 수 있습니다."

#: src/bare-metal/microcontrollers/probe-rs.md:30
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embed는 probe-rs 라이브러리를 사용하여 빌드된 바이너리입니다."

#: src/bare-metal/microcontrollers/probe-rs.md:31
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT(Real Time Transfers)는 여러 링 버퍼를 통해 디버그 호스트와 타겟 간에 데이"
"터를 전송하는 메커니즘입니다."

#: src/bare-metal/microcontrollers/debugging.md:3
#, fuzzy
msgid "_Embed.toml_:"
msgstr "Embed.toml:"

#: src/bare-metal/microcontrollers/debugging.md:15
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "`src/bare-metal/microcontrollers/examples/` 아래 하나의 터미널에서:"

#: src/bare-metal/microcontrollers/debugging.md:23
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "다른 터미널을 띄워서 서비스가 잘 수행되고 있는지 확인합니다:"

#: src/bare-metal/microcontrollers/debugging.md:25
msgid "On gLinux or Debian:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:43
msgid "In GDB, try running:"
msgstr "GDB에서 다음을 실행해 보세요."

#: src/bare-metal/microcontrollers/other-projects.md:1
#: src/bare-metal/aps/other-projects.md:1
msgid "Other projects"
msgstr "다른 프로젝트"

#: src/bare-metal/microcontrollers/other-projects.md:3
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md:4
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr ""
"\"실시간 인터럽트 기반 동시 실행(Real-Time Interrupt-driven Concurrency)\""

#: src/bare-metal/microcontrollers/other-projects.md:5
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr "공유 리소스 관리, 메시지 전달, 태스크 스케줄링, 타이머 대기열 지원"

#: src/bare-metal/microcontrollers/other-projects.md:6
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Embassy](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md:7
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "우선순위, 타이머, 네트워킹, USB가 포함된 `async` 실행자"

#: src/bare-metal/microcontrollers/other-projects.md:8
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md:9
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr "선점형 스케줄링 및 MMU를 지원하는, 보안에 중점을 둔 실시간 운영체제"

#: src/bare-metal/microcontrollers/other-projects.md:11
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md:12
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Oxide Computer Company에서 만든 마이크로커널 기반 실시간 운영체제로, 메모리 "
"보호,  권한이 없이 수행되는 드라이버 등을 지원함."

#: src/bare-metal/microcontrollers/other-projects.md:14
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[FreeRTOS용 바인딩](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md:15
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"`std`가 구현된 플랫폼도 있습니다(예: [esp-idf](https://esp-rs.github.io/book/"
"overview/using-the-standard-library.html))."

#: src/bare-metal/microcontrollers/other-projects.md:20
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr ""
"RTIC는 실시간 운영체제로 볼 수도 있고, 동시성 지원을 위한 프레임워크로 볼 수"
"도 있습니다."

#: src/bare-metal/microcontrollers/other-projects.md:21
msgid "It doesn't include any HALs."
msgstr "HAL을 포함하지는 않습니다."

#: src/bare-metal/microcontrollers/other-projects.md:22
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"스케줄링은 커널이 아니라 Cortex-M NVIC(Nested Virtual Interrupt Controller)"
"로 구현이 됩니다."

#: src/bare-metal/microcontrollers/other-projects.md:24
msgid "Cortex-M only."
msgstr "Cortex-M 전용입니다."

#: src/bare-metal/microcontrollers/other-projects.md:25
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"Google에서는 Titan 보안 키에 사용되는 Haven 마이크로컨트롤러에서 TockOS를 사"
"용합니다."

#: src/bare-metal/microcontrollers/other-projects.md:26
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOS는 대부분 C로 작성되지만, 애플리케이션을 Rust로 작성할 수 있도록 해 "
"주는 Rust 바인딩이 제공됩니다."

#: src/exercises/bare-metal/morning.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""

#: src/exercises/bare-metal/morning.md:8
#: src/exercises/concurrency/morning.md:12
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"연습문제를 살펴 본 후, 제공된 [해답](solutions-afternoon.md)을 살펴볼 수 있습"
"니다."

#: src/exercises/bare-metal/compass.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""

#: src/exercises/bare-metal/compass.md:7
msgid "Hints:"
msgstr ""

#: src/exercises/bare-metal/compass.md:9
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""

#: src/exercises/bare-metal/compass.md:13
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""

#: src/exercises/bare-metal/compass.md:14
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""

#: src/exercises/bare-metal/compass.md:15
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""

#: src/exercises/bare-metal/compass.md:19
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""

#: src/exercises/bare-metal/compass.md:22
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""

#: src/exercises/bare-metal/compass.md:26
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/compass.md:29 src/exercises/bare-metal/rtc.md:22
#, fuzzy
msgid "_src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/compass.md:47
#: src/exercises/bare-metal/solutions-morning.md:32
msgid "// Configure serial port.\n"
msgstr ""

#: src/exercises/bare-metal/compass.md:55
msgid ""
"// Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
msgstr ""

#: src/exercises/bare-metal/compass.md:58
#: src/exercises/bare-metal/solutions-morning.md:56
msgid "\"Ready.\""
msgstr ""

#: src/exercises/bare-metal/compass.md:61
msgid ""
"// Read compass data and log it to the serial port.\n"
"        // TODO\n"
msgstr ""

#: src/exercises/bare-metal/compass.md:67 src/exercises/bare-metal/rtc.md:387
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:89
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:105 src/exercises/bare-metal/rtc.md:988
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
msgid "See the serial output on Linux with:"
msgstr ""

#: src/exercises/bare-metal/compass.md:126
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""

#: src/exercises/bare-metal/compass.md:134
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "Bare Metal Rust Morning Exercise"
msgstr "Bare Metal Rust 오전 연습"

#: src/exercises/bare-metal/solutions-morning.md:5
msgid "([back to exercise](compass.md))"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:40
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:41
msgid "\"Setting up IMU...\""
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:49
msgid "// Set up display and timer.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:59
msgid "// Read compass data and log it to the serial port.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:67
msgid "\"{},{},{}\\t{},{},{}\""
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:105
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""

#: src/bare-metal/aps.md:1
msgid "Application processors"
msgstr "애플리케이션 프로세서"

#: src/bare-metal/aps.md:3
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"지금까지 Arm Cortex-M 시리즈와 같은 마이크로컨트롤러에 관해 알아봤습니다. 이"
"제 애플리케이션 프로세서인 Cortex-A를 위한 코드를 작성해 보겠습니다. 편의상 "
"QEMU의 aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt."
"html) 보드를 사용합니다."

#: src/bare-metal/aps.md:10
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"일반적으로 마이크로컨트롤러에는 MMU 또는 다중 레벨 권한(Arm CPU에서는 익셉션 "
"레벨(exception level), x86에서는 링(ring))이 없습니다. 애플리케이션 프로세서"
"는 이들을 가지고 있습니다."

#: src/bare-metal/aps.md:13
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU는 아키텍처별로 다양한 머신 또는 보드 모델을 에뮬레이션할 수 있습니다. "
"'virt' 보드는 특정 실제 하드웨어를 에뮬레이션 하지 않으며, 가상 머신용으로만 "
"설계되었습니다."

#: src/bare-metal/aps/entry-point.md:3
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""

#: src/bare-metal/aps/entry-point.md:5
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md:77
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""

#: src/bare-metal/aps/entry-point.md:79
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""

#: src/bare-metal/aps/entry-point.md:84
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""

#: src/bare-metal/aps/entry-point.md:86
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""

#: src/bare-metal/aps/entry-point.md:88
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""

#: src/bare-metal/aps/entry-point.md:92
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""

#: src/bare-metal/aps/entry-point.md:99
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""

#: src/bare-metal/aps/entry-point.md:103
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""

#: src/bare-metal/aps/entry-point.md:105
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:1
msgid "Inline assembly"
msgstr "인라인 어셈블리"

#: src/bare-metal/aps/inline-assembly.md:3
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"가끔 Rust 코드로는 구현이 불가능한 작업들이 있으며, 이 경우 어셈블리를 사용해"
"야 합니다. 예를 들어 펌웨어를 향해서 시스템 전원을 끄라고 "

#: src/bare-metal/aps/inline-assembly.md:20
msgid ""
"// Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:23
msgid "\"hvc #0\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:24
msgid "\"w0\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:25
msgid "\"w1\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:26
msgid "\"w2\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:27
msgid "\"w3\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:28
msgid "\"w4\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:29
msgid "\"w5\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:30
msgid "\"w6\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:31
msgid "\"w7\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:40
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"실제로 이를 실행하려면 이러한 모든 함수를 위한 래퍼가 포함된 [`smccc`]"
"(https://crates.io/crates/smccc) 크레이트를 사용하세요."

#: src/bare-metal/aps/inline-assembly.md:45
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI (Power State Coordination Interface)는 시스템 및 CPU 전원 상태를 관리하"
"는 Arm의 표준 인터페이스입니다. 이 인터페이스는 EL3 펌웨어와 하이퍼바이저에 "
"의해 구현됩니다."

#: src/bare-metal/aps/inline-assembly.md:48
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"`0 => _` 문법은 인라인 어셈블리 코드를 실행하기 전에 레지스터를 0으로 초기화"
"하고 그 후에는 그 레지스터의 값을 무시함을 의미합니다. 호출 시 레지스터의 값"
"이 덮어 써질 수 있으므로 `in` 대신 `inout`을 사용해야 합니다."

#: src/bare-metal/aps/inline-assembly.md:52
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"이 `main` 함수는 `#[no_mangle]` 및 `extern \"C\"`여야 합니다.  왜냐하면 이 함"
"수는 Rust 코드가 아닌, 어셈블러로 작성된 `entry.S`에서 호출되기 때문입니다."

#: src/bare-metal/aps/inline-assembly.md:54
msgid ""
"`_x0`–`_x3` are the values of registers `x0`–`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`–`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`–`_x3`는 `x0`에서 `x3` 레지스터들의 값입니다. 이 레지스터들은  일반적으"
"로 부트로더에서  디바이스 트리에 대한 포인터 등을 전달할 때 사용됩니다. 표준 "
"aarch64 호출 규약(`extern \"C\"`에서 사용하도록 지정)에 따라 레지스터 `x0`에"
"서 `x7`이 함수에 전달된 처음 8개 인수에 사용되므로 `entry.S`는 이러한 레지스"
"터를 변경하지 않는지 확인하는 것 외에는 특별히 할 작업이 없습니다."

#: src/bare-metal/aps/inline-assembly.md:60
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"`src/bare-metal/aps/examples`에서 `make qemu_psci`를 사용하여 QEMU에서 예시"
"를 실행합니다."

#: src/bare-metal/aps/mmio.md:1
msgid "Volatile memory access for MMIO"
msgstr "MMIO를 위한 휘발성(volatile) 메모리 액세스"

#: src/bare-metal/aps/mmio.md:3
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "`pointer::read_volatile` 및 `pointer::write_volatile`을 사용하세요."

#: src/bare-metal/aps/mmio.md:4
msgid "Never hold a reference."
msgstr "참조를 유지하지 마세요."

#: src/bare-metal/aps/mmio.md:5
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!`를 사용하면 임시 용도의 참조를 만들지 않고도 구조체 필드를 가져올 "
"수 있습니다."

#: src/bare-metal/aps/mmio.md:10
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"휘발성(volatile) 액세스: 읽기 또는 쓰기 작업이 부수 효과(side effect)를 동반"
"할 수 있기 때문에 컴파일러나 하드웨어가 임의로 이를 읽기 쓰기 작업의 순서를 "
"바꾸거나, 중복해서 수행하거나 또는 제거하지 못하게 합니다."

#: src/bare-metal/aps/mmio.md:12
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"일반적으로 쓰고 난 후 읽으면(예: 변경 가능한 참조를 통해) 컴파일러는 읽은 값"
"이 방금 쓴 값과 동일하다고 가정하고 실제로 메모리를 읽지 않을 수 있습니다."

#: src/bare-metal/aps/mmio.md:15
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"하드웨어에 대한 휘발성 액세스를 위한 일부 기존 크레이트는 참조를 유지하지만 "
"이는 올바른 것이 아닙니다. 참조가 있을 때마다 컴파일러는 이를 역참조하도록 선"
"택할 수 있습니다."

#: src/bare-metal/aps/mmio.md:18
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"`addr_of!` 매크로를 사용하여 구조체 포인터에서 구조체 필드 포인터를 가져옵니"
"다."

#: src/bare-metal/aps/uart.md:1
msgid "Let's write a UART driver"
msgstr "UART 드라이버 작성"

#: src/bare-metal/aps/uart.md:3
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"QEMU의 'virt' 보드에는 [PL011](https://developer.arm.com/documentation/"
"ddi0183/g) UART가 있으므로 이를 위한 드라이버를 작성해 보겠습니다."

#: src/bare-metal/aps/uart.md:9
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:17 src/bare-metal/aps/better-uart/driver.md:13
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:29 src/bare-metal/aps/better-uart/driver.md:25
#: src/exercises/bare-metal/rtc.md:337
msgid "/// Writes a single byte to the UART.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:31 src/bare-metal/aps/better-uart/driver.md:27
#: src/exercises/bare-metal/rtc.md:339
msgid "// Wait until there is room in the TX buffer.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:34 src/bare-metal/aps/uart.md:46
msgid ""
"// Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:37 src/bare-metal/aps/better-uart/driver.md:33
#: src/exercises/bare-metal/rtc.md:345
msgid "// Write to the TX buffer.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:41 src/bare-metal/aps/better-uart/driver.md:37
#: src/exercises/bare-metal/rtc.md:349
msgid "// Wait until the UART is no longer busy.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:55
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"`Uart::new`는 안전하지 않지만(usafe), 그 외 다른 메서드들은 안전한(safe) 점"
"에 주목하세요.다른 메서드들이 안전할 수 있는 이유는, `Uart::new`의 안전 요구"
"사항(즉, 지정된 UART의 드라이버 인스턴스가 하나만 있으며 주소 공간에 별칭을 "
"지정하는 다른 항목이 없음) 이 만족되기만 하면 `write_byte`와 같은 함수를 안전"
"하게 호출하는데 있어서 필요한 모든 전제조건이 만족되기  때문입니다."

#: src/bare-metal/aps/uart.md:61
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"반대 방법으로도 실행할 수 있지만(`new`를 안전하게 만들고 `write_byte`를 안전"
"하지 않게 만듦) 이는 `write_byte`를 호출하는 모든 위치에서 안전성에 관해 추론"
"해야 하므로 사용 편의성이 훨씬 떨어집니다."

#: src/bare-metal/aps/uart.md:64
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"이는 안전하지 않은 코드의 안전한 래퍼를 작성하는 일반적인 패턴입니다. 안전에 "
"관한 증명 부담을 여러 많은 위치에서 소수의 위치로 옮기는 것입니다."

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "More traits"
msgstr "트레잇(Trait)"

#: src/bare-metal/aps/uart/traits.md:3
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:17 src/exercises/bare-metal/rtc.md:381
#: src/exercises/bare-metal/solutions-afternoon.md:223
msgid ""
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:25
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:27
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/better-uart.md:1
msgid "A better UART driver"
msgstr "더 나은 UART 드라이버"

#: src/bare-metal/aps/better-uart.md:3
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"PL011에는 실제로 [훨씬 더 많은 레지스터](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers)가 있으며, 이"
"에 액세스할 포인터를 구성하기 위해 오프셋을 추가하면 오류가 발생하기 쉽고 읽"
"기 어렵습니다. 또한 그중 일부는 구조화된 방식으로 액세스할 수 있는 비트 필드"
"입니다."

#: src/bare-metal/aps/better-uart.md:7
msgid "Offset"
msgstr "오프셋"

#: src/bare-metal/aps/better-uart.md:7
msgid "Register name"
msgstr "레지스터 이름"

#: src/bare-metal/aps/better-uart.md:7
msgid "Width"
msgstr "너비"

#: src/bare-metal/aps/better-uart.md:9
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md:9
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md:9
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md:10
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md:10
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md:11
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md:11
msgid "FR"
msgstr "FR"

#: src/bare-metal/aps/better-uart.md:11
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md:12
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md:12
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md:13
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md:13
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md:13 src/bare-metal/aps/better-uart.md:16
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md:14
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md:14
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md:15
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md:15
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md:16
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md:16
msgid "CR"
msgstr "CR"

#: src/bare-metal/aps/better-uart.md:17
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md:17
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md:18
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md:18
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md:18 src/bare-metal/aps/better-uart.md:19
#: src/bare-metal/aps/better-uart.md:20 src/bare-metal/aps/better-uart.md:21
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md:19
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md:19
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md:20
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md:20
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md:21
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md:21
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md:22
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md:22
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md:26
msgid "There are also some ID registers which have been omitted for brevity."
msgstr "간결성을 위해 일부 ID 레지스터는 생략되었습니다."

#: src/bare-metal/aps/better-uart/bitflags.md:3
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:10
#: src/exercises/bare-metal/rtc.md:241
msgid "/// Flags from the UART flag register.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:14
#: src/exercises/bare-metal/rtc.md:245
msgid "/// Clear to send.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:16
#: src/exercises/bare-metal/rtc.md:247
msgid "/// Data set ready.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:18
#: src/exercises/bare-metal/rtc.md:249
msgid "/// Data carrier detect.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:20
#: src/exercises/bare-metal/rtc.md:251
msgid "/// UART busy transmitting data.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:22
#: src/exercises/bare-metal/rtc.md:253
msgid "/// Receive FIFO is empty.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:24
#: src/exercises/bare-metal/rtc.md:255
msgid "/// Transmit FIFO is full.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:26
#: src/exercises/bare-metal/rtc.md:257
msgid "/// Receive FIFO is full.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:28
#: src/exercises/bare-metal/rtc.md:259
msgid "/// Transmit FIFO is empty.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:30
#: src/exercises/bare-metal/rtc.md:261
msgid "/// Ring indicator.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:38
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:1
#, fuzzy
msgid "Multiple registers"
msgstr "더 많은 레지스터"

#: src/bare-metal/aps/better-uart/registers.md:3
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:43
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:3
msgid "Now let's use the new `Registers` struct in our driver."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:6
msgid "/// Driver for a PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:30
#: src/bare-metal/aps/better-uart/driver.md:54
#: src/exercises/bare-metal/rtc.md:342 src/exercises/bare-metal/rtc.md:366
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:41
#: src/exercises/bare-metal/rtc.md:353
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:48
#: src/exercises/bare-metal/rtc.md:360
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:63
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:1
#: src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "Using it"
msgstr "Bindgen 사용하기"

#: src/bare-metal/aps/better-uart/using.md:3
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:19
#: src/bare-metal/aps/logging/using.md:18 src/exercises/bare-metal/rtc.md:44
#: src/exercises/bare-metal/solutions-afternoon.md:33
msgid "/// Base address of the primary PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:25
#: src/bare-metal/aps/logging/using.md:24 src/exercises/bare-metal/rtc.md:50
#: src/exercises/bare-metal/solutions-afternoon.md:44
msgid ""
"// Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:29
#: src/bare-metal/aps/logging/using.md:29
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:35
msgid "b'\\r'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:36
#: src/async/pitfalls/cancellation.md:27
msgid "b'\\n'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:38
msgid "b'q'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:44
msgid "\"Bye!\""
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:54
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/logging.md:3
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"[`log`](https://crates.io/crates/log) 크레이트의 로깅 매크로를 사용할 수 있으"
"면 좋습니다. 이는 `Log` 트레잇을 구현하면 됩니다."

#: src/bare-metal/aps/logging.md:26 src/exercises/bare-metal/rtc.md:193
msgid "\"[{}] {}\""
msgstr ""

#: src/bare-metal/aps/logging.md:35 src/exercises/bare-metal/rtc.md:202
msgid "/// Initialises UART logger.\n"
msgstr ""

#: src/bare-metal/aps/logging.md:48
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"`log`함수 안에서 `unwrap`하는 것은 괜찮습니다.. 왜냐하면  `set_logger`를 호출"
"하기 전에 `LOGGER`를 초기화하기 때문입니다."

#: src/bare-metal/aps/logging/using.md:3
msgid "We need to initialise the logger before we use it."
msgstr ""

#: src/bare-metal/aps/logging/using.md:38 src/exercises/bare-metal/rtc.md:72
#: src/exercises/bare-metal/solutions-afternoon.md:115
msgid "\"{info}\""
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
msgid "Note that our panic handler can now log details of panics."
msgstr ""

#: src/bare-metal/aps/logging/using.md:47
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/exceptions.md:3
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""

#: src/bare-metal/aps/exceptions.md:67
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""

#: src/bare-metal/aps/exceptions.md:68
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""

#: src/bare-metal/aps/exceptions.md:70
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""

#: src/bare-metal/aps/exceptions.md:72
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""

#: src/bare-metal/aps/other-projects.md:3
#, fuzzy
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md:4
#, fuzzy
msgid "\"coreboot without the C\""
msgstr "\"C가 없는 coreboot\""

#: src/bare-metal/aps/other-projects.md:5
#, fuzzy
msgid "Supports x86, aarch64 and RISC-V."
msgstr "x86, aarch64, RISC-V를 지원합니다."

#: src/bare-metal/aps/other-projects.md:6
#, fuzzy
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "자체적으로 여러 드라이버를 보유하는 대신 LinuxBoot에 의존합니다."

#: src/bare-metal/aps/other-projects.md:7
#, fuzzy
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md:8
#, fuzzy
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"초기화, UART 드라이버, 간단한 부트로더, JTAG, 예외 수준, 예외 처리, 페이지 테"
"이블"

#: src/bare-metal/aps/other-projects.md:10
#, fuzzy
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr "잘 작성되지 않은 것도 있으므로 주의하세요."

#: src/bare-metal/aps/other-projects.md:12
#, fuzzy
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md:13
#, fuzzy
msgid "Static analysis to determine maximum stack usage."
msgstr "최대 스택 사용량을 결정하는 정적 분석"

#: src/bare-metal/aps/other-projects.md:17
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""

#: src/bare-metal/aps/other-projects.md:19
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""

#: src/bare-metal/aps/other-projects.md:23
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""

#: src/bare-metal/useful-crates.md:1
msgid "Useful crates"
msgstr "유용한 크레이트"

#: src/bare-metal/useful-crates.md:3
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"bare-metal 프로그래밍의 몇 가지 일반적인 문제를 해결하는 크레이트를 살펴봅니"
"다."

#: src/bare-metal/useful-crates/zerocopy.md:3
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"Fuchsia팀이 만든 [`zerocopy`](https://docs.rs/zerocopy/) 크레이트는 바이트 시"
"퀀스를 다른 타입으로 안전하게 변환하기 위한 트레잇 및 매크로를 제공합니다."

#: src/bare-metal/useful-crates/zerocopy.md:42
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"이 크레이트는 휘발성(volatile) 읽기 및 쓰기를 사용하지 않으므로 MMIO에 적합하"
"지 않지만, 하드웨어와 공유되거나(예: DMA에서) 외장 인터페이스를 통해 전송되"
"는 구조체를 다루는 데에는 유용할 수 있습니다."

#: src/bare-metal/useful-crates/zerocopy.md:48
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"어떤 타입이 가능한 모든 바이트 패턴들에 대해 올바른 값을 가질 때에만 , 그 타"
"입이 `FromBytes`를 구현할 수 있습니다. 그렇게 해서 신뢰할 수 없는 바이트 시퀀"
"스를 안전하게 해당 타입으로 변환할 수 있습니다."

#: src/bare-metal/useful-crates/zerocopy.md:50
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"위 코드에서 정의한 타입에 대해 `FromBytes`를 구현하려고 하면 에러가 발생합니"
"다. `RequestType`은 가능한 모든 u32 값을 식별자로 받아들이지 않기 때문입니"
"다. 즉 모든 바이트 패턴이 유효한 `RequestType`값은 아닙니다."

#: src/bare-metal/useful-crates/zerocopy.md:53
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder`에는 바이트 오더에 따른 서로 다른 표현 방식을 지원하는 "
"숫자 타입을 제공합니다."

#: src/bare-metal/useful-crates/zerocopy.md:54
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"`src/bare-metal/useful-crates/zerocopy-example/`에서 `cargo run`을 사용하여 "
"예시를 실행합니다(종속성 문제로 인해 플레이그라운드에서는 실행되지 않습니다)."

#: src/bare-metal/useful-crates/aarch64-paging.md:3
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"[`aarch64-paging`](https://crates.io/crates/aarch64-paging) 크레이트를 사용하"
"면 AArch64 가상 메모리 시스템 아키텍처에 따라 페이지 테이블을 만들 수 있습니"
"다."

#: src/bare-metal/useful-crates/aarch64-paging.md:14
msgid "// Create a new page table with identity mapping.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:16
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:21
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"현재는 EL1만 지원하지만 다른 익셉션 레벨(Exception Level: EL)도 어렵지 않게 "
"추가할 수 있습니다."

#: src/bare-metal/useful-crates/aarch64-paging.md:30
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"Android에서 [보호된 VM 펌웨어](https://cs.android.com/android/platform/"
"superproject/+/master:packages/modules/Virtualization/pvmfw/)에 사용됩니다."

#: src/bare-metal/useful-crates/aarch64-paging.md:31
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"이 예시를 간단하게 실행하는 방법은 없습니다. 실제 하드웨어 또는 QEMU에서 실행"
"해야 하기 때문입니다."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator)"
"는 버디 시스템 할당자를 구현하는 서드 파티 크레이트입니다. 이 크레이트의 "
"[`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html)은 [`GlobalAlloc`](https://doc."
"rust-lang.org/core/alloc/trait.GlobalAlloc.html)를 구현합니다. 따라서 여러분"
"은 버디 시스템 할당자를 'alloc' 크레이트를 통해서 사용할 수 있습니다([이전]"
"(../alloc.md)에 확인함). 또는 다른 주소 공간을 할당하는 데 사용할 수 있습니"
"다. 예를 들어 PCI BAR에 MMIO 공간을 할당할 수 있습니다."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:29
msgid "PCI BARs always have alignment equal to their size."
msgstr "PCI BAR는 BAR영역의 크기에 맞추어 정렬됩니다."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:30
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"`src/bare-metal/useful-crates/allocator-example/`에서 `cargo run`을 사용하여 "
"예시를 실행합니다(종속성 문제로 인해 플레이그라운드에서는 실행되지 않습니다)."

#: src/bare-metal/useful-crates/tinyvec.md:3
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"힙에 메모리 할당하지 않고 크기 조절이 가능한 컨테이너(예: `Vec` 같은)가 필요"
"할 때가 있습니다. [`tinyvec`](https://crates.io/crates/tinyvec)을 사용하면 됩"
"니다. `tinyvec`에서 벡터는 배열 또는 슬라이스로부터 생성이 되며, 이들은 정적"
"으로 할당되었거나 스택에 할당되어 있을 수 있습니다.`tinyvec`은 현재 벡터 안"
"에 얼마나 많은 엘리먼트들이 존재하는 지를 추적하고 있으며, 할당된 양보다 더 "
"많이 사용하려고 하면 패닉을 발생시킵니다."

#: src/bare-metal/useful-crates/tinyvec.md:25
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec`를 사용하려면 엘리먼트의 타입이 `Default`를 통해 초기화 될 수 있어"
"야 합니다."

#: src/bare-metal/useful-crates/tinyvec.md:27
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"Rust 플레이그라운드에는 `tinyvec`가 포함되어 있으므로 이 예시는 인라인으로 실"
"행됩니다."

#: src/bare-metal/useful-crates/spin.md:3
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync::Mutex` 및 `std::sync`의 기타 동기화 프리미티브는 `core` 또는 "
"`alloc`에서 사용할 수 없습니다. 그러면 어떻게 동기화 또는 interior mutability"
"와 같은 기능이 필요할 경우 어떻게 해야 할까요? "

#: src/bare-metal/useful-crates/spin.md:7
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"[`spin`](https://crates.io/crates/spin) 크레이트는 이러한 동기화 프리미티브들"
"을 스핀록으로 구현하고 있습니다."

#: src/bare-metal/useful-crates/spin.md:26
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"인터럽트 핸들러에서 락을 걸 경우, 교착 상태가 발생하지 않도록 주의하세요."

#: src/bare-metal/useful-crates/spin.md:27
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"`spin`에는 티켓 잠금 뮤텍스 구현도 있습니다. `std::sync`의 `RwLock`, "
"`Barrier`, `Once` 에 해당하는 것들이 제공되며,  지연된 초기화를 위한 `Lazy`"
"에 해당하는 것도 제공됩니다."

#: src/bare-metal/useful-crates/spin.md:29
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"[`once_cell`](https://crates.io/crates/once_cell) 크레이트에는 지연된 초기화"
"를 위한 몇 가지 유용한 타입이 있는데 `spin::once::Once`와는 약간 다른 접근 방"
"식을 사용합니다."

#: src/bare-metal/useful-crates/spin.md:31
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"Rust 플레이그라운드에는 `spin`이 포함되어 있으므로 이 예시는 인라인으로 실행"
"됩니다."

#: src/bare-metal/android.md:3
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"AOSP에서 bare-metal Rust 바이너리를 빌드하려면 `rust_ffi_static` 을 사용하여 "
"Rust 코드를 빌드하고, 링커 스크립트가 포함된 `cc_binary`를 사용하여 ELF 바이"
"너리를 생성하고, `raw_binary`를 사용해 ELF를 곧바로 수행될 수 있는 원시(raw) "
"바이너리로 변환합니다."

#: src/bare-metal/android/vmbase.md:1
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md:3
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"[vmbase](https://android.googlesource.com/platform/packages/modules/"
"Virtualization/+/refs/heads/master/vmbase/) 라이브러리는, aarch64의 crosvm에"
"서 실행되는 VM을 타겟하여, 진입점, UART 콘솔 로깅, 링커 스크립트, 빌드 룰 등"
"에 대한 기본 구현들을 제공합니다."

#: src/bare-metal/android/vmbase.md:24
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr "`main!` 매크로는 `vmbase` 진입점에서 호출될 main 함수를 표시합니다."

#: src/bare-metal/android/vmbase.md:26
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"`vmbase`가 제공하는 진입점은 콘솔을 초기화 하며, main 함수가 리턴하면  "
"PSCI_SYSTEM_OFF 메시지를 PSCI를 통해 보내어서  VM을 종료시킵니다."

#: src/exercises/bare-metal/afternoon.md:3
msgid "We will write a driver for the PL031 real-time clock device."
msgstr ""

#: src/exercises/bare-metal/afternoon.md:7
#: src/exercises/concurrency/afternoon.md:13
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"연습문제를 살펴 본 후, 제공된 [해답](solutions-afternoon.md)을 살펴볼 수 있습"
"니다."

#: src/exercises/bare-metal/rtc.md:1
#: src/exercises/bare-metal/solutions-afternoon.md:3
#, fuzzy
msgid "RTC driver"
msgstr "RTC 드라이버"

#: src/exercises/bare-metal/rtc.md:3
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"QEMU의 'virt' 보드에는 [PL011](https://developer.arm.com/documentation/"
"ddi0224/c) UART가 있으므로 이를 위한 드라이버를 작성해 보겠습니다."

#: src/exercises/bare-metal/rtc.md:6
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""

#: src/exercises/bare-metal/rtc.md:8
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""

#: src/exercises/bare-metal/rtc.md:11
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""

#: src/exercises/bare-metal/rtc.md:14
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""

#: src/exercises/bare-metal/rtc.md:15
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""

#: src/exercises/bare-metal/rtc.md:19
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/rtc.md:40
#: src/exercises/bare-metal/solutions-afternoon.md:29
msgid "/// Base addresses of the GICv3.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:55
#: src/exercises/bare-metal/solutions-afternoon.md:49
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:57
#: src/exercises/bare-metal/solutions-afternoon.md:51
msgid ""
"// Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:63
msgid "// TODO: Create instance of RTC driver and print current time.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:65
msgid "// TODO: Wait for 3 seconds.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:78
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:84 src/exercises/bare-metal/rtc.md:159
#: src/exercises/bare-metal/rtc.md:218 src/exercises/bare-metal/rtc.md:418
msgid ""
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:105
msgid "\"sync_exception_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:111
msgid "\"irq_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:113
msgid "\"No pending interrupt\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:114
msgid "\"IRQ {intid:?}\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:119
msgid "\"fiq_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:125
msgid "\"serr_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:131
msgid "\"sync_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:137
msgid "\"irq_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:143
msgid "\"fiq_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
msgid "\"serr_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:154
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:172
msgid "// ANCHOR: main\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:213
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:236
msgid "// ANCHOR: Flags\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:264
msgid "// ANCHOR_END: Flags\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:268
msgid ""
"/// Flags from the UART Receive Status Register / Error Clear Register.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:272
msgid "/// Framing error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:274
msgid "/// Parity error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:276
msgid "/// Break error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:278
msgid "/// Overrun error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:282
msgid "// ANCHOR: Registers\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:314
msgid "// ANCHOR_END: Registers\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:316
msgid ""
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:325
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:370
msgid "// ANCHOR_END: Uart\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:413
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:436 src/exercises/bare-metal/rtc.md:438
msgid "\"linux\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:437 src/exercises/bare-metal/rtc.md:439
msgid "\"CROSS_COMPILE\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:437
#, fuzzy
msgid "\"aarch64-linux-gnu\""
msgstr "aarch64-paging"

#: src/exercises/bare-metal/rtc.md:439
msgid "\"aarch64-none-elf\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:442
msgid "\"entry.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:443
#, fuzzy
msgid "\"exceptions.S\""
msgstr "예외"

#: src/exercises/bare-metal/rtc.md:444
msgid "\"idmap.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:445
msgid "\"empty\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:449
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:453
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:598
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:602
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:783
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:787
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:832
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:836
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:943
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:948
msgid "# Copyright 2023 Google LLC"
msgstr ""

#: src/exercises/bare-metal/rtc.md:962
msgid "$(shell uname -s)"
msgstr ""

#: src/exercises/bare-metal/rtc.md:964
#, fuzzy
msgid "aarch64-linux-gnu"
msgstr "aarch64-paging"

#: src/exercises/bare-metal/rtc.md:981
msgid "stdio -display none -kernel $< -s"
msgstr ""

#: src/exercises/bare-metal/rtc.md:984
msgid "cargo clean"
msgstr ""

#: src/exercises/bare-metal/rtc.md:999
msgid "Run the code in QEMU with `make qemu`."
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:1
msgid "Bare Metal Rust Afternoon"
msgstr "전Bare Metal 오후"

#: src/exercises/bare-metal/solutions-afternoon.md:5
msgid "([back to exercise](rtc.md))"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:7
#, fuzzy
msgid "_main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md:36
msgid "/// Base address of the PL031 RTC.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:38
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:57
msgid ""
"// Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:62
msgid "\"RTC: {time}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:70
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:73
#: src/exercises/bare-metal/solutions-afternoon.md:91
msgid "\"Waiting for {}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:75
#: src/exercises/bare-metal/solutions-afternoon.md:83
#: src/exercises/bare-metal/solutions-afternoon.md:96
#: src/exercises/bare-metal/solutions-afternoon.md:104
msgid "\"matched={}, interrupt_pending={}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:87
#: src/exercises/bare-metal/solutions-afternoon.md:108
msgid "\"Finished waiting\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:89
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:121
msgid "_pl031.rs_:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:128
msgid "/// Data register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:130
msgid "/// Match register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:132
msgid "/// Load register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:134
msgid "/// Control register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:137
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:140
msgid "/// Raw Interrupt Status\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:143
msgid "/// Masked Interrupt Status\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:146
msgid "/// Interrupt Clear Register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:150
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:158
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:170
msgid "/// Reads the current RTC value.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:172
#: src/exercises/bare-metal/solutions-afternoon.md:180
#: src/exercises/bare-metal/solutions-afternoon.md:188
#: src/exercises/bare-metal/solutions-afternoon.md:199
#: src/exercises/bare-metal/solutions-afternoon.md:211
#: src/exercises/bare-metal/solutions-afternoon.md:218
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:177
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:185
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:194
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:205
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:216
msgid "/// Clears a pending interrupt, if any.\n"
msgstr ""

#: src/concurrency.md:1
#, fuzzy
msgid "Welcome to Concurrency in Rust"
msgstr "Welcome to Comprehensive Rust 🦀"

#: src/concurrency.md:3
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"러스트는 동시성 지원이 막강합니다. 운영체제 레벨의 스레드를 사용하며, 뮤택스"
"와 채널도 지원합니다."

#: src/concurrency.md:6
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"러스트의 타입 시스템은 프로그램에 동시성 버그가 있을 경우, 컴파일 시에 에러"
"가 발생하도록 해 줍니다. 컴파일러를 이용해서 프로그램이 수행시에 정확히 동작"
"함을 미리 보장해 주기 때문에, 사람들은 이를 종종 _겁없는 동시성_ 이라고 합니"
"다."

#: src/concurrency/threads.md:3
msgid "Rust threads work similarly to threads in other languages:"
msgstr "러스트의 스레드는 다른 언어의 스레드와 유사하게 동작합니다:"

#: src/concurrency/threads.md:12
msgid "\"Count in thread: {i}!\""
msgstr ""

#: src/concurrency/threads.md:18
msgid "\"Main thread: {i}\""
msgstr ""

#: src/concurrency/threads.md:24
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr ""
"스레드는 모두 데몬 스레드입니다. 따라서 메인 스레드는 이 스레드들이 끝나기를 "
"기다리지 않습니다."

#: src/concurrency/threads.md:25
msgid "Thread panics are independent of each other."
msgstr "한 스레드에서 발생한 패닉은 다른 스레드에게 영향을 끼치지 않습니다."

#: src/concurrency/threads.md:26
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"패닉은 추가정보(페이로드)를 포함할 수 있으며, 이는 `downcast_ref`로 풀어볼 "
"수 있습니다."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"Notice that the thread is stopped before it reaches 10 --- the main thread "
"is not waiting."
msgstr ""
"메인 스레드가 자식 스레드를 기다리지 않기 때문에 자식 스레드의 for문은 10까"
"지 가지 않습니다."

#: src/concurrency/threads.md:35
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"만약 메인 스레드가 자식 스레드가 끝날 때 까지 기다리기를 원한다면 `let "
"handle = thread::spawn(...)`으로 스레드를 선언한 후 `handle.join()`로 연결하"
"여 사용합니다."

#: src/concurrency/threads.md:38
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr ""
"자식 스레드에서 발생한 패닉이 메인 스레드에는 영향을 주지 않음을 확인하시기 "
"바랍니다."

#: src/concurrency/threads.md:40
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"`handle.join()`사용시 `Result` 반환값을 통해 패닉의 추가정보에 접근할 수 있습"
"니다. 이 시점에서 [`Any`](https://doc.rust-lang.org/std/any/index.html)에 대"
"해 이야기를 해 보면 좋습니다."

#: src/concurrency/scoped-threads.md:3
msgid "Normal threads cannot borrow from their environment:"
msgstr "보통, 스레드는 스레드 밖에서 데이터를 빌릴 수 없습니다:"

#: src/concurrency/scoped-threads.md:20
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"하지만, [scoped thread](https://doc.rust-lang.org/std/thread/fn.scope.html)에"
"서는 가능합니다:"

#: src/concurrency/scoped-threads.md:40
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"`thread::scope` 함수가 완료되면 그 안에서 생성된 모든 스레드들이 종료했음이 "
"보장되기 때문에, 그 때 빌렸던 데이터들을 다시 반환할 수 있기 때문입니다."

#: src/concurrency/scoped-threads.md:42
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"일반적인 러스트의 빌림 규칙이 적용됩니다: 한 스레드에 의한 가변 빌림 또는 여"
"러 스레드에 대한 불변 빌림중 하나만 가능합니다."

#: src/concurrency/channels.md:3
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"러스트의 채널은 `Sender<T>` 와 `Receiver<T>` 두 부분으로 구성됩니다. 이 둘은 "
"채널을 통해 서로 연결되어 있지만, 우리는 채널을 볼 수는 없고 이 양 끝단만을 "
"사용하게 됩니다."

#: src/concurrency/channels.md:15 src/concurrency/channels.md:16
#: src/concurrency/channels.md:20
msgid "\"Received: {:?}\""
msgstr ""

#: src/concurrency/channels.md:26
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc`는 “Multi-Produce, Single-Consumer”를 의미합니다. `Sender`와 "
"`SyncSender`는 `Clone`을 구현하지만 (즉, 여러개의 producer를 만들수 있습니"
"다) `Receiver`는 `Clone`을 구현하지 않습니다."

#: src/concurrency/channels.md:29
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()`와 `recv()`는 `Result`를 반환합니다. 만일 `Err`가 반환된다면, 상대방"
"의 `Sender`또는 `Receiver`가 삭제되었고 채널이 닫혔다는 뜻입니다."

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "`mpsc::channel()` 함수는 경계가 없는 비동기 채널을 생성합니다:"

#: src/concurrency/channels/unbounded.md:16
#: src/concurrency/channels/bounded.md:16
msgid "\"Message {i}\""
msgstr ""

#: src/concurrency/channels/unbounded.md:17
#: src/concurrency/channels/bounded.md:17
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr ""

#: src/concurrency/channels/unbounded.md:19
#: src/concurrency/channels/bounded.md:19
msgid "\"{thread_id:?}: done\""
msgstr ""

#: src/concurrency/channels/unbounded.md:24
#: src/concurrency/channels/bounded.md:24
msgid "\"Main: got {msg}\""
msgstr ""

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "경계가 있는 동기 채널은 `send`가 현제 스레드를 블로킹 하도록 만듭니다:"

#: src/concurrency/channels/bounded.md:31
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""

#: src/concurrency/channels/bounded.md:34
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""

#: src/concurrency/channels/bounded.md:36
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"러스트는 어떻게 해서 스레드 간에 특정 데이터 타입이 공유될 수 있거나, 안된다"
"는 것을 알까요? 정답은 다음 두 트레잇에 있습니다:"

#: src/concurrency/send-sync.md:6
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): `T`가 스레드 "
"간 이동이 안전하다면, `T`의 타입은 `Send`입니다."

#: src/concurrency/send-sync.md:8
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): `&T`가 스레"
"드 간 이동이 안전하다면, `&T`의 타입은 `Sync`입니다."

#: src/concurrency/send-sync.md:11
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Send`와 `Sync` 트레잇은 [안전하지 않은 트레잇](../unsafe/unsafe-traits.md)입"
"니다. 컴파일러는 타입의 요소들이 모두 `Send`와 `Sync` 타입이면 자동으로 이 트"
"레잇들을 적용시켜 줍니다. 물론 여러분 스스로 맞다고 알고 있다면 직접 구현해"
"도 됩니다."

#: src/concurrency/send-sync.md:21
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"`Sync`와 `Send`는 어떤 타입이 특정한 스레드-안전 속성을 가짐을 나타내는 마커"
"로 생각할 수 있습니다."

#: src/concurrency/send-sync.md:23
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"이 두 트레이트는 제너릭에서 제약 조건을 나타내는 트레이트로 사용될 수도 있습"
"니다."

#: src/concurrency/send-sync/send.md:3
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"`T`가 스레드 간에 안전하게 이동될 수 있다면, `T`의 타입은 `Send`입니다."

#: src/concurrency/send-sync/send.md:5
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"소유권을 다른 스레드로 이동하면 소멸자가 해당 스레드에서 실행됩니다. 여기서 "
"의문은 \"언제 한 스레드에서 값을 할당하고 다른 스레드에서 값을 할당 해제할 "
"수 있는가\" 입니다."

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"예를 들어 SQLite 라이브러리 연결은 단일 스레드에서만 액세스해야 합니다."

#: src/concurrency/send-sync/sync.md:3
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"`&T`가 여러 스레드에서 안전하게 접근될 수 있다면, `&T`의 타입은 `Sync`입니다."

#: src/concurrency/send-sync/sync.md:6
msgid "More precisely, the definition is:"
msgstr "좀 더 정확한 정의는 다음과 같습니다:"

#: src/concurrency/send-sync/sync.md:8
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`&T`가 `Send`인 경우에만 `T`의 타입이 `Sync`가 됩니다"

#: src/concurrency/send-sync/sync.md:14
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"위 문장을 풀어서 이야기 하면, 어떤 타입이 스레드 간에 공유되어서 사용되기에 "
"안전하다면 그 타입의 참조 타입은 스레드 간에 이동 가능하다는 것입니다."

#: src/concurrency/send-sync/sync.md:18
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"이는 다음과 같이 증명할 수 있습니다: 어떤 타입이 `Sync`라는 말은 곧 그 타입"
"이 여러 스레드들 사이에서 데이터 레이스나 여타 동기화 문제 없이 공유 가능하다"
"는 말입니다. 스레드 간 공유가 안전하다면, 스레드간 이동도 안전할 수 밖에 없습"
"니다. 어떤 타입의 스레드간 이동이 안전하다면, 그 타입의 참조 또한 스레드간 이"
"동이 안전할 수 밖에 없습니다."

#: src/concurrency/send-sync/examples.md:3
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md:5
msgid "Most types you come across are `Send + Sync`:"
msgstr "여러분이 다루게 될 대부분의 타입은 `Send + Sync`입니다:"

#: src/concurrency/send-sync/examples.md:7
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, ..."

#: src/concurrency/send-sync/examples.md:8
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md:9
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."

#: src/concurrency/send-sync/examples.md:10
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr "`Arc<T>`: 참조 카운트 조작을 아토믹 하기 때문에 스레드 안전함."

#: src/concurrency/send-sync/examples.md:11
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr ""
"`Mutex<T>`: 값을 접근하기 위해 뮤택스를 잠궈야 하기 때문에 스레드 안전함."

#: src/concurrency/send-sync/examples.md:12
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"`AtomicBool`, `AtomicU8`, ...: 값을 접근할 때 특별한 아토믹 명령어들을 사용합"
"니다."

#: src/concurrency/send-sync/examples.md:14
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"제네릭 타입은 일반적으로 타입 파라메터가 `Send + Sync`이면 `Send + Sync` 입니"
"다."

#: src/concurrency/send-sync/examples.md:17
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md:19
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"아래 타입들은 다른 스레드로 이동될 수 있지만 내부적으로 값이 변경될 수 있기 "
"때문에 스레드 안전하지 않습니다:"

#: src/concurrency/send-sync/examples.md:22
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md:23
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md:24
msgid "`Cell<T>`"
msgstr "`Cell<T>`"

#: src/concurrency/send-sync/examples.md:25
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md:29
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr "아래 타입들은 스레드 안전하지만 다른 스레드로 이동될 수 없습니다:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T>`: 내부적으로, 운영체제가 제공하는 primitive를 사용하는데, 이 "
"primitive는 생성된 스레드에서 해제가 이루어져야 합니다. (_역주_: 그래서 다른 "
"스레드로 옮길 수 없습니다.)"

#: src/concurrency/send-sync/examples.md:34
msgid "`!Send + !Sync`"
msgstr "`!Send + !Sync`"

#: src/concurrency/send-sync/examples.md:36
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"아래 타입들은 스레드 안전하지도 않고 다른 스레드로 이동될 수도 없습니다:"

#: src/concurrency/send-sync/examples.md:38
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: `Rc<T>` 는 아토믹하지 않은 방식으로 참조 카운트를 조작하는 "
"`RcBox<T>`를 참조합니다."

#: src/concurrency/send-sync/examples.md:40
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: 러스트는 포인터가 스레드 안전하지 않다고 가정합니다."

#: src/concurrency/shared_state.md:3
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"러스트는 주로 아래 두 가지 타입을 이용해서 공유 데이터 동기화를 수행합니다:"

#: src/concurrency/shared_state.md:6
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), `T`에 대한 아"
"토믹 참조 카운트: 이 참조는 다수의 스레드 사이에서 공유될 수 있고, 참조하던 "
"마지막 스레드가 종료할 경우 `T`를 반환합니다."

#: src/concurrency/shared_state.md:8
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): `T`값에 "
"대한 상호 배제 엑세스를 보장합니다."

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html)의 `clone` 메서"
"드를 이용하면 여러 스레드가 한 데이터를 동시에 (_역주_: 그리고 안전하게. 스레"
"드가 하나라도 살아있는 동안에는 `T`가 반환되지 않음) 읽을 수 있습니다:"

#: src/concurrency/shared_state/arc.md:16
msgid "\"{thread_id:?}: {v:?}\""
msgstr ""

#: src/concurrency/shared_state/arc.md:21
#: src/concurrency/shared_state/example.md:17
#: src/concurrency/shared_state/example.md:45
msgid "\"v: {v:?}\""
msgstr ""

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc`는 \"Atomic Reference Counted\"를 의미하며, 스레드 안정성을 보장하는 "
"`Rc`라고 생각하면 됩니다."

#: src/concurrency/shared_state/arc.md:31
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`T`가 `Clone`을 구현하든 안하든 `Arc<T>`는 `Clone`을 구현합니다. `Send`와 "
"`Sync`는 `T`가 이들을 구현하는 경우에만 구현됩니다."

#: src/concurrency/shared_state/arc.md:33
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()`는 아토믹 연산을 수행하기 때문에 그 때 코스트가 좀 있지만, 일"
"단 `clone()`이 끝난 후 `T`를 사용하는 대에는 아무런 오버헤드가 없습니다."

#: src/concurrency/shared_state/arc.md:35
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"순환 참조가 발생하지 않도록 주의해야 합니다. 러스트는 순환 참조를 감지하는 가"
"비지 컬랙터가 없습니다."

#: src/concurrency/shared_state/arc.md:37
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr "순환 참조를 피하는데 `std::sync::Weak`가 도움이 될 것입니다."

#: src/concurrency/shared_state/mutex.md:3
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface:"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)를 이용하"
"면 불변 참조를 통해서도 `T`의 값을 수정할 수가 있으며, _이에 더해서_ 한 번에 "
"한 스레드만 `T`의 값을 접근(읽거나 쓰거나)함을 보장해 줍니다:"

#: src/concurrency/shared_state/mutex.md:11
#: src/concurrency/shared_state/mutex.md:18
msgid "\"v: {:?}\""
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"모든 `Mutex<T>`는 [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-lang."
"org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E)를 자동으로 구현함"
"을 참조하세요."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"러스트의 `Mutex`는 오직 하나의 데이터만 담을 수 있는 컬렉션처럼 볼 수도 있습"
"니다. 다른 컬렉션과 다른 점은, 그 데이터가 동시성 문제로부터 자유롭다는 점입"
"니다."

#: src/concurrency/shared_state/mutex.md:33
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"`Mutex`는 뮤텍스를 획득하지 않으면 보호된 데이터에 접근하는 것이 불가능  하도"
"록 디자인 되어 있습니다."

#: src/concurrency/shared_state/mutex.md:35
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"`&Mutex<T>`에 대해 lock을 획득하면 `&mut T`를 얻을 수 있습니다. `MutexGuard`"
"는 `&mut T`가 획득한 lock보다 오래 살아남지 않음을 보장합니다."

#: src/concurrency/shared_state/mutex.md:37
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`Mutex<T>`는 오직 `T`가 `Send`를 구현하는 경우에만 `Send`와 `Sync`를 구현합니"
"다."

#: src/concurrency/shared_state/mutex.md:39
#, fuzzy
msgid "A read-write lock counterpart: `RwLock`."
msgstr "읽기-쓰기 lock은 `RwLock`을 사용합니다."

#: src/concurrency/shared_state/mutex.md:40
#, fuzzy
msgid "Why does `lock()` return a `Result`?"
msgstr "왜 `lock()`이 `Result`를 반환할까요?"

#: src/concurrency/shared_state/mutex.md:41
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"`Mutex`를 획득한 스레드에서 패닉이 발생하면, 데이터가 올바르지 않은 상황이 "
"될 수 있습니다. 이를 `Mutex`가 \"중독(poisoned)\" 되었다고 표현하며, 중독된 "
"뮤텍스에서 `lock()`을 호출하면 실패하고 [`PoisonError`](https://doc.rust-"
"lang.org/std/sync/struct.PoisonError.html)가 발생합니다. 이러한 오류로부터 데"
"이터를 복구하기 위해 `into_inner()`를 호출할 수 있습니다."

#: src/concurrency/shared_state/example.md:3
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "`Arc`와 `Mutex`의 동작을 살펴봅시다:"

#: src/concurrency/shared_state/example.md:6
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid "Possible solution:"
msgstr "가능한 해결책:"

#: src/concurrency/shared_state/example.md:49
msgid "Notable parts:"
msgstr "눈여겨 볼 부분:"

#: src/concurrency/shared_state/example.md:51
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v`는 `Arc`와 `Mutex` 모두에 포함되어 있습니다. 이는 `Arc`와 `Mutex`가 서로 "
"완전히 다른 문제를 위한 도구이기 때문입니다."

#: src/concurrency/shared_state/example.md:53
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"`Mutex`를 `Arc`로 래핑하는 것은 가변 상태를 스레드들 간에 공유할 때 흔히 사용"
"하는 패턴입니다."

#: src/concurrency/shared_state/example.md:55
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>`를 다른 스레드에서 사용하려면, 먼저 `v2`로 복사를 하고 이를 그 스"
"레드로 이동 해야 합니다. 그래서 람다의 시그니처에 `move`가 있는 것입니다."

#: src/concurrency/shared_state/example.md:57
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr "블록은 `LockGuard`의 범위를 최대한 좁히기 위해 사용되었습니다."

#: src/exercises/concurrency/morning.md:3
msgid "Let us practice our new concurrency skills with"
msgstr "동시성 기법들을 연습해 봅시다"

#: src/exercises/concurrency/morning.md:5
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "식사하는 철학자 문제: 고적적인 동시성 문제입니다."

#: src/exercises/concurrency/morning.md:7
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"멀티 스레드 링크 검사기: 병렬적으로 웹페이지의 링크들을 체크합니다. 카고를 통"
"해 몇 가지 의존성들을 다운도르 받아야 하는 큰 프로젝트 입니다."

#: src/exercises/concurrency/dining-philosophers.md:3
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "식사하는 철학자 문제는 동시성에 있어서 고전적인 문제입니다:"

#: src/exercises/concurrency/dining-philosophers.md:5
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"5명의 철학자가 원탁에서 식사를 하고 있습니다.  철학자는 원탁에서 자신의 자리"
"에 앉아있습니다. 포크는 각 접시 사이에 있습니다.  제공되는 요리를 먹기 위해서"
"는 두 개의 포크를 모두 사용해야합니다. 철학자는 생각을 하다가 배가 고프면 자"
"신의 좌,우의 포크를 들어 요리를 먹습니다. 철학자는 요리를 먹은 후에는 포크를 "
"다시 자리에 내려놓습니다. 철학자는 자신의 좌,우에 포크가 있을때만 요리를 먹"
"을 수 있습니다. 따라서 두 개의 포크는 오직 자신의 좌,우 철학자가 생각을 할 때"
"만 사용할 수 있습니다."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"이번 훈련에서는 [카고 설치하기](../../cargo/running-locally.md)가 필요합니"
"다. 아래 코드를 복사해서 `src/main.rs`에 붙여놓고 빈 부분을 채우고, `cargo "
"run` 커맨드로 테스트 해서 교착상태(데드락)가 발생하지 않는지 확인합니다:"

#: src/exercises/concurrency/dining-philosophers.md:28
#: src/exercises/concurrency/dining-philosophers-async.md:23
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:36
#: src/exercises/concurrency/solutions-morning.md:24
#: src/exercises/concurrency/dining-philosophers-async.md:31
#: src/exercises/concurrency/solutions-afternoon.md:25
msgid "\"Eureka! {} has a new idea!\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:41
#: src/exercises/concurrency/dining-philosophers-async.md:37
#: src/exercises/concurrency/solutions-afternoon.md:31
msgid "// Pick up forks...\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:42
#: src/exercises/concurrency/solutions-morning.md:33
#: src/exercises/concurrency/dining-philosophers-async.md:38
#: src/exercises/concurrency/solutions-afternoon.md:38
msgid "\"{} is eating...\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
#, fuzzy
msgid "\"Socrates\""
msgstr "HAL 크레이트들"

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Hypatia\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Plato\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Aristotle\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Pythagoras\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:51
#: src/exercises/concurrency/dining-philosophers-async.md:48
#: src/exercises/concurrency/solutions-afternoon.md:50
msgid "// Create forks\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:53
#: src/exercises/concurrency/dining-philosophers-async.md:50
#: src/exercises/concurrency/solutions-afternoon.md:54
msgid "// Create philosophers\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:55
msgid "// Make each of them think and eat 100 times\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:57
#: src/exercises/concurrency/dining-philosophers-async.md:54
#: src/exercises/concurrency/solutions-afternoon.md:88
msgid "// Output their thoughts\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
msgid "You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:3
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"새로 배운것들을 활용해서 멀티 스레드 링크 검사기를 만듭니다. 이 검사기는 웹페"
"이지 안에 있는 링크들이 유효한지 확인합니다. 그리고 재귀적으로 동일 도메인의 "
"다른 모든 페이지가 유효한지 확인합니다."

#: src/exercises/concurrency/link-checker.md:8
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"이를 위해서 [`reqwest`](https://docs.rs/reqwest/)와 같은 HTTP 클라이언트가 필"
"요합니다. 새로운 로컬 프로젝트를 만들고 [`reqwest`](https://docs.rs/reqwest/)"
"를 의존성에 추가하십시요:"

#: src/exercises/concurrency/link-checker.md:17
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"만일 `cargo add` 커맨드가 `error: no such subcommand` 로 실패한다면 `Cargo."
"toml` 파일을 직접 수정해도 됩니다. 아래에 전체 의존성 내용이 있습니다."

#: src/exercises/concurrency/link-checker.md:20
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr "링크를 찾기 위해서 [`scraper`](https://docs.rs/scraper/)도 추가합니다:"

#: src/exercises/concurrency/link-checker.md:26
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"마지막으로 오류 처리하는 방법으로 [`thiserror`](https://docs.rs/thiserror/)"
"도 추가합니다:"

#: src/exercises/concurrency/link-checker.md:33
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "모든 `cargo add`가 끝나면 `Cargo.toml`에 아래 내용이 추가됩니다:"

#: src/exercises/concurrency/link-checker.md:37
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:50
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr "이제 `https://www.google.org/` 같은 웹 페이지를 탐색할 수 있습니다."

#: src/exercises/concurrency/link-checker.md:53
msgid "Your `src/main.rs` file should look something like this:"
msgstr "`rc/main.rs`파일은 아래와 같습니다:"

#: src/exercises/concurrency/link-checker.md:65
#: src/exercises/concurrency/solutions-morning.md:97
msgid "\"request error: {0}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:67
#: src/exercises/concurrency/solutions-morning.md:99
msgid "\"bad http response: {0}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:78
#: src/exercises/concurrency/solutions-morning.md:110
msgid "\"Checking {:#}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:96
#: src/exercises/concurrency/solutions-morning.md:128
msgid "\"href\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:103
#: src/exercises/concurrency/solutions-morning.md:135
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:112
#: src/exercises/concurrency/solutions-morning.md:245
msgid "\"https://www.google.org\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:115
msgid "\"Links: {links:#?}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:116
msgid "\"Could not extract links: {err:#}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:121
msgid "Run the code in `src/main.rs` with"
msgstr "아래 커맨드로 소스를 실행합니다"

#: src/exercises/concurrency/link-checker.md:129
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"스레드를 사용하여 링크를 병렬로 확인합니다: URL을 채널로 보내서 몇 개의 스레"
"드가 URL을 병렬로 체크하도록 합니다."

#: src/exercises/concurrency/link-checker.md:131
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"`www.google.org`도메인의 모든 페이지를 재귀적으로 확인하기 위해 코드를 확장해"
"서 작성합니다: 차단당하지 않도록 100페이지 정도로 제한을 두시기 바랍니다."

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "Concurrency Morning Exercise"
msgstr "3일차 오전 연습문제"

#: src/exercises/concurrency/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:29
msgid "\"{} is trying to eat\""
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:53
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:77
msgid "\"{thought}\""
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:82
#, fuzzy
msgid "Link Checker"
msgstr "멀티스레드 링크 검사기"

#: src/exercises/concurrency/solutions-morning.md:84
msgid "([back to exercise](link-checker.md))"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:154
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:162
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:188
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:229
msgid "\"Got crawling error: {:#}\""
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:247
msgid "\"Bad URLs: {:#?}\""
msgstr ""

#: src/async.md:1
#, fuzzy
msgid "Async Rust"
msgstr "비동기"

#: src/async.md:3
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"\"Async\"는 블럭될(더 이상 진행할 수 없을) 때까지 각 작업을 실행한 다음 진행"
"할 준비가 된 다른 작업으로 전환하여 여러 작업을 동시에 실행하는 동시 실행 모"
"델입니다. 이 모델을 사용하면 제한된 수의 스레드에서 더 많은 작업을 실행할 수 "
"있습니다. 이는, 한 작업을 유지하고 수행하는데 필요한 오버헤드가 (스레드에 비"
"해) 매우 낮고 운영체제가 여러 I/O들에서 현재 진행 가능한 I/O들을 효과적으로 "
"식별해 주는 프리미티브를 제공하기 때문입니다."

#: src/async.md:10
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Rust의 비동기 작업은 \"futures\"를 기반으로 하며 이는 미래에 완료될 수 있는 "
"작업을 나타냅니다. Futures는 완료되었다는 신호를 보낼 때까지 \"폴링\"됩니다."

#: src/async.md:14
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"Futures는 비동기 런타임에 의해 폴링되며, 비동기 런타임에는 여러 다양한 종류"
"가 있습니다."

#: src/async.md:19
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"파이썬에도 `asyncio`라는 유사한 모델이 있습니다. 그러나 파이썬의 `Future` 타"
"입은 콜백 기반이며 폴링되지 않습니다. 파이썬으로 비동기 프로그래밍을 할 때에"
"는, Rust에서 런타임이 내부적으로 해 주는 것과 유사한,  \"루프\"를 명시적으로 "
"사용해야 합니다."

#: src/async.md:23
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"자바스크립트의 `Promise`도 비슷하지만 역시 콜백 기반입니다. 자바스크립트에서"
"는 이벤트 루프가런타임 엔진에서 구현되므로 `Promise`가 처리되는 세부 과정이 "
"숨겨집니다."

#: src/async/async-await.md:3
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"겉에서 보았을 때, 비동기 Rust 코드는 일반적인 절차적 코드와 매우 유사합니다."

#: src/async/async-await.md:10
msgid "\"Count is: {i}!\""
msgstr ""

#: src/async/async-await.md:27
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"Rust 비동기 문법을 보여주는 간단한 예시입니다. 여기에는 오래 실행되는 작업이"
"나, 실제로 동시에 수행되는 것들은 없습니다."

#: src/async/async-await.md:30
msgid "What is the return type of an async call?"
msgstr "`async`함수의 리턴 타입은 무엇인가요?"

#: src/async/async-await.md:31
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"`main`에서 \\`let future: () = async_main(10);을 사용하여 타입을 확인하세요."

#: src/async/async-await.md:33
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr ""
"\"async\" 키워드는 문법 설탕(syntactic sugar)입니다. 컴파일러가 리턴 타입을 "
"future로 바꿉니다. "

#: src/async/async-await.md:36
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"`main`을 비동기 함수로 만들수는 없습니다. 만약 그렇게 할 경우 컴파일러는 리"
"턴 타입인 future를 어떻게 사용할 지 모르기 때문입니다."

#: src/async/async-await.md:39
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"비동기 코드를 실행하려면 실행자(executor)가 필요합니다. `block_on` 실행자는 "
"제공된 future가 완료될 때까지 현재 스레드를 블록합니다. "

#: src/async/async-await.md:42
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await`는 다른 작업이 완료될 때까지 비동기적으로 대기합니다. `block_on`과 달"
"리 `.await`는 현재 스레드를 블록하지 않습니다."

#: src/async/async-await.md:45
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr ""
"`.await`는 `async` 함수(또는 나중에 소개될 `async` 블록) 안에서만 사용할 수 "
"있습니다. "

#: src/async/futures.md:3
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)는 트레잇입"
"니다.이 트레잇은 아직 완료되지 않았을 수도 있는 작업을 나타냅니다. Future는 "
"`poll` 함수를 통해 폴링될 수 있으며, 이 함수는 [`Poll`](https://doc.rust-"
"lang.org/std/task/enum.Poll.html)을 반환합니다."

#: src/async/futures.md:23
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"비동기 함수는 `impl Future`를 반환합니다. 새로운 타입을 만들고 이 타입이 "
"`Future`를 구현하게 할 수도 있지만 일반적이지는 않습니다. 예를 들어 `tokio::"
"spawn`가 리턴하는 `JoinHandle`은 `Future`를 구현하며, 이를 통해 생성된 스레드"
"에 join할 수 있습니다."

#: src/async/futures.md:27
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"Future에 `.await`를 호출하면, 해당 Future가 준비될 때까지 현재 비동기 함수가 "
"일시 중지됩니다. 그런 다음 Future가 준비가 되면, 그 값이 `.await` 구문의 값"
"이 됩니다."

#: src/async/futures.md:32
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"`Future` 와 `Poll` 타입의 실제 정의는 위에 보이는 그대로 입니다. 링크를 클릭"
"하면 Rust 문서에서 한 번 더 확인할 수 있습니다."

#: src/async/futures.md:35
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"본 강의의 목적은 비동기 코드를 작성하는데 있기 때문에, 새로운 비동기 프리미티"
"브를 만드는데 필요한  `Pin`과 `Context`는 다루지 않습니다. 이들에 대해 간단"
"히 설명하자면:"

#: src/async/futures.md:38
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context`를 사용하면 Future가 이벤트가 발생할 때 다시 폴링되도록 예약할 수 있"
"습니다."

#: src/async/futures.md:41
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"'Pin'을 사용하면 메모리에서 Future의 위치가 고정되기 때문에 해당 future의 포"
"인터가 항상 유효하게 유지됩니다. 이는 `.await` 후에 참조를 유효한 상태로 유지"
"하기 위해 필요합니다."

#: src/async/runtimes.md:3
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"비동기 _런타임_은 _리액터_ (비동기식 작업 실행을 지원)와 _실행자_ (futures를 "
"실행)의 두 가지 역할을 합니다. Rust 언어 자체에서 기본 제공하는 비동기 런타임"
"은 없습니다. 그러나 다음과 같은 비동기 런타임 크레잇들이 있습니다."

#: src/async/runtimes.md:7
#, fuzzy
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/) - 성능이 우수합니다. 그리고 HTTP를 지원하는 "
"[Hyper](https://hyper.rs/) 와 gRPC를 지원하는 [Tonic](https://github.com/"
"hyperium/tonic)과 같은 잘 발달된 라이브러리 생태계가 있습니다."

#: src/async/runtimes.md:10
#, fuzzy
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/) - 비동기에서의 `std`를 목표로 하고 있습니다. "
"`async::task`에 기본 런타임이 포함되어 있습니다."

#: src/async/runtimes.md:12
#, fuzzy
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/) - 간단하고 가볍습니다."

#: src/async/runtimes.md:14
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"여러 대규모 애플리케이션에는 자체 런타임이 있는 경우도 있습니다. 예들 들어  "
"[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/"
"fuchsia-async/src/lib.rs)가 있습니다."

#: src/async/runtimes.md:20
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"Rust 플레이그라운드에서는 위에 나열된 비동기 런타임 중에서 Tokio만 사용할 수 "
"있습니다. 또한 Rust 플레이그라운드는 I/O를 허용하지 않으므로 async를 가지고 "
"할 수 있는 많은 흥미로운 작업들이 불가능 합니다."

#: src/async/runtimes.md:24
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Futures는 실행자가 폴링하지 않는 한 아무것도 하지 않는다는 점에서(I/O 작업조"
"차 시작하지 않음) \"비활성\" 상태입니다. 이는 사용되지 않는 경우에도 완료될 "
"때 까지 실행되는, 자바 스크립트의 promise와 다릅니다."

#: src/async/runtimes/tokio.md:3
#, fuzzy
msgid "Tokio provides:"
msgstr "Tokio는 다음을 제공합니다. "

#: src/async/runtimes/tokio.md:5
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr "비동기 코드 실행을 위한 멀티스레드 런타임"

#: src/async/runtimes/tokio.md:6
msgid "An asynchronous version of the standard library."
msgstr "표준 라이브러리의 비동기 버전"

#: src/async/runtimes/tokio.md:7
msgid "A large ecosystem of libraries."
msgstr "대규모 라이브러리 생태계"

#: src/async/runtimes/tokio.md:14
msgid "\"Count in task: {i}!\""
msgstr ""

#: src/async/runtimes/tokio.md:24
msgid "\"Main task: {i}\""
msgstr ""

#: src/async/runtimes/tokio.md:32
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr ""
"이제 `tokio::main` 매크로를 사용하면 `main`을 비동기로 만들 수 있습니다."

#: src/async/runtimes/tokio.md:34
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "`spawn` 함수는 동시 실행되는 새로운 \"작업\"을 만듭니다."

#: src/async/runtimes/tokio.md:36
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"참고: `spawn`은 `Future`를 인자로 받습니다. 때문에 `count_to`에 `.await`를 호"
"출하지 않는 점을 주목하세요."

#: src/async/runtimes/tokio.md:38
msgid "**Further exploration:**"
msgstr "**심화 학습:**"

#: src/async/runtimes/tokio.md:40
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"`count_to`가 10에 도달하지 않는 경우가 많은데 그 이유는 무엇일까요? 이는 비동"
"기적인 취소를 보여주는 예입니다. `tokio::spawn`이 리턴하는 것은 완료될 때까"
"지 기다리도록 대기하는데 사용되는 핸들입니다."

#: src/async/runtimes/tokio.md:44
msgid "Try `count_to(10).await` instead of spawning."
msgstr "`tokio::spawn` 대신 `count_to(10).await`를 사용해 보세요."

#: src/async/runtimes/tokio.md:46
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "`tokio::spawn`에서 반환된 작업을 `await` 해 보세요."

#: src/async/tasks.md:3
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust의 태스크(작업) 시스템은 경량 스레딩의 한 종류로 볼 수 있습니다."

#: src/async/tasks.md:5
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"하나의 작업에는, 실행자가 이 작업을 진행하기 위해 계속 폴링하는, 최상위 "
"future가 한 개 있습니다. 이 future에는 `poll` 메서드가 폴링하는 중첩된 future"
"가 한 개 이상 있을 수 있습니다. 이러한 중첩된 future는 일반적인 함수 호출 스"
"택하고 비슷한 역할을 합니다. 한 작업 안에서 여러 자식 future들을 폴링하면, 타"
"이머를 켜는 것과 어떤 I/O작업을 동시에 수행시킨 후 타이머와 I/O 중 먼저 끝나"
"는 것을 기다리는 것과 같은동시성도 구현할 수 있습니다."

#: src/async/tasks.md:16
msgid "\"127.0.0.1:0\""
msgstr ""

#: src/async/tasks.md:17
msgid "\"listening on port {}\""
msgstr ""

#: src/async/tasks.md:22
msgid "\"connection from {addr:?}\""
msgstr ""

#: src/async/tasks.md:25
msgid "b\"Who are you?\\n\""
msgstr ""

#: src/async/tasks.md:25 src/async/tasks.md:28 src/async/tasks.md:31
msgid "\"socket error\""
msgstr ""

#: src/async/tasks.md:30
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr ""

#: src/async/tasks.md:39 src/async/control-flow/join.md:36
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"이 예제를, 로컬 컴퓨터에 만들어 둔 `src/main.rs`에 복사하고 거기에서 실행하세"
"요."

#: src/async/tasks.md:41
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""

#: src/async/tasks.md:45
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"수강생들에게 이 서버에 몇 개의 클라이언트가 연결되면 이 서버의 상태가 어떻게 "
"변할지 그림을 그려보도록 하세요. 어떤 태스크들이 있는지, 이 태스크들의 Future"
"는 어떤 상태에 있는지 물어봅니다."

#: src/async/tasks.md:48
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"`async` 블록을 처음 보게 되었습니다. 이것은 클로저와 비슷하지만 인자를 받지 "
"않습니다. 리턴 타입은 `async fn`과 비슷한 Future입니다. "

#: src/async/tasks.md:52
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"Async 블록을 함수로 리팩터링하고 `?`를 사용하여 오류 처리를 개선해 봅시다."

#: src/async/channels.md:3
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"여러 크레이트에서 비동기 채널을 지원합니다. 예를 들어 `tokio`에서는 아래와 같"
"이합니다."

#: src/async/channels.md:13
msgid "\"Received {count} pings so far.\""
msgstr ""

#: src/async/channels.md:16
msgid "\"ping_handler complete\""
msgstr ""

#: src/async/channels.md:24
msgid "\"Failed to send ping.\""
msgstr ""

#: src/async/channels.md:25
msgid "\"Sent {} pings so far.\""
msgstr ""

#: src/async/channels.md:29
msgid "\"Something went wrong in ping handler task.\""
msgstr ""

#: src/async/channels.md:35
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr "채널 크기를 `3`으로 변경하고 동작이 어떻게 바뀌는지 확인하세요."

#: src/async/channels.md:37
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"비동기 채널을 사용하기 위한 인터페이스는 [오전 과정](concurrency/channels.md)"
"에서 배운 `sync` 채널과 비슷합니다."

#: src/async/channels.md:40
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr ""
"`std::mem::drop` 호출하는 줄을 삭제해 보세요. 어떤 결과가 나타나나요? 이유가 "
"무엇인가요?"

#: src/async/channels.md:42
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"[Flume](https://docs.rs/flume/latest/flume/) 크레이트에는 `sync`와 `async`, "
"`send`와 `recv`를 모두 구현하는 채널이 있습니다. 이것은 IO와 CPU 처리 작업이 "
"많은 복잡한 애플리케이션을 구현할 때 매우 유용합니다."

#: src/async/channels.md:46
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"`async` 채널을 사용하는 것이 더 좋은 이유는 이를 다른 `future`와 결합하여 복"
"잡한 제어 흐름을 만들 수 있기 때문입니다."

#: src/async/control-flow.md:1
#, fuzzy
msgid "Futures Control Flow"
msgstr "흐름 제어"

#: src/async/control-flow.md:3
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""
"Future들을 결합하여 계산 과정을 동시성이 있는 플로우 그래프 형태로 모델링 할 "
"수 있습니다. 앞서 배운,  각 태스크가 독립적으로 수행되도록 하는 것도 Future들"
"을 결합하는 한 방법으로 볼 수 있습니다."

#: src/async/control-flow.md:6
msgid "[Join](control-flow/join.md)"
msgstr "[Join](control-flow/join.md)"

#: src/async/control-flow.md:7
msgid "[Select](control-flow/select.md)"
msgstr "[Select](control-flow/select.md)"

#: src/async/control-flow/join.md:3
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"Join 연산은 모든 future가 준비될 때까지 기다린 후, 각 future의 결과값을 담은 "
"컬렉션을 리턴합니다. 이는 자바스크립트의 `Promise.all`이나 파이썬의 `asyncio."
"gather`와 유사합니다."

#: src/async/control-flow/join.md:21
msgid "\"https://google.com\""
msgstr ""

#: src/async/control-flow/join.md:22
msgid "\"https://httpbin.org/ip\""
msgstr ""

#: src/async/control-flow/join.md:23
msgid "\"https://play.rust-lang.org/\""
msgstr ""

#: src/async/control-flow/join.md:24
msgid "\"BAD_URL\""
msgstr ""

#: src/async/control-flow/join.md:38
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"서로 다른 타입을 가지는 여러 여러 futures들을 join하고자 할 경우 `std::"
"future::join!`을 사용할 수 있습니다. 이 매크로를 사용하려면 futures가 몇 개"
"나 있을지 컴파일 할 때 알아야 한다는 점을 주의하세요. 이 매크로는 지금은 "
"'futures' 크레이트에 있으며 곧 안정화 되어 `std::future`에 포함될 예정입니다."

#: src/async/control-flow/join.md:42
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"'join'의 위험성은 futures들 중 하나가 영영 끝나지 않을 수도 있다는 것입니다. "
"그러면 프로그램이 더이상 진행을 못하고 멈춰있을(stall) 수 있습니다. "

#: src/async/control-flow/join.md:45
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"`join_all`을 `join!`과 결합하여 http 서비스와 데이터베이스에 대한 모든 요청들"
"을 한꺼번에 진행시킬 수도 있습니다. `futures::join!`을 사용하여 `tokio::"
"time::sleep`을 future에 추가해 보세요. 이건 타임아웃을 구현하는 것이 아님을 "
"주의하세요.  실제로, 타임아웃은 다음 장에서 설명하는 `select!`를 사용해서 구"
"현해야 합니다.  여기서는 `tokio::time::sleep`을 사용한 것은 단순히 `join!`의 "
"동작을 설명하기 위함입니다."

#: src/async/control-flow/select.md:3
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"Select 연산은 여러 future들 모두에 대해서 준비될 때 까지 기다리다가, 그 중 어"
"떤 한 future가 최초로 준비 상태가 되면 해당 future의 결과값을 리턴합니다.  이"
"것은 자바스크립트에서의 `Promise.race`와 비슷합니다. 파이썬에서라면 `asyncio."
"wait(task_set, return_when=asyncio.FIRST_COMPLETED)`가 하는 동작과 비슷합니"
"다."

#: src/async/control-flow/select.md:8
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When the `future` is "
"ready, the `statement` is executed with the variables in `pattern` bound to "
"the `future`'s result."
msgstr ""
"`select!` 안에는, `match`문과 비슷하게, `pattern = future => statement` 형태"
"의 브랜치(arm) 들이 있습니다. 어떤 'future'가 진행 가능 상태가 되면 '그 "
"`future`의 결과값이 `pattern`으로 바인딩 되며, 그 상태에서 \\`statement'가 수"
"행됩니다."

#: src/async/control-flow/select.md:39
msgid "\"Felix\""
msgstr ""

#: src/async/control-flow/select.md:39
msgid "\"Failed to send cat.\""
msgstr ""

#: src/async/control-flow/select.md:43
msgid "\"Rex\""
msgstr ""

#: src/async/control-flow/select.md:43
msgid "\"Failed to send dog.\""
msgstr ""

#: src/async/control-flow/select.md:48
msgid "\"Failed to receive winner\""
msgstr ""

#: src/async/control-flow/select.md:50
msgid "\"Winner is {winner:?}\""
msgstr ""

#: src/async/control-flow/select.md:56
#, fuzzy
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"이 예제에서는 고양이와 개를 경주시켰습니다(동시에 시작시킨 후, 둘 중 먼저 끝"
"나는 쪽이 이김). `first_animal_to_finish_race`함수는 두 채널 모두에 귀기울이"
"고(listen하고) 있다가, 메시지가 먼저 도착한 채널을 선택합니다. 개는 50ms만에 "
"작업을 끝내고 고양이는 500ms가 걸리기 때문에, 개가 이깁니다."

#: src/async/control-flow/select.md:61
#, fuzzy
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"이 예제에서는 `oneshot` 채널을 사용하는 것이 더 좋은 디자인 입니다. 각 채널"
"이 한 번의 `send`만 수신해야 하는 것이 보장되기 때문입니다."

#: src/async/control-flow/select.md:64
#, fuzzy
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"이 경주에 타임아웃을 추가해서, 서로 다른 종류의 futures들을 동시에 `select`"
"할 수 있음을 확인해 보세요."

#: src/async/control-flow/select.md:67
#, fuzzy
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"`select!`는 매칭되지 않은 다른 모든 브랜치에 대해 drop을 수행합니다. 따라서 "
"경쟁에서 진 모든 future들은  취소(cancel) 됩니다. `select!`를 실행할 때마다 "
"새로운 futures가 만들어지는 경우라면, 이러한 점이 매우 편하게 느껴질 것입니"
"다. Future가 취소되는 것을 막기 위해 future를 직접 전달하는 대신 `&mut "
"future`를 전달하는 것도 가능합니다.  하지만 이렇게 하면 문제가 발생할 수 있습"
"니다 (왜 그런지는 `Pin`설명할 때 자세히 설명하겠습니다)."

#: src/async/control-flow/select.md:70
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""

#: src/async/pitfalls.md:1
msgid "Pitfalls of async/await"
msgstr "async/await에서 주의해야할 함정"

#: src/async/pitfalls.md:3
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"Async와 await는 동시 비동기 프로그래밍을 위한 편리하고 효율적인 추상화를 제공"
"합니다. 하지만 Rust의 async/await 모델에도 문제는 있습니다. 이 장에서 몇 가"
"지 예를 살펴보겠습니다."

#: src/async/pitfalls.md:7
#, fuzzy
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr "[실행자 차단](pitfalls/blocking-executor.md)"

#: src/async/pitfalls.md:8
#, fuzzy
msgid "[Pin](pitfalls/pin.md)"
msgstr "[고정](pitfalls/pin.md)"

#: src/async/pitfalls.md:9
#, fuzzy
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr "[비동기 트레잇](pitfall/async-traits.md)"

#: src/async/pitfalls.md:10
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:1
msgid "Blocking the executor"
msgstr "실행자(executor)를 블록시킴"

#: src/async/pitfalls/blocking-executor.md:3
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"대부분의 비동기 런타임은 IO 작업만 동시에 실행되도록 허용합니다. 즉, CPU를 블"
"럭하는 태스크가 있는 경우, 이는 실행자(executor)를 블럭하게 되며, 그 결과로 "
"다른 태스크가 실행되지 않습니다. 이 문제를 해결하는 간단한 방법은, 항상 async"
"를 지원하는 메서드를 사용하는 것입니다."

#: src/async/pitfalls/blocking-executor.md:14
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr ""

#: src/async/pitfalls/blocking-executor.md:19
msgid "\"current_thread\""
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"코드를 실행하여 sleep들이 동시에 진행되지 않고 순차적으로으로 진행되는지 확인"
"하세요."

#: src/async/pitfalls/blocking-executor.md:32
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"`flavor`를 `\"current_thread\"` 로 설정하면 모든 태스크가 하나의 스레드에서 "
"수행됩니다. 이렇게 하면 문제 상황이 더 분명히 드러납니다. 그러나 이 버그는 멀"
"티스레드인 경우에도 여전히 존재합니다."

#: src/async/pitfalls/blocking-executor.md:36
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"`std::thread::sleep`을 `tokio::time::sleep`으로 바꾸고 그 결과를 `await`해 보"
"세요."

#: src/async/pitfalls/blocking-executor.md:38
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"또 다른 해결 방법은 `tokio::task::spawn_blocking`입니다. 이는 실제 스레드를 "
"생성하고, 그 스레드에 대한 핸들을 future로 변환함으로써 실행자가 블록되는 것"
"을 막습니다."

#: src/async/pitfalls/blocking-executor.md:41
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"태스크를 OS 스레드라고 생각하면 안 됩니다. 태스크와 OS스레드는 일대일 매핑 관"
"계에 있지 않습니다. 대부분의 실행자는 하나의 OS 스레드에서 최대한 많은 태스크"
"를 수행하도록 설계되어 있습니다. 이점은 FFI를 통해 다른 라이브러리와 상호작용"
"할 때 특히 문제가 됩니다. 예를 들어, 해당 라이브러리가 스레드 로컬 저장소를 "
"이용하거나 특정 OS 스레드에 매핑될 수 있습니다(예: CUDA). 이러한 상황에서는 "
"`tokio::task::spawn_blocking`을 사용하는 것이 좋습니다."

#: src/async/pitfalls/blocking-executor.md:47
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"동기화 뮤텍스를 주의해서 사용하세요. `.await` 위에 뮤텍스를 적용하면 다른 작"
"업이 차단될 수 있으며 해당 작업은 동일한 스레드에서 실행 중일 수 있습니다."

#: src/async/pitfalls/pin.md:3
msgid ""
"When you await a future, all local variables (that would ordinarily be "
"stored on a stack frame) are instead stored in the Future for the current "
"async block. If your future has pointers to data on the stack, those "
"pointers might get invalidated. This is unsafe."
msgstr ""
"Future에 대해 `await`를 호출하여 그 future가 준비되기를 기다릴 때, 모든 로컬 "
"변수(일반적으로 스택 프레임에 저장됨)는 그 future객체 안에 저장됩니다.  만약 "
"그 future에 스택에 있는 어떤 데이터로의 포인터가 있으면 이러한 포인터는 올바"
"르지 않을 수 있습니다. 안전하지 않습니다."

#: src/async/pitfalls/pin.md:8
#, fuzzy
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't "
"change. That is why we need to \"pin\" futures. Using the same future "
"repeatedly in a `select!` often leads to issues with pinned values."
msgstr ""
"따라서 future가 가리키는 주소가 변경되지 않도록 해야 합니다. 이것이 future를 "
"`pin`(고정)해야 하는 이유입니다. `select!`에서 동일한 future를 반복적으로 사"
"용하면 고정 값 문제가 발생하는 경우가 많습니다."

#: src/async/pitfalls/pin.md:16
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""

#: src/async/pitfalls/pin.md:24
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr ""

#: src/async/pitfalls/pin.md:31
msgid "// Pretend to work.\n"
msgstr ""

#: src/async/pitfalls/pin.md:34
msgid "\"failed to send response\""
msgstr ""

#: src/async/pitfalls/pin.md:37
msgid "// TODO: report number of iterations every 100ms\n"
msgstr ""

#: src/async/pitfalls/pin.md:41
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr ""

#: src/async/pitfalls/pin.md:48
msgid "\"failed to send on work queue\""
msgstr ""

#: src/async/pitfalls/pin.md:49
msgid "\"failed waiting for response\""
msgstr ""

#: src/async/pitfalls/pin.md:58
msgid "\"work result for iteration {i}: {resp}\""
msgstr ""

#: src/async/pitfalls/pin.md:65
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"위에서 소개한 것은 액터(actor) 패턴의 한 예라고 봐도 무방합니다. 액터는 일반"
"적으로 루프 안에서 `select!`를 호출합니다."

#: src/async/pitfalls/pin.md:68
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr "이전 강의 몇 개의 내용을 요약한 것이기 때문에 천천히 살펴보세요."

#: src/async/pitfalls/pin.md:71
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"`_ = sleep(Duration::from_millis(100)) => { println!(..) }`을 `select!`에 추"
"가해 보세요. 이 작업은 실행되지 않습니다. 왜 그럴까요?"

#: src/async/pitfalls/pin.md:74
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"대신, 해당 future가 포함된 `timeout_fut`를 `loop` 외부에 추가해 보세요."

#: src/async/pitfalls/pin.md:85
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"여전히 작동하지 않습니다. 컴파일러 오류를 따라 `select!`의 `timeout_fut`에 "
"`&mut`를 추가하여 Move 시멘틱 관련한 문제를 해결하고 `Box::pin`을 사용하세요."

#: src/async/pitfalls/pin.md:99
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"이는 컴파일은 되지만 타임 아웃이 되면 매번 반복할 때 마다 `Poll::Ready`가 됩"
"니다(융합된 future가 도움이 될 수 있음). 타임 아웃 될 때마다 `timeout_fut`를 "
"리셋하도록 수정하세요."

#: src/async/pitfalls/pin.md:103
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box는 힙에 할당합니다. 경우에 따라 `std::pin::pin!`(최근에야 안정화되었으며 "
"이전 코드는 `tokio::pin!`을 사용하는 경우가 많음)도 사용할 수 있지만 이는 재"
"할당된 future에 사용하기가 어렵습니다."

#: src/async/pitfalls/pin.md:107
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"또 다른 방법은 `pin`을 아예 사용하지 않고 100ms마다 `oneshot` 채널에 전송할 "
"다른 작업을 생성하는 것입니다."

#: src/async/pitfalls/async-traits.md:3
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"트레잇에 async 메소드를 추가하는 것은 아직 안정화 버전 채널에서 지원되지 않습"
"니다([실험용 기능은 nightly에 존재하며 조만간 안정화 될 것입니다](https://"
"blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html))."

#: src/async/pitfalls/async-traits.md:6
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"크레이트 [async_trait](https://docs.rs/async-trait/latest/async_trait/)은 매"
"크로를 통한 해결 방법을 제공합니다."

#: src/async/pitfalls/async-traits.md:35
msgid "\"running all sleepers..\""
msgstr ""

#: src/async/pitfalls/async-traits.md:39
msgid "\"slept for {}ms\""
msgstr ""

#: src/async/pitfalls/async-traits.md:56
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait`은 사용하기 쉽지만 이를 위해 힙에 메모리를  할당한다는 점에 유의"
"하세요. 이 힙 할당에는 성능 오버헤드가 있습니다."

#: src/async/pitfalls/async-traits.md:59
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"`async trait` 를 언어 차원에서 지원하는 것과 관련된 문제는 매우 전문적인 토픽"
"이며 따라서 이 강의에서 다룰 내용은 아닙니다. [이 게시물](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/)에 이에 관한 니코 마사키스의 좋은 설명이 있으므로 관심이 있다면 참고하"
"세요."

#: src/async/pitfalls/async-traits.md:65
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"임의의 시간 동안 sleep 하는 새로운 sleeper 구조체를 만들어 Vec에 추가해 보세"
"요."

#: src/async/pitfalls/cancellation.md:3
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""

#: src/async/pitfalls/cancellation.md:35
#, fuzzy
msgid "\"not UTF-8\""
msgstr "UTF-8"

#: src/async/pitfalls/cancellation.md:51
msgid "\"hi\\nthere\\n\""
msgstr ""

#: src/async/pitfalls/cancellation.md:57
msgid "\"tick!\""
msgstr ""

#: src/async/pitfalls/cancellation.md:72
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""

#: src/async/pitfalls/cancellation.md:75
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""

#: src/async/pitfalls/cancellation.md:78
msgid "The example loses parts of the string."
msgstr ""

#: src/async/pitfalls/cancellation.md:80
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""

#: src/async/pitfalls/cancellation.md:83
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""

#: src/async/pitfalls/cancellation.md:97
msgid "// prefix buf and bytes with self.\n"
msgstr ""

#: src/async/pitfalls/cancellation.md:106
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""

#: src/async/pitfalls/cancellation.md:110
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""

#: src/async/pitfalls/cancellation.md:113
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""

#: src/exercises/concurrency/afternoon.md:3
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""

#: src/exercises/concurrency/afternoon.md:8
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:1
#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "식사하는 철학자들"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"이번 훈련에서는 [카고 설치하기](../../cargo/running-locally.md)가 필요합니"
"다. 아래 코드를 복사해서 `src/main.rs`에 붙여놓고 빈 부분을 채우고, `cargo "
"run` 커맨드로 테스트 해서 교착상태(데드락)가 발생하지 않는지 확인합니다:"

#: src/exercises/concurrency/dining-philosophers-async.md:52
#: src/exercises/concurrency/solutions-afternoon.md:78
msgid "// Make them think and eat\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:58
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:63
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:73
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:78
msgid "Can you make your implementation single-threaded?"
msgstr ""

#: src/exercises/concurrency/chat-app.md:3
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""

#: src/exercises/concurrency/chat-app.md:9
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""

#: src/exercises/concurrency/chat-app.md:12
msgid "Create a new Cargo project and add the following dependencies:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:14
msgid "_Cargo.toml_:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:18
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.0.0\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.5.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:31
msgid "The required APIs"
msgstr ""

#: src/exercises/concurrency/chat-app.md:33
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""

#: src/exercises/concurrency/chat-app.md:37
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""

#: src/exercises/concurrency/chat-app.md:39
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""

#: src/exercises/concurrency/chat-app.md:41
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""

#: src/exercises/concurrency/chat-app.md:43
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""

#: src/exercises/concurrency/chat-app.md:45
#, fuzzy
msgid "Two binaries"
msgstr "러스트 바이너리"

#: src/exercises/concurrency/chat-app.md:47
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""

#: src/exercises/concurrency/chat-app.md:54
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""

#: src/exercises/concurrency/chat-app.md:58
#: src/exercises/concurrency/solutions-afternoon.md:99
#, fuzzy
msgid "_src/bin/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/exercises/concurrency/chat-app.md:77
#: src/exercises/concurrency/chat-app.md:124
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr ""

#: src/exercises/concurrency/chat-app.md:85
#: src/exercises/concurrency/solutions-afternoon.md:147
msgid "\"127.0.0.1:2000\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:86
#: src/exercises/concurrency/solutions-afternoon.md:148
msgid "\"listening on port 2000\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:90
#: src/exercises/concurrency/solutions-afternoon.md:152
msgid "\"New connection from {addr:?}\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:93
#: src/exercises/concurrency/solutions-afternoon.md:155
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr ""

#: src/exercises/concurrency/chat-app.md:102
#: src/exercises/concurrency/solutions-afternoon.md:164
#, fuzzy
msgid "_src/bin/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/exercises/concurrency/chat-app.md:116
#: src/exercises/concurrency/solutions-afternoon.md:176
msgid "\"ws://127.0.0.1:2000\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:129
#, fuzzy
msgid "Running the binaries"
msgstr "강의 진행 방식"

#: src/exercises/concurrency/chat-app.md:131
#, fuzzy
msgid "Run the server with:"
msgstr "아래 명령어로 예제 코드를 실행하세요."

#: src/exercises/concurrency/chat-app.md:137
#, fuzzy
msgid "and the client with:"
msgstr "아래 명령어로 예제 코드를 실행하세요."

#: src/exercises/concurrency/chat-app.md:145
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr ""

#: src/exercises/concurrency/chat-app.md:146
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""

#: src/exercises/concurrency/chat-app.md:149
msgid "Complete the main function in `src/bin/client.rs`."
msgstr ""

#: src/exercises/concurrency/chat-app.md:150
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""

#: src/exercises/concurrency/chat-app.md:154
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "Concurrency Afternoon Exercise"
msgstr "1일차 오후 연습문제"

#: src/exercises/concurrency/solutions-afternoon.md:5
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:33
msgid ""
"// Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:41
msgid "// The locks are dropped here\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:61
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:75
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:90
msgid "\"Here is a thought: {thought}\""
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:97
msgid "([back to exercise](chat-app.md))"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:116
msgid "\"Welcome to chat! Type a message\""
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:119
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:128
msgid "\"From client {addr:?} {text:?}\""
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:183
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:190
msgid "\"From server: {}\""
msgstr ""

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"Comprehensive Rust 🦀를 이용해 주셔서 감사합니다. 즐겁고 유익한 시간이었기를 "
"바랍니다."

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"강의가 완벽하진 않으니 실수나 개선점이 있다면 언제든지 [깃허브](https://"
"github.com/google/comprehensive-rust/discussions)로 연락주세요."

#: src/glossary.md:3
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""

#: src/glossary.md:30
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""

#: src/glossary.md:32
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""

#: src/glossary.md:34
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""

#: src/glossary.md:37
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""

#: src/glossary.md:39
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""

#: src/glossary.md:41
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""

#: src/glossary.md:43
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""

#: src/glossary.md:45
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""

#: src/glossary.md:48
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""

#: src/glossary.md:50
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""

#: src/glossary.md:52
msgid ""
"Comprehensive Rust 🦀:  \n"
"The courses here are jointly called Comprehensive Rust 🦀."
msgstr ""

#: src/glossary.md:54
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""

#: src/glossary.md:56
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr ""

#: src/glossary.md:58
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""

#: src/glossary.md:60
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""

#: src/glossary.md:63
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""

#: src/glossary.md:65
msgid ""
"enumeration:  \n"
"A data type that consists of named constant values."
msgstr ""

#: src/glossary.md:67
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""

#: src/glossary.md:69
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""

#: src/glossary.md:72
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""

#: src/glossary.md:74
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""

#: src/glossary.md:76
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""

#: src/glossary.md:79
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""

#: src/glossary.md:82
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""

#: src/glossary.md:84
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""

#: src/glossary.md:87
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""

#: src/glossary.md:90
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""

#: src/glossary.md:92
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""

#: src/glossary.md:96
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""

#: src/glossary.md:98
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""

#: src/glossary.md:101
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""

#: src/glossary.md:104
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""

#: src/glossary.md:106
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""

#: src/glossary.md:109
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""

#: src/glossary.md:111
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""

#: src/glossary.md:114
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""

#: src/glossary.md:117
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""

#: src/glossary.md:120
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""

#: src/glossary.md:122
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""

#: src/glossary.md:125
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""

#: src/glossary.md:127
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""

#: src/glossary.md:130
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""

#: src/glossary.md:132
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""

#: src/glossary.md:135
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""

#: src/glossary.md:138
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""

#: src/glossary.md:140
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""

#: src/glossary.md:143
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 3 of this course."
msgstr ""

#: src/glossary.md:145
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""

#: src/glossary.md:147
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr ""

#: src/glossary.md:149
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""

#: src/glossary.md:152
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""

#: src/glossary.md:154
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""

#: src/glossary.md:156
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""

#: src/glossary.md:159
msgid ""
"string:  \n"
"A data type storing textual data. See [`String` vs `str`](basic-syntax/"
"string-slices.html) for more."
msgstr ""

#: src/glossary.md:162
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""

#: src/glossary.md:165
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""

#: src/glossary.md:168
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""

#: src/glossary.md:170
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""

#: src/glossary.md:173
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""

#: src/glossary.md:176
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""

#: src/glossary.md:179
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""

#: src/glossary.md:182
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""

#: src/glossary.md:185
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""

#: src/glossary.md:188
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""

#: src/glossary.md:190
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""

#: src/glossary.md:193
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe.html)."
msgstr ""

#: src/glossary.md:196
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""

#: src/other-resources.md:1
msgid "Other Rust Resources"
msgstr "러스트 참고 자료"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr "러스트 커뮤니티는 온라인에서 고품질의 무료 소스를 만들었습니다."

#: src/other-resources.md:6
msgid "Official Documentation"
msgstr "공식 문서들"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"러스트 프로젝트에는 참조할 만한 자료가 많습니다. 일반적인 내용을 다루는 몇가"
"지 참고 문서들입니다:"

#: src/other-resources.md:10
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): 러스트에 대"
"한 무료 표준 서적입니다. 언어에 대한 자세한 설명과 사람들이 빌드 할수 있는 몇"
"가지 프로젝트를 포함합니다."

#: src/other-resources.md:13
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): 여러 예제를 통"
"해 러스트의 문법을 보여주며 때때로 코드를 확장하는 약간의 연습문제들이 포함되"
"어 있습니다."

#: src/other-resources.md:17
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): 러스트 표준 라이브러"
"리 전체 문서입니다."

#: src/other-resources.md:19
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): 메모리 모델링과 "
"러스트 문법을 설명하는 문서입니다.(아직 불완전하다함)"

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "좀 더 전문적인 공식 가이드입니다:"

#: src/other-resources.md:24
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): 안전하지 않은 러스"
"트, FFI, raw포인터 작업을 다룹니다."

#: src/other-resources.md:27
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"러스트 북이 작성 된 이후 도입된 새로운 비동기 프로그래밍 모델을 다룹니다."

#: src/other-resources.md:30
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): 운"
"영체제가 없는 임베디드 장치에서의 러스트 사용법을 소개합니다."

#: src/other-resources.md:33
msgid "Unofficial Learning Material"
msgstr "비공식적 학습 자료"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "러스트에 대한 기타 안내서와 튜토리얼의 일부입니다:"

#: src/other-resources.md:37
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): C언어 프로그"
"래머 관점에서 러스트를 다룹니다."

#: src/other-resources.md:39
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): 임베디드 C개발자(펌웨어 개발자)를 위한 러스트 가이드입니다."

#: src/other-resources.md:41
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): 다"
"른 언어(C/C++, Java, Python, Javascript)와의 병렬비교를 사용하여 러스트 문법"
"을 다룹니다."

#: src/other-resources.md:44
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 러스트를 배우는데 도움"
"이 되는 100개 이상의 연습문제"

#: src/other-resources.md:46
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): 러스트 언어의 기본부터 고급을 전부 다루는 일련의 작은 "
"프레젠테이션, 웹 어셈블리, async/await 같은 부분도 함께 다룹니다."

#: src/other-resources.md:50
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/), [Take your first steps with Rust](https://docs.microsoft."
"com/en-us/learn/paths/rust-first-steps/): 첫번째는 35개의 시리즈 영상이며 두"
"번째는 러스트의 문법과 구조를 다루는 11개의 모듈 세트입니다."

#: src/other-resources.md:56
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): 몇가지 유형의 리스트 자료구조를 구현해보면서 러스"
"트의 메모리 관리 규칙들을 깊이있게 탐색합니다."

#: src/other-resources.md:61
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"[Little Book of Rust Books](https://lborb.github.io/book/)에서 더 많은 러스"
"트 북을 확인해보세요."

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"이 자료는 많은 훌륭한 러스트 문서들의 도움을 받아 작성되었습니다. 유용한 자료"
"의 전체 목록은 [other resources](other-resources.md)에서 살펴보시기 바랍니다."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Comprehensive Rust의 자료는 Apache 2.0 라이선스를 따릅니다. 자세한건 "
"[`LICENSE`](../LICENSE) 확인해 보시기 바랍니다."

#: src/credits.md:12
msgid "Rust by Example"
msgstr "Rust by Example"

#: src/credits.md:14
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"일부 예제와 연습문제는 [Rust by Example](https://doc.rust-lang.org/rust-by-"
"example/)을 참조하였습니다. 라이선스 조항을 포함하여 저장소의 `third_party/"
"rust-by-example/` 폴더를 참조하시기 바랍니다."

#: src/credits.md:19
msgid "Rust on Exercism"
msgstr "Rust on Exercism"

#: src/credits.md:21
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"일부 연습문제는 [Rust on Exercism](https://exercism.org/tracks/rust)을 참조하"
"였습니다. 라이선스 조항을 포함하여 저장소의 `third_party/rust-on-exercism/`폴"
"더를 참조하시기 바랍니다."

#: src/credits.md:26
msgid "CXX"
msgstr "CXX"

#: src/credits.md:28
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"4일차 오후 강의 중 [Interoperability with C++](android/interoperability/cpp."
"md)에서는 [CXX](https://cxx.rs/)의 이미지를 사용하였습니다. 라이선스 조항을 "
"포함하여 저장소의 `third_party/cxx/`폴더를 참조하시기 바랍니다."

#~ msgid "Small Example"
#~ msgstr "작은 예제"

#~ msgid "Why Rust?"
#~ msgstr "러스트를 써야하는 이유"

#~ msgid "Compile Time Guarantees"
#~ msgstr "컴파일 시 보장되는 것들"

#~ msgid "Runtime Guarantees"
#~ msgstr "런타임 시 보장되는 것들"

#~ msgid "Modern Features"
#~ msgstr "현대적인 특징"

#~ msgid "Basic Syntax"
#~ msgstr "기본 문법"

#~ msgid "String vs str"
#~ msgstr "String과 str"

#~ msgid "Overloading"
#~ msgstr "오버로딩"

#~ msgid "Arrays and for Loops"
#~ msgstr "배열과 for 반복문"

#~ msgid "Stack vs Heap"
#~ msgstr "스택(Stack)과 힙(Heap)"

#~ msgid "Stack Memory"
#~ msgstr "스택 메모리"

#~ msgid "Manual Memory Management"
#~ msgstr "수동 메모리 관리"

#~ msgid "Scope-Based Memory Management"
#~ msgstr "범위기반 메모리 관리"

#~ msgid "Garbage Collection"
#~ msgstr "가비지 컬렉션"

#~ msgid "Rust Memory Management"
#~ msgstr "러스트의 메모리 관리"

#~ msgid "Comparison"
#~ msgstr "비교"

#~ msgid "Moved Strings in Rust"
#~ msgstr "러스트에서의 문자열 이동"

#~ msgid "Moves in Function Calls"
#~ msgstr "함수 호출에서의 이동(Move)"

#~ msgid "Copying and Cloning"
#~ msgstr "복사와 복제"

#~ msgid "Shared and Unique Borrows"
#~ msgstr "공유와 고유 빌림"

#~ msgid "Storing Books"
#~ msgstr "책 저장하기"

#~ msgid "Iterators and Ownership"
#~ msgstr "반복자와 소유권"

#~ msgid "Field Shorthand Syntax"
#~ msgstr "필드 할당 단축 문법"

#~ msgid "Variant Payloads"
#~ msgstr "데이터를 포함하는 열거형(Variant Payloads)"

#~ msgid "Enum Sizes"
#~ msgstr "열거형의 크기"

#~ msgid "Method Receiver"
#~ msgstr "메서드 리시버(Receiver)"

#~ msgid "Destructuring Structs"
#~ msgstr "구조체 분해(역구조화)"

#~ msgid "Destructuring Arrays"
#~ msgstr "배열 분해(역구조화)"

#~ msgid "Match Guards"
#~ msgstr "매치 가드"

#~ msgid "Points and Polygons"
#~ msgstr "점과 다각형"

#~ msgid "if expressions"
#~ msgstr "if 표현식"

#~ msgid "if let expressions"
#~ msgstr "if let 표현식"

#~ msgid "while expressions"
#~ msgstr "while 표현식"

#~ msgid "for expressions"
#~ msgstr "for 표현식"

#~ msgid "loop expressions"
#~ msgstr "loop 표현식"

#~ msgid "match expressions"
#~ msgstr "match 표현식"

#~ msgid "break & continue"
#~ msgstr "break와 continue"

#~ msgid "Option and Result"
#~ msgstr "Option과 Result"

#~ msgid "Vec"
#~ msgstr "Vec"

#~ msgid "HashMap"
#~ msgstr "HashMap"

#~ msgid "Box"
#~ msgstr "Box"

#~ msgid "Recursive Data Types"
#~ msgstr "재귀적 자료구조"

#~ msgid "Rc"
#~ msgstr "Rc"

#~ msgid "Cell/RefCell"
#~ msgstr "Cell과 RefCell"

#~ msgid "Strings and Iterators"
#~ msgstr "문자열과 반복자"

#~ msgid "Generic Methods"
#~ msgstr "제네릭 메서드"

#~ msgid "Monomorphization"
#~ msgstr "단형화"

#~ msgid "Default Methods"
#~ msgstr "기본 메서드"

#~ msgid "impl Trait"
#~ msgstr "트레잇 구현하기"

#~ msgid "Important Traits"
#~ msgstr "중요한 트레잇"

#~ msgid "From and Into"
#~ msgstr "From과 Into"

#~ msgid "Default"
#~ msgstr "Default"

#~ msgid "Operators: Add, Mul, ..."
#~ msgstr "연산자: Add, Mul, ..."

#~ msgid "Closures: Fn, FnMut, FnOnce"
#~ msgstr "클로저: Fn, FnMut, FnOnce"

#~ msgid "Catching Stack Unwinding"
#~ msgstr "스택 되감기"

#~ msgid "Structured Error Handling"
#~ msgstr "구조화된 오류처리"

#~ msgid "Propagating Errors with ?"
#~ msgstr "'?'를 이용한 오류 전파"

#~ msgid "Converting Error Types"
#~ msgstr "오류타입 변환"

#~ msgid "Deriving Error Enums"
#~ msgstr "또다른 오류 열거형"

#~ msgid "Adding Context to Errors"
#~ msgstr "오류에 상황정보 추가"

#~ msgid "no_std"
#~ msgstr "no_std"

#~ msgid "alloc"
#~ msgstr "alloc"

#~ msgid "embedded-hal"
#~ msgstr "embedded-hal"

#~ msgid "probe-rs, cargo-embed"
#~ msgstr "progo-rs, cargo-embed"

#~ msgid "zerocopy"
#~ msgstr "zerocopy"

#~ msgid "buddy_system_allocator"
#~ msgstr "buddy_system_allocator"

#~ msgid "tinyvec"
#~ msgstr "tinyvec"

#~ msgid "spin"
#~ msgstr "회전"

#~ msgid "Send and Sync"
#~ msgstr "Send와 Sync"

#~ msgid "Send"
#~ msgstr "Send"

#~ msgid "Sync"
#~ msgstr "Sync"

#~ msgid "Arc"
#~ msgstr "Arc"

#~ msgid "Mutex"
#~ msgstr "Mutex"

#~ msgid "async/await"
#~ msgstr "async/await"

#~ msgid "Pin"
#~ msgstr "Pin"

#~ msgid "Day 1 Morning"
#~ msgstr "1일차 오전"

#~ msgid "Day 1 Afternoon"
#~ msgstr "1일차 오후"

#~ msgid "Day 2 Morning"
#~ msgstr "2일차 오전"

#~ msgid "Day 2 Afternoon"
#~ msgstr "2일차 오후"

#~ msgid "Day 3 Morning"
#~ msgstr "3일차 오전"

#~ msgid "Day 3 Afternoon"
#~ msgstr "3일차 오후"

#~ msgid "Bare Metal Rust Morning"
#~ msgstr "Bare Metal 오전"

#~ msgid "Concurrency Morning"
#~ msgstr "동시성 오전"

#~ msgid "Concurrency Afternoon"
#~ msgstr "동시성 오후"

#~ msgid ""
#~ "[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
#~ "google/comprehensive-rust/build.yml?style=flat-square)](https://github."
#~ "com/google/comprehensive-rust/actions/workflows/build.yml?"
#~ "query=branch%3Amain)"
#~ msgstr ""
#~ "[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
#~ "google/comprehensive-rust/build.yml?style=flat-square)](https://github."
#~ "com/google/comprehensive-rust/actions/workflows/build.yml?"
#~ "query=branch%3Amain)"

#~ msgid "Build workflow"
#~ msgstr "빌드 워크플로"

#~ msgid "GitHub contributors"
#~ msgstr "GitHub 참여자"

#~ msgid ""
#~ "[![GitHub contributors](https://img.shields.io/github/contributors/google/"
#~ "comprehensive-rust?style=flat-square)](https://github.com/google/"
#~ "comprehensive-rust/graphs/contributors) [![GitHub stars](https://img."
#~ "shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
#~ "(https://github.com/google/comprehensive-rust/stargazers)"
#~ msgstr ""
#~ "[![GitHub contributors](https://img.shields.io/github/contributors/google/"
#~ "comprehensive-rust?style=flat-square)](https://github.com/google/"
#~ "comprehensive-rust/graphs/contributors) [![GitHub stars](https://img."
#~ "shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
#~ "(https://github.com/google/comprehensive-rust/stargazers)"

#~ msgid "GitHub stars"
#~ msgstr "GitHub stars"

#~ msgid ""
#~ "[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-"
#~ "rust?style=flat-square)](https://github.com/google/comprehensive-rust/"
#~ "stargazers)"
#~ msgstr ""
#~ "[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-"
#~ "rust?style=flat-square)](https://github.com/google/comprehensive-rust/"
#~ "stargazers)"

#~ msgid "The course is fast paced and covers a lot of ground:"
#~ msgstr "강의는 빠른 속도로 진행되며, 아래 내용들을 다룹니다:"

#~ msgid "Day 1: Basic Rust, ownership and the borrow checker."
#~ msgstr "1일차: 러스트 기본, 소유권(ownership)과 빌림(borrow) 체크."

#~ msgid "Day 2: Compound data types,  pattern matching, the standard library."
#~ msgstr "2일차: 복합 데이터 유형, 패턴 매칭, 표준 라이브러리."

#~ msgid "Day 3: Traits and generics, error handling, testing, unsafe Rust."
#~ msgstr ""
#~ "3일차: 트레잇(trait)와 제네릭(generic), 오류 처리, 테스트, 안전하지 않은 "
#~ "러스트."

#~ msgid "Concurrency"
#~ msgstr "동시성"

#~ msgid ""
#~ "```shell\n"
#~ "cargo init concurrency\n"
#~ "cd concurrency\n"
#~ "cargo add tokio --features full\n"
#~ "cargo run\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "cargo init concurrency\n"
#~ "cd concurrency\n"
#~ "cargo add tokio --features full\n"
#~ "cargo run\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "    sudo apt install cargo rust-src rustfmt\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ sudo apt install cargo rust-src rustfmt\n"
#~ "```"

#~ msgid ""
#~ "We suggest using [VS Code](https://code.visualstudio.com/) to edit the "
#~ "code (but any LSP compatible editor works with rust-analyzer[3](https://"
#~ "rust-analyzer.github.io/))."
#~ msgstr ""
#~ "우리는 코드 에디터로 [VS Code](https://code.visualstudio.com/)를 추천합니"
#~ "다. 그러나 LSP를 지원하는 (그래서 rust-analyzer[3](https://rust-analyzer."
#~ "github.io/)와 연동이 가능한) 에디터라면 어떤 것이라도 괜찮습니다."

#~ msgid ""
#~ "Some folks also like to use the [JetBrains](https://www.jetbrains.com/"
#~ "clion/) family of IDEs, which do their own analysis but have their own "
#~ "tradeoffs. If you prefer them, you can install the [Rust Plugin](https://"
#~ "www.jetbrains.com/rust/). Please take note that as of January 2023 "
#~ "debugging only works on the CLion version of the JetBrains IDEA suite."
#~ msgstr ""
#~ "어떤 사람들은 [JetBrains](https://www.jetbrains.com/clion/) 제품군을 선호"
#~ "하기도 합니다. 이 제품들은 rust-analyzer 를 활용하지 않고 IDE 자체적으로 "
#~ "구문분석을 합니다. 만약 이 IDE를 설치하셨다면 [Rust Plugin](https://www."
#~ "jetbrains.com/rust/)를 설치하시기 바랍니다. 다만 2023년 1월 기준, 디버깅"
#~ "은 JetBrains IDEA suite의 CLion 버전에서만 작동한다는 점에 유의하시기 바랍"
#~ "니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "% rustc --version\n"
#~ "rustc 1.69.0 (84c898d65 2023-04-16)\n"
#~ "% cargo --version\n"
#~ "cargo 1.69.0 (6e9a83356 2023-04-12)\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "% rustc --version\n"
#~ "rustc 1.69.0 (84c898d65 2023-04-16)\n"
#~ "% cargo --version\n"
#~ "cargo 1.69.0 (6e9a83356 2023-04-12)\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ cargo new exercise\n"
#~ "     Created binary (application) `exercise` package\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cargo new exercise\n"
#~ "     Created binary (application) `exercise` package\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ cd exercise\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Hello, world!\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cd exercise\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Hello, world!\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Edit me!\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Edit me!\n"
#~ "```"

#~ msgid ""
#~ "Memory management: stack vs heap, manual memory management, scope-based "
#~ "memory management, and garbage collection."
#~ msgstr ""
#~ "메모리 관리: 스택과 힙, 수동 메모리 관리, 스코프(범위)기반 메모리 관리, 가"
#~ "비지 컬렉션(GC)"

#~ msgid ""
#~ "Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
#~ msgstr "소유권: Move 문법, 복사와 복제, 빌림, 수명."

#~ msgid ""
#~ "The idea for the first day is to show _just enough_ of Rust to be able to "
#~ "speak about the famous borrow checker. The way Rust handles memory is a "
#~ "major feature and we should show students this right away."
#~ msgstr ""
#~ "첫 날 강의의 목표는, 러스트에서 그 유명한 빌림 확인에 대해서 이야기 할 수 "
#~ "있을 정도 까지만 러스트를 소개하는 것입니다. 러스트의 가장 독특한 특징이 "
#~ "메모리를 다루는 방식이기 때문에, 학생들에게 이 부분 을 우선적으로 보여주"
#~ "려 합니다."

#~ msgid ""
#~ "If you're teaching this in a classroom, this is a good place to go over "
#~ "the schedule. We suggest splitting the day into two parts (following the "
#~ "slides):"
#~ msgstr ""
#~ "만약 당신이 강의실에서 가르치고 있다면, 이 슬라이드는 일정을 검토하기에 적"
#~ "합한 곳입니다. 하루치 강의를 아래처럼 오전 오후로 나누어 진행하는 것을 추"
#~ "천합니다. (슬라이드가 그런식으로 나뉘어 있습니다.)"

#~ msgid "Morning: 9:00 to 12:00,"
#~ msgstr "오전: 9:00 ~ 12:00,"

#~ msgid "Afternoon: 13:00 to 16:00."
#~ msgstr "오후: 13:00 ~ 16:00."

#~ msgid ""
#~ "You can of course adjust this as necessary. Please make sure to include "
#~ "breaks, we recommend a break every hour!"
#~ msgstr ""
#~ "물론 필요에 따라 조절할 수 있습니다. 강의 중간에 쉬는시간을 넣는 것을 잊"
#~ "지 마세요. 매 시간 휴식을 갖는걸 추천합니다!"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello 🌍!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello 🌍!\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Here is a small example program in Rust:"
#~ msgstr "러스트로 작성된 작은 예제입니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {              // Program entry point\n"
#~ "    let mut x: i32 = 6;  // Mutable variable binding\n"
#~ "    print!(\"{x}\");       // Macro for printing, like printf\n"
#~ "    while x != 1 {       // No parenthesis around expression\n"
#~ "        if x % 2 == 0 {  // Math like in other languages\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {              // 프로그램 진입점입니다.\n"
#~ "    let mut x: i32 = 6;  // 가변 변수 할당(binding)입니다.\n"
#~ "    print!(\"{x}\");       // printf와 같은 출력을 위한 매크로 입니다.\n"
#~ "    while x != 1 {       // 표현식에 괄호는 없습니다.\n"
#~ "        if x % 2 == 0 {  // 다른 언어와 같은 수학연산식이 사용됩니다.\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The code implements the Collatz conjecture: it is believed that the loop "
#~ "will always end, but this is not yet proved. Edit the code and play with "
#~ "different inputs."
#~ msgstr ""
#~ "이 코드는 콜라츠 추측(Collatz conjecture)으로 구현됩니다: 반복문이 언제나 "
#~ "종료될 것이라고 믿지만 증명된 것은 아닙니다. 코드를 수정하고 실행해 보시"
#~ "기 바랍니다."

#~ msgid ""
#~ "Explain that all variables are statically typed. Try removing `i32` to "
#~ "trigger type inference. Try with `i8` instead and trigger a runtime "
#~ "integer overflow."
#~ msgstr ""
#~ "모든 변수가 컴파일 시 정해진 타입을 가짐을 설명합니다. `i32`를 삭제하여 컴"
#~ "파일러가 타입 추론을 하도록 해 봅니다. `i32`을 `i8`로 변경하여 런타임 오버"
#~ "플로를 유발해 볼 수 있습니다."

#~ msgid "Change `let mut x` to `let x`, discuss the compiler error."
#~ msgstr "`let mut x`를 `let x`로 수정하여 컴파일 오류에 대해 토론합니다."

#~ msgid ""
#~ "Show how `print!` gives a compilation error if the arguments don't match "
#~ "the format string."
#~ msgstr ""
#~ "인자가 포맷 문자열과 일치하지 않는 경우 `print!`에서 컴파일 오류가 발생함"
#~ "을 언급하는 것도 좋습니다."

#~ msgid ""
#~ "Show how you need to use `{}` as a placeholder if you want to print an "
#~ "expression which is more complex than just a single variable."
#~ msgstr ""
#~ "단일 변수보다 복잡한 식을 출려하려면 `{}`을 자리 표시자로 사용하는 방법을 "
#~ "보여 줍니다."

#~ msgid ""
#~ "Show the students the standard library, show them how to search for `std::"
#~ "fmt` which has the rules of the formatting mini-language. It's important "
#~ "that the students become familiar with searching in the standard library."
#~ msgstr ""
#~ "학생들에게 표준 라이브러리가 어디 있는지 알려 주고는, `print!`가 지원하는 "
#~ "포맷팅 언어의 문법을 알기 위해 `std::fmt`를 검색해야 한다는 것을 가르치세"
#~ "요.학생들이 표준 라이브러리의 검색 기능에 익숙해 지도록 하는 것이 중요합니"
#~ "다."

#~ msgid ""
#~ "In a shell `rustup doc std::fmt` will open a browser on the local std::"
#~ "fmt documentation"
#~ msgstr ""
#~ "쉘에서  `rustup doc std::fmt`를 수행하면 로컬 브라우저로 `std:fmt`에 대한 "
#~ "문서를 보여줍니다"

#~ msgid "Compile time memory safety."
#~ msgstr "컴파일 시 메모리 안전이 보장됨."

#~ msgid "Lack of undefined runtime behavior."
#~ msgstr "정의되지 않은 런타임 동작이 없음."

#~ msgid "Modern language features."
#~ msgstr "현대적인 언어 기능."

#~ msgid "Static memory management at compile time:"
#~ msgstr "컴파일 시 정적 메모리 관리:"

#~ msgid "No memory leaks (_mostly_, see notes)."
#~ msgstr "메모리 누출 없음(_거의_. 강의참조노트 참고.)"

#~ msgid ""
#~ "It is possible to produce memory leaks in (safe) Rust. Some examples are:"
#~ msgstr ""
#~ "(안전한) 러스트에서도 메모리 누출이 발생할 수 있는 몇 가지 경우가 있습니"
#~ "다:"

#~ msgid ""
#~ "You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
#~ "html#method.leak) to leak a pointer. A use of this could be to get "
#~ "runtime-initialized and runtime-sized static variables"
#~ msgstr ""
#~ "[`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method."
#~ "leak)을 이용하여 포인터를 의도적으로 누출시킬 수 있습니다. 이를 이용해서 "
#~ "런타임이 생성하고 런타임이 크기를 정한 정적 변수를 가져올 수 있습니다"

#~ msgid ""
#~ "You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn."
#~ "forget.html) to make the compiler \"forget\" about a value (meaning the "
#~ "destructor is never run)."
#~ msgstr ""
#~ "[`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget.html)을 "
#~ "사용하여 컴파일러가 값에 대해 \"잊도록\" 만들 수 있습니다(소멸자가 실행되"
#~ "지 않음을 의미합니다)."

#~ msgid ""
#~ "You can also accidentally create a [reference cycle](https://doc.rust-"
#~ "lang.org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
#~ msgstr ""
#~ "`Rc` 또는 `Arc`를 사용하여 실수로 [순환참조](https://doc.rust-lang.org/"
#~ "book/ch15-06-reference-cycles.html)를 생성할 수도 있습니다."

#~ msgid ""
#~ "In fact, some will consider infinitely populating a collection a memory "
#~ "leak and Rust does not protect from those."
#~ msgstr ""
#~ "컬렉션을 무한정 채우는 것을 메모리 누출로 간주할 수도 있지만, 러스트는 이"
#~ "를 보호하진 못합니다."

#~ msgid ""
#~ "For the purpose of this course, \"No memory leaks\" should be understood "
#~ "as \"Pretty much no _accidental_ memory leaks\"."
#~ msgstr ""
#~ "본 강의에서는 \"메모리 누출 없음\"을 \"우발적인 메모리 누출 없음\"으로 이"
#~ "해해야 합니다."

#~ msgid ""
#~ "Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
#~ "lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
#~ "flag. If enabled, the program will panic (a controlled crash of the "
#~ "program), otherwise you get wrap-around semantics. By default, you get "
#~ "panics in debug mode (`cargo build`) and wrap-around in release mode "
#~ "(`cargo build --release`)."
#~ msgstr ""
#~ "정수형 오버플로우는 [`overflow-checks`](https://doc.rust-lang.org/rustc/"
#~ "codegen-options/index.html#overflow-checks) 컴파일 타임 플래그를 통해 정의"
#~ "됩니다. 이 플래그가 켜지면, 프로그램은 정수형 오버플로우 발생시 panic (프"
#~ "로그램을 크래시 시키는 잘 정의된 방법) 합니다. 이 플래그가 꺼지면, 오버플"
#~ "로우는 wrap-around 가 됩니다. 기본적으로 디버그 모드(`cargo build`)에서는 "
#~ "패닉이, 릴리즈 모드(`cargo build --release`)에서는 wrap-around가 발생합니"
#~ "다."

#~ msgid ""
#~ "Bounds checking cannot be disabled with a compiler flag. It can also not "
#~ "be disabled directly with the `unsafe` keyword. However, `unsafe` allows "
#~ "you to call functions such as `slice::get_unchecked` which does not do "
#~ "bounds checking."
#~ msgstr ""
#~ "컴파일 플래그를 사용하여 경계체크를 무력화 할 수 없습니다. `unsafe`를 사용"
#~ "하더라도 마찬가지입니다. 하지만 `unsafe`에서 호출 가능한 `slice::"
#~ "get_unchecked`같은 함수는 경계 검사를 수행하지 않습니다."

#~ msgid "Rust is built with all the experience gained in the last decades."
#~ msgstr ""
#~ "러스트는 지난 수십년간의 모든 (프로그래밍 언어들의) 경험으로 만들어졌습니"
#~ "다."

#~ msgid "Language Features"
#~ msgstr "언어적 특징"

#~ msgid "Tooling"
#~ msgstr "도구들"

#~ msgid ""
#~ "Zero-cost abstractions, similar to C++, means that you don't have to "
#~ "'pay' for higher-level programming constructs with memory or CPU. For "
#~ "example, writing a loop using `for` should result in roughly the same low "
#~ "level instructions as using the `.iter().fold()` construct."
#~ msgstr ""
#~ "C++ 와 유사하게 제로 코스트 추상화는 CPU나 메모리를 사용하여 상위레벨 프로"
#~ "그래밍 구조를 만드는데 '비용'을 지불할 필요가 없습니다. 예를 들어 `for` 루"
#~ "프와와 `iter().fold()` 구조를 사용하는 것과 거의 동일한 낮은 수준의 명령어"
#~ "가 생성될 것 입니다."

#~ msgid ""
#~ "It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
#~ "also known as 'sum types', which allow the type system to express things "
#~ "like `Option<T>` and `Result<T, E>`."
#~ msgstr ""
#~ "러스트의 열거형(enum)은 합계 타입(sum type)으로 알려진 대수학적 데이터형"
#~ "(Algebraic Data Type)으로, 타입 시스템이 `Option<T>`와 `Result<T, E>`등을 "
#~ "표현할 수 있게 해줍니다."

#~ msgid ""
#~ "Remind people to read the errors --- many developers have gotten used to "
#~ "ignore lengthy compiler output. The Rust compiler is significantly more "
#~ "talkative than other compilers. It will often provide you with "
#~ "_actionable_ feedback, ready to copy-paste into your code."
#~ msgstr ""
#~ "오류를 읽어보시기 바랍니다 --- 오랜기간 많은 개발자들이 컴파일러 출력을 무"
#~ "시하는데 익숙해져 있습니다. 러스트 컴파일러는 다른 컴파일러보다 더 수다스"
#~ "럽고, 복사-붙여넣기 할 수 있는 정도의 코드 피드백을 제공하는 경우가 많습니"
#~ "다."

#~ msgid ""
#~ "The Rust standard library is small compared to languages like Java, "
#~ "Python, and Go. Rust does not come with several things you might consider "
#~ "standard and essential:"
#~ msgstr ""
#~ "러스트 표준 라이브러리는 Java, Python이나 Go와 같은 언어에 비해서 규모가 "
#~ "작습니다. 당연히 포함되어야 한다고 생각할 수도 있는 아래와 같은 것들이 러"
#~ "스트의 표준 라이브러리에 없습니다:"

#~ msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
#~ msgstr ""
#~ "난수 생성기, 하지만 [rand](https://docs.rs/rand/)문서를 참조하시기 바랍니"
#~ "다."

#~ msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
#~ msgstr ""
#~ "SSL 또는 TLS지원, 하지만 [rusttls](https://docs.rs/rustls/)문서를 참조하시"
#~ "기 바랍니다."

#~ msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
#~ msgstr ""
#~ "JSON 지원, 하지만 [serde_json](https://docs.rs/serde_json/) 문서를 참조하"
#~ "시기 바랍니다."

#~ msgid ""
#~ "The reasoning behind this is that functionality in the standard library "
#~ "cannot go away, so it has to be very stable. For the examples above, the "
#~ "Rust community is still working on finding the best solution --- and "
#~ "perhaps there isn't a single \"best solution\" for some of these things."
#~ msgstr ""
#~ "그 이유는 표준 라이브러리에서 한 번 어떤 기능을 제공하면 뺄 수 없으며, 매"
#~ "우 안정적이어야 하기 때문입니다. 위에 언급한 기능들은 아직 러스트 커뮤니티"
#~ "가 최고의 솔루션을 찾지 못했기 때문에 표준 라이브러리에 포함되지 않았습니"
#~ "다. 어쩌면 이들 중 몇 개는 '최고의 솔루션'이 아예 존재할 수 없을 지도 모릅"
#~ "니다."

#~ msgid ""
#~ "Rust comes with a built-in package manager in the form of Cargo and this "
#~ "makes it trivial to download and compile third-party crates. A "
#~ "consequence of this is that the standard library can be smaller."
#~ msgstr ""
#~ "러스트는 카고라는 패키지 관리자가 내장되어 있고, 서드파티 크레이트를 다운"
#~ "로드, 컴파일 하기 매우 쉽습니다. 이 또한 표준 라이브러리가 작은 이유입니"
#~ "다."

#~ msgid ""
#~ "Discovering good third-party crates can be a problem. Sites like <https://"
#~ "lib.rs/> help with this by letting you compare health metrics for crates "
#~ "to find a good and trusted one."
#~ msgstr ""
#~ "좋은 서드파티 크레이트를 찾는 것은 어렵습니다. <https://lib.rs> 와 같은 사"
#~ "이트가 신뢰할수 있는 좋은 크레이트를 비교하여 찾는데 좋습니다."

#~ msgid ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
#~ "implementation used in major IDEs and text editors."
#~ msgstr ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/)는 주요 IDE나 텍스트 에디"
#~ "터에서 사용되는 러스트용 LSP서버 입니다."

#~ msgid "`\"foo\"`, `\"two\\nlines\"`"
#~ msgstr "`\"foo\"`, `\"two\\nlines\"`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
#~ "    println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
#~ "    println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", b\"abc\");\n"
#~ "    println!(\"{:?}\", &[97, 98, 99]);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", b\"abc\");\n"
#~ "    println!(\"{:?}\", &[97, 98, 99]);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut a: [i8; 10] = [42; 10];\n"
#~ "    a[5] = 0;\n"
#~ "    println!(\"a: {:?}\", a);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut a: [i8; 10] = [42; 10];\n"
#~ "    a[5] = 0;\n"
#~ "    println!(\"a: {:?}\", a);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let t: (i8, bool) = (7, true);\n"
#~ "    println!(\"1st index: {}\", t.0);\n"
#~ "    println!(\"2nd index: {}\", t.1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let t: (i8, bool) = (7, true);\n"
#~ "    println!(\"1st index: {}\", t.0);\n"
#~ "    println!(\"2nd index: {}\", t.1);\n"
#~ "}\n"
#~ "```"

#~ msgid "Like C++, Rust has references:"
#~ msgstr "C++와 마찬가지로 러스트도 참조형을 갖습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x: i32 = 10;\n"
#~ "    let ref_x: &mut i32 = &mut x;\n"
#~ "    *ref_x = 20;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x: i32 = 10;\n"
#~ "    let ref_x: &mut i32 = &mut x;\n"
#~ "    *ref_x = 20;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We must dereference `ref_x` when assigning to it, similar to C and C++ "
#~ "pointers."
#~ msgstr ""
#~ "`ref_x`에 값을 할당할 때, C/C++의 포인터와 유사하게 `*`를 이용해서 참조를 "
#~ "따라가야(역참조) 합니다."

#~ msgid ""
#~ "References that are declared as `mut` can be bound to different values "
#~ "over their lifetime."
#~ msgstr ""
#~ "`mut`로 선언된 참조는 그 변수가 살아있는 동안 다른 값을 가질 수 있습니다."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let ref_x: &i32;\n"
#~ "    {\n"
#~ "        let x: i32 = 10;\n"
#~ "        ref_x = &x;\n"
#~ "    }\n"
#~ "    println!(\"ref_x: {ref_x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let ref_x: &i32;\n"
#~ "    {\n"
#~ "        let x: i32 = 10;\n"
#~ "        ref_x = &x;\n"
#~ "    }\n"
#~ "    println!(\"ref_x: {ref_x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "A reference is said to \"borrow\" the value it refers to."
#~ msgstr "참조는 어떤 값을 \"빌리는\" 것입니다."

#~ msgid ""
#~ "Rust is tracking the lifetimes of all references to ensure they live long "
#~ "enough."
#~ msgstr ""
#~ "러스트는 참조 대상의 값이, 그 값에 대한 모든 참조들보다 더 오래 살아있음"
#~ "을 추적합니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
#~ "    println!(\"a: {a:?}\");\n"
#~ "\n"
#~ "    let s: &[i32] = &a[2..4];\n"
#~ "\n"
#~ "    println!(\"s: {s:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
#~ "    println!(\"a: {a:?}\");\n"
#~ "\n"
#~ "    let s: &[i32] = &a[2..4];\n"
#~ "    println!(\"s: {s:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "`String` vs `str`"
#~ msgstr "`String`과 `str`"

#~ msgid "We can now understand the two string types in Rust:"
#~ msgstr "이제 러스트의 두 가지 문자열 타입에 대해서 이해해 보겠습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: &str = \"World\";\n"
#~ "    println!(\"s1: {s1}\");\n"
#~ "\n"
#~ "    let mut s2: String = String::from(\"Hello \");\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    s2.push_str(s1);\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    \n"
#~ "    let s3: &str = &s2[6..];\n"
#~ "    println!(\"s3: {s3}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: &str = \"World\";\n"
#~ "    println!(\"s1: {s1}\");\n"
#~ "\n"
#~ "    let mut s2: String = String::from(\"Hello \");\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    s2.push_str(s1);\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    \n"
#~ "    let s3: &str = &s2[6..];\n"
#~ "    println!(\"s3: {s3}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "You can borrow `&str` slices from `String` via `&` and optionally range "
#~ "selection."
#~ msgstr ""
#~ "`&`와 범위 연산자를 이용하여 `String`에서 `&str`슬라이스를 빌려올 수 있습"
#~ "니다."

#~ msgid ""
#~ "A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
#~ "Fizz_buzz) interview question:"
#~ msgstr ""
#~ "러스트 버전의 [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) 함수입니"
#~ "다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    print_fizzbuzz_to(20);\n"
#~ "}\n"
#~ "\n"
#~ "fn is_divisible(n: u32, divisor: u32) -> bool {\n"
#~ "    if divisor == 0 {\n"
#~ "        return false;\n"
#~ "    }\n"
#~ "    n % divisor == 0\n"
#~ "}\n"
#~ "\n"
#~ "fn fizzbuzz(n: u32) -> String {\n"
#~ "    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
#~ "    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
#~ "    if fizz.is_empty() && buzz.is_empty() {\n"
#~ "        return format!(\"{n}\");\n"
#~ "    }\n"
#~ "    format!(\"{fizz}{buzz}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn print_fizzbuzz_to(n: u32) {\n"
#~ "    for i in 1..=n {\n"
#~ "        println!(\"{}\", fizzbuzz(i));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    print_fizzbuzz_to(20);\n"
#~ "}\n"
#~ "\n"
#~ "fn is_divisible(n: u32, divisor: u32) -> bool {\n"
#~ "    if divisor == 0 {\n"
#~ "        return false;\n"
#~ "    }\n"
#~ "    n % divisor == 0\n"
#~ "}\n"
#~ "\n"
#~ "fn fizzbuzz(n: u32) -> String {\n"
#~ "    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
#~ "    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
#~ "    if fizz.is_empty() && buzz.is_empty() {\n"
#~ "        return format!(\"{n}\");\n"
#~ "    }\n"
#~ "    format!(\"{fizz}{buzz}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn print_fizzbuzz_to(n: u32) {\n"
#~ "    for i in 1..=n {\n"
#~ "        println!(\"{}\", fizzbuzz(i));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We refer in `main` to a function written below. Neither forward "
#~ "declarations nor headers are necessary. "
#~ msgstr ""
#~ "`main` 함수에서 그 다음에 오는 함수들을 사용할 수 있습니다. 미리 선언하기"
#~ "(forward declaration)나 헤더 같은건 필요 없습니다. "

#~ msgid ""
#~ "The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
#~ "`=n`, which causes it to include the upper bound."
#~ msgstr ""
#~ "`fizzbuzz_to()`함수 내 `for` 반목문의 범위 표현식 중 `=n`은 n까지 포함한다"
#~ "는 의미입니다."

#~ msgid ""
#~ "All language items in Rust can be documented using special `///` syntax."
#~ msgstr "Rust의 아이템(item)은 `///` 문법을 사용하여 문서화할 수 있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "/// Determine whether the first argument is divisible by the second "
#~ "argument.\n"
#~ "///\n"
#~ "/// If the second argument is zero, the result is false.\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // Corner case, early return\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // The last expression in a block is the return "
#~ "value\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "/// 첫 번째 인수가 두 번째 인수로 나눠질 수 있는지 결정합니다.\n"
#~ "///\n"
#~ "/// 두 번째 인수가 0이면 결과는 false입니다.\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // Corner case, early return\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // 블록 안의 마지막 표현식은 반환값입니다\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "This course does not include rustdoc on slides, just to save space, but "
#~ "in real code they should be present."
#~ msgstr ""
#~ "이 슬라이드의 예제 코드는 문서화 주석이 생략되어 있지만, 실제 코드라면 문"
#~ "서화 주석을 반드시 써야 합니다."

#~ msgid ""
#~ "Inner doc comments are discussed later (in the page on modules) and need "
#~ "not be addressed here."
#~ msgstr ""
#~ "문서 내부 주석 모듈 페이지 뒷부분에서 다루며 여기서 다루지 않아도 됩니다."

#~ msgid ""
#~ "Rustdoc comments can contain code snippets that we can run and test using "
#~ "`cargo test`. We will discuss these tests in the [Testing section](../"
#~ "testing/doc-tests.html)."
#~ msgstr ""
#~ "문서화 주석은 코드를 포함할 수도 있으며, 이 코드는 `cargo test`를 통해 테"
#~ "스트로 동작할 수도 있습니다. [테스트](../testing/doc-tests.html)에서 더 자"
#~ "세히 다루겠습니다."

#~ msgid ""
#~ "Methods are functions associated with a type. The `self` argument of a "
#~ "method is an instance of the type it is associated with:"
#~ msgstr ""
#~ "메서드는 특정 타입과 연결된 함수입니다. 메서드의 `self` 인자가 그 메서드"
#~ "가 연결된 인스턴스의 타입입니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Rectangle {\n"
#~ "    width: u32,\n"
#~ "    height: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Rectangle {\n"
#~ "    fn area(&self) -> u32 {\n"
#~ "        self.width * self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inc_width(&mut self, delta: u32) {\n"
#~ "        self.width += delta;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut rect = Rectangle { width: 10, height: 5 };\n"
#~ "    println!(\"old area: {}\", rect.area());\n"
#~ "    rect.inc_width(5);\n"
#~ "    println!(\"new area: {}\", rect.area());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Rectangle {\n"
#~ "    width: u32,\n"
#~ "    height: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Rectangle {\n"
#~ "    fn area(&self) -> u32 {\n"
#~ "        self.width * self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inc_width(&mut self, delta: u32) {\n"
#~ "        self.width += delta;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut rect = Rectangle { width: 10, height: 5 };\n"
#~ "    println!(\"old area: {}\", rect.area());\n"
#~ "    rect.inc_width(5);\n"
#~ "    println!(\"new area: {}\", rect.area());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We will look much more at methods in today's exercise and in tomorrow's "
#~ "class."
#~ msgstr "오늘과 내일 강의에서 더 많은 메서드 사용법을 다룰 것입니다."

#~ msgid ""
#~ "Add a static method called `Rectangle::new` and call this from `main`:"
#~ msgstr "`Rectangle::new` 생성자를 추가하고 이를 `main`에서 호출합니다:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn new(width: u32, height: u32) -> Rectangle {\n"
#~ "    Rectangle { width, height }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn new(width: u32, height: u32) -> Rectangle {\n"
#~ "    Rectangle { width, height }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "While _technically_, Rust does not have custom constructors, static "
#~ "methods are commonly used to initialize structs (but don't have to). The "
#~ "actual constructor, `Rectangle { width, height }`, could be called "
#~ "directly. See the [Rustnomicon](https://doc.rust-lang.org/nomicon/"
#~ "constructors.html)."
#~ msgstr ""
#~ "\\_기술적_으로 이야기 하자면, 러스트는 커스텀 생성자를 지원하지 않습니다. "
#~ "정적 메소드를 사용하는 것이 구조체를 초기화 하는 일반적인 방법입니다 (물"
#~ "론 이것이 강제되지는 않습니다). 진짜 생성자인 `Rectangle { width, height }"
#~ "`를 직접 호출할 수도 있습니다. 자세한 내용은 [Rustnomicon](https://doc."
#~ "rust-lang.org/nomicon/constructors.html)을 참조하세요."

#~ msgid ""
#~ "Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
#~ "static methods can take arbitrary parameters."
#~ msgstr ""
#~ "`Rectangle::square(width: u32)` 생성자를 추가하여 생성자가 임의의 매개변수"
#~ "를 사용할 수 있음을 보입시다."

#~ msgid "Function Overloading"
#~ msgstr "(함수) 오버로딩"

#~ msgid "Overloading is not supported:"
#~ msgstr "오버로딩은 지원되지 않습니다:"

#~ msgid "Always takes a fixed number of parameters."
#~ msgstr "항상 고정된 수의 파라매터만 갖습니다."

#~ msgid "Default values are not supported:"
#~ msgstr "파라매터의 기본 값은 지원되지 않습니다:"

#~ msgid "All call sites have the same number of arguments."
#~ msgstr "모든 호출부에서는 동일한 수의 인자를 설정해야합니다."

#~ msgid "Macros are sometimes used as an alternative."
#~ msgstr "이런 사항들이 제약이 될 경우, 대안으로 매크로를 사용하기도 합니다."

#~ msgid "However, function parameters can be generic:"
#~ msgstr "하지만, 함수의 매개변수는 제네릭을 적용할 수 있습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
#~ "    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
#~ "    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "When using generics, the standard library's `Into<T>` can provide a kind "
#~ "of limited polymorphism on argument types. We will see more details in a "
#~ "later section."
#~ msgstr ""
#~ "제네릭을 사용할 때 표준 라이브러리의 `Into<T>`은 타입에 대한 다형성을 제공"
#~ "할 수 있습니다. 나중에 자세히 설명하겠습니다."

#~ msgid "Day 1: Morning Exercises"
#~ msgstr "1일차 오전 연습문제"

#~ msgid "In these exercises, we will explore two parts of Rust:"
#~ msgstr "이번 연습문제는 러스트의 두 부분을 알아볼 것입니다:"

#~ msgid "Implicit conversions between types."
#~ msgstr "타입의 묵시적 변환."

#~ msgid "Arrays and `for` loops."
#~ msgstr "배열과 `for` 반복문."

#~ msgid "A few things to consider while solving the exercises:"
#~ msgstr "연습문제를 해결하는데 고려해야 할 사항들:"

#~ msgid ""
#~ "Use a local Rust installation, if possible. This way you can get auto-"
#~ "completion in your editor. See the page about [Using Cargo](../../cargo."
#~ "md) for details on installing Rust."
#~ msgstr ""
#~ "가능하다면 러스트가 설치된 로컬 환경에서 진행하세요. 그러는 편이 텍스트 에"
#~ "디터의 자동완성 기능의 도움을 받을 수 있어서 좋습니다. [카고 사용하기]"
#~ "(../../cargo.md) 을 참조하시기 바랍니다."

#~ msgid "Alternatively, use the Rust Playground."
#~ msgstr "혹은 러스트 플레이그라운드를 이용할 수 있습니다."

#~ msgid ""
#~ "The code snippets are not editable on purpose: the inline code snippets "
#~ "lose their state if you navigate away from the page."
#~ msgstr ""
#~ "페이지 밖으로 이동할 경우 작성한 내용이 소실되기 때문에 제공되는 코드 스니"
#~ "펫은 의도적으로 편집할 수 없습니다."

#~ msgid ""
#~ "After looking at the exercises, you can look at the \\[solutions\\] "
#~ "provided."
#~ msgstr ""
#~ "연습문제를 살펴 본 후, 제공된 \\[해답\\]\\[solutions\\]을 살펴볼 수 있습니"
#~ "다."

#~ msgid ""
#~ "Rust will not automatically apply _implicit conversions_ between types "
#~ "([unlike C++](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion)). You can see this in a program like this:"
#~ msgstr ""
#~ "러스트는 [C++ 와 다르게](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion) 타입 간 _묵시적 변환_을 자동으로 적용하지 않습니다. "
#~ "아래 예시를 확인해 보세요:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn multiply(x: i16, y: i16) -> i16 {\n"
#~ "    x * y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x: i8 = 15;\n"
#~ "    let y: i16 = 1000;\n"
#~ "\n"
#~ "    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn multiply(x: i16, y: i16) -> i16 {\n"
#~ "    x * y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x: i8 = 15;\n"
#~ "    let y: i16 = 1000;\n"
#~ "\n"
#~ "    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The Rust integer types all implement the [`From<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.Into.html) traits to let us convert between "
#~ "them. The `From<T>` trait has a single `from()` method and similarly, the "
#~ "`Into<T>` trait has a single `into()` method. Implementing these traits "
#~ "is how a type expresses that it can be converted into another type."
#~ msgstr ""
#~ "러스트의 정수형 타입은 모두 [`From<T>`](https://doc.rust-lang.org/std/"
#~ "convert/trait.From.html) 와 [`Into<T>`](https://doc.rust-lang.org/std/"
#~ "convert/trait.Into.html) 트레잇을 구현하고 있으며, 이를 통해 타입 변환이 "
#~ "이루어 집니다. `From<T>` 트레잇은 `from()` 메서드를 가지고 있고, `Into<T>`"
#~ "트레잇은 `into()` 메서드를 가지고 있습니다. 러스트에서는 `From`과 `Into` "
#~ "트레잇을 구현함으로써, 타입 간 변환이 가능하다는 것을 표현합니다."

#~ msgid ""
#~ "The standard library has an implementation of `From<i8> for i16`, which "
#~ "means that we can convert a variable `x` of type `i8` to an `i16` by "
#~ "calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> "
#~ "for i16` implementation automatically create an implementation of "
#~ "`Into<i16> for i8`."
#~ msgstr ""
#~ "표준 라이브러리에는 `From<i8> for i16`가 구현되어 있는데 이것은 `i8` 타입"
#~ "의 변수 `x`를 `i16::from(x)`를 호출하여 `i16`타입으로 변환할 수 있다는 의"
#~ "미입니다. 혹은 더 간단하게 `x.into()`를 사용할 수도 있습니다. 이것이 가능"
#~ "한 이유는 `From<i8> for i16` 구현을 가지고 있으면 `Into<i16> for i8` 구현"
#~ "이 자동으로 생성되기 때문입니다."

#~ msgid ""
#~ "The same applies for your own `From` implementations for your own types, "
#~ "so it is sufficient to only implement `From` to get a respective `Into` "
#~ "implementation automatically."
#~ msgstr ""
#~ "이는 사용자 정의 타입에도 동일하게 적용되는 규칙입니다. 따라서 `From`만을 "
#~ "구현해도 `Into`까지 자동으로 구현이 됩니다."

#~ msgid "Execute the above program and look at the compiler error."
#~ msgstr "위 예제코드를 실행하고 어떤 컴파일 에러가 발생하는지 확인해 보세요."

#~ msgid "Update the code above to use `into()` to do the conversion."
#~ msgstr "`into()`를 사용하여 코드를 수정하세요."

#~ msgid ""
#~ "Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
#~ "`i128`) to see which types you can convert to which other types. Try "
#~ "converting small types to big types and the other way around. Check the "
#~ "[standard library documentation](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html) to see if `From<T>` is implemented for the pairs you "
#~ "check."
#~ msgstr ""
#~ "`x`와 `y`를 `f32`이나 `bool`, `i128` 등으로 바꿔서 해당 타입들로 변환이 되"
#~ "는지 확인해보세요. 작은 사이즈 타입에서 큰 사이즈로 변경해보시고 그 반대로"
#~ "도 해보세요. [표준 라이브러리 문서](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html)에서 시도해 본 케이스가 구현되어 있는지 확인해 보세요."

#~ msgid "Arrays and `for` Loops"
#~ msgstr "배열과 `for`반복문"

#~ msgid "We saw that an array can be declared like this:"
#~ msgstr "배열을 아래와 같이 선언 할 수 있음을 배웠습니다:"

#~ msgid ""
#~ "```rust\n"
#~ "let array = [10, 20, 30];\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let array = [10, 20, 30];\n"
#~ "```"

#~ msgid ""
#~ "You can print such an array by asking for its debug representation with "
#~ "`{:?}`:"
#~ msgstr "배열을 출력하려면 `{:?}`를 씁니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    println!(\"array: {array:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    println!(\"array: {array:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Rust lets you iterate over things like arrays and ranges using the `for` "
#~ "keyword:"
#~ msgstr ""
#~ "러스트에서는 `for` 키워드를 사용해 배열이나 범위를 반복할 수 있습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    print!(\"Iterating over array:\");\n"
#~ "    for n in array {\n"
#~ "        print!(\" {n}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "\n"
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    print!(\"Iterating over array:\");\n"
#~ "    for n in array {\n"
#~ "        print!(\" {n}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "\n"
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ "           ⎛⎡1 2 3⎤⎞      ⎡1 4 7⎤\n"
#~ "\"transpose\"⎜⎢4 5 6⎥⎟  \"==\"⎢2 5 8⎥\n"
#~ "           ⎝⎣7 8 9⎦⎠      ⎣3 6 9⎦\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ "           ⎛⎡1 2 3⎤⎞      ⎡1 4 7⎤\n"
#~ "\"transpose\"⎜⎢4 5 6⎥⎟  \"==\"⎢2 5 8⎥\n"
#~ "           ⎝⎣7 8 9⎦⎠      ⎣3 6 9⎦\n"
#~ "```"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "\n"
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);\n"
#~ "\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: 구현이 완료되면 아래 줄은 삭제합니다.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "\n"
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);\n"
#~ "\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"

#~ msgid "Bonus Question"
#~ msgstr "보너스 문제"

#~ msgid ""
#~ "Could you use `&[i32]` slices instead of hard-coded 3 × 3 matrices for "
#~ "your argument and return types? Something like `&[&[i32]]` for a two-"
#~ "dimensional slice-of-slices. Why or why not?"
#~ msgstr ""
#~ "`&[i32]`슬라이스를 잘 이용하면 행렬 크기를 3 x 3으로 하드코딩 하지 않을 "
#~ "수 있을까요? 예컨데 `&[&[i32]]`는 2차원 슬라이스의 슬라이스 입니다. 가능하"
#~ "다면/하지 않다면 왜 그런가요?"

#~ msgid ""
#~ "See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
#~ "quality implementation."
#~ msgstr ""
#~ "상용 품질의 구현에 대해서는 [`ndarray` 크레이트](https://docs.rs/ndarray/)"
#~ "를 참조하시기 바랍니다."

#~ msgid ""
#~ "The solution and the answer to the bonus section are available in the  "
#~ "[Solution](solutions-morning.md#arrays-and-for-loops) section."
#~ msgstr ""
#~ "보너스 문제에 대한 답변 역시 [해답](solutions-morning.md#arrays-and-for-"
#~ "loops)에서 확인할 수 있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x: i32 = 10;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    // x = 20;\n"
#~ "    // println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x: i32 = 10;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    // x = 20;\n"
#~ "    // println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Due to type inference the `i32` is optional. We will gradually show the "
#~ "types less and less as the course progresses."
#~ msgstr ""
#~ "타입 추론에 덕분에 `i32`는 생략 가능합니다. 강의가 진행될 수록 생략 가능"
#~ "한 부분은 점점 생략할 것입니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn takes_u32(x: u32) {\n"
#~ "    println!(\"u32: {x}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn takes_i8(y: i8) {\n"
#~ "    println!(\"i8: {y}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = 10;\n"
#~ "    let y = 20;\n"
#~ "\n"
#~ "    takes_u32(x);\n"
#~ "    takes_i8(y);\n"
#~ "    // takes_u32(y);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn takes_u32(x: u32) {\n"
#~ "    println!(\"u32: {x}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn takes_i8(y: i8) {\n"
#~ "    println!(\"i8: {y}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = 10;\n"
#~ "    let y = 20;\n"
#~ "\n"
#~ "    takes_u32(x);\n"
#~ "    takes_i8(y);\n"
#~ "    // takes_u32(y);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The following code tells the compiler to copy into a certain generic "
#~ "container without the code ever explicitly specifying the contained type, "
#~ "using `_` as a placeholder:"
#~ msgstr ""
#~ "아래 코드는, 제네릭 컨테이너를 쓸 때 컨테이터 안에 포함된 데이터의 타입을 "
#~ "명시적으로 쓰지 않고 `_`로 대체하여도 된다는 것을 보여줍니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push((10, false));\n"
#~ "    v.push((20, true));\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "\n"
#~ "    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
#~ "    println!(\"vv: {vv:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push((10, false));\n"
#~ "    v.push((20, true));\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "\n"
#~ "    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
#~ "    println!(\"vv: {vv:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
#~ "std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-"
#~ "lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
#~ "HashSet%3CT,+S%3E) implements."
#~ msgstr ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect)는 [`HashSet`](https://doc.rust-lang.org/std/"
#~ "collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-HashSet%3CT,"
#~ "+S%3E)을 구현한 [`FromIterator`](https://doc.rust-lang.org/std/iter/trait."
#~ "FromIterator.html)에 의존합니다."

#~ msgid "Static and Constant Variables"
#~ msgstr "정적변수(static)과 상수(const)"

#~ msgid ""
#~ "```rust,editable\n"
#~ "const DIGEST_SIZE: usize = 3;\n"
#~ "const ZERO: Option<u8> = Some(42);\n"
#~ "\n"
#~ "fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
#~ "    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
#~ "    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
#~ "        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
#~ "wrapping_add(b);\n"
#~ "    }\n"
#~ "    digest\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let digest = compute_digest(\"Hello\");\n"
#~ "    println!(\"Digest: {digest:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "const DIGEST_SIZE: usize = 3;\n"
#~ "const ZERO: Option<u8> = Some(42);\n"
#~ "\n"
#~ "fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
#~ "    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
#~ "    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
#~ "        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
#~ "wrapping_add(b);\n"
#~ "    }\n"
#~ "    digest\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let digest = compute_digest(\"Hello\");\n"
#~ "    println!(\"Digest: {digest:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"{BANNER}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"{BANNER}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");\n"
#~ "\n"
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");\n"
#~ "\n"
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");\n"
#~ "\n"
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");\n"
#~ "\n"
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The following code demonstrates why the compiler can't simply reuse "
#~ "memory locations when shadowing an immutable variable in a scope, even if "
#~ "the type does not change."
#~ msgstr ""
#~ "아래 코드는 불변 변수를 쉐도잉할 때 타입이 동일하더라도 새 변수가 원래 변"
#~ "수의 메모리 위치를 재사용 할 수 없는지 그 이유를 보여줍니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 1;\n"
#~ "    let b = &a;\n"
#~ "    let a = a + 1;\n"
#~ "    println!(\"{a} {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 1;\n"
#~ "    let b = &a;\n"
#~ "    let a = a + 1;\n"
#~ "    println!(\"{a} {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "First, let's refresh how memory management works."
#~ msgstr "우선 메모리 관리가 이뤄지는 방식을 다시 살펴 보겠습니다."

#~ msgid "The Stack vs The Heap"
#~ msgstr "스택(Stack)과 힙(Heap)"

#~ msgid "Stack and Heap Example"
#~ msgstr "스택과 힙에 관한 예제"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1 = String::from(\"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1 = String::from(\"Hello\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::from(\"Hello\");\n"
#~ "    s1.push(' ');\n"
#~ "    s1.push_str(\"world\");\n"
#~ "    // DON'T DO THIS AT HOME! For educational purposes only.\n"
#~ "    // String provides no guarantees about its layout, so this could lead "
#~ "to\n"
#~ "    // undefined behavior.\n"
#~ "    unsafe {\n"
#~ "        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
#~ "transmute(s1);\n"
#~ "        println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
#~ "{capacity}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::from(\"Hello\");\n"
#~ "    s1.push(' ');\n"
#~ "    s1.push_str(\"world\");\n"
#~ "    // DON'T DO THIS AT HOME! For educational purposes only.\n"
#~ "    // String provides no guarantees about its layout, so this could lead "
#~ "to\n"
#~ "    // undefined behavior.\n"
#~ "    unsafe {\n"
#~ "        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
#~ "transmute(s1);\n"
#~ "        println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
#~ "{capacity}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "You allocate and deallocate heap memory yourself."
#~ msgstr "사용자가 직접 메모리를 할당, 해제 합니다."

#~ msgid ""
#~ "If not done with care, this can lead to crashes, bugs, security "
#~ "vulnerabilities, and memory leaks."
#~ msgstr ""
#~ "조심하지 않으면, 충돌(crash), 버그, 보안취약성 및 메모리 누출이 발생할 수 "
#~ "있습니다."

#~ msgid "C Example"
#~ msgstr "C 언어 예제"

#~ msgid "You must call `free` on every pointer you allocate with `malloc`:"
#~ msgstr "`malloc`으로 할당하는 포인터마다 `free`를 호출해야 합니다:"

#~ msgid ""
#~ "```c\n"
#~ "void foo(size_t n) {\n"
#~ "    int* int_array = malloc(n * sizeof(int));\n"
#~ "    //\n"
#~ "    // ... lots of code\n"
#~ "    //\n"
#~ "    free(int_array);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c\n"
#~ "void foo(size_t n) {\n"
#~ "    int* int_array = malloc(n * sizeof(int));\n"
#~ "    //\n"
#~ "    // ... lots of code\n"
#~ "    //\n"
#~ "    free(int_array);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Memory is leaked if the function returns early between `malloc` and "
#~ "`free`: the pointer is lost and we cannot deallocate the memory. Worse, "
#~ "freeing the pointer twice, or accessing a freed pointer can lead to "
#~ "exploitable security vulnerabilities."
#~ msgstr ""
#~ "만약 `malloc` 과 `free` 사이에서 함수가 일찍 반환되면 메모리 누출이 일어납"
#~ "니다: 포인터를 잃어버리게 되어 메모리를 반환할 수 없게 됩니다. 같은 포인터"
#~ "를 두 번 반환하거나, 이미 반환된 포인터를 접근하는 것은 심각한 보안 문제"
#~ "를 일으킬 수 있습니다."

#~ msgid ""
#~ "Constructors and destructors let you hook into the lifetime of an object."
#~ msgstr ""
#~ "생성자와 소멸자를 사용하여 객체의 생명주기에 따라 메모리 할당/해제가 일어"
#~ "나도록 할 수 있습니다."

#~ msgid ""
#~ "By wrapping a pointer in an object, you can free memory when the object "
#~ "is destroyed. The compiler guarantees that this happens, even if an "
#~ "exception is raised."
#~ msgstr ""
#~ "포인터를 객체로 감싸도록 하면, 그 객체가 소멸될 때 그 포인터가 가리키는 메"
#~ "모리가 해제되도록 할 수 있습니다. 컴파일러는 객체가 소멸될 때 반드시 소멸"
#~ "자가 호출되는 것을 보장합니다. 심지어는 예외(exception)가 발생(_역주_: 함"
#~ "수의 리턴이나 스코프의 종료 뿐만이 아니라) 하더라도요."

#~ msgid ""
#~ "This is often called _resource acquisition is initialization_ (RAII) and "
#~ "gives you smart pointers."
#~ msgstr ""
#~ "이를 종종 RAII (Resource Acquisition Is Initialization)라고 하며, 이런 객"
#~ "체는 일종의 스마트 포인터 역할을 합니다."

#~ msgid ""
#~ "```c++\n"
#~ "void say_hello(std::unique_ptr<Person> person) {\n"
#~ "  std::cout << \"Hello \" << person->name << std::endl;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "void say_hello(std::unique_ptr<Person> person) {\n"
#~ "  std::cout << \"Hello \" << person->name << std::endl;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The `std::unique_ptr` object is allocated on the stack, and points to "
#~ "memory allocated on the heap."
#~ msgstr ""
#~ "`std::unique_ptr`객체는 스택에 할당되며, 힙에 할당된 메모리를 가리킵니다."

#~ msgid ""
#~ "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
#~ msgstr "`say_hello`함수가 끝나면 `std::unique_ptr`의 소멸자가 실행됩니다."

#~ msgid "The destructor frees the `Person` object it points to."
#~ msgstr "소멸자는 `Person` 객체가 가리키는 메모리를 해제합니다."

#~ msgid ""
#~ "Special move constructors are used when passing ownership to a function:"
#~ msgstr "이동 생성자는 함수 호출 시 소유권을 전달할때 사용됩니다:"

#~ msgid ""
#~ "```c++\n"
#~ "std::unique_ptr<Person> person = find_person(\"Carla\");\n"
#~ "say_hello(std::move(person));\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "std::unique_ptr<Person> person = find_person(\"Carla\");\n"
#~ "say_hello(std::move(person));\n"
#~ "```"

#~ msgid ""
#~ "An alternative to manual and scope-based memory management is automatic "
#~ "memory management:"
#~ msgstr ""
#~ "수동, 스코프기반 메모리 관리의 대안으로 자동 메모리 관리 방식이 있습니다:"

#~ msgid "The programmer never allocates or deallocates memory explicitly."
#~ msgstr "개발자는 메모리를 명시적으로 할당/해제 하지 않습니다."

#~ msgid ""
#~ "A garbage collector finds unused memory and deallocates it for the "
#~ "programmer."
#~ msgstr "가비지 컬렉터(GC)는 사용되지 않는 메모리를 찾아 해제합니다."

#~ msgid "Java Example"
#~ msgstr "Java 예제"

#~ msgid "The `person` object is not deallocated after `sayHello` returns:"
#~ msgstr ""
#~ "`person`객체는 `sayHello`함수 반환 후에도 해제되지 않습니다. (_역주_: GC"
#~ "가 나중에 알아서 해제합니다.)"

#~ msgid ""
#~ "```java\n"
#~ "void sayHello(Person person) {\n"
#~ "  System.out.println(\"Hello \" + person.getName());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "void sayHello(Person person) {\n"
#~ "  System.out.println(\"Hello \" + person.getName());\n"
#~ "}\n"
#~ "```"

#~ msgid "Memory Management in Rust"
#~ msgstr "러스트에서의 메모리 관리"

#~ msgid "Memory management in Rust is a mix:"
#~ msgstr ""
#~ "러스트의 메모리 관리는 지금까지 설명한 방식들을 혼합해서 사용합니다:"

#~ msgid "Safe and correct like Java, but without a garbage collector."
#~ msgstr "자바처럼 안전하고 정확합니다. 하지만 GC는 없습니다."

#~ msgid ""
#~ "Depending on which abstraction (or combination of abstractions) you "
#~ "choose, can be a single unique pointer, reference counted, or atomically "
#~ "reference counted."
#~ msgstr ""
#~ "다양한 추상화를 제공합니다: 단일 포인터, 참조 카운트, 아토믹(atomic) 참조 "
#~ "카운트."

#~ msgid "Scope-based like C++, but the compiler enforces full adherence."
#~ msgstr ""
#~ "C++ 처럼 범위(스코프) 기반입니다. 하지만 컴파일러가 훨씬 더 엄격합니다."

#~ msgid ""
#~ "A Rust user can choose the right abstraction for the situation, some even "
#~ "have no cost at runtime like C."
#~ msgstr ""
#~ "사용자는 상황에 따라 적합한 추상화를 선택할 수 있습니다. 그 중에는 C 언어 "
#~ "처럼 런타임 오버헤드가 없는 것도 있습니다."

#~ msgid "Rust achieves this by modeling _ownership_ explicitly."
#~ msgstr ""
#~ "러스트는 \\_소유권_을 언어 차원에서 명시적으로 모델링 함으로써 이를 이룹니"
#~ "다."

#~ msgid ""
#~ "If asked how at this point, you can mention that in Rust this is usually "
#~ "handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
#~ "boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct."
#~ "Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
#~ "(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
#~ "ownership and memory allocation via various means, and prevent the "
#~ "potential errors in C."
#~ msgstr ""
#~ "이 시점에서 그게 어떻게 가능하냐는 질문이 있으면, 러스트에서 이 작업은 일"
#~ "반적으로 [Box](https://doc.rust-lang.org/std/boxed/struct.Box.html), [Vec]"
#~ "(https://doc.rust-lang.org/std/vec/struct.Vec.html), [Rc](https://doc."
#~ "rust-lang.org/std/rc/struct.Rc.html) 또는 [Arc](https://doc.rust-lang.org/"
#~ "std/sync/struct.Arc.html)와 같은 RAII 타입에 의해 처리된다고 답변할 수 있"
#~ "습니다. 이들은 다양한 방법을 통해 소유권과 메모리 할당에 대한 구체적인 내"
#~ "용을을 캡슐화하여, C 언어였다면 발생할 수 있었을 다양한 에러를 막습니다."

#~ msgid ""
#~ "You may be asked about destructors here, the [Drop](https://doc.rust-lang."
#~ "org/std/ops/trait.Drop.html) trait is the Rust equivalent."
#~ msgstr ""
#~ "소멸자에 대한 질문도 있을 수 있습니다. [Drop](https://doc.rust-lang.org/"
#~ "std/ops/trait.Drop.html) 트레잇이 답입니다."

#~ msgid "Here is a rough comparison of the memory management techniques."
#~ msgstr "메모리 관리 기술의 대략적인 비교입니다."

#~ msgid "Pros of Different Memory Management Techniques"
#~ msgstr "메모리 관리 방법 별 장점"

#~ msgid "Manual like C:"
#~ msgstr "C와 같은 수동 관리:"

#~ msgid "No runtime overhead."
#~ msgstr "런타임 오버헤드가 없음."

#~ msgid "Automatic like Java:"
#~ msgstr "JAVA와 같은 자동화 관리:"

#~ msgid "Fully automatic."
#~ msgstr "완전한 자동화."

#~ msgid "Safe and correct."
#~ msgstr "안전하고 정확함."

#~ msgid "Scope-based like C++:"
#~ msgstr "C++ 와 같은 범위 기반 관리:"

#~ msgid "Partially automatic."
#~ msgstr "부분 자동화."

#~ msgid "Compiler-enforced scope-based like Rust:"
#~ msgstr "러스트와 같은 컴파일러 수행 범위 기반 관리:"

#~ msgid "Enforced by compiler."
#~ msgstr "컴파일러에 의해 수행됩니다."

#~ msgid "Cons of Different Memory Management Techniques"
#~ msgstr "메모리 관리 방법 별 단점"

#~ msgid "Use-after-free."
#~ msgstr "사용 후 해제 문제."

#~ msgid "Double-frees."
#~ msgstr "이중 해제 문제."

#~ msgid "Memory leaks."
#~ msgstr "메모리 누출 문제."

#~ msgid "Garbage collection pauses."
#~ msgstr "GC동작으로 인한 멈춤."

#~ msgid "Destructor delays."
#~ msgstr ""
#~ "소멸자 지연 (_역주_: 특정 메모리를 더이상 사용하지 않더라도 곧바로 해제 되"
#~ "지 않고 GC가 동작할 때 까지 기다려야 한다는 점)"

#~ msgid "Complex, opt-in by programmer (on C++)."
#~ msgstr "복잡하며, 개발자의 선택사항임."

#~ msgid "Circular references can lead to memory leaks"
#~ msgstr "순환 참조가 발생하면 메모리 누수가 발생함"

#~ msgid "Potential runtime overhead"
#~ msgstr "런타임 오버헤드 있을 수 있음"

#~ msgid "Compiler-enforced and scope-based like Rust:"
#~ msgstr "러스트와 같은 컴파일러가 강제하는 수행 범위 기반 관리:"

#~ msgid "Some upfront complexity."
#~ msgstr "처음에 배울 때 어려움."

#~ msgid "Can reject valid programs."
#~ msgstr "올바른 프로그램이더라도 컴파일러가 거부할 수 있음."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    {\n"
#~ "        let p = Point(3, 4);\n"
#~ "        println!(\"x: {}\", p.0);\n"
#~ "    }\n"
#~ "    println!(\"y: {}\", p.1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    {\n"
#~ "        let p = Point(3, 4);\n"
#~ "        println!(\"x: {}\", p.0);\n"
#~ "    }\n"
#~ "    println!(\"y: {}\", p.1);\n"
#~ "}\n"
#~ "```"

#~ msgid "A destructor can run here to free up resources."
#~ msgstr ""
#~ "스코프가 종료될 때 다른 리소스를 해제하기 위해 소멸자가 호출되도록 할 수 "
#~ "있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Hello!\");\n"
#~ "    let s2: String = s1;\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    // println!(\"s1: {s1}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Hello!\");\n"
#~ "    let s2: String = s1;\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    // println!(\"s1: {s1}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "There is always _exactly_ one variable binding which owns a value."
#~ msgstr "값(데이터)의 소유권을 갖는 변수는 항상 _단_ 하나 입니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Rust\");\n"
#~ "    let s2: String = s1;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Rust\");\n"
#~ "    let s2: String = s1;\n"
#~ "}\n"
#~ "```"

#~ msgid "The heap data from `s1` is reused for `s2`."
#~ msgstr "`s1`의 힙 데이터는 `s2`에서 재사용 됩니다."

#~ msgid ""
#~ "When `s1` goes out of scope, nothing happens (it has been moved from)."
#~ msgstr ""
#~ "`s1`의 스코프가 종료되면 아무일도 일어나지 않습니다.(이미 이동되었습니다.)"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
#~ ":                           :     :                           :\n"
#~ ":    s1                     :     :                           :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
#~ ":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
#~ ":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
#~ ":   | capacity  |     4 |   :     :                           :\n"
#~ ":   +-----------+-------+   :     :                           :\n"
#~ ":                           :     `- - - - - - - - - - - - - -'\n"
#~ ":                           :\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
#~ ":                           :     :                           :\n"
#~ ":    s1                     :     :                           :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
#~ ":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
#~ ":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
#~ ":   | capacity  |     4 |   :     :                           :\n"
#~ ":   +-----------+-------+   :     :                           :\n"
#~ ":                           :     `- - - - - - - - - - - - - -'\n"
#~ ":                           :\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid "Extra Work in Modern C++"
#~ msgstr "Modern C++에서 이중해제 문제"

#~ msgid ""
#~ "```c++\n"
#~ "std::string s1 = \"Cpp\";\n"
#~ "std::string s2 = s1;  // Duplicate the data in s1.\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "std::string s1 = \"Cpp\";\n"
#~ "std::string s2 = s1;  // s1의 데이터를 복제합니다.\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     :                       :\n"
#~ ":    s2                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     :                       :\n"
#~ ":    s2                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = String::from(\"Alice\");\n"
#~ "    say_hello(name);\n"
#~ "    // say_hello(name);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = String::from(\"Alice\");\n"
#~ "    say_hello(name);\n"
#~ "    // say_hello(name);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = 42;\n"
#~ "    let y = x;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    println!(\"y: {y}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = 42;\n"
#~ "    let y = x;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    println!(\"y: {y}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Copy, Clone, Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = p1;\n"
#~ "    println!(\"p1: {p1:?}\");\n"
#~ "    println!(\"p2: {p2:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Copy, Clone, Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = p1;\n"
#~ "    println!(\"p1: {p1:?}\");\n"
#~ "    println!(\"p2: {p2:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "If students ask about `derive`, it is sufficient to say that this is a "
#~ "way to generate code in Rust at compile time. In this case the default "
#~ "implementations of `Copy` and `Clone` traits are generated."
#~ msgstr ""
#~ "만약 학생들이 `derive`에 대해 묻는다면, 컴파일 시 러스트에서 코드를 생성하"
#~ "는방법이라고 말하는 것으로 충분합니다. 위 경우 `Copy`와 `Clone` 트레잇에 "
#~ "대한 기본 구현이 생성됩니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
#~ "    println!(\"&p.0: {:p}\", &p.0);\n"
#~ "    p\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"&p3.0: {:p}\", &p3.0);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
#~ "    println!(\"&p.0: {:p}\", &p.0);\n"
#~ "    p\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"&p3.0: {:p}\", &p3.0);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let mut a: i32 = 10;\n"
#~ "    let b: &i32 = &a;\n"
#~ "\n"
#~ "    {\n"
#~ "        let c: &mut i32 = &mut a;\n"
#~ "        *c = 20;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let mut a: i32 = 10;\n"
#~ "    let b: &i32 = &a;\n"
#~ "\n"
#~ "    {\n"
#~ "        let c: &mut i32 = &mut a;\n"
#~ "        *c = 20;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "A borrowed value has a _lifetime_:"
#~ msgstr "빌려온 값은 _수명_을 갖습니다:"

#~ msgid ""
#~ "The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`."
#~ msgstr "수명은 생략할 수 있습니다: `add(p1: &Point, p2: &Point) -> Point`."

#~ msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
#~ msgstr "물론 명시할 수도 있습니다: `&'a Point`, `&'document str`."

#~ msgid ""
#~ "Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
#~ "lifetime `a`\"."
#~ msgstr ""
#~ "`&'a Point` 는 `Point`의 수명이 최소한 `'a`라는 수명보다는 같거나 더 길다"
#~ "는 것을 의미합니다."

#~ msgid ""
#~ "Lifetimes are always inferred by the compiler: you cannot assign a "
#~ "lifetime yourself."
#~ msgstr ""
#~ "수명은 항상 컴파일러가 자동으로 추론합니다. 직접 수명을 지정할 수는 없습니"
#~ "다."

#~ msgid ""
#~ "In addition to borrowing its arguments, a function can return a borrowed "
#~ "value:"
#~ msgstr "함수는 인수를 빌리는 것 외에도 빌린 값을 반환할 수 있습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p2: Point = Point(20, 20);\n"
#~ "    let p3: &Point = left_most(&p1, &p2);\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p2: Point = Point(20, 20);\n"
#~ "    let p3: &Point = left_most(&p1, &p2);\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"

#~ msgid "`'a` is a generic parameter, it is inferred by the compiler."
#~ msgstr "`'a`는 제네릭 매개변수로 컴파일러로에 의해 추론됩니다."

#~ msgid "Lifetimes start with `'` and `'a` is a typical default name."
#~ msgstr "수명의 이름은 `'` 로 시작하며 보통 `'a`를 많이 씁니다."

#~ msgid ""
#~ "The _at least_ part is important when parameters are in different scopes."
#~ msgstr ""
#~ "매개변수들이 서로 다른 스코프에 있을 경우 \"최소한\"이라는 조건이 중요합니"
#~ "다."

#~ msgid ""
#~ "Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
#~ "resulting in the following code:"
#~ msgstr ""
#~ "`p2`와 `p3`를 새로운 범위(`{...}`)로 아래 코드와 같이 이동해 봅니다:"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p3: &Point;\n"
#~ "    {\n"
#~ "        let p2: Point = Point(20, 20);\n"
#~ "        p3 = left_most(&p1, &p2);\n"
#~ "    }\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p3: &Point;\n"
#~ "    {\n"
#~ "        let p2: Point = Point(20, 20);\n"
#~ "        p3 = left_most(&p1, &p2);\n"
#~ "    }\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"

#~ msgid "Note how this does not compile since `p3` outlives `p2`."
#~ msgstr ""
#~ "`p3`의 수명이 `p2` 보다 길기 때문에 이 예제는 컴파일되지 않음을 확인하시"
#~ "기 바랍니다."

#~ msgid ""
#~ "Reset the workspace and change the function signature to `fn "
#~ "left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will "
#~ "not compile because the relationship between the lifetimes `'a` and `'b` "
#~ "is unclear."
#~ msgstr ""
#~ "작업공간을 초기화 한 후 함수 시그니처를 `fn left_most<'a, 'b>(p1: &'a "
#~ "Point, p2: &'a Point) -> &'b Point`로 변경해 봅니다. 이 경우 `'a`와 `'b`사"
#~ "이의 관계가 불분명하기 때문에 컴파일 되지 않습니다."

#~ msgid "Another way to explain it:"
#~ msgstr "이 에러를 설명하는 또 다른 방법은 다음과 같습니다:"

#~ msgid ""
#~ "Two references to two values are borrowed by a function and the function "
#~ "returns another reference."
#~ msgstr "이 함수는 두 값을 빌려서, 새로운 참조를 반환합니다."

#~ msgid ""
#~ "It must have come from one of those two inputs (or from a global "
#~ "variable)."
#~ msgstr ""
#~ "이 반환된 참조는 두 입력 중 하나로 부터 와야 합니다. (아니면 전역 변수로 "
#~ "부터)"

#~ msgid ""
#~ "Which one is it? The compiler needs to know, so at the call site the "
#~ "returned reference is not used for longer than a variable from where the "
#~ "reference came from."
#~ msgstr ""
#~ "두 입력 중 어떤 것일까요? 컴파일러는 이를 알아야 합니다. 그래야만 함수 호"
#~ "출부에서 봤을 때, 반환된 참조의 수명이 원래 값을 수명보다 길지 않음을 확인"
#~ "할 수 있기 때문입니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);\n"
#~ "\n"
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let text = String::from(\"The quick brown fox jumps over the lazy dog."
#~ "\");\n"
#~ "    let fox = Highlight(&text[4..19]);\n"
#~ "    let dog = Highlight(&text[35..43]);\n"
#~ "    // erase(text);\n"
#~ "    println!(\"{fox:?}\");\n"
#~ "    println!(\"{dog:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);\n"
#~ "\n"
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let text = String::from(\"The quick brown fox jumps over the lazy dog."
#~ "\");\n"
#~ "    let fox = Highlight(&text[4..19]);\n"
#~ "    let dog = Highlight(&text[35..43]);\n"
#~ "    // erase(text);\n"
#~ "    println!(\"{fox:?}\");\n"
#~ "    println!(\"{dog:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Day 1: Afternoon Exercises"
#~ msgstr "1일차 오후 연습문제"

#~ msgid "We will look at two things:"
#~ msgstr "이번 연습문제는 아래 두가지입니다:"

#~ msgid "A small book library,"
#~ msgstr "작은 도서관,"

#~ msgid "Iterators and ownership (hard)."
#~ msgstr "반복자와 소유권 (어려움)"

#~ msgid ""
#~ "We will learn much more about structs and the `Vec<T>` type tomorrow. For "
#~ "now, you just need to know part of its API:"
#~ msgstr ""
#~ "우리는 내일 구조체와 `Vec<T>`에 대해 더 많은 것을 배울 것입니다. 일단 오늘"
#~ "은 API의 일부만 알면 됩니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut vec = vec![10, 20];\n"
#~ "    vec.push(30);\n"
#~ "    let midpoint = vec.len() / 2;\n"
#~ "    println!(\"middle value: {}\", vec[midpoint]);\n"
#~ "    for item in &vec {\n"
#~ "        println!(\"item: {item}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut vec = vec![10, 20];\n"
#~ "    vec.push(30);\n"
#~ "    let midpoint = vec.len() / 2;\n"
#~ "    println!(\"middle value: {}\", vec[midpoint]);\n"
#~ "    for item in &vec {\n"
#~ "        println!(\"item: {item}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Use this to model a library's book collection. Copy the code below to "
#~ "<https://play.rust-lang.org/> and update the types to make it compile:"
#~ msgstr ""
#~ "아래 코드는 도서관에 있는 도서 컬랙션을 모델링 합니다. 아래 코드를 "
#~ "<https://play.rust-lang.org/>에 복사한 후, 컴파일 되도록 수정해 봅시다:"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "struct Library {\n"
#~ "    books: Vec<Book>,\n"
#~ "}\n"
#~ "\n"
#~ "struct Book {\n"
#~ "    title: String,\n"
#~ "    year: u16,\n"
#~ "}\n"
#~ "\n"
#~ "impl Book {\n"
#~ "    // This is a constructor, used below.\n"
#~ "    fn new(title: &str, year: u16) -> Book {\n"
#~ "        Book {\n"
#~ "            title: String::from(title),\n"
#~ "            year,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Implement the methods below. Update the `self` parameter to\n"
#~ "// indicate the method's required level of ownership over the object:\n"
#~ "//\n"
#~ "// - `&self` for shared read-only access,\n"
#~ "// - `&mut self` for unique and mutable access,\n"
#~ "// - `self` for unique access by value.\n"
#~ "impl Library {\n"
#~ "    fn new() -> Library {\n"
#~ "        todo!(\"Initialize and return a `Library` value\")\n"
#~ "    }\n"
#~ "\n"
#~ "    //fn len(self) -> usize {\n"
#~ "    //    todo!(\"Return the length of `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    //    todo!(\"Return `true` if `self.books` is empty\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    //    todo!(\"Add a new book to `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn print_books(self) {\n"
#~ "    //    todo!(\"Iterate over `self.books` and each book's title and "
#~ "year\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
#~ "    //}\n"
#~ "}\n"
#~ "\n"
#~ "// This shows the desired behavior. Uncomment the code below and\n"
#~ "// implement the missing methods. You will need to update the\n"
#~ "// method signatures, including the \"self\" parameter! You may\n"
#~ "// also need to update the variable bindings within main.\n"
#~ "fn main() {\n"
#~ "    let library = Library::new();\n"
#~ "\n"
#~ "    //println!(\"The library is empty: library.is_empty() -> {}\", "
#~ "library.is_empty());\n"
#~ "    //\n"
#~ "    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
#~ "1865));\n"
#~ "    //\n"
#~ "    //println!(\"The library is no longer empty: library.is_empty() -> "
#~ "{}\", library.is_empty());\n"
#~ "    //\n"
#~ "    //\n"
#~ "    //library.print_books();\n"
#~ "    //\n"
#~ "    //match library.oldest_book() {\n"
#~ "    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
#~ "    //    None => println!(\"The library is empty!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"The library has {} books\", library.len());\n"
#~ "    //library.print_books();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "struct Library {\n"
#~ "    books: Vec<Book>,\n"
#~ "}\n"
#~ "\n"
#~ "struct Book {\n"
#~ "    title: String,\n"
#~ "    year: u16,\n"
#~ "}\n"
#~ "\n"
#~ "impl Book {\n"
#~ "    // This is a constructor, used below.\n"
#~ "    fn new(title: &str, year: u16) -> Book {\n"
#~ "        Book {\n"
#~ "            title: String::from(title),\n"
#~ "            year,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Implement the methods below. Update the `self` parameter to\n"
#~ "// indicate the method's required level of ownership over the object:\n"
#~ "//\n"
#~ "// - `&self` for shared read-only access,\n"
#~ "// - `&mut self` for unique and mutable access,\n"
#~ "// - `self` for unique access by value.\n"
#~ "impl Library {\n"
#~ "    fn new() -> Library {\n"
#~ "        todo!(\"Initialize and return a `Library` value\")\n"
#~ "    }\n"
#~ "\n"
#~ "    //fn len(self) -> usize {\n"
#~ "    //    todo!(\"Return the length of `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    //    todo!(\"Return `true` if `self.books` is empty\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    //    todo!(\"Add a new book to `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn print_books(self) {\n"
#~ "    //    todo!(\"Iterate over `self.books` and each book's title and "
#~ "year\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
#~ "    //}\n"
#~ "}\n"
#~ "\n"
#~ "// This shows the desired behavior. Uncomment the code below and\n"
#~ "// implement the missing methods. You will need to update the\n"
#~ "// method signatures, including the \"self\" parameter! You may\n"
#~ "// also need to update the variable bindings within main.\n"
#~ "fn main() {\n"
#~ "    let library = Library::new();\n"
#~ "\n"
#~ "    //println!(\"The library is empty: library.is_empty() -> {}\", "
#~ "library.is_empty());\n"
#~ "    //\n"
#~ "    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
#~ "1865));\n"
#~ "    //\n"
#~ "    //println!(\"The library is no longer empty: library.is_empty() -> "
#~ "{}\", library.is_empty());\n"
#~ "    //\n"
#~ "    //\n"
#~ "    //library.print_books();\n"
#~ "    //\n"
#~ "    //match library.oldest_book() {\n"
#~ "    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
#~ "    //    None => println!(\"The library is empty!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"The library has {} books\", library.len());\n"
#~ "    //library.print_books();\n"
#~ "}\n"
#~ "```"

#~ msgid "[Solution](solutions-afternoon.md#designing-a-library)"
#~ msgstr "[해답](solutions-afternoon.md#designing-a-library)"

#~ msgid ""
#~ "The ownership model of Rust affects many APIs. An example of this is the "
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) traits."
#~ msgstr ""
#~ "러스트의 소유권 모델은 많은 API에 반영이 되어 있습니다. 예를들어 "
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) 와 "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) 같은 트레잇이 있습니다."

#~ msgid ""
#~ "Traits are like interfaces: they describe behavior (methods) for a type. "
#~ "The `Iterator` trait simply says that you can call `next` until you get "
#~ "`None` back:"
#~ msgstr ""
#~ "트레잇은 타입에 대한 행동(메서드)를 설명한다는 점에서 인터페이스와 유사합"
#~ "니다. `Iterator`는 단순히 `None`이 나올때까지 `next`를 호출하는 것이 가능"
#~ "하다는 것을 나타내는 트레잇입니다:"

#~ msgid ""
#~ "```rust\n"
#~ "pub trait Iterator {\n"
#~ "    type Item;\n"
#~ "    fn next(&mut self) -> Option<Self::Item>;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub trait Iterator {\n"
#~ "    type Item;\n"
#~ "    fn next(&mut self) -> Option<Self::Item>;\n"
#~ "}\n"
#~ "```"

#~ msgid "You use this trait like this:"
#~ msgstr "`Iterator` 트레잇은 이렇게 사용합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    println!(\"v[0]: {:?}\", iter.next());\n"
#~ "    println!(\"v[1]: {:?}\", iter.next());\n"
#~ "    println!(\"v[2]: {:?}\", iter.next());\n"
#~ "    println!(\"No more items: {:?}\", iter.next());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    println!(\"v[0]: {:?}\", iter.next());\n"
#~ "    println!(\"v[1]: {:?}\", iter.next());\n"
#~ "    println!(\"v[2]: {:?}\", iter.next());\n"
#~ "    println!(\"No more items: {:?}\", iter.next());\n"
#~ "}\n"
#~ "```"

#~ msgid "What is the type returned by the iterator? Test your answer here:"
#~ msgstr ""
#~ "반복자가 반환하는 값들은 타입이 뭘까요? 여기서 답을 테스트 해 보세요:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Why is this type used?"
#~ msgstr "왜 이런 타입이 사용되는 것일까요?"

#~ msgid ""
#~ "```rust\n"
#~ "pub trait IntoIterator {\n"
#~ "    type Item;\n"
#~ "    type IntoIter: Iterator<Item = Self::Item>;\n"
#~ "\n"
#~ "    fn into_iter(self) -> Self::IntoIter;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub trait IntoIterator {\n"
#~ "    type Item;\n"
#~ "    type IntoIter: Iterator<Item = Self::Item>;\n"
#~ "\n"
#~ "    fn into_iter(self) -> Self::IntoIter;\n"
#~ "}\n"
#~ "```"

#~ msgid "Like before, what  is the type returned by the iterator?"
#~ msgstr "이전과 마찬가지로, 반복자가 반환하는 타입은 무엇입니까?"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
#~ "loops. They call `into_iter()` on an expression and iterates over the "
#~ "resulting iterator:"
#~ msgstr ""
#~ "자, 이제 우리는 `Iterator`와 `IntoIterator`를 알았으므로 `for` 루프를 만"
#~ "들 수 있습니다. `for` 루프는 `into_iter()`를 호출하여 반복자를 만든 다음 "
#~ "그 반복자를 이용하여 요소들을 반복해서 접근합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "\n"
#~ "    for word in &v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    for word in v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "\n"
#~ "    for word in &v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    for word in v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Experiment with the code above and then consult the documentation for "
#~ "[`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/"
#~ "struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) and [`impl "
#~ "IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
#~ "html#impl-IntoIterator-for-Vec%3CT,+A%3E) to check your answers."
#~ msgstr ""
#~ "위 코드에서 실험 해 본 후, 다음 문서를 참조해서 답변을 확인하시기 바랍니"
#~ "다:[`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/"
#~ "struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E), [`impl "
#~ "IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
#~ "html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)"

#~ msgid "Structs, enums, methods."
#~ msgstr "구조체, 열거형, 메서드."

#~ msgid ""
#~ "Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
#~ "and `continue`."
#~ msgstr ""
#~ "흐름 제어: `if`, `if let`, `while`, `while let`, `break`, 그리고 "
#~ "`continue`."

#~ msgid ""
#~ "The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
#~ "`Rc` and `Arc`."
#~ msgstr ""
#~ "표준 라이브러리: `String`, `Option` 과 `Result`, `Vec`, `HashMap`, `Rc` 그"
#~ "리고 `Arc`."

#~ msgid "Modules: visibility, paths, and filesystem hierarchy."
#~ msgstr "모듈: 가시성, 경로 및 파일 시스템 계층."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    peter.age = 28;\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    let jackie = Person {\n"
#~ "        name: String::from(\"Jackie\"),\n"
#~ "        ..peter\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    peter.age = 28;\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    let jackie = Person {\n"
#~ "        name: String::from(\"Jackie\"),\n"
#~ "        ..peter\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Methods are defined in an `impl` block, which we will see in following "
#~ "slides."
#~ msgstr ""
#~ "메서드는 `impl`블록에 정의 합니다. 다음 슬라이드에서 확인 할 수 있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(17, 23);\n"
#~ "    println!(\"({}, {})\", p.0, p.1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(17, 23);\n"
#~ "    println!(\"({}, {})\", p.0, p.1);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "struct PoundsOfForce(f64);\n"
#~ "struct Newtons(f64);\n"
#~ "\n"
#~ "fn compute_thruster_force() -> PoundsOfForce {\n"
#~ "    todo!(\"Ask a rocket scientist at NASA\")\n"
#~ "}\n"
#~ "\n"
#~ "fn set_thruster_force(force: Newtons) {\n"
#~ "    // ...\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let force = compute_thruster_force();\n"
#~ "    set_thruster_force(force);\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "struct PoundsOfForce(f64);\n"
#~ "struct Newtons(f64);\n"
#~ "\n"
#~ "fn compute_thruster_force() -> PoundsOfForce {\n"
#~ "    todo!(\"Ask a rocket scientist at NASA\")\n"
#~ "}\n"
#~ "\n"
#~ "fn set_thruster_force(force: Newtons) {\n"
#~ "    // ...\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let force = compute_thruster_force();\n"
#~ "    set_thruster_force(force);\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Person {\n"
#~ "        Person { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person::new(String::from(\"Peter\"), 27);\n"
#~ "    println!(\"{peter:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Person {\n"
#~ "        Person { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person::new(String::from(\"Peter\"), 27);\n"
#~ "    println!(\"{peter:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The `new` function could be written using `Self` as a type, as it is "
#~ "interchangeable with the struct type name"
#~ msgstr ""
#~ "`new`함수를 다음처럼 구조체 이름 대신 `Self`를 사용하여 작성해도 됩니다"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Self {\n"
#~ "        Self { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Self {\n"
#~ "        Self { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Implement the `Default` trait for the struct. Define some fields and use "
#~ "the default values for the other fields."
#~ msgstr ""
#~ "`Default` 트레잇을 구현해보세요. 필드 몇개는 초기화하고 나머지 필드는 디폴"
#~ "트 값을 사용할 수 있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Default for Person {\n"
#~ "    fn default() -> Person {\n"
#~ "        Person {\n"
#~ "            name: \"Bot\".to_string(),\n"
#~ "            age: 0,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "fn create_default() {\n"
#~ "    let tmp = Person {\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "    let tmp = Person {\n"
#~ "        name: \"Sam\".to_string(),\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Default for Person {\n"
#~ "    fn default() -> Person {\n"
#~ "        Person {\n"
#~ "            name: \"Bot\".to_string(),\n"
#~ "            age: 0,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "fn create_default() {\n"
#~ "    let tmp = Person {\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "    let tmp = Person {\n"
#~ "        name: \"Sam\".to_string(),\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid "Methods are defined in the `impl` block."
#~ msgstr "메서드는 `impl` 블록에 정의됩니다."

#~ msgid ""
#~ "Use struct update syntax to define a new structure using `peter`. Note "
#~ "that the variable `peter` will no longer be accessible afterwards."
#~ msgstr ""
#~ "`peter`와 구조체 업데이트 문법을 사용하여 새로운 구조체 인스턴스를 만들어"
#~ "보세요. 이때, `peter`는 더이상 사용할 수 없게 됩니다."

#~ msgid ""
#~ "Use `{:#?}` when printing structs to request the `Debug` representation."
#~ msgstr "구조체를 `Debug` 형태로 출력하려면 `{:#?}`를 사용하세요."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn generate_random_number() -> i32 {\n"
#~ "    // Implementation based on https://xkcd.com/221/\n"
#~ "    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum CoinFlip {\n"
#~ "    Heads,\n"
#~ "    Tails,\n"
#~ "}\n"
#~ "\n"
#~ "fn flip_coin() -> CoinFlip {\n"
#~ "    let random_number = generate_random_number();\n"
#~ "    if random_number % 2 == 0 {\n"
#~ "        return CoinFlip::Heads;\n"
#~ "    } else {\n"
#~ "        return CoinFlip::Tails;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"You got: {:?}\", flip_coin());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn generate_random_number() -> i32 {\n"
#~ "    // Implementation based on https://xkcd.com/221/\n"
#~ "    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum CoinFlip {\n"
#~ "    Heads,\n"
#~ "    Tails,\n"
#~ "}\n"
#~ "\n"
#~ "fn flip_coin() -> CoinFlip {\n"
#~ "    let random_number = generate_random_number();\n"
#~ "    if random_number % 2 == 0 {\n"
#~ "        return CoinFlip::Heads;\n"
#~ "    } else {\n"
#~ "        return CoinFlip::Tails;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"You got: {:?}\", flip_coin());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "This page offers an enum type `CoinFlip` with two variants `Heads` and "
#~ "`Tails`. You might note the namespace when using variants."
#~ msgstr ""
#~ "위의 `CoinFlip` 열거형 타입은 `Heads`와 `Tail` 두 가지 variant를 가집니"
#~ "다. 열거형 타입의 variant는 네임스페이스를 붙여서 사용합니다."

#~ msgid "In both, associated functions are defined within an `impl` block."
#~ msgstr "둘 다 연관함수를 `impl`블록으로 정의 할 수 있습니다."

#~ msgid ""
#~ "You can define richer enums where the variants carry data. You can then "
#~ "use the `match` statement to extract the data from each variant:"
#~ msgstr ""
#~ "좀더 복잡한 열거형의 경우 variant에 데이터(payload)를 포함시키도 합니다. "
#~ "각 variant에 담긴 데이터는 `match`문을 이용해 추출합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // Variant without payload\n"
#~ "    KeyPress(char),           // Tuple struct variant\n"
#~ "    Click { x: i64, y: i64 }, // Full struct variant\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, "
#~ "y={y}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };\n"
#~ "\n"
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // 페이로드가 없는 유형\n"
#~ "    KeyPress(char),           // 튜플 구조체 유형\n"
#~ "    Click { x: i64, y: i64 }, // 완전한 구조체 유형\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, "
#~ "y={y}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };\n"
#~ "\n"
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The expression is matched against the patterns from top to bottom. There "
#~ "is no fall-through like in C or C++."
#~ msgstr ""
#~ "매치 패턴들은 위에서 아래로 순서에 따라 검사합니다. C나 C++에서와 같은 "
#~ "fall-through는 없습니다."

#~ msgid ""
#~ "The match expression has a value. The value is the last expression in the "
#~ "match arm which was executed."
#~ msgstr ""
#~ "매치 표현식 자체는 값을 가집니다. 그 값은 매칭이 된 패턴에서 가장 마지막"
#~ "에 수행된 표현식이 됩니다."

#~ msgid ""
#~ "Starting from the top we look for what pattern matches the value then run "
#~ "the code following the arrow. Once we find a match, we stop. "
#~ msgstr ""
#~ "가장 위에서 부터 어떤 패턴이 주어진 값과 매칭하는지 검사한 다음, 매칭된 것"
#~ "이 발견되면 화살표를 따라 코드를 수행합니다. 한 번 매칭이 되고 코드가 수행"
#~ "이 되면, 더이상의 매칭은 없습니다. "

#~ msgid "`match` inspects a hidden discriminant field in the `enum`."
#~ msgstr ""
#~ "`match`는 주어진 열거형 값이 실제로 어떤 variant인지 판단하기 위해, 그 "
#~ "variant의 종류가 기록된, 숨겨진 필드(식별자)의 값을 검사합니다."

#~ msgid ""
#~ "It is possible to retrieve the discriminant by calling `std::mem::"
#~ "discriminant()`"
#~ msgstr "`std::mem::discriminant()`를 이용하여 식별자를 얻을 수도 있습니다"

#~ msgid ""
#~ "This is useful, for example, if implementing `PartialEq` for structs "
#~ "where comparing field values doesn't affect equality."
#~ msgstr ""
#~ "이는 각 필드 값을 굳이 비교할 필요 없는 구조체에 대해 `PartialEq` 트레잇"
#~ "을 구현할 때 유용합니다."

#~ msgid ""
#~ "`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
#~ "Click(Click)` with a top level `struct Click { ... }`. The inlined "
#~ "version cannot implement traits, for example."
#~ msgstr ""
#~ "`WebEvent::Click { ... }`은 최상위 레벨 구조체 `struct Click {...}`를 따"
#~ "로 정의하고 `WebEvent::Click(Click)`처럼 튜플 형태로 정의한 것과 정확히 같"
#~ "진 않습니다. 예를 들어 `WebEvent::Click { ... }` 로 정의한 경우, 구조체 형"
#~ "태와 유사하지만 트레잇을 구현 할 수 없습니다."

#~ msgid ""
#~ "Rust enums are packed tightly, taking constraints due to alignment into "
#~ "account:"
#~ msgstr ""
#~ "러스트의 열거형은 정렬(alignment)로 인한 제약을 고려하여 크기를 빽빽하게 "
#~ "잡습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::any::type_name;\n"
#~ "use std::mem::{align_of, size_of};\n"
#~ "\n"
#~ "fn dbg_size<T>() {\n"
#~ "    println!(\"{}: size {} bytes, align: {} bytes\",\n"
#~ "        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
#~ "}\n"
#~ "\n"
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    dbg_size::<Foo>();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::any::type_name;\n"
#~ "use std::mem::{align_of, size_of};\n"
#~ "\n"
#~ "fn dbg_size<T>() {\n"
#~ "    println!(\"{}: size {} bytes, align: {} bytes\",\n"
#~ "        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
#~ "}\n"
#~ "\n"
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    dbg_size::<Foo>();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Internally Rust is using a field (discriminant) to keep track of the enum "
#~ "variant."
#~ msgstr ""
#~ "러스트는 열거형 variant를 구분하기 위해 내부적으로 식별자(discriminant) 필"
#~ "드를 사용합니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[repr(u32)]\n"
#~ "enum Bar {\n"
#~ "    A,  // 0\n"
#~ "    B = 10000,\n"
#~ "    C,  // 10001\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"A: {}\", Bar::A as u32);\n"
#~ "    println!(\"B: {}\", Bar::B as u32);\n"
#~ "    println!(\"C: {}\", Bar::C as u32);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[repr(u32)]\n"
#~ "enum Bar {\n"
#~ "    A,  // 0\n"
#~ "    B = 10000,\n"
#~ "    C,  // 10001\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"A: {}\", Bar::A as u32);\n"
#~ "    println!(\"B: {}\", Bar::B as u32);\n"
#~ "    println!(\"C: {}\", Bar::C as u32);\n"
#~ "}\n"
#~ "```"

#~ msgid "Try out other types such as"
#~ msgstr "다른 타입들도 확인해보세요"

#~ msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
#~ msgstr "`dbg_size!(bool)`: 크기 1 바이트, 정렬: 1 바이트,"

#~ msgid ""
#~ "`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche "
#~ "optimization, see below),"
#~ msgstr ""
#~ "`dbg_size!(Option<bool>)`: 크기 1 바이트, 정렬: 1 바이트 (니치 최적화, 아"
#~ "래 설명 참조)"

#~ msgid ""
#~ "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
#~ msgstr ""
#~ "`dbg_size!(&i32)`: 크기 8 바이트, 정렬: 8 바이트 (64비트 머신인 경우)"

#~ msgid ""
#~ "`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
#~ "optimization, see below)."
#~ msgstr ""
#~ "`dbg_size!(Option<&i32>)`: 크기 8 바이트, 정렬: 8 바이트 (널포인터 최적"
#~ "화, 아래 설명 참조)"

#~ msgid ""
#~ "Niche optimization: Rust will merge unused bit patterns for the enum "
#~ "discriminant."
#~ msgstr ""
#~ "니치 최적화: 러스트는 열거형 식별자를 사용되지 않은 비트 패턴과 병합합니"
#~ "다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        println!(\"Bitwise representation of bool\");\n"
#~ "        dbg_bits!(false, u8);\n"
#~ "        dbg_bits!(true, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<bool>\");\n"
#~ "        dbg_bits!(None::<bool>, u8);\n"
#~ "        dbg_bits!(Some(false), u8);\n"
#~ "        dbg_bits!(Some(true), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
#~ "        dbg_bits!(Some(Some(false)), u8);\n"
#~ "        dbg_bits!(Some(Some(true)), u8);\n"
#~ "        dbg_bits!(Some(None::<bool>), u8);\n"
#~ "        dbg_bits!(None::<Option<bool>>, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<&i32>\");\n"
#~ "        dbg_bits!(None::<&i32>, usize);\n"
#~ "        dbg_bits!(Some(&0i32), usize);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        println!(\"Bitwise representation of bool\");\n"
#~ "        dbg_bits!(false, u8);\n"
#~ "        dbg_bits!(true, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<bool>\");\n"
#~ "        dbg_bits!(None::<bool>, u8);\n"
#~ "        dbg_bits!(Some(false), u8);\n"
#~ "        dbg_bits!(Some(true), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
#~ "        dbg_bits!(Some(Some(false)), u8);\n"
#~ "        dbg_bits!(Some(Some(true)), u8);\n"
#~ "        dbg_bits!(Some(None::<bool>), u8);\n"
#~ "        dbg_bits!(None::<Option<bool>>, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<&i32>\");\n"
#~ "        dbg_bits!(None::<&i32>, usize);\n"
#~ "        dbg_bits!(Some(&0i32), usize);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "More complex example if you want to discuss what happens when we chain "
#~ "more than 256 `Option`s together."
#~ msgstr ""
#~ "아래는 좀 더 복잡한 예제입니다.  256개 이상의 `Option`이 중첩되어 연결되"
#~ "어 있을 경우 어떻게 되는지 보여줍니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#![recursion_limit = \"1000\"]\n"
#~ "\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
#~ "signs.\n"
#~ "// Increasing the recursion limit is required to evaluate this macro.\n"
#~ "macro_rules! many_options {\n"
#~ "    ($value:expr) => { Some($value) };\n"
#~ "    ($value:expr, @) => {\n"
#~ "        Some(Some($value))\n"
#~ "    };\n"
#~ "    ($value:expr, @ $($more:tt)+) => {\n"
#~ "        many_options!(many_options!($value, $($more)+), $($more)+)\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        assert_eq!(many_options!(false), Some(false));\n"
#~ "        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
#~ "        assert_eq!(many_options!(false, @@), "
#~ "Some(Some(Some(Some(false)))));\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 128 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 256 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 257 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#![recursion_limit = \"1000\"]\n"
#~ "\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
#~ "signs.\n"
#~ "// Increasing the recursion limit is required to evaluate this macro.\n"
#~ "macro_rules! many_options {\n"
#~ "    ($value:expr) => { Some($value) };\n"
#~ "    ($value:expr, @) => {\n"
#~ "        Some(Some($value))\n"
#~ "    };\n"
#~ "    ($value:expr, @ $($more:tt)+) => {\n"
#~ "        many_options!(many_options!($value, $($more)+), $($more)+)\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        assert_eq!(many_options!(false), Some(false));\n"
#~ "        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
#~ "        assert_eq!(many_options!(false, @@), "
#~ "Some(Some(Some(Some(false)))));\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 128 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 256 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 257 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Hello, my name is {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    peter.say_hello();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Hello, my name is {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    peter.say_hello();\n"
#~ "}\n"
#~ "```"

#~ msgid "We describe the distinction between method receivers next."
#~ msgstr "다음 슬라이드에서 receiver의 구분을 설명합니다."

#~ msgid ""
#~ "Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
#~ "These constraints always come together in Rust due to borrow checker "
#~ "rules, and `self` is no exception. It isn't possible to reference a "
#~ "struct from multiple locations and call a mutating (`&mut self`) method "
#~ "on it."
#~ msgstr ""
#~ "\"공유가능한 불변\"과 \"유일한 가변\" 부분은 강조할 만합니다. 이러한 제약"
#~ "은 러스트의 빌림 검사기(borrow checker) 규칙으로 늘 붙어다닙니다. `self`"
#~ "도 예외는 아닙니다. 여러 위치에서 구조체를 참조하면서 객체를 수정하는"
#~ "(`&mut self`를 리시버로 하는) 메서드를 호출하는 것은 불가능합니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Race {\n"
#~ "    name: String,\n"
#~ "    laps: Vec<i32>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Race {\n"
#~ "    fn new(name: &str) -> Race {  // No receiver, a static method\n"
#~ "        Race { name: String::from(name), laps: Vec::new() }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
#~ "access to self\n"
#~ "        self.laps.push(lap);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn print_laps(&self) {  // Shared and read-only borrowed access to "
#~ "self\n"
#~ "        println!(\"Recorded {} laps for {}:\", self.laps.len(), self."
#~ "name);\n"
#~ "        for (idx, lap) in self.laps.iter().enumerate() {\n"
#~ "            println!(\"Lap {idx}: {lap} sec\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn finish(self) {  // Exclusive ownership of self\n"
#~ "        let total = self.laps.iter().sum::<i32>();\n"
#~ "        println!(\"Race {} is finished, total lap time: {}\", self.name, "
#~ "total);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut race = Race::new(\"Monaco Grand Prix\");\n"
#~ "    race.add_lap(70);\n"
#~ "    race.add_lap(68);\n"
#~ "    race.print_laps();\n"
#~ "    race.add_lap(71);\n"
#~ "    race.print_laps();\n"
#~ "    race.finish();\n"
#~ "    // race.add_lap(42);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Race {\n"
#~ "    name: String,\n"
#~ "    laps: Vec<i32>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Race {\n"
#~ "    fn new(name: &str) -> Race {  // No receiver, a static method\n"
#~ "        Race { name: String::from(name), laps: Vec::new() }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
#~ "access to self\n"
#~ "        self.laps.push(lap);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn print_laps(&self) {  // Shared and read-only borrowed access to "
#~ "self\n"
#~ "        println!(\"Recorded {} laps for {}:\", self.laps.len(), self."
#~ "name);\n"
#~ "        for (idx, lap) in self.laps.iter().enumerate() {\n"
#~ "            println!(\"Lap {idx}: {lap} sec\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn finish(self) {  // Exclusive ownership of self\n"
#~ "        let total = self.laps.iter().sum::<i32>();\n"
#~ "        println!(\"Race {} is finished, total lap time: {}\", self.name, "
#~ "total);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut race = Race::new(\"Monaco Grand Prix\");\n"
#~ "    race.add_lap(70);\n"
#~ "    race.add_lap(68);\n"
#~ "    race.print_laps();\n"
#~ "    race.add_lap(71);\n"
#~ "    race.print_laps();\n"
#~ "    race.finish();\n"
#~ "    // race.add_lap(42);\n"
#~ "}\n"
#~ "```"

#~ msgid "All four methods here use a different method receiver."
#~ msgstr "이 네 개의 메서드는 서로 다른 유형의 리시버를 사용합니다."

#~ msgid ""
#~ "You can point out how that changes what the function can do with the "
#~ "variable values and if/how it can be used again in `main`."
#~ msgstr ""
#~ "리시버의 유형에 따라 함수가 할 수 있는 일이 달라지고, 또 메소드를 호출한 "
#~ "뒤 `main`에서 해당 객체를 사용할 수 있는지 여부도 달라진다는 점을 강조하세"
#~ "요."

#~ msgid ""
#~ "You can showcase the error that appears when trying to call `finish` "
#~ "twice."
#~ msgstr "`finish`를 두번 호출하여 오류가 발생하는 것을 보일 수 있습니다."

#~ msgid ""
#~ "Note that although the method receivers are different, the non-static "
#~ "functions are called the same way in the main body. Rust enables "
#~ "automatic referencing and dereferencing when calling methods. Rust "
#~ "automatically adds in the `&`, `*`, `muts` so that that object matches "
#~ "the method signature."
#~ msgstr ""
#~ "비록 메서드 receiver는 다르지만 main 함수에서 비 정적 함수를 부르는 방법"
#~ "은 같습니다. 러스트는 메서드를 호출할 때 자동으로 참조/역참조(따라가기)를 "
#~ "수행합니다. 러스트는 객체와 매서드 시그니처가 서로 매치되도록 객체에 `&`, "
#~ "`*`, `muts`를 자동으로 붙여줍니다."

#~ msgid ""
#~ "You might point out that `print_laps` is using a vector that is iterated "
#~ "over. We describe vectors in more detail in the afternoon. "
#~ msgstr ""
#~ "`print_laps`함수에서 벡터를 어떤 식으로 사용하고 있는지 언급하는 것도 좋습"
#~ "니다. 벡터는 오후 강의에서 더 자세히 설명할 것입니다. "

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let input = 'x';\n"
#~ "\n"
#~ "    match input {\n"
#~ "        'q'                   => println!(\"Quitting\"),\n"
#~ "        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
#~ "        '0'..='9'             => println!(\"Number input\"),\n"
#~ "        _                     => println!(\"Something else\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let input = 'x';\n"
#~ "\n"
#~ "    match input {\n"
#~ "        'q'                   => println!(\"Quitting\"),\n"
#~ "        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
#~ "        '0'..='9'             => println!(\"Number input\"),\n"
#~ "        _                     => println!(\"Something else\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "The `_` pattern is a wildcard pattern which matches any value."
#~ msgstr "`_`패턴은 어떤 값과도 매칭되는 와일드카드입니다."

#~ msgid ""
#~ "It can be useful to show how binding works, by for instance replacing a "
#~ "wildcard character with a variable, or removing the quotes around `q`."
#~ msgstr ""
#~ "와일드카드 문자를 변수로 바꾸거나 `q`의 따옴표를 제거하는 식으로 수정하면"
#~ "서 바인딩이 어떻게 작동하는지 보여주는 것도 유용할 수 있습니다."

#~ msgid "You can demonstrate matching on a reference."
#~ msgstr "참조를 매칭하는 것도 시연할 수 있습니다."

#~ msgid ""
#~ "This might be a good time to bring up the concept of irrefutable "
#~ "patterns, as the term can show up in error messages."
#~ msgstr ""
#~ "에러 메시지에 \"반박 불가능 패턴(irrefutable pattern)\"이란 용어가 등장하"
#~ "기도 합니다. 지금 그 의미를 소개하는 것도 좋을 것 같습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum Result {\n"
#~ "    Ok(i32),\n"
#~ "    Err(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn divide_in_two(n: i32) -> Result {\n"
#~ "    if n % 2 == 0 {\n"
#~ "        Result::Ok(n / 2)\n"
#~ "    } else {\n"
#~ "        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let n = 100;\n"
#~ "    match divide_in_two(n) {\n"
#~ "        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
#~ "        Result::Err(msg) => println!(\"sorry, an error happened: "
#~ "{msg}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum Result {\n"
#~ "    Ok(i32),\n"
#~ "    Err(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn divide_in_two(n: i32) -> Result {\n"
#~ "    if n % 2 == 0 {\n"
#~ "        Result::Ok(n / 2)\n"
#~ "    } else {\n"
#~ "        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let n = 100;\n"
#~ "    match divide_in_two(n) {\n"
#~ "        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
#~ "        Result::Err(msg) => println!(\"sorry, an error happened: "
#~ "{msg}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "You can also destructure `structs`:"
#~ msgstr "`struct` 구조체 역시 분해할 수 있습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Foo {\n"
#~ "    x: (u32, u32),\n"
#~ "    y: u32,\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let foo = Foo { x: (1, 2), y: 3 };\n"
#~ "    match foo {\n"
#~ "        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
#~ "        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
#~ "        Foo { y, .. }        => println!(\"y = {y}, other fields were "
#~ "ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Foo {\n"
#~ "    x: (u32, u32),\n"
#~ "    y: u32,\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let foo = Foo { x: (1, 2), y: 3 };\n"
#~ "    match foo {\n"
#~ "        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
#~ "        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
#~ "        Foo { y, .. }        => println!(\"y = {y}, other fields were "
#~ "ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let triple = [0, -2, 3];\n"
#~ "    println!(\"Tell me about {triple:?}\");\n"
#~ "    match triple {\n"
#~ "        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
#~ "        _         => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let triple = [0, -2, 3];\n"
#~ "    println!(\"Tell me about {triple:?}\");\n"
#~ "    match triple {\n"
#~ "        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
#~ "        _         => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Destructuring of slices of unknown length also works with patterns of "
#~ "fixed length."
#~ msgstr ""
#~ "길이를 알 수 없는 슬라이스에 대해서도 고정 길이 패턴으로 분해할 수 있습니"
#~ "다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    inspect(&[0, -2, 3]);\n"
#~ "    inspect(&[0, -2, 3, 4]);\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(slice: &[i32]) {\n"
#~ "    println!(\"Tell me about {slice:?}\");\n"
#~ "    match slice {\n"
#~ "        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        &[1, ..]   => println!(\"First is 1 and the rest were "
#~ "ignored\"),\n"
#~ "        _          => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    inspect(&[0, -2, 3]);\n"
#~ "    inspect(&[0, -2, 3, 4]);\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(slice: &[i32]) {\n"
#~ "    println!(\"Tell me about {slice:?}\");\n"
#~ "    match slice {\n"
#~ "        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        &[1, ..]   => println!(\"First is 1 and the rest were "
#~ "ignored\"),\n"
#~ "        _          => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "When matching, you can add a _guard_ to a pattern. This is an arbitrary "
#~ "Boolean expression which will be executed if the pattern matches:"
#~ msgstr ""
#~ "패턴 뒤에 가드(guard, 조건식)를 덧붙일 수 있습니다. 가드는 패턴이 매치되"
#~ "면 추가로 따져보는 불리언 표현식입니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let pair = (2, -2);\n"
#~ "    println!(\"Tell me about {pair:?}\");\n"
#~ "    match pair {\n"
#~ "        (x, y) if x == y     => println!(\"These are twins\"),\n"
#~ "        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
#~ "        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
#~ "        _                    => println!(\"No correlation...\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let pair = (2, -2);\n"
#~ "    println!(\"Tell me about {pair:?}\");\n"
#~ "    match pair {\n"
#~ "        (x, y) if x == y     => println!(\"These are twins\"),\n"
#~ "        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
#~ "        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
#~ "        _                    => println!(\"No correlation...\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "You can use the variables defined in the pattern in your if expression."
#~ msgstr "패턴에 정의된 변수를 가드의 표현식에서 사용할 수 있습니다."

#~ msgid "Day 2: Morning Exercises"
#~ msgstr "2일차 오전 연습문제"

#~ msgid "We will look at implementing methods in two contexts:"
#~ msgstr "이번 연습문제들은 두가지 맥락에서 메서드 구현방법을 다룹니다:"

#~ msgid "Simple struct which tracks health statistics."
#~ msgstr "건강 상태 통계를 추적하는 프로그램의 간단한 구조체."

#~ msgid "Multiple structs and enums for a drawing library."
#~ msgstr "드로잉 라이브러리를 위한 구조체 및 열거헝."

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct User {\n"
#~ "    name: String,\n"
#~ "    age: u32,\n"
#~ "    height: f32,\n"
#~ "    visit_count: usize,\n"
#~ "    last_blood_pressure: Option<(u32, u32)>,\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Measurements {\n"
#~ "    height: f32,\n"
#~ "    blood_pressure: (u32, u32),\n"
#~ "}\n"
#~ "\n"
#~ "pub struct HealthReport<'a> {\n"
#~ "    patient_name: &'a str,\n"
#~ "    visit_count: u32,\n"
#~ "    height_change: f32,\n"
#~ "    blood_pressure_change: Option<(i32, i32)>,\n"
#~ "}\n"
#~ "\n"
#~ "impl User {\n"
#~ "    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn name(&self) -> &str {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn age(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn height(&self) -> f32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn doctor_visits(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_age(&mut self, new_age: u32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_height(&mut self, new_height: f32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
#~ "HealthReport {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_height() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.height(), 155.2);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_set_age() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.age(), 32);\n"
#~ "    bob.set_age(33);\n"
#~ "    assert_eq!(bob.age(), 33);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_visit() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.doctor_visits(), 0);\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (120, 80),\n"
#~ "    });\n"
#~ "    assert_eq!(report.patient_name, \"Bob\");\n"
#~ "    assert_eq!(report.visit_count, 1);\n"
#~ "    assert_eq!(report.blood_pressure_change, None);\n"
#~ "\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (115, 76),\n"
#~ "    });\n"
#~ "\n"
#~ "    assert_eq!(report.visit_count, 2);\n"
#~ "    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct User {\n"
#~ "    name: String,\n"
#~ "    age: u32,\n"
#~ "    height: f32,\n"
#~ "    visit_count: usize,\n"
#~ "    last_blood_pressure: Option<(u32, u32)>,\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Measurements {\n"
#~ "    height: f32,\n"
#~ "    blood_pressure: (u32, u32),\n"
#~ "}\n"
#~ "\n"
#~ "pub struct HealthReport<'a> {\n"
#~ "    patient_name: &'a str,\n"
#~ "    visit_count: u32,\n"
#~ "    height_change: f32,\n"
#~ "    blood_pressure_change: Option<(i32, i32)>,\n"
#~ "}\n"
#~ "\n"
#~ "impl User {\n"
#~ "    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn name(&self) -> &str {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn age(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn height(&self) -> f32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn doctor_visits(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_age(&mut self, new_age: u32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_height(&mut self, new_height: f32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
#~ "HealthReport {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_height() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.height(), 155.2);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_set_age() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.age(), 32);\n"
#~ "    bob.set_age(33);\n"
#~ "    assert_eq!(bob.age(), 33);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_visit() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.doctor_visits(), 0);\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (120, 80),\n"
#~ "    });\n"
#~ "    assert_eq!(report.patient_name, \"Bob\");\n"
#~ "    assert_eq!(report.visit_count, 1);\n"
#~ "    assert_eq!(report.blood_pressure_change, None);\n"
#~ "\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (115, 76),\n"
#~ "    });\n"
#~ "\n"
#~ "    assert_eq!(report.visit_count, 2);\n"
#~ "    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
#~ "}\n"
#~ "```"

#~ msgid "Polygon Struct"
#~ msgstr "Polygon 구조체"

#~ msgid ""
#~ "We will create a `Polygon` struct which contain some points. Copy the "
#~ "code below to <https://play.rust-lang.org/> and fill in the missing "
#~ "methods to make the tests pass:"
#~ msgstr ""
#~ "우리는 몇개의 꼭지점을 가진 다각형을 표현하는 `Polygon` 구조체를 만들 것입"
#~ "니다. 아래 코드를 <https://play.rust-lang.org/>에 복사해서 테스트가 통과하"
#~ "도록 빠진 메서드를 구현하시면 됩니다:"

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct Point {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Point {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Polygon {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Polygon {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Circle {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Circle {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Shape {\n"
#~ "    Polygon(Polygon),\n"
#~ "    Circle(Circle),\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    fn round_two_digits(x: f64) -> f64 {\n"
#~ "        (x * 100.0).round() / 100.0\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_magnitude() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_dist() {\n"
#~ "        let p1 = Point::new(10, 10);\n"
#~ "        let p2 = Point::new(14, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_add() {\n"
#~ "        let p1 = Point::new(16, 16);\n"
#~ "        let p2 = p1 + Point::new(-4, 3);\n"
#~ "        assert_eq!(p2, Point::new(12, 19));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_left_most_point() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "        assert_eq!(poly.left_most_point(), Some(p1));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_iter() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "\n"
#~ "        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
#~ "        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, "
#~ "16)]);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_shape_perimeters() {\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(Point::new(12, 13));\n"
#~ "        poly.add_point(Point::new(17, 11));\n"
#~ "        poly.add_point(Point::new(16, 16));\n"
#~ "        let shapes = vec![\n"
#~ "            Shape::from(poly),\n"
#~ "            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimeters = shapes\n"
#~ "            .iter()\n"
#~ "            .map(Shape::perimeter)\n"
#~ "            .map(round_two_digits)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct Point {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Point {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Polygon {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Polygon {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Circle {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Circle {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Shape {\n"
#~ "    Polygon(Polygon),\n"
#~ "    Circle(Circle),\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    fn round_two_digits(x: f64) -> f64 {\n"
#~ "        (x * 100.0).round() / 100.0\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_magnitude() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_dist() {\n"
#~ "        let p1 = Point::new(10, 10);\n"
#~ "        let p2 = Point::new(14, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_add() {\n"
#~ "        let p1 = Point::new(16, 16);\n"
#~ "        let p2 = p1 + Point::new(-4, 3);\n"
#~ "        assert_eq!(p2, Point::new(12, 19));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_left_most_point() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "        assert_eq!(poly.left_most_point(), Some(p1));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_iter() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "\n"
#~ "        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
#~ "        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, "
#~ "16)]);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_shape_perimeters() {\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(Point::new(12, 13));\n"
#~ "        poly.add_point(Point::new(17, 11));\n"
#~ "        poly.add_point(Point::new(16, 16));\n"
#~ "        let shapes = vec![\n"
#~ "            Shape::from(poly),\n"
#~ "            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimeters = shapes\n"
#~ "            .iter()\n"
#~ "            .map(Shape::perimeter)\n"
#~ "            .map(round_two_digits)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "Since the method signatures are missing from the problem statements, the "
#~ "key part of the exercise is to specify those correctly. You don't have to "
#~ "modify the tests."
#~ msgstr ""
#~ "누락된 메서드 시그니처를 올바르게 정의하는 것이 문제의 핵심 부분입니다. 테"
#~ "스트는 수정하면 안됩니다."

#~ msgid "Other interesting parts of the exercise:"
#~ msgstr "연습문제의 다른 흥미로운 부분:"

#~ msgid ""
#~ "Derive a `Copy` trait for some structs, as in tests the methods sometimes "
#~ "don't borrow their arguments."
#~ msgstr ""
#~ "테스트 코드를 보면 어떤 메서드들은 인자를 borrow하는 대신 `Copy` 트레잇을 "
#~ "사용하기도 합니다. 구조체가 `Copy` 트레잇을 상속(derive)하도록 하면 됩니"
#~ "다."

#~ msgid ""
#~ "Discover that `Add` trait must be implemented for two objects to be "
#~ "addable via \"+\". Note that we do not discuss generics until Day 3."
#~ msgstr ""
#~ "\"+\"를 사용하여 두 객체를 서로 더하려면 `Add` 트레잇을 구현해야 합니다. "
#~ "이는 3일차에 다룰 내용입니다."

#~ msgid ""
#~ "As we have seen, `if` is an expression in Rust. It is used to "
#~ "conditionally evaluate one of two blocks, but the blocks can have a value "
#~ "which then becomes the value of the `if` expression. Other control flow "
#~ "expressions work similarly in Rust."
#~ msgstr ""
#~ "앞에서 살펴본 바와 같이 러스트에서 `if`는 표현식입니다. 조건에 따라 두 블"
#~ "록 중 하나를 평가하며, 그 결과값이 `if` 표현식의 값이 됩니다. 다른 흐름제"
#~ "어 표현식도 유사하게 작동합니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = {\n"
#~ "        let y = 10;\n"
#~ "        println!(\"y: {y}\");\n"
#~ "        let z = {\n"
#~ "            let w = {\n"
#~ "                3 + 4\n"
#~ "            };\n"
#~ "            println!(\"w: {w}\");\n"
#~ "            y * w\n"
#~ "        };\n"
#~ "        println!(\"z: {z}\");\n"
#~ "        z - y\n"
#~ "    };\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = {\n"
#~ "        let y = 10;\n"
#~ "        println!(\"y: {y}\");\n"
#~ "        let z = {\n"
#~ "            let w = {\n"
#~ "                3 + 4\n"
#~ "            };\n"
#~ "            println!(\"w: {w}\");\n"
#~ "            y * w\n"
#~ "        };\n"
#~ "        println!(\"z: {z}\");\n"
#~ "        z - y\n"
#~ "    };\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The same rule is used for functions: the value of the function body is "
#~ "the return value:"
#~ msgstr ""
#~ "함수에도 동일한 규칙이 적용됩니다. 함수 바디를 이루는 블록의 값이 반환값"
#~ "이 됩니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn double(x: i32) -> i32 {\n"
#~ "    x + x\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"doubled: {}\", double(7));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn double(x: i32) -> i32 {\n"
#~ "    x + x\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"doubled: {}\", double(7));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The point of this slide is to show that blocks have a type and value in "
#~ "Rust. "
#~ msgstr ""
#~ "러스트에서는 블록이 타입과 값을 가진다는 점이 이 슬라이드의 핵심입니다. "

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    if x % 2 == 0 {\n"
#~ "        x = x / 2;\n"
#~ "    } else {\n"
#~ "        x = 3 * x + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    if x % 2 == 0 {\n"
#~ "        x = x / 2;\n"
#~ "    } else {\n"
#~ "        x = 3 * x + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    x = if x % 2 == 0 {\n"
#~ "        x / 2\n"
#~ "    } else {\n"
#~ "        3 * x + 1\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    x = if x % 2 == 0 {\n"
#~ "        x / 2\n"
#~ "    } else {\n"
#~ "        3 * x + 1\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let arg = std::env::args().next();\n"
#~ "    if let Some(value) = arg {\n"
#~ "        println!(\"Program name: {value}\");\n"
#~ "    } else {\n"
#~ "        println!(\"Missing name?\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let arg = std::env::args().next();\n"
#~ "    if let Some(value) = arg {\n"
#~ "        println!(\"Program name: {value}\");\n"
#~ "    } else {\n"
#~ "        println!(\"Missing name?\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "See [pattern matching](../pattern-matching.md) for more details on "
#~ "patterns in Rust."
#~ msgstr ""
#~ "패턴에 관한 설명은 [패턴 매칭](../pattern-matching.md)을 참조하세요."

#~ msgid ""
#~ "Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-"
#~ "example/flow_control/let_else.html) construct allows to do a "
#~ "destructuring assignment, or if it fails, execute a block which is "
#~ "required to abort normal control flow (with `panic`/`return`/`break`/"
#~ "`continue`):"
#~ msgstr ""
#~ "1.65부터 유사한 [let-else](https://doc.rust-lang.org/rust-by-example/"
#~ "flow_control/let_else.html) 구성은 디스트럭처링 할당을 실행하거나 실패할 "
#~ "경우 반환되지 않는 블록 브랜치(panic/return/break/continue)를 보유하도록 "
#~ "허용합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
#~ "}\n"
#~ " \n"
#~ "fn second_word_to_upper(s: &str) -> Option<String> {\n"
#~ "    let mut it = s.split(' ');\n"
#~ "    let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
#~ "        return None;\n"
#~ "    };\n"
#~ "    Some(item.to_uppercase())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
#~ "}\n"
#~ " \n"
#~ "fn second_word_to_upper(s: &str) -> Option<String> {\n"
#~ "    let mut it = s.split(' ');\n"
#~ "    let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
#~ "        return None;\n"
#~ "    };\n"
#~ "    Some(item.to_uppercase())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    while x != 1 {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    while x != 1 {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "`for` loops"
#~ msgstr "`for` 반복문"

#~ msgid ""
#~ "The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is "
#~ "closely related to the [`while let` loop](while-let-expressions.md). It "
#~ "will automatically call `into_iter()` on the expression and then iterate "
#~ "over it:"
#~ msgstr ""
#~ "`for` 반복문은 `while let` 반복문과 매우 유사합니다. `for` 반복문은 자동으"
#~ "로 `into_iter()`를 호출한 다음 이를 반복합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "\n"
#~ "    for x in v {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "    \n"
#~ "    for i in (0..10).step_by(2) {\n"
#~ "        println!(\"i: {i}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "\n"
#~ "    for x in v {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "    \n"
#~ "    for i in (0..10).step_by(2) {\n"
#~ "        println!(\"i: {i}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "You can use `break` and `continue` here as usual."
#~ msgstr "다른 언어와 마찬가지로 `break` 와 `continue`를 사용할 수 있습니다."

#~ msgid "Index iteration is not a special syntax in Rust for just that case."
#~ msgstr "러스트는 인덱스 기반의 반복을 위한 별도의 문법을 사용하지 않습니다."

#~ msgid "`(0..10)` is a range that implements an `Iterator` trait. "
#~ msgstr "`(0..10)`은 `Iterator` 트레잇을 구현하는 범위(range) 값입니다. "

#~ msgid ""
#~ "`step_by` is a method that returns another `Iterator` that skips every "
#~ "other element. "
#~ msgstr ""
#~ "`step_by`는 반복자의 요소들을 건너뛰는 또다른 `Iterator`를 반환하는 메서드"
#~ "입니다. "

#~ msgid ""
#~ "Modify the elements in the vector and explain the compiler errors. Change "
#~ "vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
#~ msgstr ""
#~ "벡터 요소들을 수정하려고 하면 나오는 컴파일러 에러를 같이 살펴보세요. `v` "
#~ "벡터를 가변 변수로 변경하고 루프는 `for x in v.iter_mut()`로 수정하세요."

#~ msgid "`loop` expressions"
#~ msgstr "`loop` 표현식"

#~ msgid ""
#~ "Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
#~ "expressions/loop-expr.html#infinite-loops) which creates an endless loop."
#~ msgstr ""
#~ "마지막으로, 무한 루프를 만드는 [`loop` 키워드](https://doc.rust-lang.org/"
#~ "reference/expressions/loop-expr.html#infinite-loops)가 있습니다."

#~ msgid "Here you must either `break` or `return` to stop the loop:"
#~ msgstr ""
#~ "따라서 반드시 `break` 또는 `return`을 사용해서 루프를 정지해야 합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    loop {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "        if x == 1 {\n"
#~ "            break;\n"
#~ "        }\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    loop {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "        if x == 1 {\n"
#~ "            break;\n"
#~ "        }\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
#~ msgstr "`loop`를 값(예: `break 8`)으로 나누고 출력합니다."

#~ msgid ""
#~ "The [`match` keyword](https://doc.rust-lang.org/reference/expressions/"
#~ "match-expr.html) is used to match a value against one or more patterns. "
#~ "In that sense, it works like a series of `if let` expressions:"
#~ msgstr ""
#~ "`match`키워드는 어떤 값을 하나 이상의 패턴에 대해 매치하는데 사용합니다. "
#~ "그런 면에서 `if let` 표현식을 여러개 이어 놓은 것과 같습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    match std::env::args().next().as_deref() {\n"
#~ "        Some(\"cat\") => println!(\"Will do cat things\"),\n"
#~ "        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
#~ "        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
#~ "        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
#~ "        None        => println!(\"Hmm, no program name?\"),\n"
#~ "        _           => println!(\"Unknown program name!\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    match std::env::args().next().as_deref() {\n"
#~ "        Some(\"cat\") => println!(\"Will do cat things\"),\n"
#~ "        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
#~ "        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
#~ "        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
#~ "        None        => println!(\"Hmm, no program name?\"),\n"
#~ "        _           => println!(\"Unknown program name!\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Save the match expression to a variable and print it out."
#~ msgstr "`match` 표현식을 변수에 할당하고 그 값을 출력해보세요."

#~ msgid "Remove `.as_deref()` and explain the error."
#~ msgstr "`.as_deref()`를 지워보고, 이 때 나오는 에러를 설명해주세요."

#~ msgid ""
#~ "`std::env::args().next()` returns an `Option<String>`, but we cannot "
#~ "match against `String`."
#~ msgstr ""
#~ "`std::env::args().next()`는 `Option<String>` 값을 반환하는데, `String`은 "
#~ "직접 매치할 수 없습니다."

#~ msgid ""
#~ "`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our "
#~ "case, this turns `Option<String>` into `Option<&str>`."
#~ msgstr ""
#~ "`as_deref()`는 `Option<T>`를 `Option<&T::Target>`으로 바꿔줍니다. 이 경우"
#~ "는 `Option<String>`에서 `Option<&str>`로 바뀝니다."

#~ msgid ""
#~ "We can now use pattern matching to match against the `&str` inside "
#~ "`Option`."
#~ msgstr "이제는 패턴 매칭으로 `Option` 안의 `&str`을 매치할 수 있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "    'outer: while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "        let mut i = 0;\n"
#~ "        while i < x {\n"
#~ "            println!(\"x: {x}, i: {i}\");\n"
#~ "            i += 1;\n"
#~ "            if i == 3 {\n"
#~ "                break 'outer;\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "    'outer: while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "        let mut i = 0;\n"
#~ "        while i < x {\n"
#~ "            println!(\"x: {x}, i: {i}\");\n"
#~ "            i += 1;\n"
#~ "            if i == 3 {\n"
#~ "                break 'outer;\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "The common vocabulary types include:"
#~ msgstr "일반적인 타입은 아래와 같습니다:"

#~ msgid ""
#~ "[`Option` and `Result`](std/option-result.md) types: used for optional "
#~ "values and [error handling](error-handling.md)."
#~ msgstr ""
#~ "[`Option`과 `Result`](std/option-result.md) : 어떤 값이 있거나 없거나 하"
#~ "는 경우, 그리고 [오류 처리](error-handling.md)에 사용합니다."

#~ msgid ""
#~ "[`String`](std/string.md): the default string type used for owned data."
#~ msgstr ""
#~ "[`String`](std/string.md): 기본적인 문자열 타입으로, 문자열 데이터를 소유"
#~ "하는 경우에 사용합니다."

#~ msgid "[`Vec`](std/vec.md): a standard extensible vector."
#~ msgstr "[`Vec`](std/vec.md): 가변 크기의 표준 벡터 타입입니다."

#~ msgid ""
#~ "[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
#~ "algorithm."
#~ msgstr ""
#~ "[`HashMap`](std/hashmap.md): 해시 알고리즘을 따로 지정할 수도 있는 해시맵 "
#~ "타입입니다."

#~ msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
#~ msgstr "[`Box`](std/box.md): 힙 데이터에 대한 소유 포인터입니다."

#~ msgid ""
#~ "[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
#~ "data."
#~ msgstr ""
#~ "[`Rc`](std/rc.md): 힙에 할당된 데이터에 대한 참조 카운팅 공유 포인터입니"
#~ "다."

#~ msgid "`Option` and `Result`"
#~ msgstr "`Option`과 `Result`"

#~ msgid "The types represent optional data:"
#~ msgstr "이 타입은 선택적 데이터를 나타냅니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let numbers = vec![10, 20, 30];\n"
#~ "    let first: Option<&i8> = numbers.first();\n"
#~ "    println!(\"first: {first:?}\");\n"
#~ "\n"
#~ "    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
#~ "    println!(\"idx: {idx:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let numbers = vec![10, 20, 30];\n"
#~ "    let first: Option<&i8> = numbers.first();\n"
#~ "    println!(\"first: {first:?}\");\n"
#~ "\n"
#~ "    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
#~ "    println!(\"idx: {idx:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "`Option<&T>` has zero space overhead compared to `&T`."
#~ msgstr "`Option<&T>` 는 `&T`에 비해 공간 오버헤드가 없습니다."

#~ msgid "`binary_search` returns `Result<usize, usize>`."
#~ msgstr "`binary_search`는 `Result<usize, usize>`를 반환합니다."

#~ msgid "If found, `Result::Ok` holds the index where the element is found."
#~ msgstr ""
#~ "요소가 발견된다면, `Result::Ok`는 발견된 요소의 인덱스를 보유합니다."

#~ msgid ""
#~ "Otherwise, `Result::Err` contains the index where such an element should "
#~ "be inserted."
#~ msgstr ""
#~ "아니면, `Result::Err`에는 요소가 삽입되야 하는 인덱스가 포함되어 있습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::new();\n"
#~ "    s1.push_str(\"Hello\");\n"
#~ "    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
#~ "\n"
#~ "    let mut s2 = String::with_capacity(s1.len() + 1);\n"
#~ "    s2.push_str(&s1);\n"
#~ "    s2.push('!');\n"
#~ "    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
#~ "\n"
#~ "    let s3 = String::from(\"🇨🇭\");\n"
#~ "    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
#~ "             s3.chars().count());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::new();\n"
#~ "    s1.push_str(\"Hello\");\n"
#~ "    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
#~ "\n"
#~ "    let mut s2 = String::with_capacity(s1.len() + 1);\n"
#~ "    s2.push_str(&s1);\n"
#~ "    s2.push('!');\n"
#~ "    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
#~ "\n"
#~ "    let s3 = String::from(\"🇨🇭\");\n"
#~ "    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
#~ "             s3.chars().count());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v1 = Vec::new();\n"
#~ "    v1.push(42);\n"
#~ "    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
#~ "\n"
#~ "    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
#~ "    v2.extend(v1.iter());\n"
#~ "    v2.push(9999);\n"
#~ "    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
#~ "\n"
#~ "    // Canonical macro to initialize a vector with elements.\n"
#~ "    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
#~ "\n"
#~ "    // Retain only the even elements.\n"
#~ "    v3.retain(|x| x % 2 == 0);\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "\n"
#~ "    // Remove consecutive duplicates.\n"
#~ "    v3.dedup();\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v1 = Vec::new();\n"
#~ "    v1.push(42);\n"
#~ "    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
#~ "\n"
#~ "    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
#~ "    v2.extend(v1.iter());\n"
#~ "    v2.push(9999);\n"
#~ "    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
#~ "\n"
#~ "    // 요소로 벡터를 초기화하는 표준 매크로입니다.\n"
#~ "    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
#~ "\n"
#~ "    // 짝수 요소만 유지합니다.\n"
#~ "    v3.retain(|x| x % 2 == 0);\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "\n"
#~ "    // 연속 중복을 삭제합니다.\n"
#~ "    v3.dedup();\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Show iterating over a vector and mutating the value: `for e in &mut v "
#~ "{ *e += 50; }`"
#~ msgstr ""
#~ "벡터를 순회하면서 값을 변경할 수도 있음을 보여주세요: `for e in &mut v "
#~ "{ *e += 50; }`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut page_counts = HashMap::new();\n"
#~ "    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
#~ "207);\n"
#~ "    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
#~ "    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
#~ "\n"
#~ "    if !page_counts.contains_key(\"Les Misérables\") {\n"
#~ "        println!(\"We know about {} books, but not Les Misérables.\",\n"
#~ "                 page_counts.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        match page_counts.get(book) {\n"
#~ "            Some(count) => println!(\"{book}: {count} pages\"),\n"
#~ "            None => println!(\"{book} is unknown.\")\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // Use the .entry() method to insert a value if nothing is found.\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        let page_count: &mut i32 = page_counts.entry(book.to_string())."
#~ "or_insert(0);\n"
#~ "        *page_count += 1;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"{page_counts:#?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut page_counts = HashMap::new();\n"
#~ "    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
#~ "207);\n"
#~ "    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
#~ "    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
#~ "\n"
#~ "    if !page_counts.contains_key(\"Les Misérables\") {\n"
#~ "        println!(\"We know about {} books, but not Les Misérables.\",\n"
#~ "                 page_counts.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        match page_counts.get(book) {\n"
#~ "            Some(count) => println!(\"{book}: {count} pages\"),\n"
#~ "            None => println!(\"{book} is unknown.\")\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // 아무것도 찾을 수 없는 경우 .entry() 메서드를 사용하여 값을 삽입합니"
#~ "다.\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        let page_count: &mut i32 = page_counts.entry(book.to_string())."
#~ "or_insert(0);\n"
#~ "        *page_count += 1;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"{page_counts:#?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "  let pc1 = page_counts\n"
#~ "      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
#~ "      .unwrap_or(&336);\n"
#~ "  let pc2 = page_counts\n"
#~ "      .entry(\"The Hunger Games\".to_string())\n"
#~ "      .or_insert(374);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "  let pc1 = page_counts\n"
#~ "      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
#~ "      .unwrap_or(&336);\n"
#~ "  let pc2 = page_counts\n"
#~ "      .entry(\"The Hunger Games\".to_string())\n"
#~ "      .or_insert(374);\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "  let page_counts = HashMap::from([\n"
#~ "    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
#~ "    (\"The Hunger Games\".to_string(), 374),\n"
#~ "  ]);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "  let page_counts = HashMap::from([\n"
#~ "    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
#~ "    (\"The Hunger Games\".to_string(), 374),\n"
#~ "  ]);\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let five = Box::new(5);\n"
#~ "    println!(\"five: {}\", *five);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let five = Box::new(5);\n"
#~ "    println!(\"five: {}\", *five);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                     Heap\n"
#~ ".- - - - - - -.     .- - - - - - -.\n"
#~ ":             :     :             :\n"
#~ ":    five     :     :             :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":   | o---|---+-----+-->|  5  |   :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":             :     :             :\n"
#~ ":             :     :             :\n"
#~ "`- - - - - - -'     `- - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ "  스택                힙\n"
#~ ".- - - - - - -.     .- - - - - - -.\n"
#~ ":             :     :             :\n"
#~ ":    five     :     :             :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":   | o---|---+-----+-->|  5  |   :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":             :     :             :\n"
#~ ":             :     :             :\n"
#~ "`- - - - - - -'     `- - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "In the above example, you can even leave out the `*` in the `println!` "
#~ "statement thanks to `Deref`. "
#~ msgstr ""
#~ "`Deref` 덕분에 위 예제의 `println!`문에 사용된 `*`를 빼도 문제가 없습니"
#~ "다. "

#~ msgid "Box with Recursive Data Structures"
#~ msgstr "재귀자료 구조에서의 `Box`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "enum List<T> {\n"
#~ "    Cons(T, Box<List<T>>),\n"
#~ "    Nil,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
#~ "new(List::Nil))));\n"
#~ "    println!(\"{list:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "enum List<T> {\n"
#~ "    Cons(T, Box<List<T>>),\n"
#~ "    Nil,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
#~ "new(List::Nil))));\n"
#~ "    println!(\"{list:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = Rc::new(10);\n"
#~ "    let mut b = Rc::clone(&a);\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = Rc::new(10);\n"
#~ "    let mut b = Rc::clone(&a);\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::cell::RefCell;\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Node {\n"
#~ "    value: i64,\n"
#~ "    children: Vec<Rc<RefCell<Node>>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Node {\n"
#~ "    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
#~ "        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
#~ "    }\n"
#~ "\n"
#~ "    fn sum(&self) -> i64 {\n"
#~ "        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
#~ "<i64>()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let root = Node::new(1);\n"
#~ "    root.borrow_mut().children.push(Node::new(5));\n"
#~ "    let subtree = Node::new(10);\n"
#~ "    subtree.borrow_mut().children.push(Node::new(11));\n"
#~ "    subtree.borrow_mut().children.push(Node::new(12));\n"
#~ "    root.borrow_mut().children.push(subtree);\n"
#~ "\n"
#~ "    println!(\"graph: {root:#?}\");\n"
#~ "    println!(\"graph sum: {}\", root.borrow().sum());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::cell::RefCell;\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Node {\n"
#~ "    value: i64,\n"
#~ "    children: Vec<Rc<RefCell<Node>>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Node {\n"
#~ "    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
#~ "        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
#~ "    }\n"
#~ "\n"
#~ "    fn sum(&self) -> i64 {\n"
#~ "        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
#~ "<i64>()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let root = Node::new(1);\n"
#~ "    root.borrow_mut().children.push(Node::new(5));\n"
#~ "    let subtree = Node::new(10);\n"
#~ "    subtree.borrow_mut().children.push(Node::new(11));\n"
#~ "    subtree.borrow_mut().children.push(Node::new(12));\n"
#~ "    root.borrow_mut().children.push(subtree);\n"
#~ "\n"
#~ "    println!(\"graph: {root:#?}\");\n"
#~ "    println!(\"graph sum: {}\", root.borrow().sum());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "mod foo {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the foo module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "mod bar {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the bar module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo::do_something();\n"
#~ "    bar::do_something();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "mod foo {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the foo module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "mod bar {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the bar module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo::do_something();\n"
#~ "    bar::do_something();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "mod outer {\n"
#~ "    fn private() {\n"
#~ "        println!(\"outer::private\");\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn public() {\n"
#~ "        println!(\"outer::public\");\n"
#~ "    }\n"
#~ "\n"
#~ "    mod inner {\n"
#~ "        fn private() {\n"
#~ "            println!(\"outer::inner::private\");\n"
#~ "        }\n"
#~ "\n"
#~ "        pub fn public() {\n"
#~ "            println!(\"outer::inner::public\");\n"
#~ "            super::private();\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    outer::public();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "mod outer {\n"
#~ "    fn private() {\n"
#~ "        println!(\"outer::private\");\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn public() {\n"
#~ "        println!(\"outer::public\");\n"
#~ "    }\n"
#~ "\n"
#~ "    mod inner {\n"
#~ "        fn private() {\n"
#~ "            println!(\"outer::inner::private\");\n"
#~ "        }\n"
#~ "\n"
#~ "        pub fn public() {\n"
#~ "            println!(\"outer::inner::public\");\n"
#~ "            super::private();\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    outer::public();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::collections::HashSet;\n"
#~ "use std::mem::transmute;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::collections::HashSet;\n"
#~ "use std::mem::transmute;\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "mod garden;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "mod garden;\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "//! This module implements the garden, including a highly performant "
#~ "germination\n"
#~ "//! implementation.\n"
#~ "\n"
#~ "// Re-export types from this module.\n"
#~ "pub use seeds::SeedPacket;\n"
#~ "pub use garden::Garden;\n"
#~ "\n"
#~ "/// Sow the given seed packets.\n"
#~ "pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
#~ "\n"
#~ "/// Harvest the produce in the garden that is ready.\n"
#~ "pub fn harvest(garden: &mut Garden) { todo!() }\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "//! 이 모듈은 높은 성능의 발아 구현을 비롯하여 정원을\n"
#~ "//! 구현합니다.\n"
#~ "\n"
#~ "// 이 모듈에 정의된 타입을 밖으로 공개합니다.\n"
#~ "pub use seeds::SeedPacket;\n"
#~ "pub use garden::Garden;\n"
#~ "\n"
#~ "/// 지정된 씨앗 패킷을 뿌립니다.\n"
#~ "pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
#~ "\n"
#~ "/// 정원에서 준비된 농산물을 수확합니다.\n"
#~ "pub fn harvest(garden: &mut Garden) { todo!() }\n"
#~ "```"

#~ msgid ""
#~ "```ignore\n"
#~ "src/\n"
#~ "├── main.rs\n"
#~ "├── top_module.rs\n"
#~ "└── top_module/\n"
#~ "    └── sub_module.rs\n"
#~ "```"
#~ msgstr ""
#~ "```ignore\n"
#~ "src/\n"
#~ "├── main.rs\n"
#~ "├── top_module.rs\n"
#~ "└── top_module/\n"
#~ "    └── sub_module.rs\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[path = \"some/path.rs\"]\n"
#~ "mod some_module;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[path = \"some/path.rs\"]\n"
#~ "mod some_module;\n"
#~ "```"

#~ msgid "Day 2: Afternoon Exercises"
#~ msgstr "2일차 오후 연습문제"

#~ msgid ""
#~ "The exercises for this afternoon will focus on strings and iterators."
#~ msgstr "이번 연습문제는 문자열과 반복자에 초점을 맞출 것입니다."

#~ msgid ""
#~ "Copy the code below to <https://play.rust-lang.org/> and implement the "
#~ "function."
#~ msgstr ""
#~ "아래 코드를 <https://play.rust-lang.org/>에 복사해서 구현하시면 됩니다."

#~ msgid ""
#~ "Try to solve the problem the \"simple\" way first, using `for` loops and "
#~ "integers. Then, revisit the solution and try to implement it with "
#~ "iterators."
#~ msgstr ""
#~ "`for`반복문과 인덱스를 이용하는 \"쉬운\"방법으로 먼저 풀어 보세요. 그런 다"
#~ "음 반복자를 이용해서 다시 풀어 보세요."

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn luhn(cc_number: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_non_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty_cc_number() {\n"
#~ "    assert!(!luhn(\"\"));\n"
#~ "    assert!(!luhn(\" \"));\n"
#~ "    assert!(!luhn(\"  \"));\n"
#~ "    assert!(!luhn(\"    \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"0\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_two_digit_cc_number() {\n"
#~ "    assert!(luhn(\" 0 0 \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_valid_cc_number() {\n"
#~ "    assert!(luhn(\"4263 9826 4026 9299\"));\n"
#~ "    assert!(luhn(\"4539 3195 0343 6467\"));\n"
#~ "    assert!(luhn(\"7992 7398 713\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_invalid_cc_number() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn luhn(cc_number: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_non_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty_cc_number() {\n"
#~ "    assert!(!luhn(\"\"));\n"
#~ "    assert!(!luhn(\" \"));\n"
#~ "    assert!(!luhn(\"  \"));\n"
#~ "    assert!(!luhn(\"    \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"0\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_two_digit_cc_number() {\n"
#~ "    assert!(luhn(\" 0 0 \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_valid_cc_number() {\n"
#~ "    assert!(luhn(\"4263 9826 4026 9299\"));\n"
#~ "    assert!(luhn(\"4539 3195 0343 6467\"));\n"
#~ "    assert!(luhn(\"7992 7398 713\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_invalid_cc_number() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "In this exercise, you are implementing a routing component of a web "
#~ "server. The server is configured with a number of _path prefixes_ which "
#~ "are matched against _request paths_. The path prefixes can contain a "
#~ "wildcard character which matches a full segment. See the unit tests below."
#~ msgstr ""
#~ "이번 훈련은 웹 서버의 라우팅 컴포넌트를 구현합니다. 서버는 _요청 경로"
#~ "(request path)_ 를 처리할 수 있는 여러 개의 _경로 접두사(path prefix)_ 로 "
#~ "구성됩니다. 경로 접두사는 와일드카드문자를 포함할 수 있습니다.  아래 단위 "
#~ "테스트 코드를 참조하세요."

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
#~ "abc-123\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
#~ "books\"));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/"
#~ "publishersBooks\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
#~ "publishers\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_with_wildcard() {\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/bar/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books/book1\"\n"
#~ "    ));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
#~ "publishers\"));\n"
#~ "    assert!(!prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
#~ "abc-123\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
#~ "books\"));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/"
#~ "publishersBooks\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
#~ "publishers\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_with_wildcard() {\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/bar/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books/book1\"\n"
#~ "    ));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
#~ "publishers\"));\n"
#~ "    assert!(!prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Traits: deriving traits, default methods, and important standard library "
#~ "traits."
#~ msgstr ""
#~ "트레잇: 트레잇 상속(derive), 디폴트 메서드, 표준 라이브러에 있는 중요한 트"
#~ "레잇들."

#~ msgid ""
#~ "Generics: generic data types, generic methods, monomorphization, and "
#~ "trait objects."
#~ msgstr ""
#~ "제네릭: 제네릭 데이터 타입, 제네릭 메서드, 단형화(monomorphization), 트레"
#~ "잇 객체."

#~ msgid "Testing: unit tests, documentation tests, and integration tests."
#~ msgstr "테스트: 단위 테스트, 문서 테스트 및 통합 테스트."

#~ msgid ""
#~ "Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
#~ "functions."
#~ msgstr ""
#~ "안전하지 않은 러스트: 원시(raw) 포인터, 정적 변수, 안전하지 않은 함수, 외"
#~ "부 함수."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T> {\n"
#~ "    x: T,\n"
#~ "    y: T,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Point { x: 5, y: 10 };\n"
#~ "    let float = Point { x: 1.0, y: 4.0 };\n"
#~ "    println!(\"{integer:?} and {float:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T> {\n"
#~ "    x: T,\n"
#~ "    y: T,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Point { x: 5, y: 10 };\n"
#~ "    let float = Point { x: 1.0, y: 4.0 };\n"
#~ "    println!(\"{integer:?} and {float:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
#~ msgstr "새 변수 `let p = Point { x: 5, y: 10.0 };`를 선언해 보세요."

#~ msgid "Fix the code to allow points that have elements of different types."
#~ msgstr ""
#~ "`Point`가 서로 다른 타입의 값들으로 이루어져도 컴파일 되도록 코드를 수정"
#~ "해 보세요."

#~ msgid "You can declare a generic type on your `impl` block:"
#~ msgstr "`impl` 블록에서도 제네릭 타입을 선언할 수 있습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T>(T, T);\n"
#~ "\n"
#~ "impl<T> Point<T> {\n"
#~ "    fn x(&self) -> &T {\n"
#~ "        &self.0  // + 10\n"
#~ "    }\n"
#~ "\n"
#~ "    // fn set_x(&mut self, x: T)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(5, 10);\n"
#~ "    println!(\"p.x = {}\", p.x());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T>(T, T);\n"
#~ "\n"
#~ "impl<T> Point<T> {\n"
#~ "    fn x(&self) -> &T {\n"
#~ "        &self.0  // + 10\n"
#~ "    }\n"
#~ "\n"
#~ "    // fn set_x(&mut self, x: T)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(5, 10);\n"
#~ "    println!(\"p.x = {}\", p.x());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Generic code is turned into non-generic code based on the call sites:"
#~ msgstr "제네릭 코드는 호출부에서 비 제네릭 코드로 전환됩니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let integer = Some(5);\n"
#~ "    let float = Some(5.0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let integer = Some(5);\n"
#~ "    let float = Some(5.0);\n"
#~ "}\n"
#~ "```"

#~ msgid "behaves as if you wrote"
#~ msgstr "위 코드는 아래와 같이 동작합니다"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum Option_i32 {\n"
#~ "    Some(i32),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "enum Option_f64 {\n"
#~ "    Some(f64),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Option_i32::Some(5);\n"
#~ "    let float = Option_f64::Some(5.0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum Option_i32 {\n"
#~ "    Some(i32),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "enum Option_f64 {\n"
#~ "    Some(f64),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Option_i32::Some(5);\n"
#~ "    let float = Option_f64::Some(5.0);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn greet<P: Pet>(pet: &P) {\n"
#~ "    println!(\"Who's a cutie? {} is!\", pet.name());\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fido = Dog { name: \"Fido\".into() };\n"
#~ "    greet(&fido);\n"
#~ "\n"
#~ "    let captain_floof = Cat;\n"
#~ "    greet(&captain_floof);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn greet<P: Pet>(pet: &P) {\n"
#~ "    println!(\"Who's a cutie? {} is!\", pet.name());\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fido = Dog { name: \"Fido\".into() };\n"
#~ "    greet(&fido);\n"
#~ "\n"
#~ "    let captain_floof = Cat;\n"
#~ "    greet(&captain_floof);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let pets: Vec<Box<dyn Pet>> = vec![\n"
#~ "        Box::new(Cat),\n"
#~ "        Box::new(Dog { name: String::from(\"Fido\") }),\n"
#~ "    ];\n"
#~ "    for pet in pets {\n"
#~ "        println!(\"Hello {}!\", pet.name());\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let pets: Vec<Box<dyn Pet>> = vec![\n"
#~ "        Box::new(Cat),\n"
#~ "        Box::new(Dog { name: String::from(\"Fido\") }),\n"
#~ "    ];\n"
#~ "    for pet in pets {\n"
#~ "        println!(\"Hello {}!\", pet.name());\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
#~ "<Cat>());\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
#~ "<&Cat>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
#~ "<Cat>());\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
#~ "<&Cat>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
#~ "```"

#~ msgid ""
#~ "Rust derive macros work by automatically generating code that implements "
#~ "the specified traits for a data structure."
#~ msgstr ""
#~ "러스트의 derive 매크로는 데이터 구조체가 특정 트레잇을 구현하는 코드를 자"
#~ "동으로 만들어 줍니다."

#~ msgid "You can let the compiler derive a number of traits as follows:"
#~ msgstr ""
#~ "컴파일러가 여러가지 트레잇을 상속(derive)하도록 할 수 있습니다. 이 경우 컴"
#~ "파일러가 트레잇을 자동으로 구현합니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
#~ "struct Player {\n"
#~ "    name: String,\n"
#~ "    strength: u8,\n"
#~ "    hit_points: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Player::default();\n"
#~ "    let p2 = p1.clone();\n"
#~ "    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
#~ "             if p1 == p2 { \"yes\" } else { \"no\" });\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
#~ "struct Player {\n"
#~ "    name: String,\n"
#~ "    strength: u8,\n"
#~ "    hit_points: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Player::default();\n"
#~ "    let p2 = p1.clone();\n"
#~ "    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
#~ "             if p1 == p2 { \"yes\" } else { \"no\" });\n"
#~ "}\n"
#~ "```"

#~ msgid "Traits can implement behavior in terms of other trait methods:"
#~ msgstr ""
#~ "트레잇의 디폴트 메서드에서 다른(구현되지 않은) 메소드를 이용할 수 있습니"
#~ "다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Equals {\n"
#~ "    fn equals(&self, other: &Self) -> bool;\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Centimeter(i16);\n"
#~ "\n"
#~ "impl Equals for Centimeter {\n"
#~ "    fn equals(&self, other: &Centimeter) -> bool {\n"
#~ "        self.0 == other.0\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Centimeter(10);\n"
#~ "    let b = Centimeter(20);\n"
#~ "    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
#~ "    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Equals {\n"
#~ "    fn equals(&self, other: &Self) -> bool;\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Centimeter(i16);\n"
#~ "\n"
#~ "impl Equals for Centimeter {\n"
#~ "    fn equals(&self, other: &Centimeter) -> bool {\n"
#~ "        self.0 == other.0\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Centimeter(10);\n"
#~ "    let b = Centimeter(20);\n"
#~ "    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
#~ "    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
#~ "}\n"
#~ "```"

#~ msgid "Move method `not_equals` to a new trait `NotEquals`."
#~ msgstr "`not_equal` 메서드를 새로운 트레잇인 `NotEqual`로 이동합니다."

#~ msgid "Make `Equals` a super trait for `NotEquals`."
#~ msgstr "`NotEqual`을 `Equal`의 슈퍼 트레잇으로 만듭니다."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
#~ msgstr "`Equal`에 `NotEqual`의 포괄적 구현을 제공합니다."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl<T> NotEquals for T where T: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl<T> NotEquals for T where T: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "With the blanket implementation, you no longer need `Equals` as a super "
#~ "trait for `NotEqual`."
#~ msgstr ""
#~ "포괄적 구현을 사용하면 더 이상 `NotEqual`이 `Equal`의 슈퍼 트레잇으로 필요"
#~ "하지 않습니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "\n"
#~ "// Syntactic sugar for:\n"
#~ "//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
#~ "fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
#~ "    x.into() + 42_000_000\n"
#~ "}\n"
#~ "\n"
#~ "// struct NotClonable;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let foo = String::from(\"foo\");\n"
#~ "    let pair = duplicate(foo);\n"
#~ "    println!(\"{pair:?}\");\n"
#~ "\n"
#~ "    let many = add_42_millions(42_i8);\n"
#~ "    println!(\"{many}\");\n"
#~ "    let many_more = add_42_millions(10_000_000);\n"
#~ "    println!(\"{many_more}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "\n"
#~ "// 다음에 대한 문법 슈가:\n"
#~ "//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
#~ "fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
#~ "    x.into() + 42_000_000\n"
#~ "}\n"
#~ "\n"
#~ "// struct NotClonable;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let foo = String::from(\"foo\");\n"
#~ "    let pair = duplicate(foo);\n"
#~ "    println!(\"{pair:?}\");\n"
#~ "\n"
#~ "    let many = add_42_millions(42_i8);\n"
#~ "    println!(\"{many}\");\n"
#~ "    let many_more = add_42_millions(10_000_000);\n"
#~ "    println!(\"{many_more}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn duplicate<T>(a: T) -> (T, T)\n"
#~ "where\n"
#~ "    T: Clone,\n"
#~ "{\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn duplicate<T>(a: T) -> (T, T)\n"
#~ "where\n"
#~ "    T: Clone,\n"
#~ "{\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::fmt::Display;\n"
#~ "\n"
#~ "fn get_x(name: impl Display) -> impl Display {\n"
#~ "    format!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = get_x(\"foo\");\n"
#~ "    println!(\"{x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::fmt::Display;\n"
#~ "\n"
#~ "fn get_x(name: impl Display) -> impl Display {\n"
#~ "    format!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = get_x(\"foo\");\n"
#~ "    println!(\"{x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "`impl Trait` allows you to work with types which you cannot name."
#~ msgstr "`impl Trait`를 이용하면 이름이 없는 타입을 다룰 수 있습니다."

#~ msgid ""
#~ "This example is great, because it uses `impl Display` twice. It helps to "
#~ "explain that nothing here enforces that it is _the same_ `impl Display` "
#~ "type. If we used a single  `T: Display`, it would enforce the constraint "
#~ "that input `T` and return `T` type are the same type. It would not work "
#~ "for this particular function, as the type we expect as input is likely "
#~ "not what `format!` returns. If we wanted to do the same via `: Display` "
#~ "syntax, we'd need two independent generic parameters."
#~ msgstr ""
#~ "이 예시는 `impl Display`가 두번 사용 되었다는 점에서 훌륭합니다. 여기서 중"
#~ "요한 것은 이 두 `impl Display`가 실제로 같은 타입일 필요가 없다는 것입니"
#~ "다. 만약 `T: Display`로 트레잇 경계를 정하고 입력 파라메터와 리턴 값의 타"
#~ "입을 모두 `T`로 했다면, 이는 입력과 리턴값이 같은 타입임을 강제합니다. 이"
#~ "렇게 했다면 위의 예제는 동작하지 않았을 것입니다. 왜냐하면, 입력 값의 타입"
#~ "이 `format!`이 리턴하는 타입과 같지 않을 가능성이 높기 때문입니다. 만약 "
#~ "`: Display` 문법을 사용하고 싶다면 독립적인 제네릭 매개변수가 두 개가 필요"
#~ "합니다."

#~ msgid ""
#~ "We will now look at some of the most common traits of the Rust standard "
#~ "library:"
#~ msgstr ""
#~ "러스트 표준 라이브러리에는 다음과 같은 범용 트레잇들이 정의되어 있습니다:"

#~ msgid ""
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) used in `for` loops,"
#~ msgstr ""
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html)와 "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) 트레잇은 `for` 반복문에서 사용됩니다,"

#~ msgid ""
#~ "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and "
#~ "[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) used to "
#~ "convert values,"
#~ msgstr ""
#~ "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html)과 [`Into`]"
#~ "(https://doc.rust-lang.org/std/convert/trait.Into.html) 트레잇은 값을 변환"
#~ "할 때 사용됩니다,"

#~ msgid ""
#~ "[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
#~ "(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
#~ msgstr ""
#~ "[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html)와 [`Write`]"
#~ "(https://doc.rust-lang.org/std/io/trait.Write.html) 트레잇은 I/O에 사용됩"
#~ "니다,"

#~ msgid ""
#~ "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`]"
#~ "(https://doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
#~ "overloading, and"
#~ msgstr ""
#~ "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`]"
#~ "(https://doc.rust-lang.org/std/ops/trait.Mul.html) 등의 트레잇들은 연산자 "
#~ "오버로딩(overloading)에 사용됩니다."

#~ msgid ""
#~ "[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
#~ "used to construct a default instance of a type."
#~ msgstr ""
#~ "[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) 트레"
#~ "잇은 어떤 타입의 기본값 인스턴스를 만들때 사용됩니다."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Fibonacci {\n"
#~ "    curr: u32,\n"
#~ "    next: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for Fibonacci {\n"
#~ "    type Item = u32;\n"
#~ "\n"
#~ "    fn next(&mut self) -> Option<Self::Item> {\n"
#~ "        let new_next = self.curr + self.next;\n"
#~ "        self.curr = self.next;\n"
#~ "        self.next = new_next;\n"
#~ "        Some(self.curr)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fib = Fibonacci { curr: 0, next: 1 };\n"
#~ "    for (i, n) in fib.enumerate().take(5) {\n"
#~ "        println!(\"fib({i}): {n}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Fibonacci {\n"
#~ "    curr: u32,\n"
#~ "    next: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for Fibonacci {\n"
#~ "    type Item = u32;\n"
#~ "\n"
#~ "    fn next(&mut self) -> Option<Self::Item> {\n"
#~ "        let new_next = self.curr + self.next;\n"
#~ "        self.curr = self.next;\n"
#~ "        self.next = new_next;\n"
#~ "        Some(self.curr)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fib = Fibonacci { curr: 0, next: 1 };\n"
#~ "    for (i, n) in fib.enumerate().take(5) {\n"
#~ "        println!(\"fib({i}): {n}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let primes = vec![2, 3, 5, 7];\n"
#~ "    let prime_squares = primes\n"
#~ "        .into_iter()\n"
#~ "        .map(|prime| prime * prime)\n"
#~ "        .collect::<Vec<_>>();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let primes = vec![2, 3, 5, 7];\n"
#~ "    let prime_squares = primes\n"
#~ "        .into_iter()\n"
#~ "        .map(|prime| prime * prime)\n"
#~ "        .collect::<Vec<_>>();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "`Iterator` implements `fn collect<B>(self) -> B where B: "
#~ "FromIterator<Self::Item>, Self: Sized`"
#~ msgstr ""
#~ "`Iterator`에는 다음 함수가 정의되어 있습니다: `fn collect<B>(self) -> B "
#~ "where B: FromIterator<Self::Item>, Self: Sized`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"hello\");\n"
#~ "    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
#~ "    let one = i16::from(true);\n"
#~ "    let bigger = i32::from(123i16);\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"hello\");\n"
#~ "    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
#~ "    let one = i16::from(true);\n"
#~ "    let bigger = i32::from(123i16);\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s: String = \"hello\".into();\n"
#~ "    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
#~ "    let one: i16 = true.into();\n"
#~ "    let bigger: i32 = 123i16.into();\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s: String = \"hello\".into();\n"
#~ "    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
#~ "    let one: i16 = true.into();\n"
#~ "    let bigger: i32 = 123i16.into();\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::io::{BufRead, BufReader, Read, Result};\n"
#~ "\n"
#~ "fn count_lines<R: Read>(reader: R) -> usize {\n"
#~ "    let buf_reader = BufReader::new(reader);\n"
#~ "    buf_reader.lines().count()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
#~ "    println!(\"lines in slice: {}\", count_lines(slice));\n"
#~ "\n"
#~ "    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
#~ "    println!(\"lines in file: {}\", count_lines(file));\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::io::{BufRead, BufReader, Read, Result};\n"
#~ "\n"
#~ "fn count_lines<R: Read>(reader: R) -> usize {\n"
#~ "    let buf_reader = BufReader::new(reader);\n"
#~ "    buf_reader.lines().count()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
#~ "    println!(\"lines in slice: {}\", count_lines(slice));\n"
#~ "\n"
#~ "    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
#~ "    println!(\"lines in file: {}\", count_lines(file));\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::io::{Result, Write};\n"
#~ "\n"
#~ "fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
#~ "    writer.write_all(msg.as_bytes())?;\n"
#~ "    writer.write_all(\"\\n\".as_bytes())\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let mut buffer = Vec::new();\n"
#~ "    log(&mut buffer, \"Hello\")?;\n"
#~ "    log(&mut buffer, \"World\")?;\n"
#~ "    println!(\"Logged: {:?}\", buffer);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::io::{Result, Write};\n"
#~ "\n"
#~ "fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
#~ "    writer.write_all(msg.as_bytes())?;\n"
#~ "    writer.write_all(\"\\n\".as_bytes())\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let mut buffer = Vec::new();\n"
#~ "    log(&mut buffer, \"Hello\")?;\n"
#~ "    log(&mut buffer, \"World\")?;\n"
#~ "    println!(\"Logged: {:?}\", buffer);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Droppable {\n"
#~ "    name: &'static str,\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for Droppable {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        println!(\"Dropping {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Droppable { name: \"a\" };\n"
#~ "    {\n"
#~ "        let b = Droppable { name: \"b\" };\n"
#~ "        {\n"
#~ "            let c = Droppable { name: \"c\" };\n"
#~ "            let d = Droppable { name: \"d\" };\n"
#~ "            println!(\"Exiting block B\");\n"
#~ "        }\n"
#~ "        println!(\"Exiting block A\");\n"
#~ "    }\n"
#~ "    drop(a);\n"
#~ "    println!(\"Exiting main\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Droppable {\n"
#~ "    name: &'static str,\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for Droppable {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        println!(\"Dropping {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Droppable { name: \"a\" };\n"
#~ "    {\n"
#~ "        let b = Droppable { name: \"b\" };\n"
#~ "        {\n"
#~ "            let c = Droppable { name: \"c\" };\n"
#~ "            let d = Droppable { name: \"d\" };\n"
#~ "            println!(\"Exiting block B\");\n"
#~ "        }\n"
#~ "        println!(\"Exiting block A\");\n"
#~ "    }\n"
#~ "    drop(a);\n"
#~ "    println!(\"Exiting main\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Derived {\n"
#~ "    x: u32,\n"
#~ "    y: String,\n"
#~ "    z: Implemented,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Implemented(String);\n"
#~ "\n"
#~ "impl Default for Implemented {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self(\"John Smith\".into())\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let default_struct = Derived::default();\n"
#~ "    println!(\"{default_struct:#?}\");\n"
#~ "\n"
#~ "    let almost_default_struct = Derived {\n"
#~ "        y: \"Y is set!\".into(),\n"
#~ "        ..Derived::default()\n"
#~ "    };\n"
#~ "    println!(\"{almost_default_struct:#?}\");\n"
#~ "\n"
#~ "    let nothing: Option<Derived> = None;\n"
#~ "    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Derived {\n"
#~ "    x: u32,\n"
#~ "    y: String,\n"
#~ "    z: Implemented,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Implemented(String);\n"
#~ "\n"
#~ "impl Default for Implemented {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self(\"John Smith\".into())\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let default_struct = Derived::default();\n"
#~ "    println!(\"{default_struct:#?}\");\n"
#~ "\n"
#~ "    let almost_default_struct = Derived {\n"
#~ "        y: \"Y is set!\".into(),\n"
#~ "        ..Derived::default()\n"
#~ "    };\n"
#~ "    println!(\"{almost_default_struct:#?}\");\n"
#~ "\n"
#~ "    let nothing: Option<Derived> = None;\n"
#~ "    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "`Add`, `Mul`, ..."
#~ msgstr "`Add`, `Mul`, ..."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Copy, Clone)]\n"
#~ "struct Point { x: i32, y: i32 }\n"
#~ "\n"
#~ "impl std::ops::Add for Point {\n"
#~ "    type Output = Self;\n"
#~ "\n"
#~ "    fn add(self, other: Self) -> Self {\n"
#~ "        Self {x: self.x + other.x, y: self.y + other.y}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 10, y: 20 };\n"
#~ "    let p2 = Point { x: 100, y: 200 };\n"
#~ "    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Copy, Clone)]\n"
#~ "struct Point { x: i32, y: i32 }\n"
#~ "\n"
#~ "impl std::ops::Add for Point {\n"
#~ "    type Output = Self;\n"
#~ "\n"
#~ "    fn add(self, other: Self) -> Self {\n"
#~ "        Self {x: self.x + other.x, y: self.y + other.y}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 10, y: 20 };\n"
#~ "    let p2 = Point { x: 100, y: 200 };\n"
#~ "    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
#~ "    println!(\"Calling function on {input}\");\n"
#~ "    func(input)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let add_3 = |x| x + 3;\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
#~ "\n"
#~ "    let mut v = Vec::new();\n"
#~ "    let mut accumulate = |x: i32| {\n"
#~ "        v.push(x);\n"
#~ "        v.iter().sum::<i32>()\n"
#~ "    };\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
#~ "\n"
#~ "    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
#~ "    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
#~ "    println!(\"Calling function on {input}\");\n"
#~ "    func(input)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let add_3 = |x| x + 3;\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
#~ "\n"
#~ "    let mut v = Vec::new();\n"
#~ "    let mut accumulate = |x: i32| {\n"
#~ "        v.push(x);\n"
#~ "        v.iter().sum::<i32>()\n"
#~ "    };\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
#~ "\n"
#~ "    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
#~ "    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
#~ "    return move |name| println!(\"{} {}\", prefix, name)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let hi = make_greeter(\"Hi\".to_string());\n"
#~ "    hi(\"there\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
#~ "    return move |name| println!(\"{} {}\", prefix, name)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let hi = make_greeter(\"Hi\".to_string());\n"
#~ "    hi(\"there\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Day 3: Morning Exercises"
#~ msgstr "3일차 오전 연습문제"

#~ msgid "We will design a classical GUI library traits and trait objects."
#~ msgstr ""
#~ "이번 연습문제에서는 트레잇와 트레잇 객체를 통해 고전적인 GUI 라이브러리를 "
#~ "설계할 것입니다."

#~ msgid ""
#~ "`Button`: has a `label` and a callback function which is invoked when the "
#~ "button is pressed."
#~ msgstr ""
#~ "`Button`: `label` 속성을 가지고 있으며, 버튼이 눌렸을때 실행되는 콜백 함수"
#~ "가 있습니다."

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;\n"
#~ "\n"
#~ "    /// Draw the widget into a buffer.\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
#~ "\n"
#~ "    /// Draw the widget on standard output.\n"
#~ "    fn draw(&self) {\n"
#~ "        let mut buffer = String::new();\n"
#~ "        self.draw_into(&mut buffer);\n"
#~ "        println!(\"{buffer}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Label {\n"
#~ "    label: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl Label {\n"
#~ "    fn new(label: &str) -> Label {\n"
#~ "        Label {\n"
#~ "            label: label.to_owned(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Button {\n"
#~ "    label: Label,\n"
#~ "    callback: Box<dyn FnMut()>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Button {\n"
#~ "    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
#~ "        Button {\n"
#~ "            label: Label::new(label),\n"
#~ "            callback,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Window {\n"
#~ "    title: String,\n"
#~ "    widgets: Vec<Box<dyn Widget>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Window {\n"
#~ "    fn new(title: &str) -> Window {\n"
#~ "        Window {\n"
#~ "            title: title.to_owned(),\n"
#~ "            widgets: Vec::new(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
#~ "        self.widgets.push(widget);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inner_width(&self) -> usize {\n"
#~ "        std::cmp::max(\n"
#~ "            self.title.chars().count(),\n"
#~ "            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
#~ "        )\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
#~ "\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Click me!\",\n"
#~ "        Box::new(|| println!(\"You clicked the button!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;\n"
#~ "\n"
#~ "    /// Draw the widget into a buffer.\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
#~ "\n"
#~ "    /// Draw the widget on standard output.\n"
#~ "    fn draw(&self) {\n"
#~ "        let mut buffer = String::new();\n"
#~ "        self.draw_into(&mut buffer);\n"
#~ "        println!(\"{buffer}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Label {\n"
#~ "    label: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl Label {\n"
#~ "    fn new(label: &str) -> Label {\n"
#~ "        Label {\n"
#~ "            label: label.to_owned(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Button {\n"
#~ "    label: Label,\n"
#~ "    callback: Box<dyn FnMut()>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Button {\n"
#~ "    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
#~ "        Button {\n"
#~ "            label: Label::new(label),\n"
#~ "            callback,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Window {\n"
#~ "    title: String,\n"
#~ "    widgets: Vec<Box<dyn Widget>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Window {\n"
#~ "    fn new(title: &str) -> Window {\n"
#~ "        Window {\n"
#~ "            title: title.to_owned(),\n"
#~ "            widgets: Vec::new(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
#~ "        self.widgets.push(widget);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inner_width(&self) -> usize {\n"
#~ "        std::cmp::max(\n"
#~ "            self.title.chars().count(),\n"
#~ "            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
#~ "        )\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
#~ "\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Click me!\",\n"
#~ "        Box::new(|| println!(\"You clicked the button!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "========\n"
#~ "Rust GUI Demo 1.23\n"
#~ "========\n"
#~ "\n"
#~ "This is a small text GUI demo.\n"
#~ "\n"
#~ "| Click me! |\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "========\n"
#~ "Rust GUI Demo 1.23\n"
#~ "========\n"
#~ "\n"
#~ "This is a small text GUI demo.\n"
#~ "\n"
#~ "| Click me! |\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let width = 10;\n"
#~ "    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
#~ "    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
#~ "    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let width = 10;\n"
#~ "    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
#~ "    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
#~ "    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "+--------------------------------+\n"
#~ "|       Rust GUI Demo 1.23       |\n"
#~ "+================================+\n"
#~ "| This is a small text GUI demo. |\n"
#~ "| +-----------+                  |\n"
#~ "| | Click me! |                  |\n"
#~ "| +-----------+                  |\n"
#~ "+--------------------------------+\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "+--------------------------------+\n"
#~ "|       Rust GUI Demo 1.23       |\n"
#~ "+================================+\n"
#~ "| This is a small text GUI demo. |\n"
#~ "| +-----------+                  |\n"
#~ "| | Click me! |                  |\n"
#~ "| +-----------+                  |\n"
#~ "+--------------------------------+\n"
#~ "```"

#~ msgid "Error handling in Rust is done using explicit control flow:"
#~ msgstr "러스트에서 오류는 명시적인 흐름을 따라 처리가 됩니다:"

#~ msgid "Functions that can have errors list this in their return type,"
#~ msgstr "오류를 발생할 수 있는 함수는 반환 타입에 이를 명시해야 합니다,"

#~ msgid "There are no exceptions."
#~ msgstr "예외(exception) 기능은 없습니다."

#~ msgid ""
#~ "```rust,editable,should_panic\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    println!(\"v[100]: {}\", v[100]);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,should_panic\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    println!(\"v[100]: {}\", v[100]);\n"
#~ "}\n"
#~ "```"

#~ msgid "Catching the Stack Unwinding"
#~ msgstr "스택 되감기"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::panic;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        println!(\"hello!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_ok());\n"
#~ "    \n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        panic!(\"oh no!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_err());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::panic;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        println!(\"hello!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_ok());\n"
#~ "    \n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        panic!(\"oh no!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_err());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We have already seen the `Result` enum. This is used pervasively when "
#~ "errors are expected as part of normal operation:"
#~ msgstr ""
#~ "여러분은 이미 `Result` 열거형을 몇 번 봤습니다. 이 타입은 프로그램의 정상"
#~ "적인 수행 중에 발생할 수 있는 오류값들을 나타내기 위해 사용됩니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let file = fs::File::open(\"diary.txt\");\n"
#~ "    match file {\n"
#~ "        Ok(mut file) => {\n"
#~ "            let mut contents = String::new();\n"
#~ "            file.read_to_string(&mut contents);\n"
#~ "            println!(\"Dear diary: {contents}\");\n"
#~ "        },\n"
#~ "        Err(err) => {\n"
#~ "            println!(\"The diary could not be opened: {err}\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let file = fs::File::open(\"diary.txt\");\n"
#~ "    match file {\n"
#~ "        Ok(mut file) => {\n"
#~ "            let mut contents = String::new();\n"
#~ "            file.read_to_string(&mut contents);\n"
#~ "            println!(\"Dear diary: {contents}\");\n"
#~ "        },\n"
#~ "        Err(err) => {\n"
#~ "            println!(\"The diary could not be opened: {err}\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Propagating Errors with `?`"
#~ msgstr "`?`를 이용한 오류 전파"

#~ msgid ""
#~ "The try-operator `?` is used to return errors to the caller. It lets you "
#~ "turn the common"
#~ msgstr ""
#~ "연산자 `?`는 호출자에게 오류를 반환할 때 사용합니다. 이를 이용하면 이런 코"
#~ "드를"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "match some_expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err) => return Err(err),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "match some_expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err) => return Err(err),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "some_expression?\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "some_expression?\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, io::Error> {\n"
#~ "    let username_file_result = fs::File::open(path);\n"
#~ "    let mut username_file = match username_file_result {\n"
#~ "        Ok(file) => file,\n"
#~ "        Err(err) => return Err(err),\n"
#~ "    };\n"
#~ "\n"
#~ "    let mut username = String::new();\n"
#~ "    match username_file.read_to_string(&mut username) {\n"
#~ "        Ok(_) => Ok(username),\n"
#~ "        Err(err) => Err(err),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, io::Error> {\n"
#~ "    let username_file_result = fs::File::open(path);\n"
#~ "    let mut username_file = match username_file_result {\n"
#~ "        Ok(file) => file,\n"
#~ "        Err(err) => return Err(err),\n"
#~ "    };\n"
#~ "\n"
#~ "    let mut username = String::new();\n"
#~ "    match username_file.read_to_string(&mut username) {\n"
#~ "        Ok(_) => Ok(username),\n"
#~ "        Err(err) => Err(err),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The return type of the function has to be compatible with the nested "
#~ "functions it calls. For instance, a function returning a `Result<T, Err>` "
#~ "can only apply the `?` operator on a function returning a  `Result<AnyT, "
#~ "Err>`. It cannot apply the `?` operator on a function returning an "
#~ "`Option<AnyT>` or `Result<T, OtherErr>` unless `OtherErr` implements "
#~ "`From<Err>`. Reciprocally, a function returning an `Option<T>` can only "
#~ "apply the `?` operator  on a function returning an `Option<AnyT>`."
#~ msgstr ""
#~ "함수의 리턴 타입은 네스팅 되어 호출되는 함수의 리턴 타입과 호환되어야 합니"
#~ "다. 예를 들어 `Result<T, Err>`를 리턴하는 함수는 `Result<AnyT, Err>`를 리"
#~ "턴하는 함수를 호출할 때에만`?`를 사용할 수 있습니다. `Option<AnyT>`나 "
#~ "`Result<T, OtherErr>` (`OtherError`가 `From<Err>`를 구현하지 않는 다고 가"
#~ "정할 때)와 같은 타입을 리턴하는 함수를 호출할 때에는 `?`를 사용할 수 없습"
#~ "니다. 동일한 이유로, `Option<T>`를 리턴하는 함수는 `Option<AnyT>`를 리턴하"
#~ "는 함수를 호출할 때에만 `?`를 사용할 수 있습니다."

#~ msgid ""
#~ "You can convert incompatible types into one another with the different "
#~ "`Option` and `Result` methods  such as `Option::ok_or`, `Result::ok`, "
#~ "`Result::err`."
#~ msgstr ""
#~ "`Option`과 `Result`간의 변환을 위해 `Option::ok_or`, `Result::ok`, "
#~ "`Result::err`와 같은 함수들을 사용할 수 있습니다."

#~ msgid ""
#~ "```rust,ignore\n"
#~ "expression?\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "expression?\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "match expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err)  => return Err(From::from(err)),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "match expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err)  => return Err(From::from(err)),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::error::Error;\n"
#~ "use std::fmt::{self, Display, Formatter};\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::{self, Read};\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    IoError(io::Error),\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "impl Error for ReadUsernameError {}\n"
#~ "\n"
#~ "impl Display for ReadUsernameError {\n"
#~ "    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
#~ "        match self {\n"
#~ "            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
#~ "            Self::EmptyUsername(filename) => write!(f, \"Found no "
#~ "username in {filename}\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl From<io::Error> for ReadUsernameError {\n"
#~ "    fn from(err: io::Error) -> ReadUsernameError {\n"
#~ "        ReadUsernameError::IoError(err)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::error::Error;\n"
#~ "use std::fmt::{self, Display, Formatter};\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::{self, Read};\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    IoError(io::Error),\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "impl Error for ReadUsernameError {}\n"
#~ "\n"
#~ "impl Display for ReadUsernameError {\n"
#~ "    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
#~ "        match self {\n"
#~ "            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
#~ "            Self::EmptyUsername(filename) => write!(f, \"Found no "
#~ "username in {filename}\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl From<io::Error> for ReadUsernameError {\n"
#~ "    fn from(err: io::Error) -> ReadUsernameError {\n"
#~ "        ReadUsernameError::IoError(err)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "It is good practice for all error types that don't need to be `no_std` to "
#~ "implement `std::error::Error`, which requires `Debug` and `Display`. The "
#~ "`Error` crate for `core` is only available in [nightly](https://github."
#~ "com/rust-lang/rust/issues/103765), so not fully `no_std` compatible yet."
#~ msgstr ""
#~ "모든 에러 타입 (`no_std`이어야 하는 에러 타입을 제외하고)에 대해 `std::"
#~ "error::Error`를 구현하는 것은 좋은 습관입니다. `std::error::Error`를 구현"
#~ "한다는 것은 `Debug`와 `Display`도 구현한다는 것입니다. `core`를 위한 "
#~ "`Error`크레이크는 [나이틀리](https://github.com/rust-lang/rust/"
#~ "issues/103765)에만 제공이 됩니다. 그래서 아직 `no_std`환경에서 사용할 수"
#~ "는 없습니다."

#~ msgid ""
#~ "It's generally helpful for them to implement `Clone` and `Eq` too where "
#~ "possible, to make life easier for tests and consumers of your library. In "
#~ "this case we can't easily do so, because `io::Error` doesn't implement "
#~ "them."
#~ msgstr ""
#~ "가능하다면 `Clone`과 `Eq` 트레잇도 구현하도록 하세요. 여러분의 라이브러리"
#~ "가 테스트 하기 쉬워지고, 사용하기 좋아질 겁니다. 다만, 이 예제에서는 그렇"
#~ "게 하기 힘듭니다. 왜냐하면 `io::Error`는 이 트레잇들을 구현하고 있지 않기 "
#~ "때문입니다."

#~ msgid ""
#~ "The [thiserror](https://docs.rs/thiserror/) crate is a popular way to "
#~ "create an error enum like we did on the previous page:"
#~ msgstr ""
#~ "[thiserror](https://docs.rs/thiserror/)는, 이전 페이지에서 보았던 것과 같"
#~ "은 에러 열거형을 쉽게 만들 수 있게 해 주는 유명한 크레이트 입니다:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "\n"
#~ "#[derive(Debug, Error)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    #[error(\"Could not read: {0}\")]\n"
#~ "    IoError(#[from] io::Error),\n"
#~ "    #[error(\"Found no username in {0}\")]\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "\n"
#~ "#[derive(Debug, Error)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    #[error(\"Could not read: {0}\")]\n"
#~ "    IoError(#[from] io::Error),\n"
#~ "    #[error(\"Found no username in {0}\")]\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "`thiserror`'s derive macro automatically implements `std::error::Error`, "
#~ "and optionally `Display` (if the `#[error(...)]` attributes are provided) "
#~ "and `From` (if the `#[from]` attribute is added). It also works for "
#~ "structs."
#~ msgstr ""
#~ "`thiserror`의 derive 매크로를 이용하면 `std::error::Error`과 `Display`(만"
#~ "약 `#[error(...)]` 어트리뷰트를 추가했을 경우), `From`(만약 `#[from]` 어트"
#~ "리뷰트를 추가했을 경우) 트레잇들이 자동으로 구현이 됩니다. 구조체에 대해서"
#~ "도 사용 가능합니다."

#~ msgid ""
#~ "It doesn't affect your public API, which makes it good for libraries."
#~ msgstr ""
#~ "이 매크로를 사용해도 밖으로 노출되는 API가 변경되지는 않습니다. 라이브러리"
#~ "를 만들 경우에는 이게 중요하죠."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "use std::error::Error;\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
#~ "#[error(\"Found no username in {0}\")]\n"
#~ "struct EmptyUsernameError(String);\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(EmptyUsernameError(String::from(path)).into());\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "use std::error::Error;\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
#~ "#[error(\"Found no username in {0}\")]\n"
#~ "struct EmptyUsernameError(String);\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(EmptyUsernameError(String::from(path)).into());\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
#~ "contextual information to your errors and allows you to have fewer custom "
#~ "error types:"
#~ msgstr ""
#~ "[anyhow](https://docs.rs/anyhow/) 크레이트는 에러에 에러가 발생한 문맥에 "
#~ "대한 정보를 추가하기 위해 널리 사용되며, 이를 이용하면 서로 다른 문맥을 나"
#~ "타내기 사용자 정의 오류 타입을 많이 만들어야 하는 불편함을 피할 수 있습니"
#~ "다:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use anyhow::{Context, Result, bail};\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    fs::File::open(path)\n"
#~ "        .with_context(|| format!(\"Failed to open {path}\"))?\n"
#~ "        .read_to_string(&mut username)\n"
#~ "        .context(\"Failed to read\")?;\n"
#~ "    if username.is_empty() {\n"
#~ "        bail!(\"Found no username in {path}\");\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err:?}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use anyhow::{Context, Result, bail};\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    fs::File::open(path)\n"
#~ "        .with_context(|| format!(\"Failed to open {path}\"))?\n"
#~ "        .read_to_string(&mut username)\n"
#~ "        .context(\"Failed to read\")?;\n"
#~ "    if username.is_empty() {\n"
#~ "        bail!(\"Found no username in {path}\");\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err:?}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Mark unit tests with `#[test]`:"
#~ msgstr "단위 테스트는 `#[test]` 로 표시합니다:"

#~ msgid ""
#~ "```rust,editable,ignore\n"
#~ "fn first_word(text: &str) -> &str {\n"
#~ "    match text.find(' ') {\n"
#~ "        Some(idx) => &text[..idx],\n"
#~ "        None => &text,\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty() {\n"
#~ "    assert_eq!(first_word(\"\"), \"\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_word() {\n"
#~ "    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_multiple_words() {\n"
#~ "    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,ignore\n"
#~ "fn first_word(text: &str) -> &str {\n"
#~ "    match text.find(' ') {\n"
#~ "        Some(idx) => &text[..idx],\n"
#~ "        None => &text,\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty() {\n"
#~ "    assert_eq!(first_word(\"\"), \"\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_word() {\n"
#~ "    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_multiple_words() {\n"
#~ "    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Use `cargo test` to find and run the unit tests."
#~ msgstr "`cargo test` 커맨드를 사용하면 단위 테스트를 찾아서 실행합니다."

#~ msgid ""
#~ "Unit tests are often put in a nested module (run tests on the [Playground]"
#~ "(https://play.rust-lang.org/)):"
#~ msgstr ""
#~ "단위 테스트는 원래 모듈 밑에 서브 모듈로 만드는 경우가 많습니다. ([플레이"
#~ "그라운드](https://play.rust-lang.org/)에서 다음 테스트를 수행해 보세요):"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn helper(a: &str, b: &str) -> String {\n"
#~ "    format!(\"{a} {b}\")\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_helper() {\n"
#~ "        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn helper(a: &str, b: &str) -> String {\n"
#~ "    format!(\"{a} {b}\")\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_helper() {\n"
#~ "        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use my_library::init;\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_init() {\n"
#~ "    assert!(init().is_ok());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "use my_library::init;\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_init() {\n"
#~ "    assert!(init().is_ok());\n"
#~ "}\n"
#~ "```"

#~ msgid "Useful crates for writing tests"
#~ msgstr "테스트 작성에 유용한 크레이트"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static HELLO_WORLD: &str = \"Hello, world!\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static HELLO_WORLD: &str = \"Hello, world!\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static mut COUNTER: u32 = 0;\n"
#~ "\n"
#~ "fn add_to_counter(inc: u32) {\n"
#~ "    unsafe { COUNTER += inc; }  // Potential data race!\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    add_to_counter(42);\n"
#~ "\n"
#~ "    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data "
#~ "race!\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static mut COUNTER: u32 = 0;\n"
#~ "\n"
#~ "fn add_to_counter(inc: u32) {\n"
#~ "    unsafe { COUNTER += inc; }  // 잠재적 데이터 경합!\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    add_to_counter(42);\n"
#~ "\n"
#~ "    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // 잠재적 데이터 경합!\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[repr(C)]\n"
#~ "union MyUnion {\n"
#~ "    i: u8,\n"
#~ "    b: bool,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let u = MyUnion { i: 42 };\n"
#~ "    println!(\"int: {}\", unsafe { u.i });\n"
#~ "    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[repr(C)]\n"
#~ "union MyUnion {\n"
#~ "    i: u8,\n"
#~ "    b: bool,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let u = MyUnion { i: 42 };\n"
#~ "    println!(\"int: {}\", unsafe { u.i });\n"
#~ "    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let emojis = \"🗻∈🌏\";\n"
#~ "\n"
#~ "    // Safe because the indices are in the correct order, within the "
#~ "bounds of\n"
#~ "    // the string slice, and lie on UTF-8 sequence boundaries.\n"
#~ "    unsafe {\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..7) }));\n"
#~ "\n"
#~ "    // Not upholding the UTF-8 encoding requirement breaks memory "
#~ "safety!\n"
#~ "    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
#~ "    // println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..3) }));\n"
#~ "}\n"
#~ "\n"
#~ "fn count_chars(s: &str) -> usize {\n"
#~ "    s.chars().map(|_| 1).sum()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let emojis = \"🗻∈🌏\";\n"
#~ "\n"
#~ "    // Safe because the indices are in the correct order, within the "
#~ "bounds of\n"
#~ "    // the string slice, and lie on UTF-8 sequence boundaries.\n"
#~ "    unsafe {\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..7) }));\n"
#~ "\n"
#~ "    // Not upholding the UTF-8 encoding requirement breaks memory "
#~ "safety!\n"
#~ "    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
#~ "    // println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..3) }));\n"
#~ "}\n"
#~ "\n"
#~ "fn count_chars(s: &str) -> usize {\n"
#~ "    s.chars().map(|_| 1).sum()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "/// Swaps the values pointed to by the given pointers.\n"
#~ "///\n"
#~ "/// # Safety\n"
#~ "///\n"
#~ "/// The pointers must be valid and properly aligned.\n"
#~ "unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
#~ "    let temp = *a;\n"
#~ "    *a = *b;\n"
#~ "    *b = temp;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = 42;\n"
#~ "    let mut b = 66;\n"
#~ "\n"
#~ "    // Safe because ...\n"
#~ "    unsafe {\n"
#~ "        swap(&mut a, &mut b);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a = {}, b = {}\", a, b);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "/// Swaps the values pointed to by the given pointers.\n"
#~ "///\n"
#~ "/// # Safety\n"
#~ "///\n"
#~ "/// The pointers must be valid and properly aligned.\n"
#~ "unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
#~ "    let temp = *a;\n"
#~ "    *a = *b;\n"
#~ "    *b = temp;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = 42;\n"
#~ "    let mut b = 66;\n"
#~ "\n"
#~ "    // Safe because ...\n"
#~ "    unsafe {\n"
#~ "        swap(&mut a, &mut b);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a = {}, b = {}\", a, b);\n"
#~ "}\n"
#~ "```"

#~ msgid "Calling External Code"
#~ msgstr "외부 코드 호출"

#~ msgid ""
#~ "Functions from other languages might violate the guarantees of Rust. "
#~ "Calling them is thus unsafe:"
#~ msgstr ""
#~ "다른 언어의 함수는 러스트의 보증을 위반할 수 있습니다. 따라서 이를 호출하"
#~ "는 것은 안전하지 않습니다:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(input: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    unsafe {\n"
#~ "        // Undefined behavior if abs misbehaves.\n"
#~ "        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(input: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    unsafe {\n"
#~ "        // Undefined behavior if abs misbehaves.\n"
#~ "        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::mem::size_of_val;\n"
#~ "use std::slice;\n"
#~ "\n"
#~ "/// ...\n"
#~ "/// # Safety\n"
#~ "/// The type must have a defined representation and no padding.\n"
#~ "pub unsafe trait AsBytes {\n"
#~ "    fn as_bytes(&self) -> &[u8] {\n"
#~ "        unsafe {\n"
#~ "            slice::from_raw_parts(self as *const Self as *const u8, "
#~ "size_of_val(self))\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Safe because u32 has a defined representation and no padding.\n"
#~ "unsafe impl AsBytes for u32 {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::mem::size_of_val;\n"
#~ "use std::slice;\n"
#~ "\n"
#~ "/// ...\n"
#~ "/// # Safety\n"
#~ "/// The type must have a defined representation and no padding.\n"
#~ "pub unsafe trait AsBytes {\n"
#~ "    fn as_bytes(&self) -> &[u8] {\n"
#~ "        unsafe {\n"
#~ "            slice::from_raw_parts(self as *const Self as *const u8, "
#~ "size_of_val(self))\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Safe because u32 has a defined representation and no padding.\n"
#~ "unsafe impl AsBytes for u32 {}\n"
#~ "```"

#~ msgid "Day 3: Afternoon Exercises"
#~ msgstr "3일차 오후 연습문제"

#~ msgid "Let us build a safe wrapper for reading directory content!"
#~ msgstr "디렉터리의 내용을 읽는 안전한 래퍼 코드를 작성해 봅시다!"

#~ msgid ""
#~ "For this exercise, we suggest using a local dev environment instead of "
#~ "the Playground. This will allow you to run your binary on your own "
#~ "machine."
#~ msgstr ""
#~ "이번 연습에서는, 플레이그라운드 대신 로컬 개발 환경을 사용해서, 여러분의 "
#~ "컴퓨터에서 바이너리를 직접 수행해 보세요."

#~ msgid ""
#~ "To get started, follow the [running locally](../../cargo/running-locally."
#~ "md) instructions."
#~ msgstr ""
#~ "시작하기 위해, [로컬 환경에서 수행하기](../../cargo/running-locally.md)를 "
#~ "따르세요."

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int};\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
#~ "\n"
#~ "    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct DIR {\n"
#~ "        _data: [u8; 0],\n"
#~ "        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
#~ "PhantomPinned)>,\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the Linux man page for readdir(3), where ino_t "
#~ "and\n"
#~ "    // off_t are resolved according to the definitions in\n"
#~ "    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_ino: c_ulong,\n"
#~ "        pub d_off: c_long,\n"
#~ "        pub d_reclen: c_ushort,\n"
#~ "        pub d_type: c_uchar,\n"
#~ "        pub d_name: [c_char; 256],\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the macOS man page for dir(5).\n"
#~ "    #[cfg(all(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_fileno: u64,\n"
#~ "        pub d_seekoff: u64,\n"
#~ "        pub d_reclen: u16,\n"
#~ "        pub d_namlen: u16,\n"
#~ "        pub d_type: u8,\n"
#~ "        pub d_name: [c_char; 1024],\n"
#~ "    }\n"
#~ "\n"
#~ "    extern \"C\" {\n"
#~ "        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
#~ "\n"
#~ "        #[cfg(not(all(target_os = \"macos\", target_arch = "
#~ "\"x86_64\")))]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        // See https://github.com/rust-lang/libc/issues/414 and the "
#~ "section on\n"
#~ "        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for "
#~ "stat(2).\n"
#~ "        //\n"
#~ "        // \"Platforms that existed before these updates were available\" "
#~ "refers\n"
#~ "        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
#~ "PowerPC.\n"
#~ "        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
#~ "        #[link_name = \"readdir$INODE64\"]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        pub fn closedir(s: *mut DIR) -> c_int;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use std::ffi::{CStr, CString, OsStr, OsString};\n"
#~ "use std::os::unix::ffi::OsStrExt;\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}\n"
#~ "\n"
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for DirectoryIterator {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Call closedir as needed.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int};\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
#~ "\n"
#~ "    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct DIR {\n"
#~ "        _data: [u8; 0],\n"
#~ "        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
#~ "PhantomPinned)>,\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the Linux man page for readdir(3), where ino_t "
#~ "and\n"
#~ "    // off_t are resolved according to the definitions in\n"
#~ "    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_ino: c_ulong,\n"
#~ "        pub d_off: c_long,\n"
#~ "        pub d_reclen: c_ushort,\n"
#~ "        pub d_type: c_uchar,\n"
#~ "        pub d_name: [c_char; 256],\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the macOS man page for dir(5).\n"
#~ "    #[cfg(all(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_fileno: u64,\n"
#~ "        pub d_seekoff: u64,\n"
#~ "        pub d_reclen: u16,\n"
#~ "        pub d_namlen: u16,\n"
#~ "        pub d_type: u8,\n"
#~ "        pub d_name: [c_char; 1024],\n"
#~ "    }\n"
#~ "\n"
#~ "    extern \"C\" {\n"
#~ "        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
#~ "\n"
#~ "        #[cfg(not(all(target_os = \"macos\", target_arch = "
#~ "\"x86_64\")))]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        // See https://github.com/rust-lang/libc/issues/414 and the "
#~ "section on\n"
#~ "        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for "
#~ "stat(2).\n"
#~ "        //\n"
#~ "        // \"Platforms that existed before these updates were available\" "
#~ "refers\n"
#~ "        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
#~ "PowerPC.\n"
#~ "        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
#~ "        #[link_name = \"readdir$INODE64\"]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        pub fn closedir(s: *mut DIR) -> c_int;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use std::ffi::{CStr, CString, OsStr, OsString};\n"
#~ "use std::os::unix::ffi::OsStrExt;\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}\n"
#~ "\n"
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for DirectoryIterator {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Call closedir as needed.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "source build/envsetup.sh\n"
#~ "lunch aosp_cf_x86_64_phone-userdebug\n"
#~ "acloud create\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ source build/envsetup.sh\n"
#~ "$ lunch aosp_cf_x86_64_phone-userdebug\n"
#~ "$ acloud create\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust\",\n"
#~ "    crate_name: \"hello_rust\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust\",\n"
#~ "    crate_name: \"hello_rust\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello from Rust!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//! Rust 데모입니다.\n"
#~ "\n"
#~ "/// 인사말을 표준 출력으로 인쇄합니다.\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello from Rust!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_with_dep\",\n"
#~ "    crate_name: \"hello_rust_with_dep\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libgreetings\",\n"
#~ "        \"libtextwrap\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "\n"
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_with_dep\",\n"
#~ "    crate_name: \"hello_rust_with_dep\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libgreetings\",\n"
#~ "        \"libtextwrap\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "\n"
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Rust 데모입니다.\n"
#~ "\n"
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;\n"
#~ "\n"
#~ "/// 인사말을 표준 출력으로 인쇄합니다.\n"
#~ "fn main() {\n"
#~ "    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Greeting library.\n"
#~ "\n"
#~ "/// Greet `name`.\n"
#~ "pub fn greeting(name: &str) -> String {\n"
#~ "    format!(\"Hello {name}, it is very nice to meet you!\")\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! 인사말 라이브러리입니다.\n"
#~ "\n"
#~ "/// `이름`에게 인사합니다.\n"
#~ "pub fn greeting(name: &str) -> String {\n"
#~ "    format!(\"Hello {name}, it is very nice to meet you!\")\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** Birthday service interface. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** 생일 서비스 인터페이스입니다. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "aidl_interface {\n"
#~ "    name: \"com.example.birthdayservice\",\n"
#~ "    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
#~ "    unstable: true,\n"
#~ "    backend: {\n"
#~ "        rust: { // Rust is not enabled by default\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "aidl_interface {\n"
#~ "    name: \"com.example.birthdayservice\",\n"
#~ "    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
#~ "    unstable: true,\n"
#~ "    backend: {\n"
#~ "        rust: { // Rust is not enabled by default\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Implementation of the `IBirthdayService` AIDL interface.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "/// The `IBirthdayService` implementation.\n"
#~ "pub struct BirthdayService;\n"
#~ "\n"
#~ "impl binder::Interface for BirthdayService {}\n"
#~ "\n"
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
#~ "Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} "
#~ "years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! `IBirthdayService` AIDL 인터페이스의 구현입니다.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "/// `IBirthdayService` 구현입니다.\n"
#~ "pub struct BirthdayService;\n"
#~ "\n"
#~ "impl binder::Interface for BirthdayService {}\n"
#~ "\n"
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
#~ "Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} "
#~ "years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_library {\n"
#~ "    name: \"libbirthdayservice\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    crate_name: \"birthdayservice\",\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_library {\n"
#~ "    name: \"libbirthdayservice\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    crate_name: \"birthdayservice\",\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// Entry point for birthday service.\n"
#~ "fn main() {\n"
#~ "    let birthday_service = BirthdayService;\n"
#~ "    let birthday_service_binder = BnBirthdayService::new_binder(\n"
#~ "        birthday_service,\n"
#~ "        binder::BinderFeatures::default(),\n"
#~ "    );\n"
#~ "    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
#~ "as_binder())\n"
#~ "        .expect(\"Failed to register service\");\n"
#~ "    binder::ProcessState::join_thread_pool()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! 생일 서비스입니다.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// 생일 서비스의 진입점입니다.\n"
#~ "fn main() {\n"
#~ "    let birthday_service = BirthdayService;\n"
#~ "    let birthday_service_binder = BnBirthdayService::new_binder(\n"
#~ "        birthday_service,\n"
#~ "        binder::BinderFeatures::default(),\n"
#~ "    );\n"
#~ "    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
#~ "as_binder())\n"
#~ "        .expect(\"Failed to register service\");\n"
#~ "    binder::ProcessState::join_thread_pool()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_server\",\n"
#~ "    crate_name: \"birthday_server\",\n"
#~ "    srcs: [\"src/server.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "        \"libbirthdayservice\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_server\",\n"
#~ "    crate_name: \"birthday_server\",\n"
#~ "    srcs: [\"src/server.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "        \"libbirthdayservice\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "adb shell service check birthdayservice\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb shell service check birthdayservice\n"
#~ "Service birthdayservice: found\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "Service birthdayservice: found\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb shell service check birthdayservice\n"
#~ "Service birthdayservice: found\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "adb shell service call birthdayservice 1 s16 Bob i32 24\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb shell service check birthdayservice\n"
#~ "Service birthdayservice: found\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "Result: Parcel(\n"
#~ "  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
#~ "  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
#~ "  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
#~ "  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
#~ "  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
#~ "  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
#~ "  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
#~ "  0x00000070: 00210073 00000000                   's.!.....        ')\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
#~ "Result: Parcel(\n"
#~ "  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
#~ "  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
#~ "  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
#~ "  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
#~ "  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
#~ "  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
#~ "  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
#~ "  0x00000070: 00210073 00000000                   's.!.....        ')\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// Connect to the BirthdayService.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
#~ "StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}\n"
#~ "\n"
#~ "/// Call the birthday service.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);\n"
#~ "\n"
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to "
#~ "BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! 생일 서비스입니다.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// BirthdayService에 연결합니다.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
#~ "StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}\n"
#~ "\n"
#~ "/// 생일 서비스를 호출합니다.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);\n"
#~ "\n"
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to "
#~ "BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_client\",\n"
#~ "    crate_name: \"birthday_client\",\n"
#~ "    srcs: [\"src/client.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_client\",\n"
#~ "    crate_name: \"birthday_client\",\n"
#~ "    srcs: [\"src/client.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** Birthday service interface. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years, in String[] text);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** 생일 서비스 인터페이스입니다. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years, in String[] text);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_logs\",\n"
#~ "    crate_name: \"hello_rust_logs\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"liblog_rust\",\n"
#~ "        \"liblogger\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "    host_supported: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_logs\",\n"
#~ "    crate_name: \"hello_rust_logs\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"liblog_rust\",\n"
#~ "        \"liblogger\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "    host_supported: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust logging demo.\n"
#~ "\n"
#~ "use log::{debug, error, info};\n"
#~ "\n"
#~ "/// Logs a greeting.\n"
#~ "fn main() {\n"
#~ "    logger::init(\n"
#~ "        logger::Config::default()\n"
#~ "            .with_tag_on_device(\"rust\")\n"
#~ "            .with_min_level(log::Level::Trace),\n"
#~ "    );\n"
#~ "    debug!(\"Starting program.\");\n"
#~ "    info!(\"Things are going fine.\");\n"
#~ "    error!(\"Something went wrong!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Rust 로깅 데모입니다.\n"
#~ "\n"
#~ "use log::{debug, error, info};\n"
#~ "\n"
#~ "/// 인사말을 기록합니다.\n"
#~ "fn main() {\n"
#~ "    logger::init(\n"
#~ "        logger::Config::default()\n"
#~ "            .with_tag_on_device(\"rust\")\n"
#~ "            .with_min_level(log::Level::Trace),\n"
#~ "    );\n"
#~ "    debug!(\"Starting program.\");\n"
#~ "    info!(\"Things are going fine.\");\n"
#~ "    error!(\"Something went wrong!\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "adb logcat -s rust\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ sudo apt install cargo rust-src rustfmt\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting "
#~ "program.\n"
#~ "09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
#~ "fine.\n"
#~ "09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
#~ "wrong!\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb logcat -s rust\n"
#~ "09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting "
#~ "program.\n"
#~ "09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
#~ "fine.\n"
#~ "09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
#~ "wrong!\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -42;\n"
#~ "    let abs_x = unsafe { abs(x) };\n"
#~ "    println!(\"{x}, {abs_x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -42;\n"
#~ "    let abs_x = unsafe { abs(x) };\n"
#~ "    println!(\"{x}, {abs_x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI demo.\n"
#~ "\n"
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;\n"
#~ "\n"
#~ "/// HelloWorld::hello method implementation.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"system\" fn Java_HelloWorld_hello(\n"
#~ "    env: JNIEnv,\n"
#~ "    _class: JClass,\n"
#~ "    name: JString,\n"
#~ ") -> jstring {\n"
#~ "    let input: String = env.get_string(name).unwrap().into();\n"
#~ "    let greeting = format!(\"Hello, {input}!\");\n"
#~ "    let output = env.new_string(greeting).unwrap();\n"
#~ "    output.into_inner()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI 데모입니다.\n"
#~ "\n"
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;\n"
#~ "\n"
#~ "/// HelloWorld::hello 메서드 구현입니다.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"system\" fn Java_HelloWorld_hello(\n"
#~ "    env: JNIEnv,\n"
#~ "    _class: JClass,\n"
#~ "    name: JString,\n"
#~ ") -> jstring {\n"
#~ "    let input: String = env.get_string(name).unwrap().into();\n"
#~ "    let greeting = format!(\"Hello, {input}!\");\n"
#~ "    let output = env.new_string(greeting).unwrap();\n"
#~ "    output.into_inner()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_ffi_shared {\n"
#~ "    name: \"libhello_jni\",\n"
#~ "    crate_name: \"hello_jni\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    rustlibs: [\"libjni\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_ffi_shared {\n"
#~ "    name: \"libhello_jni\",\n"
#~ "    crate_name: \"hello_jni\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    rustlibs: [\"libjni\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);\n"
#~ "\n"
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        String output = HelloWorld.hello(\"Alice\");\n"
#~ "        System.out.println(output);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);\n"
#~ "\n"
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        String output = HelloWorld.hello(\"Alice\");\n"
#~ "        System.out.println(output);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "java_binary {\n"
#~ "    name: \"helloworld_jni\",\n"
#~ "    srcs: [\"HelloWorld.java\"],\n"
#~ "    main_class: \"HelloWorld\",\n"
#~ "    required: [\"libhello_jni\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "java_binary {\n"
#~ "    name: \"helloworld_jni\",\n"
#~ "    srcs: [\"HelloWorld.java\"],\n"
#~ "    main_class: \"HelloWorld\",\n"
#~ "    required: [\"libhello_jni\"],\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "m helloworld_jni\n"
#~ "adb sync  # requires adb root && adb remount\n"
#~ "adb shell /system/bin/helloworld_jni\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ m helloworld_jni\n"
#~ "$ adb sync  # requires adb root && adb remount\n"
#~ "$ adb shell /system/bin/helloworld_jni\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom "
#~ "pkg-config qemu-system-arm\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom "
#~ "pkg-config qemu-system-arm\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
#~ "GROUP=\"plugdev\"' |\\\n"
#~ "  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
#~ "sudo udevadm control --reload-rules\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
#~ "GROUP=\"plugdev\"' |\\\n"
#~ "  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
#~ "sudo udevadm control --reload-rules\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "xcode-select --install\n"
#~ "brew install gdb picocom qemu\n"
#~ "brew install --cask gcc-aarch64-embedded\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "xcode-select --install\n"
#~ "brew install gdb picocom qemu\n"
#~ "brew install --cask gcc-aarch64-embedded\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "#[panic_handler]\n"
#~ "fn panic(_panic: &PanicInfo) -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "#[panic_handler]\n"
#~ "fn panic(_panic: &PanicInfo) -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate alloc;\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use alloc::string::ToString;\n"
#~ "use alloc::vec::Vec;\n"
#~ "use buddy_system_allocator::LockedHeap;\n"
#~ "\n"
#~ "#[global_allocator]\n"
#~ "static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
#~ "\n"
#~ "static mut HEAP: [u8; 65536] = [0; 65536];\n"
#~ "\n"
#~ "pub fn entry() {\n"
#~ "    // Safe because `HEAP` is only used here and `entry` is only called "
#~ "once.\n"
#~ "    unsafe {\n"
#~ "        // Give the allocator some memory to allocate.\n"
#~ "        HEAP_ALLOCATOR\n"
#~ "            .lock()\n"
#~ "            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    // Now we can do things that require heap allocation.\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push(\"A string\".to_string());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate alloc;\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use alloc::string::ToString;\n"
#~ "use alloc::vec::Vec;\n"
#~ "use buddy_system_allocator::LockedHeap;\n"
#~ "\n"
#~ "#[global_allocator]\n"
#~ "static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
#~ "\n"
#~ "static mut HEAP: [u8; 65536] = [0; 65536];\n"
#~ "\n"
#~ "pub fn entry() {\n"
#~ "    // Safe because `HEAP` is only used here and `entry` is only called "
#~ "once.\n"
#~ "    unsafe {\n"
#~ "        // Give the allocator some memory to allocate.\n"
#~ "        HEAP_ALLOCATOR\n"
#~ "            .lock()\n"
#~ "            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    // 이제 힙 할당이 필요한 작업을 실행할 수 있습니다.\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push(\"A string\".to_string());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use core::mem::size_of;\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "/// GPIO port 0 peripheral address\n"
#~ "const GPIO_P0: usize = 0x5000_0000;\n"
#~ "\n"
#~ "// GPIO peripheral offsets\n"
#~ "const PIN_CNF: usize = 0x700;\n"
#~ "const OUTSET: usize = 0x508;\n"
#~ "const OUTCLR: usize = 0x50c;\n"
#~ "\n"
#~ "// PIN_CNF fields\n"
#~ "const DIR_OUTPUT: u32 = 0x1;\n"
#~ "const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
#~ "const PULL_DISABLED: u32 = 0x0 << 2;\n"
#~ "const DRIVE_S0S1: u32 = 0x0 << 8;\n"
#~ "const SENSE_DISABLED: u32 = 0x0 << 16;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    // Safe because the pointers are to valid peripheral control "
#~ "registers, and\n"
#~ "    // no aliases exist.\n"
#~ "    unsafe {\n"
#~ "        pin_cnf_21.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "        pin_cnf_28.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
#~ "    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
#~ "    // Safe because the pointers are to valid peripheral control "
#~ "registers, and\n"
#~ "    // no aliases exist.\n"
#~ "    unsafe {\n"
#~ "        gpio0_outclr.write_volatile(1 << 28);\n"
#~ "        gpio0_outset.write_volatile(1 << 21);\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use core::mem::size_of;\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "/// GPIO 포트 0 주변기기 주소입니다.\n"
#~ "const GPIO_P0: usize = 0x5000_0000;\n"
#~ "\n"
#~ "// GPIO 주변기기 오프셋입니다.\n"
#~ "const PIN_CNF: usize = 0x700;\n"
#~ "const OUTSET: usize = 0x508;\n"
#~ "const OUTCLR: usize = 0x50c;\n"
#~ "\n"
#~ "// PIN_CNF 필드입니다.\n"
#~ "const DIR_OUTPUT: u32 = 0x1;\n"
#~ "const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
#~ "const PULL_DISABLED: u32 = 0x0 << 2;\n"
#~ "const DRIVE_S0S1: u32 = 0x0 << 8;\n"
#~ "const SENSE_DISABLED: u32 = 0x0 << 16;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    // Safe because the pointers are to valid peripheral control "
#~ "registers, and\n"
#~ "    // no aliases exist.\n"
#~ "    unsafe {\n"
#~ "        pin_cnf_21.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "        pin_cnf_28.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    // 핀 28을 low로, 핀 21을 high로 설정하여 LED을 켭니다.\n"
#~ "    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
#~ "    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
#~ "    // 포인터가 유효한 주변기기 컨트롤 레지스터에 관한 것이므로 안전하고\n"
#~ "    // 별칭이 없습니다.\n"
#~ "    unsafe {\n"
#~ "        gpio0_outclr.write_volatile(1 << 28);\n"
#~ "        gpio0_outset.write_volatile(1 << 21);\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin mmio\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin mmio\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_pac::Peripherals;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p.P0;\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    gpio0.pin_cnf[21].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "    gpio0.pin_cnf[28].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    gpio0.outclr.write(|w| w.pin28().clear());\n"
#~ "    gpio0.outset.write(|w| w.pin21().set());\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_pac::Peripherals;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p.P0;\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    gpio0.pin_cnf[21].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "    gpio0.pin_cnf[28].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "\n"
#~ "    // 핀 28을 low로, 핀 21을 high로 설정하여 LED를 켭니다.\n"
#~ "    gpio0.outclr.write(|w| w.pin28().clear());\n"
#~ "    gpio0.outset.write(|w| w.pin21().set());\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_hal::gpio::{p0, Level};\n"
#~ "use nrf52833_hal::pac::Peripherals;\n"
#~ "use nrf52833_hal::prelude::*;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "\n"
#~ "    // Create HAL wrapper for GPIO port 0.\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
#~ "    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    col1.set_low().unwrap();\n"
#~ "    row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_hal::gpio::{p0, Level};\n"
#~ "use nrf52833_hal::pac::Peripherals;\n"
#~ "use nrf52833_hal::prelude::*;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "\n"
#~ "    // Create HAL wrapper for GPIO port 0.\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
#~ "    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    col1.set_low().unwrap();\n"
#~ "    row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin hal\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin hal\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use microbit::hal::prelude::*;\n"
#~ "use microbit::Board;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let mut board = Board::take().unwrap();\n"
#~ "\n"
#~ "    board.display_pins.col1.set_low().unwrap();\n"
#~ "    board.display_pins.row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use microbit::hal::prelude::*;\n"
#~ "use microbit::Board;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let mut board = Board::take().unwrap();\n"
#~ "\n"
#~ "    board.display_pins.col1.set_low().unwrap();\n"
#~ "    board.display_pins.row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin board_support\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin board_support\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
#~ "\n"
#~ "    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
#~ "    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
#~ "    if pin_input.is_high().unwrap() {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    pin_output.set_high().unwrap();\n"
#~ "    // pin_input.is_high(); // Error, moved.\n"
#~ "\n"
#~ "    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
#~ "        .p0_02\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
#~ "into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
#~ "\n"
#~ "    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
#~ "    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
#~ "    if pin_input.is_high().unwrap() {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    pin_output.set_high().unwrap();\n"
#~ "    // pin_input.is_high(); // 오류, 이동했습니다.\n"
#~ "\n"
#~ "    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
#~ "        .p0_02\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
#~ "into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid "SWD"
#~ msgstr "SWD"

#~ msgid "GDB stub and Microsoft "
#~ msgstr "GDB 스텁 및 Microsoft "

#~ msgid "DAP"
#~ msgstr "DAP"

#~ msgid " server"
#~ msgstr " 서버"

#~ msgid ""
#~ "`cargo-embed` is a cargo subcommand to build and flash binaries, log "
#~ msgstr ""
#~ "`cargo-embed`는 cargo의 서브 커맨트로써, 바이너리를 빌드하고 플래시하며, "

#~ msgid "RTT"
#~ msgstr "RTT"

#~ msgid ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin board_support debug\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin board_support debug\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
#~ "command=\"target remote :1337\"\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
#~ "command=\"target remote :1337\"\n"
#~ "```"

#~ msgid ""
#~ "```gdb\n"
#~ "b src/bin/board_support.rs:29\n"
#~ "b src/bin/board_support.rs:30\n"
#~ "b src/bin/board_support.rs:32\n"
#~ "c\n"
#~ "c\n"
#~ "c\n"
#~ "```"
#~ msgstr ""
#~ "```gdb\n"
#~ "b src/bin/board_support.rs:29\n"
#~ "b src/bin/board_support.rs:30\n"
#~ "b src/bin/board_support.rs:32\n"
#~ "c\n"
#~ "c\n"
#~ "c\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "\n"
#~ "[debug.reset]\n"
#~ "halt_afterwards = true\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "```"

#~ msgid "HVC"
#~ msgstr "HVC"

#~ msgid " to tell the firmware to power off the system:"
#~ msgstr "를 호출하는  방법은 다음과 같습니다."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::arch::asm;\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "mod exceptions;\n"
#~ "\n"
#~ "const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
#~ "\n"
#~ "#[no_mangle]\n"
#~ "extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
#~ "    // Safe because this only uses the declared registers and doesn't do\n"
#~ "    // anything with memory.\n"
#~ "    unsafe {\n"
#~ "        asm!(\"hvc #0\",\n"
#~ "            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
#~ "            inout(\"w1\") 0 => _,\n"
#~ "            inout(\"w2\") 0 => _,\n"
#~ "            inout(\"w3\") 0 => _,\n"
#~ "            inout(\"w4\") 0 => _,\n"
#~ "            inout(\"w5\") 0 => _,\n"
#~ "            inout(\"w6\") 0 => _,\n"
#~ "            inout(\"w7\") 0 => _,\n"
#~ "            options(nomem, nostack)\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::arch::asm;\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "mod exceptions;\n"
#~ "\n"
#~ "const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
#~ "\n"
#~ "#[no_mangle]\n"
#~ "extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
#~ "    // Safe because this only uses the declared registers and doesn't do\n"
#~ "    // anything with memory.\n"
#~ "    unsafe {\n"
#~ "        asm!(\"hvc #0\",\n"
#~ "            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
#~ "            inout(\"w1\") 0 => _,\n"
#~ "            inout(\"w2\") 0 => _,\n"
#~ "            inout(\"w3\") 0 => _,\n"
#~ "            inout(\"w4\") 0 => _,\n"
#~ "            inout(\"w5\") 0 => _,\n"
#~ "            inout(\"w6\") 0 => _,\n"
#~ "            inout(\"w7\") 0 => _,\n"
#~ "            options(nomem, nostack)\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
#~ "const FR_BUSY: u8 = 1 << 3;\n"
#~ "const FR_TXFF: u8 = 1 << 5;\n"
#~ "\n"
#~ "/// Minimal driver for a PL011 UART.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    base_address: *mut u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
#~ "        Self { base_address }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Writes a single byte to the UART.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register() & FR_TXFF != 0 {}\n"
#~ "\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            self.base_address.write_volatile(byte);\n"
#~ "        }\n"
#~ "\n"
#~ "        // Wait until the UART is no longer busy.\n"
#~ "        while self.read_flag_register() & FR_BUSY != 0 {}\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> u8 {\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
#~ "read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
#~ "const FR_BUSY: u8 = 1 << 3;\n"
#~ "const FR_TXFF: u8 = 1 << 5;\n"
#~ "\n"
#~ "/// PL011 UART용 최소 드라이버입니다.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    base_address: *mut u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
#~ "        Self { base_address }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// UART에 한 바이트를 씁니다.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register() & FR_TXFF != 0 {}\n"
#~ "\n"
#~ "        //  `base_address`가 PL011의 컨트롤 레지스터가 매핑된 주소를 가리"
#~ "키고\n"
#~ "        // 있으므로 안전합니다.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            self.base_address.write_volatile(byte);\n"
#~ "        }\n"
#~ "\n"
#~ "        // UART가 더 이상 사용 중이 아닐 때까지 기다립니다.\n"
#~ "        while self.read_flag_register() & FR_BUSY != 0 {}\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> u8 {\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
#~ "read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "/// Driver for a PL011 UART.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    registers: *mut Registers,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
#~ "        Self {\n"
#~ "            registers: base_address as *mut Registers,\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Writes a single byte to the UART.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register().contains(Flags::TXFF) {}\n"
#~ "\n"
#~ "        // Safe because we know that self.registers points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            addr_of_mut!((*self.registers).dr).write_volatile(byte."
#~ "into());\n"
#~ "        }\n"
#~ "\n"
#~ "        // Wait until the UART is no longer busy.\n"
#~ "        while self.read_flag_register().contains(Flags::BUSY) {}\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Reads and returns a pending byte, or `None` if nothing has been "
#~ "received.\n"
#~ "    pub fn read_byte(&self) -> Option<u8> {\n"
#~ "        if self.read_flag_register().contains(Flags::RXFE) {\n"
#~ "            None\n"
#~ "        } else {\n"
#~ "            let data = unsafe { addr_of!((*self.registers).dr)."
#~ "read_volatile() };\n"
#~ "            // TODO: Check for error conditions in bits 8-11.\n"
#~ "            Some(data as u8)\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> Flags {\n"
#~ "        // Safe because we know that self.registers points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
#~ "const FR_BUSY: u8 = 1 << 3;\n"
#~ "const FR_TXFF: u8 = 1 << 5;\n"
#~ "\n"
#~ "/// PL011 UART용 최소 드라이버입니다.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    base_address: *mut u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
#~ "        Self { base_address }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// UART에 한 바이트를 씁니다.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register() & FR_TXFF != 0 {}\n"
#~ "\n"
#~ "        //  `base_address`가 PL011의 컨트롤 레지스터가 매핑된 주소를 가리"
#~ "키고\n"
#~ "        // 있으므로 안전합니다.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            self.base_address.write_volatile(byte);\n"
#~ "        }\n"
#~ "\n"
#~ "        // UART가 더 이상 사용 중이 아닐 때까지 기다립니다.\n"
#~ "        while self.read_flag_register() & FR_BUSY != 0 {}\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> u8 {\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
#~ "read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// Initialises UART logger.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// UART 로거를 초기화합니다.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use zerocopy::AsBytes;\n"
#~ "\n"
#~ "#[repr(u32)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "enum RequestType {\n"
#~ "    #[default]\n"
#~ "    In = 0,\n"
#~ "    Out = 1,\n"
#~ "    Flush = 4,\n"
#~ "}\n"
#~ "\n"
#~ "#[repr(C)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "struct VirtioBlockRequest {\n"
#~ "    request_type: RequestType,\n"
#~ "    reserved: u32,\n"
#~ "    sector: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let request = VirtioBlockRequest {\n"
#~ "        request_type: RequestType::Flush,\n"
#~ "        sector: 42,\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "\n"
#~ "    assert_eq!(\n"
#~ "        request.as_bytes(),\n"
#~ "        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use zerocopy::AsBytes;\n"
#~ "\n"
#~ "#[repr(u32)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "enum RequestType {\n"
#~ "    #[default]\n"
#~ "    In = 0,\n"
#~ "    Out = 1,\n"
#~ "    Flush = 4,\n"
#~ "}\n"
#~ "\n"
#~ "#[repr(C)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "struct VirtioBlockRequest {\n"
#~ "    request_type: RequestType,\n"
#~ "    reserved: u32,\n"
#~ "    sector: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let request = VirtioBlockRequest {\n"
#~ "        request_type: RequestType::Flush,\n"
#~ "        sector: 42,\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "\n"
#~ "    assert_eq!(\n"
#~ "        request.as_bytes(),\n"
#~ "        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use aarch64_paging::{\n"
#~ "    idmap::IdMap,\n"
#~ "    paging::{Attributes, MemoryRegion},\n"
#~ "};\n"
#~ "\n"
#~ "const ASID: usize = 1;\n"
#~ "const ROOT_LEVEL: usize = 1;\n"
#~ "\n"
#~ "// Create a new page table with identity mapping.\n"
#~ "let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
#~ "// Map a 2 MiB region of memory as read-only.\n"
#~ "idmap.map_range(\n"
#~ "    &MemoryRegion::new(0x80200000, 0x80400000),\n"
#~ "    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
#~ ").unwrap();\n"
#~ "// Set `TTBR0_EL1` to activate the page table.\n"
#~ "idmap.activate();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use aarch64_paging::{\n"
#~ "    idmap::IdMap,\n"
#~ "    paging::{Attributes, MemoryRegion},\n"
#~ "};\n"
#~ "\n"
#~ "const ASID: usize = 1;\n"
#~ "const ROOT_LEVEL: usize = 1;\n"
#~ "\n"
#~ "// 상동(identity) 매핑으로 새로운 페이지 테이블을 만듭니다.\n"
#~ "let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
#~ "// 2MiB 메모리 영역을 읽기 전용으로 매핑합니다.\n"
#~ "idmap.map_range(\n"
#~ "    &MemoryRegion::new(0x80200000, 0x80400000),\n"
#~ "    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
#~ ").unwrap();\n"
#~ "// 페이지 테이블을 활성화하도록 `TTBR0_EL1`을 설정합니다.\n"
#~ "idmap.activate();\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use buddy_system_allocator::FrameAllocator;\n"
#~ "use core::alloc::Layout;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut allocator = FrameAllocator::<32>::new();\n"
#~ "    allocator.add_frame(0x200_0000, 0x400_0000);\n"
#~ "\n"
#~ "    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
#~ "    let bar = allocator\n"
#~ "        .alloc_aligned(layout)\n"
#~ "        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
#~ "    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use buddy_system_allocator::FrameAllocator;\n"
#~ "use core::alloc::Layout;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut allocator = FrameAllocator::<32>::new();\n"
#~ "    allocator.add_frame(0x200_0000, 0x400_0000);\n"
#~ "\n"
#~ "    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
#~ "    let bar = allocator\n"
#~ "        .alloc_aligned(layout)\n"
#~ "        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
#~ "    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tinyvec::{array_vec, ArrayVec};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.push(7);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.remove(1);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tinyvec::{array_vec, ArrayVec};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.push(7);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.remove(1);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "    *counter.lock() += 2;\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "    *counter.lock() += 2;\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```soong\n"
#~ "rust_ffi_static {\n"
#~ "    name: \"libvmbase_example\",\n"
#~ "    defaults: [\"vmbase_ffi_defaults\"],\n"
#~ "    crate_name: \"vmbase_example\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libvmbase\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "cc_binary {\n"
#~ "    name: \"vmbase_example\",\n"
#~ "    defaults: [\"vmbase_elf_defaults\"],\n"
#~ "    srcs: [\n"
#~ "        \"idmap.S\",\n"
#~ "    ],\n"
#~ "    static_libs: [\n"
#~ "        \"libvmbase_example\",\n"
#~ "    ],\n"
#~ "    linker_scripts: [\n"
#~ "        \"image.ld\",\n"
#~ "        \":vmbase_sections\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "raw_binary {\n"
#~ "    name: \"vmbase_example_bin\",\n"
#~ "    stem: \"vmbase_example.bin\",\n"
#~ "    src: \":vmbase_example\",\n"
#~ "    enabled: false,\n"
#~ "    target: {\n"
#~ "        android_arm64: {\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```soong\n"
#~ "rust_ffi_static {\n"
#~ "    name: \"libvmbase_example\",\n"
#~ "    defaults: [\"vmbase_ffi_defaults\"],\n"
#~ "    crate_name: \"vmbase_example\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libvmbase\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "cc_binary {\n"
#~ "    name: \"vmbase_example\",\n"
#~ "    defaults: [\"vmbase_elf_defaults\"],\n"
#~ "    srcs: [\n"
#~ "        \"idmap.S\",\n"
#~ "    ],\n"
#~ "    static_libs: [\n"
#~ "        \"libvmbase_example\",\n"
#~ "    ],\n"
#~ "    linker_scripts: [\n"
#~ "        \"image.ld\",\n"
#~ "        \":vmbase_sections\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "raw_binary {\n"
#~ "    name: \"vmbase_example_bin\",\n"
#~ "    stem: \"vmbase_example.bin\",\n"
#~ "    src: \":vmbase_example\",\n"
#~ "    enabled: false,\n"
#~ "    target: {\n"
#~ "        android_arm64: {\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use vmbase::{main, println};\n"
#~ "\n"
#~ "main!(main);\n"
#~ "\n"
#~ "pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
#~ "    println!(\"Hello world\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use vmbase::{main, println};\n"
#~ "\n"
#~ "main!(main);\n"
#~ "\n"
#~ "pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
#~ "    println!(\"Hello world\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "// Copyright 2023 Google LLC\n"
#~ "//\n"
#~ "// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
#~ "// you may not use this file except in compliance with the License.\n"
#~ "// You may obtain a copy of the License at\n"
#~ "//\n"
#~ "//      http://www.apache.org/licenses/LICENSE-2.0\n"
#~ "//\n"
#~ "// Unless required by applicable law or agreed to in writing, software\n"
#~ "// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
#~ "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or "
#~ "implied.\n"
#~ "// See the License for the specific language governing permissions and\n"
#~ "// limitations under the License.\n"
#~ "\n"
#~ "// ANCHOR: main\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// Initialises UART logger.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// UART 로거를 초기화합니다.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    thread::spawn(|| {\n"
#~ "        for i in 1..10 {\n"
#~ "            println!(\"Count in thread: {i}!\");\n"
#~ "            thread::sleep(Duration::from_millis(5));\n"
#~ "        }\n"
#~ "    });\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    thread::spawn(|| {\n"
#~ "        for i in 1..10 {\n"
#~ "            println!(\"Count in thread: {i}!\");\n"
#~ "            thread::sleep(Duration::from_millis(5));\n"
#~ "        }\n"
#~ "    });\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn foo() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::scope(|scope| {\n"
#~ "        scope.spawn(|| {\n"
#~ "            println!(\"Length: {}\", s.len());\n"
#~ "        });\n"
#~ "    });\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::scope(|scope| {\n"
#~ "        scope.spawn(|| {\n"
#~ "            println!(\"Length: {}\", s.len());\n"
#~ "        });\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    tx.send(10).unwrap();\n"
#~ "    tx.send(20).unwrap();\n"
#~ "\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "\n"
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    tx.send(10).unwrap();\n"
#~ "    tx.send(20).unwrap();\n"
#~ "\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "\n"
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(vec![10, 20, 30]);\n"
#~ "    let mut handles = Vec::new();\n"
#~ "    for _ in 1..5 {\n"
#~ "        let v = Arc::clone(&v);\n"
#~ "        handles.push(thread::spawn(move || {\n"
#~ "            let thread_id = thread::current().id();\n"
#~ "            println!(\"{thread_id:?}: {v:?}\");\n"
#~ "        }));\n"
#~ "    }\n"
#~ "\n"
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(vec![10, 20, 30]);\n"
#~ "    let mut handles = Vec::new();\n"
#~ "    for _ in 1..5 {\n"
#~ "        let v = Arc::clone(&v);\n"
#~ "        handles.push(thread::spawn(move || {\n"
#~ "            let thread_id = thread::current().id();\n"
#~ "            println!(\"{thread_id:?}: {v:?}\");\n"
#~ "        }));\n"
#~ "    }\n"
#~ "\n"
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "// use std::sync::{Arc, Mutex};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let handle = thread::spawn(|| {\n"
#~ "        v.push(10);\n"
#~ "    });\n"
#~ "    v.push(1000);\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo new link-checker\n"
#~ "cd link-checker\n"
#~ "cargo add --features blocking,rustls-tls reqwest\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "cargo init concurrency\n"
#~ "cd concurrency\n"
#~ "cargo add tokio --features full\n"
#~ "cargo run\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo add scraper\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo add thiserror\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin mmio\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo run\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::executor::block_on;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count is: {i}!\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn async_main(count: i32) {\n"
#~ "    count_to(count).await;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    block_on(async_main(10));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::executor::block_on;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count is: {i}!\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn async_main(count: i32) {\n"
#~ "    count_to(count).await;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    block_on(async_main(10));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::pin::Pin;\n"
#~ "use std::task::Context;\n"
#~ "\n"
#~ "pub trait Future {\n"
#~ "    type Output;\n"
#~ "    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
#~ "Output>;\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Poll<T> {\n"
#~ "    Ready(T),\n"
#~ "    Pending,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::pin::Pin;\n"
#~ "use std::task::Context;\n"
#~ "\n"
#~ "pub trait Future {\n"
#~ "    type Output;\n"
#~ "    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
#~ "Output>;\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Poll<T> {\n"
#~ "    Ready(T),\n"
#~ "    Pending,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::time;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count in task: {i}!\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    tokio::spawn(count_to(10));\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main task: {i}\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::time;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count in task: {i}!\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    tokio::spawn(count_to(10));\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main task: {i}\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
#~ "use tokio::net::TcpListener;\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() -> io::Result<()> {\n"
#~ "    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
#~ "\tprintln!(\"listening on port 6142\");\n"
#~ "\n"
#~ "    loop {\n"
#~ "        let (mut socket, addr) = listener.accept().await?;\n"
#~ "\n"
#~ "        println!(\"connection from {addr:?}\");\n"
#~ "\n"
#~ "        tokio::spawn(async move {\n"
#~ "            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await "
#~ "{\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "                return;\n"
#~ "            }\n"
#~ "\n"
#~ "            let mut buf = vec![0; 1024];\n"
#~ "            let reply = match socket.read(&mut buf).await {\n"
#~ "                Ok(n) => {\n"
#~ "                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
#~ "trim();\n"
#~ "                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
#~ "                }\n"
#~ "                Err(e) => {\n"
#~ "                    println!(\"socket error: {e:?}\");\n"
#~ "                    return;\n"
#~ "                }\n"
#~ "            };\n"
#~ "\n"
#~ "            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "            }\n"
#~ "        });\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
#~ "use tokio::net::TcpListener;\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() -> io::Result<()> {\n"
#~ "    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
#~ "\tprintln!(\"listening on port 6142\");\n"
#~ "\n"
#~ "    loop {\n"
#~ "        let (mut socket, addr) = listener.accept().await?;\n"
#~ "\n"
#~ "        println!(\"connection from {addr:?}\");\n"
#~ "\n"
#~ "        tokio::spawn(async move {\n"
#~ "            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await "
#~ "{\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "                return;\n"
#~ "            }\n"
#~ "\n"
#~ "            let mut buf = vec![0; 1024];\n"
#~ "            let reply = match socket.read(&mut buf).await {\n"
#~ "                Ok(n) => {\n"
#~ "                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
#~ "trim();\n"
#~ "                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
#~ "                }\n"
#~ "                Err(e) => {\n"
#~ "                    println!(\"socket error: {e:?}\");\n"
#~ "                    return;\n"
#~ "                }\n"
#~ "            };\n"
#~ "\n"
#~ "            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "            }\n"
#~ "        });\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "\n"
#~ "async fn ping_handler(mut input: Receiver<()>) {\n"
#~ "    let mut count: usize = 0;\n"
#~ "\n"
#~ "    while let Some(_) = input.recv().await {\n"
#~ "        count += 1;\n"
#~ "        println!(\"Received {count} pings so far.\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"ping_handler complete\");\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (sender, receiver) = mpsc::channel(32);\n"
#~ "    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
#~ "    for i in 0..10 {\n"
#~ "        sender.send(()).await.expect(\"Failed to send ping.\");\n"
#~ "        println!(\"Sent {} pings so far.\", i + 1);\n"
#~ "    }\n"
#~ "\n"
#~ "    drop(sender);\n"
#~ "    ping_handler_task.await.expect(\"Something went wrong in ping handler "
#~ "task.\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "\n"
#~ "async fn ping_handler(mut input: Receiver<()>) {\n"
#~ "    let mut count: usize = 0;\n"
#~ "\n"
#~ "    while let Some(_) = input.recv().await {\n"
#~ "        count += 1;\n"
#~ "        println!(\"Received {count} pings so far.\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"ping_handler complete\");\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (sender, receiver) = mpsc::channel(32);\n"
#~ "    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
#~ "    for i in 0..10 {\n"
#~ "        sender.send(()).await.expect(\"Failed to send ping.\");\n"
#~ "        println!(\"Sent {} pings so far.\", i + 1);\n"
#~ "    }\n"
#~ "\n"
#~ "    std::mem::drop(sender);\n"
#~ "    ping_handler_task.await.expect(\"Something went wrong in ping handler "
#~ "task.\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use anyhow::Result;\n"
#~ "use futures::future;\n"
#~ "use reqwest;\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "async fn size_of_page(url: &str) -> Result<usize> {\n"
#~ "    let resp = reqwest::get(url).await?;\n"
#~ "    Ok(resp.text().await?.len())\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let urls: [&str; 4] = [\n"
#~ "        \"https://google.com\",\n"
#~ "        \"https://httpbin.org/ip\",\n"
#~ "        \"https://play.rust-lang.org/\",\n"
#~ "        \"BAD_URL\",\n"
#~ "    ];\n"
#~ "    let futures_iter = urls.into_iter().map(size_of_page);\n"
#~ "    let results = future::join_all(futures_iter).await;\n"
#~ "    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
#~ "        urls.into_iter().zip(results.into_iter()).collect();\n"
#~ "    println!(\"{:?}\", page_sizes_dict);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use anyhow::Result;\n"
#~ "use futures::future;\n"
#~ "use reqwest;\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "async fn size_of_page(url: &str) -> Result<usize> {\n"
#~ "    let resp = reqwest::get(url).await?;\n"
#~ "    Ok(resp.text().await?.len())\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let urls: [&str; 4] = [\n"
#~ "        \"https://google.com\",\n"
#~ "        \"https://httpbin.org/ip\",\n"
#~ "        \"https://play.rust-lang.org/\",\n"
#~ "        \"BAD_URL\",\n"
#~ "    ];\n"
#~ "    let futures_iter = urls.into_iter().map(size_of_page);\n"
#~ "    let results = future::join_all(futures_iter).await;\n"
#~ "    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
#~ "        urls.into_iter().zip(results.into_iter()).collect();\n"
#~ "    println!(\"{:?}\", page_sizes_dict);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[derive(Debug, PartialEq)]\n"
#~ "enum Animal {\n"
#~ "    Cat { name: String },\n"
#~ "    Dog { name: String },\n"
#~ "}\n"
#~ "\n"
#~ "async fn first_animal_to_finish_race(\n"
#~ "    mut cat_rcv: Receiver<String>,\n"
#~ "    mut dog_rcv: Receiver<String>,\n"
#~ ") -> Option<Animal> {\n"
#~ "    tokio::select! {\n"
#~ "        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: "
#~ "cat_name? }),\n"
#~ "        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: "
#~ "dog_name? })\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
#~ "    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(500)).await;\n"
#~ "        cat_sender\n"
#~ "            .send(String::from(\"Felix\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send cat.\");\n"
#~ "    });\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(50)).await;\n"
#~ "        dog_sender\n"
#~ "            .send(String::from(\"Rex\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send dog.\");\n"
#~ "    });\n"
#~ "\n"
#~ "    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
#~ "        .await\n"
#~ "        .expect(\"Failed to receive winner\");\n"
#~ "\n"
#~ "    println!(\"Winner is {winner:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[derive(Debug, PartialEq)]\n"
#~ "enum Animal {\n"
#~ "    Cat { name: String },\n"
#~ "    Dog { name: String },\n"
#~ "}\n"
#~ "\n"
#~ "async fn first_animal_to_finish_race(\n"
#~ "    mut cat_rcv: Receiver<String>,\n"
#~ "    mut dog_rcv: Receiver<String>,\n"
#~ ") -> Option<Animal> {\n"
#~ "    tokio::select! {\n"
#~ "        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: "
#~ "cat_name? }),\n"
#~ "        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: "
#~ "dog_name? })\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
#~ "    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(500)).await;\n"
#~ "        cat_sender\n"
#~ "            .send(String::from(\"Felix\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send cat.\");\n"
#~ "    });\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(50)).await;\n"
#~ "        dog_sender\n"
#~ "            .send(String::from(\"Rex\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send dog.\");\n"
#~ "    });\n"
#~ "\n"
#~ "    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
#~ "        .await\n"
#~ "        .expect(\"Failed to receive winner\");\n"
#~ "\n"
#~ "    println!(\"Winner is {winner:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::future::join_all;\n"
#~ "use std::time::Instant;\n"
#~ "\n"
#~ "async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
#~ "    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
#~ "    println!(\n"
#~ "        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
#~ "        start.elapsed().as_millis()\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main(flavor = \"current_thread\")]\n"
#~ "async fn main() {\n"
#~ "    let start = Instant::now();\n"
#~ "    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
#~ "    join_all(sleep_futures).await;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::future::join_all;\n"
#~ "use std::time::Instant;\n"
#~ "\n"
#~ "async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
#~ "    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
#~ "    println!(\n"
#~ "        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
#~ "        start.elapsed().as_millis()\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main(flavor = \"current_thread\")]\n"
#~ "async fn main() {\n"
#~ "    let start = Instant::now();\n"
#~ "    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
#~ "    join_all(sleep_futures).await;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::{mpsc, oneshot};\n"
#~ "use tokio::task::spawn;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "// A work item. In this case, just sleep for the given time and respond\n"
#~ "// with a message on the `respond_on` channel.\n"
#~ "#[derive(Debug)]\n"
#~ "struct Work {\n"
#~ "    input: u32,\n"
#~ "    respond_on: oneshot::Sender<u32>,\n"
#~ "}\n"
#~ "\n"
#~ "// A worker which listens for work on a queue and performs it.\n"
#~ "async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
#~ "    let mut iterations = 0;\n"
#~ "    loop {\n"
#~ "        tokio::select! {\n"
#~ "            Some(work) = work_queue.recv() => {\n"
#~ "                sleep(Duration::from_millis(10)).await; // Pretend to "
#~ "work.\n"
#~ "                work.respond_on\n"
#~ "                    .send(work.input * 1000)\n"
#~ "                    .expect(\"failed to send response\");\n"
#~ "                iterations += 1;\n"
#~ "            }\n"
#~ "            // TODO: report number of iterations every 100ms\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// A requester which requests work and waits for it to complete.\n"
#~ "async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
#~ "    let (tx, rx) = oneshot::channel();\n"
#~ "    work_queue\n"
#~ "        .send(Work {\n"
#~ "            input,\n"
#~ "            respond_on: tx,\n"
#~ "        })\n"
#~ "        .await\n"
#~ "        .expect(\"failed to send on work queue\");\n"
#~ "    rx.await.expect(\"failed waiting for response\")\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel(10);\n"
#~ "    spawn(worker(rx));\n"
#~ "    for i in 0..100 {\n"
#~ "        let resp = do_work(&tx, i).await;\n"
#~ "        println!(\"work result for iteration {i}: {resp}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::{mpsc, oneshot};\n"
#~ "use tokio::task::spawn;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "// 작업 항목. 이 경우 지정된 시간 동안 절전 모드로 있다가\n"
#~ "// `respond_on` 채널의 메시지로 응답합니다.\n"
#~ "#[derive(Debug)]\n"
#~ "struct Work {\n"
#~ "    input: u32,\n"
#~ "    respond_on: oneshot::Sender<u32>,\n"
#~ "}\n"
#~ "\n"
#~ "// 대기열에서 작업을 리슨하고 실행하는 worker입니다.\n"
#~ "async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
#~ "    let mut iterations = 0;\n"
#~ "    loop {\n"
#~ "        tokio::select! {\n"
#~ "            Some(work) = work_queue.recv() => {\n"
#~ "                sleep(Duration::from_millis(10)).await; // Pretend to "
#~ "work.\n"
#~ "                work.respond_on\n"
#~ "                    .send(work.input * 1000)\n"
#~ "                    .expect(\"failed to send response\");\n"
#~ "                iterations += 1;\n"
#~ "            }\n"
#~ "            // TODO: 100ms마다 반복 횟수를 보고합니다.\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// 작업을 요청하고 작업이 완료될 때까지 기다리는 요청자입니다.\n"
#~ "async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
#~ "    let (tx, rx) = oneshot::channel();\n"
#~ "    work_queue\n"
#~ "        .send(Work {\n"
#~ "            input,\n"
#~ "            respond_on: tx,\n"
#~ "        })\n"
#~ "        .await\n"
#~ "        .expect(\"failed to send on work queue\");\n"
#~ "    rx.await.expect(\"failed waiting for response\")\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel(10);\n"
#~ "    spawn(worker(rx));\n"
#~ "    for i in 0..100 {\n"
#~ "        let resp = do_work(&tx, i).await;\n"
#~ "        println!(\"work result for iteration {i}: {resp}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = sleep(Duration::from_millis(100));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = sleep(Duration::from_millis(100));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = &mut timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = &mut timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use async_trait::async_trait;\n"
#~ "use std::time::Instant;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "trait Sleeper {\n"
#~ "    async fn sleep(&self);\n"
#~ "}\n"
#~ "\n"
#~ "struct FixedSleeper {\n"
#~ "    sleep_ms: u64,\n"
#~ "}\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "impl Sleeper for FixedSleeper {\n"
#~ "    async fn sleep(&self) {\n"
#~ "        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
#~ "n_times: usize) {\n"
#~ "    for _ in 0..n_times {\n"
#~ "        println!(\"running all sleepers..\");\n"
#~ "        for sleeper in &sleepers {\n"
#~ "            let start = Instant::now();\n"
#~ "            sleeper.sleep().await;\n"
#~ "            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
#~ "    ];\n"
#~ "    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use async_trait::async_trait;\n"
#~ "use std::time::Instant;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "trait Sleeper {\n"
#~ "    async fn sleep(&self);\n"
#~ "}\n"
#~ "\n"
#~ "struct FixedSleeper {\n"
#~ "    sleep_ms: u64,\n"
#~ "}\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "impl Sleeper for FixedSleeper {\n"
#~ "    async fn sleep(&self) {\n"
#~ "        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
#~ "n_times: usize) {\n"
#~ "    for _ in 0..n_times {\n"
#~ "        println!(\"running all sleepers..\");\n"
#~ "        for sleeper in &sleepers {\n"
#~ "            let start = Instant::now();\n"
#~ "            sleeper.sleep().await;\n"
#~ "            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
#~ "    ];\n"
#~ "    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo run --bin server\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo run --bin client\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#~ msgid "You will find solutions to the exercises on the following pages."
#~ msgstr "연습문제의 해답은 다음 페이지에서 확인할 수 있습니다."

#~ msgid ""
#~ "Feel free to ask questions about the solutions [on GitHub](https://github."
#~ "com/google/comprehensive-rust/discussions). Let us know if you have a "
#~ "different or better solution than what is presented here."
#~ msgstr ""
#~ "[깃허브](https://github.com/google/comprehensive-rust/discussions)에서 이"
#~ "에 대해 자유롭게 질문하시고 더 나은 솔루션이 있다면 알려주시기 바랍니다."

#~ msgid ""
#~ "**Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label` "
#~ "comments you see in the solutions. They are there to make it possible to "
#~ "re-use parts of the solutions as the exercises."
#~ msgstr ""
#~ "**참고:** `// ANCHOR: label`과 `// ANCHOR_END: label` 주석은 문제를 구성하"
#~ "기 위한 메타 주석으로 무시하시면 됩니다."

#~ msgid "Day 1 Morning Exercises"
#~ msgstr "1일차 오전 연습문제"

#~ msgid "Bonus question"
#~ msgstr "보너스 문제"

#~ msgid ""
#~ "It requires more advanced concepts. It might seem that we could use a "
#~ "slice-of-slices (`&[&[i32]]`) as the input type to transpose and thus "
#~ "make our function handle any size of matrix. However, this quickly breaks "
#~ "down: the return type cannot be `&[&[i32]]` since it needs to own the "
#~ "data you return."
#~ msgstr ""
#~ "사실 이 문제는 고급 개념이 필요합니다. 슬라이스의 슬라이스(slice-of-"
#~ "slices, `&[&[i32]]`)를 입력 타입으로 사용하면 모든 크기의 행렬을 처리할 "
#~ "수 있을것 같습니다. 하지만 실제로 해보면 금방 안된다는 걸 알 수 있습니다. "
#~ "반환값을 소유해야 하기때문에 `&[&[i32]]` 반환 타입으로 사용할 수 없습니다."

#~ msgid ""
#~ "You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't "
#~ "work out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
#~ "`&[&[i32]]` so now you cannot easily use `pretty_print` either."
#~ msgstr ""
#~ "`Vec<Vec<i32>>`와 같은 타입을 사용하려고 시도할 수도 있지만 역시 쉽게 되"
#~ "진 않습니다. `Vec<Vec<i32>>` 타입을 `&[&[i32]]`로 변환하는 것이 어렵기 때"
#~ "문에 `pretty_print`을 사용하는데 어려움이 있습니다."

#~ msgid ""
#~ "Once we get to traits and generics, we'll be able to use the [`std::"
#~ "convert::AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) "
#~ "trait to abstract over anything that can be referenced as a slice."
#~ msgstr ""
#~ "트레잇나 제네릭을 다루고 나면 [`std::convert::AsRef`](https://doc.rust-"
#~ "lang.org/std/convert/trait.AsRef.html) 트레잇을 사용하여 슬라이스처럼 사용"
#~ "될 수 있는 타입을 추상화할 수 있습니다."

#~ msgid ""
#~ "In addition, the type itself would not enforce that the child slices are "
#~ "of the same length, so such variable could contain an invalid matrix."
#~ msgstr ""
#~ "또한, 슬라이스 타입은 길이를 포함하지 않기 때문에 한 단계 아래의 슬라이스"
#~ "들이 같은 길이임을 보장할 수 없습니다. 때문에 슬라이스 타입의 변수에는 잘"
#~ "못된 행렬이 전달될 수 있습니다."

#~ msgid "Day 1 Afternoon Exercises"
#~ msgstr "1일차 오후 연습문제"

#~ msgid "Designing a Library"
#~ msgstr "도서관 설계"

#~ msgid "Day 2 Morning Exercises"
#~ msgstr "2일차 오전 연습문제"

#~ msgid "Day 2 Afternoon Exercises"
#~ msgstr "2일차 오후 연습문제"

#~ msgid "Day 3 Morning Exercise"
#~ msgstr "3일차 오전 연습문제"

#~ msgid "Day 3 Afternoon Exercises"
#~ msgstr "3일차 오후 연습문제"
