msgid ""
msgstr ""
"Project-Id-Version: [í•œêµ­ì–´]Comprehensive Rust ğŸ¦€\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-02-27 18:16+0900\n"
"Last-Translator: keispace <keispace.kyj@google.com>\n"
"Language-Team: \n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: src/SUMMARY.md:3
msgid "Welcome to Comprehensive Rust ğŸ¦€"
msgstr "Comprehensive Rustì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤ ğŸ¦€"

#: src/SUMMARY.md:4
msgid "Running the Course"
msgstr "ê°•ì˜ ì§„í–‰"

#: src/SUMMARY.md:5
msgid "Course Structure"
msgstr "ê°•ì˜ êµ¬ì„±"

#: src/SUMMARY.md:6
msgid "Keyboard Shortcuts"
msgstr "ë‹¨ì¶•í‚¤"

#: src/SUMMARY.md:7
msgid "Translations"
msgstr "ë‹¤ë¥¸ ì–¸ì–´ë“¤"

#: src/SUMMARY.md:8
msgid "Using Cargo"
msgstr "ì¹´ê³  ì‚¬ìš©í•˜ê¸°"

#: src/SUMMARY.md:9
msgid "Rust Ecosystem"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„"

#: src/SUMMARY.md:10
msgid "Code Samples"
msgstr "ì½”ë“œ ìƒ˜í”Œ"

#: src/SUMMARY.md:11
msgid "Running Cargo Locally"
msgstr "ì¹´ê³ (Cargo) ìˆ˜í–‰í•˜ê¸°"

#: src/SUMMARY.md:14
msgid "Day 1: Morning"
msgstr "1ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:18 src/SUMMARY.md:74 src/SUMMARY.md:127 src/SUMMARY.md:183
msgid "Welcome"
msgstr "ê°œìš”"

#: src/SUMMARY.md:19
msgid "What is Rust?"
msgstr "ëŸ¬ìŠ¤íŠ¸ë€?"

#: src/SUMMARY.md:20
msgid "Hello World!"
msgstr "Hello World!"

#: src/SUMMARY.md:21
msgid "Small Example"
msgstr "ì‘ì€ ì˜ˆì œ"

#: src/SUMMARY.md:22
msgid "Why Rust?"
msgstr "ëŸ¬ìŠ¤íŠ¸ë¥¼ ì¨ì•¼í•˜ëŠ” ì´ìœ "

#: src/SUMMARY.md:23
msgid "Compile Time Guarantees"
msgstr "ì»´íŒŒì¼ ì‹œ ë³´ì¥ë˜ëŠ” ê²ƒë“¤"

#: src/SUMMARY.md:24
msgid "Runtime Guarantees"
msgstr "ëŸ°íƒ€ì„ ì‹œ ë³´ì¥ë˜ëŠ” ê²ƒë“¤"

#: src/SUMMARY.md:25
msgid "Modern Features"
msgstr "í˜„ëŒ€ì ì¸ íŠ¹ì§•"

#: src/SUMMARY.md:26
msgid "Basic Syntax"
msgstr "ê¸°ë³¸ ë¬¸ë²•"

#: src/SUMMARY.md:27
msgid "Scalar Types"
msgstr "ìŠ¤ì¹¼ë¼ íƒ€ì…"

#: src/SUMMARY.md:28
msgid "Compound Types"
msgstr "ë³µí•© íƒ€ì…"

#: src/SUMMARY.md:29
msgid "References"
msgstr "ì°¸ì¡°"

#: src/SUMMARY.md:30
msgid "Dangling References"
msgstr "í—ˆìƒ(dangling) ì°¸ì¡°"

#: src/SUMMARY.md:31
msgid "Slices"
msgstr "ìŠ¬ë¼ì´ìŠ¤"

#: src/SUMMARY.md:32
msgid "String vs str"
msgstr "Stringê³¼ str"

#: src/SUMMARY.md:33
msgid "Functions"
msgstr "í•¨ìˆ˜"

#: src/SUMMARY.md:34 src/SUMMARY.md:81
msgid "Methods"
msgstr "ë©”ì„œë“œ"

#: src/SUMMARY.md:35
msgid "Overloading"
msgstr "ì˜¤ë²„ë¡œë”©"

#: src/SUMMARY.md:36 src/SUMMARY.md:65 src/SUMMARY.md:89 src/SUMMARY.md:118
#: src/SUMMARY.md:147 src/SUMMARY.md:175 src/SUMMARY.md:198 src/SUMMARY.md:225
msgid "Exercises"
msgstr "ì—°ìŠµë¬¸ì œ"

#: src/SUMMARY.md:37
msgid "Implicit Conversions"
msgstr "ë¬µì‹œì  í˜•ë³€í™˜"

#: src/SUMMARY.md:38
msgid "Arrays and for Loops"
msgstr "ë°°ì—´ê³¼ for ë°˜ë³µë¬¸"

#: src/SUMMARY.md:40
msgid "Day 1: Afternoon"
msgstr "1ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:42
msgid "Variables"
msgstr "ë³€ìˆ˜"

#: src/SUMMARY.md:43
msgid "Type Inference"
msgstr "íƒ€ì… ì¶”ë¡ "

#: src/SUMMARY.md:44
msgid "static & const"
msgstr "ì •ì ë³€ìˆ˜(static)ì™€ ìƒìˆ˜(const)"

#: src/SUMMARY.md:45
msgid "Scopes and Shadowing"
msgstr "ë²”ìœ„(Scopes)ì™€ ì‰ë„ì‰(Shadowing)"

#: src/SUMMARY.md:46
msgid "Memory Management"
msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/SUMMARY.md:47
msgid "Stack vs Heap"
msgstr "ìŠ¤íƒ(Stack)ê³¼ í™(Heap)"

#: src/SUMMARY.md:48
msgid "Stack Memory"
msgstr "ìŠ¤íƒ ë©”ëª¨ë¦¬"

#: src/SUMMARY.md:49
msgid "Manual Memory Management"
msgstr "ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/SUMMARY.md:50
msgid "Scope-Based Memory Management"
msgstr "ë²”ìœ„ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/SUMMARY.md:51
msgid "Garbage Collection"
msgstr "ê°€ë¹„ì§€ ì»¬ë ‰ì…˜"

#: src/SUMMARY.md:52
msgid "Rust Memory Management"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/SUMMARY.md:53
msgid "Comparison"
msgstr "ë¹„êµ"

#: src/SUMMARY.md:54
msgid "Ownership"
msgstr "ì†Œìœ ê¶Œ"

#: src/SUMMARY.md:55
msgid "Move Semantics"
msgstr "Move ë¬¸ë²•"

#: src/SUMMARY.md:56
msgid "Moved Strings in Rust"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œì˜ ë¬¸ìì—´ ì´ë™"

#: src/SUMMARY.md:57
msgid "Double Frees in Modern C++"
msgstr "Modern C++ì—ì„œ ì´ì¤‘í•´ì œ ë¬¸ì œ"

#: src/SUMMARY.md:58
msgid "Moves in Function Calls"
msgstr "í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ì´ë™(Move)"

#: src/SUMMARY.md:59
msgid "Copying and Cloning"
msgstr "ë³µì‚¬ì™€ ë³µì œ"

#: src/SUMMARY.md:60
msgid "Borrowing"
msgstr "ë¹Œë¦¼"

#: src/SUMMARY.md:61
msgid "Shared and Unique Borrows"
msgstr "ê³µìœ ì™€ ê³ ìœ  ë¹Œë¦¼"

#: src/SUMMARY.md:62
msgid "Lifetimes"
msgstr "ìˆ˜ëª…"

#: src/SUMMARY.md:63
msgid "Lifetimes in Function Calls"
msgstr "í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ìˆ˜ëª…"

#: src/SUMMARY.md:64
msgid "Lifetimes in Data Structures"
msgstr "êµ¬ì¡°ì²´ì—ì„œì˜ ìˆ˜ëª…"

#: src/SUMMARY.md:66
msgid "Designing a Library"
msgstr "ë„ì„œê´€ ì„¤ê³„"

#: src/SUMMARY.md:67
msgid "Iterators and Ownership"
msgstr "ë°˜ë³µìì™€ ì†Œìœ ê¶Œ"

#: src/SUMMARY.md:70
msgid "Day 2: Morning"
msgstr "2ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:75
msgid "Structs"
msgstr "êµ¬ì¡°ì²´"

#: src/SUMMARY.md:76
msgid "Tuple Structs"
msgstr "íŠœí”Œ"

#: src/SUMMARY.md:77
msgid "Field Shorthand Syntax"
msgstr "í•„ë“œ í• ë‹¹ ë‹¨ì¶• ë¬¸ë²•"

#: src/SUMMARY.md:78
msgid "Enums"
msgstr "ì—´ê±°í˜•"

#: src/SUMMARY.md:79
msgid "Variant Payloads"
msgstr "ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ì—´ê±°í˜•(Variant Payloads)"

#: src/SUMMARY.md:80
msgid "Enum Sizes"
msgstr "ì—´ê±°í˜•ì˜ í¬ê¸°"

#: src/SUMMARY.md:82
msgid "Method Receiver"
msgstr "ë©”ì„œë“œ ë¦¬ì‹œë²„(Receiver)"

#: src/SUMMARY.md:83 src/SUMMARY.md:158 src/SUMMARY.md:193
msgid "Example"
msgstr "ì˜ˆì œ"

#: src/SUMMARY.md:84
msgid "Pattern Matching"
msgstr "íŒ¨í„´ ë§¤ì¹­"

#: src/SUMMARY.md:85
msgid "Destructuring Enums"
msgstr "ì—´ê±°í˜• ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/SUMMARY.md:86
msgid "Destructuring Structs"
msgstr "êµ¬ì¡°ì²´ ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/SUMMARY.md:87
msgid "Destructuring Arrays"
msgstr "ë°°ì—´ ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/SUMMARY.md:88
msgid "Match Guards"
msgstr "ë§¤ì¹˜ ê°€ë“œ"

#: src/SUMMARY.md:90
msgid "Health Statistics"
msgstr "ê±´ê°•ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"

#: src/SUMMARY.md:91
msgid "Points and Polygons"
msgstr "ì ê³¼ ë‹¤ê°í˜•"

#: src/SUMMARY.md:93
msgid "Day 2: Afternoon"
msgstr "2ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:95
msgid "Control Flow"
msgstr "íë¦„ ì œì–´"

#: src/SUMMARY.md:96
msgid "Blocks"
msgstr "ë¸”ë¡"

#: src/SUMMARY.md:97
msgid "if expressions"
msgstr "if í‘œí˜„ì‹"

#: src/SUMMARY.md:98
msgid "if let expressions"
msgstr "if let í‘œí˜„ì‹"

#: src/SUMMARY.md:99
msgid "while expressions"
msgstr "while í‘œí˜„ì‹"

#: src/SUMMARY.md:100
msgid "while let expressions"
msgstr "while let í‘œí˜„ì‹"

#: src/SUMMARY.md:101
msgid "for expressions"
msgstr "for í‘œí˜„ì‹"

#: src/SUMMARY.md:102
msgid "loop expressions"
msgstr "loop í‘œí˜„ì‹"

#: src/SUMMARY.md:103
msgid "match expressions"
msgstr "match í‘œí˜„ì‹"

#: src/SUMMARY.md:104
msgid "break & continue"
msgstr "breakì™€ continue"

#: src/SUMMARY.md:105
msgid "Standard Library"
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:106
msgid "Option and Result"
msgstr "Optionê³¼ Result"

#: src/SUMMARY.md:107
msgid "String"
msgstr "String"

#: src/SUMMARY.md:108
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:109
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:110
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:111
msgid "Recursive Data Types"
msgstr "ì¬ê·€ì  ìë£Œêµ¬ì¡°"

#: src/SUMMARY.md:112
msgid "Niche Optimization"
msgstr "ë‹ˆì¹˜(í‹ˆìƒˆ) ìµœì í™”(Niche Optimization)"

#: src/SUMMARY.md:113
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:114
msgid "Modules"
msgstr "ëª¨ë“ˆ"

#: src/SUMMARY.md:115
msgid "Visibility"
msgstr "ê°€ì‹œì„±"

#: src/SUMMARY.md:116
msgid "Paths"
msgstr "ê²½ë¡œ"

#: src/SUMMARY.md:117
msgid "Filesystem Hierarchy"
msgstr "íŒŒì¼ì‹œìŠ¤í…œ ê³„ì¸µ"

#: src/SUMMARY.md:119
msgid "Luhn Algorithm"
msgstr "ë£¬ ì•Œê³ ë¦¬ì¦˜"

#: src/SUMMARY.md:120
msgid "Strings and Iterators"
msgstr "ë¬¸ìì—´ê³¼ ë°˜ë³µì"

#: src/SUMMARY.md:123
msgid "Day 3: Morning"
msgstr "3ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:128
msgid "Traits"
msgstr "íŠ¸ë ˆì‡(Trait)"

#: src/SUMMARY.md:129
msgid "Deriving Traits"
msgstr "íŠ¸ë ˆì‡ ìƒì†í•˜ê¸°"

#: src/SUMMARY.md:130
msgid "Default Methods"
msgstr "ê¸°ë³¸ ë©”ì„œë“œ"

#: src/SUMMARY.md:131
msgid "Important Traits"
msgstr "ì¤‘ìš”í•œ íŠ¸ë ˆì‡"

#: src/SUMMARY.md:132
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:133
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:134
msgid "From and Into"
msgstr "Fromê³¼ Into"

#: src/SUMMARY.md:135
msgid "Read and Write"
msgstr "Readì™€ Write"

#: src/SUMMARY.md:136
msgid "Add, Mul, ..."
msgstr "Add, Mul, ..."

#: src/SUMMARY.md:137
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:138
msgid "Default"
msgstr "Default"

#: src/SUMMARY.md:139
msgid "Generics"
msgstr "ì œë„¤ë¦­"

#: src/SUMMARY.md:140
msgid "Generic Data Types"
msgstr "ì œë„¤ë¦­ ë°ì´í„° íƒ€ì…"

#: src/SUMMARY.md:141
msgid "Generic Methods"
msgstr "ì œë„¤ë¦­ ë©”ì„œë“œ"

#: src/SUMMARY.md:142
msgid "Trait Bounds"
msgstr "ì œë„¤ë¦­ íƒ€ì… ì œí•œ(íŠ¸ë ˆì‡ ê²½ê³„)"

#: src/SUMMARY.md:143
msgid "impl Trait"
msgstr "íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°"

#: src/SUMMARY.md:144
msgid "Closures"
msgstr "í´ë¡œì €"

#: src/SUMMARY.md:145
msgid "Monomorphization"
msgstr "ë‹¨í˜•í™”"

#: src/SUMMARY.md:146
msgid "Trait Objects"
msgstr "íŠ¸ë ˆì‡ ê°ì²´"

#: src/SUMMARY.md:148
msgid "A Simple GUI Library"
msgstr "ê°„ë‹¨í•œ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:150
msgid "Day 3: Afternoon"
msgstr "3ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:152
msgid "Error Handling"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:153
msgid "Panics"
msgstr "íŒ¨ë‹‰"

#: src/SUMMARY.md:154
msgid "Catching Stack Unwinding"
msgstr "ìŠ¤íƒ ë˜ê°ê¸°"

#: src/SUMMARY.md:155
msgid "Structured Error Handling"
msgstr "êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:156
msgid "Propagating Errors with ?"
msgstr "'?'ë¥¼ ì´ìš©í•œ ì˜¤ë¥˜ ì „íŒŒ"

#: src/SUMMARY.md:157
msgid "Converting Error Types"
msgstr "ì˜¤ë¥˜íƒ€ì… ë³€í™˜"

#: src/SUMMARY.md:159
msgid "Deriving Error Enums"
msgstr "ë˜ë‹¤ë¥¸ ì˜¤ë¥˜ ì—´ê±°í˜•"

#: src/SUMMARY.md:160
msgid "Dynamic Error Types"
msgstr "ë™ì ì¸ ì—ëŸ¬ íƒ€ì…"

#: src/SUMMARY.md:161
msgid "Adding Context to Errors"
msgstr "ì˜¤ë¥˜ì— ìƒí™©ì •ë³´ ì¶”ê°€"

#: src/SUMMARY.md:162
msgid "Testing"
msgstr "í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:163
msgid "Unit Tests"
msgstr "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:164
msgid "Test Modules"
msgstr "í…ŒìŠ¤íŠ¸ ëª¨ë“ˆ"

#: src/SUMMARY.md:165
msgid "Documentation Tests"
msgstr "ë¬¸ì„œí™”ì£¼ì„ í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:166
msgid "Integration Tests"
msgstr "í†µí•© í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:167
msgid "Unsafe Rust"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸"

#: src/SUMMARY.md:168
msgid "Dereferencing Raw Pointers"
msgstr "ì›ì‹œ í¬ì¸í„° ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)"

#: src/SUMMARY.md:169
msgid "Mutable Static Variables"
msgstr "ì •ì  ê°€ë³€ ë³€ìˆ˜"

#: src/SUMMARY.md:170
msgid "Unions"
msgstr "Unions"

#: src/SUMMARY.md:171
msgid "Calling Unsafe Functions"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ í˜¸ì¶œ"

#: src/SUMMARY.md:172
msgid "Writing Unsafe Functions"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ ì‘ì„±í•˜ê¸°"

#: src/SUMMARY.md:173
msgid "Extern Functions"
msgstr "ì™¸ë¶€(ë‹¤ë¥¸ì–¸ì–´) í•¨ìˆ˜ë“¤"

#: src/SUMMARY.md:174
msgid "Implementing Unsafe Traits"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°"

#: src/SUMMARY.md:176
msgid "Safe FFI Wrapper"
msgstr "FFIë˜í¼"

#: src/SUMMARY.md:179
msgid "Day 4: Morning"
msgstr "4ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:184
msgid "Concurrency"
msgstr "ë™ì‹œì„±"

#: src/SUMMARY.md:185
msgid "Threads"
msgstr "ìŠ¤ë ˆë“œ"

#: src/SUMMARY.md:186
msgid "Scoped Threads"
msgstr "ë²”ìœ„ ìŠ¤ë ˆë“œ(Scoped Threads)"

#: src/SUMMARY.md:187
msgid "Channels"
msgstr "ì±„ë„"

#: src/SUMMARY.md:188
msgid "Unbounded Channels"
msgstr "ë¬´ê²½ê³„ ì±„ë„"

#: src/SUMMARY.md:189
msgid "Bounded Channels"
msgstr "ê²½ê³„ ì±„ë„"

#: src/SUMMARY.md:190
msgid "Shared State"
msgstr "ìƒíƒœ ê³µìœ "

#: src/SUMMARY.md:191
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:192
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:194
msgid "Send and Sync"
msgstr "Sendì™€ Sync"

#: src/SUMMARY.md:194
msgid "Send"
msgstr "Send"

#: src/SUMMARY.md:194
msgid "Sync"
msgstr "Sync"

#: src/SUMMARY.md:197
msgid "Examples"
msgstr "ì˜ˆì œ"

#: src/SUMMARY.md:199
msgid "Dining Philosophers"
msgstr "ì‹ì‚¬í•˜ëŠ” ì² í•™ìë“¤"

#: src/SUMMARY.md:200
msgid "Multi-threaded Link Checker"
msgstr "ë©€í‹°ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°"

#: src/SUMMARY.md:202
msgid "Day 4: Afternoon"
msgstr "4ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:206
msgid "Android"
msgstr "ì•ˆë“œë¡œì´ë“œ"

#: src/SUMMARY.md:207
msgid "Setup"
msgstr "ì„¤ì¹˜"

#: src/SUMMARY.md:208
msgid "Build Rules"
msgstr "ë¹Œë“œ ê·œì¹™"

#: src/SUMMARY.md:209
msgid "Binary"
msgstr "ë°”ì´ë„ˆë¦¬"

#: src/SUMMARY.md:210
msgid "Library"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:211
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:212
msgid "Interface"
msgstr "AIDL ì¸í„°í˜ì´ìŠ¤"

#: src/SUMMARY.md:213
msgid "Implementation"
msgstr "ì„œë¹„ìŠ¤ êµ¬í˜„"

#: src/SUMMARY.md:214
msgid "Server"
msgstr "AIDL ì„œë²„"

#: src/SUMMARY.md:215
msgid "Deploy"
msgstr "ë°°í¬"

#: src/SUMMARY.md:216
msgid "Client"
msgstr "í´ë¼ì´ì–¸íŠ¸"

#: src/SUMMARY.md:217
msgid "Changing API"
msgstr "API ìˆ˜ì •"

#: src/SUMMARY.md:218
msgid "Logging"
msgstr "ë¡œê¹…"

#: src/SUMMARY.md:219
msgid "Interoperability"
msgstr "ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:220
msgid "With C"
msgstr "Cì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:221
msgid "Calling C with Bindgen"
msgstr "Bindgenì„ ì‚¬ìš©í•œ Cí˜¸ì¶œ"

#: src/SUMMARY.md:222
msgid "Calling Rust from C"
msgstr "Cì—ì„œ ëŸ¬ìŠ¤íŠ¸ í˜¸ì¶œ"

#: src/SUMMARY.md:223
msgid "With C++"
msgstr "C++ ì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:224
msgid "With Java"
msgstr "Javaì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:227
msgid "Final Words"
msgstr "ëìœ¼ë¡œ..."

#: src/SUMMARY.md:229
msgid "Thanks!"
msgstr "ê°ì‚¬ì¸ì‚¬"

#: src/SUMMARY.md:230
msgid "Other Resources"
msgstr "ëŸ¬ìŠ¤íŠ¸ ì°¸ê³  ìë£Œ"

#: src/SUMMARY.md:231
msgid "Credits"
msgstr "ë„ì™€ì£¼ì‹  ë¶„ë“¤"

#: src/SUMMARY.md:235
msgid "Solutions"
msgstr "í•´ë‹µ"

#: src/SUMMARY.md:240
msgid "Day 1 Morning"
msgstr "1ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:241
msgid "Day 1 Afternoon"
msgstr "1ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:242
msgid "Day 2 Morning"
msgstr "2ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:243
msgid "Day 2 Afternoon"
msgstr "2ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:244
msgid "Day 3 Morning"
msgstr "3ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:245
msgid "Day 3 Afternoon"
msgstr "3ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:246
msgid "Day 4 Morning"
msgstr "4ì¼ì°¨ ì˜¤ì „"

#: src/welcome.md:1
msgid "# Welcome to Comprehensive Rust ğŸ¦€"
msgstr "# Welcome to Comprehensive Rust ğŸ¦€"

#: src/welcome.md:3
msgid ""
"This is a four day Rust course developed by the Android team. The course covers\n"
"the full spectrum of Rust, from basic syntax to advanced topics like generics\n"
"and error handling. It also includes Android-specific content on the last day."
msgstr "ì´ 4ì¼ì§œë¦¬ ëŸ¬ìŠ¤íŠ¸ ê°•ì˜ëŠ” ì•ˆë“œë¡œì´ë“œ íŒ€ì´ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ ë¬¸ë²•ë¶€í„° ì œë„¤ë¦­, ì—ëŸ¬ í•¸ë“¤ë§ê³¼ ê°™ì€ ê³ ê¸‰ì£¼ì œê¹Œì§€ ëŸ¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ê²ƒì„ í¬í•¨í•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ ë‚ ì—ëŠ” ì•ˆë“œë¡œì´ë“œì— ëŒ€í•œ ê²ƒ ê¹Œì§€ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/welcome.md:7
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know anything\n"
"about Rust and hope to:"
msgstr "ê°•ì˜ëŠ” ë‹¹ì‹ ì´ ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•´ì„œ ì•„ë¬´ê²ƒë„ ëª¨ë¥¸ë‹¤ê³  ê°€ì •í•˜ê³  ì•„ë˜ì˜ ëª©í‘œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:"

#: src/welcome.md:10
msgid ""
"* Give you a comprehensive understanding of the Rust syntax and language.\n"
"* Enable you to modify existing programs and write new programs in Rust.\n"
"* Show you common Rust idioms."
msgstr ""
"* ëŸ¬ìŠ¤íŠ¸ êµ¬ë¬¸ê³¼ ì–¸ì–´ì— ëŒ€í•œ í¬ê´„ì ì¸ ì´í•´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n"
"* ê¸°ì¡´ í”„ë¡œê·¸ë¨ì„ ìˆ˜ì •í•˜ê³  ëŸ¬ìŠ¤íŠ¸ì—ì„œ ìƒˆ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì¼ë°˜ì ì¸ ëŸ¬ìŠ¤íŠ¸ ê´€ìš©êµ¬ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/welcome.md:14
msgid "On Day 4, we will cover Android-specific things such as:"
msgstr "4ì¼ì°¨ ê°•ì˜ì— ìš°ë¦¬ëŠ” ì•„ë˜ì™€ ê°™ì€ ì•ˆë“œë¡œì´ë“œ íŠ¹í™”ëœ ë‚´ìš©ë“¤ë„ ì„¤ëª…í•©ë‹ˆë‹¤:"

#: src/welcome.md:16
msgid ""
"* Building Android components in Rust.\n"
"* AIDL servers and clients.\n"
"* Interoperability with C, C++, and Java."
msgstr ""
"* ëŸ¬ìŠ¤íŠ¸ì—ì„œ Android êµ¬ì„± ìš”ì†Œë¥¼ êµ¬ì¶•.\n"
"* AIDL ì„œë²„ ë° í´ë¼ì´ì–¸íŠ¸.\n"
"* C, C++ ë° Javaì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±."

#: src/welcome.md:20
msgid ""
"It is important to note that this course does not cover Android **application** \n"
"development in Rust, and that the Android-specific parts are specifically about\n"
"writing code for Android itself, the operating system. "
msgstr "ì´ ê°•ì˜ì—ì„œëŠ” ëŸ¬ìŠ¤íŠ¸ë¡œ ì•ˆë“œë¡œì´ë“œ **ì• í”Œë¦¬ì¼€ì´ì…˜**ì„ ê°œë°œí•˜ëŠ” ê²ƒì€ ë‹¤ë£¨ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ ê°•ì˜ì—ì„œ ë‹¤ë£¨ëŠ” ì•ˆë“œë¡œì´ë“œ íŠ¹í™”ëœ ë‚´ìš©ì€ ì•ˆë“œë¡œì´ë“œ OSì˜ ì¼ë¶€ë¥¼ ëŸ¬ìŠ¤íŠ¸ë¡œ ê°œë°œí•˜ëŠ” ê²ƒì— ëŒ€í•œ ê²ƒì…ë‹ˆë‹¤. "

#: src/welcome.md:24
msgid "## Non-Goals"
msgstr "## ì œì™¸ì‚¬í•­"

#: src/welcome.md:26
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few days.\n"
"Some non-goals of this course are:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë©°ì¹ ë§Œì— ëª¨ë“  ê²ƒì„ ë‹¤ë£¨ê¸°ì—ëŠ” ë„ˆë¬´ í° ì–¸ì–´ì…ë‹ˆë‹¤. ê·¸ë˜ì„œ ì•„ë˜ì™€ ê°™ì€ê²ƒì„ ëª©í‘œë¡œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/welcome.md:29
msgid ""
"* Learn how to use async Rust --- we'll only mention async Rust when\n"
"  covering traditional concurrency primitives. Please see [Asynchronous\n"
"  Programming in Rust](https://rust-lang.github.io/async-book/) instead for\n"
"  details on this topic.\n"
"* Learn how to develop macros, please see [Chapter 19.5 in the Rust\n"
"  Book](https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by\n"
"  Example](https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"* ë¹„ë™ê¸°ì  ëŸ¬ìŠ¤íŠ¸ ì‚¬ìš©ë²•. ê°„ë‹¨í•˜ê²Œ ì–¸ê¸‰ì •ë„ëŠ” í•˜ê² ì§€ë§Œ ì¢€ ë” ìì„¸í•œ ë‚´ìš©ì€ [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)ë¥¼ ì°¸ì¡°í•´ì£¼ì„¸ìš”.\n"
"* ë§¤í¬ë¡œë¥¼ ê°œë°œí•˜ëŠ” ë°©ë²•. [Chapter 19.5 in the Rust Book](https://doc.rust-lang.org/book/ch19-06-macros.html)ì™€ [Rust by Example](https://doc.rust-lang.org/rust-by-example/macros.html)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/welcome.md:37
msgid "## Assumptions"
msgstr "## ë…ì ìˆ˜ì¤€ì— ëŒ€í•œ ê°€ì •"

#: src/welcome.md:39
msgid ""
"The course assumes that you already know how to program. Rust is a statically\n"
"typed language and we will sometimes make comparisons with C and C++ to better\n"
"explain or contrast the Rust approach."
msgstr "ë³¸ ê°•ì˜ëŠ” ì—¬ëŸ¬ë¶„ì´ í”„ë¡œê·¸ë˜ë° ìì²´ì— ëŒ€í•´ì„œëŠ” ì•Œê³  ìˆë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ì •ì íƒ€ì… ì–¸ì–´ì´ë©°, ê°•ì¢Œì—ì„œëŠ” C/C++ ì™€ì˜ ë¹„êµ, ëŒ€ì¡°ë¥¼ í†µí•´ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì„¤ëª…í•  ê²ƒì…ë‹ˆë‹¤."

#: src/welcome.md:43
msgid ""
"If you know how to program in a dynamically typed language such as Python or\n"
"JavaScript, then you will be able to follow along just fine too."
msgstr "C/C++ì„ ëª¨ë¥´ë”ë¼ë„ ë™ì  íƒ€ì… ì–¸ì–´(Pythonì´ë‚˜ JavaScript ë“±) í”„ë¡œê·¸ë˜ë° ê²½í—˜ì´ ìˆë‹¤ë©´ ë”°ë¼ì˜¤ëŠ”ë° í° ë¬¸ì œëŠ” ì—†ì„ ê²ƒì…ë‹ˆë‹¤."

#: src/welcome.md:46 src/cargo/rust-ecosystem.md:19
#: src/cargo/code-samples.md:22 src/cargo/running-locally.md:68
#: src/welcome-day-1.md:14 src/welcome-day-1/what-is-rust.md:19
#: src/hello-world.md:20 src/hello-world/small-example.md:21 src/why-rust.md:9
#: src/why-rust/compile-time.md:14 src/why-rust/runtime.md:8
#: src/why-rust/modern.md:19 src/basic-syntax/compound-types.md:28
#: src/basic-syntax/slices.md:18 src/basic-syntax/string-slices.md:25
#: src/basic-syntax/functions.md:33 src/basic-syntax/functions-interlude.md:25
#: src/exercises/day-1/morning.md:9 src/exercises/day-1/for-loops.md:90
#: src/basic-syntax/variables.md:15 src/basic-syntax/type-inference.md:24
#: src/basic-syntax/static-and-const.md:46
#: src/basic-syntax/scopes-shadowing.md:23 src/memory-management/stack.md:26
#: src/memory-management/rust.md:12 src/ownership/move-semantics.md:20
#: src/ownership/moves-function-calls.md:18 src/ownership/copy-clone.md:33
#: src/ownership/borrowing.md:25 src/ownership/shared-unique-borrows.md:23
#: src/ownership/lifetimes-function-calls.md:27
#: src/ownership/lifetimes-data-structures.md:23
#: src/exercises/day-1/afternoon.md:9 src/structs/tuple-structs.md:35
#: src/structs/field-shorthand.md:25 src/enums/variant-payloads.md:33
#: src/methods.md:28 src/pattern-matching/destructuring-enums.md:33
#: src/pattern-matching/destructuring-arrays.md:19
#: src/pattern-matching/match-guards.md:20 src/exercises/day-2/morning.md:9
#: src/exercises/day-2/points-polygons.md:115 src/control-flow/blocks.md:40
#: src/control-flow/if-expressions.md:29
#: src/control-flow/if-let-expressions.md:19
#: src/control-flow/while-let-expressions.md:25
#: src/control-flow/match-expressions.md:25 src/std/option-result.md:16
#: src/std/string.md:28 src/std/vec.md:35 src/std/hashmap.md:36
#: src/std/box.md:32 src/std/box-recursive.md:31 src/std/rc.md:29
#: src/modules.md:26 src/modules/visibility.md:37 src/modules/filesystem.md:24
#: src/exercises/day-2/afternoon.md:5 src/traits.md:39
#: src/traits/iterator.md:30 src/traits/from-iterator.md:15
#: src/traits/operators.md:24 src/traits/drop.md:32 src/traits/default.md:38
#: src/generics/methods.md:23 src/generics/trait-bounds.md:33
#: src/generics/impl-trait.md:22 src/generics/closures.md:23
#: src/exercises/day-3/morning.md:5 src/error-handling/result.md:25
#: src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:48
#: src/error-handling/deriving-error-enums.md:37
#: src/error-handling/dynamic-errors.md:34
#: src/error-handling/error-contexts.md:33 src/unsafe.md:26
#: src/unsafe/raw-pointers.md:24 src/unsafe/mutable-static-variables.md:30
#: src/unsafe/unions.md:19 src/unsafe/writing-unsafe-functions.md:31
#: src/unsafe/extern-functions.md:19 src/unsafe/unsafe-traits.md:28
#: src/exercises/day-3/afternoon.md:5 src/concurrency/threads.md:28
#: src/concurrency/channels.md:25 src/concurrency/shared_state/arc.md:27
#: src/concurrency/shared_state/example.md:21 src/concurrency/send-sync.md:18
#: src/concurrency/send-sync/sync.md:12 src/exercises/day-4/morning.md:10
#: src/android/interoperability/with-c/rust.md:81
#: src/exercises/day-4/afternoon.md:10
msgid "<details>"
msgstr "<details>"

#: src/welcome.md:48
msgid ""
"This is an example of a _speaker note_. We will use these to add additional\n"
"information to the slides. This could be key points which the instructor should\n"
"cover as well as answers to typical questions which come up in class."
msgstr "ì´ê²ƒì€ \"ë°œí‘œì ë…¸íŠ¸\"ì˜ ì˜ˆì œì…ë‹ˆë‹¤. ì´ ë¶€ë¶„ì„ ì´ìš©í•´ì„œ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì£¼ë¡œ ê°•ì˜ì‹¤ì—ì„œ ì œê¸°ë˜ëŠ” ì¼ë°˜ì ì¸ ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ê³¼ ê°•ì‚¬ê°€ ë‹¤ë£¨ì–´ì•¼ í•  í‚¤ í¬ì¸íŠ¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/welcome.md:52 src/cargo/rust-ecosystem.md:67
#: src/cargo/code-samples.md:35 src/cargo/running-locally.md:74
#: src/welcome-day-1.md:42 src/welcome-day-1/what-is-rust.md:29
#: src/hello-world.md:36 src/hello-world/small-example.md:44 src/why-rust.md:24
#: src/why-rust/compile-time.md:35 src/why-rust/runtime.md:22
#: src/why-rust/modern.md:66 src/basic-syntax/compound-types.md:62
#: src/basic-syntax/references.md:28 src/basic-syntax/slices.md:36
#: src/basic-syntax/functions.md:54 src/exercises/day-1/morning.md:28
#: src/exercises/day-1/for-loops.md:95 src/basic-syntax/variables.md:20
#: src/basic-syntax/type-inference.md:48
#: src/basic-syntax/static-and-const.md:52
#: src/basic-syntax/scopes-shadowing.md:39 src/memory-management/stack.md:49
#: src/memory-management/rust.md:18 src/ownership/move-semantics.md:26
#: src/ownership/moves-function-calls.md:26 src/ownership/borrowing.md:51
#: src/ownership/shared-unique-borrows.md:29
#: src/ownership/lifetimes-function-calls.md:60
#: src/exercises/day-1/afternoon.md:15 src/exercises/day-1/book-library.md:103
#: src/structs.md:41 src/structs/field-shorthand.md:41 src/enums/sizes.md:136
#: src/methods/example.md:53 src/pattern-matching/destructuring-enums.md:39
#: src/pattern-matching/destructuring-arrays.md:46
#: src/exercises/day-2/morning.md:15 src/exercises/day-2/points-polygons.md:125
#: src/control-flow/if-let-expressions.md:26
#: src/control-flow/for-expressions.md:29
#: src/control-flow/loop-expressions.md:27 src/std.md:31
#: src/std/option-result.md:25 src/std/string.md:40 src/std/vec.md:49
#: src/std/hashmap.md:66 src/std/rc.md:69 src/modules.md:32
#: src/modules/visibility.md:48 src/modules/filesystem.md:53
#: src/exercises/day-2/afternoon.md:11 src/traits.md:54
#: src/traits/from-iterator.md:26 src/traits/operators.md:38
#: src/traits/drop.md:42 src/traits/default.md:47 src/generics/methods.md:31
#: src/generics/closures.md:38 src/exercises/day-3/morning.md:11
#: src/error-handling/try-operator.md:55
#: src/error-handling/converting-error-types-example.md:60
#: src/error-handling/deriving-error-enums.md:45
#: src/error-handling/dynamic-errors.md:41
#: src/error-handling/error-contexts.md:42 src/unsafe.md:32
#: src/unsafe/raw-pointers.md:42 src/unsafe/mutable-static-variables.md:35
#: src/unsafe/unions.md:28 src/unsafe/writing-unsafe-functions.md:38
#: src/unsafe/extern-functions.md:28 src/unsafe/unsafe-traits.md:37
#: src/exercises/day-3/afternoon.md:11 src/concurrency/threads.md:45
#: src/concurrency/channels.md:32 src/concurrency/shared_state/arc.md:38
#: src/concurrency/shared_state/example.md:60
#: src/concurrency/send-sync/sync.md:18 src/exercises/day-4/morning.md:16
#: src/android/interoperability/with-c/rust.md:86
#: src/exercises/day-4/afternoon.md:15
msgid "</details>"
msgstr "</details>"

#: src/running-the-course.md:1
msgid "# Running the Course"
msgstr "# ê°•ì˜ ì§„í–‰ ë°©ì‹"

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "> This page is for the course instructor."
msgstr "> ê°•ì‚¬ë¥¼ ìœ„í•œ ì•ˆë‚´ í˜ì´ì§€ì…ë‹ˆë‹¤."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the course\n"
"internally at Google."
msgstr "ë‹¤ìŒì€ êµ¬ê¸€ ë‚´ë¶€ì—ì„œ ì´ ê³¼ì •ì„ ì–´ë–¤ì‹ìœ¼ë¡œ ìš´ì˜í•´ì™”ëŠ”ì§€ì— ëŒ€í•œ ë°°ê²½ ì •ë³´ì…ë‹ˆë‹¤."

#: src/running-the-course.md:8
msgid "To run the course, you need to:"
msgstr "ê°•ì˜ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì¤€ë¹„:"

#: src/running-the-course.md:10
msgid ""
"1. Make yourself familiar with the course material. We've included speaker notes\n"
"   on some of the pages to help highlight the key points (please help us by\n"
"   contributing more speaker notes!). You should make sure to open the speaker\n"
"   notes in a popup (click the link with a little arrow next to \"Speaker\n"
"   Notes\"). This way you have a clean screen to present to the class."
msgstr "1. ê°•ì˜ ìë£Œë¥¼ ìˆ™ì§€í•©ë‹ˆë‹¤. ì£¼ìš” ìš”ì ì„ ê°•ì¡°í•˜ê¸° ìœ„í•´ ì¼ë¶€ í˜ì´ì§€ì— ê°•ì˜ ì°¸ì¡°ë…¸íŠ¸ë¥¼ í¬í•¨í•˜ì˜€ìŠµë‹ˆë‹¤. (ì¶”ê°€ì ì¸ ë…¸íŠ¸ë¥¼ ì‘ì„±í•˜ì—¬ ì œê³µí•´ ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.) ê°•ì˜ ì°¸ì¡° ë…¸íŠ¸ì˜ ë§í¬ë¥¼ ëˆ„ë¥´ë©´ ê°•ì˜ë…¸íŠ¸ê°€ ë³„ë„ì˜ íŒì—…ìœ¼ë¡œ ë¶„ë¦¬ê°€ ë˜ë©°, ë©”ì¸ í™”ë©´ì—ì„œëŠ” ì‚¬ë¼ì§‘ë‹ˆë‹¤."

#: src/running-the-course.md:16
msgid ""
"2. Decide on the dates. Since the course is large, we recommend that you\n"
"   schedule the four days over two weeks. Course participants have said that\n"
"   they find it helpful to have a gap in the course since it helps them process\n"
"   all the information we give them."
msgstr "2. ê°•ì˜ ë‚ ì§œë¥¼ ì •í•©ë‹ˆë‹¤. ê°•ì˜ ë‚´ìš©ì´ ë§ê³  ìˆ˜ê°•ìƒë“¤ì´ ëª¨ë“  ì •ë³´ë¥¼ ê³µë¶€í•  ìˆ˜ ìˆë„ë¡ ì¤‘ê°„ì— í‹ˆì„ ë‘ì–´ 2ì£¼ì— ê±¸ì³ 4ì¼ì„ ì¡ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤."

#: src/running-the-course.md:21
msgid ""
"3. Find a room large enough for your in-person participants. We recommend a\n"
"   class size of 15-20 people. That's small enough that people are comfortable\n"
"   asking questions --- it's also small enough that one instructor will have\n"
"   time to answer the questions."
msgstr "3. ì¶©ë¶„í•œ ê³µê°„ì„ í™•ë³´í•©ë‹ˆë‹¤. ìˆ˜ê°•ìƒê³¼ ê°•ì‚¬ê°€ ì§ˆì˜ë¥¼ í•˜ê¸°ì— ì¶©ë¶„í•œ ì‹œê°„ê³¼ ê³µê°„ì´ì–´ì•¼ í•©ë‹ˆë‹¤. 15ì—ì„œ 20ëª… ê·œëª¨ì˜ ê³µê°„ì„ ì¶”ì²œí•©ë‹ˆë‹¤."

#: src/running-the-course.md:26
msgid ""
"4. On the day of your course, show up to the room a little early to set things\n"
"   up. We recommend presenting directly using `mdbook serve` running on your\n"
"   laptop (see the [installation instructions][5]). This ensures optimal performance with no lag as you change pages.\n"
"   Using your laptop will also allow you to fix typos as you or the course\n"
"   participants spot them."
msgstr "4. ê°•ì˜ ë‹¹ì¼ ì¡°ê¸ˆ ì¼ì° ì™€ì„œ ì¤€ë¹„í•©ë‹ˆë‹¤. ê°•ì‚¬ ë…¸íŠ¸ë¶ì—ì„œ `mdbook serve -d book/ko`ë¥¼ ì´ìš©í•´ ì§ì ‘ í”„ë ˆì  í…Œì´ì…˜ í•˜ë©´ í˜ì´ì§€ ì´ë™ ì‹œì˜ ì§€ì—°ì´ ì—†ìŠµë‹ˆë‹¤.([ì„¤ì¹˜ ë°©ë²•][5]ì„ ì°¸ì¡°í•˜ì„¸ìš”.) ë˜í•œ, ê·¸ë ‡ê²Œ í•˜ë©´ ê°•ì˜ ë„ì¤‘ ì˜¤íƒ€ë¥¼ ë°œê²¬í–ˆì„ ë•Œ ê·¸ ìë¦¬ì—ì„œ ë°”ë¡œ ìˆ˜ì • ê°€ëŠ¥í•˜ë‹¤ëŠ” ì¥ì ë„ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course.md:32
msgid ""
"5. Let people solve the exercises by themselves or in small groups. Make sure to\n"
"   ask people if they're stuck or if there is anything you can help with. When\n"
"   you see that several people have the same problem, call it out to the class\n"
"   and offer a solution, e.g., by showing people where to find the relevant\n"
"   information in the standard library."
msgstr "5. ìˆ˜ê°•ìƒë“¤ì´ ì§ì ‘ (ê°œë³„ í˜¹ì€ ê·¸ë£¹ìœ¼ë¡œ) ì—°ìŠµë¬¸ì œë¥¼ í’€ë„ë¡ í•©ë‹ˆë‹¤. ì§„í–‰ì´ ë§‰í˜€ ë„ì›€ì„ í•„ìš”ë¡œ í•˜ëŠ” ìˆ˜ê°•ìƒì´ ì—†ëŠ”ì§€ ìˆ˜ì‹œë¡œ í™•ì¸í•©ë‹ˆë‹¤. ë§Œì•½ ê°™ì€ ë¬¸ì œë¥¼ ì—¬ëŸ¬ ì‚¬ëŒì´ ê²ªê³  ìˆë‹¤ë©´, ê·¸ ë¬¸ì œë¥¼ ê°•ì˜ì‹¤ ì „ì²´ ì¸ì›ì—ê²Œ ì•Œë¦¬ê³  í•´ê²°ì±…ì„ ì œì‹œí•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì–´ë””ì— ê°€ë©´ ê·¸ ë¬¸ì œì— ëŒ€í•œ í•´ë‹µì„ ì°¾ì„ ìˆ˜ ìˆëŠ”ì§€ ì•Œë ¤ ì¤ë‹ˆë‹¤."

#: src/running-the-course.md:38
msgid ""
"6. If you don't skip the Android specific parts on Day 4, you will need an [AOSP\n"
"   checkout][1]. Make a checkout of the [course repository][2] on the same\n"
"   machine and move the `src/android/` directory into the root of your AOSP\n"
"   checkout. This will ensure that the Android build system sees the\n"
"   `Android.bp` files in `src/android/`."
msgstr "6. 4ì¼ì°¨ì— ìˆì„ ì•ˆë“œë¡œì´ë“œ ë¶€ë¶„ì„ ê±´ë„ˆë„ì§€ ì•ŠëŠ”ë‹¤ë©´ [AOSP ì½”ë“œ][1]ë¥¼ ì²´í¬ì•„ì›ƒí•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ, ê°™ì€ ì»´í“¨í„°ì—ì„œ [ê³¼ì • ì €ì¥ì†Œ][2]ë¥¼ ì²´í¬ì•„ì›ƒí•˜ê³  `src/android/` ë””ë ‰í„°ë¦¬ë¥¼ AOSP ì½”ë“œì˜ ë£¨íŠ¸ë¡œ ì´ë™í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì•ˆë“œë¡œì´ë“œ ë¹Œë“œ ì‹œìŠ¤í…œì—ì„œ ê³¼ì œìš©ìœ¼ë¡œ ì¶”ê°€ëœ `Android.bp`íŒŒì¼ì„ ì¸ì‹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course.md:44
msgid ""
"   Ensure that `adb sync` works with your emulator or real device and pre-build\n"
"   all Android examples using `src/android/build_all.sh`. Read the script to see\n"
"   the commands it runs and make sure they work when you run them by hand."
msgstr "   `adb sync` ëª…ë ì–´ê°€ ì—ë®¬ë ˆì´í„° í˜¹ì€ ì‹¤ì œ ì¥ì¹˜ì™€ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  `src/android/build_all.sh`ë¥¼ ìˆ˜í–‰í•´ì„œ ëª¨ë“  ì•ˆë“œë¡œì´ë“œ ì˜ˆì œë¥¼ ë¯¸ë¦¬ ë¹Œë“œí•´ ë³´ì„¸ìš”. ê·¸ ì‰˜ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì½ê³ , ê·¸ ì•ˆì—ì„œ ìˆ˜í–‰ë˜ëŠ” ëª…ë ¹ì–´ë“¤ì„ í™•ì¸í•œ í›„ ê° ëª…ë ¹ì–´ë“¤ì„ ìˆ˜ë™ìœ¼ë¡œ ì‹¤í–‰í•´ë„ ì˜ ë˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun for\n"
"you as it has been for us!"
msgstr "ì´ì œ ì¤€ë¹„ëŠ” ëë‚¬ìŠµë‹ˆë‹¤. ìš°ë¦¬ê°€ ê·¸ë¬ë“¯ì´ ì—¬ëŸ¬ë¶„ë“¤ë„ ì´ ê°•ì˜ë¥¼ ì¦ê¸°ì‹œê¸¸ ë°”ëë‹ˆë‹¤!"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback][3] afterwards so that we can keep improving the\n"
"course. We would love to hear what worked well for you and what can be made\n"
"better. Your students are also very welcome to [send us feedback][4]!"
msgstr "ê°•ì˜ë¥¼ ê³„ì† ê°œì„ í•  ìˆ˜ ìˆë„ë¡ [í”¼ë“œë°±][3]ì„ ì œê³µí•´ ì£¼ì‹­ì‹œì˜¤. ìš°ë¦¬ëŠ” ë¬´ì—‡ì´ ì¢‹ì•˜ê³ , ë¬´ì—‡ì´ ëª¨ìëëŠ”ì§€ ë“£ê³  ì‹¶ìŠµë‹ˆë‹¤. ìˆ˜ê°•ìƒë“¤ë¡œ ë¶€í„°ì˜ [í”¼ë“œë°±][4]ë„ í™˜ì˜í•©ë‹ˆë‹¤!"

#: src/running-the-course.md:55
msgid ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100\n"
"[5]: https://github.com/google/comprehensive-rust#building"
msgstr ""
"[1]: https://source.android.com/docs/setup/download/downloading\n"
"[2]: https://github.com/google/comprehensive-rust\n"
"[3]: https://github.com/google/comprehensive-rust/discussions/86\n"
"[4]: https://github.com/google/comprehensive-rust/discussions/100\n"
"[5]: https://github.com/google/comprehensive-rust#building"

#: src/running-the-course/course-structure.md:1
msgid "# Course Structure"
msgstr "# ê°•ì˜ êµ¬ì„±"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "ê°•ì˜ëŠ” ë¹ ë¥¸ ì†ë„ë¡œ ì§„í–‰ë˜ë©°, ì•„ë˜ ë‚´ìš©ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤:"

#: src/running-the-course/course-structure.md:7
msgid ""
"* Day 1: Basic Rust, ownership and the borrow checker.\n"
"* Day 2: Compound data types,  pattern matching, the standard library.\n"
"* Day 3: Traits and generics, error handling, testing, unsafe Rust.\n"
"* Day 4: Concurrency in Rust and interoperability with other languages"
msgstr ""
"* 1ì¼ì°¨: ëŸ¬ìŠ¤íŠ¸ ê¸°ë³¸, ì†Œìœ ê¶Œ(ownership)ê³¼ ë¹Œë¦¼(borrow) ì²´í¬\n"
"* 2ì¼ì°¨: ë³µí•© ë°ì´í„° ìœ í˜•, íŒ¨í„´ ë§¤ì¹­, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬\n"
"* 3ì¼ì°¨: íŠ¸ë ˆì‡(trait)ì™€ ì œë„¤ë¦­(generic), ì˜¤ë¥˜ ì²˜ë¦¬, í…ŒìŠ¤íŠ¸, ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸\n"
"* 4ì¼ì°¨: ëŸ¬ìŠ¤íŠ¸ì˜ ë™ì‹œì„± ë° ë‹¤ë¥¸ ì–¸ì–´ì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±"

#: src/running-the-course/course-structure.md:12
msgid ""
"> **Exercise for Day 4:** Do you interface with some C/C++ code in your project\n"
"> which we could attempt to move to Rust? The fewer dependencies the better.\n"
"> Parsing code would be ideal."
msgstr "> **4ì¼ì°¨ ì—°ìŠµë¬¸ì œ:** ëŸ¬ìŠ¤íŠ¸ í”„ë¡œì íŠ¸ì—ì„œ C/C++ë¡œ ì‘ì„±ëœ ì½”ë“œë¥¼ ì´ì „í•´ì„œ ì—°ê²°í•˜ë ¤ê³  í•œë‹¤ë©´ ì¢…ì†ì„±ì´ ì ì„ ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤. êµ¬ë¬¸ ë¶„ì„ ì½”ë“œë¼ë©´ ì´ìƒì ì…ë‹ˆë‹¤."

#: src/running-the-course/course-structure.md:16
msgid "## Format"
msgstr "## ê°•ì˜ í˜•ì‹"

#: src/running-the-course/course-structure.md:18
msgid ""
"The course is meant to be very interactive and we recommend letting the\n"
"questions drive the exploration of Rust!"
msgstr "ì´ ê°•ì˜ëŠ” ê°•ì‚¬ì™€ ìˆ˜ê°•ìƒì´ ì–‘ë°©í–¥ìœ¼ë¡œ ì†Œí†µí•˜ë©´ì„œ ì§„í–‰í•˜ë„ë¡ ë””ìì¸ ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì–‘í•œ ì§ˆë¬¸ì„ í†µí•´ ëŸ¬ìŠ¤íŠ¸ì˜ ì—¬ëŸ¬ ë¶€ë¶„ì„ íƒí—˜í•  ìˆ˜ ìˆë„ë¡ í•˜ì„¸ìš”!"

#: src/running-the-course/keyboard-shortcuts.md:1
msgid "# Keyboard Shortcuts"
msgstr "# ë‹¨ì¶•í‚¤"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "mdBook ì‹œìŠ¤í…œ(í˜„ ì‚¬ì´íŠ¸)ì—ì„œ ìœ ìš©í•œ ë‹¨ì¶•í‚¤ë“¤ ì…ë‹ˆë‹¤:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ""
"* <kbd>Arrow-Left</kbd>: Navigate to the previous page.\n"
"* <kbd>Arrow-Right</kbd>: Navigate to the next page.\n"
"* <kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.\n"
"* <kbd>s</kbd>: Activate the search bar."
msgstr ""
"* <kbd>ì™¼ìª½ í™”ì‚´í‘œ</kbd>: ì´ì „ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤.\n"
"* <kbd>ì˜¤ë¥¸ìª½ í™”ì‚´í‘œ</kbd>: ë‹¤ìŒ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤.\n"
"* <kbd>Ctrl + Enter</kbd>: í˜„ì¬ í¬ì»¤ìŠ¤ë¥¼ ë°›ì€ ì½”ë“œ ìƒ˜í”Œ ë¸”ë¡ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.\n"
"* <kbd>s</kbd>: ê²€ìƒ‰ì°½ì„ í™œì„±í™”í•©ë‹ˆë‹¤.(mdBook ë¬¸ì œë¡œ 23.01.19 ê¸°ì¤€ ì˜ì–´ë¡œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.)"

#: src/running-the-course/translations.md:1
msgid "# Translations"
msgstr "# ë‹¤ë¥¸ ì–¸ì–´ë“¤"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful\n"
"volunteers:"
msgstr "ì´ ê³¼ì •ì€ ë‹¤ë¥¸ ì–¸ì–´ë¡œë„ ì œê³µë©ë‹ˆë‹¤. ê´„í˜¸ ì•ˆì€ ë²ˆì—­ì— ë„ì›€ ì£¼ì‹  ë¶„ë“¤ì…ë‹ˆë‹¤."

#: src/running-the-course/translations.md:6
msgid ""
"* [Brazilian Portuguese][pt-BR] by [@rastringer] and [@hugojacob].\n"
"* [Korean][ko] by [@keispace], [@jiyongp] and [@jooyunghan]."
msgstr ""
"* [ì˜ì–´][en]\n"
"* [ë¸Œë¼ì§ˆ í¬ë¥´íˆ¬ê°ˆì–´][pt-BR] ([@rastringer], [@hugojacob]).\n"
"* [í•œêµ­ì–´][ko] ([@keispace], [@jiyongp], [@jooyunghan])"

#: src/running-the-course/translations.md:9
msgid "Use the language picker in the top-right corner to switch between languages."
msgstr "í˜ì´ì§€ ì˜¤ë¥¸ìª½ ìœ„ì˜ ë©”ë‰´ë¥¼ í†µí•´ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course/translations.md:11
msgid ""
"If you want to help with this effort, please see [our instructions] for how to\n"
"get going. Translations are coordinated on the [issue tracker]."
msgstr ""
"ì´ ê³¼ì •ì˜ ë²ˆì—­ ì‘ì—…ì— ë„ì›€ì„ ì£¼ê³  ì‹¶ë‹¤ë©´ [ì—¬ê¸°][our instructions] ì„¤ëª…ëœ ë‚´ìš©ì„ ì°¸ê³ í•˜ì„¸ìš”.\n"
"ì§„í–‰ ì¤‘ì¸ ë²ˆì—­ ì‘ì—…ì— ëŒ€í•œ ë‚´ìš©ì€ [ì´ìŠˆ íŠ¸ë˜ì»¤][issue tracker]ë¥¼ ì°¸ê³ í•˜ì„¸ìš”."

#: src/running-the-course/translations.md:14
msgid ""
"[pt-BR]: https://google.github.io/comprehensive-rust/pt-BR/\n"
"[ko]: https://google.github.io/comprehensive-rust/ko/\n"
"[@rastringer]: https://github.com/rastringer\n"
"[@hugojacob]: https://github.com/hugojacob\n"
"[@keispace]: https://github.com/keispace\n"
"[@jiyongp]: https://github.com/jiyongp\n"
"[@jooyunghan]: https://github.com/jooyunghan\n"
"[our instructions]: https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md\n"
"[issue tracker]: https://github.com/google/comprehensive-rust/issues/282"
msgstr ""
"[en]: https://google.github.io/comprehensive-rust/\n"
"[pt-BR]: https://google.github.io/comprehensive-rust/pt-BR/\n"
"[ko]: https://google.github.io/comprehensive-rust/ko/\n"
"[@rastringer]: https://github.com/rastringer\n"
"[@hugojacob]: https://github.com/hugojacob\n"
"[@keispace]: https://github.com/keispace\n"
"[@jiyongp]: https://github.com/jiyongp\n"
"[@jooyunghan]: https://github.com/jooyunghan\n"
"[our instructions]: https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md\n"
"[issue tracker]: https://github.com/google/comprehensive-rust/issues/282"

#: src/cargo.md:1
msgid "# Using Cargo"
msgstr "# ì¹´ê³ (Cargo) ì‚¬ìš©í•˜ê¸°"

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc.rust-lang.org/cargo/), the standard tool\n"
"used in the Rust ecosystem to build and run Rust applications. Here we want to\n"
"give a brief overview of what Cargo is and how it fits into the wider ecosystem\n"
"and how it fits into this training."
msgstr "ëŸ¬ìŠ¤íŠ¸ë¥¼ ì‹œì‘í•˜ë ¤ê³ í•˜ë©´ ë‹¹ì‹ ì€ ê³§ [Cargo](https://doc.rust-lang.org/cargo/)ë¼ëŠ”, ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„ì—ì„œ ì‚¬ìš©í•˜ëŠ” í‘œì¤€ ë¹Œë“œ/ì‹¤í–‰ ë„êµ¬ë¥¼ ë§Œë‚  ê²ƒ ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ì¹´ê³ ê°€ ë¬´ì—‡ì¸ì§€, ê·¸ë¦¬ê³  ì¹´ê³ ê°€ ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„ì—ì„œ ì–´ë–¤ ì—­í• ì„ í•˜ëŠ”ì§€, ê·¸ë¦¬ê³  ì´ ê°•ì˜ì—ì„œ ì–´ë–»ê²Œ ì‚¬ìš©ë  ì§€ì— ëŒ€í•´ ê°„ëµíˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤."

#: src/cargo.md:8
msgid "## Installation"
msgstr "## ì„¤ì¹˜í•˜ê¸°"

#: src/cargo.md:10
msgid "### Rustup (Recommended)"
msgstr "#### Rustup (ì¶”ì²œ)"

#: src/cargo.md:12
msgid "You can follow the instructions to install cargo and rust compiler, among other standard ecosystem tools with the [rustup][3] tool, which is maintained by the Rust Foundation."
msgstr "ëŸ¬ìŠ¤íŠ¸ ì¬ë‹¨ì—ì„œ ê´€ë¦¬í•˜ê³  ìˆëŠ” [rustup][3] ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¹´ê³  ë° ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ ë“± í‘œì¤€ ë„êµ¬ë¥¼ ì„¤ì¹˜ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo.md:14
msgid "Along with cargo and rustc, Rustup will install itself as a command line utility that you can use to install/switch toolchains, setup cross compilation, etc."
msgstr "ì¹´ê³ (cargo)ì™€ ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬(rustc)ì™€ í•¨ê»˜, rustupì€ íˆ´ì²´ì¸ì„ ì„¤ì¹˜í•˜ê³ , ë‹¤ë¥¸ íˆ´ì²´ì¸ìœ¼ë¡œ ì „í™˜í•˜ê³ , í¬ë¡œìŠ¤ ì»´íŒŒì¼ ì„¤ì •ì„ í•˜ëŠ” ì¼ì„ ë‹´ë‹¹í•˜ëŠ” ì»¤ë§¨ë“œ ë¼ì¸ ìœ í‹¸ë¦¬í‹° ì…ë‹ˆë‹¤."

#: src/cargo.md:16
msgid "### Package Managers"
msgstr "### íŒ¨í‚¤ì§€ ë§¤ë‹ˆì €"

#: src/cargo.md:18
msgid "#### Debian"
msgstr "#### ë°ë¹„ì•ˆ"

#: src/cargo.md:20
msgid "On Debian/Ubuntu, you can install Cargo, the Rust source and the [Rust formatter][6] with"
msgstr "ë°ë¹„ì•ˆì´ë‚˜ ìš°ë¶„íˆ¬ì—ì„œ cargo, ëŸ¬ìŠ¤íŠ¸ ì†ŒìŠ¤ì½”ë“œ, [ëŸ¬ìŠ¤íŠ¸ í¬ë§¤í„°][6]ë¥¼ ì•„ë˜ ì»¤ë§¨ë“œë¡œ ì„¤ì¹˜í•©ë‹ˆë‹¤."

#: src/cargo.md:22
msgid ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""
"```shell\n"
"$ sudo apt install cargo rust-src rustfmt\n"
"```"

#: src/cargo.md:26
msgid ""
"This will allow [rust-analyzer][1] to jump to the definitions. We suggest using\n"
"[VS Code][2] to edit the code (but any LSP compatible editor works)."
msgstr "ì´ë ‡ê²Œ í•˜ë©´ [rust-analyzer][1]ë¥¼ ì´ìš©í•´ì„œ íŠ¹ì • ì‹¬ë³¼ì´ ì •ì˜ëœ ìœ„ì¹˜ë¡œ ì‰½ê²Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì—ë””í„°ë¡œ [VS Code][2]ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤ë§Œ, ì‚¬ì‹¤ LSPë¥¼ ì§€ì›í•œë‹¤ë©´ ì–´ë–¤ ì—ë””í„°ë„ ë¬´ë°©í•©ë‹ˆë‹¤."

#: src/cargo.md:29
msgid "Some folks also like to use the [JetBrains][4] family of IDEs, which do their own analysis but have their own tradeoffs. If you prefer them, you can install the [Rust Plugin][5]. Please take note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite."
msgstr "ì–´ë–¤ ì‚¬ëŒë“¤ì€ [JetBrains][4] ì œí’ˆêµ°ì„ ì„ í˜¸í•˜ê¸°ë„ í•©ë‹ˆë‹¤. ì´ ì œí’ˆë“¤ì€ rust-analyzer ë¥¼ í™œìš©í•˜ì§€ ì•Šê³  IDE ìì²´ì ìœ¼ë¡œ êµ¬ë¬¸ë¶„ì„ì„ í•©ë‹ˆë‹¤. ë§Œì•½ ì´ IDEë¥¼ ì„¤ì¹˜í•˜ì…¨ë‹¤ë©´ [Rust Plugin][5]ë¥¼ ì„¤ì¹˜í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ë‹¤ë§Œ 2023ë…„ 1ì›” ê¸°ì¤€, ë””ë²„ê¹…ì€ JetBrains IDEA suiteì˜ CLion ë²„ì „ì—ì„œë§Œ ì‘ë™í•œë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo.md:31
msgid ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/\n"
"[6]: https://github.com/rust-lang/rustfmt"
msgstr ""
"[1]: https://rust-analyzer.github.io/\n"
"[2]: https://code.visualstudio.com/\n"
"[3]: https://rustup.rs/\n"
"[4]: https://www.jetbrains.com/clion/\n"
"[5]: https://www.jetbrains.com/rust/\n"
"[6]: https://github.com/rust-lang/rustfmt"

#: src/cargo/rust-ecosystem.md:1
msgid "# The Rust Ecosystem"
msgstr "# ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„"

#: src/cargo/rust-ecosystem.md:3
msgid "The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ìƒíƒœê³„ëŠ” ì—¬ëŸ¬ê°€ì§€ ë„êµ¬ë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ê·¸ ì¤‘ ì¤‘ìš”í•œ ê²ƒë“¤ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"* `rustc`: the Rust compiler which turns `.rs` files into binaries and other\n"
"  intermediate formats."
msgstr "* `rustc`: `.rs` í™•ì¥ì íŒŒì¼ì„ ë°”ì´ë„ˆë¦¬ í˜¹ì€ ë‹¤ë¥¸ ì¤‘ê°„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•´ì£¼ëŠ” Rust ì»´íŒŒì¼ëŸ¬ì…ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"* `cargo`: the Rust dependency manager and build tool. Cargo knows how to\n"
"  download dependencies hosted on <https://crates.io> and it will pass them to\n"
"  `rustc` when building your project. Cargo also comes with a built-in test\n"
"  runner which is used to execute unit tests."
msgstr "* `cargo`: ëŸ¬ìŠ¤íŠ¸ ì˜ì¡´ì„± ê´€ë¦¬ì ë° ë¹Œë“œë„êµ¬ ì…ë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ í”„ë¡œì íŠ¸ì— ëª…ì‹œëœ ì˜ì¡´ì„±ë“¤ì„ <https://crates.io>ì—ì„œ ìë™ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œ ë°›ê³ , ê·¸ ì†ŒìŠ¤ì½”ë“œë¥¼ `rustc`ë¡œ ì „ë‹¬í•˜ì—¬ ë¹Œë“œë¥¼ ì‹œí‚µë‹ˆë‹¤. ë˜í•œ ìœ ë‹› í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ëŠ” í…ŒìŠ¤íŠ¸ ëŸ¬ë„ˆë¥¼ ë‚´ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:13
msgid ""
"* `rustup`: the Rust toolchain installer and updater. This tool is used to\n"
"  install and update `rustc` and `cargo` when new versions of Rust is released.\n"
"  In addition, `rustup` can also download documentation for the standard\n"
"  library. You can have multiple versions of Rust installed at once and `rustup`\n"
"  will let you switch between them as needed."
msgstr "* `rustup`: ëŸ¬ìŠ¤íŠ¸ íˆ´ì²´ì¸ ì„¤ì¹˜ í”„ë¡œê·¸ë¨ ë° ì—…ë°ì´íŠ¸ í”„ë¡œê·¸ë¨. ì´ ë„êµ¬ëŠ” ìƒˆ ë²„ì „ì˜ ëŸ¬ìŠ¤íŠ¸ê°€ ì¶œì‹œë  ë•Œ `rustc` ë° `cargo` ì„¤ì¹˜í•˜ê³  ì—…ë°ì´íŠ¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ë˜í•œ `rustup`ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ ë¬¸ì„œë¥¼ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. í•œ ë²ˆì— ì—¬ëŸ¬ ë²„ì „ì˜ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ìˆìœ¼ë©° `rustup`ì„ í†µí•´ í•„ìš”ì— ë”°ë¼ ì´ë“¤ ë²„ì „ì„ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30
msgid "Key points:"
msgstr "í‚¤ í¬ì¸íŠ¸:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"* Rust has a rapid release schedule with a new release coming out\n"
"  every six weeks. New releases maintain backwards compatibility with\n"
"  old releases --- plus they enable new functionality."
msgstr "* ëŸ¬ìŠ¤íŠ¸ëŠ” 6ì£¼ë§ˆë‹¤ ìƒˆë¡œìš´ ë¦´ë¦¬ì¦ˆê°€ ë°œí‘œë˜ë©° ì´ì „ ë¦´ë¦¬ì¦ˆì™€ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:27
msgid "* There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "* ë¦´ë¦¬ì¦ˆëŠ” 3ê°€ì§€ ë²„ì „ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤: \"stable\", \"beta\" ê·¸ë¦¬ê³  \"nightly\"."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"* New features are being tested on \"nightly\", \"beta\" is what becomes\n"
"  \"stable\" every six weeks."
msgstr "* ìƒˆë¡œìš´ ê¸°ëŠ¥ì€ \"nightly\" -> \"beta\" -(6ì£¼ í›„)-> \"stable\" ë¡œ ë³€ê²½ë©ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"* Rust also has [editions]: the current edition is Rust 2021. Previous\n"
"  editions were Rust 2015 and Rust 2018."
msgstr "* ëŸ¬ìŠ¤íŠ¸ëŠ” [ì—ë””ì…˜][editions]ìœ¼ë¡œ êµ¬ë¶„ë©ë‹ˆë‹¤. í˜„ì¬ëŠ” Rust 2021 ì—ë””ì…˜ì…ë‹ˆë‹¤. ì´ ì „ ì—ë””ì…˜ìœ¼ë¡œ Rust 2015ì™€ Rust 2018ì´ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:35
msgid ""
"  * The editions are allowed to make backwards incompatible changes to\n"
"    the language."
msgstr "  * ì—ë””ì…˜ì€ ì´ì „ ì—ë””ì…˜ê³¼ í˜¸í™˜ì´ ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:38
msgid ""
"  * To prevent breaking code, editions are opt-in: you select the\n"
"    edition for your crate via the `Cargo.toml` file."
msgstr "  * ì—ë””ì…˜ì´ ë°”ë€Œë©´ì„œ í”„ë¡œê·¸ë¨ì´ ì˜ë„ì¹˜ ì•Šê²Œ ê¹¨ì§€ëŠ” ë¬¸ì œë¥¼ ë§‰ê¸° ìœ„í•´, ê° í”„ë¡œê·¸ë¨ì€ ìì‹ ì´ ë¹Œë“œë  ì—ë””ì…˜ì„ ëª…ì‹œì ìœ¼ë¡œ `Cargo.toml`ì— ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:41
msgid ""
"  * To avoid splitting the ecosystem, Rust compilers can mix code\n"
"    written for different editions."
msgstr "  * ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„ê°€ ì—ë””ì…˜ ë³„ë¡œ íŒŒí¸íšŒ ë˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´, ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ì„œë¡œ ë‹¤ë¥¸ ì—ë””ì…˜ì—ì„œ ì‘ì„±ëœ ì½”ë“œë“¤ì„ í•˜ë‚˜ì˜ ë°”ì´ë„ˆë¦¬ë¡œ ë¬¶ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:44
msgid "  * Mention that it is quite rare to ever use the compiler directly not through `cargo` (most users never do)."
msgstr "  * `cargo`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì»´íŒŒì¼ëŸ¬ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŒì„ ì–¸ê¸‰í•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:46
msgid ""
"  * It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  It is capable of many advanced features including but not limited to: \n"
"      * Project/package structure\n"
"      * [workspaces]\n"
"      * Dev Dependencies and Runtime Dependency management/caching\n"
"      * [build scripting]\n"
"      * [global installation]\n"
"      * It is also extensible with sub command plugins as well (such as [cargo clippy]).\n"
"  * Read more from the [official Cargo Book]"
msgstr ""
"  * ì¹´ê³  ìì²´ê°€ ë§¤ìš° ê°•ë ¥í•˜ê³  í¬ê´„ì ì¸ ë„êµ¬ì„ì„ ì ê·¹ì ìœ¼ë¡œ ì•Œë¦¬ì„¸ìš”.\n"
"  ì¹´ê³ ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë‹¤ì–‘í•œ ê³ ê¸‰ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.\n"
"      * í”„ë¡œì íŠ¸/íŒ¨í‚¤ì§€ êµ¬ì¡°í™”\n"
"      * [ì›Œí¬ìŠ¤í˜ì´ìŠ¤][workspaces]\n"
"      * ê°œë°œ/ëŸ°íƒ€ì„ ì¢…ì†ì„± ê´€ë¦¬ ë° ìºì‹±\n"
"      * [ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸][build scripting]\n"
"      * [ì „ì—­ ì„¤ì¹˜][global installation]\n"
"      * [cargo clippy]ì™€ ê°™ì€ í•˜ìœ„ í”ŒëŸ¬ê·¸ì¸ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥\n"
"  * [ê³µì‹ Cargo Book][official Cargo Book]ì—ì„œ ìì„¸í•œ ì‚¬í•­ì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:55
msgid "[editions]: https://doc.rust-lang.org/edition-guide/"
msgstr "[editions]: https://doc.rust-lang.org/edition-guide/"

#: src/cargo/rust-ecosystem.md:57
msgid "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"
msgstr "[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html"

#: src/cargo/rust-ecosystem.md:59
msgid "[build scripting]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"
msgstr "[build scripting]: https://doc.rust-lang.org/cargo/reference/build-scripts.html"

#: src/cargo/rust-ecosystem.md:61
msgid "[global installation]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"
msgstr "[global installation]: https://doc.rust-lang.org/cargo/commands/cargo-install.html"

#: src/cargo/rust-ecosystem.md:63
msgid "[cargo clippy]: https://github.com/rust-lang/rust-clippy"
msgstr "[cargo clippy]: https://github.com/rust-lang/rust-clippy"

#: src/cargo/rust-ecosystem.md:65
msgid "[official Cargo Book]: https://doc.rust-lang.org/cargo/"
msgstr "[official Cargo Book]: https://doc.rust-lang.org/cargo/"

#: src/cargo/code-samples.md:1
msgid "# Code Samples in This Training"
msgstr "# ê°•ì˜ì—ì„œì˜ ì½”ë“œ ìƒ˜í”Œ"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples\n"
"which can be executed through your browser. This makes the setup much easier and\n"
"ensures a consistent experience for everyone."
msgstr "ì´ ê°•ì˜ìë£Œì— ìˆëŠ” ëª¨ë“  ì˜ˆì œëŠ” ë¸Œë¼ìš°ì €ì—ì„œ ë°”ë¡œ ìˆ˜í–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•œ ì´ìœ ëŠ”, ì¤€ë¹„ ê³¼ì •ì„ ë‹¨ìˆœí™” ì‹œí‚¤ê³ , ëª¨ë‘ê°€ ê°™ì€ í™˜ê²½ì—ì„œ ì‘ì—…í•  ìˆ˜ ìˆë„ë¡ í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do the\n"
"exercises. On the last day, we will do a larger exercise which shows you how to\n"
"work with dependencies and for that you need Cargo."
msgstr "ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ , ì¹´ê³ (cargo)ë¥¼ ì§ì ‘ ì„¤ì¹˜í•˜ëŠ” ê²ƒì„ ê°•ë ¥ ê¶Œì¥í•©ë‹ˆë‹¤. ì´ê²Œ ê³¼ì œ ì‘ì„±ì— ë” ë„ì›€ì´ ë ê²ë‹ˆë‹¤. ë˜í•œ, ë§ˆì§€ë§‰ ë‚ ì—ëŠ” ì˜ì¡´ì„±ì´ ìˆëŠ” ì˜ˆì œë¥¼ ì‘ì—…í•˜ê²Œ ë  í…ë°, ê·¸ ë•Œì—ëŠ” ì–´ì°¨í”¼ ì¹´ê³ ê°€ í•„ìš”í•©ë‹ˆë‹¤."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "ì´ ê°•ì˜ ìë£Œì˜ ì½”ë“œ ë¸”ë¡ë“¤ì€ ì „ë¶€ ì¸í„°ì—‘í‹°ë¸Œ í•©ë‹ˆë‹¤:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"

#: src/cargo/code-samples.md:19
msgid ""
"You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the\n"
"text box."
msgstr "ì½”ë“œ ë¸”ë¡ì— í¬ì»¤ìŠ¤ë¥¼ ë‘ê³  <kbd>Ctrl + Enter</kbd>ë¥¼ ëˆŒëŸ¬ ì‹¤í–‰í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples\n"
"are not editable for various reasons:"
msgstr "ê°•ì˜ì—ì„œ ëŒ€ë¶€ë¶„ì˜ ì½”ë“œ ìƒ˜í”Œì€ ìœ„ì™€ ê°™ì´ ìˆ˜ì •í• ìˆ˜ ìˆì§€ë§Œ ì¼ë¶€ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ë¡œ ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/cargo/code-samples.md:27
msgid ""
"* The embedded playgrounds cannot execute unit tests. Copy-paste the\n"
"  code and open it in the real Playground to demonstrate unit tests."
msgstr "* ìœ ë‹› í…ŒìŠ¤íŠ¸ëŠ” ë‚´ì¥ í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ì´ ì•ˆë©ë‹ˆë‹¤. ì™¸ë¶€ í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì‚¬ì´íŠ¸ì— ë¶™ì—¬ë„£ì–´ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo/code-samples.md:30
msgid ""
"* The embedded playgrounds lose their state the moment you navigate\n"
"  away from the page! This is the reason that the students should\n"
"  solve the exercises using a local Rust installation or via the\n"
"  Playground."
msgstr "* ë‚´ì¥ëœ í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œëŠ” í˜ì´ì§€ ì´ë™ì‹œ ì‘ì„±ëœ ëª¨ë“  ë‚´ìš©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤. ë”°ë¼ì„œ ë¡œì»¬ í™˜ê²½ì´ë‚˜ ì™¸ë¶€ í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì‚¬ì´íŠ¸ì—ì„œ ì—°ìŠµë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/cargo/running-locally.md:1
msgid "# Running Code Locally with Cargo"
msgstr "# ë¡œì»¬ í™˜ê²½ì˜ ì¹´ê³ "

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will need\n"
"to first install Rust. Do this by following the [instructions in the Rust\n"
"Book][1]. This should give you a working `rustc` and `cargo`. At the time of\n"
"writing, the latest stable Rust release has these version numbers:"
msgstr "ë§Œì•½ ê°œì¸ìš© ì»´í“¨í„°ì—ì„œ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë ¤ë©´ ë¨¼ì € ëŸ¬ìŠ¤íŠ¸ë¥¼ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. [Rust Book][1]ì˜ ì§€ì¹¨ì— ë”°ë¼ `rustc`ì™€ `cargo`ë¥¼ í•¨ê»˜ ì„¤ì¹˜ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì„¤ì¹˜ í›„ ì•„ë˜ ì»¤ë§¨ë“œë¥¼ í†µí•´ ê° íˆ´ì˜ ë²„ì „ì„ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.61.0 (fe5b13d68 2022-05-18)\n"
"% cargo --version\n"
"cargo 1.61.0 (a028ae4 2022-04-29)\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:15
msgid ""
"With this is in place, then follow these steps to build a Rust binary from one\n"
"of the examples in this training:"
msgstr "ì •ìƒì ìœ¼ë¡œ ì„¤ì¹˜ê°€ ë˜ì—ˆìœ¼ë©´ ê°•ì˜ì˜ ì½”ë“œ ë¸”ë¡ì¤‘ í•˜ë‚˜ë¥¼ ì•„ë˜ ë‹¨ê³„ë¥¼ ë”°ë¼ ë¡œì»¬ì—ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/cargo/running-locally.md:18
msgid "1. Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "1. ì˜ˆì‹œ ë¸”ë¡ì— ìˆëŠ” \"Copy to clipboard\"ë²„íŠ¼ì„ í´ë¦­í•´ì„œ ë³µì‚¬í•©ë‹ˆë‹¤."

#: src/cargo/running-locally.md:20
msgid "2. Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr "2. í„°ë¯¸ë„ì—ì„œ `cargo new exercise`ë¥¼ ì…ë ¥í•´ì„œ ìƒˆë¡œìš´ `exercise/` í´ë”ë¥¼ ë§Œë“­ë‹ˆë‹¤:"

#: src/cargo/running-locally.md:22
msgid ""
"    ```shell\n"
"    $ cargo new exercise\n"
"         Created binary (application) `exercise` package\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:27
msgid "3. Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr "3. `exercise/` í´ë”ë¡œ ì´ë™í•œ í›„, `cargo run` ì»¤ë§¨ë“œë¡œ ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/cargo/running-locally.md:29
msgid ""
"    ```shell\n"
"    $ cd exercise\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"         Running `target/debug/exercise`\n"
"    Hello, world!\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:38
msgid ""
"4. Replace the boiler-plate code in `src/main.rs` with your own code. For\n"
"   example, using the example on the previous page, make `src/main.rs` look like"
msgstr "4. `src/main.rs`ì— ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì´ì „ í˜ì´ì§€ì˜ ì†ŒìŠ¤ë¥¼ ì•„ë˜ì™€ ê°™ì´ `src/main.rs`ì— ì‘ì„±í•©ë‹ˆë‹¤"

#: src/cargo/running-locally.md:41
msgid ""
"    ```rust\n"
"    fn main() {\n"
"        println!(\"Edit me!\");\n"
"    }\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:47
msgid "5. Use `cargo run` to build and run your updated binary:"
msgstr "5. `cargo run`ì»¤ë§¨ë“œë¡œ ì†ŒìŠ¤ë¥¼ ë¹Œë“œí•˜ê³  ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/cargo/running-locally.md:49
msgid ""
"    ```shell\n"
"    $ cargo run\n"
"       Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"        Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"         Running `target/debug/exercise`\n"
"    Edit me!\n"
"    ```"
msgstr ""

#: src/cargo/running-locally.md:57
msgid ""
"6. Use `cargo check` to quickly check your project for errors, use `cargo build`\n"
"   to compile it without running it. You will find the output in `target/debug/`\n"
"   for a normal debug build. Use `cargo build --release` to produce an optimized\n"
"   release build in `target/release/`."
msgstr "6. `cargo check`ì»¤ë§¨ë“œëŠ” ë¹ ë¥´ê²Œ ì—ëŸ¬ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `cargo build`ëŠ” ì‹¤í–‰ì—†ì´ ì»´íŒŒì¼ë§Œ í•©ë‹ˆë‹¤. ì´ ê²½ìš°ì— `target/debug/`í´ë”ì—ì„œ outputì„ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `cargo build --release`ì»¤ë§¨ë“œëŠ” ë¦´ë¦¬ì¦ˆ ë²„ì „ìš© ìµœì í™”ë¥¼ ì¼œì„œ ì»´íŒŒì¼í•˜ë©° `target/release/`í´ë”ì—ì„œ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/running-locally.md:62
msgid ""
"7. You can add dependencies for your project by editing `Cargo.toml`. When you\n"
"   run `cargo` commands, it will automatically download and compile missing\n"
"   dependencies for you."
msgstr "7. `Cargo.toml`íŒŒì¼ì—ëŠ” ì˜ì¡´ì„± íŒ¨í‚¤ì§€ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `cargo`ì»¤ë§¨ë“œë¥¼ ì‹¤í–‰í•˜ë©´ ìë™ìœ¼ë¡œ ì˜ì¡´ì„± íŒ¨í‚¤ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ê³  ì»´íŒŒì¼ ê¹Œì§€ í•´ ì¤ë‹ˆë‹¤."

#: src/cargo/running-locally.md:66
msgid "[1]: https://doc.rust-lang.org/book/ch01-01-installation.html"
msgstr ""

#: src/cargo/running-locally.md:70
msgid ""
"Try to encourage the class participants to install Cargo and use a\n"
"local editor. It will make their life easier since they will have a\n"
"normal development environment."
msgstr "ìˆ˜ê°•ìƒë“¤ì´ ì¹´ê³ ë¥¼ ì„¤ì¹˜í•˜ê³  ë¡œì»¬ í¸ì§‘ê¸°ë¥¼ ì´ìš©í•˜ë„ë¡ ë…ë ¤í•˜ì„¸ìš”. ì¡°ê¸ˆ ê·€ì°®ì„ ìˆ˜ë„ ìˆì§€ë§Œ, ì´ë ‡ê²Œ í•´ì•¼ë§Œ ì¢€ ë” ì‹¤ì œì™€ ê°€ê¹Œìš´ ê°œë°œí™˜ê²½ì„ ê°–ì¶”ê²Œ ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/welcome-day-1.md:1
msgid "# Welcome to Day 1"
msgstr "# 1ì¼ì°¨ ê°œìš”"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Comprehensive Rust. We will cover a lot of ground\n"
"today:"
msgstr "ê°•ì˜ ì²« ë‚ ì…ë‹ˆë‹¤. ì˜¤ëŠ˜ ë°°ìš¸ ê²ƒì´ ì°¸ ë§ìŠµë‹ˆë‹¤:"

#: src/welcome-day-1.md:6
msgid ""
"* Basic Rust syntax: variables, scalar and compound types, enums, structs,\n"
"  references, functions, and methods."
msgstr "* ëŸ¬ìŠ¤íŠ¸ ê¸°ë³¸ ë¬¸ë²•: ë³€ìˆ˜, ìŠ¤ì¹¼ë¼ / ë³µí•© íƒ€ì…, ì—´ê±°í˜•, êµ¬ì¡°ì²´, ì°¸ì¡°í˜•, í•¨ìˆ˜ì™€ ë©”ì„œë“œ."

#: src/welcome-day-1.md:9
msgid ""
"* Memory management: stack vs heap, manual memory management, scope-based memory\n"
"  management, and garbage collection."
msgstr "* ë©”ëª¨ë¦¬ ê´€ë¦¬: ìŠ¤íƒê³¼ í™, ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬, ìŠ¤ì½”í”„(ë²”ìœ„)ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬, ê°€ë¹„ì§€ ì»¬ë ‰ì…˜(GC)"

#: src/welcome-day-1.md:12
msgid "* Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr "* ì†Œìœ ê¶Œ: Move ë¬¸ë²•, ë³µì‚¬ì™€ ë³µì œ, ë¹Œë¦¼, ìˆ˜ëª…."

#: src/welcome-day-1.md:16
msgid "Please remind the students that:"
msgstr "í•™ìƒë“¤ì—ê²Œ ë‹¤ìŒì„ ìƒê¸°ì‹œì¼œ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/welcome-day-1.md:18
msgid ""
"* They should ask questions when they get them, don't save them to the end.\n"
"* The class is meant to be interactive and discussions are very much encouraged!\n"
"  * As an instructor, you should try to keep the discussions relevant, i.e.,\n"
"    keep the related to how Rust does things vs some other language. It can be\n"
"    hard to find the right balance, but err on the side of allowing discussions\n"
"    since they engage people much more than one-way communication.\n"
"* The questions will likely mean that we talk about things ahead of the slides.\n"
"  * This is perfectly okay! Repetition is an important part of learning. Remember\n"
"    that the slides are just a support and you are free to skip them as you\n"
"    like."
msgstr ""
"* ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ë©´ ì£¼ì €í•˜ì§€ ë§ê³  ì§ˆë¬¸ í•´ì•¼ í•©ë‹ˆë‹¤.\n"
"* ì´ ìˆ˜ì—…ì€ ìƒí˜¸ì‘ìš©ì´ ì¤‘ìš”í•˜ê³  í† ë¡ ì„ ê¶Œì¥í•©ë‹ˆë‹¤.\n"
"  * ê°•ì‚¬ë¡œì„œ í† ë¡ ì´ ì˜†ê¸¸ë¡œ ìƒˆì§€ ì•Šê²Œ ì£¼ì˜í•˜ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´ ëŸ¬ìŠ¤íŠ¸ì™€ ë‹¤ë¥¸ ì–¸ì–´ë“¤ì„ ë¹„êµí•œë‹¤ë“ ì§€ í•˜ëŠ” ê²ƒì€ ì¢‹ìŠµë‹ˆë‹¤. ì ì ˆí•œ ê· í˜•ì„ ì°¾ê¸° ì• ë§¤í•œ ê²½ìš°ë¼ë©´ í† ë¡ ì„ í—ˆìš©í•˜ëŠ” ìª½ì´ ì¼ë°©ì ì¸ ê°•ì˜ë³´ë‹¤ëŠ” ë” ë§ì€ ì‚¬ëŒë“¤ì˜ ì°¸ì—¬ë¥¼ ì´ëŒì–´ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì§ˆë¬¸ì´ ìŠ¬ë¼ì´ë“œë³´ë‹¤ ì•ì„œê°€ë„ ê´œì°®ìŠµë‹ˆë‹¤.\n"
"  * í•™ìŠµì— ìˆì–´ì„œ ë°˜ë³µì€ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ìŠ¬ë¼ì´ë“œëŠ” ê·¸ì € ë„ì›€ì„ ì¤„ ë¿, ì›í•˜ëŠ” ëŒ€ë¡œ ê±´ë„ˆë„ì–´ë„ ë©ë‹ˆë‹¤."

#: src/welcome-day-1.md:29
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to speak\n"
"about the famous borrow checker. The way Rust handles memory is a major feature\n"
"and we should show students this right away."
msgstr "ì²« ë‚  ê°•ì˜ì˜ ëª©í‘œëŠ”, ëŸ¬ìŠ¤íŠ¸ì—ì„œ ê·¸ ìœ ëª…í•œ ë¹Œë¦¼ í™•ì¸ì— ëŒ€í•´ì„œ ì´ì•¼ê¸° í•  ìˆ˜ ìˆì„ ì •ë„ ê¹Œì§€ë§Œ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì†Œê°œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì˜ ê°€ì¥ ë…íŠ¹í•œ íŠ¹ì§•ì´ ë©”ëª¨ë¦¬ë¥¼ ë‹¤ë£¨ëŠ” ë°©ì‹ì´ê¸° ë•Œë¬¸ì—, í•™ìƒë“¤ì—ê²Œ ì´ ë¶€ë¶„ ì„ ìš°ì„ ì ìœ¼ë¡œ ë³´ì—¬ì£¼ë ¤ í•©ë‹ˆë‹¤."

#: src/welcome-day-1.md:33
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the\n"
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr "ë§Œì•½ ë‹¹ì‹ ì´ ê°•ì˜ì‹¤ì—ì„œ ê°€ë¥´ì¹˜ê³  ìˆë‹¤ë©´, ì´ ìŠ¬ë¼ì´ë“œëŠ” ì¼ì •ì„ ê²€í† í•˜ê¸°ì— ì í•©í•œ ê³³ì…ë‹ˆë‹¤. í•˜ë£¨ì¹˜ ê°•ì˜ë¥¼ ì•„ë˜ì²˜ëŸ¼ ì˜¤ì „ ì˜¤í›„ë¡œ ë‚˜ëˆ„ì–´ ì§„í–‰í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤. (ìŠ¬ë¼ì´ë“œê°€ ê·¸ëŸ°ì‹ìœ¼ë¡œë‚˜ë‰˜ì–´ ìˆìŠµë‹ˆë‹¤.)"

#: src/welcome-day-1.md:36
msgid ""
"* Morning: 9:00 to 12:00,\n"
"* Afternoon: 13:00 to 16:00."
msgstr ""
"* ì˜¤ì „: 9:00 ~ 12:00,\n"
"* ì˜¤í›„: 13:00 ~ 16:00."

#: src/welcome-day-1.md:39
msgid ""
"You can of course adjust this as necessary. Please make sure to include breaks,\n"
"we recommend a break every hour!"
msgstr "ë¬¼ë¡  í•„ìš”ì— ë”°ë¼ ì¡°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°•ì˜ ì¤‘ê°„ì— ì‰¬ëŠ”ì‹œê°„ì„ ë„£ëŠ” ê²ƒì„ ìŠì§€ ë§ˆì„¸ìš”. ë§¤ ì‹œê°„ íœ´ì‹ì„ ê°–ëŠ”ê±¸ ì¶”ì²œí•©ë‹ˆë‹¤!"

#: src/welcome-day-1/what-is-rust.md:1
msgid "# What is Rust?"
msgstr "# ëŸ¬ìŠ¤íŠ¸ë€?"

#: src/welcome-day-1/what-is-rust.md:3
msgid "Rust is a new programming language which had its [1.0 release in 2015][1]:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” 2015ë…„ì— [ë²„ì „ 1.0][1]ì„ ë¦´ë¦¬ì¦ˆ í•œ ìƒˆë¡œìš´ í”„ë¡œê·¸ë¨ ì–¸ì–´ì…ë‹ˆë‹¤:"

#: src/welcome-day-1/what-is-rust.md:5
msgid ""
"* Rust is a statically compiled language in a similar role as C++\n"
"  * `rustc` uses LLVM as its backend.\n"
"* Rust supports many [platforms and\n"
"  architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* Rust is used for a wide range of devices:\n"
"  * firmware and boot loaders,\n"
"  * smart displays,\n"
"  * mobile phones,\n"
"  * desktops,\n"
"  * servers."
msgstr ""
"* ëŸ¬ìŠ¤íŠ¸ëŠ” C++ì™€ ìœ ì‚¬í•œ ì •ì  ì»´íŒŒì¼ ì–¸ì–´ì…ë‹ˆë‹¤.\n"
"  * `rustc`ëŠ” LLVMì„ ë°±ì—”ë“œë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ì–‘í•œ í”Œë«í¼ê³¼ ì•„í‚¤í…ì³ë¥¼ ì§€ì›í•©ë‹ˆë‹¤.\n"
"  * x86, ARM, WebAssembly, ...\n"
"  * Linux, Mac, Windows, ...\n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ì–‘í•œ ì¥ì¹˜ì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:\n"
"  * íŒì›¨ì–´ì™€ ë¶€íŠ¸ë¡œë”(ì„ë² ë””ë“œ)\n"
"  * ìŠ¤ë§ˆíŠ¸ ë””ìŠ¤í”Œë ˆì´\n"
"  * ìŠ¤ë§ˆíŠ¸í°\n"
"  * ë°ìŠ¤í¬íƒ‘\n"
"  * ì„œë²„"

#: src/welcome-day-1/what-is-rust.md:21
msgid "Rust fits in the same area as C++:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” C++ê°€ ì‚¬ìš©ë˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ê³³ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/welcome-day-1/what-is-rust.md:23
msgid ""
"* High flexibility.\n"
"* High level of control.\n"
"* Can be scaled down to very constrained devices like mobile phones.\n"
"* Has no runtime or garbage collection.\n"
"* Focuses on reliability and safety without sacrificing performance."
msgstr ""
"* ë†’ì€ ìœ ì—°ì„±.\n"
"* ë†’ì€ ë ˆë²¨ ìˆ˜ì¤€ì˜ ì œì–´.\n"
"* íœ´ëŒ€í°ê³¼ ê°™ì€ ë§¤ìš° ì œí•œëœ ì¥ì¹˜ë¡œ ìŠ¤ì¼€ì¼ ë‹¤ìš´ ê°€ëŠ¥.\n"
"* ë³„ë„ì˜ ëŸ°íƒ€ì„ì„ í•„ìš”ë¡œ í•˜ì§€ ì•Šìœ¼ë©°, ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ë„ ì—†ìŒ.\n"
"* ì„±ëŠ¥ì„ íƒ€í˜‘í•˜ì§€ ì•Šìœ¼ë©´ì„œë„ ì•ˆì •ì„±ê³¼ ì•ˆì „ì— ì¤‘ì ì„ ë‘ ."

#: src/welcome-day-1/what-is-rust.md:31
msgid "[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html"
msgstr ""

#: src/hello-world.md:1
msgid "# Hello World!"
msgstr "# Hello World!"

#: src/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World\n"
"program:"
msgstr "ê°€ì¥ ê°„ë‹¨í•œ ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ìœ¼ë¡œì¨, ê³ ì „ì ì¸ Hello World ë¥¼ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/hello-world.md:6
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Hello ğŸŒ!\");\n"
"}\n"
"```"
msgstr ""

#: src/hello-world.md:12
msgid "What you see:"
msgstr "í™•ì¸í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤:"

#: src/hello-world.md:14
msgid ""
"* Functions are introduced with `fn`.\n"
"* Blocks are delimited by curly braces like in C and C++.\n"
"* The `main` function is the entry point of the program.\n"
"* Rust has hygienic macros, `println!` is an example of this.\n"
"* Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"* í•¨ìˆ˜ëŠ” `fn`ìœ¼ë¡œ ì„ ì–¸í•©ë‹ˆë‹¤.\n"
"* C/C++ ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì¤‘ê´„í˜¸`{}`ë¡œ ë¸”ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.\n"
"* `main` í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ ì§„ì…ì ì…ë‹ˆë‹¤.\n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ë˜‘ë˜‘í•œ ë§¤í¬ë¡œ(hygienic macros) ì‹œìŠ¤í…œì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. `println!`ëŠ” ê·¸ ì˜ˆì‹œì…ë‹ˆë‹¤.\n"
"* ëŸ¬ìŠ¤íŠ¸ì˜ ë¬¸ìì—´ì€ UTF-8ë¡œ ì¸ì½”ë”©ë˜ë©° ì´ëª¨ì§€ì™€ ê°™ì€ ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/hello-world.md:22
msgid ""
"This slide tries to make the students comfortable with Rust code. They will see\n"
"a ton of it over the next four days so we start small with something familiar."
msgstr "ì´ ìŠ¬ë¼ì´ë“œëŠ” í•™ìƒë“¤ì´ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œì— ìµìˆ™í•´ì§€ê¸° ìœ„í•´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì•ìœ¼ë¡œ 4ì¼ ë™ì•ˆ ë§ì€ ì½”ë“œë¥¼ ì ‘í•  ê²ƒì´ê¸° ë•Œë¬¸ì— ìš°ì„  ì¹œìˆ™í•œ ì½”ë“œë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤."

#: src/hello-world.md:27
msgid ""
"* Rust is very much like other languages in the C/C++/Java tradition. It is\n"
"  imperative (not functional) and it doesn't try to reinvent things unless\n"
"  absolutely necessary."
msgstr "* ëŸ¬ìŠ¤íŠ¸ëŠ” C/C++/Javaì™€ ê°™ì€ ì „í†µì ì¸ ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ì ˆì°¨ì (í•¨ìˆ˜í˜• ì•„ë‹˜) ì–¸ì–´ì…ë‹ˆë‹¤. ì •ë§ë¡œ í•„ìš”í•œ ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´, ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²ƒì„ ìƒˆë¡œ êµ¬í˜„í•˜ë ¤ê³  í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/hello-world.md:31
msgid "* Rust is modern with full support for things like Unicode."
msgstr "* ëŸ¬ìŠ¤íŠ¸ëŠ” ìœ ë‹ˆì½”ë“œ ì§€ì›ê³¼ ê°™ì€ í˜„ëŒ€ ì–¸ì–´ì˜ íŠ¹ì§•ì„ ì „ë¶€ ì§€ì›í•©ë‹ˆë‹¤."

#: src/hello-world.md:33
msgid ""
"* Rust uses macros for situations where you want to have a variable number of\n"
"  arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr "* ëŸ¬ìŠ¤íŠ¸ëŠ” ì¸ìì˜ ê°œìˆ˜ë¥¼ ì‚¬ì „ì— ì§€ì •í•  ìˆ˜ ì—†ëŠ” ìƒí™©ì—ì„œ í•¨ìˆ˜ [ì˜¤ë²„ë¡œë”©](basic-syntax/functions-interlude.md)ëŒ€ì‹  ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/hello-world/small-example.md:1
msgid "# Small Example"
msgstr "# ì‘ì€ ì˜ˆì œ"

#: src/hello-world/small-example.md:3
msgid "Here is a small example program in Rust:"
msgstr "ëŸ¬ìŠ¤íŠ¸ë¡œ ì‘ì„±ëœ ì‘ì€ ì˜ˆì œì…ë‹ˆë‹¤:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {              // í”„ë¡œê·¸ë¨ ì§„ì…ì ì…ë‹ˆë‹¤.\n"
"    let mut x: i32 = 6;  // ê°€ë³€ ë³€ìˆ˜ í• ë‹¹(binding)ì…ë‹ˆë‹¤.\n"
"    print!(\"{x}\");       // printfì™€ ê°™ì€ ì¶œë ¥ì„ ìœ„í•œ ë§¤í¬ë¡œ ì…ë‹ˆë‹¤.\n"
"    while x != 1 {       // í‘œí˜„ì‹ì— ê´„í˜¸ëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
"        if x % 2 == 0 {  // ë‹¤ë¥¸ ì–¸ì–´ì™€ ê°™ì€ ìˆ˜í•™ì—°ì‚°ì‹ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"

#: src/hello-world/small-example.md:23
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop will\n"
"always end, but this is not yet proved. Edit the code and play with different\n"
"inputs."
msgstr "ì´ ì½”ë“œëŠ” ì½œë¼ì¸  ì¶”ì¸¡(Collatz conjecture)ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤: ë°˜ë³µë¬¸ì´ ì–¸ì œë‚˜ ì¢…ë£Œë  ê²ƒì´ë¼ê³  ë¯¿ì§€ë§Œ ì¦ëª…ëœ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. ì½”ë“œë¥¼ ìˆ˜ì •í•˜ê³  ì‹¤í–‰í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/hello-world/small-example.md:29
msgid ""
"* Explain that all variables are statically typed. Try removing `i32` to trigger\n"
"  type inference. Try with `i8` instead and trigger a runtime integer overflow."
msgstr "* ëª¨ë“  ë³€ìˆ˜ê°€ ì»´íŒŒì¼ ì‹œ ì •í•´ì§„ íƒ€ì…ì„ ê°€ì§ì„ ì„¤ëª…í•©ë‹ˆë‹¤. `i32`ë¥¼ ì‚­ì œí•˜ì—¬ ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ ì„ í•˜ë„ë¡ í•´ ë´…ë‹ˆë‹¤. `i32`ì„ `i8`ë¡œ ë³€ê²½í•˜ì—¬ ëŸ°íƒ€ì„ ì˜¤ë²„í”Œë¡œë¥¼ ìœ ë°œí•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/hello-world/small-example.md:32
msgid "* Change `let mut x` to `let x`, discuss the compiler error."
msgstr "* `let mut x`ë¥¼ `let x`ë¡œ ìˆ˜ì •í•˜ì—¬ ì»´íŒŒì¼ ì˜¤ë¥˜ì— ëŒ€í•´ í† ë¡ í•©ë‹ˆë‹¤."

#: src/hello-world/small-example.md:34
msgid ""
"* Show how `print!` gives a compilation error if the arguments don't match the\n"
"  format string."
msgstr "* ì¸ìê°€ í¬ë§· ë¬¸ìì—´ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ê²½ìš° `print!`ì—ì„œ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•¨ì„ ì–¸ê¸‰í•˜ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤."

#: src/hello-world/small-example.md:37
msgid ""
"* Show how you need to use `{}` as a placeholder if you want to print an\n"
"  expression which is more complex than just a single variable."
msgstr "* ë‹¨ì¼ ë³€ìˆ˜ë³´ë‹¤ ë³µì¡í•œ ì‹ì„ ì¶œë ¤í•˜ë ¤ë©´ `{}`ì„ ìë¦¬ í‘œì‹œìë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ ì¤ë‹ˆë‹¤."

#: src/hello-world/small-example.md:40
msgid ""
"* Show the students the standard library, show them how to search for `std::fmt`\n"
"  which has the rules of the formatting mini-language. It's important that the\n"
"  students become familiar with searching in the standard library."
msgstr "* í•™ìƒë“¤ì—ê²Œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì–´ë”” ìˆëŠ”ì§€ ì•Œë ¤ ì£¼ê³ ëŠ”, `print!`ê°€ ì§€ì›í•˜ëŠ” í¬ë§·íŒ… ì–¸ì–´ì˜ ë¬¸ë²•ì„ ì•Œê¸° ìœ„í•´ `std::fmt`ë¥¼ ê²€ìƒ‰í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ê°€ë¥´ì¹˜ì„¸ìš”.í•™ìƒë“¤ì´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê²€ìƒ‰ ê¸°ëŠ¥ì— ìµìˆ™í•´ ì§€ë„ë¡ í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤."

#: src/why-rust.md:1
msgid "# Why Rust?"
msgstr "# ëŸ¬ìŠ¤íŠ¸ë¥¼ ì¨ì•¼í•˜ëŠ” ì´ìœ "

#: src/why-rust.md:3
msgid "Some unique selling points of Rust:"
msgstr "ëŸ¬ìŠ¤íŠ¸ë§Œì˜ ë…íŠ¹í•œ ì„¸ì¼ì¦ˆ í¬ì¸íŠ¸(ì¥ì ):"

#: src/why-rust.md:5
msgid ""
"* Compile time memory safety.\n"
"* Lack of undefined runtime behavior.\n"
"* Modern language features."
msgstr ""
"* ì»´íŒŒì¼ ì‹œ ë©”ëª¨ë¦¬ ì•ˆì „ì´ ë³´ì¥ë¨.\n"
"* ì •ì˜ë˜ì§€ ì•Šì€ ëŸ°íƒ€ì„ ë™ì‘ì´ ì—†ìŒ.\n"
"* í˜„ëŒ€ì ì¸ ì–¸ì–´ ê¸°ëŠ¥."

#: src/why-rust.md:11
msgid ""
"Make sure to ask the class which languages they have experience with. Depending\n"
"on the answer you can highlight different features of Rust:"
msgstr "ìˆ˜ê°•ìƒë“¤ì—ê²Œ ì–´ë–¤ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í–ˆëŠ”ì§€ ë¬¼ì–´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤. ì–´ë–¤ ì–¸ì–´ë¥¼ ì‚¬ìš©í–ˆëŠëƒì— ë”°ë¼ ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì–´ë–¤ ì ì„ ê°•ì¡°í•´ì•¼ í• ì§€ë¥¼ ê³ ë¯¼í•´ ë³´ì„¸ìš”:"

#: src/why-rust.md:14
msgid ""
"* Experience with C or C++: Rust eliminates a whole class of _runtime errors_\n"
"  via the borrow checker. You get performance like in C and C++, but you don't\n"
"  have the memory unsafety issues. In addition, you get a modern language with\n"
"  constructs like pattern matching and built-in dependency management."
msgstr "* C/C++: ëŸ¬ìŠ¤íŠ¸ëŠ” 'ë¹Œë¦¼'ê²€ì‚¬ê¸°ë¥¼ í†µí•´ì„œ ìˆ˜í–‰ì¤‘ì— ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ì—ëŸ¬ë¥¼ ì œê±°í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” Cì™€ C++ê³¼ ë¹„ìŠ·í•œ ìˆ˜ì¤€ì˜ ì„±ëŠ¥ì„ ë³´ì—¬ì£¼ë©´ì„œë„, ê·¸ ì–¸ì–´ë“¤ì—ì„œ ì¢…ì¢… ë°œìƒí•˜ëŠ” ë©”ëª¨ë¦¬ ê´€ë ¨ ì˜¤ë¥˜ê°€ ì—†ìŠµë‹ˆë‹¤. ë˜í•œ, íŒ¨í„´ ë§¤ì¹­ì´ë‚˜, ê¸°ë³¸ì ìœ¼ë¡œ ì œê³µë˜ëŠ” ì¢…ì†ì„± ê´€ë¦¬ì™€ ê°™ì€ í˜„ëŒ€ì ì¸ ì–¸ì–´ì˜ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/why-rust.md:19
msgid ""
"* Experience with Java, Go, Python, JavaScript...: You get the same memory safety\n"
"  as in those languages, plus a similar high-level language feeling. In addition\n"
"  you get fast and predictable performance like C and C++ (no garbage collector)\n"
"  as well as access to low-level hardware (should you need it)"
msgstr "* Java, Go, Python, JaveScript: ì´ ì–¸ì–´ë“¤ê³¼ ë™ì¼í•œ ë©”ëª¨ë¦¬ ì•ˆì •ì„±ê³¼ í•¨ê»˜, 'í•˜ì´ë ˆë²¨'ì–¸ì–´ì˜ ëŠë‚Œì„ ëŠë‚„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê±°ê¸°ì— ë”í•´, ê°€ë¹„ì§€ ì»¬ë ‰í„°ê°€ ì—†ëŠ” C/C++ì™€ ìœ ì‚¬í•œ ìˆ˜ì¤€ì˜ ë¹ ë¥´ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì„±ëŠ¥ì„ ê¸°ëŒ€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  í•„ìš”í•œ ê²½ìš° ì €ìˆ˜ì¤€ í•˜ë“œì›¨ì–´ë¥¼ ë‹¤ë£¨ëŠ” ì½”ë“œë¡œ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/why-rust/compile-time.md:1
msgid "# Compile Time Guarantees"
msgstr "# ì»´íŒŒì¼ ì‹œ ë³´ì¥ë˜ëŠ” ê²ƒë“¤"

#: src/why-rust/compile-time.md:3
msgid "Static memory management at compile time:"
msgstr "ì»´íŒŒì¼ ì‹œ ì •ì  ë©”ëª¨ë¦¬ ê´€ë¦¬:"

#: src/why-rust/compile-time.md:5
msgid ""
"* No uninitialized variables.\n"
"* No memory leaks (_mostly_, see notes).\n"
"* No double-frees.\n"
"* No use-after-free.\n"
"* No `NULL` pointers.\n"
"* No forgotten locked mutexes.\n"
"* No data races between threads.\n"
"* No iterator invalidation."
msgstr ""
"* ì´ˆê¸°í™”ë˜ì§€ ì•ŠëŠ” ë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.\n"
"* ë©”ëª¨ë¦¬ ëˆ„ì¶œ ì—†ìŒ(_ê±°ì˜_. ê°•ì˜ì°¸ì¡°ë…¸íŠ¸ ì°¸ê³ .)\n"
"* ë©”ëª¨ë¦¬ ì´ì¤‘ í•´ì œê°€ ì›ì²œì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥ í•©ë‹ˆë‹¤.\n"
"* ë©”ëª¨ë¦¬ í•´ì œ í›„ ì‚¬ìš©ì´ ì›ì²œì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥ í•©ë‹ˆë‹¤.\n"
"* `NULL`í¬ì¸í„°ëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
"* ë®¤í…ìŠ¤ë¥¼ ì ê¶ˆ ë†“ê³  ì—¬ëŠ” ê²ƒì„ ìŠëŠ” ì‹¤ìˆ˜ë¥¼ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
"* ìŠ¤ë ˆë“œê°„ ë°ì´í„° ë ˆì´ìŠ¤ë¥¼ ë§‰ì•„ì¤ë‹ˆë‹¤.\n"
"* ë°˜ë³µìê°€ ê°‘ìê¸° ë¬´íš¨í™” ë˜ëŠ” ê²½ìš°ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/why-rust/compile-time.md:16
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples\n"
"are:"
msgstr "(ì•ˆì „í•œ) ëŸ¬ìŠ¤íŠ¸ì—ì„œë„ ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª‡ ê°€ì§€ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/why-rust/compile-time.md:19
msgid ""
"* You can for use [`Box::leak`] to leak a pointer. A use of this could\n"
"  be to get runtime-initialized and runtime-sized static variables\n"
"* You can use [`std::mem::forget`] to make the compiler \"forget\" about\n"
"  a value (meaning the destructor is never run).\n"
"* You can also accidentally create a [reference cycle] with `Rc` or\n"
"  `Arc`.\n"
"* In fact, some will consider infinitely populating a collection a memory\n"
"  leak and Rust does not protect from those."
msgstr ""
"* [`Box::leak`]ì„ ì´ìš©í•˜ì—¬ í¬ì¸í„°ë¥¼ ì˜ë„ì ìœ¼ë¡œ ëˆ„ì¶œì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•´ì„œ ëŸ°íƒ€ì„ì´ ìƒì„±í•˜ê³  ëŸ°íƒ€ì„ì´ í¬ê¸°ë¥¼ ì •í•œ ì •ì  ë³€ìˆ˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* [`std::mem::forget`]ì„ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼ëŸ¬ê°€ ê°’ì— ëŒ€í•´ \"ìŠë„ë¡\" ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì†Œë©¸ìê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤).\n"
"* `Rc` ë˜ëŠ” `Arc`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤ìˆ˜ë¡œ [ìˆœí™˜ì°¸ì¡°][reference cycle]ë¥¼ ìƒì„±í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.\n"
"* ì»¬ë ‰ì…˜ì„ ë¬´í•œì • ì±„ìš°ëŠ” ê²ƒì„ ë©”ëª¨ë¦¬ ëˆ„ì¶œë¡œ ê°„ì£¼í•  ìˆ˜ë„ ìˆì§€ë§Œ, ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ë¥¼ ë³´í˜¸í•˜ì§„ ëª»í•©ë‹ˆë‹¤."

#: src/why-rust/compile-time.md:28
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood\n"
"as \"Pretty much no *accidental* memory leaks\"."
msgstr "ë³¸ ê°•ì˜ì—ì„œëŠ” \"ë©”ëª¨ë¦¬ ëˆ„ì¶œ ì—†ìŒ\"ì„ \"ìš°ë°œì ì¸ ë©”ëª¨ë¦¬ ëˆ„ì¶œ ì—†ìŒ\"ìœ¼ë¡œ ì´í•´í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/why-rust/compile-time.md:31
msgid ""
"[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n"
"[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n"
"[reference cycle]: https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"
msgstr ""

#: src/why-rust/runtime.md:1
msgid "# Runtime Guarantees"
msgstr "# ëŸ°íƒ€ì„ ì‹œ ë³´ì¥ë˜ëŠ” ê²ƒë“¤"

#: src/why-rust/runtime.md:3
msgid "No undefined behavior at runtime:"
msgstr "ëŸ°íƒ€ì„ ì‹œ ì •ì˜ë˜ì§€ ì•ŠìŒ(undefined) ë™ì‘ ì—†ìŒ:"

#: src/why-rust/runtime.md:5
msgid ""
"* Array access is bounds checked.\n"
"* Integer overflow is defined."
msgstr ""
"* ë°°ì—´ ì ‘ê·¼ì‹œ ê²½ê³„ ì²´í¬\n"
"* ì •ìˆ˜í˜• íƒ€ì…ì˜ ë³€ìˆ˜ì—ì„œ ì˜¤ë²„í”Œë¡œìš° ë°œìƒì‹œ ë™ì‘ì´ ì˜ ì •ì˜ë˜ì–´ìˆìŠµë‹ˆë‹¤."

#: src/why-rust/runtime.md:12
msgid ""
"* Integer overflow is defined via a compile-time flag. The options are\n"
"  either a panic (a controlled crash of the program) or wrap-around\n"
"  semantics. By default, you get panics in debug mode (`cargo build`)\n"
"  and wrap-around in release mode (`cargo build --release`)."
msgstr "* ì •ìˆ˜í˜• ì˜¤ë²„í”Œë¡œìš°ëŠ” ì»´íŒŒì¼ íƒ€ì„ í”Œë ˆê·¸ë¥¼ í†µí•´ ì •ì˜ë©ë‹ˆë‹¤. ì˜µì…˜ì€ íŒ¨ë‹‰(í”„ë¡œê·¸ë¨ í¬ë ˆì‹œ) í˜¹ì€ ì˜¬ë¦¼(wrap-around)ì…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ë””ë²„ê·¸ ëª¨ë“œ(`cargo build`)ì—ì„œëŠ” íŒ¨ë‹‰ì´, ë¦´ë¦¬ì¦ˆ ëª¨ë“œ(`cargo build --release`)ì—ì„œëŠ” wrap-aroundê°€ ë°œìƒí•©ë‹ˆë‹¤."

#: src/why-rust/runtime.md:17
msgid ""
"* Bounds checking cannot be disabled with a compiler flag. It can also\n"
"  not be disabled directly with the `unsafe` keyword. However,\n"
"  `unsafe` allows you to call functions such as `slice::get_unchecked`\n"
"  which does not do bounds checking."
msgstr "* ì»´íŒŒì¼ í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²½ê³„ì²´í¬ë¥¼ ë¬´ë ¥í™” í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `unsafe`ë¥¼ ì‚¬ìš©í•˜ë”ë¼ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ `unsafe`ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ `slice::get_unchecked`ê°™ì€ í•¨ìˆ˜ëŠ” ê²½ê³„ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/why-rust/modern.md:1
msgid "# Modern Features"
msgstr "# í˜„ëŒ€ì ì¸ íŠ¹ì§•"

#: src/why-rust/modern.md:3
msgid "Rust is built with all the experience gained in the last 40 years."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì§€ë‚œ 40ë…„ê°„ì˜ ëª¨ë“  (í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë“¤ì˜) ê²½í—˜ìœ¼ë¡œ ë§Œë“¤ì–´ì¡ŒìŠµë‹ˆë‹¤."

#: src/why-rust/modern.md:5
msgid "## Language Features"
msgstr "## ì–¸ì–´ì  íŠ¹ì§•"

#: src/why-rust/modern.md:7
msgid ""
"* Enums and pattern matching.\n"
"* Generics.\n"
"* No overhead FFI.\n"
"* Zero-cost abstractions."
msgstr ""
"* ì—´ê±°í˜•ê³¼ íŒ¨í„´ ë§¤ì¹­.\n"
"* ì œë„¤ë¦­.\n"
"* FFI ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ ì—†ìŒ.\n"
"  * _ì—­ì£¼: FFI: Foreign Function Interface. íƒ€ ì–¸ì–´ ì½”ë“œë¥¼ í˜¸ì¶œí•˜ê¸° ìœ„í•œ ì¸í„°í˜ì´ìŠ¤_\n"
"* ì œë¡œ ì½”ìŠ¤íŠ¸ ì¶”ìƒí™”."

#: src/why-rust/modern.md:12
msgid "## Tooling"
msgstr "## ë„êµ¬ë“¤"

#: src/why-rust/modern.md:14
msgid ""
"* Great compiler errors.\n"
"* Built-in dependency manager.\n"
"* Built-in support for testing.\n"
"* Excellent Language Server Protocol support."
msgstr ""
"* ì¹œì ˆí•œ ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ë©”ì‹œì§€.\n"
"* ë‚´ì¥ ì¢…ì†ì„± ê´€ë¦¬ì.\n"
"* ë‚´ì¥ í…ŒìŠ¤íŠ¸ ì§€ì›.\n"
"* LSP (Language Server Protocol, ì–¸ì–´ ì„œë²„ í”„ë¡œí† ì½œ) ì§€ì›ì´ ì˜ë˜ì–´ ìˆìŒ."

#: src/why-rust/modern.md:23
msgid ""
"* Zero-cost abstractions, similar to C++, means that you don't have to 'pay'\n"
"  for higher-level programming constructs with memory or CPU. For example,\n"
"  writing a loop using `for` should result in roughly the same low level\n"
"  instructions as using the `.iter().fold()` construct."
msgstr "* C++ ì™€ ìœ ì‚¬í•˜ê²Œ ì œë¡œ ì½”ìŠ¤íŠ¸ ì¶”ìƒí™”ëŠ” CPUë‚˜ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒìœ„ë ˆë²¨ í”„ë¡œê·¸ë˜ë° êµ¬ì¡°ë¥¼ ë§Œë“œëŠ”ë° 'ë¹„ìš©'ì„ ì§€ë¶ˆí•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `for` ë£¨í”„ì™€ì™€ `iter().fold()` êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ê±°ì˜ ë™ì¼í•œ ë‚®ì€ ìˆ˜ì¤€ì˜ ëª…ë ¹ì–´ê°€ ìƒì„±ë  ê²ƒ ì…ë‹ˆë‹¤."

#: src/why-rust/modern.md:28
msgid ""
"* It may be worth mentioning that Rust enums are 'Algebraic Data Types', also\n"
"  known as 'sum types', which allow the type system to express things like\n"
"  `Option<T>` and `Result<T, E>`."
msgstr "* ëŸ¬ìŠ¤íŠ¸ì˜ ì—´ê±°í˜•(enum)ì€ í•©ê³„ íƒ€ì…(sum type)ìœ¼ë¡œ ì•Œë ¤ì§„ ëŒ€ìˆ˜í•™ì  ë°ì´í„°í˜•(Algebraic Data Type)ìœ¼ë¡œ, íƒ€ì… ì‹œìŠ¤í…œì´ `Option<T>`ì™€ `Result<T, E>`ë“±ì„ í‘œí˜„í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤."

#: src/why-rust/modern.md:32
msgid ""
"* Remind people to read the errors --- many developers have gotten used to\n"
"  ignore lengthy compiler output. The Rust compiler is significantly more\n"
"  talkative than other compilers. It will often provide you with _actionable_\n"
"  feedback, ready to copy-paste into your code."
msgstr "* ì˜¤ë¥˜ë¥¼ ì½ì–´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤ --- ì˜¤ëœê¸°ê°„ ë§ì€ ê°œë°œìë“¤ì´ ì»´íŒŒì¼ëŸ¬ ì¶œë ¥ì„ ë¬´ì‹œí•˜ëŠ”ë° ìµìˆ™í•´ì ¸ ìˆìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ë¥¸ ì»´íŒŒì¼ëŸ¬ë³´ë‹¤ ë” ìˆ˜ë‹¤ìŠ¤ëŸ½ê³ , ë³µì‚¬-ë¶™ì—¬ë„£ê¸° í•  ìˆ˜ ìˆëŠ” ì •ë„ì˜ ì½”ë“œ í”¼ë“œë°±ì„ ì œê³µí•˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤."

#: src/why-rust/modern.md:37
msgid ""
"* The Rust standard library is small compared to languages like Java, Python,\n"
"  and Go. Rust does not come with several things you might consider standard and\n"
"  essential:"
msgstr "* ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” Java, Pythonì´ë‚˜ Goì™€ ê°™ì€ ì–¸ì–´ì— ë¹„í•´ì„œ ê·œëª¨ê°€ ì‘ìŠµë‹ˆë‹¤. ë‹¹ì—°íˆ í¬í•¨ë˜ì–´ì•¼ í•œë‹¤ê³  ìƒê°í•  ìˆ˜ë„ ìˆëŠ” ì•„ë˜ì™€ ê°™ì€ ê²ƒë“¤ì´ ëŸ¬ìŠ¤íŠ¸ì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì—†ìŠµë‹ˆë‹¤:"

#: src/why-rust/modern.md:41
msgid ""
"  * a random number generator, but see [rand].\n"
"  * support for SSL or TLS, but see [rusttls].\n"
"  * support for JSON, but see [serde_json]."
msgstr ""
"  * ë‚œìˆ˜ ìƒì„±ê¸°, í•˜ì§€ë§Œ [rand]ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"  * SSL ë˜ëŠ” TLSì§€ì›, í•˜ì§€ë§Œ [rusttls]ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"  * JSON ì§€ì›, í•˜ì§€ë§Œ [serde_json] ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/why-rust/modern.md:45
msgid ""
"  The reasoning behind this is that functionality in the standard library cannot\n"
"  go away, so it has to be very stable. For the examples above, the Rust\n"
"  community is still working on finding the best solution --- and perhaps there\n"
"  isn't a single \"best solution\" for some of these things."
msgstr "  ê·¸ ì´ìœ ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ í•œ ë²ˆ ì–´ë–¤ ê¸°ëŠ¥ì„ ì œê³µí•˜ë©´ ëº„ ìˆ˜ ì—†ìœ¼ë©°, ë§¤ìš° ì•ˆì •ì ì´ì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ìœ„ì— ì–¸ê¸‰í•œ ê¸°ëŠ¥ë“¤ì€ ì•„ì§ ëŸ¬ìŠ¤íŠ¸ ì»¤ë®¤ë‹ˆí‹°ê°€ ìµœê³ ì˜ ì†”ë£¨ì…˜ì„ ì°¾ì§€ ëª»í–ˆê¸° ë•Œë¬¸ì— í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— í¬í•¨ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì–´ì©Œë©´ ì´ë“¤ ì¤‘ ëª‡ ê°œëŠ” 'ìµœê³ ì˜ ì†”ë£¨ì…˜'ì´ ì•„ì˜ˆ ì¡´ì¬í•  ìˆ˜ ì—†ì„ ì§€ë„ ëª¨ë¦…ë‹ˆë‹¤."

#: src/why-rust/modern.md:50
msgid ""
"  Rust comes with a built-in package manager in the form of Cargo and this makes\n"
"  it trivial to download and compile third-party crates. A consequence of this\n"
"  is that the standard library can be smaller."
msgstr "  ëŸ¬ìŠ¤íŠ¸ëŠ” ì¹´ê³ ë¼ëŠ” íŒ¨í‚¤ì§€ ê´€ë¦¬ìê°€ ë‚´ì¥ë˜ì–´ ìˆê³ , ì„œë“œíŒŒí‹° í¬ë ˆì´íŠ¸ë¥¼ ë‹¤ìš´ë¡œë“œ, ì»´íŒŒì¼ í•˜ê¸° ë§¤ìš° ì‰½ìŠµë‹ˆë‹¤. ì´ ë˜í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì‘ì€ ì´ìœ ì…ë‹ˆë‹¤."

#: src/why-rust/modern.md:54
msgid ""
"  Discovering good third-party crates can be a problem. Sites like\n"
"  <https://lib.rs/> help with this by letting you compare health metrics for\n"
"  crates to find a good and trusted one.\n"
"  \n"
"* [rust-analyzer] is a well supported LSP implementation used in major\n"
"  IDEs and text editors."
msgstr ""
"  ì¢‹ì€ ì„œë“œíŒŒí‹° í¬ë ˆì´íŠ¸ë¥¼ ì°¾ëŠ” ê²ƒì€ ì–´ë µìŠµë‹ˆë‹¤. <https://lib.rs> ì™€ ê°™ì€ ì‚¬ì´íŠ¸ê°€ ì‹ ë¢°í• ìˆ˜ ìˆëŠ” ì¢‹ì€ í¬ë ˆì´íŠ¸ë¥¼ ë¹„êµí•˜ì—¬ ì°¾ëŠ”ë° ì¢‹ìŠµë‹ˆë‹¤.\n"
"* [rust-analyzer]ëŠ” ì£¼ìš” IDEë‚˜ í…ìŠ¤íŠ¸ ì—ë””í„°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ëŸ¬ìŠ¤íŠ¸ìš© LSPì„œë²„ ì…ë‹ˆë‹¤."

#: src/why-rust/modern.md:61
msgid ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"
msgstr ""
"[rand]: https://docs.rs/rand/\n"
"[rusttls]: https://docs.rs/rustls/\n"
"[serde_json]: https://docs.rs/serde_json/\n"
"[rust-analyzer]: https://rust-analyzer.github.io/"

#: src/basic-syntax.md:1
msgid "# Basic Syntax"
msgstr "# ê¸°ë³¸ ë¬¸ë²•"

#: src/basic-syntax.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "ëŒ€ë¶€ë¶„ì˜ ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•ì€ C/C++/Java ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤:"

#: src/basic-syntax.md:5
msgid ""
"* Blocks and scopes are delimited by curly braces.\n"
"* Line comments are started with `//`, block comments are delimited by `/* ...\n"
"  */`.\n"
"* Keywords like `if` and `while` work the same.\n"
"* Variable assignment is done with `=`, comparison is done with `==`."
msgstr ""
"* ë¸”ë¡ê³¼ ë²”ìœ„ëŠ” ì¤‘ê´„í˜¸`{}`ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.\n"
"* ì¸ë¼ì¸ ì£¼ì„ì€ `//`, ë¸”ë¡ ì£¼ì„ì€ `/* ... */`ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"* `if`ë‚˜ `while`ê°™ì€ í‚¤ì›Œë“œë„ ë™ì¼í•©ë‹ˆë‹¤.\n"
"* ë³€ìˆ˜ í• ë‹¹ì€ `=`, ë¹„êµëŠ” `==`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/basic-syntax/scalar-types.md:1
msgid "# Scalar Types"
msgstr "# ìŠ¤ì¹¼ë¼ íƒ€ì…"

#: src/basic-syntax/scalar-types.md:3
msgid ""
"|                        | Types                                      | Literals                      |\n"
"|------------------------|--------------------------------------------|-------------------------------|\n"
"| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123i64` |\n"
"| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10u16`           |\n"
"| Floating point numbers | `f32`, `f64`                               | `3.14`, `-10.0e20`, `2f32`    |\n"
"| Strings                | `&str`                                     | `\"foo\"`, `r#\"\\\\\"#`            |\n"
"| Unicode scalar values  | `char`                                     | `'a'`, `'Î±'`, `'âˆ'`           |\n"
"| Byte strings           | `&[u8]`                                    | `b\"abc\"`, `br#\" \" \"#`         |\n"
"| Booleans               | `bool`                                     | `true`, `false`               |"
msgstr ""
"|                 | íƒ€ì…                                       | ìŠ¤ì¹¼ë¼ ë¦¬í„°ëŸ´ ê°’              |\n"
"|-----------------|--------------------------------------------|-------------------------------|\n"
"| ë¶€í˜¸ìˆëŠ” ì •ìˆ˜   | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123i64` |\n"
"| ë¶€í˜¸ì—†ëŠ” ì •ìˆ˜   | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10u16`           |\n"
"| ë¶€ë™ì†Œìˆ˜        | `f32`, `f64`                               | `3.14`, `-10.0e20`, `2f32`    |\n"
"| ë¬¸ìì—´          | `&str`                                     | `\"foo\"`, `r#\"\\\\\"#`      |\n"
"| ìœ ë‹ˆì½”ë“œ ë¬¸ì   | `char`                                     | `'a'`, `'Î±'`, `'âˆ'`           |\n"
"| ë°”ì´íŠ¸ ë¬¸ì     | `&[u8]`                                    | `b\"abc\"`, `br#\" \" \"#`    |\n"
"| ë¶ˆë¦¬ì–¸          | `bool`                                     | `true`, `false`               |"

#: src/basic-syntax/scalar-types.md:13
msgid "The types have widths as follows:"
msgstr "ê° íƒ€ì…ì˜ í¬ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/basic-syntax/scalar-types.md:15
msgid ""
"* `iN`, `uN`, and `fN` are _N_ bits wide,\n"
"* `isize` and `usize` are the width of a pointer,\n"
"* `char` is 32 bit wide,\n"
"* `bool` is 8 bit wide."
msgstr ""
"* ì •ìˆ˜(`i`) ë° ë¶€ë™ì†Œìˆ˜í˜•(`f`)ì€ ë’¤ì˜ ìˆ«ìì™€ ê°™ì€ ë¹„íŠ¸ ìˆ˜ ì…ë‹ˆë‹¤. (`i8` = 8ë¹„íŠ¸)\n"
"* `isize` ì™€ `usize` ëŠ” í¬ì¸í„°ì™€ ê°™ì€ í¬ê¸°ì…ë‹ˆë‹¤.\n"
"  * _ì—­ì£¼: 32 ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œëŠ” 32 ë¹„íŠ¸, 64 ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œëŠ” 64 ë¹„íŠ¸. Cì˜ `int`ì™€ ê°™ìŒ._\n"
"* `char` 32 ë¹„íŠ¸ ì…ë‹ˆë‹¤.\n"
"* `bool`ì€ 8 ë¹„íŠ¸ ì…ë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:1
msgid "# Compound Types"
msgstr "# ë³µí•© íƒ€ì…"

#: src/basic-syntax/compound-types.md:3
msgid ""
"|        | Types                         | Literals                          |\n"
"|--------|-------------------------------|-----------------------------------|\n"
"| Arrays | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| Tuples | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"
msgstr ""
"|      | íƒ€ì…                          | ë¦¬í„°ëŸ´                            |\n"
"|------|-------------------------------|-----------------------------------|\n"
"| ë°°ì—´ | `[T; N]`                      | `[20, 30, 40]`, `[0; 3]`          |\n"
"| íŠœí”Œ | `()`, `(T,)`, `(T1, T2)`, ... | `()`, `('x',)`, `('x', 1.2)`, ... |"

#: src/basic-syntax/compound-types.md:8
msgid "Array assignment and access:"
msgstr "ë°°ì—´ ì„ ì–¸ê³¼ ì ‘ê·¼:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:18
msgid "Tuple assignment and access:"
msgstr "íŠœí”Œ ì„ ì–¸ê³¼ ì ‘ê·¼:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:32
msgid "Arrays:"
msgstr "ë°°ì—´:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"* Arrays have elements of the same type, `T`, and length, `N`, which is a compile-time constant.\n"
"  Note that the length of the array is *part of its type*, which means that `[u8; 3]` and\n"
"  `[u8; 4]` are considered two different types."
msgstr "* ë°°ì—´ì€, ê°™ì€ íƒ€ì… `T`ì˜ ê°’ì´ `N`ê°œ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ `N`ì€ ì»´íŒŒì¼ íƒ€ì„ì— ê²°ì •ëœ ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ ê¸¸ì´ë„ íƒ€ì…ì˜ ì¼ë¶€ì…ë‹ˆë‹¤. ë”°ë¼ì„œ, `[u8; 3]`ì™€ `[u8; 4]`ì€ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì…ë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:38
msgid "* We can use literals to assign values to arrays."
msgstr "* ë¦¬í„°ëŸ´ì„ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ì— ê°’ì„ í• ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:40
msgid ""
"* In the main function, the print statement asks for the debug implementation with the `?` format\n"
"  parameter: `{}` gives the default output, `{:?}` gives the debug output. We\n"
"  could also have used `{a}` and `{a:?}` without specifying the value after the\n"
"  format string."
msgstr "* í¬ë§¤íŒ… ë¬¸ìì—´ì—ì„œ `?`ëŠ” ë””ë²„ê¹… ì¶œë ¥ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. `{}`ëŠ” ê¸°ë³¸ ì¶œë ¥ì´ë©°, `{:?}`ëŠ” ë””ë²„ê¹… ì¶œë ¥ì…ë‹ˆë‹¤. `{a}`ì™€ `{a:?}`ì™€ ê°™ì´ ì¶œë ¥í•  ë³€ìˆ˜ ì´ë¦„ì„ í¬ë§¤íŒ… ë¬¸ìì—´ì— í¬í•¨ì‹œí‚¬ ìˆ˜ë„ ìˆìœ¼ë©°, ì´ ê²½ìš° ì¸ì `a`ëŠ” ë³„ë„ì˜ ì¸ìë¡œ ì¶”ê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:45
msgid "* Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be easier to read."
msgstr "* `#`ì„ ì¶”ê°€í•˜ë©´(`{a:#?}`) ì¢€ ë” ì½ê¸° ì‰¬ìš´ \"ì´ìœ\" í˜•íƒœë¡œ ì¶œë ¥ì´ ë©ë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:47
msgid "Tuples:"
msgstr "íŠœí”Œ:"

#: src/basic-syntax/compound-types.md:49
msgid "* Like arrays, tuples have a fixed length."
msgstr "* ë°°ì—´ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ íŠœí”Œì€ ê³ ì • ê¸¸ì´ë¥¼ ê°–ìŠµë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:51
msgid "* Tuples group together values of different types into a compound type."
msgstr "* íŠœí”Œì€ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì˜ ê°’ë“¤ì„ í•˜ë‚˜ì˜ ë³µí•© íƒ€ì…ìœ¼ë¡œ ë¬¶ìŠµë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:53
msgid "* Fields of a tuple can be accessed by the period and the index of the value, e.g. `t.0`, `t.1`."
msgstr "* íŠœí”Œì— ì†í•œ ê°’ì€ `t.0`, `t.1`ê³¼ ê°™ì´ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/basic-syntax/compound-types.md:55
msgid ""
"* The empty tuple `()` is also known as the \"unit type\". It is both a type, and\n"
"  the only valid value of that type - that is to say both the type and its value\n"
"  are expressed as `()`. It is used to indicate, for example, that a function or\n"
"  expression has no return value, as we'll see in a future slide. \n"
"    * You can think of it as `void` that can be familiar to you from other \n"
"      programming languages."
msgstr ""
"* ë¹„ì–´ìˆëŠ” íŠœí”Œ`()`ì€ ë‹¨ìœ„ íƒ€ì…(unit type)ì´ë¼ê³ ë„ í•©ë‹ˆë‹¤. ì´ëŠ” íƒ€ì…ì´ë©´ì„œ í•´ë‹¹ íƒ€ì…ì˜ ìœ ì¼í•˜ë©° ìœ íš¨í•œ ê°’ì…ë‹ˆë‹¤. ì¦‰ íƒ€ì…ê³¼ ê°’ì´ ëª¨ë‘ `()`ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í•¨ìˆ˜ë‚˜ ì‹ì—ì„œ ë°˜í™˜ ê°’ì´ ì—†ìŒì„ ë‚˜íƒ€ë‚¼ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"  * ë‹¤ë¥¸ ì–¸ì–´ì—ì„œ ìµìˆ™í•œ `void` ê°œë…ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/basic-syntax/references.md:1
msgid "# References"
msgstr "# ì°¸ì¡°"

#: src/basic-syntax/references.md:3
msgid "Like C++, Rust has references:"
msgstr "C++ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ëŸ¬ìŠ¤íŠ¸ë„ ì°¸ì¡°í˜•ì„ ê°–ìŠµë‹ˆë‹¤:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
msgid "Some notes:"
msgstr "ì°¸ê³ ì‚¬í•­:"

#: src/basic-syntax/references.md:16
msgid ""
"* We must dereference `ref_x` when assigning to it, similar to C and C++ pointers.\n"
"* Rust will auto-dereference in some cases, in particular when invoking\n"
"  methods (try `ref_x.count_ones()`).\n"
"* References that are declared as `mut` can be bound to different values over their lifetime."
msgstr ""
"* `ref_x`ì— ê°’ì„ í• ë‹¹í•  ë•Œ, C/C++ì˜ í¬ì¸í„°ì™€ ìœ ì‚¬í•˜ê²Œ `*`ë¥¼ ì´ìš©í•´ì„œ ì°¸ì¡°ë¥¼ ë”°ë¼ê°€ì•¼(ì—­ì°¸ì¡°) í•©ë‹ˆë‹¤.\n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” íŠ¹ì •í•œ ê²½ìš°(ë©”ì„œë“œ í˜¸ì¶œ)ì— ìë™ìœ¼ë¡œ ì—­ì°¸ì¡°ë¥¼ í•©ë‹ˆë‹¤.(`ref_x.count_one()`ì„ í•˜ë©´ `*ref_x`ê°€ `count_one`ì˜ ì¸ìë¡œ ì „ë‹¬ë©ë‹ˆë‹¤.)\n"
"* `mut`ë¡œ ì„ ì–¸ëœ ì°¸ì¡°ëŠ” ê·¸ ë³€ìˆ˜ê°€ ì‚´ì•„ìˆëŠ” ë™ì•ˆ ë‹¤ë¥¸ ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/basic-syntax/references.md:21
msgid ""
"<details>\n"
"Key points:"
msgstr ""
"<details>\n"
"í‚¤ í¬ì¸íŠ¸:"

#: src/basic-syntax/references.md:24
msgid ""
"* Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x:\n"
"  &mut i32`. The first one represents a mutable reference which can be bound to\n"
"  different values, while the second represents a reference to a mutable value."
msgstr "* `let mut ref_x: &i32`ì™€ `let ref_x: &mut i32`ì˜ ì°¨ì´ì ì— ì£¼ì˜ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì²«ë²ˆì§¸ ê°’ì€ ë‹¤ë¥¸ ê°’ì— ë°”ì¸ë”© ë  ìˆ˜ ìˆëŠ” ê°€ë³€ ì°¸ì¡°ì´ê³ , ë‘ë²ˆì§¸ ê°’ì€ ê°€ë³€ ê°’ì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤."

#: src/basic-syntax/references-dangling.md:1
msgid "# Dangling References"
msgstr "# í—ˆìƒ(dangling) ì°¸ì¡°"

#: src/basic-syntax/references-dangling.md:3
msgid "Rust will statically forbid dangling references:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” í—ˆìƒ(dangling) ì°¸ì¡°ë¥¼ ì»´íŒŒì¼ëŸ¬ ë‹¨ê³„ì—ì„œ ì°¾ì•„ë‚´ê³  ê¸ˆì§€í•©ë‹ˆë‹¤:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
msgid ""
"* A reference is said to \"borrow\" the value it refers to.\n"
"* Rust is tracking the lifetimes of all references to ensure they live long\n"
"  enough.\n"
"* We will talk more about borrowing when we get to ownership."
msgstr ""
"* ì°¸ì¡°ëŠ” ì–´ë–¤ ê°’ì„ \"ë¹Œë¦¬ëŠ”\" ê²ƒì…ë‹ˆë‹¤.\n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ì°¸ì¡° ëŒ€ìƒì˜ ê°’ì´, ê·¸ ê°’ì— ëŒ€í•œ ëª¨ë“  ì°¸ì¡°ë“¤ë³´ë‹¤ ë” ì˜¤ë˜ ì‚´ì•„ìˆìŒì„ ì¶”ì í•©ë‹ˆë‹¤.\n"
"* ì†Œìœ ê¶Œì— ëŒ€í•œ ì£¼ì œë¥¼ ë‹¤ë£° ë•Œ ì´ ë¹Œë¦¼ì— ëŒ€í•´ ë” ìì„¸íˆ ì´ì•¼ê¸° í•˜ê² ìŠµë‹ˆë‹¤."

#: src/basic-syntax/slices.md:1
msgid "# Slices"
msgstr "# ìŠ¬ë¼ì´ìŠ¤"

#: src/basic-syntax/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "ìŠ¬ë¼ì´ìŠ¤ëŠ” í° ì»¬ë™ì…˜ì˜ ì¼ë¶€(í˜¹ì€ ì „ì²´)ë¥¼ ë³´ì—¬ì£¼ëŠ” ë·°(view)ì…ë‹ˆë‹¤:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");"
msgstr ""

#: src/basic-syntax/slices.md:10
msgid ""
"    let s: &[i32] = &a[2..4];\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:15
msgid ""
"* Slices borrow data from the sliced type.\n"
"* Question: What happens if you modify `a[3]`?"
msgstr ""
"* ìŠ¬ë¼ì´ìŠ¤ëŠ” ë‹¤ë¥¸(ìŠ¬ë¼ì´ìŠ¤ ëœ) íƒ€ì…ìœ¼ë¡œë¶€í„° ë°ì´í„°ë¥¼ 'ë¹Œë ¤'ì˜µë‹ˆë‹¤.\n"
"* ì§ˆë¬¸: `a[3]`ì„ ìˆ˜ì •í•˜ë©´ ë¬´ìŠ¨ ì¼ì´ ìˆì–´ë‚ ê¹Œìš”?"

#: src/basic-syntax/slices.md:20
msgid "* We create a slice by borrowing `a` and specifying the starting and ending indexes in brackets."
msgstr "* ìŠ¬ë¼ì´ìŠ¤ëŠ” ìš°ì„  `a`ë¥¼ ë¹Œë¦°ë‹¤ìŒ, ì‹œì‘ê³¼ ë ì¸ë±ìŠ¤ë¥¼ ë¸Œë˜í‚·(`[]`)ì•ˆì— ì§€ì •í•´ì„œ ë§Œë“­ë‹ˆë‹¤."

#: src/basic-syntax/slices.md:22
msgid ""
"* If the slice starts at index 0, Rustâ€™s range syntax allows us to drop the starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are identical.\n"
"    \n"
"* The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are identical."
msgstr ""
"* ìŠ¬ë¼ì´ìŠ¤ê°€ ì¸ë±ìŠ¤ 0ë¶€í„° ì‹œì‘í•œë‹¤ë©´ ì‹œì‘ ì¸ë±ìŠ¤ëŠ” ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì¦‰ `&a[0..a.len()]`ì™€ `&a[..a.len()]` ëŠ” ë™ì¼í•©ë‹ˆë‹¤.\n"
"* ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë„ ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ `&a[2..a.len()]` ì™€ `&a[2..]`ëŠ” ë™ì¼í•©ë‹ˆë‹¤."

#: src/basic-syntax/slices.md:26
msgid "* To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "* ë”°ë¼ì„œ ì „ì²´ ë°°ì—´ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ëŠ” `&a[..]`ê°€ ë©ë‹ˆë‹¤."

#: src/basic-syntax/slices.md:28
msgid ""
"* `s` is a reference to a slice of `i32`s. Notice that the type of `s` (`&[i32]`) no longer mentions the array length. This allows us to perform computation on slices of different sizes.\n"
" \n"
"* Slices always borrow from another object. In this example, `a` has to remain 'alive' (in scope) for at least as long as our slice. \n"
"    \n"
"* The question about modifying `a[3]` can spark an interesting discussion, but the answer is that for memory safety reasons\n"
"  you cannot do it through `a` after you created a slice, but you can read the data from both `a` and `s` safely. \n"
"  More details will be explained in the borrow checker section."
msgstr ""
"* `s`ëŠ” `i32`ë“¤ë¡œ ì´ë£¨ì–´ì§„ ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤. `s`ì˜ íƒ€ì…(`&[i32]`)ì— ë°°ì—´ì˜ í¬ê¸°ê°€ ë¹ ì ¸ìˆìŒì— ì£¼ëª©í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì¦‰, ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì´ìš©í•˜ë©´ ë‹¤ì–‘í•œ ê¸¸ì´ì˜ ë°ì´í„°ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ìŠ¬ë¼ì´ìŠ¤ëŠ” í•­ìƒ ë‹¤ë¥¸ ê°ì²´ë¡œë¶€í„° 'ë¹Œë ¤' ì˜µë‹ˆë‹¤. ì´ ì˜ˆì‹œì—ì„œ ê°ì²´ `a`ëŠ” ìŠ¬ë¼ì´ìŠ¤ `s`ë³´ë‹¤ ë” ì˜¤ë˜ ì‚´ì•„ ìˆì–´ì•¼ë§Œ í•©ë‹ˆë‹¤.\n"
"* `a[3]`ì˜ ê°’ì„ ë°”ê¿€ ìˆ˜ ìˆëƒëŠ” ì§ˆë¬¸ì€ ì¢‹ì€ ì§ˆë¬¸ì…ë‹ˆë‹¤. ì—¬ê¸°ì— ëŒ€í•œ ë‹µì€ `a`ì™€ `s`ë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ëŠ” ìˆì§€ë§Œ ìˆ˜ì •í•  ìˆ˜ëŠ” ì—†ìœ¼ë©°, ì´ëŠ” ë©”ëª¨ë¦¬ ì•ˆì „ì„ ìœ„í•´ì„œë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ì™œ ê·¸ëŸ°ì§€ì— ëŒ€í•œ ì¢€ë” êµ¬ì²´ì ì¸ ë‹µì€ ë¹Œë¦¼ ê²€ì‚¬ ë¶€ë¶„ì—ì„œ ìì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤."

#: src/basic-syntax/string-slices.md:1
msgid "# `String` vs `str`"
msgstr "# `String`ê³¼ `str`"

#: src/basic-syntax/string-slices.md:3
msgid "We can now understand the two string types in Rust:"
msgstr "ì´ì œ ëŸ¬ìŠ¤íŠ¸ì˜ ë‘ ê°€ì§€ ë¬¸ìì—´ íƒ€ì…ì— ëŒ€í•´ì„œ ì´í•´í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");"
msgstr ""

#: src/basic-syntax/string-slices.md:10
msgid ""
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/string-slices.md:20
msgid "Rust terminology:"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìš©ì–´:"

#: src/basic-syntax/string-slices.md:22
msgid ""
"* `&str` an immutable reference to a string slice.\n"
"* `String` a mutable string buffer."
msgstr ""
"* `&str`ì€ ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•œ (ë¶ˆë³€) ì°¸ì¡°ì…ë‹ˆë‹¤.\n"
"* `String`ì€ ë¬¸ìì—´ì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ë²„í¼ì…ë‹ˆë‹¤."

#: src/basic-syntax/string-slices.md:27
msgid ""
"* `&str` introduces a string slice, which is an immutable reference to UTF-8 encoded string data \n"
"  stored in a block of memory. String literals (`â€Helloâ€`), are stored in the programâ€™s binary."
msgstr "* `&str`ì€ ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì˜ ë¶ˆë³€ ì°¸ì¡°ì…ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì—ì„œ ë¬¸ìì—´ì€ UTF-8ë¡œ ì¸ì½”ë”©ëœ ë°ì´í„°ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ë¬¸ìì—´ ë¦¬í„°ëŸ´(`\"Hello\"`)ì€ í”„ë¡œê·¸ë¨ ë°”ì´ë„ˆë¦¬ì— ì €ì¥ë©ë‹ˆë‹¤."

#: src/basic-syntax/string-slices.md:30
msgid ""
"* Rustâ€™s `String` type is a wrapper around a vector of bytes. As with a `Vec<T>`, it is owned.\n"
"    \n"
"* As with many other types `String::from()` creates a string from a string literal; `String::new()` \n"
"  creates a new empty string, to which string data can be added using the `push()` and `push_str()` methods."
msgstr ""
"* ëŸ¬ìŠ¤íŠ¸ì˜ `String`íƒ€ì…ì€ ì‹¤ì œë¡œëŠ” ë¬¸ìì—´ì„ ì´ë£¨ëŠ” ë°”ì´íŠ¸ì— ëŒ€í•œ ë°±í„°(`Vec<u8>`)ì…ë‹ˆë‹¤. `Vec<T>`ê°€ `T`ë¥¼ ì†Œìœ í•˜ê³  ìˆë“¯ì´, `String`ì´ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ë¬¸ìì—´ì€ `String`ì˜ ì†Œìœ ì…ë‹ˆë‹¤.\n"
"* ë‹¤ë¥¸ ë§ì€ íƒ€ì…ë“¤ì²˜ëŸ¼ `String::from`ëŠ” ë¬¸ìì—´ ë¦¬í„°ëŸ´ë¡œë¶€í„° ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤. `String::new()`ëŠ” ìƒˆë¡œìš´ ë¹ˆ ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤. `push()`ì™€ `push_str()`ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¬¸ìì—´ ë°ì´í„°ë¥¼ ì¶”ê°€ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/basic-syntax/string-slices.md:35
msgid ""
"* The `format!()` macro is a convenient way to generate an owned string from dynamic values. It \n"
"  accepts the same format specification as `println!()`.\n"
"    \n"
"* You can borrow `&str` slices from `String` via `&` and optionally range selection.\n"
"    \n"
"* For C++ programmers: think of `&str` as `const char*` from C++, but the one that always points \n"
"  to a valid string in memory. Rust `String` is a rough equivalent of `std::string` from C++ \n"
"  (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).\n"
"    \n"
"</details>"
msgstr ""
"* `format!()` ë§¤í¬ë¡œëŠ” ë³€ìˆ˜ì˜ ê°’ì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ëŠ” í¸ë¦¬í•œ ë°©ë²•ì…ë‹ˆë‹¤. ì´ ë§¤í¬ë¡œëŠ” `println!()` ë§¤í¬ë¡œì™€ ë™ì¼í•œ í¬ë§·íŒ… í˜•ì‹ì„ ì§€ì›í•©ë‹ˆë‹¤.\n"
"* `&`ì™€ ë²”ìœ„ ì—°ì‚°ìë¥¼ ì´ìš©í•˜ì—¬ `String`ì—ì„œ `&str`ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë¹Œë ¤ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ë‹¹ì‹ ì´ C++ í”„ë¡œê·¸ë˜ë¨¸ ë¼ë©´: `&str`ëŠ” C++ì˜ `const char*`ì™€ ìœ ì‚¬í•˜ì§€ë§Œ í•­ìƒ ìœ íš¨í•œ ë¬¸ìì—´ì„ ê°€ë¦¬í‚¨ë‹¤ëŠ” ì ì´ ë‹¤ë¦…ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì˜ `String`ì€ C++ì˜ `std::string` ê³¼ ëŒ€ëµ ê±°ì˜ ë™ì¼í•©ë‹ˆë‹¤. (ì£¼ìš” ì°¨ì´ì : ëŸ¬ìŠ¤íŠ¸ì˜ `String`ì€ UTF-8 ì¸ì½”ë”© ë°”ì´íŠ¸ë§Œ í¬í•¨í•  ìˆ˜ ìˆìœ¼ë©° ì‘ì€ ë¬¸ìì—´ ìµœì í™”(small-string optimization)ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/basic-syntax/functions.md:1
msgid "# Functions"
msgstr "# í•¨ìˆ˜"

#: src/basic-syntax/functions.md:3
msgid "A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) interview question:"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë²„ì „ì˜ [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) í•¨ìˆ˜ì…ë‹ˆë‹¤:"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
"}"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    fizzbuzz_to(20);   //C/C++ ì™€ ë‹¬ë¦¬ í˜¸ì¶œë¶€ í•˜ë‹¨ì— ì •ì˜í•´ë„ ë¬¸ì œ ì—†ìŠµë‹ˆë‹¤.\n"
"}"

#: src/basic-syntax/functions.md:10
msgid ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return value\n"
"}"
msgstr ""
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner caseì´ë¯€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"    }\n"
"    lhs % rhs == 0     // ë§ˆì§€ë§‰ í‘œí˜„ì‹ì€ ë°˜í™˜ ê°’ì…ë‹ˆë‹¤.(;ì—†ìŒì— ì£¼ëª©)\n"
"}"

#: src/basic-syntax/functions.md:17
msgid ""
"fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit type `()`\n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"
msgstr ""
"fn fizzbuzz(n: u32) -> () {  // `()`ëŠ” ë°˜í™˜ê°’ì´ ì—†ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. \n"
"    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
"        (true,  true)  => println!(\"fizzbuzz\"),\n"
"        (true,  false) => println!(\"fizz\"),\n"
"        (false, true)  => println!(\"buzz\"),\n"
"        (false, false) => println!(\"{n}\"),\n"
"    }\n"
"}"

#: src/basic-syntax/functions.md:26
msgid ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn fizzbuzz_to(n: u32) {  // `-> ()` ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ìƒëµí•©ë‹ˆë‹¤.\n"
"    for i in 1..=n {\n"
"        fizzbuzz(i);\n"
"    }\n"
"}\n"
"```"

#: src/basic-syntax/functions.md:35
msgid ""
"* We refer in `main` to a function written below. Neither forward declarations nor headers are necessary. \n"
"* Declaration parameters are followed by a type (the reverse of some programming languages), then a return type.\n"
"* The last expression in a function body (or any block) becomes the return value. Simply omit the `;` at the end of the expression.\n"
"* Some functions have no return value, and return the 'unit type', `()`. The compiler will infer this if the `-> ()` return type is omitted.\n"
"* The range expression in the `for` loop in `fizzbuzz_to()` contains `=n`, which causes it to include the upper bound.\n"
"* The `match` expression in `fizzbuzz()` is doing a lot of work. It is expanded below to show what is happening."
msgstr ""
"* `main` í•¨ìˆ˜ì—ì„œ ê·¸ ë‹¤ìŒì— ì˜¤ëŠ” í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒë‹¨ì— ì„ ì–¸ì´ë‚˜ í—¤ë” ê°™ì€ê±´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.\n"
"* ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œì—ëŠ” ì´ë¦„ì„ ë¨¼ì € ì“°ê³ , íƒ€ì…ì„ ë‚˜ì¤‘ì— ì”ë‹ˆë‹¤. ì´ë¦„ê³¼ íƒ€ì…ì€ `:` ë¡œ êµ¬ë¶„í•©ë‹ˆë‹¤. ì´ëŠ” ì¼ë¶€ ì–¸ì–´(ì˜ˆë¥¼ ë“¤ì–´ C)ì™€ ë°˜ëŒ€ì„ì— ìœ ì˜í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ, ë¦¬í„´ íƒ€ì…ë„ í•¨ìˆ˜ì˜ ì‹œì‘ì´ ì•„ë‹Œ ê°€ì¥ ë’·ë¶€ë¶„ì— ì„ ì–¸í•©ë‹ˆë‹¤.\n"
"* í•¨ìˆ˜ ë³¸ë¬¸ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì€ ë°˜í™˜ ê°’ì´ ë©ë‹ˆë‹¤. ê°„ë‹¨íˆ, ì‹ ëì— ìˆëŠ” `;`ë¥¼ ìƒëµí•˜ë©´ ë©ë‹ˆë‹¤.\n"
"* ë°˜í™˜ê°’ì´ ì—†ëŠ” í•¨ìˆ˜ì˜ ê²½ìš°, ìœ ë‹› íƒ€ì… `()`ì„ ë°˜í™˜í•©ë‹ˆë‹¤. `-> ()`ê°€ ìƒëµëœ ê²½ìš° ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì¶”ë¡ í•©ë‹ˆë‹¤.\n"
"* `fizzbuzz_to()`í•¨ìˆ˜ ë‚´ `for` ë°˜ëª©ë¬¸ì˜ ë²”ìœ„ í‘œí˜„ì‹ ì¤‘ `=n`ì€ nê¹Œì§€ í¬í•¨í•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.\n"
"* `fizzbuzz()`í•¨ìˆ˜ì˜ `match` í‘œí˜„ì‹ì€ ë§ì€ ì¼ì„ í•©ë‹ˆë‹¤. ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì¡°ê¸ˆ ë” ì´í•´í•˜ê¸° ì‰½ë„ë¡ ì•„ë˜ ì½”ë“œë¥¼ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/basic-syntax/functions.md:42
msgid "  (Type annotations added for clarity, but they can be elided.)"
msgstr "  (ëª…í™•í•œ ì„¤ëª…ì„ ìœ„í•´ íƒ€ì…ì´ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸ ë˜ì—ˆì§€ë§Œ ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤.)"

#: src/basic-syntax/functions.md:44
msgid ""
"  ```rust,ignore\n"
"  let by_3: bool = is_divisible_by(n, 3);\n"
"  let by_5: bool = is_divisible_by(n, 5);\n"
"  let by_35: (bool, bool) = (by_3, by_5);\n"
"  match by_35 {\n"
"    // ...\n"
"  ```"
msgstr ""

#: src/basic-syntax/functions.md:52
msgid "  "
msgstr ""

#: src/basic-syntax/methods.md:1 src/methods.md:1
msgid "# Methods"
msgstr "# ë©”ì„œë“œ"

#: src/basic-syntax/methods.md:3
msgid ""
"Rust has methods, they are simply functions that are associated with a particular type. The\n"
"first argument of a method is an instance of the type it is associated with:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ì„œë“œëŠ” íŠ¹ì • íƒ€ì…ê³¼ ì—°ê²°ëœ í•¨ìˆ˜ì…ë‹ˆë‹¤. ë©”ì„œë“œì˜ ì²«ë²ˆì§¸ ì¸ìì˜ íƒ€ì…ì´ ë°”ë¡œ ê·¸ ë©”ì„œë“œê°€ ì—°ê²°ëœ íƒ€ì…ì…ë‹ˆë‹¤:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}"
msgstr ""

#: src/basic-syntax/methods.md:12
msgid ""
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }"
msgstr ""

#: src/basic-syntax/methods.md:17
msgid ""
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}"
msgstr ""

#: src/basic-syntax/methods.md:22
msgid ""
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:30
msgid "* We will look much more at methods in today's exercise and in tomorrow's class."
msgstr "* ì˜¤ëŠ˜ê³¼ ë‚´ì¼ ê°•ì˜ì—ì„œ ë” ë§ì€ ë©”ì„œë“œ ì‚¬ìš©ë²•ì„ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/basic-syntax/functions-interlude.md:1
msgid "# Function Overloading"
msgstr "# (í•¨ìˆ˜) ì˜¤ë²„ë¡œë”©"

#: src/basic-syntax/functions-interlude.md:3
msgid "Overloading is not supported:"
msgstr "ì˜¤ë²„ë¡œë”©ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/basic-syntax/functions-interlude.md:5
msgid ""
"* Each function has a single implementation:\n"
"  * Always takes a fixed number of parameters.\n"
"  * Always takes a single set of parameter types.\n"
"* Default values are not supported:\n"
"  * All call sites have the same number of arguments.\n"
"  * Macros are sometimes used as an alternative."
msgstr ""
"* ê°œë³„í•¨ìˆ˜ëŠ” ë‹¨ì¼ êµ¬í˜„ë§Œ ê°–ìŠµë‹ˆë‹¤.\n"
"  * í•­ìƒ ê³ ì •ëœ ìˆ˜ì˜ íŒŒë¼ë§¤í„°ë§Œ ê°–ìŠµë‹ˆë‹¤.\n"
"  * íŒŒë¼ë§¤í„°ë“¤ì˜ íƒ€ì…ì€ í•­ìƒ ê³ ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.\n"
"* íŒŒë¼ë§¤í„°ì˜ ê¸°ë³¸ ê°’ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"  * ëª¨ë“  í˜¸ì¶œë¶€ì—ì„œëŠ” ë™ì¼í•œ ìˆ˜ì˜ ì¸ìë¥¼ ì„¤ì •í•´ì•¼í•©ë‹ˆë‹¤. \n"
"  * ì´ëŸ° ì‚¬í•­ë“¤ì´ ì œì•½ì´ ë  ê²½ìš°, ëŒ€ì•ˆìœ¼ë¡œ ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ê¸°ë„ í•©ë‹ˆë‹¤."

#: src/basic-syntax/functions-interlude.md:12
msgid "However, function parameters can be generic:"
msgstr "í•˜ì§€ë§Œ, í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ëŠ” ì œë„¤ë¦­ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}"
msgstr ""

#: src/basic-syntax/functions-interlude.md:19
msgid ""
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions-interlude.md:27
msgid ""
"* When using generics, the standard library's `Into<T>` can provide a kind of limited\n"
"  polymorphism on argument types. We will see more details in a later section."
msgstr "* ì œë„¤ë¦­ì„ ì‚¬ìš©í•  ë•Œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `Into<T>`ì€ íƒ€ì…ì— ëŒ€í•œ ë‹¤í˜•ì„±ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚˜ì¤‘ì— ìì„¸íˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤."

#: src/basic-syntax/functions-interlude.md:30
msgid "</defails>"
msgstr ""

#: src/exercises/day-1/morning.md:1
msgid "# Day 1: Morning Exercises"
msgstr "# 1ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-1/morning.md:3
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ë‘ ë¶€ë¶„ì„ ì•Œì•„ë³¼ ê²ƒì…ë‹ˆë‹¤:"

#: src/exercises/day-1/morning.md:5
msgid "* Implicit conversions between types."
msgstr "* íƒ€ì…ì˜ ë¬µì‹œì  ë³€í™˜."

#: src/exercises/day-1/morning.md:7
msgid "* Arrays and `for` loops."
msgstr "* ë°°ì—´ê³¼ `for` ë°˜ë³µë¬¸."

#: src/exercises/day-1/morning.md:11
msgid "A few things to consider while solving the exercises:"
msgstr "ì—°ìŠµë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ë° ê³ ë ¤í•´ì•¼ í•  ì‚¬í•­ë“¤:"

#: src/exercises/day-1/morning.md:13
msgid ""
"* Use a local Rust installation, if possible. This way you can get\n"
"  auto-completion in your editor. See the page about [Using Cargo] for details\n"
"  on installing Rust."
msgstr "* ê°€ëŠ¥í•˜ë‹¤ë©´ ëŸ¬ìŠ¤íŠ¸ê°€ ì„¤ì¹˜ëœ ë¡œì»¬ í™˜ê²½ì—ì„œ ì§„í–‰í•˜ì„¸ìš”. ê·¸ëŸ¬ëŠ” í¸ì´ í…ìŠ¤íŠ¸ ì—ë””í„°ì˜ ìë™ì™„ì„± ê¸°ëŠ¥ì˜ ë„ì›€ì„ ë°›ì„ ìˆ˜ ìˆì–´ì„œ ì¢‹ìŠµë‹ˆë‹¤. [ì¹´ê³  ì‚¬ìš©í•˜ê¸°][Using Cargo] ì„ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/exercises/day-1/morning.md:17
msgid "* Alternatively, use the Rust Playground."
msgstr "* í˜¹ì€ ëŸ¬ìŠ¤íŠ¸ í”Œë ˆì´ê·¸ë¼ìš´ë“œë¥¼ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-1/morning.md:19
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose\n"
"their state if you navigate away from the page."
msgstr "í˜ì´ì§€ ë°–ìœ¼ë¡œ ì´ë™í•  ê²½ìš° ì‘ì„±í•œ ë‚´ìš©ì´ ì†Œì‹¤ë˜ê¸° ë•Œë¬¸ì— ì œê³µë˜ëŠ” ì½”ë“œ ìŠ¤ë‹ˆí«ì€ ì˜ë„ì ìœ¼ë¡œ í¸ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/exercises/day-1/morning.md:22 src/exercises/day-1/afternoon.md:11
#: src/exercises/day-2/morning.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/day-3/morning.md:7 src/exercises/day-4/morning.md:12
msgid "After looking at the exercises, you can look at the [solutions] provided."
msgstr "ì—°ìŠµë¬¸ì œë¥¼ ì‚´í´ ë³¸ í›„, ì œê³µëœ [í•´ë‹µ][solutions]ì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-1/morning.md:24 src/exercises/day-2/morning.md:13
#: src/exercises/day-3/morning.md:9 src/exercises/day-4/morning.md:14
msgid "[solutions]: solutions-morning.md"
msgstr ""

#: src/exercises/day-1/morning.md:26
msgid "[Using Cargo]: ../../cargo.md"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:1
msgid "# Implicit Conversions"
msgstr "# ë¬µì‹œì  í˜•ë³€í™˜"

#: src/exercises/day-1/implicit-conversions.md:3
msgid ""
"Rust will not automatically apply _implicit conversions_ between types ([unlike\n"
"C++][3]). You can see this in a program like this:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” [C++ ì™€ ë‹¤ë¥´ê²Œ][3] íƒ€ì… ê°„ *ë¬µì‹œì  ë³€í™˜*ì„ ìë™ìœ¼ë¡œ ì ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì•„ë˜ ì˜ˆì‹œë¥¼ í™•ì¸í•´ ë³´ì„¸ìš”:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:11
msgid ""
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:15
msgid ""
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
msgid ""
"The Rust integer types all implement the [`From<T>`][1] and [`Into<T>`][2]\n"
"traits to let us convert between them. The `From<T>` trait has a single `from()`\n"
"method and similarly, the `Into<T>` trait has a single `into()` method.\n"
"Implementing these traits is how a type expresses that it can be converted into\n"
"another type."
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ì •ìˆ˜í˜• íƒ€ì…ì€ ëª¨ë‘ [`From<T>`][1] ì™€ [`Into<T>`][2] íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©°, ì´ë¥¼ í†µí•´ íƒ€ì… ë³€í™˜ì´ ì´ë£¨ì–´ ì§‘ë‹ˆë‹¤. `From<T>` íŠ¸ë ˆì‡ì€ `from()` ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆê³ , `Into<T>`íŠ¸ë ˆì‡ì€ `into()` ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” `From`ê³¼ `Into` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•¨ìœ¼ë¡œì¨, íƒ€ì… ê°„ ë³€í™˜ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ í‘œí˜„í•©ë‹ˆë‹¤."

#: src/exercises/day-1/implicit-conversions.md:25
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which means\n"
"that we can convert a variable `x` of type `i8` to an `i16` by calling \n"
"`i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for i16`\n"
"implementation automatically create an implementation of `Into<i16> for i8`."
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” `From<i8> for i16`ê°€ êµ¬í˜„ë˜ì–´ ìˆëŠ”ë° ì´ê²ƒì€ `i8` íƒ€ì…ì˜ ë³€ìˆ˜ `x`ë¥¼ `i16::from(x)`ë¥¼ í˜¸ì¶œí•˜ì—¬ `i16`íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. í˜¹ì€ ë” ê°„ë‹¨í•˜ê²Œ `x.into()`ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì´ ê°€ëŠ¥í•œ ì´ìœ ëŠ” `From<i8> for i16` êµ¬í˜„ì„ ê°€ì§€ê³  ìˆìœ¼ë©´ `Into<i16> for i8` êµ¬í˜„ì´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/exercises/day-1/implicit-conversions.md:30
msgid ""
"The same applies for your own `From` implementations for your own types, so it is\n"
"sufficient to only implement `From` to get a respective `Into` implementation automatically."
msgstr "ì´ëŠ” ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì—ë„ ë™ì¼í•˜ê²Œ ì ìš©ë˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤. ë”°ë¼ì„œ `From`ë§Œì„ êµ¬í˜„í•´ë„ `Into`ê¹Œì§€ ìë™ìœ¼ë¡œ êµ¬í˜„ì´ ë©ë‹ˆë‹¤."

#: src/exercises/day-1/implicit-conversions.md:33
msgid "1. Execute the above program and look at the compiler error."
msgstr "1. ìœ„ ì˜ˆì œì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  ì–´ë–¤ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/exercises/day-1/implicit-conversions.md:35
msgid "2. Update the code above to use `into()` to do the conversion."
msgstr "2. `into()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì„¸ìš”."

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"3. Change the types of `x` and `y` to other things (such as `f32`, `bool`,\n"
"   `i128`) to see which types you can convert to which other types. Try\n"
"   converting small types to big types and the other way around. Check the\n"
"   [standard library documentation][1] to see if `From<T>` is implemented for\n"
"   the pairs you check."
msgstr "3. `x`ì™€ `y`ë¥¼ `f32`ì´ë‚˜ `bool`, `i128` ë“±ìœ¼ë¡œ ë°”ê¿”ì„œ í•´ë‹¹ íƒ€ì…ë“¤ë¡œ ë³€í™˜ì´ ë˜ëŠ”ì§€ í™•ì¸í•´ë³´ì„¸ìš”. ì‘ì€ ì‚¬ì´ì¦ˆ íƒ€ì…ì—ì„œ í° ì‚¬ì´ì¦ˆë¡œ ë³€ê²½í•´ë³´ì‹œê³  ê·¸ ë°˜ëŒ€ë¡œë„ í•´ë³´ì„¸ìš”. [í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ][1]ì—ì„œ ì‹œë„í•´ ë³¸ ì¼€ì´ìŠ¤ê°€ êµ¬í˜„ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/exercises/day-1/implicit-conversions.md:43
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[3]: https://en.cppreference.com/w/cpp/language/implicit_conversion"
msgstr ""

#: src/exercises/day-1/for-loops.md:1
msgid "# Arrays and `for` Loops"
msgstr "# ë°°ì—´ê³¼ `for`ë°˜ë³µë¬¸"

#: src/exercises/day-1/for-loops.md:3
msgid "We saw that an array can be declared like this:"
msgstr "ë°°ì—´ì„ ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸ í•  ìˆ˜ ìˆìŒì„ ë°°ì› ìŠµë‹ˆë‹¤:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:9
msgid "You can print such an array by asking for its debug representation with `{:?}`:"
msgstr "ë°°ì—´ì„ ì¶œë ¥í•˜ë ¤ë©´ `{:?}`ë¥¼ ì”ë‹ˆë‹¤:"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:18
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for`\n"
"keyword:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” `for` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ ë°°ì—´ì´ë‚˜ ë²”ìœ„ë¥¼ ë°˜ë³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();"
msgstr ""

#: src/exercises/day-1/for-loops.md:30
msgid ""
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:38
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix and\n"
"a function `transpose` which will transpose a matrix (turn rows into columns):"
msgstr "ìœ„ ì½”ë“œë¥¼ ì´ìš©í•´ì„œ, í–‰ë ¬ì„ ì˜ˆì˜ê²Œ ì¶œë ¥í•˜ëŠ” `pretty_print`í•¨ìˆ˜ì™€, í–‰ë ¬ì„ ì „ì¹˜(í–‰ê³¼ ì—´ì„ ì„œë¡œ ë°”ê¾¸ëŠ”)ì‹œí‚¤ëŠ” `transpose`í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           â›â¡1 2 3â¤â      â¡1 4 7â¤\n"
"\"transpose\"âœâ¢4 5 6â¥âŸ  \"==\"â¢2 5 8â¥\n"
"           ââ£7 8 9â¦â       â£3 6 9â¦\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
msgid "Hard-code both functions to operate on 3 Ã— 3 matrices."
msgstr "ë‘ í•¨ìˆ˜ ëª¨ë‘ í–‰ë ¬ì˜ í¬ê¸°ëŠ” 3 x 3 ìœ¼ë¡œ í•˜ë“œì½”ë”© í•©ë‹ˆë‹¤."

#: src/exercises/day-1/for-loops.md:49
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the\n"
"functions:"
msgstr "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤:"

#: src/exercises/day-1/for-loops.md:52 src/exercises/day-1/book-library.md:20
#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""
"```rust,should_panic\n"
"// TODO: êµ¬í˜„ì´ ì™„ë£Œë˜ë©´ ì•„ë˜ ì¤„ì€ ì‚­ì œí•©ë‹ˆë‹¤.\n"
"#![allow(unused_variables, dead_code)]"

#: src/exercises/day-1/for-loops.md:56
msgid ""
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-1/for-loops.md:60
msgid ""
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-1/for-loops.md:64
msgid ""
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""

#: src/exercises/day-1/for-loops.md:71
#: src/exercises/day-1/solutions-morning.md:70
msgid ""
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);"
msgstr ""

#: src/exercises/day-1/for-loops.md:74
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:80
msgid "## Bonus Question"
msgstr "## ë³´ë„ˆìŠ¤ ë¬¸ì œ"

#: src/exercises/day-1/for-loops.md:82
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 Ã— 3 matrices for your\n"
"argument and return types? Something like `&[&[i32]]` for a two-dimensional\n"
"slice-of-slices. Why or why not?"
msgstr "`&[i32]`ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì˜ ì´ìš©í•˜ë©´ í–‰ë ¬ í¬ê¸°ë¥¼ 3 x 3ìœ¼ë¡œ í•˜ë“œì½”ë”© í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì„ê¹Œìš”? ì˜ˆì»¨ë° `&[&[i32]]`ëŠ” 2ì°¨ì› ìŠ¬ë¼ì´ìŠ¤ì˜ ìŠ¬ë¼ì´ìŠ¤ ì…ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë‹¤ë©´/í•˜ì§€ ì•Šë‹¤ë©´ ì™œ ê·¸ëŸ°ê°€ìš”?"

#: src/exercises/day-1/for-loops.md:87
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality\n"
"implementation."
msgstr "ìƒìš© í’ˆì§ˆì˜ êµ¬í˜„ì— ëŒ€í•´ì„œëŠ” [`ndarray` í¬ë ˆì´íŠ¸](https://docs.rs/ndarray/)ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/exercises/day-1/for-loops.md:92
msgid ""
"The solution and the answer to the bonus section are available in the \n"
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr "ë³´ë„ˆìŠ¤ ë¬¸ì œì— ëŒ€í•œ ë‹µë³€ ì—­ì‹œ [í•´ë‹µ](solutions-morning.md#arrays-and-for-loops)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/basic-syntax/variables.md:1
msgid "# Variables"
msgstr "# ë³€ìˆ˜"

#: src/basic-syntax/variables.md:3
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable by\n"
"default:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì •ì  íƒ€ì´í•‘ì„ í†µí•´ íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤. ë³€ìˆ˜ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë¶ˆë³€(immutable)í•©ë‹ˆë‹¤:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"

#: src/basic-syntax/variables.md:17
msgid ""
"* Due to type inference the `i32` is optional. We will gradually show the types less and less as the course progresses.\n"
"* Note that since `println!` is a macro, `x` is not moved, even using the function like syntax of `println!(\"x: {}\", x)`"
msgstr ""
"* íƒ€ì… ì¶”ë¡ ì— ë•ë¶„ì— `i32`ëŠ” ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê°•ì˜ê°€ ì§„í–‰ë  ìˆ˜ë¡ ìƒëµ ê°€ëŠ¥í•œ ë¶€ë¶„ì€ ì ì  ìƒëµí•  ê²ƒì…ë‹ˆë‹¤.\n"
"* `println!(\"x: {}\", x)`ëŠ” í•¨ìˆ˜ í˜¸ì¶œ ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ì‹¤ì€ ë§¤í¬ë¡œ í˜¸ì¶œì´ë©° `x`ëŠ” ì´ë™ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/basic-syntax/type-inference.md:1
msgid "# Type Inference"
msgstr "# íƒ€ì… ì¶”ë¡ "

#: src/basic-syntax/type-inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë³€ìˆ˜ê°€ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ë¥¼ ë³´ê³  ê·¸ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•©ë‹ˆë‹¤:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}"
msgstr ""

#: src/basic-syntax/type-inference.md:10
msgid ""
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}"
msgstr ""

#: src/basic-syntax/type-inference.md:14
msgid ""
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;"
msgstr ""

#: src/basic-syntax/type-inference.md:18
msgid ""
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.\n"
"    \n"
"It is very important to emphasize that variables declared like this are not of some sort of dynamic \"any type\" that can\n"
"hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type.\n"
"The compiler does the job for us and helps us write more concise code."
msgstr "ì´ ìŠ¬ë¼ì´ë“œëŠ”, ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ê°€ ë³€ìˆ˜ê°€ ì–´ë–»ê²Œ ì„ ì–¸ë˜ì–´ ìˆê³ , ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ë¥¼ ì œì•½ ì¡°ê±´ìœ¼ë¡œ ì‚¼ì•„ì„œ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ëŠ” ëª¨ìŠµì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê²ƒì€, ì´ë ‡ê²Œ ëª…ì‹œì ì¸ íƒ€ì…ì„ ìƒëµí•˜ê³  ì„ ì–¸ë˜ì—ˆë‹¤ê³  í•´ì„œ \"ì–´ë–¤ íƒ€ì…\"ì´ë¼ë„ ë‹¤ ë‹´ì„ ìˆ˜ ìˆëŠ” íƒ€ì…ì´ ë˜ëŠ” ê²ƒì€ ì•„ë‹ˆë¼ëŠ” ì ì…ë‹ˆë‹¤. ëª…ì‹œì ì¸ íƒ€ì… ì„ ì–¸ì´ ìˆë˜ ì—†ë˜, ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•œ ë¨¸ì‹ ì½”ë“œëŠ” ë™ì¼í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¨ì§€ íƒ€ì… ì„ ì–¸ì„ ìƒëµí•  ìˆ˜ ìˆë„ë¡ í•´ì„œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ë” ê°„ê²°í•œ ì½”ë“œë¥¼ ì“¸ ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤„ ë¿ì…ë‹ˆë‹¤."

#: src/basic-syntax/type-inference.md:32
msgid "The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using `_` as a placeholder:"
msgstr "ì•„ë˜ ì½”ë“œëŠ”, ì œë„¤ë¦­ ì»¨í…Œì´ë„ˆë¥¼ ì“¸ ë•Œ ì»¨í…Œì´í„° ì•ˆì— í¬í•¨ëœ ë°ì´í„°ì˜ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì“°ì§€ ì•Šê³  `_`ë¡œ ëŒ€ì²´í•˜ì—¬ë„ ëœë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");"
msgstr ""

#: src/basic-syntax/type-inference.md:41
msgid ""
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
msgid "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect) relies on `FromIterator`, which [`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) implements."
msgstr "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect)ëŠ” [`HashSet`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)ì„ êµ¬í˜„í•œ `FromIterator`ì— ì˜ì¡´í•©ë‹ˆë‹¤."

#: src/basic-syntax/static-and-const.md:1
msgid "# Static and Constant Variables"
msgstr "# ì •ì ë³€ìˆ˜(static)ê³¼ ìƒìˆ˜(const)"

#: src/basic-syntax/static-and-const.md:3
msgid "Global state is managed with static and constant variables."
msgstr "í”„ë¡œê·¸ë¨ì˜ ê¸€ë¡œë²Œ ìƒíƒœëŠ” ê²°êµ­ ì •ì  ë³€ìˆ˜ì™€ ìƒìˆ˜ë¡œ í‘œí˜„ë©ë‹ˆë‹¤."

#: src/basic-syntax/static-and-const.md:5
msgid "## `const`"
msgstr "## ìƒìˆ˜(`const`)"

#: src/basic-syntax/static-and-const.md:7
msgid "You can declare compile-time constants:"
msgstr "ì»´íŒŒì¼ ì‹œ ê°’ì´ ì •í•´ì§€ëŠ” ìƒìˆ˜ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/basic-syntax/static-and-const.md:9
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);"
msgstr ""

#: src/basic-syntax/static-and-const.md:13
msgid ""
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}"
msgstr ""

#: src/basic-syntax/static-and-const.md:21
msgid ""
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:27
msgid "According the the [Rust RFC Book][1] these are inlined upon use."
msgstr "[Rust RFC Book][1]ì— ë”°ë¥´ë©´ ìƒìˆ˜ëŠ”, ê·¸ ìƒìˆ˜ê°€ ì‚¬ìš©ë˜ëŠ” ê³³ì— ì¸ë¼ì¸ ë©ë‹ˆë‹¤."

#: src/basic-syntax/static-and-const.md:29
msgid "## `static`"
msgstr "## ì •ì ë³€ìˆ˜(`static`)"

#: src/basic-syntax/static-and-const.md:31
msgid "You can also declare static variables:"
msgstr "ë§ˆì°¬ê°€ì§€ë¡œ ì •ì  ë³€ìˆ˜ë„ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/basic-syntax/static-and-const.md:33
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";"
msgstr ""

#: src/basic-syntax/static-and-const.md:36
msgid ""
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:41
msgid "As noted in the [Rust RFC Book][1], these are not inlined upon use and have an actual associated memory location.  This is useful for unsafe and embedded code, and the variable lives through the entirety of the program execution."
msgstr "[Rust RFC Book][1]ì—ì„œ ì–¸ê¸‰í•œ ë°”ì™€ ê°™ì´, ì •ì  ë³€ìˆ˜ëŠ” ë³„ë„ì˜ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°€ì§€ë©°, ì¸ë¼ì¸ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì •ì  ë³€ìˆ˜ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€(unsafe) ëŸ¬ìŠ¤íŠ¸ì™€ ì„ë² ë””ë“œ ì‹œìŠ¤í…œìš© ì½”ë“œì—ì„œ ìœ ìš©í•©ë‹ˆë‹¤. ì´ë“¤ì˜ ìˆ˜ëª…ì€ í”„ë¡œê·¸ë¨ì´ ìˆ˜í–‰ë˜ëŠ” ì „ì²´ ì‹œê°„ê³¼ ë™ì¼í•©ë‹ˆë‹¤."

#: src/basic-syntax/static-and-const.md:44
msgid "We will look at mutating static data in the [chapter on Unsafe Rust](../unsafe.md)."
msgstr "ê°€ë³€ ì •ì  ë°ì´í„°ì— ëŒ€í•´ì„œëŠ” [ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸](../unsafe.md)ì—ì„œ ì‚´í´ë´…ë‹ˆë‹¤."

#: src/basic-syntax/static-and-const.md:48
msgid ""
"* Mention that `const` behaves semantically similar to C++'s `constexpr`.\n"
"* `static`, on the other hand, is much more similar to a `const` or mutable global variable in C++.\n"
"* It isn't super common that one would need a runtime evaluated constant, but it is helpful and safer than using a static."
msgstr ""
"* `const`ëŠ” C++ì˜ `constexpr`ê³¼ ë§¤ìš° ë¹„ìŠ·í•©ë‹ˆë‹¤.\n"
"* ë°˜ë©´ì— `static`ì€ C++ì˜ `const`ë‚˜ ê°€ë³€ ì •ì  ë³€ìˆ˜ì™€ í›¨ì”¬ ë” ìœ ì‚¬í•©ë‹ˆë‹¤.\n"
"* í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì‹œ ê·¸ ê°’ì´ ì •í•´ì§€ëŠ” ìƒìˆ˜ê°€ í•„ìš”í•œ ê²½ìš°ëŠ” ë“œë­…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ë ‡ë‹¤ê³  í•´ë„, ì •ì  ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ ë³´ë‹¤ëŠ” ë” ìœ ìš©í•˜ê³  ì•ˆì „í•©ë‹ˆë‹¤."

#: src/basic-syntax/static-and-const.md:54
msgid "[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:1
msgid "# Scopes and Shadowing"
msgstr "# ë²”ìœ„(Scope)ì™€ ì‰ë„ì‰(Shadowing)"

#: src/basic-syntax/scopes-shadowing.md:3
msgid ""
"You can shadow variables, both those from outer scopes and variables from the\n"
"same scope:"
msgstr "í˜„ì¬ ë²”ìœ„ì— ìˆëŠ” ë³€ìˆ˜ì™€, ë°”ê¹¥ ë²”ìœ„ì— ìˆëŠ” ë³€ìˆ˜ ëª¨ë‘ ê°€ë¦´(ì‰ë„ì‰)ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:11
msgid ""
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:15
msgid ""
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:19
msgid ""
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:25
msgid ""
"* Definition: Shadowing is different from mutation, because after shadowing both variable's memory locations exist at the same time. Both are available under the same name, depending where you use it in the code. \n"
"* A shadowing variable can have a different type. \n"
"* Shadowing looks obscure at first, but is convenient for holding on to values after `.unwrap()`.\n"
"* The following code demonstrates why the compiler can't simply reuse memory locations when shadowing an immutable variable in a scope, even if the type does not change."
msgstr ""
"* ì‰ë„ì‰ì€ ê¸°ì¡´ ë³€ìˆ˜ì— ìƒˆë¡œìš´ ê°’ì„ í• ë‹¹í•˜ëŠ” ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤. ì‰ë„ì‰ì„ í•˜ë©´ ìƒˆë¡œìš´ ë³€ìˆ˜ê¸° ìƒê¸°ë©°, ì´ì „ ë³€ìˆ˜ì™€ ìƒˆ ë³€ìˆ˜ëŠ” ë©”ëª¨ë¦¬ì˜ ì„œë¡œ ë‹¤ë¥¸ ìœ„ì¹˜ì— ì¡´ì¬í•©ë‹ˆë‹¤. ê·¸ ë‘ ë³€ìˆ˜ëŠ” ë‹¨ì§€ ì´ë¦„ì´ ê°™ì€ ë¿ì´ë©°, ì½”ë“œ ì¤‘ ì–´ë””ì—ì„œ ê·¸ ì´ë¦„ì´ ì‚¬ìš©ë˜ì—ˆëŠëƒì— ë”°ë¼ ì–´ë–¤ ë³€ìˆ˜ë¥¼ ì§€ì¹­í•˜ëŠ” ì§€ê°€ ê²°ì •ë©ë‹ˆë‹¤.\n"
"* ì‰ë„ì‰ ì‹œ íƒ€ì…ì„ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì²˜ìŒì— ì‰ë„ì‰ì„ ë³´ë©´ ì½”ë“œë¥¼ ë” ëª¨í˜¸í•˜ê²Œ ë§Œë“ ë‹¤ê³  ìƒê°í•  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì‹¤ì œë¡œ ì‰ë„ì‰ì„ ì´ìš©í•˜ë©´, ì–´ë–¤ ë³€ìˆ˜ì—ì„œ `.unwrap()` ëœ ê°’ì„ ìƒˆë¡œìš´ ë³€ìˆ˜ì— ë‹´ì„ ê²½ìš° ìƒˆë¡œìš´ ì´ë¦„ì„ ì§€ì„ í•„ìš” ì—†ì´ ê¸°ì¡´ ì´ë¦„ì„ ìœ ì§€í•  ìˆ˜ ìˆì–´ì„œ í¸ë¦¬í•©ë‹ˆë‹¤.\n"
"* ì•„ë˜ ì½”ë“œëŠ” ë¶ˆë³€ ë³€ìˆ˜ë¥¼ ì‰ë„ì‰í•  ë•Œ íƒ€ì…ì´ ë™ì¼í•˜ë”ë¼ë„ ìƒˆ ë³€ìˆ˜ê°€ ì›ë˜ ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ ìœ„ì¹˜ë¥¼ ì¬ì‚¬ìš© í•  ìˆ˜ ì—†ëŠ”ì§€ ê·¸ ì´ìœ ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management.md:1
msgid "# Memory Management"
msgstr "# ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/memory-management.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "ì „í†µì ìœ¼ë¡œ, ë‘ ì¢…ë¥˜ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/memory-management.md:5
msgid ""
"* Full control via manual memory management: C, C++, Pascal, ...\n"
"* Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ..."
msgstr ""
"* ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ í”„ë¡œê·¸ë˜ë¨¸ì˜ ì™„ì „í•œ í†µì œí•˜ì— ìˆì§€ë§Œ ìˆ˜ë™(ê·¸ë˜ì„œ ì•ˆì „í•˜ì§€ ì•Šì„ ìˆ˜ ìˆëŠ”)ì¸ ì–¸ì–´: C, C++, Pascal, ...\n"
"* ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ëŸ°íƒ€ì„ì— ì˜í•´ ë˜ë¯€ë¡œ ì•ˆì „í•˜ì§€ë§Œ ìë™(ê·¸ë˜ì„œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ê°œì…í•  ì—¬ì§€ê°€ ì ê±°ë‚˜ ì—†ëŠ”)ì¸ ì–¸ì–´: Java, Python, Go, Haskell, ..."

#: src/memory-management.md:8
msgid "Rust offers a new mix:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ ë‘˜ì„ í˜¼í•©í•œ ìƒˆë¡œìš´ í˜•íƒœì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ë²•ì„ ì œê³µí•©ë‹ˆë‹¤:"

#: src/memory-management.md:10
msgid ""
"> Full control *and* safety via compile time enforcement of correct memory\n"
"> management."
msgstr "> ì»´íŒŒì¼ ì‹œ ì˜¬ë°”ë¥¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ê°•ì œí•¨ìœ¼ë¡œì¨ ì™„ì „í•œ í†µì œì™€ ì•ˆì „ì„± ëª¨ë‘ ì œê³µ"

#: src/memory-management.md:13
msgid "It does this with an explicit ownership concept."
msgstr "ì´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ì»¨ì…‰ì€ ëª…ì‹œì ì¸ ì†Œìœ ê¶Œì…ë‹ˆë‹¤."

#: src/memory-management.md:15
msgid "First, let's refresh how memory management works."
msgstr "ìš°ì„  ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ì´ë¤„ì§€ëŠ” ë°©ì‹ì„ ë‹¤ì‹œ ì‚´í´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/memory-management/stack-vs-heap.md:1
msgid "# The Stack vs The Heap"
msgstr "# ìŠ¤íƒ(Stack)ê³¼ í™(Heap)"

#: src/memory-management/stack-vs-heap.md:3
msgid ""
"* Stack: Continuous area of memory for local variables.\n"
"  * Values have fixed sizes known at compile time.\n"
"  * Extremely fast: just move a stack pointer.\n"
"  * Easy to manage: follows function calls.\n"
"  * Great memory locality."
msgstr ""
"* ìŠ¤íƒ: ì§€ì—­ ë³€ìˆ˜ë¥¼ ìœ„í•œ ì—°ì†ì ì¸ ë©”ëª¨ë¦¬ ì˜ì—­\n"
"  * ì—¬ê¸° ì €ì¥ë˜ëŠ” ê°’ì€ ì»´íŒŒì¼ ì‹œ ê²°ì •ë˜ëŠ” ê³ ì • í¬ê¸°ë¥¼ ê°–ìŠµë‹ˆë‹¤. \n"
"  * ë§¤ìš° ë¹ ë¦„: ë©”ëª¨ë¦¬ í• ë‹¹/ë°˜í™˜ì´ ë‹¨ì§€ ìŠ¤íƒ í¬ì¸í„°ì˜ ì´ë™ë§Œìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤.\n"
"  * ê´€ë¦¬ê°€ ì‰¬ì›€: í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´ í• ë‹¹ë˜ê³ , ë¦¬í„´í•˜ë©´ ë°˜í™˜ë©ë‹ˆë‹¤.\n"
"  * ìŠ¤íƒì— ìˆëŠ” ê°’ë“¤ì€ ë§¤ìš° ë†’ì€ ë©”ëª¨ë¦¬ ì¸ì ‘ì„±ì„ ê°€ì§‘ë‹ˆë‹¤(_ì—­ì£¼_: ê·¸ë˜ì„œ ìºì‹œë¥¼ íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤)"

#: src/memory-management/stack-vs-heap.md:9
msgid ""
"* Heap: Storage of values outside of function calls.\n"
"  * Values have dynamic sizes determined at runtime.\n"
"  * Slightly slower than the stack: some book-keeping needed.\n"
"  * No guarantee of memory locality."
msgstr ""
"* í™: í•¨ìˆ˜ í˜¸ì¶œ/ë¦¬í„´ê³¼ ìƒê´€ ì—†ì´ ìœ ì§€ë˜ëŠ” ê°’ì´ ì €ì¥ë˜ëŠ” ê³³\n"
"  * ì—¬ê¸° ì €ì¥ë˜ëŠ” ê°’ì€ í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì‹œ ê·¸ í¬ê¸°ê°€ ê²°ì •ë©ë‹ˆë‹¤.\n"
"  * ìŠ¤íƒ ë³´ë‹¤ëŠ” ëŠë¦¼: ë©”ëª¨ë¦¬ í• ë‹¹/ë°˜í™˜ì‹œ í•´ì•¼ í•  ì¼ì´ ì¢€ ë” ìˆìŠµë‹ˆë‹¤.\n"
"  * ë©”ëª¨ë¦¬ ì¸ì ‘ì„±ì„ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/memory-management/stack.md:1
msgid "# Stack Memory"
msgstr "# ìŠ¤íƒ ë©”ëª¨ë¦¬"

#: src/memory-management/stack.md:3
msgid ""
"Creating a `String` puts fixed-sized data on the stack and dynamically sized\n"
"data on the heap:"
msgstr "`String` íƒ€ì…ì€ ê³ ì • í¬ê¸° ë°ì´í„°(_ì—­ì£¼_: ë¬¸ìì—´ì˜ ê¸¸ì´, ë¬¸ìì—´ì´ ì €ì¥ëœ ë²„í¼ì˜ ì£¼ì†Œ ë“±)ëŠ” ìŠ¤íƒì— ì €ì¥í•˜ê³ , ê°€ë³€ í¬ê¸° ë°ì´í„°(_ì—­ì£¼_: ë¬¸ìì—´ ë²„í¼)ëŠ” í™ì— ì €ì¥í•©ë‹ˆë‹¤:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/memory-management/stack.md:28
msgid "* Mention that a `String` is backed by a `Vec`, so it has a capacity and length and can grow if mutable via reallocation on the heap."
msgstr "* ë¬¸ìì—´(`String`)ì€ ì‹¤ì œë¡œëŠ” `Vec`ì…ë‹ˆë‹¤. í¬ê¸°(capacity)ì™€ í˜„ì¬ ê¸¸ì´(length) ì •ë³´ë¥¼ ê°€ì§€ë©°, ë” í° í¬ê¸°ê°€ í•„ìš”í•  ê²½ìš° í™ì—ì„œ ì¬ í• ë‹¹ì„ í•©ë‹ˆë‹¤."

#: src/memory-management/stack.md:30
msgid "* If students ask about it, you can mention that the underlying memory is heap allocated using the [System Allocator] and custom allocators can be implemented using the [Allocator API]"
msgstr "* í™ì€ ê¸°ë³¸ì ìœ¼ë¡œ [System Allocator]ë¥¼ í†µí•´ í• ë‹¹ë©ë‹ˆë‹¤. ê·¸ë¦¬ê³  [Allocator API]ë¥¼ ì´ìš©í•´ì„œ ì»¤ìŠ¤í…€ ë©”ëª¨ë¦¬ í• ë‹¹ìë¥¼ ë§Œë“¤ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/stack.md:32
msgid "* We can inspect the memory layout with `unsafe` code. However, you should point out that this is rightfully unsafe!"
msgstr "* `unsafe` ì½”ë“œë¡œ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬¼ë¡  ì´ ì½”ë“œê°€ ì•ˆì „í•˜ì§€ ì•Šë‹¤ëŠ” ì ì„ ì•Œë ¤ì£¼ì„¸ìš”!"

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"

#: src/memory-management/stack.md:51
msgid ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"
msgstr ""
"[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html\n"
"[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html"

#: src/memory-management/manual.md:1
msgid "# Manual Memory Management"
msgstr "# ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/memory-management/manual.md:3
msgid "You allocate and deallocate heap memory yourself."
msgstr "ì‚¬ìš©ìê°€ ì§ì ‘ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹, í•´ì œ í•©ë‹ˆë‹¤."

#: src/memory-management/manual.md:5
msgid "If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks."
msgstr "ì¡°ì‹¬í•˜ì§€ ì•Šìœ¼ë©´, ì¶©ëŒ(crash), ë²„ê·¸, ë³´ì•ˆì·¨ì•½ì„± ë° ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/manual.md:7
msgid "## C Example"
msgstr "## C ì–¸ì–´ ì˜ˆì œ"

#: src/memory-management/manual.md:9
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr "`malloc`ìœ¼ë¡œ í• ë‹¹í•˜ëŠ” í¬ì¸í„°ë§ˆë‹¤ `free`ë¥¼ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = (int*)malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: the\n"
"pointer is lost and we cannot deallocate the memory."
msgstr "ë§Œì•½ `malloc` ê³¼ `free` ì‚¬ì´ì—ì„œ í•¨ìˆ˜ê°€ ì¼ì° ë°˜í™˜ë˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ì¼ì–´ë‚©ë‹ˆë‹¤: í¬ì¸í„°ë¥¼ ìƒì–´ë²„ë¦¬ê²Œ ë˜ì–´ ë©”ëª¨ë¦¬ë¥¼ ë°˜í™˜í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤."

#: src/memory-management/scope-based.md:1
msgid "# Scope-Based Memory Management"
msgstr "# ë²”ìœ„ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/memory-management/scope-based.md:3
msgid "Constructors and destructors let you hook into the lifetime of an object."
msgstr "ìƒì„±ìì™€ ì†Œë©¸ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ì˜ ìƒëª…ì£¼ê¸°ì— ë”°ë¼ ë©”ëª¨ë¦¬ í• ë‹¹/í•´ì œê°€ ì¼ì–´ë‚˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/scope-based.md:5
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is\n"
"destroyed. The compiler guarantees that this happens, even if an exception is\n"
"raised."
msgstr "í¬ì¸í„°ë¥¼ ê°ì²´ë¡œ ê°ì‹¸ë„ë¡ í•˜ë©´, ê·¸ ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ê·¸ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ê°€ í•´ì œë˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ë°˜ë“œì‹œ ì†Œë©¸ìê°€ í˜¸ì¶œë˜ëŠ” ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤. ì‹¬ì§€ì–´ëŠ” ì˜ˆì™¸(exception)ê°€ ë°œìƒ(_ì—­ì£¼_: í•¨ìˆ˜ì˜ ë¦¬í„´ì´ë‚˜ ìŠ¤ì½”í”„ì˜ ì¢…ë£Œ ë¿ë§Œì´ ì•„ë‹ˆë¼) í•˜ë”ë¼ë„ìš”."

#: src/memory-management/scope-based.md:9
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and gives\n"
"you smart pointers."
msgstr "ì´ë¥¼ ì¢…ì¢… RAII (Resource Acquisition Is Initialization)ë¼ê³  í•˜ë©°, ì´ëŸ° ê°ì²´ëŠ” ì¼ì¢…ì˜ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì—­í• ì„ í•©ë‹ˆë‹¤."

#: src/memory-management/scope-based.md:12
msgid "## C++ Example"
msgstr "## C++ ì˜ˆì œ"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/scope-based.md:20
msgid ""
"* The `std::unique_ptr` object is allocated on the stack, and points to\n"
"  memory allocated on the heap.\n"
"* At the end of `say_hello`, the `std::unique_ptr` destructor will run.\n"
"* The destructor frees the `Person` object it points to."
msgstr ""
"* `std::unique_ptr`ê°ì²´ëŠ” ìŠ¤íƒì— í• ë‹¹ë˜ë©°, í™ì— í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤.\n"
"* `say_hello`í•¨ìˆ˜ê°€ ëë‚˜ë©´ `std::unique_ptr`ì˜ ì†Œë©¸ìê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.\n"
"* ì†Œë©¸ìëŠ” `Person` ê°ì²´ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•©ë‹ˆë‹¤."

#: src/memory-management/scope-based.md:25
msgid "Special move constructors are used when passing ownership to a function:"
msgstr "ì´ë™ ìƒì„±ìëŠ” í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ì†Œìœ ê¶Œì„ ì „ë‹¬í• ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
msgid "# Automatic Memory Management"
msgstr "# ìë™ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/memory-management/garbage-collection.md:3
msgid ""
"An alternative to manual and scope-based memory management is automatic memory\n"
"management:"
msgstr "ìˆ˜ë™, ìŠ¤ì½”í”„ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ì˜ ëŒ€ì•ˆìœ¼ë¡œ ìë™ ë©”ëª¨ë¦¬ ê´€ë¦¬ ë°©ì‹ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/memory-management/garbage-collection.md:6
msgid ""
"* The programmer never allocates or deallocates memory explicitly.\n"
"* A garbage collector finds unused memory and deallocates it for the programmer."
msgstr ""
"* ê°œë°œìëŠ” ë©”ëª¨ë¦¬ë¥¼ ëª…ì‹œì ìœ¼ë¡œ í• ë‹¹/í•´ì œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"* ê°€ë¹„ì§€ ì»¬ë ‰í„°(GC)ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ë¥¼ ì°¾ì•„ í•´ì œí•©ë‹ˆë‹¤."

#: src/memory-management/garbage-collection.md:9
msgid "## Java Example"
msgstr "## Jave ì˜ˆì œ"

#: src/memory-management/garbage-collection.md:11
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr "`person`ê°ì²´ëŠ” `sayHello`í•¨ìˆ˜ ë°˜í™˜ í›„ì—ë„ í•´ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (_ì—­ì£¼_: GCê°€ ë‚˜ì¤‘ì— ì•Œì•„ì„œ í•´ì œí•©ë‹ˆë‹¤.)"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/rust.md:1
msgid "# Memory Management in Rust"
msgstr "# ëŸ¬ìŠ¤íŠ¸ì—ì„œì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/memory-management/rust.md:3
msgid "Memory management in Rust is a mix:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ëŠ” ì§€ê¸ˆê¹Œì§€ ì„¤ëª…í•œ ë°©ì‹ë“¤ì„ í˜¼í•©í•´ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/memory-management/rust.md:5
msgid ""
"* Safe and correct like Java, but without a garbage collector.\n"
"* Depending on which abstraction (or combination of abstractions) you choose, can be a single unique pointer, reference counted, or atomically reference counted.\n"
"* Scope-based like C++, but the compiler enforces full adherence.\n"
"* A Rust user can choose the right abstraction for the situation, some even have no cost at runtime like C."
msgstr ""
"* ìë°”ì²˜ëŸ¼ ì•ˆì „í•˜ê³  ì •í™•í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ GCëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
"* ë‹¤ì–‘í•œ ì¶”ìƒí™”ë¥¼ ì œê³µí•©ë‹ˆë‹¤: ë‹¨ì¼ í¬ì¸í„°, ì°¸ì¡° ì¹´ìš´íŠ¸, ì•„í† ë¯¹(atomic) ì°¸ì¡° ì¹´ìš´íŠ¸.\n"
"* C++ ì²˜ëŸ¼ ë²”ìœ„(ìŠ¤ì½”í”„) ê¸°ë°˜ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì»´íŒŒì¼ëŸ¬ê°€ í›¨ì”¬ ë” ì—„ê²©í•©ë‹ˆë‹¤.\n"
"* ì‚¬ìš©ìëŠ” ìƒí™©ì— ë”°ë¼ ì í•©í•œ ì¶”ìƒí™”ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ ì¤‘ì—ëŠ” C ì–¸ì–´ ì²˜ëŸ¼ ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ì—†ëŠ” ê²ƒë„ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/rust.md:10
msgid "It achieves this by modeling _ownership_ explicitly."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” *ì†Œìœ ê¶Œ*ì„ ì–¸ì–´ ì°¨ì›ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ëª¨ë¸ë§ í•¨ìœ¼ë¡œì¨ ì´ë¥¼ ì´ë£¹ë‹ˆë‹¤."

#: src/memory-management/rust.md:14
msgid "* If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper types such as [Box], [Vec], [Rc], or [Arc]. These encapsulate ownership and memory allocation via various means, and prevent the potential errors in C."
msgstr "* ì´ ì‹œì ì—ì„œ ê·¸ê²Œ ì–´ë–»ê²Œ ê°€ëŠ¥í•˜ëƒëŠ” ì§ˆë¬¸ì´ ìˆìœ¼ë©´, ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì´ ì‘ì—…ì€ ì¼ë°˜ì ìœ¼ë¡œ [Box], [Vec], [Rc] ë˜ëŠ” [Arc]ì™€ ê°™ì€ RAII íƒ€ì…ì— ì˜í•´ ì²˜ë¦¬ëœë‹¤ê³  ë‹µë³€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë“¤ì€ ë‹¤ì–‘í•œ ë°©ë²•ì„ í†µí•´ ì†Œìœ ê¶Œê³¼ ë©”ëª¨ë¦¬ í• ë‹¹ì— ëŒ€í•œ êµ¬ì²´ì ì¸ ë‚´ìš©ì„ì„ ìº¡ìŠí™”í•˜ì—¬, C ì–¸ì–´ì˜€ë‹¤ë©´ ë°œìƒí•  ìˆ˜ ìˆì—ˆì„ ë‹¤ì–‘í•œ ì—ëŸ¬ë¥¼ ë§‰ìŠµë‹ˆë‹¤."

#: src/memory-management/rust.md:16
msgid "* You may be asked about destructors here, the [Drop] trait is the Rust equivalent."
msgstr "* ì†Œë©¸ìì— ëŒ€í•œ ì§ˆë¬¸ë„ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. [Drop] íŠ¸ë ˆì‡ì´ ë‹µì…ë‹ˆë‹¤."

#: src/memory-management/rust.md:20
msgid ""
"[Box]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[Vec]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[Rc]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[Arc]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[Drop]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""

#: src/memory-management/comparison.md:1
msgid "# Comparison"
msgstr "# ë¹„êµ"

#: src/memory-management/comparison.md:3
msgid "Here is a rough comparison of the memory management techniques."
msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ìˆ ì˜ ëŒ€ëµì ì¸ ë¹„êµì…ë‹ˆë‹¤."

#: src/memory-management/comparison.md:5
msgid "## Pros of Different Memory Management Techniques"
msgstr "## ë©”ëª¨ë¦¬ ê´€ë¦¬ ë°©ë²• ë³„ ì¥ì "

#: src/memory-management/comparison.md:7
msgid ""
"* Manual like C:\n"
"  * No runtime overhead.\n"
"* Automatic like Java:\n"
"  * Fully automatic.\n"
"  * Safe and correct.\n"
"* Scope-based like C++:\n"
"  * Partially automatic.\n"
"  * No runtime overhead.\n"
"* Compiler-enforced scope-based like Rust:\n"
"  * Enforced by compiler.\n"
"  * No runtime overhead.\n"
"  * Safe and correct."
msgstr ""
"* Cì™€ ê°™ì€ ìˆ˜ë™ ê´€ë¦¬: \n"
"  * ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ì—†ìŒ. \n"
"* JAVAì™€ ê°™ì€ ìë™í™” ê´€ë¦¬: \n"
"  * ì™„ì „í•œ ìë™í™”.\n"
"  * ì•ˆì „í•˜ê³  ì •í™•í•¨.\n"
"* C++ ì™€ ê°™ì€ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬: \n"
"  * ë¶€ë¶„ ìë™í™”\n"
"  * ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ì—†ìŒ.\n"
"* ëŸ¬ìŠ¤íŠ¸ì™€ ê°™ì€ ì»´íŒŒì¼ëŸ¬ ìˆ˜í–‰ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬: \n"
"  * ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìˆ˜í–‰ë©ë‹ˆë‹¤.\n"
"  * ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ì—†ìŠµë‹ˆë‹¤. \n"
"  * ì•ˆì „í•˜ê³  ì •í™•í•©ë‹ˆë‹¤."

#: src/memory-management/comparison.md:20
msgid "## Cons of Different Memory Management Techniques"
msgstr "## ë©”ëª¨ë¦¬ ê´€ë¦¬ ë°©ë²• ë³„ ë‹¨ì "

#: src/memory-management/comparison.md:22
msgid ""
"* Manual like C:\n"
"  * Use-after-free.\n"
"  * Double-frees.\n"
"  * Memory leaks.\n"
"* Automatic like Java:\n"
"  * Garbage collection pauses.\n"
"  * Destructor delays.\n"
"* Scope-based like C++:\n"
"  * Complex, opt-in by programmer.\n"
"  * Potential for use-after-free.\n"
"* Compiler-enforced and scope-based like Rust:\n"
"  * Some upfront complexity.\n"
"  * Can reject valid programs."
msgstr ""
"* Cì™€ ê°™ì€ ìˆ˜ë™ ê´€ë¦¬:\n"
"  * ì‚¬ìš© í›„ í•´ì œ ë¬¸ì œ.\n"
"  * ì´ì¤‘ í•´ì œ ë¬¸ì œ.\n"
"  * ë©”ëª¨ë¦¬ ëˆ„ì¶œ ë¬¸ì œ.\n"
"* JAVAì™€ ê°™ì€ ìë™í™” ê´€ë¦¬:\n"
"  * GCë™ì‘ìœ¼ë¡œ ì¸í•œ ë©ˆì¶¤.\n"
"  * ì†Œë©¸ì ì§€ì—° (_ì—­ì£¼_: íŠ¹ì • ë©”ëª¨ë¦¬ë¥¼ ë”ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šë”ë¼ë„ ê³§ë°”ë¡œ í•´ì œ ë˜ì§€ ì•Šê³  GCê°€ ë™ì‘í•  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•œë‹¤ëŠ” ì )\n"
"* C++ ì™€ ê°™ì€ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬:\n"
"  * ë³µì¡í•˜ë©°, ê°œë°œìì˜ ì„ íƒì‚¬í•­ì„.\n"
"  * ì‚¬ìš© í›„ í•´ì œ ë¬¸ì œ ê°€ëŠ¥ì„± ìˆìŒ.\n"
"* ëŸ¬ìŠ¤íŠ¸ì™€ ê°™ì€ ì»´íŒŒì¼ëŸ¬ê°€ ê°•ì œí•˜ëŠ” ìˆ˜í–‰ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬:\n"
"  * ì•½ê°„ì˜ ì´ˆê¸° ë³µì¡ì„±.\n"
"  * ì˜¬ë°”ë¥¸ í”„ë¡œê·¸ë¨ì´ì§€ë§Œ ì»´íŒŒì¼ëŸ¬ê°€ ê±°ë¶€í•  ìˆ˜ ìˆìŒ."

#: src/ownership.md:1
msgid "# Ownership"
msgstr "# ì†Œìœ ê¶Œ"

#: src/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error to\n"
"use a variable outside its scope:"
msgstr "ëª¨ë“  ë³€ìˆ˜ ë°”ì¸ë”©ì€ ìœ íš¨í•œ *ë²”ìœ„(ìŠ¤ì½”í”„)*ë¥¼ ê°€ì§€ë©°, ë²”ìœ„ ë°–ì—ì„œ ë³€ìˆ˜ ì‚¬ìš©í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);"
msgstr ""

#: src/ownership.md:9
msgid ""
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""

#: src/ownership.md:18
msgid ""
"* At the end of the scope, the variable is _dropped_ and the data is freed.\n"
"* A destructor can run here to free up resources.\n"
"* We say that the variable _owns_ the value."
msgstr ""
"* ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ë³€ìˆ˜ëŠ” *ì‚­ì œ(drop)*ë˜ì—ˆë‹¤ê³  í•˜ë©° ê·¸ ë³€ìˆ˜ì˜ ë°ì´í„°ëŠ” ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë©ë‹ˆë‹¤.\n"
"* ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë  ë•Œ ë‹¤ë¥¸ ë¦¬ì†ŒìŠ¤ë¥¼ í•´ì œí•˜ê¸° ìœ„í•´ ì†Œë©¸ìê°€ í˜¸ì¶œë˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì´ê²ƒì„ ë‘ê³  ë³€ìˆ˜ê°€ ê°’ì„ *ì†Œìœ *í•œë‹¤ê³  í‘œí˜„í•©ë‹ˆë‹¤."

#: src/ownership/move-semantics.md:1
msgid "# Move Semantics"
msgstr "# Move ë¬¸ë²•(Move Semantics)"

#: src/ownership/move-semantics.md:3
msgid "An assignment will transfer ownership between variables:"
msgstr "(ë³€ìˆ˜ì˜) í• ë‹¹ì€ ì†Œìœ ê¶Œì„ ë³€ìˆ˜ ê°„ì— ì´ë™ì‹œí‚µë‹ˆë‹¤:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/move-semantics.md:14
msgid ""
"* The assignment of `s1` to `s2` transfers ownership.\n"
"* The data was _moved_ from `s1` and `s1` is no longer accessible.\n"
"* When `s1` goes out of scope, nothing happens: it has no ownership.\n"
"* When `s2` goes out of scope, the string data is freed.\n"
"* There is always _exactly_ one variable binding which owns a value."
msgstr ""
"* `s1`ì„ `s2`ì— í• ë‹¹í•˜ì—¬ ì†Œìœ ê¶Œì„ ì´ì „ì‹œí‚µë‹ˆë‹¤.\n"
"* ë°ì´í„°ëŠ” `s1`ì—ì„œ _ì´ë™_ë©ë‹ˆë‹¤. ë”°ë¼ì„œ í”„ë¡œê·¸ë˜ë¨¸ëŠ” `s1`ì€ ë” ì´ìƒ ì ‘ê·¼ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
"* `s1`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ì•„ë¬´ ì¼ë„ ì—†ìŠµë‹ˆë‹¤: ì™œëƒí•˜ë©´ `s1`ì€ ì•„ë¬´ëŸ° ì†Œìœ ê¶Œì´ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"
"* `s2`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ë¬¸ìì—´ ë°ì´í„°ëŠ” í•´ì œë©ë‹ˆë‹¤.\n"
"* ê°’(ë°ì´í„°)ì˜ ì†Œìœ ê¶Œì„ ê°–ëŠ” ë³€ìˆ˜ëŠ” í•­ìƒ *ë‹¨* í•˜ë‚˜ ì…ë‹ˆë‹¤."

#: src/ownership/move-semantics.md:22
msgid "* Mention that this is the opposite of the defaults in C++, which copies by value unless you use `std::move` (and the move constructor is defined!)."
msgstr "* ì´ëŠ” C++ê³¼ ì •ë°˜ëŒ€ ì„ì„ ì„¤ëª…í•˜ì„¸ìš”. C++ì—ì„œëŠ” ë³µì‚¬ê°€ ê¸°ë³¸ì´ê³ , `std::move` ë¥¼ ì´ìš©í•´ì•¼ë§Œ (ê·¸ë¦¬ê³  ì´ë™ ìƒì„±ìê°€ ì •ì˜ë˜ì–´ ìˆì–´ì•¼ë§Œ!) ì†Œìœ ê¶Œ ì´ì „ì´ ë©ë‹ˆë‹¤."

#: src/ownership/move-semantics.md:24
msgid "* In Rust, clones are explicit (by using `clone`)."
msgstr "* ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ë³µì‚¬í• ë•Œì—ëŠ” ëª…ì‹œì ìœ¼ë¡œ `clone`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/ownership/moved-strings-rust.md:1
msgid "# Moved Strings in Rust"
msgstr "# ëŸ¬ìŠ¤íŠ¸ì—ì„œì˜ ë¬¸ìì—´ ì´ë™(Move)"

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
msgid ""
"* The heap data from `s1` is reused for `s2`.\n"
"* When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"* `s1`ì˜ í™ ë°ì´í„°ëŠ” `s2`ì—ì„œ ì¬ì‚¬ìš© ë©ë‹ˆë‹¤.\n"
"* `s1`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ì•„ë¬´ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.(ì´ë¯¸ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.)"

#: src/ownership/moved-strings-rust.md:13
msgid "Before move to `s2`:"
msgstr "`s2`ë¡œ ì´ë™ ì „ ë©”ëª¨ë¦¬:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:30
msgid "After move to `s2`:"
msgstr "`s2`ë¡œ ì´ë™ í›„ ë©”ëª¨ë¦¬:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:1
msgid "# Double Frees in Modern C++"
msgstr "# Modern C++ì—ì„œ ì´ì¤‘í•´ì œ ë¬¸ì œ"

#: src/ownership/double-free-modern-cpp.md:3
msgid "Modern C++ solves this differently:"
msgstr "Modern C++ì€ ì´ ë¬¸ì œë¥¼ ë‹¤ë¥´ê²Œ í•´ê²°í•©ë‹ˆë‹¤:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:10
msgid ""
"* The heap data from `s1` is duplicated and `s2` gets its own independent copy.\n"
"* When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"* `s1`ì˜ í™ ë°ì´í„°ëŠ” ë³µì œë˜ê³ , `s2`ëŠ” ë…ë¦½ì ì¸ ë³µì‚¬ë³¸ì„ ì–»ìŠµë‹ˆë‹¤.\n"
"* `s1` ì™€ `s2`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ê°ê°ì˜ ë©”ëª¨ë¦¬ê°€ í•´ì œë©ë‹ˆë‹¤."

#: src/ownership/double-free-modern-cpp.md:13
msgid "Before copy-assignment:"
msgstr "ë³µì‚¬ ì „:"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:30
msgid "After copy-assignment:"
msgstr "ë³µì‚¬ í›„:"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:1
msgid "# Moves in Function Calls"
msgstr "# í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ì´ë™(Move)"

#: src/ownership/moves-function-calls.md:3
msgid ""
"When you pass a value to a function, the value is assigned to the function\n"
"parameter. This transfers ownership:"
msgstr "ê°’ì„ í•¨ìˆ˜ì— ì „ë‹¬í• ë•Œ, ê·¸ ê°’ì€ ë§¤ê°œë³€ìˆ˜ì— í• ë‹¹ë©ë‹ˆë‹¤. ì´ë•Œ ì†Œìœ ê¶Œì˜ ì´ë™ì´ ì¼ì–´ë‚©ë‹ˆë‹¤:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}"
msgstr ""

#: src/ownership/moves-function-calls.md:11
msgid ""
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:20
msgid ""
"* With the first call to `say_hello`, `main` gives up ownership of `name`. Afterwards, `name` cannot be used anymore within `main`.\n"
"* The heap memory allocated for `name` will be freed at the end of the `say_hello` function.\n"
"* `main` can retain ownership if it passes `name` as a reference (`&name`) and if `say_hello` accepts a reference as a parameter.\n"
"* Alternatively, `main` can pass a clone of `name` in the first call (`name.clone()`).\n"
"* Rust makes it harder than C++ to inadvertently create copies by making move semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"* `say_hello`í•¨ìˆ˜ì˜ ì²«ë²ˆì§¸ í˜¸ì¶œì‹œ `main`í•¨ìˆ˜ëŠ” ìì‹ ì´ ê°€ì§„ `name`ì— ëŒ€í•œ ì†Œìœ ê¶Œì„ í¬ê¸°í•˜ë¯€ë¡œ, ì´í›„ `main`í•¨ìˆ˜ì—ì„œëŠ” `name`ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
"* `name`ì— í• ë‹¹ë˜ìˆëŠ” í™ ë©”ëª¨ë¦¬ëŠ” `say_hello`í•¨ìˆ˜ì˜ ëì—ì„œ í•´ì œë©ë‹ˆë‹¤.\n"
"* `main`í•¨ìˆ˜ì—ì„œ `name`ì„ ì°¸ì¡°ë¡œ ì „ë‹¬(ë¹Œë¦¼)í•˜ê³ (`&name`), `say_hello`ì—ì„œ ë§¤ê°œë³€ìˆ˜ë¥¼ ì°¸ì¡°í˜•ìœ¼ë¡œ ìˆ˜ì •í•œë‹¤ë©´ `main`í•¨ìˆ˜ëŠ” `name`ì˜ ì†Œìœ ê¶Œì„ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ë˜ëŠ” ì²«ë²ˆì§¸ í˜¸ì¶œ ì‹œ `main`í•¨ìˆ˜ì—ì„œ `name`ì„ ë³µì œí•˜ì—¬ ì „ë‹¬í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.(`name.clone()`)\n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ë™ì„ ê¸°ë³¸ìœ¼ë¡œ í•˜ê³  ë³µì œë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í•˜ë„ë¡ ë§Œë“¬ìœ¼ë¡œ, ì˜ë„ì¹˜ ì•Šê²Œ ë³µì‚¬ë³¸ì„ ë§Œë“œëŠ” ê²ƒì´ C++ì—ì„œë³´ë‹¤ ì–´ë µìŠµë‹ˆë‹¤."

#: src/ownership/copy-clone.md:1
msgid "# Copying and Cloning"
msgstr "# ë³µì‚¬(copy)ì™€ ë³µì œ(clone)"

#: src/ownership/copy-clone.md:3
msgid "While move semantics are the default, certain types are copied by default:"
msgstr "ì´ë™ì´ ê¸°ë³¸ ì„¤ì •ì´ì§€ë§Œ, íŠ¹ì • íƒ€ì…ì€ ë³µì‚¬ë©ë‹ˆë‹¤:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:14
msgid "These types implement the `Copy` trait."
msgstr "ì´ëŸ¬í•œ íƒ€ì…ë“¤ì€ `Copy` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/ownership/copy-clone.md:16
msgid "You can opt-in your own types to use copy semantics:"
msgstr "ì§ì ‘ ë§Œë“  íƒ€ì…ë“¤ë„ `Copy`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ì—¬ ë³µì‚¬ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);"
msgstr ""

#: src/ownership/copy-clone.md:22
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:30
msgid ""
"* After the assignment, both `p1` and `p2` own their own data.\n"
"* We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"* í• ë‹¹ í›„, `p1`ì™€ `p2`ëŠ” ìì‹ ì˜ ë°ì´í„°ë¥¼ ì†Œìœ í•©ë‹ˆë‹¤.\n"
"* ëª…ì‹œì ìœ¼ë¡œ `p1.clone()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ë³µì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/ownership/copy-clone.md:35
msgid "Copying and cloning are not the same thing:"
msgstr "ë³µì‚¬(copy)ì™€ ë³µì œ(clone)ëŠ” ê°™ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/ownership/copy-clone.md:37
msgid ""
"* Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.\n"
"* Copying does not allow for custom logic (unlike copy constructors in C++).\n"
"* Cloning is a more general operation and also allows for custom behavior by implementing the `Clone` trait.\n"
"* Copying does not work on types that implement the `Drop` trait."
msgstr ""
"* ë³µì‚¬ëŠ” ë©”ëª¨ë¦¬ì˜ ë‚´ìš©ì„ ê·¸ëŒ€ë¡œ í•œ ë²Œ ë” ë§Œë“œëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë©°, ì•„ë¬´ ê°ì²´ì—ì„œë‚˜ ë‹¤ ì§€ì›í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.\n"
"* ë³µì‚¬ëŠ” ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (C++ì—ì„œ ë³µì‚¬ ìƒì„±ìë¥¼ í†µí•´ ë³µì‚¬ ë™ì‘ì„ ì„ì˜ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ê²ƒê³¼ ë¹„êµê°€ ë©ë‹ˆë‹¤.)\n"
"* ë³µì œëŠ” ë³´ë‹¤ ì¼ë°˜ì ì¸ ì‘ì—…ì´ë©°, `Clone`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ì—¬ ë³µì œì‹œ ë™ì‘ì„ ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `Drop` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•œ íƒ€ì…ì€ ë³µì‚¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
msgid "In the above example, try the following:"
msgstr "ìœ„ì˜ ì˜ˆì‹œì—ì„œ ë‹¤ìŒì„ ì‹œë„í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/ownership/copy-clone.md:44
msgid ""
"* Add a `String` field to `struct Point`. It will not compile because `String` is not a `Copy` type.\n"
"* Remove `Copy` from the `derive` attribute. The compiler error is now in the `println!` for  `p1`.\n"
"* Show that it works if you clone `p1` instead."
msgstr ""
"* `Point`êµ¬ì¡°ì²´ì— `String`í•„ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”. ì»´íŒŒì¼ ë˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤. ì™œëƒí•˜ë©´ `String`ì€ `Copy`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"
"* `derive` ì†ì„±ì—ì„œ `Copy`ë¥¼ ì œê±°í•´ ë³´ì„¸ìš”. `p1`ì„ `println!` í•  ë•Œ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•  ê²ƒì…ë‹ˆë‹¤.\n"
"* `p1`ì„ ë³µì œí•˜ë©´ ì˜ ë™ì‘í•¨ì„ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/ownership/copy-clone.md:48
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way to generate code in Rust\n"
"at compile time. In this case the default implementations of `Copy` and `Clone` traits are generated.\n"
"    \n"
"</details>"
msgstr ""
"ë§Œì•½ í•™ìƒë“¤ì´ `derive`ì— ëŒ€í•´ ë¬»ëŠ”ë‹¤ë©´, ì»´íŒŒì¼ ì‹œ ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ”ë°©ë²•ì´ë¼ê³  ë§í•˜ëŠ” ê²ƒìœ¼ë¡œ ì¶©ë¶„í•©ë‹ˆë‹¤. ìœ„ ê²½ìš° `Copy`ì™€ `Clone` íŠ¸ë ˆì‡ì— ëŒ€í•œ ê¸°ë³¸ êµ¬í˜„ì´ ìƒì„±ë©ë‹ˆë‹¤.\n"
"</details>"

#: src/ownership/borrowing.md:1
msgid "# Borrowing"
msgstr "# ë¹Œë¦¼(Borrowing)"

#: src/ownership/borrowing.md:3
msgid ""
"Instead of transferring ownership when calling a function, you can let a\n"
"function _borrow_ the value:"
msgstr "í•¨ìˆ˜ í˜¸ì¶œì‹œ ê°’ì˜ ì†Œìœ ê¶Œì„ ì´ë™í•˜ëŠ” ëŒ€ì‹ ì˜ í•¨ìˆ˜ê°€ ê°’ì„ *ë¹Œë ¤ì˜¬ ìˆ˜* ìˆìŠµë‹ˆë‹¤:"

#: src/ownership/borrowing.md:6 src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);"
msgstr ""

#: src/ownership/borrowing.md:10
msgid ""
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}"
msgstr ""

#: src/ownership/borrowing.md:14
msgid ""
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:22
msgid ""
"* The `add` function _borrows_ two points and returns a new point.\n"
"* The caller retains ownership of the inputs."
msgstr ""
"* `add` í•¨ìˆ˜ëŠ” ë‘ `Point` ê°ì²´ ê°’ì„ _ë¹Œë ¤_ì™€ì„œ ìƒˆë¡œìš´ `Point` ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"* `p1`ê³¼ `p2`ì˜ ì†Œìœ ê¶Œì€ ì—¬ì „íˆ í˜¸ì¶œì(`main`í•¨ìˆ˜)ì— ìˆìŠµë‹ˆë‹¤."

#: src/ownership/borrowing.md:27
msgid ""
"Notes on stack returns:\n"
"* Demonstrate that the return from `add` is cheap because the compiler can eliminate the copy operation. Change the above code to print stack addresses and run it on the [Playground]. In the \"DEBUG\" optimization level, the addresses should change, while the stay the same when changing to the \"RELEASE\" setting:"
msgstr ""
"ìŠ¤íƒì— í• ë‹¹ëœ ê°’ì„ ë¦¬í„´í•˜ëŠ” ê²ƒì— ëŒ€í•œ ì°¸ê³ : \n"
"* `add`ì—ì„œ ê°’ì„ ë°˜í™˜í•˜ëŠ” ê²ƒì€ ë§¤ìš° ê°’ì´ ì‹¸ë‹¤ëŠ” ê²ƒì„ ì„¤ëª…í•˜ì„¸ìš”. ì™œëƒí•˜ë©´, ì»´íŒŒì¼ëŸ¬ê°€ ë³µì‚¬ ê³¼ì •ì„ ìƒëµí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ìœ„ ì½”ë“œë¥¼ ìŠ¤íƒ ì£¼ì†Œë¥¼ ì¶œë ¥í•˜ë„ë¡ ìˆ˜ì •í•˜ê³  [Playground]ì—ì„œ ìˆ˜í–‰í•´ ë³´ì„¸ìš”. \"ë””ë²„ê·¸\" ìµœì í™” ë ˆë²¨ì—ì„œëŠ” ì£¼ì†Œê°€ ë°”ë€Œì§€ë§Œ, \"ë¦´ë¦¬ì¦ˆ\" ë ˆë²¨ì—ì„œëŠ” ë°”ë€Œì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/ownership/borrowing.md:30
msgid ""
"  ```rust,editable\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""

#: src/ownership/borrowing.md:34
msgid ""
"  fn add(p1: &Point, p2: &Point) -> Point {\n"
"      let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"      println!(\"&p.0: {:p}\", &p.0);\n"
"      p\n"
"  }"
msgstr ""

#: src/ownership/borrowing.md:40
msgid ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* The Rust compiler can do return value optimization (RVO).\n"
"* In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always performs a simple and efficient `memcpy` copy."
msgstr ""
"  fn main() {\n"
"      let p1 = Point(3, 4);\n"
"      let p2 = Point(10, 20);\n"
"      let p3 = add(&p1, &p2);\n"
"      println!(\"&p3.0: {:p}\", &p3.0);\n"
"      println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"  }\n"
"  ```\n"
"* ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ë°˜í™˜ê°’ ìµœì í™”(RVO)ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* C++ì—ì„œ copy elisionì€ ìƒì„±ìì˜ ë¶€ìˆ˜íš¨ê³¼ ê°€ëŠ¥ì„±ì´ ìˆì–´ ì–¸ì–´ë ˆë²¨ì˜ ì •ì˜ê°€ í•„ìš”í•˜ì§€ë§Œ ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë§Œì•½ RVOê°€ ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ëŸ¬ìŠ¤íŠ¸ëŠ” í•­ìƒ ê°„ë‹¨í•˜ê³  íš¨ìœ¨ì ì¸ `memcpy`ë³µì‚¬ë¥¼ ìˆ˜í–‰í•  ê²ƒì…ë‹ˆë‹¤."

#: src/ownership/borrowing.md:53
msgid "[Playground]: https://play.rust-lang.org/"
msgstr ""

#: src/ownership/shared-unique-borrows.md:1
msgid "# Shared and Unique Borrows"
msgstr "# ê³µìœ ì™€ ê³ ìœ  ë¹Œë¦¼"

#: src/ownership/shared-unique-borrows.md:3
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ê°’ì„ ë¹Œë¦´ ë•Œ ë‹¤ìŒê³¼ ê°™ì€ ì œì•½ì¡°ê±´ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/ownership/shared-unique-borrows.md:5
msgid ""
"* You can have one or more `&T` values at any given time, _or_\n"
"* You can have exactly one `&mut T` value."
msgstr ""
"* í•œë²ˆì— í•˜ë‚˜ ì´ìƒì˜ `&T` ê°’ì„ ê°€ì§€ê±°ë‚˜, _ë˜ëŠ”_\n"
"* ì •í™•íˆ í•˜ë‚˜ì˜ `&mut T` ê°’ë§Œì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;"
msgstr ""

#: src/ownership/shared-unique-borrows.md:13
msgid ""
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }"
msgstr ""

#: src/ownership/shared-unique-borrows.md:18 src/std/rc.md:13
msgid ""
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/shared-unique-borrows.md:25
msgid ""
"* The above code does not compile because `a` is borrowed as mutable (through `c`) and as immutable (through `b`) at the same time.\n"
"* Move the `println!` statement for `b` before the scope that introduces `c` to make the code compile.\n"
"* After that change, the compiler realizes that `b` is only ever used before the new mutable borrow of `a` through `c`. This is a feature of the borrow checker called \"non-lexical lifetimes\"."
msgstr ""
"* ìœ„ ì½”ë“œ ì»´íŒŒì¼ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ `c`ëŠ” `a`ë¥¼ ê°€ë³€ ë³€ìˆ˜ë¡œ ë¹Œë ¸ê³ , ì´ì™€ ë™ì‹œì— `b`ëŠ” `a`ë¥¼ ë¶ˆë³€ ë³€ìˆ˜ë¡œ ë¹Œë ¸ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"
"* `b`ì— ëŒ€í•œ `println!` êµ¬ë¶„ì„ `c`ê°€ ìˆëŠ” ìŠ¤ì½”í”„ ì•ìœ¼ë¡œ ì´ë™í•˜ë©´ ì»´íŒŒì¼ì´ ë©ë‹ˆë‹¤.\n"
"* ì´ë ‡ê²Œ ë°”ê¾¸ë©´, ì»´íŒŒì¼ëŸ¬ëŠ” `c`ê°€ `a`ë¥¼ ê°€ë³€ ë³€ìˆ˜ë¡œ ë¹Œë¦¬ê¸° ì „ì—ë§Œ `b`ê°€ ì‚¬ìš©ëœë‹¤ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¹Œë¦¼ ê²€ì‚¬ê¸°ì˜ ì´ëŸ¬í•œ ê¸°ëŠ¥ì„ \"non-lexical lifetime\" ì´ë¼ê³  í•©ë‹ˆë‹¤.\n"
"  * ë‹¨ìˆœíˆ ìŠ¤ì½”í”„ë§Œ ë³´ë©´ `b`ì˜ ìˆ˜ëª…ì€ `main`í•¨ìˆ˜ì˜ ì „ì²´ë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë•Œë¬¸ì— `c`ì˜ ë¸”ë¡ ì•ˆì—ì„œëŠ” `a`ì— ëŒ€í•œ ê°€ë³€ ë¹Œë¦¼ê³¼ ë¶ˆë³€ ë¹Œë¦¼ì´ ë™ì‹œì— ì¡´ì¬í•˜ëŠ” ê²ƒ ì²˜ëŸ¼ ë³´ì´ë©°, ì´ëŠ” ìœ„ ì œì•½ ì¡°ê±´ì„ ìœ„ë°˜í•˜ëŠ” ê²ƒìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì»´íŒŒì¼ëŸ¬ëŠ” `b`ê°€ `c`ë¸”ë¡ì´ ì‹œì‘ë˜ê¸° ì „ì—ë§Œ ì‚¬ìš©ëœë‹¤ëŠ” ì ì„ ì ê·¹ í™œìš©í•´ì„œ `b`ì˜ ìˆ˜ëª…ì„ `c`ë¸”ë¡ì˜ ì‹œì‘ ì „ ê¹Œì§€ë¡œ ì¤„ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ `b`ì™€ `c`ì˜ ìˆ˜ëª…ì€ ê²¹ì¹˜ì§€ ì•Šê³ , ë”°ë¼ì„œ ì œì•½ ì¡°ê±´ì„ ìœ„ë°˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/ownership/lifetimes.md:1
msgid "# Lifetimes"
msgstr "# ìˆ˜ëª…"

#: src/ownership/lifetimes.md:3
msgid "A borrowed value has a _lifetime_:"
msgstr "ë¹Œë ¤ì˜¨ ê°’ì€ *ìˆ˜ëª…*ì„ ê°–ìŠµë‹ˆë‹¤:"

#: src/ownership/lifetimes.md:5
msgid ""
"* The lifetime can be elided: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* Lifetimes can also be explicit: `&'a Point`, `&'document str`.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"* Lifetimes are always inferred by the compiler: you cannot assign a lifetime\n"
"  yourself.\n"
"  * Lifetime annotations create constraints; the compiler verifies that there is\n"
"    a valid solution."
msgstr ""
"* ìˆ˜ëª…ì€ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤: `add(p1: &Point, p2: &Point) -> Point`.\n"
"* ë¬¼ë¡  ëª…ì‹œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤: `&'a Point`, `&'document str`.\n"
"* `&'a Point` ëŠ” `Point`ì˜ ìˆ˜ëª…ì´ ìµœì†Œí•œ `'a`ë¼ëŠ” ìˆ˜ëª…ë³´ë‹¤ëŠ” ê°™ê±°ë‚˜ ë” ê¸¸ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"* ìˆ˜ëª…ì€ í•­ìƒ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ì¶”ë¡ í•©ë‹ˆë‹¤. ì§ì ‘ ìˆ˜ëª…ì„ ì§€ì •í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
"  * ìˆ˜ëª… í‘œê¸°(`'`)ì€ ìˆ˜ëª… ì¶”ë¡ ì‹œ ì œì•½ì¡°ê±´ì´ ë©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì´ ì œì•½ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ëŠ” ìœ ìš”í•œ ìˆ˜ëª…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆëŠ”ì§€ ê²€ì‚¬ë¥¼ í•©ë‹ˆë‹¤."

#: src/ownership/lifetimes-function-calls.md:1
msgid "# Lifetimes in Function Calls"
msgstr "# í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ìˆ˜ëª…"

#: src/ownership/lifetimes-function-calls.md:3
msgid "In addition to borrowing its arguments, a function can return a borrowed value:"
msgstr "í•¨ìˆ˜ëŠ” ì¸ìˆ˜ë¥¼ ë¹Œë¦¬ëŠ” ê²ƒ ì™¸ì—ë„ ë¹Œë¦° ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/ownership/lifetimes-function-calls.md:9
msgid ""
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:13
msgid ""
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:21
msgid ""
"* `'a` is a generic parameter, it is inferred by the compiler.\n"
"* Lifetimes start with `'` and `'a` is a typical default name.\n"
"* Read `&'a Point` as \"a borrowed `Point` which is valid for at least the\n"
"  lifetime `a`\".\n"
"  * The _at least_ part is important when parameters are in different scopes."
msgstr ""
"* `'a`ëŠ” ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ë¡œ ì»´íŒŒì¼ëŸ¬ë¡œì— ì˜í•´ ì¶”ë¡ ë©ë‹ˆë‹¤.\n"
"* ìˆ˜ëª…ì˜ ì´ë¦„ì€ `'` ë¡œ ì‹œì‘í•˜ë©° ë³´í†µ `'a`ë¥¼ ë§ì´ ì”ë‹ˆë‹¤.\n"
"* `&'a Point` ëŠ” `Point`ì˜ ìˆ˜ëª…ì´ `'a` ìˆ˜ëª…ê³¼ ìµœì†Œí•œ ê°™ê±°ë‚˜ ë” ê¸¸ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"  * ë§¤ê°œë³€ìˆ˜ë“¤ì´ ì„œë¡œ ë‹¤ë¥¸ ìŠ¤ì½”í”„ì— ìˆì„ ê²½ìš° \"ìµœì†Œí•œ\"ì´ë¼ëŠ” ì¡°ê±´ì´ ì¤‘ìš”í•©ë‹ˆë‹¤."

#: src/ownership/lifetimes-function-calls.md:31
msgid ""
"* Move the declaration of `p2` and `p3` into a a new scope (`{ ... }`), resulting in the following code:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"
msgstr ""
"* `p2`ì™€ `p3`ë¥¼ ìƒˆë¡œìš´ ë²”ìœ„(`{...}`)ë¡œ ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ì´ë™í•´ ë´…ë‹ˆë‹¤:\n"
"  ```rust,ignore\n"
"  #[derive(Debug)]\n"
"  struct Point(i32, i32);"

#: src/ownership/lifetimes-function-calls.md:36
msgid ""
"  fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"      if p1.0 < p2.0 { p1 } else { p2 }\n"
"  }"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:40
msgid ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"  fn main() {\n"
"      let p1: Point = Point(10, 10);\n"
"      let p3: &Point;\n"
"      {\n"
"          let p2: Point = Point(20, 20);\n"
"          p3 = left_most(&p1, &p2);\n"
"      }\n"
"      println!(\"left-most point: {:?}\", p3);\n"
"  }\n"
"  ```\n"
"  `p3`ì˜ ìˆ˜ëª…ì´ `p2` ë³´ë‹¤ ê¸¸ê¸° ë•Œë¬¸ì— ì´ ì˜ˆì œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠìŒì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/ownership/lifetimes-function-calls.md:52
msgid ""
"* Reset the workspace and change the function signature to `fn left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile because the relationship between the lifetimes `'a` and `'b` is unclear.\n"
"* Another way to explain it:\n"
"  * Two references to two values are borrowed by a function and the function returns\n"
"    another reference.\n"
"  * It must have come from one of those two inputs (or from a global variable).\n"
"  * Which one is it? The compiler needs to to know, so at the call site the returned reference is not used\n"
"    for longer than a variable from where the reference came from."
msgstr ""
"* ì‘ì—…ê³µê°„ì„ ì´ˆê¸°í™” í•œ í›„ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ `fn left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`ë¡œ ë³€ê²½í•´ ë´…ë‹ˆë‹¤. ì´ ê²½ìš° `'a`ì™€ `'b`ì‚¬ì´ì˜ ê´€ê³„ê°€ ë¶ˆë¶„ëª…í•˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"* ì´ ì—ëŸ¬ë¥¼ ì„¤ëª…í•˜ëŠ” ë˜ ë‹¤ë¥¸ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:\n"
"  * ì´ í•¨ìˆ˜ëŠ” ë‘ ê°’ì„ ë¹Œë ¤ì„œ, ìƒˆë¡œìš´ ì°¸ì¡°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"  * ì´ ë°˜í™˜ëœ ì°¸ì¡°ëŠ” ë‘ ì…ë ¥ ì¤‘ í•˜ë‚˜ë¡œ ë¶€í„° ì™€ì•¼ í•©ë‹ˆë‹¤. (ì•„ë‹ˆë©´ ì „ì—­ ë³€ìˆ˜ë¡œ ë¶€í„°)\n"
"  * ë‘ ì…ë ¥ ì¤‘ ì–´ë–¤ ê²ƒì¼ê¹Œìš”? ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤. ê·¸ë˜ì•¼ë§Œ í•¨ìˆ˜ í˜¸ì¶œë¶€ì—ì„œ ë´¤ì„ ë•Œ, ë°˜í™˜ëœ ì°¸ì¡°ì˜ ìˆ˜ëª…ì´ ì›ë˜ ê°’ì„ ìˆ˜ëª…ë³´ë‹¤ ê¸¸ì§€ ì•ŠìŒì„ í™•ì¸í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/ownership/lifetimes-data-structures.md:1
msgid "# Lifetimes in Data Structures"
msgstr "# êµ¬ì¡°ì²´ì—ì„œì˜ ìˆ˜ëª…"

#: src/ownership/lifetimes-data-structures.md:3
msgid "If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr "ì–´ë–¤ íƒ€ì…ì´ ë¹Œë ¤ì˜¨ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ìˆë‹¤ë©´, ë°˜ë“œì‹œ ìˆ˜ëª…ì„ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:9
msgid ""
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:13
msgid ""
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog.\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:25
msgid ""
"* In the above example, the annotation on `Highlight` enforces that the data underlying the contained `&str` lives at least as long as any instance of `Highlight` that uses that data.\n"
"* If `text` is consumed before the end of the lifetime of `fox` (or `dog`), the borrow checker throws an error.\n"
"* Types with borrowed data force users to hold on to the original data. This can be useful for creating lightweight views, but it generally makes them somewhat harder to use.\n"
"* When possible, make data structures own their data directly.\n"
"* Some structs with multiple references inside can have more than one lifetime annotation. This can be necessary if there is a need to describe lifetime relationships between the references themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases.\n"
"</details>"
msgstr ""
"* ìœ„ì˜ ì˜ˆì œì—ì„œ `Highlight`ì˜ ì–´ë…¸í…Œì´ì…˜(`<'doc>`)ì€ ì ì–´ë„ `Highlight` ì¸ìŠ¤í„´ìŠ¤ê°€ ì‚´ì•„ìˆëŠ” ë™ì•ˆì—ëŠ” ê·¸ ë‚´ë¶€ì˜ `&str`ê°€ ê°€ë¦¬í‚¤ëŠ” ë°ì´í„° ì—­ì‹œ ì‚´ì•„ìˆì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"* ë§Œì•½ `text`ê°€ `fox` (í˜¹ì€ `dog`)ì˜ ìˆ˜ëª…ì´ ë‹¤í•˜ê¸° ì „ì— `erase`í•¨ìˆ˜ í˜¸ì¶œ ë“±ìœ¼ë¡œ ì‚¬ë¼ì§€ê²Œ ëœë‹¤ë©´ ë¹Œë¦¼ ê²€ì‚¬ê¸°ê°€ ì—ëŸ¬ë¥¼ ë°œìƒí•©ë‹ˆë‹¤.\n"
"* ë¹Œë¦° ë°ì´í„°ë¥¼ ê°€ì§€ê³  ìˆëŠ” íƒ€ì…ì€ ì‚¬ìš©ìë¡œ í•˜ì—¬ê¸ˆ ì›ë³¸ ë°ì´í„°ë¥¼ ìœ ì§€í•˜ë„ë¡ ê°•ì œí•©ë‹ˆë‹¤. ì´ëŸ° íƒ€ì…ì€ ê²½ëŸ‰ ë·°(lightweight view)ë¥¼ ë§Œë“œëŠ”ë° ìœ ìš©í•˜ì§€ë§Œ, ì´ ì œì•½ ì¡°ê±´ ë•Œë¬¸ì— ì´ëŸ° íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì‰½ì§€ë§Œì€ ì•ŠìŠµë‹ˆë‹¤.\n"
"* ë”°ë¼ì„œ, ê°€ëŠ¥í•˜ë‹¤ë©´, êµ¬ì¡°ì²´ê°€ ìì‹ ì˜ ë°ì´í„°ë¥¼ ì§ì ‘ ì†Œìœ í•˜ë„ë¡ í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.\n"
"* í•œ êµ¬ì¡°ì²´ì•ˆì— ì—¬ëŸ¬ ì°¸ì¡°ê°€ ìˆìœ¼ë©´ì„œ, ì´ ì°¸ì¡°ë“¤ì˜ ìˆ˜ëª…ì´ ì„œë¡œ ë‹¤ë¥´ê²Œ ì§€ì •ë˜ëŠ” ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì°¸ì¡°ì™€ ê·¸ êµ¬ì¡°ì²´ ê°„ì˜ ê´€ê³„ ë¿ë§Œì´ ì•„ë‹ˆë¼, ê·¸ ì°¸ì¡°ë“¤ ì‚¬ì´ì˜ ìˆ˜ëª… ê´€ê³„ë¥¼ ì„¤ëª…í•´ì•¼ í•  ê²½ìš°ì— í•„ìš”í•©ë‹ˆë‹¤. ë§¤ìš° ê³ ê¸‰ ê¸°ìˆ ì…ë‹ˆë‹¤.\n"
"</details>"

#: src/exercises/day-1/afternoon.md:1
msgid "# Day 1: Afternoon Exercises"
msgstr "# 1ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-1/afternoon.md:3
msgid "We will look at two things:"
msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œëŠ” ì•„ë˜ ë‘ê°€ì§€ì…ë‹ˆë‹¤:"

#: src/exercises/day-1/afternoon.md:5
msgid "* A small book library,"
msgstr "* ì‘ì€ ë„ì„œê´€"

#: src/exercises/day-1/afternoon.md:7
msgid "* Iterators and ownership (hard)."
msgstr "* ë°˜ë³µìì™€ ì†Œìœ ê¶Œ (ì–´ë ¤ì›€)"

#: src/exercises/day-1/afternoon.md:13 src/exercises/day-2/afternoon.md:9
msgid "[solutions]: solutions-afternoon.md"
msgstr ""

#: src/exercises/day-1/book-library.md:1
msgid "# Designing a Library"
msgstr "# ë„ì„œê´€ ì„¤ê³„"

#: src/exercises/day-1/book-library.md:3
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For now,\n"
"you just need to know part of its API:"
msgstr "ìš°ë¦¬ëŠ” ë‚´ì¼ êµ¬ì¡°ì²´ì™€ `Vec<T>`ì— ëŒ€í•´ ë” ë§ì€ ê²ƒì„ ë°°ìš¸ ê²ƒì…ë‹ˆë‹¤. ì¼ë‹¨ ì˜¤ëŠ˜ì€ APIì˜ ì¼ë¶€ë§Œ ì•Œë©´ ë©ë‹ˆë‹¤:"

#: src/exercises/day-1/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    println!(\"middle value: {}\", vec[vec.len() / 2]);\n"
"    for item in vec.iter() {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:17
msgid ""
"Use this to create a library application. Copy the code below to\n"
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr "ë„ì„œê´€ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ê¸° ìœ„í•´ ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤:"

#: src/exercises/day-1/book-library.md:24
msgid ""
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:28
#: src/exercises/day-1/solutions-afternoon.md:27
msgid ""
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:33
#: src/exercises/day-1/solutions-afternoon.md:32
msgid ""
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"impl Book {\n"
"    // ì•„ë˜ëŠ” Book êµ¬ì¡°ì²´ì˜ ìƒì„±ìì…ë‹ˆë‹¤.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:43
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"
msgstr ""
"// ì´ êµ¬í˜„ë©”ì„œë“œëŠ” {} í¬ë§·ìœ¼ë¡œ ì¶œë ¥í•  ìˆ˜ ìˆê²Œ ë„ì™€ì¤ë‹ˆë‹¤.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}"

#: src/exercises/day-1/book-library.md:50
msgid ""
"impl Library {\n"
"    fn new() -> Library {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-1/book-library.md:55
msgid ""
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:59
msgid ""
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:63
msgid ""
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:67
msgid ""
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}"
msgstr ""

#: src/exercises/day-1/book-library.md:71
msgid ""
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"}"
msgstr ""

#: src/exercises/day-1/book-library.md:76
msgid ""
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""
"// ì•„ë˜ ì†ŒìŠ¤ ì£¼ì„ì„ ì œê±°í•˜ê³  ëˆ„ë½ëœ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì„¸ìš”\n"
"// ë¯¸êµ¬í˜„ ë©”ì„œë“œë„ ì¡´ì¬í•˜ë¯€ë¡œ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì—…ë°ì´íŠ¸ í•˜ì„¸ìš”(self í¬í•¨)\n"
"fn main() {\n"
"    let library = Library::new();"

#: src/exercises/day-1/book-library.md:83
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/book-library.md:99
msgid ""
"<details>\n"
"    \n"
"[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"<details>\n"
"    \n"
"[í•´ë‹µ](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-1/iterators-and-ownership.md:1
msgid "# Iterators and Ownership"
msgstr "# ë°˜ë³µìì™€ ì†Œìœ ê¶Œ"

#: src/exercises/day-1/iterators-and-ownership.md:3
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the\n"
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and\n"
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)\n"
"traits."
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ì†Œìœ ê¶Œ ëª¨ë¸ì€ ë§ì€ APIì— ë°˜ì˜ì´ ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ë“¤ì–´ [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) ì™€ [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) ê°™ì€ íŠ¸ë ˆì‡ì´ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-1/iterators-and-ownership.md:8
msgid "## `Iterator`"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:10
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The\n"
"`Iterator` trait simply says that you can call `next` until you get `None` back:"
msgstr "íŠ¸ë ˆì‡ì€ íƒ€ì…ì— ëŒ€í•œ í–‰ë™(ë©”ì„œë“œ)ë¥¼ ì„¤ëª…í•œë‹¤ëŠ” ì ì—ì„œ ì¸í„°í˜ì´ìŠ¤ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤. `Iterator`ëŠ” ë‹¨ìˆœíˆ `None`ì´ ë‚˜ì˜¬ë•Œê¹Œì§€ `next`ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤:"

#: src/exercises/day-1/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:20
msgid "You use this trait like this:"
msgstr "`Iterator` íŠ¸ë ˆì‡ì€ ì´ë ‡ê²Œ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/exercises/day-1/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:27
msgid ""
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:34
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr "ë°˜ë³µìê°€ ë°˜í™˜í•˜ëŠ” ê°’ë“¤ì€ íƒ€ì…ì´ ë­˜ê¹Œìš”? ì—¬ê¸°ì„œ ë‹µì„ í…ŒìŠ¤íŠ¸ í•´ ë³´ì„¸ìš”:"

#: src/exercises/day-1/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:41
#: src/exercises/day-1/iterators-and-ownership.md:78
msgid ""
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:46
msgid "Why is this type used?"
msgstr "ì™œ ì´ëŸ° íƒ€ì…ì´ ì‚¬ìš©ë˜ëŠ” ê²ƒì¼ê¹Œìš”?"

#: src/exercises/day-1/iterators-and-ownership.md:48
msgid "## `IntoIterator`"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:50
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an\n"
"iterator. The related trait `IntoIterator` tells you how to create the iterator:"
msgstr "`Iterator` íŠ¸ë ˆì‡ì€ ìƒì„±ëœ ë°˜ë³µìë¥¼ *ì‚¬ìš©*í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤. ë°˜ë©´ `IntoIterator` íŠ¸ë ˆì‡ì€ ë°˜ë³µìë¥¼ *ìƒì„±*í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤:"

#: src/exercises/day-1/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:58
msgid ""
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:62
msgid ""
"The syntax here means that every implementation of `IntoIterator` must\n"
"declare two types:"
msgstr "`IntoIterator`ì˜ ëª¨ë“  êµ¬í˜„ì€ ë°˜ë“œì‹œ ë‹¤ìŒì˜ ë‘ íƒ€ì…ì„ ì„ ì–¸í•´ì•¼í•©ë‹ˆë‹¤:"

#: src/exercises/day-1/iterators-and-ownership.md:65
msgid ""
"* `Item`: the type we iterate over, such as `i8`,\n"
"* `IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"* `Item`: `i8`ê³¼ ê°™ì´ ë°˜ë³µë˜ëŠ” ê°’ì˜ íƒ€ì…\n"
"* `IntoIter`: `into_iter` ë©”ì„œë“œì—ì„œ ë°˜í™˜ë˜ëŠ” `Iterator`íƒ€ì…."

#: src/exercises/day-1/iterators-and-ownership.md:68
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same\n"
"`Item` type, which means that it returns `Option<Item>`"
msgstr "`IntoIter`ì—ëŠ” `Item`ì´ ì—°ê²°ë˜ì–´ ìˆìŒì„ ì£¼ëª©í•˜ì„¸ìš”. `IntoIter` ë°˜ë³µìëŠ” `Item` íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ê°€ë¦¬ì¼œì•¼ í•©ë‹ˆë‹¤. ì¦‰, ë°˜ë³µìëŠ” `Option<Item>`ì„ ë¦¬í„´í•©ë‹ˆë‹¤."

#: src/exercises/day-1/iterators-and-ownership.md:71
msgid "Like before, what  is the type returned by the iterator?"
msgstr "ì´ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ, ë°˜ë³µìê°€ ë°˜í™˜í•˜ëŠ” íƒ€ì…ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#: src/exercises/day-1/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];\n"
"    let mut iter = v.into_iter();"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:83
msgid "## `for` Loops"
msgstr "## ë°°ì—´ê³¼ `for` ë°˜ë³µë¬¸"

#: src/exercises/day-1/iterators-and-ownership.md:85
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` loops.\n"
"They call `into_iter()` on an expression and iterates over the resulting\n"
"iterator:"
msgstr "ì, ì´ì œ ìš°ë¦¬ëŠ” `Iterator`ì™€ `IntoIterator`ë¥¼ ì•Œì•˜ìœ¼ë¯€ë¡œ `for` ë£¨í”„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `for` ë£¨í”„ëŠ” `into_iter()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ë°˜ë³µìë¥¼ ë§Œë“  ë‹¤ìŒ ê·¸ ë°˜ë³µìë¥¼ ì´ìš©í•˜ì—¬ ìš”ì†Œë“¤ì„ ë°˜ë³µí•´ì„œ ì ‘ê·¼í•©ë‹ˆë‹¤:"

#: src/exercises/day-1/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::from(\"bar\")];"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:93
msgid ""
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:97
msgid ""
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/iterators-and-ownership.md:103
msgid "What is the type of `word` in each loop?"
msgstr "ë§¤ ë£¨í”„ì—ì„œ `word`ì˜ íƒ€ì…ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#: src/exercises/day-1/iterators-and-ownership.md:105
msgid ""
"Experiment with the code above and then consult the documentation for [`impl\n"
"IntoIterator for\n"
"&Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"and [`impl IntoIterator for\n"
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)\n"
"to check your answers."
msgstr ""
"ìœ„ ì½”ë“œì—ì„œ ì‹¤í—˜ í•´ ë³¸ í›„ ë‹¤ìŒ ë¬¸ì„œë¥¼ ì°¸ì¡°í•´ì„œ ë‹µë³€ì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"* [`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E)\n"
"* [`impl IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)"

#: src/welcome-day-2.md:1
msgid "# Welcome to Day 2"
msgstr "# 2ì¼ì°¨ ê°œìš”"

#: src/welcome-day-2.md:3
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "ìƒë‹¹í•œ ë¶„ëŸ‰ì˜ ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•´ ë³´ì•˜ê³ , ì´ì–´ì„œ ì˜¤ëŠ˜ ê°•ì˜ë¥¼ ì§„í–‰í•˜ê² ìŠµë‹ˆë‹¤:"

#: src/welcome-day-2.md:5
msgid "* Structs, enums, methods."
msgstr "* êµ¬ì¡°ì²´, ì—´ê±°í˜•, ë©”ì„œë“œ."

#: src/welcome-day-2.md:7
msgid "* Pattern matching: destructuring enums, structs, and arrays."
msgstr "* íŒ¨í„´ ë§¤ì¹­: ì—´ê±°í˜•, êµ¬ì¡°ì²´ ê·¸ë¦¬ê³  ë°°ì—´ ë¶„í•´."

#: src/welcome-day-2.md:9
msgid ""
"* Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and\n"
"  `continue`."
msgstr "* íë¦„ ì œì–´: `if`, `if let`, `while`, `while let`, `break`, ê·¸ë¦¬ê³  `continue`."

#: src/welcome-day-2.md:12
msgid ""
"* The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, `Rc`\n"
"  and `Arc`."
msgstr "* í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬: `String`, `Option` ê³¼ `Result`, `Vec`, `HashMap`, `Rc` ê·¸ë¦¬ê³  `Arc`."

#: src/welcome-day-2.md:15
msgid "* Modules: visibility, paths, and filesystem hierarchy."
msgstr "* ëª¨ë“ˆ: ê°€ì‹œì„±, ê²½ë¡œ ë° íŒŒì¼ ì‹œìŠ¤í…œ ê³„ì¸µ."

#: src/structs.md:1
msgid "# Structs"
msgstr "# êµ¬ì¡°ì²´"

#: src/structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "C/C++ ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ëŸ¬ìŠ¤íŠ¸ëŠ” ì»¤ìŠ¤í…€ êµ¬ì¡°ì²´ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""

#: src/structs.md:11
msgid ""
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""

#: src/structs.md:29
msgid ""
"<details>\n"
"Key Points: "
msgstr ""
"<details>\n"
"í‚¤ í¬ì¸íŠ¸: "

#: src/structs.md:32
msgid ""
"* Structs work like in C or C++.\n"
"  * Like in C++, and unlike in C, no typedef is needed to define a type.\n"
"  * Unlike in C++, there is no inheritance between structs.\n"
"* Methods are defined in an `impl` block, which we will see in following slides.\n"
"* This may be a good time to let people know there are different types of structs. \n"
"  * Zero-sized structs `e.g., struct Foo;` might be used when implementing a trait on some type but donâ€™t have any data that you want to store in the value itself. \n"
"  * The next slide will introduce Tuple structs, used when the field names are not important.\n"
"* The syntax `..peter` allows us to copy the majority of the fields from the old struct without having to explicitly type it all out. It must always be the last element."
msgstr ""
"* êµ¬ì¡°ì²´ëŠ” C/C++ ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤.\n"
"  * C++ ì™€ ê°™ì§€ë§Œ Cì™€ëŠ” ë‹¬ë¦¬ íƒ€ì…ì„ ì •ì˜í•˜ê¸° ìœ„í•´ 'typedef'ê°€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"  * C++ ì™€ ë‹¬ë¦¬ êµ¬ì¡°ì²´ ê°„ ìƒì†ì€ ì—†ìŠµë‹ˆë‹¤.\n"
"* ë©”ì„œë“œëŠ” `impl`ë¸”ë¡ì— ì •ì˜ í•©ë‹ˆë‹¤. ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì‚¬ëŒë“¤ì—ê²Œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ êµ¬ì¡°ì²´ê°€ ìˆìŒì„ ì•Œê²Œ í•˜ê¸°ì— ì¢‹ì€ ì‹œê°„ì¼ ê²ƒì…ë‹ˆë‹¤.\n"
"  * 0 í¬ê¸° êµ¬ì¡°ì²´(ì˜ˆ: `struct Foo;`)ëŠ” ë°ì´í„°ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šì§€ë§Œ íŠ¹ì • íƒ€ì…ì˜ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.\n"
"  * ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œëŠ” í•„ë“œ ì´ë¦„ì´ ëœ ì¤‘ìš”í•  ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íŠœí”Œ êµ¬ì¡°ì²´ë¥¼ ì†Œê°œí•©ë‹ˆë‹¤.\n"
"* `..peter` ë¬¸ë²•ì€ í•œ êµ¬ì¡°ì²´ì—ì„œ ë‹¤ë¥¸ êµ¬ì¡°ì²´ë¡œ ëŒ€ë¶€ë¶„ì˜ ê°’ì„ ë³µì‚¬í•˜ë ¤ê³  í•˜ëŠ” ê²½ìš°ì— í•˜ë‚˜í•˜ë‚˜ íƒ€ì´í•‘í•˜ëŠ” ìˆ˜ê³ ë¥¼ ëœì–´ì¤ë‹ˆë‹¤. ë°˜ë“œì‹œ ë§¨ ë§ˆì§€ë§‰ì— ì™€ì•¼ í•©ë‹ˆë‹¤."

#: src/structs/tuple-structs.md:1
msgid "# Tuple Structs"
msgstr "# íŠœí”Œ"

#: src/structs/tuple-structs.md:3
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "ê° í•„ë“œ ì´ë¦„ì´ ì¤‘ìš”í•˜ì§€ ì•Šë‹¤ë©´ íŠœí”Œ êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);"
msgstr ""

#: src/structs/tuple-structs.md:8
msgid ""
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:14
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr "íŠœí”Œ êµ¬ì¡°ì²´ëŠ” ì¢…ì¢… ë‹¨ì¼ í•„ë“œì˜ ë˜í¼(wrapper, ëŸ¬ìŠ¤íŠ¸ì—ì„œ ë‰´íƒ€ì…(newtype)ì´ë¼ê³  ë¶€ë¦„)ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤:"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundOfForce(f64);\n"
"struct Newtons(f64);"
msgstr ""

#: src/structs/tuple-structs.md:20
msgid ""
"fn compute_thruster_force() -> PoundOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}"
msgstr ""

#: src/structs/tuple-structs.md:24
msgid ""
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}"
msgstr ""

#: src/structs/tuple-structs.md:28
msgid ""
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}"
msgstr ""

#: src/structs/tuple-structs.md:33 src/traits/default.md:36
#: src/generics/trait-objects.md:86
msgid "```"
msgstr ""

#: src/structs/tuple-structs.md:37
msgid ""
"* Newtypes are a great way to encode additional information about the value in a primitive type, for example:\n"
"  * The number is measured in some units: `Newtons` in the example above.\n"
"  * The value passed some validation when it was created, so you no longer have to validate it again at every use: 'PhoneNumber(String)` or `OddNumber(u32)`.\n"
"* Demonstrate how to add a `f64` value to a `Newtons` type by accessing the single field in the newtype.\n"
"  *  Rust generally doesnâ€™t like inexplicit things, like automatic unwrapping or for instance using booleans as integers.\n"
"  *  Operator overloading is discussed on Day 3 (generics). \n"
"</details>"
msgstr ""
"* ë‰´íƒ€ì…ì€ ë‹¤ìŒê³¼ ê°™ì€ ì›ì‹œíƒ€ì… ê°’ì— íŠ¹ë³„í•œ ì˜ë¯¸ë¥¼ ë¶€ì—¬í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.\n"
"  * ë‹¨ìœ„ í‘œì‹œë¥¼ ìœ„í•œ ìˆ«ì: ìœ„ ì˜ˆì œì—ì„œëŠ” ë‰´í„´ ë‹¨ìœ„ í‘œê¸°ë¥¼ ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"  * ê°’ì´ ìƒì„±ë  ë•Œ ì´ë¯¸ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í†µê³¼ í–ˆìœ¼ë¯€ë¡œ ì¶”ê°€ì ì¸ ê²€ì‚¬ê°€ í•„ìš”ì—†ëŠ” ê²½ìš°: `PhoneNumber(String)`ë˜ëŠ” `OddNumber(u32)`\n"
"* `Newtons` íƒ€ì…ì˜ ê°’ì— `f64` ê°’ì„ ë”í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì£¼ì„¸ìš”.\n"
"  * ëŸ¬ìŠ¤íŠ¸ëŠ” ëŒ€ì²´ë¡œ ë¶„ëª…í•˜ì§€ ì•Šì€ ê²ƒì„ ì‹«ì–´í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ë©´ ìë™ìœ¼ë¡œ unwrapí•˜ê±°ë‚˜ ë¶ˆë¦¬ì–¸ ê°’ì„ ì •ìˆ˜ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒë“¤ì´ ê·¸ë ‡ìŠµë‹ˆë‹¤.\n"
"  * ì—°ì‚°ì ì¬ì •ì˜ëŠ” 3ì¼ì°¨ ì œë„¤ë¦­ ë¶€ë¶„ì—ì„œ ë‹¤ë£¹ë‹ˆë‹¤.\n"
"</details>"

#: src/structs/field-shorthand.md:1
msgid "# Field Shorthand Syntax"
msgstr "# í•„ë“œ í• ë‹¹ ë‹¨ì¶• ë¬¸ë²•(Field Shorthand Syntax)"

#: src/structs/field-shorthand.md:3
msgid ""
"If you already have variables with the right names, then you can create the\n"
"struct using a shorthand:"
msgstr "êµ¬ì¡°ì²´ í•„ë“œì™€ ë™ì¼í•œ ì´ë¦„ì˜ ë³€ìˆ˜ê°€ ìˆë‹¤ë©´ ì•„ë˜ì™€ ê°™ì´ \"ì§§ì€ ë¬¸ë²•\"ìœ¼ë¡œ êµ¬ì¡°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/structs/field-shorthand.md:6 src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}"
msgstr ""

#: src/structs/field-shorthand.md:13
msgid ""
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}"
msgstr ""

#: src/structs/field-shorthand.md:19
msgid ""
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:27
msgid "*  The `new` function could be written using `Self` as a type, as it is interchangeable with the struct type name"
msgstr "* `new`í•¨ìˆ˜ë¥¼ ë‹¤ìŒì²˜ëŸ¼ êµ¬ì¡°ì²´ ì´ë¦„ ëŒ€ì‹  `Self`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‘ì„±í•´ë„ ë©ë‹ˆë‹¤."

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,ignore\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:37
msgid ""
"* Methods are defined in the `impl` block.\n"
"* Use struct update syntax to define a new structure using `peter`. Note that the variable `peter` will no longer be accessible afterwards.\n"
"* Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""
"* ë©”ì„œë“œëŠ” `impl` ë¸”ë¡ì— ì •ì˜ë©ë‹ˆë‹¤.\n"
"* `peter`ì™€ êµ¬ì¡°ì²´ ì—…ë°ì´íŠ¸ ë¬¸ë²•ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ êµ¬ì¡°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”. ì´ë•Œ, `peter`ëŠ” ë”ì´ìƒ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤.\n"
"* êµ¬ì¡°ì²´ë¥¼ `Debug` í˜•íƒœë¡œ ì¶œë ¥í•˜ë ¤ë©´ `{:#?}`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/enums.md:1
msgid "# Enums"
msgstr "# ì—´ê±°í˜•"

#: src/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few\n"
"different variants:"
msgstr "`enum` í‚¤ì›Œë“œëŠ” ëª‡ê°€ì§€ ìœ í˜•(variant)ìœ¼ë¡œ í‘œí˜„ë˜ëŠ” íƒ€ì…ì„ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}"
msgstr ""

#: src/enums.md:11
msgid ""
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}"
msgstr ""

#: src/enums.md:17
msgid ""
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}"
msgstr ""

#: src/enums.md:26
msgid ""
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:31
msgid ""
"<details>\n"
"    \n"
"Key Points:"
msgstr ""
"<details>\n"
"    \n"
"í‚¤ í¬ì¸íŠ¸:"

#: src/enums.md:35
msgid ""
"* Enumerations allow you to collect a set of values under one type\n"
"* This page offers an enum type `CoinFlip` with two variants `Heads` and `Tail`. You might note the namespace when using variants.\n"
"* This might be a good time to compare Structs and Enums:\n"
"  * In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant payloads). \n"
"  * In both, associated functions are defined within an `impl` block.\n"
"  * You could even implement the different variants of an enum with separate structs but then they wouldnâ€™t be the same type as they would if they were all defined in an enum. \n"
"</details>"
msgstr ""
"* ì—´ê±°í˜•ì€ ê°’ë“¤ì˜ ì§‘í•©ì„ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.\n"
"* ìœ„ì˜ `CoinFlip` ì—´ê±°í˜• íƒ€ì…ì€ `Heads`ì™€ `Tail` ë‘ê°€ì§€ variantë¥¼ ê°€ì§‘ë‹ˆë‹¤. ì—´ê±°í˜• íƒ€ì…ì˜ variantëŠ” ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ë¶™ì—¬ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"* êµ¬ì¡°ì²´ì™€ ì—´ê±°í˜•ì„ ë¹„êµí•´ ë³¼ê¹Œìš”?\n"
"  * êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜• ëª¨ë‘, í•„ë“œê°€ í•˜ë‚˜ë„ ì—†ëŠ” ë‹¨ìˆœí•œ í˜•íƒœë„ ê°€ëŠ¥ í•˜ê³ , ì—¬ëŸ¬ íƒ€ì…ì˜ í•„ë“œë¥¼ ê°€ì§ˆ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.\n"
"  * ë‘˜ ë‹¤ ì—°ê´€í•¨ìˆ˜ë¥¼ `impl`ë¸”ë¡ìœ¼ë¡œ ì •ì˜ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"  * ì—´ê±°í˜• íƒ€ì…ì˜ ê° variantë¥¼ ë³„ë„ì˜ êµ¬ì¡°ì²´ë¡œ ì •ì˜í•  ìˆ˜ë„ ìˆì§€ë§Œ, ê·¸ëŸ¬ë©´ ì—´ê±°í˜•ì„ ì‚¬ìš©í–ˆì„ ë•Œì²˜ëŸ¼ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ ì·¨ê¸‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
"</details>"

#: src/enums/variant-payloads.md:1
msgid "# Variant Payloads"
msgstr "# ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ì—´ê±°í˜•(Variant Payloads)"

#: src/enums/variant-payloads.md:3
msgid ""
"You can define richer enums where the variants carry data. You can then use the\n"
"`match` statement to extract the data from each variant:"
msgstr "ì¢€ë” ë³µì¡í•œ ì—´ê±°í˜•ì˜ ê²½ìš° variantì— ë°ì´í„°(payload)ë¥¼ í¬í•¨ì‹œí‚¤ë„ í•©ë‹ˆë‹¤. ê° variantì— ë‹´ê¸´ ë°ì´í„°ëŠ” `match`ë¬¸ì„ ì´ìš©í•´ ì¶”ì¶œí•©ë‹ˆë‹¤:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}"
msgstr ""

#: src/enums/variant-payloads.md:13
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}"
msgstr ""

#: src/enums/variant-payloads.md:22
msgid ""
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };"
msgstr ""

#: src/enums/variant-payloads.md:27
msgid ""
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:35
msgid ""
"* The values in the enum variants can only be accessed after being pattern matched. The pattern binds references to the fields in the \"match arm\" after the `=>`.\n"
"  * The expressions is matched against the patterns from top to bottom. There is no fall-through like in C or C++.\n"
"  * The match expression has a value. The value is the last expression in the match arm which was executed.\n"
"  * Starting from the top we look for what pattern matches the value then run the code following the arrow. Once we find a match, we stop. \n"
"* Demonstrate what happens when the search is inexhaustive. Note the advantage the Rust compiler provides by confirming when all cases are handled. \n"
"* `match` inspects a hidden discriminant field in the `enum`.\n"
"* It is possible to retrieve the discriminant by calling `std::mem::discriminant()`\n"
"  * This is useful, for example, if implementing `PartialEq` for structs where comparing field values doesn't affect equality.\n"
"* `WebEvent::Click { ... }` is not exactly the same as `WebEvent::Click(Click)` with a top level `struct Click { ... }`. The inlined version cannot implement traits, for example.  \n"
"  \n"
"</details>"
msgstr ""
"* ì—´ê±°í˜• ì•ˆì˜ ê°’ì€ íŒ¨í„´ ë§¤ì¹­ì´ ë˜ê³  ë‚œ ì´í›„ì—ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ ê°’ì— ëŒ€í•œ ë ˆí¼ëŸ°ìŠ¤ëŠ” `=>` ì´í›„ì— ì‚¬ìš©ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
"  * ë§¤ì¹˜ íŒ¨í„´ë“¤ì€ ìœ„ì—ì„œ ì•„ë˜ë¡œ ìˆœì„œì— ë”°ë¼ ê²€ì‚¬í•©ë‹ˆë‹¤. Cë‚˜ C++ì—ì„œì™€ ê°™ì€ fall-throughëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
"  * ë§¤ì¹˜ í‘œí˜„ì‹ ìì²´ëŠ” ê°’ì„ ê°€ì§‘ë‹ˆë‹¤. ê·¸ ê°’ì€ ë§¤ì¹­ì´ ëœ íŒ¨í„´ì—ì„œ ê°€ì¥ ë§ˆì§€ë§‰ì— ìˆ˜í–‰ëœ í‘œí˜„ì‹ì´ ë©ë‹ˆë‹¤.\n"
"  * ê°€ì¥ ìœ„ì—ì„œ ë¶€í„° ì–´ë–¤ íŒ¨í„´ì´ ì£¼ì–´ì§„ ê°’ê³¼ ë§¤ì¹­í•˜ëŠ”ì§€ ê²€ì‚¬í•œ ë‹¤ìŒ, ë§¤ì¹­ëœ ê²ƒì´ ë°œê²¬ë˜ë©´ í™”ì‚´í‘œë¥¼ ë”°ë¼ ì½”ë“œë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. í•œ ë²ˆ ë§¤ì¹­ì´ ë˜ê³  ì½”ë“œê°€ ìˆ˜í–‰ì´ ë˜ë©´, ë”ì´ìƒì˜ ë§¤ì¹­ì€ ì—†ìŠµë‹ˆë‹¤.\n"
"* ë§¤ì¹­ íŒ¨í„´ë“¤ì´ ë¶ˆì¶©ë¶„ í•˜ë‹¤ë©´ ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì„¤ëª…í•˜ì„¸ìš”. ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ëª¨ë“  ê°€ëŠ¥í•œ ì¼€ì´ìŠ¤ë“¤ì´ í•¸ë“¤ë§ ë˜ëŠ”ì§€ ì²´í¬í•œë‹¤ëŠ” ì ì„ ìƒê¸°ì‹œí‚¤ì„¸ìš”.\n"
"* `match`ëŠ” ì£¼ì–´ì§„ ì—´ê±°í˜• ê°’ì´ ì‹¤ì œë¡œ ì–´ë–¤ variantì¸ì§€ íŒë‹¨í•˜ê¸° ìœ„í•´, ê·¸ variantì˜ ì¢…ë¥˜ê°€ ê¸°ë¡ëœ, ìˆ¨ê²¨ì§„ í•„ë“œ(ì‹ë³„ì)ì˜ ê°’ì„ ê²€ì‚¬í•©ë‹ˆë‹¤.\n"
"* `std::mem::discriminant()`ë¥¼ ì´ìš©í•˜ì—¬ ì‹ë³„ìë¥¼ ì–»ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.\n"
"  * ì´ëŠ” ê° í•„ë“œ ê°’ì„ êµ³ì´ ë¹„êµí•  í•„ìš” ì—†ëŠ” êµ¬ì¡°ì²´ì— ëŒ€í•´ `PartialEq` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.\n"
"* `WebEvent::Click { ... }`ì€ ìµœìƒìœ„ ë ˆë²¨ êµ¬ì¡°ì²´ `struct Click {...}`ë¥¼ ë”°ë¡œ ì •ì˜í•˜ê³  `WebEvent::Click(Click)`ì²˜ëŸ¼ íŠœí”Œ í˜•íƒœë¡œ ì •ì˜í•œ ê²ƒê³¼ ì •í™•íˆ ê°™ì§„ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `WebEvent::Click { ... }` ë¡œ ì •ì˜í•œ ê²½ìš°, êµ¬ì¡°ì²´ í˜•íƒœì™€ ìœ ì‚¬í•˜ì§€ë§Œ íŠ¸ë ˆì‡ì„ êµ¬í˜„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
"  \n"
"</details>"

#: src/enums/sizes.md:1
msgid "# Enum Sizes"
msgstr "# ì—´ê±°í˜• íƒ€ì…ì˜ í¬ê¸°"

#: src/enums/sizes.md:3
msgid "Rust enums are packed tightly, taking constraints due to alignment into account:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ì—´ê±°í˜•ì€ ì •ë ¬(alignment)ë¡œ ì¸í•œ ì œì•½ì„ ê³ ë ¤í•˜ì—¬ í¬ê¸°ë¥¼ ë¹½ë¹½í•˜ê²Œ ì¡ìŠµë‹ˆë‹¤:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::mem::{align_of, size_of};"
msgstr ""

#: src/enums/sizes.md:8
msgid ""
"macro_rules! dbg_size {\n"
"    ($t:ty) => {\n"
"        println!(\"{}: size {} bytes, align: {} bytes\",\n"
"                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:15
msgid ""
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}"
msgstr ""

#: src/enums/sizes.md:20
msgid ""
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}"
msgstr ""

#: src/enums/sizes.md:27
msgid ""
"fn main() {\n"
"    dbg_size!(Foo);\n"
"    dbg_size!(Bar);\n"
"    dbg_size!(bool);\n"
"    dbg_size!(Option<bool>);\n"
"    dbg_size!(&i32);\n"
"    dbg_size!(Option<&i32>);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:37
msgid "* See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)."
msgstr "* ìì„¸í•œ ì‚¬í•­ì€ [ê³µì‹ë¬¸ì„œ](https://doc.rust-lang.org/reference/type-layout.html)ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/enums/sizes.md:39
msgid ""
"<details>\n"
"    \n"
"Key Points: \n"
" * Internally Rust is using a field (discriminant) to keep track of the enum variant.\n"
" * `Bar` enum demonstrates that there is a way to control the discriminant value and type. If `repr` is removed, the discriminant type takes 2 bytes, becuase 10001 fits 2 bytes.\n"
" * As a niche optimization an enum discriminant is merged with the pointer so that `Option<&Foo>` is the same size as `&Foo`.\n"
" * `Option<bool>` is another example of tight packing.\n"
" * For [some types](https://doc.rust-lang.org/std/option/#representation), Rust guarantees that `size_of::<T>()` equals `size_of::<Option<T>>()`.\n"
" * Zero-sized types allow for efficient implementation of `HashSet` using `HashMap` with `()` as the value."
msgstr ""
"<details>\n"
"    \n"
"í‚¤ í¬ì¸íŠ¸: \n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì—´ê±°í˜•ì˜ ê° variantë¥¼ êµ¬ë¶„í•˜ê¸° ìœ„í•´ ë³„ë„ì˜ í•„ë“œ(ì‹ë³„ì)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"* `Bar` íƒ€ì…ì„ ë³´ë©´ ì‹ë³„ìì˜ ê°’ì„ ì§ì ‘ ì§€ì •í•˜ê±°ë‚˜ ê·¸ íƒ€ì…ì„ ë³€ê²½í•  ìˆ˜ ìˆìŒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`repr`ì„ ì œê±°í•˜ë©´ 10001ì„ ë‚˜íƒ€ë‚´ëŠ”ë° 2ë°”ì´íŠ¸ê°€ í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ì‹ë³„ì íƒ€ì…ì´ 2ë°”ì´íŠ¸ë¥¼ ì°¨ì§€í•©ë‹ˆë‹¤.\n"
"* ë‹ˆì¹˜ ìµœì í™”(niche optimization)ë¡œì„œ ì—´ê±°í˜•(enum)ì˜ ì‹ë³„ìëŠ” í¬ì¸í„°ì— ê²°í•©ë©ë‹ˆë‹¤.ê·¸ë˜ì„œ `Option<&Foo>` íƒ€ì…ì€ `&Foo`ì™€ ê°™ì€ ì‚¬ì´ì¦ˆê°€ ë©ë‹ˆë‹¤.\n"
"* `Option<bool>ì—­ì‹œ ì´ì— ëŒ€í•œ ë˜ ë‹¤ë¥¸ ì˜ˆì…ë‹ˆë‹¤.\n"
"* [ì¼ë¶€ íƒ€ì…](https://doc.rust-lang.org/std/option/#representation)ì˜ ê²½ìš° ëŸ¬ìŠ¤íŠ¸ëŠ” `size_of::<T>()`ì™€ `size_of::<Option<T>>()`ê°€ ë™ì¼í•¨ì„ ë³´ì¥í•©ë‹ˆë‹¤. \n"
"* 0í¬ê¸° íƒ€ì… ë•ë¶„ì— `HashMap`ì˜ ê°’ì„ `()`ë¡œ ì§€ì •í•˜ëŠ” ì‹ìœ¼ë¡œ `HashSet`ì„ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/enums/sizes.md:49
msgid ""
"Example code if you want to show how the bitwise representation *may* look like in practice.\n"
"It's important to note that the compiler provides no guarantees regarding this representation, therefore this is totally unsafe."
msgstr "ë¹„íŠ¸ ìˆ˜ì¤€ì—ì„œ ì–´ë–¤ì‹ìœ¼ë¡œ í‘œí˜„ë˜ëŠ”ì§€ ë³´ì—¬ì£¼ê³  ì‹¶ë‹¤ë©´ ë‹¤ìŒ ì˜ˆì œ ì½”ë“œë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”. ì»´íŒŒì¼ëŸ¬ê°€ ë¹„íŠ¸ í‘œí˜„ê¹Œì§€ ë³´ì¥í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì—¬ê¸°ì— ì˜ì¡´í•˜ëŠ” ê²ƒì€ ì•ˆì „í•˜ì§€ ì•Šë‹¤ëŠ” ì ì„ ê¼­ ì•Œë ¤ì£¼ì„¸ìš”."

#: src/enums/sizes.md:52
msgid ""
"```rust,editable\n"
"use std::mem::transmute;"
msgstr ""

#: src/enums/sizes.md:55 src/enums/sizes.md:94
msgid ""
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, $bit_type>($e));\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:61
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        println!(\"Bitwise representation of bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);"
msgstr ""

#: src/enums/sizes.md:69
msgid ""
"        println!(\"Bitwise representation of Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);"
msgstr ""

#: src/enums/sizes.md:74
msgid ""
"        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);"
msgstr ""

#: src/enums/sizes.md:80
msgid ""
"        println!(\"Bitwise representation of Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:87
msgid "More complex example if you want to discuss what happens when we chain more than 256 `Option`s together."
msgstr "ì¢€ë” ë³µì¡í•œ ì˜ˆì œì…ë‹ˆë‹¤. `Option`ì„ 256ê°œ ì´ìƒìœ¼ë¡œ ì¤‘ì²©í•œ ê²½ìš°ì— ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/enums/sizes.md:89
msgid ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]"
msgstr ""

#: src/enums/sizes.md:92
msgid "use std::mem::transmute;"
msgstr ""

#: src/enums/sizes.md:100
msgid ""
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" signs.\n"
"// Increasing the recursion limit is required to evaluate this macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}"
msgstr ""

#: src/enums/sizes.md:112
msgid ""
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));"
msgstr ""

#: src/enums/sizes.md:120
msgid ""
"        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);"
msgstr ""

#: src/enums/sizes.md:124
msgid ""
"        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);"
msgstr ""

#: src/enums/sizes.md:128
msgid ""
"        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with an\n"
"`impl` block:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì„ ì–¸ëœ íƒ€ì…ì— ëŒ€í•´ `impl`ë¸”ë¡ì— í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ì—¬ ë©”ì„œë“œë¥¼ ì—°ê²° í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/methods.md:13
msgid ""
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/methods.md:19
msgid ""
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:30
msgid ""
"Key Points:\n"
"* It can be helpful to introduce methods by comparing them to functions.\n"
"  * Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as `self`.\n"
"  * Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. By using methods we can keep all the implementation code in one predictable place.\n"
"* Point out the use of the keyword `self`, a method receiver. \n"
"  * Show that it is an abbreviated term for `self:&Self` and perhaps show how the struct name could also be used. \n"
"  * Explain that `Self` is a type alias for the type the `impl` block is in and can be used elsewhere in the block.\n"
"  * Note how `self` is used like other structs and dot notation can be used to refer to individual fields.\n"
"  * This might be a good time to demonstrate how the `&self` differs from `self` by modifying the code and trying to run say_hello twice.  \n"
"* We describe the distinction between method receivers next.\n"
"   \n"
"</details>"
msgstr ""
"í‚¤ í¬ì¸íŠ¸: \n"
"* ë©”ì„œë“œë¥¼ í•¨ìˆ˜ì™€ ë¹„êµí•˜ì—¬ ì†Œê°œí•˜ëŠ” ê²ƒë„ ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"  * ë©”ì„œë“œëŠ” êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜•ê³¼ ê°™ì€ íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ í˜¸ì¶œ ë˜ë©°, ì²«ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜(íŒŒë¼ë©”í„°)ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ `self`ë¡œ í‘œê¸°í•©ë‹ˆë‹¤.\n"
"  * ë©”ì„œë“œë¥¼ ì´ìš©í•˜ë©´ receiver ë¬¸ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê³  ì½”ë“œë¥¼ ì¢€ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë©”ì„œë“œë“¤ì´ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ìœ„ì¹˜ì— ëª¨ì—¬ ìˆìœ¼ë‹ˆ ì°¾ê¸° ì‰½ìŠµë‹ˆë‹¤.\n"
"* ë©”ì„œë“œ receiverì¸ `self` í‚¤ì›Œë“œ ì‚¬ìš©ì„ ì–¸ê¸‰í•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"  * ì˜ˆì œì˜ ê²½ìš° `self: &Self`ì˜ ì¤„ì¸ ë²„ì „ì„ì„ ì•Œë ¤ì£¼ê³ , êµ¬ì¡°ì²´ì˜ ì´ë¦„ì„ ì§ì ‘ ì‚¬ìš©í•˜ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ë³´ì—¬ì£¼ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤.\n"
"  * `impl` ë¸”ë¡ ë‚´ë¶€ì—ì„œëŠ” `Self`ê°€ í•´ë‹¹ íƒ€ì…ì˜ ì´ë¦„ ëŒ€ìš©ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒì„ ì•Œë ¤ì£¼ì„¸ìš”.\n"
"  * êµ¬ì¡°ì²´ì˜ í•„ë“œë¥¼ ì ‘ê·¼í•  ë•Œ ì  í‘œê¸°ë¥¼ ì‚¬ìš©í•˜ë“¯ì´ `self`ì— ì  í‘œê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°œë³„ í•„ë“œë“¤ì„ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"  * `say_hello` í•¨ìˆ˜ê°€ ë‘ ë²ˆ í˜¸ì¶œë˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì—¬ `&self`ì™€ `self`ê°€ ì–´ë–»ê²Œ ë‹¤ë¥¸ì§€ ë³´ì—¬ì£¼ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤.\n"
"* ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œ receiverì˜ êµ¬ë¶„ì„ ì„¤ëª…í•©ë‹ˆë‹¤.\n"
"</details>"

#: src/methods/receiver.md:1
msgid "# Method Receiver"
msgstr "# ë©”ì„œë“œ ë¦¬ì‹œë²„(Receiver)"

#: src/methods/receiver.md:3
msgid ""
"The `&self` above indicates that the method borrows the object immutably. There\n"
"are other possible receivers for a method:"
msgstr "`&self`ëŠ” ë©”ì„œë“œê°€ ê°ì²´ë¥¼ ë¶ˆë³€í•˜ê²Œ ë¹Œë ¤ì˜´ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ë©”ì„œë“œì˜ ë¦¬ì‹œë²„ëŠ” ë‹¤ìŒì˜ í˜•íƒœë“¤ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/methods/receiver.md:6
msgid ""
"* `&self`: borrows the object from the caller using a shared and immutable\n"
"  reference. The object can be used again afterwards.\n"
"* `&mut self`: borrows the object from the caller using a unique and mutable\n"
"  reference. The object can be used again afterwards.\n"
"* `self`: takes ownership of the object and moves it away from the caller. The\n"
"  method becomes the owner of the object. The object will be dropped (deallocated)\n"
"  when the method returns, unless its ownership is explicitly\n"
"  transmitted.\n"
"* `mut self`: same as above, but while the method owns the object, it can\n"
"  mutate it too. Complete ownership does not automatically mean mutability.\n"
"* No receiver: this becomes a static method on the struct. Typically used to\n"
"  create constructors which are called `new` by convention."
msgstr ""
"* `&self`: í˜¸ì¶œìë¡œë¶€í„° ê³µìœ ê°€ëŠ¥í•œ ë¶ˆë³€ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ ê°ì²´ë¥¼ ë¹Œë ¤ì˜´ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ê°ì²´ëŠ” ë©”ì†Œë“œ í˜¸ì¶œ ë’¤ì—ë„ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `&mut self`: í˜¸ì¶œìë¡œë¶€í„° ìœ ì¼í•œ ê°€ë³€ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ ê°ì²´ë¥¼ ë¹Œë ¤ì˜´ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ê°ì²´ëŠ” ë©”ì†Œë“œ í˜¸ì¶œ ë’¤ì—ë„ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `self`: í˜¸ì¶œìë¡œë¶€í„° ê°ì²´ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜¤ê³  ê°ì²´ëŠ” í˜¸ì¶œìë¡œë¶€í„° ë©”ì†Œë“œë¡œ ì´ë™ë©ë‹ˆë‹¤. ë©”ì†Œë“œê°€ ê°ì²´ë¥¼ ì†Œìœ í•˜ê²Œ ë˜ë©° ë”°ë¼ì„œ ëª…ì‹œì ìœ¼ë¡œ ì†Œìœ ê¶Œì„ ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ì „ë‹¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë©”ì„œë“œ ì¢…ë£Œì™€ í•¨ê»˜ ê°ì²´ëŠ” drop(í•´ì œ)ë©ë‹ˆë‹¤.\n"
"* `mut self`: ìœ„ì™€ ë™ì¼í•˜ì§€ë§Œ ë©”ì„œë“œê°€ ê°ì²´ì˜ ì†Œìœ ê¶Œì„ ê°€ì§€ë©´ì„œ ë™ì‹œì— ê°ì²´ë¥¼ ìˆ˜ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì†Œìœ ê¶Œì„ ê°€ì§€ëŠ” ê²ƒì´ ìˆ˜ì •í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•˜ëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤.\n"
"* ë¦¬ì‹œë²„ ì—†ìŒ: êµ¬ì¡°ì²´ì˜ ì •ì  ë©”ì„œë“œê°€ ë©ë‹ˆë‹¤. ì£¼ë¡œ ìƒì„±ìë¥¼ ë§Œë“¤ë•Œ ì‚¬ìš©í•˜ê²Œ ë˜ë©°, ìƒì„±ìëŠ” í”íˆ `new`ë¼ê³  ì´ë¦„ë¶™ì…ë‹ˆë‹¤."

#: src/methods/receiver.md:19
msgid ""
"Beyond variants on `self`, there are also\n"
"[special wrapper types](https://doc.rust-lang.org/reference/special-types-and-traits.html)\n"
"allowed to be receiver types, such as `Box<Self>`."
msgstr "`self`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ê°™ì€ ë³€í˜•ë“¤ ì™¸ì—ë„ `Box<Self>`ì™€ ê°™ì´ ë¦¬ì‹œë²„ íƒ€ì…ìœ¼ë¡œ í—ˆìš©ë˜ëŠ” [íŠ¹ë³„í•œ ë˜í¼ íƒ€ì…](https://doc.rust-lang.org/reference/special-types-and-traits.html)ì´ ìˆìŠµë‹ˆë‹¤."

#: src/methods/receiver.md:23
msgid ""
"<details>\n"
"  \n"
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". These constraints always come\n"
"together in Rust due to borrow checker rules, and `self` is no exception. It isn't possible to\n"
"reference a struct from multiple locations and call a mutating (`&mut self`) method on it.\n"
"  \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
" \"ê³µìœ ê°€ëŠ¥í•œ ë¶ˆë³€\"ê³¼ \"ìœ ì¼í•œ ê°€ë³€\" ë¶€ë¶„ì€ ê°•ì¡°í•  ë§Œí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì œì•½ì€ ëŸ¬ìŠ¤íŠ¸ì˜ ë¹Œë¦¼ ê²€ì‚¬ê¸°(borrow checker) ê·œì¹™ìœ¼ë¡œ ëŠ˜ ë¶™ì–´ë‹¤ë‹™ë‹ˆë‹¤. `self`ë„ ì˜ˆì™¸ëŠ” ì•„ë‹™ë‹ˆë‹¤. ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ êµ¬ì¡°ì²´ë¥¼ ì°¸ì¡°í•˜ë©´ì„œ ê°ì²´ë¥¼ ìˆ˜ì •í•˜ëŠ”(`&mut self`ë¥¼ ë¦¬ì‹œë²„ë¡œ í•˜ëŠ”) ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
"</details>"

#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "# Example"
msgstr "# ì˜ˆì œ"

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}"
msgstr ""

#: src/methods/example.md:10
msgid ""
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }"
msgstr ""
"impl Race {\n"
"    fn new(name: &str) -> Race {  // ë¦¬ì‹œë²„ ì—†ìŒ. ì •ì  ë©”ì„œë“œ\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }"

#: src/methods/example.md:15
msgid ""
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write access to self\n"
"        self.laps.push(lap);\n"
"    }"
msgstr ""
"    fn add_lap(&mut self, lap: i32) {  // selfì— ëŒ€í•œ ë°°íƒ€ì ì¸ ë¹Œë¦¼. ì½ê³  ì“°ê¸° ê°€ëŠ¥\n"
"        self.laps.push(lap);\n"
"    }"

#: src/methods/example.md:19
msgid ""
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }"
msgstr ""
"    fn print_laps(&self) {  // selfì— ëŒ€í•œ ì½ê¸° ì „ìš© ë¹Œë¦¼. ê³µìœ  ê°€ëŠ¥\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }"

#: src/methods/example.md:26
msgid ""
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
"    }\n"
"}"
msgstr ""
"    fn finish(self) {  // ë°°íƒ€ì  self ì†Œìœ ê¶Œ\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, total);\n"
"    }\n"
"}"

#: src/methods/example.md:32
msgid ""
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:44
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* All four methods here use a different method receiver.\n"
"  * You can point out how that changes what the function can do with the variable values and if/how it can be used again in `main`.\n"
"  * You can showcase the error that appears when trying to call `finish` twice.\n"
"* Note that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the `&`, `*`, `muts` so that that object matches the method signature.\n"
"* You might point out that `print_laps` is using a vector that is iterated over. We describe vectors in more detail in the afternoon. "
msgstr ""
"<details>\n"
"    \n"
"í‚¤ í¬ì¸íŠ¸:\n"
"* 4ê°€ì§€ ìœ í˜•ì˜ ë©”ì„œë“œ receiverì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤.\n"
"  * receiver ìœ í˜•ì— ë”°ë¼ í•¨ìˆ˜ê°€ í•  ìˆ˜ ìˆëŠ” ì¼ì´ ë‹¬ë¼ì§€ê³ , ë˜ ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•œ ë’¤ `main`ì—ì„œ í•´ë‹¹ ê°ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ë„ ë‹¬ë¼ì§„ë‹¤ëŠ” ì ì„ ê°•ì¡°í•˜ì„¸ìš”.\n"
"  * `finish`ë¥¼ ë‘ë²ˆ í˜¸ì¶œí•˜ì—¬ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ë¹„ë¡ ë©”ì„œë“œ receiverëŠ” ë‹¤ë¥´ì§€ë§Œ main í•¨ìˆ˜ì—ì„œ ë¹„ ì •ì  í•¨ìˆ˜ë¥¼ ë¶€ë¥´ëŠ” ë°©ë²•ì€ ê°™ìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ë•Œ ìë™ìœ¼ë¡œ ì°¸ì¡°/ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ê°ì²´ì™€ ë§¤ì„œë“œ ì‹œê·¸ë‹ˆì²˜ê°€ ì„œë¡œ ë§¤ì¹˜ë˜ë„ë¡ ê°ì²´ì— `&`, `*`, `muts`ë¥¼ ìë™ìœ¼ë¡œ ë¶™ì—¬ì¤ë‹ˆë‹¤.\n"
"* `print_laps`í•¨ìˆ˜ì—ì„œ ë²¡í„°ë¥¼ ì–´ë–¤ ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ìˆëŠ”ì§€ ì–¸ê¸‰í•˜ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤. ë²¡í„°ëŠ” ì˜¤í›„ ê°•ì˜ì—ì„œ ë” ìì„¸íˆ ì„¤ëª…í•  ê²ƒì…ë‹ˆë‹¤. "

#: src/pattern-matching.md:1
msgid "# Pattern Matching"
msgstr "# íŒ¨í„´ ë§¤ì¹­"

#: src/pattern-matching.md:3
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. The\n"
"comparisons are done from top to bottom and the first match wins."
msgstr "`match`í‚¤ì›Œë“œëŠ” ê°’ì„ ì—¬ëŸ¬ í˜•íƒœì˜ íŒ¨í„´ê³¼ ë§¤ì¹˜ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§¨ ìœ„ íŒ¨í„´ë¶€í„° í•˜ë‚˜ì”© ë§¤ì¹˜ë˜ëŠ”ì§€ ê²€ì‚¬í•˜ë©°, ì²˜ìŒìœ¼ë¡œ ë§¤ì¹˜ë˜ëŠ” íŒ¨í„´ì´ ì„ íƒë©ë‹ˆë‹¤."

#: src/pattern-matching.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "C/C++ì˜ `switch`ì™€ ë¹„ìŠ·í•˜ê²Œ ê°’ì„ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';"
msgstr ""

#: src/pattern-matching.md:12
msgid ""
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr "`_`íŒ¨í„´ì€ ì–´ë–¤ ê°’ê³¼ë„ ë§¤ì¹­ë˜ëŠ” ì™€ì¼ë“œì¹´ë“œì…ë‹ˆë‹¤."

#: src/pattern-matching.md:23
msgid ""
"<details>\n"
"    \n"
"Key Points:\n"
"* You might point out how some specific characters are being used when in a pattern\n"
"  * `|` as an `or`\n"
"  * `..` can expand as much as it needs to be\n"
"  * `1..=5` represents an inclusive range\n"
"  * `_` is a wild card\n"
"* It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around `q`.\n"
"* You can demonstrate matching on a reference.\n"
"* This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.\n"
"   \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"í‚¤ í¬ì¸íŠ¸:\n"
"* íŒ¨í„´ì—ì„œ ì‚¬ìš©ë˜ëŠ” íŠ¹ìˆ˜ ë¬¸ìë“¤ì„ ì•Œë ¤ì£¼ì„¸ìš”.\n"
"  * `|`: or ê¸°í˜¸ì…ë‹ˆë‹¤.\n"
"  * `..`: í•„ìš”í•œ ë§Œí¼ í™•ì¥í•©ë‹ˆë‹¤.\n"
"  * `1..=5`: ë ê°’(ì—¬ê¸°ì„œëŠ” 5)ì„ í¬í•¨í•˜ëŠ” ë²”ìœ„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\n"
"  * `_`: ì™€ì¼ë“œì¹´ë“œì…ë‹ˆë‹¤.\n"
"* ì™€ì¼ë“œì¹´ë“œ ë¬¸ìë¥¼ ë³€ìˆ˜ë¡œ ë°”ê¾¸ê±°ë‚˜ `q`ì˜ ë”°ì˜´í‘œë¥¼ ì œê±°í•˜ëŠ” ì‹ìœ¼ë¡œ ìˆ˜ì •í•˜ë©´ì„œ ë°”ì¸ë”©ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ë³´ì—¬ì£¼ëŠ” ê²ƒë„ ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì°¸ì¡°ë¥¼ ë§¤ì¹­í•˜ëŠ” ê²ƒë„ ì‹œì—°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì—ëŸ¬ ë©”ì‹œì§€ì— \"ë°˜ë°• ë¶ˆê°€ëŠ¥ íŒ¨í„´(irrefutable pattern)\"ì´ë€ ìš©ì–´ê°€ ë“±ì¥í•˜ê¸°ë„ í•©ë‹ˆë‹¤. ì§€ê¸ˆ ê·¸ ì˜ë¯¸ë¥¼ ì†Œê°œí•˜ëŠ” ê²ƒë„ ì¢‹ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.\n"
"\n"
"</details>"

#: src/pattern-matching/destructuring-enums.md:1
msgid "# Destructuring Enums"
msgstr "# ì—´ê±°í˜• ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/pattern-matching/destructuring-enums.md:3
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is how\n"
"you inspect the structure of your types. Let us start with a simple `enum` type:"
msgstr "êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜• ê°’ì˜ ì¼ë¶€ë¥¼ íŒ¨í„´ ë§¤ì¹˜ë¥¼ í†µí•´ ë³€ìˆ˜ì— ë°”ì¸ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°„ë‹¨í•œ `enum` íƒ€ì…ì„ ë¨¼ì € ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"
msgstr ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}"

#: src/pattern-matching/destructuring-enums.md:12
msgid ""
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}"
msgstr ""
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}"

#: src/pattern-matching/destructuring-enums.md:20
msgid ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-enums.md:29
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first\n"
"arm, `half` is bound to the value inside the `Ok` variant. In the second arm,\n"
"`msg` is bound to the error message."
msgstr "`match`êµ¬ë¬¸ì—ì„œ `divide_in_two`í•¨ìˆ˜ì—ì„œ ë°˜í™˜ë˜ëŠ” `Result` ê°’ì„ ë‘ ê°œì˜ íŒ”(í˜¹ì€ ê°€ì§€)ë¡œ _ë¶„í•´(destructure)_ í•˜ì˜€ìŠµë‹ˆë‹¤. ì²«ë²ˆì§¸ íŒ”ì—ì„œ `half`ëŠ” `Ok` variantì— ë‹´ê¸´ ê°’ìœ¼ë¡œ ë°”ì¸ë”©ë©ë‹ˆë‹¤. ë‘ë²ˆì§¸ íŒ”ì—ì„œ `msg`ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ ë¬¸ìì—´ì— ë°”ì¸ë”©ë©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring-enums.md:35
msgid ""
"Key points:\n"
"* The `if`/`else` expression is returning an enum that is later unpacked with a `match`.\n"
"* You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now inexhaustive and how the compiler tries to give you hints."
msgstr ""
"í‚¤ í¬ì¸íŠ¸:\n"
"* `if`/`else` í‘œí˜„ì‹ì€ ì—´ê±°í˜•ì„ ë°˜í™˜í•˜ê³ , ì´ ê°’ì€ ë‚˜ì¤‘ì— `match`ë¡œ ë¶„í•´ë©ë‹ˆë‹¤.\n"
"* ì—´ê±°í˜•ì— ì„¸ë²ˆì§¸ variantë¥¼ ì¶”ê°€í•˜ê³  ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ ì˜¤ë¥˜ë¥¼ í‘œì‹œí•´ë³´ì„¸ìš”. ì½”ë“œ ì–´ëŠ ë¶€ë¶„ì— ëˆ„ë½ì´ ìˆëŠ”ì§€, ê·¸ë¦¬ê³  ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–¤ ì‹ìœ¼ë¡œ íŒíŠ¸ë¥¼ ì£¼ëŠ”ì§€ ê°™ì´ ì‚´í´ë³´ì„¸ìš”."

#: src/pattern-matching/destructuring-structs.md:1
msgid "# Destructuring Structs"
msgstr "# êµ¬ì¡°ì²´ ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/pattern-matching/destructuring-structs.md:3
msgid "You can also destructure `structs`:"
msgstr "`struct` êµ¬ì¡°ì²´ ì—­ì‹œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"
msgstr ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}"

#: src/pattern-matching/destructuring-structs.md:11
msgid ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"<details>"
msgstr ""
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"<details>"

#: src/pattern-matching/destructuring-structs.md:23
msgid ""
"* Change the literal values in `foo` to match with the other patterns.\n"
"* Add a new field to `Foo` and make changes to the pattern as needed.\n"
"</details>"
msgstr ""
"* `foo` ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì— ì‚¬ìš©ëœ ë¦¬í„°ëŸ´ ê°’ì„ ë³€ê²½í•´ì„œ ë‹¤ë¥¸ íŒ¨í„´ì— ë§¤ì¹˜ë˜ë„ë¡ í•´ë³´ì„¸ìš”.\n"
"* `Foo` êµ¬ì¡°ì²´ì— ìƒˆ í•„ë“œë¥¼ ì¶”ê°€í•˜ê³  íŒ¨í„´ë„ ë°”ê¿”ë³´ì„¸ìš”.\n"
"</details>"

#: src/pattern-matching/destructuring-arrays.md:1
msgid "# Destructuring Arrays"
msgstr "# ë°°ì—´ ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/pattern-matching/destructuring-arrays.md:3
msgid "You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr "ë°°ì—´ì´ë‚˜ íŠœí”Œ, ìŠ¬ë¼ì´ìŠ¤ë„ ê·¸ ìš”ì†Œë“¤ì— ëŒ€í•´ íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/destructuring-arrays.md:21
msgid "* Destructuring of slices of unknown length also works with patterns of fixed length."
msgstr "* ê¸¸ì´ë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•´ì„œë„ ê³ ì • ê¸¸ì´ íŒ¨í„´ìœ¼ë¡œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/pattern-matching/destructuring-arrays.md:24
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}"

#: src/pattern-matching/destructuring-arrays.md:30
msgid ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"  \n"
"* Create a new pattern using `_` to represent an element. \n"
"* Add more values to the array.\n"
"* Point out that how `..` will expand to account for different number of elements.\n"
"* Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```\n"
"* ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ë§¤ì¹­í•  ë•Œ `_`ë¥¼ ì‚¬ìš©í•˜ëŠ” íŒ¨í„´ì„ ì¶”ê°€í•´ ë³´ì„¸ìš”.\n"
"* ë°°ì—´ì— ê°’ì„ ë” ì¶”ê°€í•´ ë³´ì„¸ìš”.\n"
"* `..`ê°€ ì„œë¡œ ë‹¤ë¥¸ ê°œìˆ˜ì˜ ì—˜ë¦¬ë¨¼íŠ¸ë“¤ì— ëŒ€í•´ ì–´ë–»ê²Œ í™•ì¥ë˜ëŠ”ì§€ ì„¤ëª…í•˜ì„¸ìš”.\n"
"* `[.., b]`ë‚˜ `[a@.., b]`ì™€ ê°™ì€ íŒ¨í„´ìœ¼ë¡œ ê¼¬ë¦¬ ë¶€ë¶„ì„ ë§¤ì¹­í•˜ëŠ” ê²ƒì„ ë³´ì—¬ì£¼ì„¸ìš”.\n"
"</details>"

#: src/pattern-matching/match-guards.md:1
msgid "# Match Guards"
msgstr "# ë§¤ì¹˜ ê°€ë“œ"

#: src/pattern-matching/match-guards.md:3
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary Boolean\n"
"expression which will be executed if the pattern matches:"
msgstr "íŒ¨í„´ ë’¤ì— ê°€ë“œ(guard, ì¡°ê±´ì‹)ë¥¼ ë§ë¶™ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ë“œëŠ” íŒ¨í„´ì´ ë§¤ì¹˜ë˜ë©´ ì¶”ê°€ë¡œ ë”°ì ¸ë³´ëŠ” ë¶ˆë¦¬ì–¸ í‘œí˜„ì‹ì…ë‹ˆë‹¤:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"

#: src/pattern-matching/match-guards.md:22
msgid ""
"Key Points:\n"
"* Match guards as a separate syntax feature are important and necessary when we wish to concisely express more complex ideas than patterns alone would allow.\n"
"* They are not the same as separate `if` expression inside of the match arm. An `if` expression inside of the branch block (after `=>`) happens after the match arm is selected. Failing the `if` condition inside of that block won't result in other arms\n"
"of the original `match` expression being considered.  \n"
"* You can use the variables defined in the pattern in your if expression.\n"
"* The condition defined in the guard applies to every expression in a pattern with an `|`.\n"
"</details>"
msgstr ""
"í‚¤ í¬ì¸íŠ¸:\n"
"* ë§¤ì¹˜ ê°€ë“œëŠ” ë³„ë„ì˜ ë¬¸ë²• ìš”ì†Œë¡œì„œ íŒ¨í„´ ìì²´ë§Œìœ¼ë¡œ í‘œí˜„í•˜ê¸° ì–´ë ¤ìš´ ë³µì¡í•œ ê²½ìš°ë¥¼ ê°„ê²°í•˜ê²Œ í‘œí˜„í•˜ê³ ì í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.\n"
"* ë§¤ì¹˜ì˜ ê° íŒ”(í˜¹ì€ ê°€ì§€) ì•ˆì— ë”°ë¡œ `if`ë¥¼ ì‚¬ìš©í•œ ê²ƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. ë§¤ì¹˜ ê°€ì§€ì˜ `=>` ë’¤ì— ì‚¬ìš©ëœ `if` í‘œí˜„ì‹ì€ í•´ë‹¹\n"
"  ê°€ì§€ê°€ ì„ íƒëœ ë‹¤ìŒì— ì‹¤í–‰ë©ë‹ˆë‹¤. ë”°ë¼ì„œ ì—¬ê¸°ì„œ `if` ì¡°ê±´ì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì›ë˜ `match`ì˜ ë‹¤ë¥¸ ê°€ì§€ëŠ” ê³ ë ¤ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"* íŒ¨í„´ì— ì •ì˜ëœ ë³€ìˆ˜ë¥¼ ê°€ë“œì˜ í‘œí˜„ì‹ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ê°€ë“œì— ì •ì˜ëœ ì¡°ê±´ì€ `|` ë¥¼ í¬í•¨í•˜ëŠ” íŒ¨í„´ì˜ ëª¨ë“  í‘œí˜„ì‹ì— ì ìš©ë©ë‹ˆë‹¤.\n"
"</details>"

#: src/exercises/day-2/morning.md:1
msgid "# Day 2: Morning Exercises"
msgstr "# 2ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-2/morning.md:3
msgid "We will look at implementing methods in two contexts:"
msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œë“¤ì€ ë‘ê°€ì§€ ë§¥ë½ì—ì„œ ë©”ì„œë“œ êµ¬í˜„ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤:"

#: src/exercises/day-2/morning.md:5
msgid "* Simple struct which tracks health statistics."
msgstr "* ê±´ê°• ìƒíƒœ í†µê³„ë¥¼ ì¶”ì í•˜ëŠ” í”„ë¡œê·¸ë¨ì˜ ê°„ë‹¨í•œ êµ¬ì¡°ì²´."

#: src/exercises/day-2/morning.md:7
msgid "* Multiple structs and enums for a drawing library."
msgstr "* ë“œë¡œì‰ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìœ„í•œ êµ¬ì¡°ì²´ ë° ì—´ê±°í—."

#: src/exercises/day-2/health-statistics.md:1
msgid "# Health Statistics"
msgstr "# ê±´ê°•ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"

#: src/exercises/day-2/health-statistics.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, you\n"
"need to keep track of users' health statistics."
msgstr "ë‹¹ì‹ ì€ ê±´ê°• ìƒíƒœë¥¼ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ëŠ” ì¼ì„ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ê·¸ ì¼í™˜ìœ¼ë¡œ ë‹¹ì‹ ì€ ì‚¬ìš©ìì˜ ê±´ê°• ìƒíƒœ í†µê³„ë¥¼ ì¶”ì í•´ì•¼í•©ë‹ˆë‹¤."

#: src/exercises/day-2/health-statistics.md:6
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a `User`\n"
"struct definition. Your goal is to implement the stubbed out methods on the\n"
"`User` `struct` defined in the `impl` block."
msgstr "ë‹¹ì‹ ì˜ ëª©í‘œëŠ” `User` êµ¬ì¡°ì²´ì˜ `impl` ë¸”ë¡ì˜ ë¹ˆ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/exercises/day-2/health-statistics.md:10
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"methods:"
msgstr "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ ë¹ ì§„ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤:"

#: src/exercises/day-2/health-statistics.md:17
msgid ""
"struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    weight: f32,\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:23
msgid ""
"impl User {\n"
"    pub fn new(name: String, age: u32, weight: f32) -> Self {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:28
msgid ""
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:32
msgid ""
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:36
msgid ""
"    pub fn weight(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:40
msgid ""
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-2/health-statistics.md:44
msgid ""
"    pub fn set_weight(&mut self, new_weight: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:49
msgid ""
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:54
msgid ""
"#[test]\n"
"fn test_weight() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.weight(), 155.2);\n"
"}"
msgstr ""

#: src/exercises/day-2/health-statistics.md:60
msgid ""
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:1
msgid "# Polygon Struct"
msgstr "# Polygon êµ¬ì¡°ì²´"

#: src/exercises/day-2/points-polygons.md:3
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code below\n"
"to <https://play.rust-lang.org/> and fill in the missing methods to make the\n"
"tests pass:"
msgstr "ìš°ë¦¬ëŠ” ëª‡ê°œì˜ ê¼­ì§€ì ì„ ê°€ì§„ ë‹¤ê°í˜•ì„ í‘œí˜„í•˜ëŠ” `Polygon` êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ ê²ƒì…ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í•˜ë„ë¡ ë¹ ì§„ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤:"

#: src/exercises/day-2/points-polygons.md:7 src/exercises/day-2/luhn.md:23
#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]"
msgstr ""

#: src/exercises/day-2/points-polygons.md:11
msgid ""
"pub struct Point {\n"
"    // add fields\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:15
msgid ""
"impl Point {\n"
"    // add methods\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:19
msgid ""
"pub struct Polygon {\n"
"    // add fields\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:23
msgid ""
"impl Polygon {\n"
"    // add methods\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:27
msgid ""
"pub struct Circle {\n"
"    // add fields\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:31
msgid ""
"impl Circle {\n"
"    // add methods\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:35
msgid ""
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:40 src/testing/test-modules.md:15
msgid ""
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""

#: src/exercises/day-2/points-polygons.md:44
#: src/exercises/day-2/solutions-morning.md:165
msgid ""
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:48
#: src/exercises/day-2/solutions-morning.md:169
msgid ""
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:54
#: src/exercises/day-2/solutions-morning.md:175
msgid ""
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:61
#: src/exercises/day-2/solutions-morning.md:182
msgid ""
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:68
#: src/exercises/day-2/solutions-morning.md:189
msgid ""
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""

#: src/exercises/day-2/points-polygons.md:73
#: src/exercises/day-2/solutions-morning.md:194
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:79
#: src/exercises/day-2/solutions-morning.md:200
msgid ""
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);"
msgstr ""

#: src/exercises/day-2/points-polygons.md:84
#: src/exercises/day-2/solutions-morning.md:205
msgid ""
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);"
msgstr ""

#: src/exercises/day-2/points-polygons.md:88
#: src/exercises/day-2/solutions-morning.md:209
msgid ""
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }"
msgstr ""

#: src/exercises/day-2/points-polygons.md:92
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/points-polygons.md:111 src/exercises/day-2/luhn.md:68
msgid ""
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/points-polygons.md:117
msgid ""
"Since the method signatures are missing from the problem statements, the key part\n"
"of the exercise is to specify those correctly. You don't have to modify the tests."
msgstr "ëˆ„ë½ëœ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì •ì˜í•˜ëŠ” ê²ƒì´ ë¬¸ì œì˜ í•µì‹¬ ë¶€ë¶„ì…ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ëŠ” ìˆ˜ì •í•˜ë©´ ì•ˆë©ë‹ˆë‹¤."

#: src/exercises/day-2/points-polygons.md:120
msgid ""
"Other interesting parts of the exercise:\n"
"    \n"
"* Derive a `Copy` trait for some structs, as in tests the methods sometimes don't borrow their arguments.\n"
"* Discover that `Add` trait must be implemented for two objects to be addable via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"ì—°ìŠµë¬¸ì œì˜ ë‹¤ë¥¸ í¥ë¯¸ë¡œìš´ ë¶€ë¶„:\n"
"    \n"
"* í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ë³´ë©´ ì–´ë–¤ ë©”ì„œë“œë“¤ì€ ì¸ìë¥¼ borrowí•˜ëŠ” ëŒ€ì‹  `Copy` íŠ¸ë ˆì‡ì„ ì‚¬ìš©í•˜ê¸°ë„ í•©ë‹ˆë‹¤. êµ¬ì¡°ì²´ê°€ `Copy` íŠ¸ë ˆì‡ì„ ìƒì†(derive)í•˜ë„ë¡ í•˜ë©´ ë©ë‹ˆë‹¤.\n"
"* \"+\"ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‘ ê°ì²´ë¥¼ ì„œë¡œ ë”í•˜ë ¤ë©´ `Add` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” 3ì¼ì°¨ì— ë‹¤ë£° ë‚´ìš©ì…ë‹ˆë‹¤."

#: src/control-flow.md:1
msgid "# Control Flow"
msgstr "# íë¦„ ì œì–´"

#: src/control-flow.md:3
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally\n"
"evaluate one of two blocks, but the blocks can have a value which then becomes\n"
"the value of the `if` expression. Other control flow expressions work similarly\n"
"in Rust."
msgstr "ì•ì—ì„œ ì‚´í´ë³¸ ë°”ì™€ ê°™ì´ ëŸ¬ìŠ¤íŠ¸ì—ì„œ `if`ëŠ” í‘œí˜„ì‹ì…ë‹ˆë‹¤. ì¡°ê±´ì— ë”°ë¼ ë‘ ë¸”ë¡ ì¤‘ í•˜ë‚˜ë¥¼ í‰ê°€í•˜ë©°, ê·¸ ê²°ê³¼ê°’ì´ `if` í‘œí˜„ì‹ì˜ ê°’ì´ ë©ë‹ˆë‹¤. ë‹¤ë¥¸ íë¦„ì œì–´ í‘œí˜„ì‹ë„ ìœ ì‚¬í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤."

#: src/control-flow/blocks.md:1
msgid "# Blocks"
msgstr "# ë¸”ë¡"

#: src/control-flow/blocks.md:3
msgid ""
"A block in Rust has a value and a type: the value is the last expression of the\n"
"block:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ ë¸”ë¡ì€ ê°’ê³¼ íƒ€ì…ì„ ê°–ìŠµë‹ˆë‹¤. ë¸”ë¡ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì´ ë¸”ë¡ì˜ ê°’ì´ ë©ë‹ˆë‹¤:"

#: src/control-flow/blocks.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:25
msgid ""
"The same rule is used for functions: the value of the function body is the\n"
"return value:"
msgstr "í•¨ìˆ˜ì—ë„ ë™ì¼í•œ ê·œì¹™ì´ ì ìš©ë©ë‹ˆë‹¤. í•¨ìˆ˜ ë°”ë””ë¥¼ ì´ë£¨ëŠ” ë¸”ë¡ì˜ ê°’ì´ ë°˜í™˜ê°’ì´ ë©ë‹ˆë‹¤:"

#: src/control-flow/blocks.md:28
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}"
msgstr ""

#: src/control-flow/blocks.md:33
msgid ""
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:38
msgid "However if the last expression ends with `;`, then the resulting value and type is `()`."
msgstr "ìœ„ì˜ `main` í•¨ìˆ˜ëŠ” ë§ˆì§€ë§‰ í‘œí˜„ì‹ì´ `;`ë¡œ ëë‚˜ê¸° ë•Œë¬¸ì— ë°˜í™˜ë˜ëŠ” ê°’ê³¼ íƒ€ì…ì´ `()`ì…ë‹ˆë‹¤."

#: src/control-flow/blocks.md:42
msgid ""
"Key Points:\n"
"* The point of this slide is to show that blocks have a type and value in Rust. \n"
"* You can show how the value of the block changes by changing the last line in the block. For instance, adding/removing a semicolon or using a `return`.\n"
"   \n"
"</details>"
msgstr ""
"í‚¤ í¬ì¸íŠ¸:\n"
"* ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ë¸”ë¡ì´ íƒ€ì…ê³¼ ê°’ì„ ê°€ì§„ë‹¤ëŠ” ì ì´ ì´ ìŠ¬ë¼ì´ë“œì˜ í•µì‹¬ì…ë‹ˆë‹¤.\n"
"* ë¸”ë¡ ë§ˆì§€ë§‰ ì¤„ì„ ìˆ˜ì •í•˜ë©´ì„œ ë¸”ë¡ì˜ ê°’ì´ ì–´ë–»ê²Œ ë°”ë€ŒëŠ”ì§€ ë³´ì—¬ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´, ì„¸ë¯¸ì½œë¡ ì„\n"
"  ë„£ê±°ë‚˜ ëº€ë‹¤ë“ ì§€, ì•„ë‹ˆë©´ `return`ì„ ì‚¬ìš©í•´ ë³´ì„¸ìš”.\n"
"</details>"

#: src/control-flow/if-expressions.md:1
msgid "# `if` expressions"
msgstr "# `if` í‘œí˜„ì‹"

#: src/control-flow/if-expressions.md:3
msgid "You use `if` very similarly to how you would in other languages:"
msgstr "`if`ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤:"

#: src/control-flow/if-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:16
msgid "In addition, you can use it as an expression. This does the same as above:"
msgstr "ê²Œë‹¤ê°€ `if`ëŠ” í‘œí˜„ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ ì½”ë“œëŠ” ìœ„ì™€ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/control-flow/if-expressions.md:18
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:31
msgid ""
"Because `if` is an expression and must have a particular type, both of its branch blocks must have the same type. Consider showing what happens if you add `;` after `x / 2` in the second example.\n"
"    \n"
"</details>"
msgstr ""
"`if`ëŠ” í‘œí˜„ì‹ì´ê³  íƒ€ì…ì„ ê°€ì ¸ì•¼ í•˜ë¯€ë¡œ ë¶„ê¸° ë¸”ë¡ì€ ëª¨ë‘ ê°™ì€ íƒ€ì…ì„ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤. ë‘ë²ˆì§¸ ì˜ˆì‹œì˜ `x / 2` ë’¤ì— `;`ë¥¼ ì¶”ê°€í•˜ì—¬ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ í™•ì¸í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"</details>"

#: src/control-flow/if-let-expressions.md:1
msgid "# `if let` expressions"
msgstr "# `if let` í‘œí˜„ì‹"

#: src/control-flow/if-let-expressions.md:3
msgid "If you want to match a value against a pattern, you can use `if let`:"
msgstr "ì–´ë–¤ ê°’ì´ íŒ¨í„´ì— ë§¤ì¹˜ë˜ëŠ”ì§€ ê²€ì‚¬í•˜ë ¤ë©´ `if let` í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤:"

#: src/control-flow/if-let-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:16
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:22
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns in\n"
"Rust."
msgstr "íŒ¨í„´ì— ê´€í•œ ì„¤ëª…ì€ [íŒ¨í„´ ë§¤ì¹­](../pattern-matching.md)ì„ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/control-flow/if-let-expressions.md:21
msgid ""
"* `if let` can be more concise than `match`, e.g., when only one case is interesting. In contrast, `match` requires all branches to be covered.\n"
"    * For the similar use case consider demonstrating a newly stabilized [`let else`](https://github.com/rust-lang/rust/pull/93628) feature.\n"
"* A common usage is handling `Some` values when working with `Option`.\n"
"* Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"* `if let`ì€ `match`ë³´ë‹¤ ë” ê°„ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ íŠ¹ì •í•œ ê²½ìš°ë§Œ ê³ ë ¤í•˜ê³  ì‹¶ë”ë¼ë„ `match`ëŠ” ëª¨ë“  ë¶„ê¸°ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.\n"
"  * ë¹„ìŠ·í•œ ì‚¬ìš©ë¡€ë¡œ ìƒˆë¡­ê²Œ \"stable\" ë¦´ë¦¬ì¦ˆ ëœ [`let else`](https://github.com/rust-lang/rust/pull/93628) ê¸°ëŠ¥ì„ ì‹œì—°í•˜ëŠ” ê²ƒë„ ê³ ë ¤í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"* ì¼ë°˜ì ìœ¼ë¡œ `Option`ìœ¼ë¡œ ì‘ì—…í•  ë•Œ `Some` ê°’ì„ ì²˜ë¦¬í•˜ëŠ” ì‹ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"* `match`ì™€ ë‹¤ë¥´ê²Œ `if let` íŒ¨í„´ ë§¤ì¹­ì—ì„œëŠ” ê°€ë“œë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/control-flow/while-expressions.md:1
msgid "# `while` expressions"
msgstr "# `while` í‘œí˜„ì‹"

#: src/control-flow/while-expressions.md:3
msgid "The `while` keyword works very similar to other languages:"
msgstr "`while` ì—­ì‹œ ë‹¤ë¥¸ ì–¸ì–´ê³¼ ë§¤ìš° ë¹„ìŠ·í•©ë‹ˆë‹¤:"

#: src/control-flow/while-expressions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
msgid "# `while let` expressions"
msgstr "# `while let` í‘œí˜„ì‹"

#: src/control-flow/while-let-expressions.md:3
msgid ""
"Like with `if`, there is a `while let` variant which repeatedly tests a value\n"
"against a pattern:"
msgstr "`if`ì™€ ë™ì¼í•˜ê²Œ `while let`êµ¬ë¬¸ ì—­ì‹œ íŒ¨í„´ë§¤ì¹­ì— ì‚¬ìš© í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();"
msgstr ""

#: src/control-flow/while-let-expressions.md:11
msgid ""
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
msgid ""
"Here the iterator returned by `v.iter()` will return a `Option<i32>` on every\n"
"call to `next()`. It returns `Some(x)` until it is done, after which it will\n"
"return `None`. The `while let` lets us keep iterating through all items."
msgstr "`v.into_iter()`ê°€ ë°˜í™˜í•œ ë°˜ë³µìëŠ” `next()`ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ `Option<i32>`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë°˜ë³µìê°€ ì™„ë£Œë  ë•Œê¹Œì§€ëŠ” `Some(x)`ë¥¼ ë°˜í™˜í•˜ê³  ë§ˆì§€ë§‰ì—” `None`ì„ ë°˜í™˜í•©ë‹ˆë‹¤. `while let`ì„ í†µí•´ ë°˜ë³µìì˜ ëª¨ë“  ì•„ì´í…œì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/control-flow/while-let-expressions.md:27
msgid ""
"* Point out that the `while let` loop will keep going as long as the value matches the pattern.\n"
"* You could rewrite the `while let` loop as an infinite loop with an if statement that breaks when there is no value to unwrap for `iter.next()`. The `while let` provides syntactic sugar for the above scenario.\n"
"    \n"
"</details>"
msgstr ""
"* `while let`ì€ ê°’ì´ íŒ¨í„´ì— ë§¤ì¹˜ë˜ëŠ” ë™ì•ˆ ê³„ì†ë©ë‹ˆë‹¤.\n"
"* `while let` ë£¨í”„ ëŒ€ì‹  ë¬´í•œ ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ê³  `iter.next()`ê°€ ë¹ˆ ê°’ì„ ë°˜í™˜í•  ë•Œ ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ì˜¤ë„ë¡ ì‘ì„±í• ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. `while let`ì€ ê·¸ëŸ¬í•œ ê²½ìš°ë¥¼ ìœ„í•œ ë¬¸ë²•ì  í¸ì˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/control-flow/for-expressions.md:1
msgid "# `for` expressions"
msgstr "# `for` í‘œí˜„ì‹"

#: src/control-flow/for-expressions.md:3
msgid ""
"The `for` expression is closely related to the `while let` expression. It will\n"
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr "`for`í‘œí˜„ì‹ì€ `while let` í‘œí˜„ì‹ê³¼ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤. `for`í‘œí˜„ì‹ì€ ìë™ìœ¼ë¡œ `into_iter()`ë¥¼ í˜¸ì¶œí•œ ë‹¤ìŒ ì´ë¥¼ ë°˜ë³µí•©ë‹ˆë‹¤:"

#: src/control-flow/for-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];"
msgstr ""

#: src/control-flow/for-expressions.md:10
msgid ""
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:20
msgid "You can use `break` and `continue` here as usual."
msgstr "ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `break` ì™€ `continue`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/control-flow/for-expressions.md:22
msgid ""
"<details>\n"
"    \n"
"* Index iteration is not a special syntax in Rust for just that case.\n"
"* `(0..10)` is a range that implements an `Iterator` trait. \n"
"* `step_by` is a method that returns another `Iterator` that skips every other element. \n"
"* Modify the elements in the vector and explain the compiler errors. Change vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"<details>\n"
"    \n"
"* ëŸ¬ìŠ¤íŠ¸ëŠ” ì¸ë±ìŠ¤ ë°˜ë³µì„ ìœ„í•´ ë³„ë„ì˜ ë¬¸ë²•ì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. \n"
"* `(0..10)`ì€ `Iterator` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ë²”ìœ„(range) ê°’ì…ë‹ˆë‹¤. \n"
"* `step_by`ëŠ” ë°˜ë³µìì˜ ìš”ì†Œë“¤ì„ ê±´ë„ˆë›°ëŠ” ë˜ë‹¤ë¥¸ `Iterator`ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.\n"
"* ë²¡í„° ìš”ì†Œë“¤ì„ ìˆ˜ì •í•˜ë ¤ê³  í•˜ë©´ ë‚˜ì˜¤ëŠ” ì»´íŒŒì¼ëŸ¬ ì—ëŸ¬ë¥¼ ê°™ì´ ì‚´í´ë³´ì„¸ìš”. `v` ë²¡í„°ë¥¼ ê°€ë³€ ë³€ìˆ˜ë¡œ ë³€ê²½í•˜ê³  ë£¨í”„ëŠ” `for x in v.iter_mut()`ë¡œ ìˆ˜ì •í•˜ì„¸ìš”."

#: src/control-flow/loop-expressions.md:1
msgid "# `loop` expressions"
msgstr "# `loop` í‘œí˜„ì‹"

#: src/control-flow/loop-expressions.md:3
msgid ""
"Finally, there is a `loop` keyword which creates an endless loop. Here you must\n"
"either `break` or `return` to stop the loop:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ `loop`í‚¤ì›Œë“œëŠ” ë¬´í•œ ë£¨í”„ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ë°˜ë“œì‹œ `break` ë˜ëŠ” `return`ì„ ì‚¬ìš©í•´ì„œ ë£¨í”„ë¥¼ ì •ì§€í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/control-flow/loop-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:23
msgid ""
"<details>\n"
"    \n"
"* Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr ""
"<details>\n"
"    \n"
"* `loop` ë¸”ë¡ì„ ë¹ ì ¸ë‚˜ì˜¬ ë•Œ `break 8`ì²˜ëŸ¼ ê°’ì„ ì§€ì •í•˜ê³  ê·¸ê±¸ ì¶œë ¥í•´ë³´ì„¸ìš”."

#: src/control-flow/match-expressions.md:1
msgid "# `match` expressions"
msgstr "# `match` í‘œí˜„ì‹"

#: src/control-flow/match-expressions.md:3
msgid ""
"The `match` keyword is used to match a value against one or more patterns. In\n"
"that sense, it works like a series of `if let` expressions:"
msgstr "`match`í‚¤ì›Œë“œëŠ” ì–´ë–¤ ê°’ì„ í•˜ë‚˜ ì´ìƒì˜ íŒ¨í„´ì— ëŒ€í•´ ë§¤ì¹˜í•˜ëŠ”ë° ì‚¬ìš©í•©ë‹ˆë‹¤. ê·¸ëŸ° ë©´ì—ì„œ `if let` í‘œí˜„ì‹ì„ ì—¬ëŸ¬ê°œ ì´ì–´ ë†“ì€ ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/control-flow/match-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/match-expressions.md:19
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last\n"
"expression of the block, if any. In the example above, the type is `()`."
msgstr "`if let`ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë§¤ì¹˜ì˜ ëª¨ë“  íŒ”(arm)ì€ ê°™ì€ íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤. íŒ”ì´ ë¸”ë¡ì´ë¼ë©´ ë¸”ë¡ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì´ ê·¸ íƒ€ì…ì´ ë©ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì œì—ì„œ ë§¤ì¹˜ í‘œí˜„ì‹ì˜ íƒ€ì…ì€ `()`ì…ë‹ˆë‹¤."

#: src/control-flow/match-expressions.md:27
msgid ""
"* Save the match expression to a variable and print it out.\n"
"* Remove `.as_deref()` and explain the error.\n"
"    * `std::env::args().next()` returns an `Option<String>`, but we cannot match against `String`.\n"
"    * `as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, this turns `Option<String>` into `Option<&str>`.\n"
"    * We can now use pattern matching to match against the `&str` inside `Option`.\n"
"</details>"
msgstr ""
"* `match` í‘œí˜„ì‹ì„ ë³€ìˆ˜ì— í• ë‹¹í•˜ê³  ê·¸ ê°’ì„ ì¶œë ¥í•´ë³´ì„¸ìš”.\n"
"* `.as_deref()`ë¥¼ ì§€ì›Œë³´ê³ , ì´ ë•Œ ë‚˜ì˜¤ëŠ” ì—ëŸ¬ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.\n"
"    * `std::env::args().next()`ëŠ” `Option<String>` ê°’ì„ ë°˜í™˜í•˜ëŠ”ë°, `String`ì€ ì§ì ‘ ë§¤ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
"    * `as_deref()`ëŠ” `Option<T>`ë¥¼ `Option<&T::Target>`ìœ¼ë¡œ ë°”ê¿”ì¤ë‹ˆë‹¤. ì´ ê²½ìš°ëŠ” `Option<String>`ì—ì„œ `Option<&str>`ë¡œ ë°”ë€ë‹ˆë‹¤.\n"
"    * ì´ì œëŠ” íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ `Option` ì•ˆì˜ `&str`ì„ ë§¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"</details>"

#: src/control-flow/break-continue.md:1
msgid "# `break` and `continue`"
msgstr "# `break`ì™€ `continue`"

#: src/control-flow/break-continue.md:3
msgid ""
"If you want to exit a loop early, use `break`, if you want to immediately start\n"
"the next iteration use `continue`. Both `continue` and `break` can optionally\n"
"take a label argument which is used to break out of nested loops:"
msgstr "ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ê°€ë ¤ë©´ `break`ë¥¼, ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ë„˜ì–´ê°€ê¸° ìœ„í•´ì„œëŠ” `continue`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì¤‘ì²© ë£¨í”„ì—ì„œëŠ” ë ˆì´ë¸”ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/control-flow/break-continue.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/control-flow/break-continue.md:25
msgid "In this case we break the outer loop after 3 iterations of the inner loop."
msgstr "ìœ„ ì˜ˆì œëŠ” ë‚´ë¶€ì˜ `while` ë£¨í”„ë¥¼ 3íšŒ ë°˜ë³µí•œ í›„ ë°”ê¹¥ ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ê°‘ë‹ˆë‹¤."

#: src/std.md:1
msgid "# Standard Library"
msgstr "# í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/std.md:3
msgid ""
"Rust comes with a standard library which helps establish a set of common types\n"
"used by Rust library and programs. This way, two libraries can work together\n"
"smoothly because they both use the same `String` type."
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ëŸ¬ìŠ¤íŠ¸ë¡œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•  ë•Œ ê³µí†µì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ íƒ€ì…ë“¤ì„ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì„œë¡œ ë‹¤ë¥¸ ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¼ í•˜ë”ë¼ë„ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ”ë° í° ì–´ë ¤ì›€ì´ ì—†ê²Œ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ë©´ ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë‘ ê°™ì€ `String` íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/std.md:7
msgid "The common vocabulary types include:"
msgstr "ì¼ë°˜ì ì¸ íƒ€ì…ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/std.md:9
msgid ""
"* [`Option` and `Result`](std/option-result.md) types: used for optional values\n"
"  and [error handling](error-handling.md)."
msgstr "* [`Option`ê³¼ `Result`](std/option-result.md) : ì–´ë–¤ ê°’ì´ ìˆê±°ë‚˜ ì—†ê±°ë‚˜ í•˜ëŠ” ê²½ìš°, ê·¸ë¦¬ê³  [ì˜¤ë¥˜ ì²˜ë¦¬](error-handling.md)ì— ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/std.md:12
msgid "* [`String`](std/string.md): the default string type used for owned data."
msgstr "* [`String`](std/string.md): ê¸°ë³¸ì ì¸ ë¬¸ìì—´ íƒ€ì…ìœ¼ë¡œ, ë¬¸ìì—´ ë°ì´í„°ë¥¼ ì†Œìœ í•˜ëŠ” ê²½ìš°ì— ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/std.md:14
msgid "* [`Vec`](std/vec.md): a standard extensible vector."
msgstr "* [`Vec`](std/vec.md): ê°€ë³€ í¬ê¸°ì˜ í‘œì¤€ ë²¡í„° íƒ€ì…ì…ë‹ˆë‹¤."

#: src/std.md:16
msgid ""
"* [`HashMap`](std/hashmap.md): a hash map type with a configurable hashing\n"
"  algorithm."
msgstr "* [`HashMap`](std/hashmap.md): í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ì„ ë”°ë¡œ ì§€ì •í•  ìˆ˜ë„ ìˆëŠ” í•´ì‹œë§µ íƒ€ì…ì…ë‹ˆë‹¤."

#: src/std.md:19
msgid "* [`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr "* [`Box`](std/box.md): í™ ë°ì´í„°ì— ëŒ€í•œ ì†Œìœ  í¬ì¸í„°ì…ë‹ˆë‹¤."

#: src/std.md:21
msgid "* [`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated data."
msgstr "* [`Rc`](std/rc.md): í™ì— í• ë‹¹ëœ ë°ì´í„°ì— ëŒ€í•œ ì°¸ì¡° ì¹´ìš´íŒ… ê³µìœ  í¬ì¸í„°ì…ë‹ˆë‹¤."

#: src/std.md:23
msgid ""
"<details>\n"
"  \n"
"  * In fact, Rust contains several layers of the Standard Library: `core`, `alloc` and `std`. \n"
"  * `core` includes the most basic types and functions that don't depend on `libc`, allocator or\n"
"    even the presence of an operating system. \n"
"  * `alloc` includes types which require a global heap allocator, such as `Vec`, `Box` and `Arc`.\n"
"  * Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"<details>\n"
"  \n"
"  * ì‚¬ì‹¤, ëŸ¬ìŠ¤íŠ¸ì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `core`, `alloc`, `std`ì™€ ê°™ì´ ê³„ì¸µ(layer)ìœ¼ë¡œ ë‚˜ëˆ ì§‘ë‹ˆë‹¤.\n"
"  * `core`ëŠ” `libc`ë‚˜ í• ë‹¹ì(allocator), ì‹¬ì§€ì–´ OSì—ë„ ì˜ì¡´í•˜ì§€ ì•ŠëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ í•¨ìˆ˜ì™€ íƒ€ì…ì„ í¬í•¨í•©ë‹ˆë‹¤.\n"
"  * `alloc`ì€ `Vec`, `Box`, `Arc`ì™€ ê°™ì´ ì „ì—­ í™ í• ë‹¹ì´ í•„ìš”í•œ íƒ€ì…ì„ í¬í•¨í•©ë‹ˆë‹¤.\n"
"  * ì„ë² ë””ë“œ ëŸ¬ìŠ¤íŠ¸ ì‘ìš©í”„ë¡œê·¸ë¨ì€ ì£¼ë¡œ `core`ë§Œ ì‚¬ìš©í•˜ê±°ë‚˜ ê°€ë” `alloc`ì„ í•¨ê»˜ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/std/option-result.md:1
msgid "# `Option` and `Result`"
msgstr "# `Option`ê³¼ `Result`"

#: src/std/option-result.md:3
msgid "The types represent optional data:"
msgstr "ì´ íƒ€ì…ì€ ì„ íƒì  ë°ì´í„°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");"
msgstr ""

#: src/std/option-result.md:11
msgid ""
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/option-result.md:18
msgid ""
"* `Option` and `Result` are widely used not just in the standard library.\n"
"* `Option<&T>` has zero space overhead compared to `&T`.\n"
"* `Result` is the standard type to implement error handling as we will see on Day 3.\n"
"* `binary_search` returns `Result<usize, usize>`.\n"
"  * If found, `Result::Ok` holds the index where the element is found.\n"
"  * Otherwise, `Result::Err` contains the index where such an element should be inserted."
msgstr ""
"* `Option`ê³¼ `Result`ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¿ë§Œì•„ë‹ˆë¼ ë§¤ìš° ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©ë˜ëŠ” íƒ€ì…ì…ë‹ˆë‹¤.\n"
"* `Option<&T>` ëŠ” `&T`ì— ë¹„í•´ ê³µê°„ ì˜¤ë²„í—¤ë“œê°€ ì—†ìŠµë‹ˆë‹¤.\n"
"* `Result`ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ í‘œì¤€ íƒ€ì…ì…ë‹ˆë‹¤. 3ì¼ì°¨ ê³¼ì •ì—ì„œ ì‚´í´ë´…ë‹ˆë‹¤.\n"
"* `binary_search`ëŠ” `Result<usize, usize>`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"  * ìš”ì†Œê°€ ë°œê²¬ëœë‹¤ë©´, `Result::Ok`ëŠ” ë°œê²¬ëœ ìš”ì†Œì˜ ì¸ë±ìŠ¤ë¥¼ ë³´ìœ í•©ë‹ˆë‹¤.\n"
"  * ì•„ë‹ˆë©´, `Result::Err`ì—ëŠ” ìš”ì†Œê°€ ì‚½ì…ë˜ì•¼ í•˜ëŠ” ì¸ë±ìŠ¤ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/std/string.md:1
msgid "# String"
msgstr "# `String` ë¬¸ìì—´"

#: src/std/string.md:3
msgid "[`String`][1] is the standard heap-allocated growable UTF-8 string buffer:"
msgstr "[`String`][1]ì€ í™ì— í• ë‹¹ë˜ê³  ê°€ë³€ ê¸¸ì´ì˜ í‘œì¤€ UTF-8 ë¬¸ìì—´ ë²„í¼ì…ë‹ˆë‹¤:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());"
msgstr ""

#: src/std/string.md:11
msgid ""
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());"
msgstr ""

#: src/std/string.md:16
msgid ""
"    let s3 = String::from(\"ğŸ‡¨ğŸ‡­\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""

#: src/std/string.md:22
msgid ""
"`String` implements [`Deref<Target = str>`][2], which means that you can call all\n"
"`str` methods on a `String`."
msgstr "`String`ì€ [`Deref<Target = str>`][2]ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” , `String` ê°’ì— ëŒ€í•´ì„œë„ `str`ì˜ ëª¨ë“  ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ ì…ë‹ˆë‹¤."

#: src/std/string.md:25
msgid ""
"[1]: https://doc.rust-lang.org/std/string/struct.String.html\n"
"[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"
msgstr ""

#: src/std/string.md:30
msgid ""
"* `String::new` returns a new empty string, use `String::with capacity` when you know how much data you want to push to the string.\n"
"* `String::len` returns the size of the `String` in bytes (which can be different from its length in characters).\n"
"* `String::chars` returns an iterator over the actual characters. Note that a `char` can be different from what a human will consider a \"character\" due to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html).\n"
"*  When people refer to strings they could either be talking about `&str` or `String`.  \n"
"* When a type implements `Deref<Target = T>`, the compiler will let you transparently call methods from `T`.\n"
"    * `String` implements `Deref<Target = str>` which transparently gives it access to `str`'s methods.\n"
"    * Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;.\n"
"* `String` is implemented as a wrapper around a vector of bytes, many of the operations you see supported on vectors are also supported on `String`, but with some extra guarantees.\n"
"* Compare the different ways to inde a Strings by using `s3[i]` and `s3.chars.nth(i).unwrap()` where `i` is in-bound, out-of-bounds, and \"on\" the flag unicode character."
msgstr ""
"* `String::new`ëŠ” ìƒˆë¡œìš´ ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤. `String::with_capacity`ëŠ” ìƒˆë¡œ ë§Œë“¤ ë¬¸ìì—´ ë²„í¼ì— ë„£ì„ ë°ì´í„° í¬ê¸°ë¥¼ ì•Œê³  ìˆëŠ” ê²½ìš°ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `String::len`ì€ `String`ì˜ ë°”ì´íŠ¸ í¬ê¸°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. (ì‹¤ì œ ë¬¸ì ê°œìˆ˜ì™€ëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)\n"
"* `String::chars`ëŠ” ì‹¤ì œ ë¬¸ì(character)ë“¤ì— ëŒ€í•œ ì´í„°ë ˆì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `char`ë¡œ í‘œí˜„ë˜ëŠ” ë¬¸ìëŠ” ìš°ë¦¬ê°€ ì‹¤ì œë¡œ ì¸ì‹í•˜ê³  ì‚¬ìš©í•˜ëŠ” ë¬¸ìì™€ëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìì†Œ ê²°í•©ìœ¼ë¡œ ë¬¸ìë¥¼ í‘œí˜„í•˜ëŠ” ê²½ìš°ê°€ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” [Grapheme Cluster](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.\n"
"* ë¬¸ìì—´ì´ë¼ê³  ì–¸ê¸‰í•˜ëŠ” ê²½ìš°ëŠ” `&str`ì´ê±°ë‚˜ `String`ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì–´ë–¤ íƒ€ì…ì´ `Deref<Target = T>`ë¥¼ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©´, ì»´íŒŒì¼ëŸ¬ëŠ” ì—¬ëŸ¬ë¶„ì´ `T`ì˜ ë©”ì†Œë“œë“¤ì„ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ ë„ì™€ì¤ë‹ˆë‹¤.\n"
"    * `String`ì€ `Deref<Target = str>`ì„ êµ¬í˜„í•˜ê³  ìˆê¸° ë•Œë¬¸ì— `String`ì— ëŒ€í•´ì„œë„ `str` ë©”ì†Œë“œë“¤ì„ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"    * `let s3 = s1.deref();`ì™€ `let s3 = &*s1;`ì„ ë¹„êµí•´ë³´ì„¸ìš”.\n"
"* `String`ì€ ë°”ì´íŠ¸ ë²¡í„°ì˜ ë˜í¼ë¡œ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë²¡í„°ê°€ ì§€ì›í•˜ëŠ” ì—¬ëŸ¬ê°€ì§€ ì—°ì‚°ë“¤ì„ `String`ë„ ì§€ì›í•©ë‹ˆë‹¤. ë‹¤ë§Œ `String`ì€ ëª‡ê°€ì§€ ë³´ì¥ ë‚´ìš©ì´ ë” ìˆìŠµë‹ˆë‹¤.\n"
"* Compare the different ways to inde a Strings by using `s3[i]` and `s3.chars.nth(i).unwrap()` where `i` is in-bound, out-of-bounds, and \"on\" the flag unicode character."

#: src/std/vec.md:1
msgid "# `Vec`"
msgstr "# `Vec`"

#: src/std/vec.md:3
msgid "[`Vec`][1] is the standard resizable heap-allocated buffer:"
msgstr "[`Vec`][1] ëŠ” í™ì— í• ë‹¹ëœ í‘œì¤€ ê°€ë³€ í¬ê¸° ë²„í¼ì…ë‹ˆë‹¤:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());"
msgstr ""

#: src/std/vec.md:11
msgid ""
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());"
msgstr ""

#: src/std/vec.md:16
msgid ""
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];"
msgstr ""

#: src/std/vec.md:19
msgid ""
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");"
msgstr ""

#: src/std/vec.md:23
msgid ""
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/vec.md:29
msgid ""
"`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call slice\n"
"methods on a `Vec`."
msgstr "`Vec`ì€ [`Deref<Target = [T]>`][2]ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” `Vec`ì—ì„œ ìŠ¬ë¼ì´ìŠ¤ ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#: src/std/vec.md:32
msgid ""
"[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html\n"
"[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-[T]"
msgstr ""

#: src/std/vec.md:37
msgid ""
"* `Vec` is a type of collection, along with `String` and `HashMap`. The data it contains is stored\n"
"  on the heap. This means the amount of data doesn't need to be  known at compile time. It can grow\n"
"  or shrink at runtime.\n"
"* Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` explicitly. As always\n"
"  with Rust type inference, the `T` was established during the first `push` call.\n"
"* `vec![...]` is a canonical macro to use instead of `Vec::new()` and it supports adding initial\n"
"  elements to the vector.\n"
"* To index the vector you use `[` `]`, but they will panic if out of bounds. Alternatively, using\n"
"  `get` will return an `Option`. The `pop` function will remove the last element.\n"
"* Show iterating over a vector and mutating the value:\n"
"  `for e in &mut v { *e += 50; }`"
msgstr ""

#: src/std/hashmap.md:1
msgid "# `HashMap`"
msgstr "# `HashMap`"

#: src/std/hashmap.md:3
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "HashDoS ê³µê²©ìœ¼ë¡œë¶€í„° ë³´í˜¸ë˜ëŠ” í‘œì¤€ í•´ì‹œ ë§µì…ë‹ˆë‹¤:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;"
msgstr ""

#: src/std/hashmap.md:8
msgid ""
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), 207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);"
msgstr ""

#: src/std/hashmap.md:14
msgid ""
"    if !page_counts.contains_key(\"Les MisÃ©rables\") {\n"
"        println!(\"We know about {} books, but not Les MisÃ©rables.\",\n"
"                 page_counts.len());\n"
"    }"
msgstr ""

#: src/std/hashmap.md:19
msgid ""
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }"
msgstr ""

#: src/std/hashmap.md:26
msgid ""
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string()).or_insert(0);\n"
"        *page_count += 1;\n"
"    }"
msgstr ""

#: src/std/hashmap.md:32
msgid ""
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
msgid ""
"* `HashMap` is not defined in the prelude and needs to be brought into scope.\n"
"* Try the following lines of code. The first line will see if a book is in the hashmap and if not return an alternative value. The second line will insert the alternative value in the hashmap if the book is not found."
msgstr ""

#: src/std/hashmap.md:41
msgid ""
"  ```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"  ```\n"
"* Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.\n"
"  * Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1], which allows us to easily initialize a hash map from a literal array:"
msgstr ""

#: src/std/hashmap.md:52
msgid ""
"  ```rust,ignore\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"    (\"The Hunger Games\".to_string(), 374),\n"
"  ]);\n"
"  ```"
msgstr ""

#: src/std/hashmap.md:59
msgid ""
" * Alternatively HashMap can be built from any `Iterator` which yields key-value tuples.\n"
"* We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make examples easier. Using references in collections can, of course, be done,\n"
"  but it can lead into complications with the borrow checker.\n"
"  * Try removing `to_string()` from the example above and see if it still compiles. Where do you think we might run into issues?"
msgstr ""

#: src/std/hashmap.md:64
msgid "[1]: https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K%2C%20V)%3B%20N%5D%3E-for-HashMap%3CK%2C%20V%2C%20RandomState%3E"
msgstr ""

#: src/std/box.md:1
msgid "# `Box`"
msgstr "# `Box`"

#: src/std/box.md:3
msgid "[`Box`][1] is an owned pointer to data on the heap:"
msgstr "[`Box`][1]ëŠ” í™ ë°ì´í„°ì— ëŒ€í•œ ì†Œìœ  í¬ì¸í„°ì…ë‹ˆë‹¤:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""

#: src/std/box.md:26
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call methods\n"
"from `T` directly on a `Box<T>`][2]."
msgstr "`Box<T>`ì€ [`Deref<Target = T>`][2]ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” [`Box<T>`ì—ì„œ `T` ë©”ì„œë“œë¥¼ ì§ì ‘ í˜¸ì¶œ][2] í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#: src/std/box.md:29
msgid ""
"[1]: https://doc.rust-lang.org/std/boxed/struct.Box.html\n"
"[2]: https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion"
msgstr ""

#: src/std/box.md:34
msgid ""
"* `Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be not null. \n"
"* In the above example, you can even leave out the `*` in the `println!` statement thanks to `Deref`. \n"
"* A `Box` can be useful when you:\n"
"   * have a type whose size that can't be known at compile time, but the Rust compiler wants to know an exact size.\n"
"   * want to transfer ownership of a large amount of data. To avoid copying large amounts of data on the stack, instead store the data on the heap in a `Box` so only the pointer is moved.\n"
"</details>"
msgstr ""

#: src/std/box-recursive.md:1
msgid "# Box with Recursive Data Structures"
msgstr "# ì¬ê·€ìë£Œ êµ¬ì¡°ì—ì„œì˜ `Box`"

#: src/std/box-recursive.md:3
msgid "Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "ì¬ê·€ ë°ì´í„°ë‚˜ ë™ì í¬ê¸°ì˜ ë°ì´í„° íƒ€ì…ì€ `Box`íƒ€ì…ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}"
msgstr ""

#: src/std/box-recursive.md:12 src/std/box-niche.md:10
msgid ""
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                               :\n"
":    list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // |   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/std/box-recursive.md:33
msgid ""
"* If the `Box` was not used here and we attempted to embed a `List` directly into the `List`,\n"
"the compiler would not compute a fixed size of the struct in memory, it would look infinite."
msgstr "* ë§Œì¼ `Box`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  `List`ì— ì§ì ‘ `List`ë¥¼ í¬í•¨í•˜ë ¤ê³  ì‹œë„í•œë‹¤ë©´, ì»´íŒŒì¼ëŸ¬ëŠ” êµ¬ì¡°ì²´ì˜ ê³ ì • í¬ê¸°ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ë³´ê¸°ì— ë¬´í•œëŒ€ì˜ í¬ê¸°ë¡œ ë³´ì¼ ê²ƒì…ë‹ˆë‹¤."

#: src/std/box-recursive.md:36
msgid ""
"* `Box` solves this problem as it has the same size as a regular pointer and just points at the next\n"
"element of the `List` in the heap."
msgstr "* `Box`ëŠ” ì¼ë°˜ í¬ì¸í„°ì™€ í¬ê¸°ê°€ ê°™ê¸° ë•Œë¬¸ì— í¬ê¸°ë¥¼ ê³„ì‚°í•˜ëŠ” ë° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë§Œ í™ì— ìœ„ì¹˜í•œ `List`ì˜ ë‹¤ìŒ ìš”ì†Œë¥¼ ê°€ë¦¬í‚¬ ë¿ì…ë‹ˆë‹¤."

#: src/std/box-recursive.md:39
msgid ""
"* Remove the `Box` in the List definition and show the compiler error. \"Recursive with indirection\" is a hint you might want to use a Box or reference of some kind, instead of storing a value directly.   \n"
"    \n"
"</details>"
msgstr ""
"* `List` ì •ì˜ì—ì„œ `Box`ë¥¼ ì œê±°í•˜ë©´ ì–´ë–¤ ì»´íŒŒì¼ëŸ¬ ì—ëŸ¬ê°€ ë‚˜ì˜¤ëŠ”ì§€ ê°™ì´ ì‚´í´ë³´ì„¸ìš”. â€œRecursive with indirectionâ€ë¼ëŠ” ë©”ì‹œì§€ë¥¼ ë³´ë©´, ê°’ì„ ì§ì ‘ ì €ì¥í•˜ëŠ” ëŒ€ì‹  `Box`ë‚˜ ë¹„ìŠ·í•œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì°¸ì¡° íƒ€ì…ì´ í•„ìš”í•˜ë‹¤ëŠ” íŒíŠ¸ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/std/box-niche.md:1
msgid "# Niche Optimization"
msgstr "# í‹ˆìƒˆ ìµœì í™”(Niche Optimization)"

#: src/std/box-niche.md:16
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This\n"
"allows the compiler to optimize the memory layout:"
msgstr "`Box`ëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ í¬ì¸í„°ëŠ” í•­ìƒ ìœ íš¨í•˜ë©° `null`ì´ ì•„ë‹™ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ìµœì í™” í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.\n"
":                         :     :                                             :\n"
":    list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null |             :\n"
":   +----+----+           :     :    +----+----+    +----+------+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/std/rc.md:1
msgid "# `Rc`"
msgstr "# `Rc`"

#: src/std/rc.md:3
msgid ""
"[`Rc`][1] is a reference-counted shared pointer. Use this when you need to refer\n"
"to the same data from multiple places:"
msgstr "[`Rc`][1]ëŠ” ì°¸ì¡° ì¹´ìš´íŒ… ê³µìœ  í¬ì¸í„°ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ë™ì¼í•œ ë°ì´í„°ë¥¼ ì°¸ì¡°í•´ì•¼í•  ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;"
msgstr ""

#: src/std/rc.md:9
msgid ""
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = a.clone();"
msgstr ""

#: src/std/rc.md:18
msgid ""
"* If you need to mutate the data inside an `Rc`, you will need to wrap the data in\n"
"  a type such as [`Cell` or `RefCell`][2].\n"
"* See [`Arc`][3] if you are in a multi-threaded context.\n"
"* You can *downgrade* a shared pointer into a [`Weak`][4] pointer to create cycles\n"
"  that will get dropped."
msgstr ""
"* `Rc`ë‚´ë¶€ì˜ ë°ì´í„°ë¥¼ ë³€ê²½í•´ì•¼ í•˜ëŠ” ê²½ìš°, ë°ì´í„°ë¥¼ [`Cell` ë˜ëŠ” `RefCell`][2]ë¡œ ë˜í•‘í•´ì•¼í•©ë‹ˆë‹¤.\n"
"* ë©€í‹°ìŠ¤ë ˆë“œì¸ ê²½ìš° [`Arc`][3]ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.\n"
"* drop ê°€ëŠ¥í•œ ìˆœí™˜ êµ¬ì¡°ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ê³µìœ  í¬ì¸í„°ë¥¼ [`Weak`][4] í¬ì¸í„°ë¡œ **ë‹¤ìš´ê·¸ë ˆì´ë“œ**í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/std/rc.md:24
msgid ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html\n"
"[2]: https://doc.rust-lang.org/std/cell/index.html\n"
"[3]: ../concurrency/shared_state/arc.md\n"
"[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html"

#: src/std/rc.md:31
msgid ""
"* `Rc`'s Count ensures that its contained value is valid for as long as there are references.\n"
"* Like C++'s `std::shared_ptr`.\n"
"* `clone` is cheap: it creates a pointer to the same allocation and increases the reference count. Does not make a deep clone and can generally be ignored when looking for performance issues in code.\n"
"* `make_mut` actually clones the inner value if necessary (\"clone-on-write\") and returns a mutable reference.\n"
"* Use `Rc::strong_count` to check the reference count.\n"
"* Compare the different datatypes mentioned. `Box` enables (im)mutable borrows that are enforced at compile time. `RefCell` enables (im)mutable borrows that are enforced at run time and will panic if it fails at runtime.\n"
"* You can `downgrade()` a `Rc` into a *weakly reference-counted* object to\n"
"  create cycles that will be dropped properly (likely in combination with\n"
"  `RefCell`)."
msgstr ""
"* `Rc`ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ í†µí•´ ì°¸ì¡°ê°€ ìˆëŠ” ë™ì•ˆì€ `Rc`ê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ê°’ì´ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë˜ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤.\n"
"* C++ì˜ `std::shared_ptr`ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤.\n"
"* `clone`ì€ ì €ë ´í•©ë‹ˆë‹¤. ê°™ì€ ê³³ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ í•˜ë‚˜ ë” ë§Œë“¤ê³ , ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ëŠ˜ë¦½ë‹ˆë‹¤. í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ ìì²´ê°€ ë³µì œ(ê¹Šì€ ë³µì œ)ë˜ì§€ëŠ” ì•Šìœ¼ë©°, ê·¸ë˜ì„œ ì½”ë“œì—ì„œ ì„±ëŠ¥ ë¬¸ì œê°€ ìˆëŠ”ì§€ ê²€í† í•  ë•Œ ì¼ë°˜ì ìœ¼ë¡œ `Rc`ë¥¼ `clone`í•˜ëŠ” ê²ƒì€ ë¬´ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `make_mut`ëŠ” ì‹¤ì œë¡œ í•„ìš”í•œ ê²½ìš°ì— ë‚´ë¶€ ê°’ì„ ë³µì œí•˜ê³ ( (\"clone-on-write\") ) ê°€ë³€ ì°¸ì¡°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"* ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ í™•ì¸í•˜ë ¤ë©´ `Rc::strong_count`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.\n"
"* ì—¬ê¸° ì–¸ê¸‰ëœ ëª‡ê°€ì§€ ë°ì´í„° íƒ€ì…ì„ ë¹„êµí•´ë³´ì„¸ìš”. `Box`ëŠ” ë¶ˆë³€/ê°€ë³€ ë¹Œë¦¼(borrow)ì„ ì»´íŒŒì¼ ì‹œì ì— ê°•ì œí•©ë‹ˆë‹¤. `RefCell`ì€ ì‹¤í–‰ ì‹œì ì— ë¶ˆë³€/ê°€ë³€ ë¹Œë¦¼ì„ ê°•ì œí•˜ë©°, ë§Œì•½ ëŸ°íƒ€ì„ ì‹œì— ë¹Œë¦¼ ë¬¸ì œê°€ ë°œìƒí•˜ë©´ íŒ¨ë‹‰ì„ ì¼ìœ¼í‚µë‹ˆë‹¤.\n"
"* `Rc`ëŠ” `downgrade()`ë¡œ ë‹¤ìš´ê·¸ë ˆì´ë“œí•˜ì—¬ **weak ì°¸ì¡° ì¹´ìš´íŠ¸**ë¡œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ìˆœí™˜êµ¬ì¡°ë¼ í•˜ë”ë¼ë„ dropì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. (ì•„ë§ˆë„ `RefCell` ì„ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•  ê²ƒì…ë‹ˆë‹¤.)"

#: src/std/rc.md:41
msgid ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;"
msgstr ""
"```rust,editable\n"
"use std::rc::{Rc, Weak};\n"
"use std::cell::RefCell;"

#: src/std/rc.md:45
msgid ""
"#[derive(Debug)]\n"
"struct Node {\n"
"    value: i64,\n"
"    parent: Option<Weak<RefCell<Node>>>,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}"
msgstr ""

#: src/std/rc.md:52
msgid ""
"fn main() {\n"
"    let mut root = Rc::new(RefCell::new(Node {\n"
"        value: 42,\n"
"        parent: None,\n"
"        children: vec![],\n"
"    }));\n"
"    let child = Rc::new(RefCell::new(Node {\n"
"        value: 43,\n"
"        children: vec![],\n"
"        parent: Some(Rc::downgrade(&root))\n"
"    }));\n"
"    root.borrow_mut().children.push(child);"
msgstr ""

#: src/std/rc.md:65
msgid ""
"    println!(\"graph: {root:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:1
msgid "# Modules"
msgstr "# ëª¨ë“ˆ"

#: src/modules.md:3
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr "`impl`ë¸”ë¡ì€ í•´ë‹¹ íƒ€ì…ì˜ í•¨ìˆ˜ë“¤ì— ëŒ€í•œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/modules.md:5
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "ë§ˆì°¬ê°€ì§€ë¡œ, `mod`ëŠ” íƒ€ì…ê³¼ í•¨ìˆ˜ë“¤ì— ëŒ€í•´ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}"
msgstr ""

#: src/modules.md:14
msgid ""
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}"
msgstr ""

#: src/modules.md:20
msgid ""
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:28
msgid ""
"* Packages provide functionality and include a `Cargo.toml` file that describes how to build a bundle of 1+ crates.\n"
"* Crates are a tree of modules, where a binary crate creates an executable and a library crate compiles to a library.\n"
"* Modules define organization, scope, and are the focus of this section."
msgstr ""

#: src/modules/visibility.md:1
msgid "# Visibility"
msgstr "# ê°€ì‹œì„±"

#: src/modules/visibility.md:3
msgid "Modules are a privacy boundary:"
msgstr "ëª¨ë“ˆì˜ íƒ€ì…ì´ë‚˜ í•¨ìˆ˜ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë¹„ê¹¥ì— ë…¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/modules/visibility.md:5
msgid ""
"* Module items are private by default (hides implementation details).\n"
"* Parent and sibling items are always visible.\n"
"* In other words, if an item is visible in module `foo`, it's visible in all the\n"
"  descendants of `foo`."
msgstr ""
"* ë”°ë¼ì„œ ëª¨ë“ˆì˜ ì„¸ë¶€ êµ¬í˜„ ë‚´ìš©ì´ ê°ì¶°ì§‘ë‹ˆë‹¤.\n"
"* ë¶€ëª¨ì™€ ì´ì›ƒ í•­ëª©ì€ ì–¸ì œë‚˜ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
"* ì¦‰, ëª¨ë“ˆ `foo`ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•œ í•­ëª©ì´ë¼ë©´ `foo` ì•„ë˜ì˜ ëª¨ë“  ëª¨ë“ˆì—ì„œ ì ‘ê·¼ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }"
msgstr ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }"

#: src/modules/visibility.md:16
msgid ""
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }"
msgstr ""
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }"

#: src/modules/visibility.md:20
msgid ""
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }"
msgstr ""
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }"

#: src/modules/visibility.md:25
msgid ""
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}"

#: src/modules/visibility.md:32
msgid ""
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"

#: src/modules/visibility.md:39
msgid "* Use the `pub` keyword to make modules public."
msgstr "* `pub` í‚¤ì›Œë“œëŠ” ëª¨ë“ˆì—ë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/visibility.md:41
msgid "Additionally, there are advanced `pub(...)` specifiers to restrict the scope of public visibility."
msgstr "ë˜í•œ, ê³ ê¸‰ ê¸°ëŠ¥ìœ¼ë¡œ `pub(...)` ì§€ì •ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê³µê°œ ë²”ìœ„ë¥¼ ì œí•œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/visibility.md:43
msgid ""
"* See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself).\n"
"* Configuring `pub(crate)` visibility is a common pattern.\n"
"* Less commonly, you can give visibility to a specific path.\n"
"* In any case, visibility must be granted to an ancestor module (and all of its descendants)."
msgstr ""
"* [ê³µì‹ ë¬¸ì„œ](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.\n"
"* `pub(crate)`ë¡œ ê°€ì‹œì„±ì„ ì§€ì •í•˜ëŠ” ê²ƒì´ ìì£¼ ì“°ì…ë‹ˆë‹¤.\n"
"* ìì£¼ ì“°ì´ì§„ ì•Šì§€ë§Œ íŠ¹ì • ê²½ë¡œì— ëŒ€í•´ì„œë§Œ ê°€ì‹œì„±ì„ ë¶€ì—¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì–´ë–¤ ê²½ìš°ì´ë“  ê°€ì‹œì„±ì´ ë¶€ì—¬ë˜ë©´ í•´ë‹¹ ëª¨ë“ˆì„ í¬í•¨í•˜ì—¬ í•˜ìœ„ì˜ ëª¨ë“  ëª¨ë“ˆì´ ì ìš©ë°›ìŠµë‹ˆë‹¤."

#: src/modules/paths.md:1
msgid "# Paths"
msgstr "# ê²½ë¡œ"

#: src/modules/paths.md:3
msgid "Paths are resolved as follows:"
msgstr "ê²½ë¡œëŠ” ì•„ë˜ì™€ ê°™ì´ êµ¬ë¶„í•©ë‹ˆë‹¤:"

#: src/modules/paths.md:5
msgid ""
"1. As a relative path:\n"
"   * `foo` or `self::foo` refers to `foo` in the current module,\n"
"   * `super::foo` refers to `foo` in the parent module."
msgstr ""
"1. ìƒëŒ€ ê²½ë¡œ\n"
"   *  `foo` ë˜ëŠ” `self::foo`ëŠ” í˜„ì¬ ëª¨ë“ˆ ë‚´ë¶€ì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤.\n"
"   * `super::foo`ëŠ” ë¶€ëª¨ ëª¨ë“ˆì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤."

#: src/modules/paths.md:9
msgid ""
"2. As an absolute path:\n"
"   * `crate::foo` refers to `foo` in the root of the current crate,\n"
"   * `bar::foo` refers to `foo` in the `bar` crate."
msgstr ""
"2. ì ˆëŒ€ ê²½ë¡œ\n"
"   * `crate::foo`ëŠ” í˜„ì¬ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤.\n"
"   * `bar::foo`ëŠ” `bar`í¬ë ˆì´íŠ¸ì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤."

#: src/modules/filesystem.md:1
msgid "# Filesystem Hierarchy"
msgstr "# íŒŒì¼ì‹œìŠ¤í…œ ê³„ì¸µ"

#: src/modules/filesystem.md:3
msgid "The module content can be omitted:"
msgstr "ëª¨ë“ˆì˜ ë‚´ìš©ì€ ìƒëµë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
msgid "The `garden` module content is found at:"
msgstr "`garden` ëª¨ë“ˆì˜ ë‚´ìš©ì€ ì•„ë˜ ìœ„ì¹˜ì—ì„œ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/modules/filesystem.md:11
msgid ""
"* `src/garden.rs` (modern Rust 2018 style)\n"
"* `src/garden/mod.rs` (older Rust 2015 style)"
msgstr ""

#: src/modules/filesystem.md:14
msgid "Similarly, a `garden::vegetables` module can be found at:"
msgstr "ìœ ì‚¬í•˜ê²Œ `garden::vegetables` ëª¨ë“ˆì€ ì•„ë˜ ìœ„ì¹˜ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/modules/filesystem.md:16
msgid ""
"* `src/garden/vegetables.rs` (modern Rust 2018 style)\n"
"* `src/garden/vegetables/mod.rs` (older Rust 2015 style)"
msgstr ""

#: src/modules/filesystem.md:19
msgid "The `crate` root is in:"
msgstr "`crate(í¬ë ˆì´íŠ¸)`ì˜ ë£¨íŠ¸ëŠ” ì•„ë˜ ê²½ë¡œ ì…ë‹ˆë‹¤:"

#: src/modules/filesystem.md:21
msgid ""
"* `src/lib.rs` (for a library crate)\n"
"* `src/main.rs` (for a binary crate)"
msgstr ""

#: src/modules/filesystem.md:26
msgid ""
"* The change from `module/mod.rs` to `module.rs` doesn't preclude the use of submodules in Rust 2018.\n"
"  (It was mandatory in Rust 2015.)"
msgstr "* `module/mod.rs`ë¥¼ `module.rs`ë¡œ ë°”ê¾¼ë‹¤ í•˜ë”ë¼ë„ Rust 2018ì—ì„œëŠ” í•˜ìœ„ ëª¨ë“ˆì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (Rust 2015ì—ì„œëŠ” í•˜ìœ„ ëª¨ë“ˆì´ ìˆëŠ” ëª¨ë“ˆì€ `module/mod.rs` í˜•íƒœì—¬ì•¼ í–ˆìŠµë‹ˆë‹¤.)"

#: src/modules/filesystem.md:29
msgid "  The following is valid:"
msgstr "  ì•„ë˜ì²˜ëŸ¼ êµ¬ì„±í•˜ëŠ”ë° ì•„ë¬´ëŸ° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤:"

#: src/modules/filesystem.md:31
msgid ""
"  ```ignore\n"
"  src/\n"
"  â”œâ”€â”€ main.rs\n"
"  â”œâ”€â”€ top_module.rs\n"
"  â””â”€â”€ top_module/\n"
"      â””â”€â”€ sub_module.rs\n"
"  ```"
msgstr ""
"  ```ignore\n"
"  src/\n"
"  â”œâ”€â”€ main.rs\n"
"  â”œâ”€â”€ top_module.rs\n"
"  â””â”€â”€ top_module/\n"
"      â””â”€â”€ sub_module.rs\n"
"  ```"

#: src/modules/filesystem.md:39
msgid ""
"* The main reason for the change is to prevent many files named `mod.rs`, which can be hard\n"
"  to distinguish in IDEs."
msgstr "* ì´ë ‡ê²Œ ë³€ê²½ëœ ì£¼ëœ ì´ìœ ëŠ” ëª¨ë‘ ë˜‘ê°™ì€ ì´ë¦„ì˜ `mod.rs` íŒŒì¼ì´ ì”ëœ© ìƒê¸°ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ì„œ ì…ë‹ˆë‹¤. IDEì—ì„œëŠ” ì´ë“¤ì„ êµ¬ë¶„í•˜ê¸°ê°€ ê¹Œë‹¤ë¡œì› ìŠµë‹ˆë‹¤."

#: src/modules/filesystem.md:42
msgid ""
"* Rust will look for modules in `modulename/mod.rs` and `modulename.rs`, but this can be changed\n"
"  with a compiler directive:"
msgstr "* ëŸ¬ìŠ¤íŠ¸ëŠ” ëª¨ë“ˆì„ ì°¾ì„ ë•Œ `modulename/mod.rs`ì™€ `modulename.rs` íŒŒì¼ì„ ê²€ì‚¬í•˜ëŠ”ë°, ì»´íŒŒì¼ëŸ¬ ë””ë ‰í‹°ë¸Œë¡œ ì´ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/filesystem.md:45
msgid ""
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```"
msgstr ""
"  ```rust,ignore\n"
"  #[path = \"some/path.rs\"]\n"
"  mod some_module { }\n"
"  ```"

#: src/modules/filesystem.md:50
msgid ""
"  This is useful, for example, if you would like to place tests for a module in a file named\n"
"  `some_module_test.rs`, similar to the convention in Go."
msgstr "  Goì–¸ì–´ ì—ì„œì²˜ëŸ¼ ì–´ë–¤ ëª¨ë“ˆì˜ í…ŒìŠ¤íŠ¸ë¥¼ `some_module_test.rs` ê°™ì€ íŒŒì¼ì— ë‘ê³  ì‹¶ì€ ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤."

#: src/exercises/day-2/afternoon.md:1
msgid "# Day 2: Afternoon Exercises"
msgstr "# 2ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-2/afternoon.md:3
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œëŠ” ë¬¸ìì—´ê³¼ ë°˜ë³µìì— ì´ˆì ì„ ë§ì¶œ ê²ƒì…ë‹ˆë‹¤."

#: src/exercises/day-2/luhn.md:1
msgid "# Luhn Algorithm"
msgstr "# ë£¬(Luhn) ì•Œê³ ë¦¬ì¦˜"

#: src/exercises/day-2/luhn.md:3
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to\n"
"validate credit card numbers. The algorithm takes a string as input and does the\n"
"following to validate the credit card number:"
msgstr "[ë£¬(Luhn) ì•Œê³ ë¦¬ì¦˜](https://ko.wikipedia.org/wiki/%EB%A3%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)ì€ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ ê²€ì¦ì— ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤. ì´ ì•Œê³ ë¦¬ì¦˜ì€ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ë¥¼ `ë¬¸ìì—´`ë¡œ ì…ë ¥ë°›ê³ , ì•„ë˜ì˜ ìˆœì„œì— ë”°ë¼ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ì˜ ìœ íš¨ì„±ì„ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/exercises/day-2/luhn.md:7
msgid "* Ignore all spaces. Reject number with less than two digits."
msgstr "* ëª¨ë“  ê³µë°±ì„ ë¬´ì‹œí•©ë‹ˆë‹¤. 2ìë¦¬ ë¯¸ë§Œ ìˆ«ìëŠ” ë¬´ì‹œí•©ë‹ˆë‹¤."

#: src/exercises/day-2/luhn.md:9
msgid ""
"* Moving from right to left, double every second digit: for the number `1234`,\n"
"  we double `3` and `1`."
msgstr "* ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë©° 2ë²ˆì§¸ ìë¦¬ë§ˆë‹¤ ìˆ«ìë¥¼ 2ë°° ì¦ê°€ì‹œí‚µë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `1234`ì—ì„œ 3ê³¼ 1ì„ ë‘ë°°ë¡œ ë§Œë“­ë‹ˆë‹¤.(2464)"

#: src/exercises/day-2/luhn.md:12
msgid ""
"* After doubling a digit, sum the digits. So doubling `7` becomes `14` which\n"
"  becomes `5`."
msgstr "* ë‘ë°°ë¡œ ë§Œë“  ìˆ«ìê°€ 2ìë¦¬ë¼ë©´ ê° ìë¦¬ ìˆ«ìë¥¼ ë”í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `7`ì€ ë‘ë°°ë¡œ ë§Œë“¤ë©´ `14`ì´ë¯€ë¡œ `5`ê°€ ë©ë‹ˆë‹¤."

#: src/exercises/day-2/luhn.md:15
msgid "* Sum all the undoubled and doubled digits."
msgstr "* ëª¨ë“  ìë¦¬ì˜ ìˆ«ìë¥¼ ë”í•©ë‹ˆë‹¤."

#: src/exercises/day-2/luhn.md:17
msgid "* The credit card number is valid if the sum ends with `0`."
msgstr "* í•©ê³„ì˜ ëìë¦¬ê°€ `0`ì¸ ê²½ìš° ìœ íš¨í•œ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ ì…ë‹ˆë‹¤."

#: src/exercises/day-2/luhn.md:19
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and implement the\n"
"function:"
msgstr "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  í•¨ìˆ˜ë¥¼ êµ¬í˜„í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/exercises/day-2/luhn.md:27
msgid ""
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:31
msgid ""
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:36 src/exercises/day-2/solutions-afternoon.md:64
msgid ""
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:44 src/exercises/day-2/solutions-afternoon.md:72
msgid ""
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:49 src/exercises/day-2/solutions-afternoon.md:77
msgid ""
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:54 src/exercises/day-2/solutions-afternoon.md:82
msgid ""
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/luhn.md:61
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:1
msgid "# Strings and Iterators"
msgstr "# ë¬¸ìì—´ê³¼ ë°˜ë³µì"

#: src/exercises/day-2/strings-iterators.md:3
msgid ""
"In this exercise, you are implementing a routing component of a web server. The\n"
"server is configured with a number of _path prefixes_ which are matched against\n"
"_request paths_. The path prefixes can contain a wildcard character which\n"
"matches a full segment. See the unit tests below."
msgstr "ì´ë²ˆ í›ˆë ¨ì€ ì›¹ ì„œë²„ì˜ ë¼ìš°íŒ… ì»´í¬ë„ŒíŠ¸ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì„œë²„ëŠ” _ìš”ì²­ ê²½ë¡œ(request path)_ ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ ê°œì˜ _ê²½ë¡œ ì ‘ë‘ì‚¬(path prefix)_ ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. ê²½ë¡œ ì ‘ë‘ì‚¬ëŠ” ì™€ì¼ë“œì¹´ë“œë¬¸ìë¥¼ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  ì•„ë˜ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/exercises/day-2/strings-iterators.md:8
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests\n"
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤. ì¤‘ê°„ ê²°ê³¼ê°’ì„ `Vec`ì— í• ë‹¹í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/exercises/day-2/strings-iterators.md:16
msgid ""
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:20
msgid ""
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:26
#: src/exercises/day-2/solutions-afternoon.md:146
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/publishers\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:31
#: src/exercises/day-2/solutions-afternoon.md:151
msgid ""
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));"
msgstr ""

#: src/exercises/day-2/strings-iterators.md:46
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-3.md:1
msgid "# Welcome to Day 3"
msgstr "# 3ì¼ì°¨ ê°œìš”"

#: src/welcome-day-3.md:3
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "ì˜¤ëŠ˜ì€ ëª‡ ê°€ì§€ ê³ ê¸‰ ì£¼ì œë¥¼ ë‹¤ë£¹ë‹ˆë‹¤:"

#: src/welcome-day-3.md:5
msgid ""
"* Traits: deriving traits, default methods, and important standard library\n"
"  traits."
msgstr "* íŠ¸ë ˆì‡: íŠ¸ë ˆì‡ ìƒì†(derive), ë””í´íŠ¸ ë©”ì„œë“œ, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ì— ìˆëŠ” ì¤‘ìš”í•œ íŠ¸ë ˆì‡ë“¤."

#: src/welcome-day-3.md:8
msgid ""
"* Generics: generic data types, generic methods, monomorphization, and trait\n"
"  objects."
msgstr "* ì œë„¤ë¦­: ì œë„¤ë¦­ ë°ì´í„° íƒ€ì…, ì œë„¤ë¦­ ë©”ì„œë“œ, ë‹¨í˜•í™”(monomorphization), íŠ¸ë ˆì‡ ê°ì²´."

#: src/welcome-day-3.md:11
msgid "* Error handling: panics, `Result`, and the try operator `?`."
msgstr "* ì˜¤ë¥˜ì²˜ë¦¬(ì—ëŸ¬ í•¸ë“¤ë§): íŒ¨ë‹‰, `Result`, `?` ì—°ì‚°ì."

#: src/welcome-day-3.md:13
msgid "* Testing: unit tests, documentation tests, and integration tests."
msgstr "* í…ŒìŠ¤íŠ¸: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, ë¬¸ì„œ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸."

#: src/welcome-day-3.md:15
msgid ""
"* Unsafe Rust: raw pointers, static variables, unsafe functions, and extern\n"
"  functions."
msgstr "* ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸: ì›ì‹œ(raw) í¬ì¸í„°, ì •ì  ë³€ìˆ˜, ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜, ì™¸ë¶€ í•¨ìˆ˜."

#: src/traits.md:1
msgid "# Traits"
msgstr "# íŠ¸ë ˆì‡(Trait)"

#: src/traits.md:3
msgid "Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "íŠ¸ë ˆì‡ì€ íƒ€ì…ì„ ì¶”ìƒí™” í•˜ëŠ”ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì¸í„°í˜ì´ìŠ¤ì™€ ë¹„ìŠ·í•©ë‹ˆë‹¤:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Greet {\n"
"    fn say_hello(&self);\n"
"}"
msgstr ""

#: src/traits.md:10
msgid ""
"struct Dog {\n"
"    name: String,\n"
"}"
msgstr ""

#: src/traits.md:14
msgid "struct Cat;  // No name, cats won't respond to it anyway."
msgstr "struct Cat;  // ì´ë¦„ì´ ì—†ìŠµë‹ˆë‹¤. ì´ë¦„ì´ ìˆë”ë¼ë„ ê³ ì–‘ì´ëŠ” ì–´ì°¨í”¼ ë¶ˆëŸ¬ë„ ë°˜ì‘ ì—†ì„ ê²ë‹ˆë‹¤."

#: src/traits.md:16
msgid ""
"impl Greet for Dog {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Wuf, my name is {}!\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/traits.md:22
msgid ""
"impl Greet for Cat {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Miau!\");\n"
"    }\n"
"}"
msgstr ""

#: src/traits.md:28
msgid ""
"fn main() {\n"
"    let pets: Vec<Box<dyn Greet>> = vec![\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"        Box::new(Cat),\n"
"    ];\n"
"    for pet in pets {\n"
"        pet.say_hello();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits.md:41
msgid ""
"* Traits may specify pre-implemented (default) methods and methods that users are required to implement themselves. Methods with default implementations can rely on required methods.\n"
"* Types that implement a given trait may be of different sizes. This makes it impossible to have things like `Vec<Greet>` in the example above.\n"
"* `dyn Greet` is a way to tell the compiler about a dynamically sized type that implements `Greet`.\n"
"* In the example, `pets` holds Fat Pointers to objects that implement `Greet`. The Fat Pointer consists of two components, a pointer to the actual object and a pointer to the virtual method table for the `Greet` implementation of that particular object."
msgstr ""
"* íŠ¸ë ˆì‡ì€ ì‚¬ìš©ìê°€ ì§ì ‘ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ë©”ì„œë“œì™€ ì‚¬ì „ êµ¬í˜„ëœ(ë””í´íŠ¸) ë©”ì„œë“œë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê¸°ë³¸ êµ¬í˜„ëœ ë©”ì„œë“œëŠ” (ë‹¤ë¥¸)í•„ìˆ˜ ë©”ì„œë“œë¥¼ ì˜ì¡´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì—¬ëŸ¬ íƒ€ì…ì´ ê°™ì€ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë”ë¼ë„ ê·¸ í¬ê¸°ëŠ” ì„œë¡œ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ `Vec<Greeet>`ê°™ì€ ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ì™œëƒí•˜ë©´ `Greet`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…ë“¤ ì¤‘ ì–´ë–¤ í¬ê¸°ì˜ íƒ€ì…ì´ ì‹¤ì œë¡œ ì‚¬ìš©ë  ì§€, ì»´íŒŒì¼ ì‹œì— ì•Œ ë°©ë²•ì´ ì—†ëŠ” ë°˜ë©´, `Vec<>`ëŠ” íƒ€ì…ì˜ í¬ê¸°ë¥¼ ì»´íŒŒì¼ ì‹œì— ì•Œê³ ì í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"
"* `dyn Greet`ëŠ” `Greet`ì„ êµ¬í˜„í•˜ëŠ”, ê°€ë³€ í¬ê¸°ì˜ íƒ€ì…ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/traits.md:46
msgid ""
"Compare these outputs in the above example:\n"
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"
msgstr ""
"ìœ„ì˜ ì˜ˆì œì— ì•„ë˜ë¥¼ ì¶”ê°€í•˜ì—¬ ì¶œë ¥ì„ ë¹„êµí•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤:\n"
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Greet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Greet>>());\n"
"```"

#: src/traits/deriving-traits.md:1
msgid "# Deriving Traits"
msgstr "# íŠ¸ë ˆì‡ ìƒì†í•˜ê¸°(Deriving Traits)"

#: src/traits/deriving-traits.md:3
msgid "You can let the compiler derive a number of traits:"
msgstr "ì»´íŒŒì¼ëŸ¬ê°€ ì—¬ëŸ¬ê°€ì§€ íŠ¸ë ˆì‡ì„ ìƒì†(derive)í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš° ì»´íŒŒì¼ëŸ¬ê°€ íŠ¸ë ˆì‡ì„ ìë™ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤:"

#: src/traits/deriving-traits.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}"
msgstr ""

#: src/traits/deriving-traits.md:13
msgid ""
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:1
msgid "# Default Methods"
msgstr "# ë””í´íŠ¸ ë©”ì„œë“œ"

#: src/traits/default-methods.md:3
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr "íŠ¸ë ˆì‡ì˜ ë””í´íŠ¸ ë©”ì„œë“œì—ì„œ ë‹¤ë¥¸(êµ¬í˜„ë˜ì§€ ì•Šì€) ë©”ì†Œë“œë¥¼ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equal(&self, other: &Self) -> bool;\n"
"    fn not_equal(&self, other: &Self) -> bool {\n"
"        !self.equal(other)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/default-methods.md:13
msgid ""
"#[derive(Debug)]\n"
"struct Centimeter(i16);"
msgstr ""

#: src/traits/default-methods.md:16
msgid ""
"impl Equals for Centimeter {\n"
"    fn equal(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}"
msgstr ""

#: src/traits/default-methods.md:22
msgid ""
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equal(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equal(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/important-traits.md:1
msgid "# Important Traits"
msgstr "# ì¤‘ìš”í•œ íŠ¸ë ˆì‡ë“¤"

#: src/traits/important-traits.md:3
msgid "We will now look at some of the most common traits of the Rust standard library:"
msgstr "ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë²”ìš© íŠ¸ë ˆì‡ë“¤ì´ ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#: src/traits/important-traits.md:5
msgid ""
"* [`Iterator`][1] and [`IntoIterator`][2] used in `for` loops,\n"
"* [`From`][3] and [`Into`][4] used to convert values,\n"
"* [`Read`][5] and [`Write`][6] used for IO,\n"
"* [`Add`][7], [`Mul`][8], ... used for operator overloading, and\n"
"* [`Drop`][9] used for defining destructors.\n"
"* [`Default`][10] used to construct a default instance of a type."
msgstr ""
"* [`Iterator`][1]ì™€ [`IntoIterator`][2] íŠ¸ë ˆì‡ì€ `for` ë£¨í”„ì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"* [`From`][3]ê³¼ [`Into`][4] íŠ¸ë ˆì‡ì€ ê°’ì„ ë³€í™˜í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"* [`Read`][5]ì™€ [`Write`][6] íŠ¸ë ˆì‡ì€ I/Oì— ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"* [`Add`][7], [`Mul`][8] ë“±ì˜ íŠ¸ë ˆì‡ë“¤ì€ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©(overloading)ì— ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"* [`Drop`][9] íŠ¸ë ˆì‡ì€ ì†Œë©¸ì ì •ì˜ì— ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
"* [`Default`][10] íŠ¸ë ˆì‡ì€ ì–´ë–¤ íƒ€ì…ì˜ ê¸°ë³¸ê°’ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/traits/important-traits.md:12
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\n"
"[3]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[4]: https://doc.rust-lang.org/std/convert/trait.Into.html\n"
"[5]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[6]: https://doc.rust-lang.org/std/io/trait.Write.html\n"
"[7]: https://doc.rust-lang.org/std/ops/trait.Add.html\n"
"[8]: https://doc.rust-lang.org/std/ops/trait.Mul.html\n"
"[9]: https://doc.rust-lang.org/std/ops/trait.Drop.html\n"
"[10]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr ""

#: src/traits/iterator.md:1
msgid "# Iterators"
msgstr "# Iterators"

#: src/traits/iterator.md:3
msgid "You can implement the [`Iterator`][1] trait on your own types:"
msgstr "`Iterator`íŠ¸ë ˆì‡ì„ ì—¬ëŸ¬ë¶„ì´ ì •ì˜í•œ íƒ€ì…ì—ì„œ êµ¬í˜„í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}"
msgstr ""

#: src/traits/iterator.md:11
msgid ""
"impl Iterator for Fibonacci {\n"
"    type Item = u32;"
msgstr ""

#: src/traits/iterator.md:14
msgid ""
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}"
msgstr ""

#: src/traits/iterator.md:22
msgid ""
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
msgid ""
"* `IntoIterator` is the trait that makes for loops work. It is implemented by collection types such as\n"
"  `Vec<T>` and references to them such as `&Vec<T>` and `&[T]`. Ranges also implement it.\n"
"* The `Iterator` trait implements many common functional programming operations over collections \n"
"  (e.g. `map`, `filter`, `reduce`, etc). This is the trait where you can find all the documentation\n"
"  about them. In Rust these functions should produce the code as efficient as equivalent imperative\n"
"  implementations.\n"
"    \n"
"</details>"
msgstr ""
"* `IntoIterator`ëŠ” ë£¨í”„ê°€ ì‘ë™í•˜ë„ë¡ ë§Œë“œëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤. `Vec<T>`ì™€ ê°™ì€ ì»¬ë ‰ì…˜ íƒ€ì…ê³¼ ê·¸ì— ëŒ€í•œ ì°¸ì¡° íƒ€ì…(`&Vec<T>`, `&[T]`)ë“¤ ëª¨ë‘ ì´ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤. Range ì—­ì‹œ ì´ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.\n"
"* `Iterator` íŠ¸ë ˆì‡ì€ ì»¬ë ‰ì…˜ì— ëŒ€í•´ ë‹¤ì–‘í•œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì—°ì‚° (`map`, `filter`, `reduce` ë“±)ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ ì—°ì‚°ë“¤ì— ëŒ€í•œ ìì„¸í•œ ì„¤ëª…ì€ `Iterator` íŠ¸ë ˆì‡ì˜ API ë ˆí¼ëŸ°ìŠ¤ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì´ëŸ¬í•œ í•¨ìˆ˜í˜• ì—°ì‚°ë“¤ì€ ì ˆì°¨í˜•ìœ¼ë¡œ êµ¬í˜„ëœ ì½”ë“œì™€ ë™ì¼í•œ ì„±ëŠ¥ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/traits/iterator.md:41
msgid "[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr ""

#: src/traits/from-iterator.md:1
msgid "# FromIterator"
msgstr "# FromIterator"

#: src/traits/from-iterator.md:3
msgid "[`FromIterator`][1] lets you build a collection from an [`Iterator`][2]."
msgstr "ì–´ë–¤ ì»¬ë ‰ì…˜ì´ `[FromIterator`][1]ë¥¼ êµ¬í˜„í•˜ê³  ìˆë‹¤ë©´ [`Iterator`][2]ë¡œë¶€í„° ê·¸ ì»¬ë ‰ì…˜ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
msgid ""
"`Iterator` implements\n"
"`fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized`"
msgstr ""
"`Iterator`ëŠ” ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤.\n"
"```\n"
"fn collect<B>(self) -> B\n"
"where\n"
"    B: FromIterator<Self::Item>,\n"
"    Self: Sized\n"
"```"

#: src/traits/from-iterator.md:23
msgid ""
"There are also implementations which let you do cool things like convert an\n"
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr "ì´ëŠ” ë˜í•œ `Iterator<Item = Result<V, E>>`ì„ `Result<Vec<V>, E>`ë¡œ ë³€ê²½í•˜ëŠ” ë©‹ì§„ ì‘ì—…ë„ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/traits/from-iterator.md:28
msgid ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html\n"
"[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"

#: src/traits/from-into.md:1
msgid "# `From` and `Into`"
msgstr "# `From`ê³¼ `Into`"

#: src/traits/from-into.md:3
msgid "Types implement [`From`][1] and [`Into`][2] to facilitate type conversions:"
msgstr "íƒ€ì…ì€ ìš©ì´í•œ í˜•ë³€í™˜ì„ ìœ„í•´ [`From`][1]ê³¼ [`Into`][2]ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
msgid "[`Into`][2] is automatically implemented when [`From`][1] is implemented:"
msgstr "[`From`][1]ì´ êµ¬í˜„ë˜ë©´ [`Into`][2] ì—­ì‹œ ìë™ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤:"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:27
msgid ""
"<details>\n"
"  \n"
"* That's why it is common to only implement `From`, as your type will get `Into` implementation too.\n"
"* When declaring a function argument input type like \"anything that can be converted into a `String`\", the rule is opposite, you should use `Into`.\n"
"  Your function will accept types that implement `From` and those that _only_ implement `Into`.\n"
"    \n"
"</details>"
msgstr ""
"<details>\n"
"  \n"
"* ê·¸ë ‡ê¸° ë•Œë¬¸ì— ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì˜ ê²½ìš°ì—ë„ `From` ë§Œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.\n"
"* \"`String`ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²ƒ\"ê³¼ ê°™ì€ í•¨ìˆ˜ì˜ ì¸ìˆ˜ íƒ€ì…ì„ ì„ ì–¸í•  ë•Œì—ëŠ” `Into`ë¥¼ ì‚¬ìš©í•´ì•¼ í•¨ì„ ì¡°ì‹¬í•˜ì„¸ìš”. ê·¸ë˜ì•¼ë§Œ, í•¨ìˆ˜ëŠ” `From`ì„ êµ¬í˜„í•œ íƒ€ì…ê³¼ `Into` _ë§Œ_ êµ¬í˜„í•œ íƒ€ì… ëª¨ë‘ë¥¼ ì¸ìë¡œ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/traits/from-into.md:35
msgid ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/convert/trait.From.html\n"
"[2]: https://doc.rust-lang.org/std/convert/trait.Into.html"

#: src/traits/read-write.md:1
msgid "# `Read` and `Write`"
msgstr "# `Read`ì™€ `Write`"

#: src/traits/read-write.md:3
msgid "Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:"
msgstr "[`Read`][1]ì™€ [`BufRead`][2]ë¥¼ ì‚¬ìš©í•˜ë©´ `u8` íƒ€ì…ì˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};"
msgstr ""

#: src/traits/read-write.md:8
msgid ""
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}"
msgstr ""

#: src/traits/read-write.md:13
msgid ""
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));"
msgstr ""

#: src/traits/read-write.md:17
msgid ""
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
msgid "Similarly, [`Write`][3] lets you abstract over `u8` sinks:"
msgstr "ì´ì™€ ë¹„ìŠ·í•˜ê²Œ, `Write`ë¥¼ ì‚¬ì˜¹í•˜ë©´ `u8` íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};"
msgstr ""

#: src/traits/read-write.md:28
msgid ""
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}"
msgstr ""

#: src/traits/read-write.md:33
msgid ""
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:42
msgid ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/io/trait.Read.html\n"
"[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n"
"[3]: https://doc.rust-lang.org/std/io/trait.Write.html"

#: src/traits/operators.md:1
msgid "# `Add`, `Mul`, ..."
msgstr "# `Add`, `Mul`, ..."

#: src/traits/operators.md:3
msgid "Operator overloading is implemented via traits in [`std::ops`][1]:"
msgstr "ì—°ì‚°ì ì˜¤ë²„ë¡œë“œëŠ” `std::ops`ì— ìˆëŠ” ë‹¤ì–‘í•œ íŠ¸ë ˆì‡ë“¤ì„ í†µí•´ êµ¬í˜„ë©ë‹ˆë‹¤:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }"
msgstr ""

#: src/traits/operators.md:9 src/exercises/day-2/solutions-morning.md:46
msgid ""
"impl std::ops::Add for Point {\n"
"    type Output = Self;"
msgstr ""

#: src/traits/operators.md:12
msgid ""
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}"
msgstr ""

#: src/traits/operators.md:17
msgid ""
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:26 src/traits/drop.md:34
msgid "Discussion points:"
msgstr "ë…¼ì˜ì :"

#: src/traits/operators.md:28
msgid ""
"* You could implement `Add` for `&Point`. In which situations is that useful? \n"
"    * Answer: `Add:add` consumes `self`. If type `T` for which you are\n"
"        overloading the operator is not `Copy`, you should consider overloading\n"
"        the operator for `&T` as well. This avoids unnecessary cloning on the\n"
"        call site.\n"
"* Why is `Output` an associated type? Could it be made a type parameter?\n"
"    * Short answer: Type parameters are controlled by the caller, but\n"
"        associated types (like `Output`) are controlled by the implementor of a\n"
"        trait."
msgstr ""
"* `&Point`ê°€ `Add`ë¥¼ êµ¬í˜„í•˜ë„ë¡ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ê²Œ ì–´ë–¤ ê²½ìš°ì— ìœ ìš©í• ê¹Œìš”?\n"
"  * ë‹µ: `Add:add`ëŠ” `self`ë¥¼ ì†Œëª¨í•©ë‹ˆë‹¤. ë§Œì•½ íƒ€ì… `T`ê°€ `Copy`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆì§€ ì•Šë‹¤ë©´ `&T`ì— ëŒ€í•´ì„œë„ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ í˜¸ì¶œë¶€ì—ì„œ ë¶ˆí•„ìš”í•œ ë³µì‚¬ë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì™œ `Output`ì´ ì—°ê´€ëœ íƒ€ì…ì¸ê°€ìš”? íƒ€ì… íŒŒë¼ë©”í„°ë¡œ ë§Œë“¤ ìˆ˜ ìˆì„ê¹Œìš”?\n"
"  * ë‹µ: íƒ€ì… íŒŒë¼ë©”í„°ë¥¼ í˜¸ì¶œí•˜ëŠ” ìª½ì—ì„œ ê²°ì •í•©ë‹ˆë‹¤. ë°˜ë©´ ì—°ê´€ëœ íƒ€ì…(`Output`ê°™ì€) ì€ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ìª½ì—ì„œ ì œì–´ ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/traits/operators.md:40
msgid "[1]: https://doc.rust-lang.org/std/ops/index.html"
msgstr ""

#: src/traits/drop.md:1
msgid "# The `Drop` Trait"
msgstr "# `Drop` íŠ¸ë ˆì‡"

#: src/traits/drop.md:3
msgid "Values which implement [`Drop`][1] can specify code to run when they go out of scope:"
msgstr "[`Drop`][1]íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë©´, ê·¸ ê°’ì´ ìŠ¤ì½”í”„ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ë•Œ ì‹¤í–‰ë  ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}"
msgstr ""

#: src/traits/drop.md:10
msgid ""
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}"
msgstr ""

#: src/traits/drop.md:16
msgid ""
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:36
msgid ""
"* Why doesn't `Drop::drop` take `self`?\n"
"    * Short-answer: If it did, `std::mem::drop` would be called at the end of\n"
"        the block, resulting in another call to `Drop::drop`, and a stack\n"
"        overflow!\n"
"* Try replacing `drop(a)` with `a.drop()`."
msgstr ""
"* `Drop::drop`ì€ ì™œ `self`ë¥¼ ì¸ìë¡œ ë°›ì§€ ì•ŠìŠµë‹ˆê¹Œ?\n"
"  * ì§§ì€ ëŒ€ë‹µ: ë§Œì•½ ê·¸ë ‡ê²Œ ëœë‹¤ë©´ `std::mem::drop`ì´ ë¸”ë¡ì˜ ëì—ì„œ í˜¸ì¶œë˜ê³ , ë‹¤ì‹œ `Drop::drop`ì„ í˜¸ì¶œí•˜ê²Œë˜ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œê°€ ë°œìƒí•©ë‹ˆë‹¤.\n"
"* `drop(a)`ë¥¼ `a.drop()`ë¡œ ë³€ê²½í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/traits/drop.md:44
msgid "[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html"
msgstr ""

#: src/traits/default.md:1
msgid "# The `Default` Trait"
msgstr "# `Default` íŠ¸ë ˆì‡"

#: src/traits/default.md:3
msgid "[`Default`][1] trait provides a default implementation of a trait."
msgstr "[`Default`][1] íŠ¸ë ˆì‡ì€ ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}"
msgstr ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}"

#: src/traits/default.md:13
msgid ""
"#[derive(Debug)]\n"
"struct Implemented(String);"
msgstr ""
"#[derive(Debug)]\n"
"struct Implemented(String);"

#: src/traits/default.md:16
msgid ""
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}"
msgstr ""
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}"

#: src/traits/default.md:22
msgid ""
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");"
msgstr ""
"fn main() {\n"
"    let default_struct: Derived = Default::default();\n"
"    println!(\"{default_struct:#?}\");"

#: src/traits/default.md:26
msgid ""
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");"
msgstr ""
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Default::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");"

#: src/traits/default.md:32
msgid ""
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}"
msgstr ""
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}"

#: src/traits/default.md:40
msgid ""
"  * It can be implemented directly or it can be derived via `#[derive(Default)]`.\n"
"  * Derived implementation will produce an instance where all fields are set to their default values.\n"
"    * This means all types in the struct must implement `Default` too.\n"
"  * Standard Rust types often implement `Default` with reasonable values (e.g. `0`, `\"\"`, etc).\n"
"  * The partial struct copy works nicely with default.\n"
"  * Rust standard library is aware that types can implement `Default` and provides convenience methods that use it."
msgstr ""
"  * íŠ¸ë ˆì‡ì„ ì§ì ‘ êµ¬í˜„í•˜ê±°ë‚˜ `#[derive(Default)]`ë¥¼ ë¶™ì—¬ì„œ ì»´íŒŒì¼ëŸ¬ì—ê²Œ êµ¬í˜„ì„ ë§¡ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"  * ì»´íŒŒì¼ëŸ¬ê°€ ì œê³µí•˜ëŠ” ìë™ êµ¬í˜„ì˜ ê²½ìš° ëª¨ë“  í•„ë“œì— ëŒ€í•´ ê¸°ë³¸ ê°’ì„ ì„¤ì •í•œ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"    * êµ¬ì¡°ì²´ì˜ ê° í•„ë“œ íƒ€ì…ë“¤ì´ ëª¨ë‘ `Default`ë¥¼ êµ¬í˜„í•´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"  * ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ íƒ€ì…ë“¤ì€ ëŒ€ë¶€ë¶„ `Default`ë¥¼ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©°, ê¸°ë³¸ ê°’ì€ `0`ì´ë‚˜ `\"\"`ì²˜ëŸ¼ ì˜ˆìƒ ê°€ëŠ¥í•œ ê°’ë“¤ì…ë‹ˆë‹¤.\n"
"  * êµ¬ì¡°ì²´ ë¶€ë¶„ ë³µì‚¬ë¥¼ í• ë•Œ `default`ë¥¼ í¸ë¦¬í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"  * Rust standard library is aware that types can implement `Default` and provides convenience methods that use it."

#: src/traits/default.md:49
msgid "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"
msgstr "[1]: https://doc.rust-lang.org/std/default/trait.Default.html"

#: src/generics.md:1
msgid "# Generics"
msgstr "# ì œë„¤ë¦­"

#: src/generics.md:3
msgid ""
"Rust support generics, which lets you abstract an algorithm (such as sorting)\n"
"over the types used in the algorithm."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì œë„¤ë¦­ì„ ì§€ì›í•©ë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ì•Œê³ ë¦¬ì¦˜(ì •ë ¬ê³¼ ê°™ì€)ì„ ì¶”ìƒí™” í•˜ì—¬ íŠ¹ì • íƒ€ì…ì— ì˜ì¡´í•˜ì§€ ì•Šë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/data-types.md:1
msgid "# Generic Data Types"
msgstr "# ì œë„¤ë¦­ ë°ì´í„° íƒ€ì…"

#: src/generics/data-types.md:3
msgid "You can use generics to abstract over the concrete field type:"
msgstr "ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ì—¬ í•„ë“œì˜ íƒ€ì…ì„ ì¶”ìƒí™” í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}"
msgstr ""

#: src/generics/data-types.md:12
msgid ""
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:1
msgid "# Generic Methods"
msgstr "# ì œë„¤ë¦­ ë©”ì„œë“œ"

#: src/generics/methods.md:3
msgid "You can declare a generic type on your `impl` block:"
msgstr "`impl` ë¸”ë¡ì—ì„œë„ ì œë„¤ë¦­ íƒ€ì…ì„ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);"
msgstr ""

#: src/generics/methods.md:9
msgid ""
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }"
msgstr ""

#: src/generics/methods.md:14
msgid ""
"    // fn set_x(&mut self, x: T)\n"
"}"
msgstr ""

#: src/generics/methods.md:17
msgid ""
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
msgid ""
"* *Q:* Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that redundant?\n"
"    * This is because it is a generic implementation section for generic type. They are independently generic.\n"
"    * It means these methods are defined for any `T`.\n"
"    * It is possible to write `impl Point<u32> { .. }`. \n"
"      * `Point` is still generic and you can use `Point<f64>`, but methods in this block will only be available for `Point<u32>`."
msgstr ""
"* *ì§ˆë¬¸:* `impl<T> Point<T> {}`ì—ì„œ `T`ê°€ ì™œ ë‘ ë²ˆ ì‚¬ìš©ë©ë‹ˆê¹Œ?\n"
"  * ì œë„¤ë¦­ íƒ€ì…ì— ëŒ€í•œ ì œë„¤ë¦­ êµ¬í˜„ ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ ë‘ ì œë„¤ë¦­ì€ ì„œë¡œ ë…ë¦½ì ì…ë‹ˆë‹¤.\n"
"  * ì´ëŠ” ì„ì˜ì˜ ëª¨ë“  `T`ì— ëŒ€í•´ì„œ ì´ ë©”ì†Œë“œë“¤ì´ ì •ì˜ëœë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"  * `impl Point<u32> { .. }`ì™€ ê°™ì´ ì‘ì„±í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
"    * `Point`ëŠ” ì—¬ì „íˆ ì œë„¤ë¦­ì´ë©° `Point<f64>`ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆì§€ë§Œ ì´ ë¸”ë¡ì˜ ë©”ì„œë“œëŠ” `Point<u32>`ë§Œ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/trait-bounds.md:1
msgid "# Trait Bounds"
msgstr "# ì œë„¤ë¦­ íƒ€ì… ì œí•œ(íŠ¸ë ˆì‡ ê²½ê³„, Trait Bounds)"

#: src/generics/trait-bounds.md:3
msgid ""
"When working with generics, you often want to require the types to implement\n"
"some trait, so that you can call this trait's methods."
msgstr "ì œë„¤ë¦­ì„ ì´ìš©í•˜ë‹¤ ë³´ë©´ íƒ€ì…ì´ ì–´ë–¤ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆì–´ì•¼ í•˜ëŠ” ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ì•¼ ê·¸ íŠ¸ë ˆì‡ì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/generics/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "`T: Trait` í˜¹ì€ `impl Trait`ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤:"

#: src/generics/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}"
msgstr ""

#: src/generics/trait-bounds.md:13
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}"
msgstr ""

#: src/generics/trait-bounds.md:19
msgid "// struct NotClonable;"
msgstr ""

#: src/generics/trait-bounds.md:21
msgid ""
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");"
msgstr ""

#: src/generics/trait-bounds.md:26
msgid ""
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-bounds.md:35
msgid ""
"Show a `where` clause, students will encounter it when reading code.\n"
"    \n"
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""
"`where` ë¬¸ë²•ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ìˆ˜ê°•ìƒë“¤ë„ ì½”ë“œë¥¼ ì½ë‹¤ê°€ ê·¸ ë¬¸ë²•ì„ ë§ˆì£¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"

#: src/generics/trait-bounds.md:46
msgid ""
"* It declutters the function signature if you have many parameters.\n"
"* It has additional features making it more powerful.\n"
"    * If someone asks, the extra feature is that the type on the left of \":\" can be arbitrary, like `Option<T>`.\n"
"    \n"
"</details>"
msgstr ""
"* ì´ë¥¼ ì´ìš©í•˜ë©´ íƒ€ì… íŒŒë¼ë©”í„°ê°€ ë§ì€ ê²½ìš° í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•˜ëŠ”ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.\n"
"* ì¢€ ë” ê°•ë ¥í•œ ì¶”ê°€ ê¸°ëŠ¥ë„ ì œê³µí•©ë‹ˆë‹¤.\n"
"  * `\":\" ì™¼ìª½ì— ì„ì˜ì˜ íƒ€ì…(ì˜ˆë¥¼ ë“¤ì–´ `Option<T>`)ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/generics/impl-trait.md:1
msgid "# `impl Trait`"
msgstr "# íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°(`impl Trait`)"

#: src/generics/impl-trait.md:3
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function\n"
"arguments and return values:"
msgstr "íŠ¸ë ˆì‡ ë°”ìš´ë“œì™€ ìœ ì‚¬í•˜ê²Œ `impl Trait` ë¬¸ë²•ì€ í•¨ìˆ˜ì˜ ì¸ìì™€ ë°˜í™˜ê°’ì—ë„ ì ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/generics/impl-trait.md:6 src/generics/trait-objects.md:5
#: src/generics/trait-objects.md:28
msgid ""
"```rust,editable\n"
"use std::fmt::Display;"
msgstr ""

#: src/generics/impl-trait.md:9
msgid ""
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}"
msgstr ""

#: src/generics/impl-trait.md:13
msgid ""
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/impl-trait.md:19
msgid ""
"* `impl Trait` cannot be used with the `::<>` turbo fish syntax.\n"
"* `impl Trait` allows you to work with types which you cannot name."
msgstr ""
"* `impl Trait`ë¥¼ í„°ë³´í”¼ì‰¬ë¬¸ë²•(`::<>`)ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
"* `impl Trait`ë¥¼ ì´ìš©í•˜ë©´ ì´ë¦„ì´ ì—†ëŠ” íƒ€ì…ì„ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/impl-trait.md:24
msgid "The meaning of `impl Trait` is a bit different in the different positions."
msgstr "`impl Trait`ëŠ” ì–´ë””ì— ì‚¬ìš©ë˜ì—ˆëŠëƒì— ë”°ë¼ ì˜ë¯¸ê°€ ì¡°ê¸ˆì”© ë‹¤ë¦…ë‹ˆë‹¤."

#: src/generics/impl-trait.md:26
msgid ""
"* For a parameter, `impl Trait` is like an anonymous generic parameter with a trait bound.\n"
"* For a return type, it means that the return type is some concrete type that implements the trait,\n"
"  without naming the type. This can be useful when you don't want to expose the concrete type in a\n"
"  public API."
msgstr ""
"* í•¨ìˆ˜ ì¸ìì˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆì„ ê²½ìš°ì—ëŠ” `impl Trait`ëŠ” íŠ¸ë ˆì‡ ê²½ê³„ê°€ ìˆëŠ” ìµëª…ì˜ ì œë„¤ë¦­ íƒ€ì…ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"* ë¦¬í„´ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆì„ ê²½ìš°ì—ëŠ”, ê·¸ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” êµ¬ì²´ì ì¸ íƒ€ì…ì¸ë°, íƒ€ì… ì´ë¦„ì„ í”„ë¡œê·¸ë˜ë¨¸ê°€ ì§“ì§€ ì•Šì•˜ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ê·¸ êµ¬ì²´ì ì¸ íƒ€ì… ì´ë¦„ì„ APIë¡œ ê³µê°œí•˜ê³  ì‹¶ì§€ ì•Šì€ ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤."

#: src/generics/impl-trait.md:31
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to explain that\n"
"nothing here enforces that it is _the same_ `impl Display` type. If we used a single \n"
"`T: Display`, it would enforce the constraint that input `T` and return `T` type are the same type.\n"
"It would not work for this particular function, as the type we expect as input is likely not\n"
"what `format!` returns. If we wanted to do the same via `: Display` syntax, we'd need two\n"
"independent generic parameters.\n"
"    \n"
"</details>"
msgstr ""
"ì´ ì˜ˆì‹œëŠ” `impl Display`ê°€ ë‘ë²ˆ ì‚¬ìš© ë˜ì—ˆë‹¤ëŠ” ì ì—ì„œ í›Œë¥­í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê²ƒì€ ì´ ë‘ `impl Display`ê°€ ì‹¤ì œë¡œ ê°™ì€ íƒ€ì…ì¼ í•„ìš”ê°€ ì—†ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ë§Œì•½ `T: Display`ë¡œ íŠ¸ë ˆì‡ ê²½ê³„ë¥¼ ì •í•˜ê³  ì…ë ¥ íŒŒë¼ë©”í„°ì™€ ë¦¬í„´ ê°’ì˜ íƒ€ì…ì„ ëª¨ë‘ `T`ë¡œ í–ˆë‹¤ë©´, ì´ëŠ” ì…ë ¥ê³¼ ë¦¬í„´ê°’ì´ ê°™ì€ íƒ€ì…ì„ì„ ê°•ì œí•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í–ˆë‹¤ë©´ ìœ„ì˜ ì˜ˆì œëŠ” ë™ì‘í•˜ì§€ ì•Šì•˜ì„ ê²ƒì…ë‹ˆë‹¤. ì™œëƒí•˜ë©´, ì…ë ¥ ê°’ì˜ íƒ€ì…ì´ `format!`ì´ ë¦¬í„´í•˜ëŠ” íƒ€ì…ê³¼ ê°™ì§€ ì•Šì„ ê°€ëŠ¥ì„±ì´ ë†’ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë§Œì•½ `: Display` ë¬¸ë²•ì„ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ ë…ë¦½ì ì¸ ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ê°€ ë‘ ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/generics/closures.md:1
msgid "# Closures"
msgstr "# í´ë¡œì €(Closures)"

#: src/generics/closures.md:3
msgid ""
"Closures or lambda expressions have types which cannot be named. However, they\n"
"implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),\n"
"[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and\n"
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr "í´ë¡œì € í˜¹ì€ ëŒë‹¤í‘œí˜„ì‹ì€ ìµëª…íƒ€ì…ì…ë‹ˆë‹¤. ì´ë“¤ì€ [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) ë¼ëŠ” íŠ¹ë³„í•œ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤:"

#: src/generics/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}"
msgstr ""

#: src/generics/closures.md:14
msgid ""
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    let mul_5 = |x| x * 5;"
msgstr ""

#: src/generics/closures.md:18
msgid ""
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"mul_5: {}\", apply_with_log(mul_5, 20));\n"
"}\n"
"```"
msgstr ""

#: src/generics/closures.md:25
msgid "If you have an `FnOnce`, you may only call it once. It might consume captured values."
msgstr "`FnOnce`ëŠ” í•œë²ˆë§Œ í˜¸ì¶œë˜ë©° ìº¡ì²˜ëœ ê°’ì„ ì†Œëª¨í•©ë‹ˆë‹¤."

#: src/generics/closures.md:27
msgid "An `FnMut` might mutate captured values, so you can call it multiple times but not concurrently."
msgstr "`FnMut`ëŠ” ìº¡ì²˜ëœ ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì—¬ëŸ¬ë²ˆ í˜¸ì¶œì€ ê°€ëŠ¥í•˜ì§€ë§Œ ë™ì‹œì— í˜¸ì¶œ í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤."

#: src/generics/closures.md:29
msgid ""
"An `Fn` neither consumes nor mutates captured values, or perhaps captures nothing at all, so it can\n"
"be called multiple times concurrently."
msgstr "`Fn`ì€ ìº¡ì²˜ëœ ê°’ì„ ì†Œëª¨ë„ ë³€ê²½ë„ í•˜ì§€ ì•Šê³ , í˜¹ì€ ì–´ë–¤ ê²ƒë„ ìº¡ì³í•˜ì§€ ì•Šì•˜ì„ ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì— ë™ì‹œì— ì—¬ëŸ¬ë²ˆ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/closures.md:32
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. I.e. you can use an\n"
"`FnMut` wherever an `FnOnce` is called for, and you can use an `Fn` wherever an `FnMut` or `FnOnce`\n"
"is called for."
msgstr "`FnMut` ëŠ” `FnOnce`ì˜ í•˜ìœ„íƒ€ì…ì…ë‹ˆë‹¤. `Fn`ì€ `FnMut`ê³¼ `FnOnce`ì˜ í•˜ìœ„ íƒ€ì…ì…ë‹ˆë‹¤. ì¦‰, `FnMut`ëŠ” `FnOnce`ê°€ í˜¸ì¶œë˜ëŠ” ê³³ì´ë©´ ì–´ë””ì„œë‚˜ ì‚¬ìš© í•  ìˆ˜ ìˆê³  `Fn`ì€ `FnMut`ì™€ `FnOnce`ê°€ í˜¸ì¶œë˜ëŠ” ê³³ì´ë©´ ì–´ë””ë“  ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/closures.md:36
msgid "`move` closures only implement `FnOnce`."
msgstr "í´ë¡œì €ê°€ `move`ì™€ í•¨ê»˜ ì„ ì–¸ë˜ì—ˆë‹¤ë©´ ê·¸ í´ë¡œì €ëŠ” ì˜¤ì§ `FnOnce`ë§Œ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/generics/monomorphization.md:1
msgid "# Monomorphization"
msgstr "# ë‹¨í˜•í™”(Monomorphization)"

#: src/generics/monomorphization.md:3
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr "ì œë„¤ë¦­ ì½”ë“œëŠ” í˜¸ì¶œë¶€ì—ì„œ ë¹„ ì œë„¤ë¦­ ì½”ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
msgid "behaves as if you wrote"
msgstr "ìœ„ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ì´ ë™ì‘í•©ë‹ˆë‹¤"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}"
msgstr ""

#: src/generics/monomorphization.md:20
msgid ""
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}"
msgstr ""

#: src/generics/monomorphization.md:25
msgid ""
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you had\n"
"hand-coded the data structures without the abstraction."
msgstr "ì´ê²ƒì´ ë°”ë¡œ ë¹„ìš©ì´ ë“¤ì§€ ì•ŠëŠ” (zero-cost) ì¶”ìƒí™” ì…ë‹ˆë‹¤: ëŸ¬ìŠ¤íŠ¸ì˜ ì œë„¤ë¦­ì€ ì¶”ìƒí™”ë¥¼ ê±°ì¹˜ì§€ ì•Šê³  ì§ì ‘ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì¨ì„œ ì½”ë”©í•œ ê²ƒê³¼ ì •í™•íˆ ë™ì¼í•œ ê²°ê³¼ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/generics/trait-objects.md:1
msgid "# Trait Objects"
msgstr "# íŠ¸ë ˆì‡ ê°ì²´"

#: src/generics/trait-objects.md:3
msgid "We've seen how a function can take arguments which implement a trait:"
msgstr "í•¨ìˆ˜ê°€ íŠ¹ì • íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ì¸ìë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ë„ë¡ í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ì„¤ëª…í–ˆì—ˆìŠµë‹ˆë‹¤:"

#: src/generics/trait-objects.md:8
msgid ""
"fn print<T: Display>(x: T) {\n"
"    println!(\"Your value: {x}\");\n"
"}"
msgstr ""

#: src/generics/trait-objects.md:12
msgid ""
"fn main() {\n"
"    print(123);\n"
"    print(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:18
msgid "However, how can we store a collection of mixed types which implement `Display`?"
msgstr "ê·¸ëŸ°ë°, ì•„ë˜ì™€ ê°™ì´ `Display`ë¥¼ êµ¬í˜„í•˜ëŠ” ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ë“¤ì˜ ì½œë ‰ì…˜ì„ ì €ì¥í•˜ê³  ì‹¶ë‹¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?"

#: src/generics/trait-objects.md:20
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let xs = vec![123, \"Hello\"];\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:26
msgid "For this, we need _trait objects_:"
msgstr "ì´ë¥¼ ìœ„í•´ì„œëŠ” _íŠ¸ë ˆì‡ ê°ì²´_ê°€ í•„ìš”í•©ë‹ˆë‹¤:"

#: src/generics/trait-objects.md:31
msgid ""
"fn main() {\n"
"    let xs: Vec<Box<dyn Display>> = vec![Box::new(123), Box::new(\"Hello\")];\n"
"    for x in xs {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:39
msgid "Memory layout after allocating `xs`:"
msgstr "`xs`ê°€ í• ë‹¹ë ë•Œ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:"

#: src/generics/trait-objects.md:41
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - - -.\n"
":                           :     :                                               :\n"
":    xs                     :     :                                               :\n"
":   +-----------+-------+   :     :   +-----+-----+                               :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |                               :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+                               :\n"
":   | capacity  |     2 |   :     :     | |   | |   +----+----+----+----+----+    :\n"
":   +-----------+-------+   :     :     | |   | '-->| H  | e  | l  | l  | o  |    :\n"
":                           :     :     | |   |     +----+----+----+----+----+    :\n"
"`- - - - - - - - - - - - - -'     :     | |   |                                   :\n"
"                                  :     | |   |     +-------------------------+   :\n"
"                                  :     | |   '---->| \"<str as Display>::fmt\" |   :\n"
"                                  :     | |         +-------------------------+   :\n"
"                                  :     | |                                       :\n"
"                                  :     | |   +----+----+----+----+               :\n"
"                                  :     | '-->| 7b | 00 | 00 | 00 |               :\n"
"                                  :     |     +----+----+----+----+               :\n"
"                                  :     |                                         :\n"
"                                  :     |     +-------------------------+         :\n"
"                                  :     '---->| \"<i32 as Display>::fmt\" |         :\n"
"                                  :           +-------------------------+         :\n"
"                                  :                                               :\n"
"                                  :                                               :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/generics/trait-objects.md:69
msgid ""
"Similarly, you need a trait object if you want to return different types\n"
"implementing a trait:"
msgstr "ë§ˆì°¬ê°€ì§€ë¡œ, ê°™ì€ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì˜ ê°’ì„ ë¦¬í„´í•  ë•Œì—ë„ íŠ¸ë ˆì‡ ê°ì²´ê°€ í•„ìš”í•©ë‹ˆë‹¤:"

#: src/generics/trait-objects.md:72
msgid ""
"```rust,editable\n"
"fn numbers(n: i32) -> Box<dyn Iterator<Item=i32>> {\n"
"    if n > 0 {\n"
"        Box::new(0..n)\n"
"    } else {\n"
"        Box::new((n..0).rev())\n"
"    }\n"
"}"
msgstr ""

#: src/generics/trait-objects.md:81
msgid ""
"fn main() {\n"
"    println!(\"{:?}\", numbers(-5).collect::<Vec<_>>());\n"
"    println!(\"{:?}\", numbers(5).collect::<Vec<_>>());\n"
"}"
msgstr ""

#: src/exercises/day-3/morning.md:1
msgid "# Day 3: Morning Exercises"
msgstr "# 3ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-3/morning.md:3
msgid "We will design a classical GUI library traits and trait objects."
msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œì—ì„œëŠ” íŠ¸ë ˆì‡ì™€ íŠ¸ë ˆì‡ ê°ì²´ë¥¼ í†µí•´ ê³ ì „ì ì¸ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ê³„í•  ê²ƒì…ë‹ˆë‹¤."

#: src/exercises/day-3/simple-gui.md:1
msgid "# A Simple GUI Library"
msgstr "# ê°„ë‹¨í•œ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/exercises/day-3/simple-gui.md:3
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and\n"
"trait objects."
msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œì—ì„œëŠ” íŠ¸ë ˆì‡ì™€ íŠ¸ë ˆì‡ ê°ì²´ì— ëŒ€í•´ ë°°ìš´ê²ƒì„ í™œìš©í•˜ì—¬ ê³ ì „ì ì¸ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ê³„í•  ê²ƒì…ë‹ˆë‹¤."

#: src/exercises/day-3/simple-gui.md:6
msgid "We will have a number of widgets in our library:"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” ëª‡ ê°€ì§€ ìœ„ì ¯ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/exercises/day-3/simple-gui.md:8
msgid ""
"* `Window`: has a `title` and contains other widgets.\n"
"* `Button`: has a `label` and a callback function which is invoked when the\n"
"  button is pressed.\n"
"* `Label`: has a `label`."
msgstr ""
"* `Window`: `title` ì†ì„±ì„ ê°€ì§€ê³  ìˆìœ¼ë©°, ë‹¤ë¥¸ ìœ„ì ¯ë“¤ì„ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `Button`: `label` ì†ì„±ì„ ê°€ì§€ê³  ìˆìœ¼ë©°, ë²„íŠ¼ì´ ëˆŒë ¸ì„ë•Œ ì‹¤í–‰ë˜ëŠ” ì½œë°± í•¨ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.\n"
"* `Label`: `label` ì†ì„±ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-3/simple-gui.md:13
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "ìœ„ì ¯ë“¤ì€ ëª¨ë‘ `Widget` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/exercises/day-3/simple-gui.md:15
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing\n"
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  ëˆ„ë½ëœ `draw_into`ë©”ì„œë“œë¥¼ ì±„ì›Œ ë„£ì–´ `Widget` íŠ¸ë ˆì‡ì„ ì™„ì„±í•´ë´…ì‹œë‹¤:"

#: src/exercises/day-3/simple-gui.md:18
#: src/exercises/day-3/safe-ffi-wrapper.md:25
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]"
msgstr ""

#: src/exercises/day-3/simple-gui.md:22
msgid ""
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""

#: src/exercises/day-3/simple-gui.md:26
#: src/exercises/day-3/solutions-morning.md:27
msgid ""
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);"
msgstr ""

#: src/exercises/day-3/simple-gui.md:29
#: src/exercises/day-3/solutions-morning.md:30
msgid ""
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:37
#: src/exercises/day-3/solutions-morning.md:38
msgid ""
"pub struct Label {\n"
"    label: String,\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:41
#: src/exercises/day-3/solutions-morning.md:42
msgid ""
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:49
#: src/exercises/day-3/solutions-morning.md:50
msgid ""
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:54
#: src/exercises/day-3/solutions-morning.md:55
msgid ""
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:63
#: src/exercises/day-3/solutions-morning.md:64
msgid ""
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:68
#: src/exercises/day-3/solutions-morning.md:69
msgid ""
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:76
#: src/exercises/day-3/solutions-morning.md:77
msgid ""
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:82
msgid ""
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:87 src/exercises/day-3/simple-gui.md:97
#: src/exercises/day-3/simple-gui.md:107
msgid ""
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/simple-gui.md:92
msgid ""
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:102
msgid ""
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }"
msgstr ""

#: src/exercises/day-3/simple-gui.md:112
msgid ""
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:123
msgid "The output of the above program can be something simple like this:"
msgstr "ìœ„ í”„ë¡œê·¸ë¨ì˜ ì¶œë ¥ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/exercises/day-3/simple-gui.md:125
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
msgid "This is a small text GUI demo."
msgstr ""

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"| Click me! |\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:135
msgid ""
"If you want to draw aligned text, you can use the\n"
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)\n"
"formatting operators. In particular, notice how you can pad with different\n"
"characters (here a `'/'`) and how you can control alignment:"
msgstr "í…ìŠ¤íŠ¸ë¥¼ ì¤„ë§ì¶¤ í•´ì„œ ê·¸ë¦¬ë ¤ë©´ [fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment)ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. íŠ¹ìˆ˜ ë¬¸ì(ì—¬ê¸°ì„œëŠ” '/')ë¡œ íŒ¨ë”©ì„ ì£¼ëŠ” ë°©ë²•ê³¼ ì •ë ¬ì„ ì œì–´í•˜ëŠ” ë°©ë²•ì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/exercises/day-3/simple-gui.md:140
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:149
msgid "Using such alignment tricks, you can for example produce output like this:"
msgstr "ìœ„ì˜ ì •ë ¬ íŠ¸ë¦­ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/exercises/day-3/simple-gui.md:151
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/error-handling.md:1
msgid "# Error Handling"
msgstr "# ì˜¤ë¥˜ì²˜ë¦¬"

#: src/error-handling.md:3
msgid "Error handling in Rust is done using explicit control flow:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì˜¤ë¥˜ëŠ” ëª…ì‹œì ì¸ íë¦„ì„ ë”°ë¼ ì²˜ë¦¬ê°€ ë©ë‹ˆë‹¤:"

#: src/error-handling.md:5
msgid ""
"* Functions that can have errors list this in their return type,\n"
"* There are no exceptions."
msgstr ""
"* ì˜¤ë¥˜ë¥¼ ë°œìƒí•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ëŠ” ë°˜í™˜ íƒ€ì…ì— ì´ë¥¼ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.\n"
"* ì˜ˆì™¸(exception) ê¸°ëŠ¥ì€ ì—†ìŠµë‹ˆë‹¤."

#: src/error-handling/panics.md:1
msgid "# Panics"
msgstr "# íŒ¨ë‹‰"

#: src/error-handling/panics.md:3
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ìˆ˜í–‰ ì¤‘ ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ë¥¼ ë§Œë‚˜ë©´ íŒ¨ë‹‰ì„ ë°œìƒí•  ê²ƒì…ë‹ˆë‹¤:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panics.md:12
msgid ""
"* Panics are for unrecoverable and unexpected errors.\n"
"  * Panics are symptoms of bugs in the program.\n"
"* Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"* íŒ¨ë‹‰ì€ ë³µêµ¬í•  ìˆ˜ ì—†ê³  ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ì…ë‹ˆë‹¤.\n"
"  * íŒ¨ë‹‰ì€ í”„ë¡œê·¸ë¨ì— ë²„ê·¸ê°€ ìˆë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\n"
"* ì¶©ëŒ(í¬ë˜ì‹œ)ë¥¼ í—ˆìš©í•˜ì§€ ì•Šì•„ì•¼ í•˜ëŠ” ê²½ìš°, íŒ¨ë‹‰ì„ ìœ ë°œí•˜ì§€ ì•ŠëŠ” API(`Vec::get`ë“±)ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/error-handling/panic-unwind.md:1
msgid "# Catching the Stack Unwinding"
msgstr "# ìŠ¤íƒ ë˜ê°ê¸°"

#: src/error-handling/panic-unwind.md:3
msgid "By default, a panic will cause the stack to unwind. The unwinding can be caught:"
msgstr "ê¸°ë³¸ì ìœ¼ë¡œ, íŒ¨ë‹‰ì´ ë°œìƒí•˜ë©´ ìŠ¤íƒ ë˜ê°ê¸°ë¥¼ í•©ë‹ˆë‹¤. ìŠ¤íƒ ë˜ê°ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ìºì¹˜ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust\n"
"use std::panic;"
msgstr ""

#: src/error-handling/panic-unwind.md:8
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    println!(\"hello!\");\n"
"});\n"
"assert!(result.is_ok());"
msgstr ""

#: src/error-handling/panic-unwind.md:13
msgid ""
"let result = panic::catch_unwind(|| {\n"
"    panic!(\"oh no!\");\n"
"});\n"
"assert!(result.is_err());\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:19
msgid ""
"* This can be useful in servers which should keep running even if a single\n"
"  request crashes.\n"
"* This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"* ì´ê²ƒì€ ë‹¨ì¼ ìš”ì²­ì´ í¬ë˜ì‹œ ë˜ë”ë¼ë„ í”„ë¡œê·¸ë¨ì´ ê³„ì† ì‹¤í–‰ë˜ì•¼ í•˜ëŠ” ì„œë²„ì— ìœ ìš©í•©ë‹ˆë‹¤.\n"
"* ë§Œì•½ `Cargo.toml`ì„¤ì •íŒŒì¼ì— `panic = abort`ì„ ì„¤ì •í–ˆë‹¤ë©´ í¬ë˜ì‹œë¥¼ ìºì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/error-handling/result.md:1
msgid "# Structured Error Handling with `Result`"
msgstr "# `Result`ë¥¼ ì´ìš©í•œ êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ì²˜ë¦¬"

#: src/error-handling/result.md:3
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors are\n"
"expected as part of normal operation:"
msgstr "ì—¬ëŸ¬ë¶„ì€ ì´ë¯¸ `Result` ì—´ê±°í˜•ì„ ëª‡ ë²ˆ ë´¤ìŠµë‹ˆë‹¤. ì´ íƒ€ì…ì€ í”„ë¡œê·¸ë¨ì˜ ì •ìƒì ì¸ ìˆ˜í–‰ ì¤‘ì— ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜¤ë¥˜ê°’ë“¤ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤:"

#: src/error-handling/result.md:6
msgid ""
"```rust\n"
"use std::fs::File;\n"
"use std::io::Read;"
msgstr ""

#: src/error-handling/result.md:10
msgid ""
"fn main() {\n"
"    let file = File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
msgid ""
"  * As with `Option`, the successful value sits inside of `Result`, forcing the developer to\n"
"    explicitly extract it. This encourages error checking. In the case where an error should never happen,\n"
"    `unwrap()` or `expect()` can be called, and this is a signal of the developer intent too.  \n"
"  * `Result` documentation is a recommended read. Not during the course, but it is worth mentioning. \n"
"    It contains a lot of convenience methods and functions that help functional-style programming. \n"
"    \n"
"</details>"
msgstr ""
"  * `Option`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ, ì„±ê³µí•œ ê²½ìš°ì˜ ê°’ì€ `Result` ë‚´ë¶€ì— ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ, ê°œë°œìëŠ” ëª…ì‹œì ìœ¼ë¡œ ì´ë¥¼ ì¶”ì¶œí•˜ì—¬ì•¼ í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•¨ìœ¼ë¡œì¨ ê°’ì„ ì½ê¸° ì „ì— ì˜¤ë¥˜ ë°œìƒ ì—¬ë¶€ë¥¼ ë°˜ë“œì‹œ ì²´í¬í•˜ë„ë¡ ìœ ë„í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë§Œì¼ ì˜¤ë¥˜ê°€ ì ˆëŒ€ ë°œìƒí•˜ì§€ ì•ŠëŠ” ê²½ìš°ë¼ë©´ `unwrap()`ì´ë‚˜ `expect()`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ê°œë°œìì˜ ì˜ë„(_ì—­ì£¼_: ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ì—†ìŒ)ì„ ëª…ì‹œì ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•ì´ê¸°ë„ í•©ë‹ˆë‹¤.\n"
"  * ìˆ˜ì—…ì¤‘ì—” ì•„ë‹ˆì§€ë§Œ `Result`ì˜ API ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì½ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ìŠ¤íƒ€ì¼ì— ë„ì›€ì´ ë˜ëŠ” í¸ë¦¬í•œ ë©”ì„œë“œì™€ í•¨ìˆ˜ë¥¼ ë§ì´ ë°°ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/error-handling/try-operator.md:1
msgid "# Propagating Errors with `?`"
msgstr "# '?'ë¥¼ ì´ìš©í•œ ì˜¤ë¥˜ ì „íŒŒ"

#: src/error-handling/try-operator.md:3
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you turn\n"
"the common"
msgstr "ì—°ì‚°ì `?`ëŠ” í˜¸ì¶œìì—ê²Œ ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ì´ëŸ° ì½”ë“œë¥¼"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:13
msgid "into the much simpler"
msgstr "ì´ë ‡ê²Œ ì§§ê²Œ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:19
msgid "We can use this to simplify our error handing code:"
msgstr "ì´ì œ ìš°ë¦¬ ì˜ˆì œì— ì ìš©í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::{self, Read};"
msgstr ""

#: src/error-handling/try-operator.md:25
msgid ""
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);"
msgstr ""

#: src/error-handling/try-operator.md:28
msgid ""
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(e) => return Err(e),\n"
"    };"
msgstr ""

#: src/error-handling/try-operator.md:33
msgid "    let mut username = String::new();"
msgstr ""

#: src/error-handling/try-operator.md:35
msgid ""
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(e) => Err(e),\n"
"    }\n"
"}"
msgstr ""

#: src/error-handling/try-operator.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:52
#: src/error-handling/converting-error-types-example.md:52
msgid ""
"* The `username` variable can be either `Ok(string)` or `Err(error)`.\n"
"* Use the `fs::write` call to test out the different scenarios: no file, empty file, file with username."
msgstr ""
"* `username` ë³€ìˆ˜ëŠ” `Ok(string)`ì´ê±°ë‚˜ `Err(error)`ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* `fs::write` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ íŒŒì¼ì´ ì—†ê±°ë‚˜, ë¹„ì—ˆê±°ë‚˜, ì¤‘ë³µë˜ëŠ” ê²½ìš° ë“±ì„ í…ŒìŠ¤íŠ¸í•´ ë´…ë‹ˆë‹¤."

#: src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
msgid "# Converting Error Types"
msgstr "# ì—ëŸ¬ íƒ€ì…ì´ ë‹¤ë¥¼ ê²½ìš°"

#: src/error-handling/converting-error-types.md:3
msgid "The effective expansion of `?` is a little more complicated than previously indicated:"
msgstr "ì‹¤ì œë¡œ `?`ê°€ ì ìš©ë˜ëŠ” ê³¼ì •ì€ ì•„ê¹Œ ì„¤ëª…í•œ ê²ƒ ë³´ë‹¤ ì¢€ ë” ë³µì¡í•©ë‹ˆë‹¤:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:9
msgid "works the same as"
msgstr "ìœ„ í‘œí˜„ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:18
msgid ""
"The `From::from` call here means we attempt to convert the error type to the\n"
"type returned by the function:"
msgstr "`From::from`ì„ í†µí•´ ì›ë˜ì˜ ì—ëŸ¬ íƒ€ì…ì„ ì´ í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ê³  ìˆìŠµë‹ˆë‹¤:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};"
msgstr ""

#: src/error-handling/converting-error-types-example.md:9
msgid ""
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:15
msgid "impl Error for ReadUsernameError {}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:17
msgid ""
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {}\", e),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username in {}\", filename),\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:26
msgid ""
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:32
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/converting-error-types-example.md:41
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types-example.md:55
msgid ""
"It is good practice for all error types to implement `std::error::Error`, which requires `Debug` and\n"
"`Display`. It's generally helpful for them to implement `Clone` and `Eq` too where possible, to make\n"
"life easier for tests and consumers of your library. In this case we can't easily do so, because\n"
"`io::Error` doesn't implement them."
msgstr "ì—ëŸ¬ íƒ€ì…ì´ `std::error::Error`ë¥¼ êµ¬í˜„í•˜ë„ë¡ í•˜ëŠ” ê²ƒì€ ì¢‹ì€ ìŠµê´€ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ `Debug`ì™€ `Display` íŠ¸ë ˆì‡ ë˜í•œ êµ¬í˜„ì„ í•´ì•¼ í•©ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë‹¤ë©´ `Clone`ê³¼ `Eq` íŠ¸ë ˆì‡ë„ êµ¬í˜„í•˜ë„ë¡ í•˜ì„¸ìš”. ì—¬ëŸ¬ë¶„ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í…ŒìŠ¤íŠ¸ í•˜ê¸° ì‰¬ì›Œì§€ê³ , ì‚¬ìš©í•˜ê¸° ì¢‹ì•„ì§ˆ ê²ë‹ˆë‹¤. ë‹¤ë§Œ, ì´ ì˜ˆì œì—ì„œëŠ” ê·¸ë ‡ê²Œ í•˜ê¸° í˜ë“­ë‹ˆë‹¤. ì™œëƒí•˜ë©´ `io::Error`ëŠ” ì´ íŠ¸ë ˆì‡ë“¤ì„ êµ¬í˜„í•˜ê³  ìˆì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/error-handling/deriving-error-enums.md:1
msgid "# Deriving Error Enums"
msgstr "# ë˜ë‹¤ë¥¸ ì˜¤ë¥˜ ì—´ê±°í˜•"

#: src/error-handling/deriving-error-enums.md:3
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create an\n"
"error enum like we did on the previous page:"
msgstr "[thiserror](https://docs.rs/thiserror/)ëŠ”, ì´ì „ í˜ì´ì§€ì—ì„œ ë³´ì•˜ë˜ ê²ƒê³¼ ê°™ì€ ì—ëŸ¬ ì—´ê±°í˜•ì„ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” ìœ ëª…í•œ í¬ë ˆì´íŠ¸ ì…ë‹ˆë‹¤:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;"
msgstr ""

#: src/error-handling/deriving-error-enums.md:11
msgid ""
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}"
msgstr ""

#: src/error-handling/deriving-error-enums.md:19
msgid ""
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/deriving-error-enums.md:28
#: src/error-handling/dynamic-errors.md:25
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and optionally `Display`\n"
"(if the `#[error(...)]` attributes are provided) and `From` (if the `#[from]` attribute is added).\n"
"It also works for structs."
msgstr "`thiserror`ì˜ derive ë§¤í¬ë¡œë¥¼ ì´ìš©í•˜ë©´ `std::error::Error`ê³¼ `Display`(ë§Œì•½ `#[error(...)]` ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì¶”ê°€í–ˆì„ ê²½ìš°), `From`(ë§Œì•½ `#[from]` ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì¶”ê°€í–ˆì„ ê²½ìš°) íŠ¸ë ˆì‡ë“¤ì´ ìë™ìœ¼ë¡œ êµ¬í˜„ì´ ë©ë‹ˆë‹¤. êµ¬ì¡°ì²´ì— ëŒ€í•´ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/error-handling/deriving-error-enums.md:43
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr "ì´ ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•´ë„ ë°–ìœ¼ë¡œ ë…¸ì¶œë˜ëŠ” APIê°€ ë³€ê²½ë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“¤ ê²½ìš°ì—ëŠ” ì´ê²Œ ì¤‘ìš”í•˜ì£ ."

#: src/error-handling/dynamic-errors.md:1
msgid "# Dynamic Error Types"
msgstr "# ë™ì ì¸ ì—ëŸ¬ íƒ€ì…"

#: src/error-handling/dynamic-errors.md:3
msgid ""
"Sometimes we want to allow any type of error to be returned without writing our own enum covering\n"
"all the different possibilities. `std::error::Error` makes this easy."
msgstr "ë•Œë•Œë¡œ ìš°ë¦¬ëŠ”, ë°œìƒ ê°€ëŠ¥í•œ ëª¨ë“  ì—ëŸ¬ë¥¼ ì¼ì¼íˆ ì—´ê±°í•˜ì§€ ì•Šê³ , ì–´ë–¤ ì¢…ë¥˜ì˜ ì—ëŸ¬ë¼ë„ ìƒê´€ì—†ì´ ë¦¬í„´í•˜ê³  ì‹¶ì„ ë•Œê°€ ìˆìŠµë‹ˆë‹¤. `std::error::Error`ë¥¼ ì´ìš©í•˜ë©´ ì‰½ìŠµë‹ˆë‹¤."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs::{self, File};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;"
msgstr ""

#: src/error-handling/dynamic-errors.md:12
msgid ""
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);"
msgstr ""

#: src/error-handling/dynamic-errors.md:16
msgid ""
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
msgid ""
"This saves on code, but gives up the ability to cleanly handle different error cases differently in\n"
"the program. As such it's generally not a good idea to use `Box<dyn Error>` in the public API of a\n"
"library, but it can be a good option in a program where you just want to display the error message\n"
"somewhere."
msgstr "ì´ë ‡ê²Œ í•˜ë©´ ì½”ë“œì˜ ì–‘ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì„œë¡œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì—ëŸ¬ë¥¼ êµ¬ë³„í•˜ì—¬ ë‹¤ë¥´ê²Œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•´ ì§‘ë‹ˆë‹¤. ë•Œë¬¸ì—, `Box<dyn Error>`ë¥¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ APIë¡œ ë…¸ì¶œí•˜ëŠ”ê²Œ ì¢‹ì€ ë””ìì¸ì€ ì•„ë‹™ë‹ˆë‹¤. ì—ëŸ¬ ë°œìƒì‹œ, ê·¸ì € ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê³  ì‹¶ì€ ê²½ìš°ì™€ ê°™ì´ ì œí•œëœ ìƒí™©ì—ì„œëŠ” ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/error-contexts.md:1
msgid "# Adding Context to Errors"
msgstr "# ì˜¤ë¥˜ì— ë¬¸ë§¥ ì¶”ê°€"

#: src/error-handling/error-contexts.md:3
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add\n"
"contextual information to your errors and allows you to have fewer\n"
"custom error types:"
msgstr "[anyhow](https://docs.rs/anyhow/) í¬ë ˆì´íŠ¸ëŠ” ì—ëŸ¬ì— ì—ëŸ¬ê°€ ë°œìƒí•œ ë¬¸ë§¥ì— ëŒ€í•œ ì •ë³´ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´ ë„ë¦¬ ì‚¬ìš©ë˜ë©°, ì´ë¥¼ ì´ìš©í•˜ë©´ ì„œë¡œ ë‹¤ë¥¸ ë¬¸ë§¥ì„ ë‚˜íƒ€ë‚´ê¸° ì‚¬ìš©ì ì •ì˜ ì˜¤ë¥˜ íƒ€ì…ì„ ë§ì´ ë§Œë“¤ì–´ì•¼ í•˜ëŠ” ë¶ˆí¸í•¨ì„ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};"
msgstr ""

#: src/error-handling/error-contexts.md:12
msgid ""
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .context(format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}"
msgstr ""

#: src/error-handling/error-contexts.md:24
msgid ""
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
msgid ""
"* `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.\n"
"* `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such it's again generally not\n"
"  a good choice for the public API of a library, but is widely used in applications.\n"
"* Actual error type inside of it can be extracted for examination if necessary.\n"
"* Functionality provided by `anyhow::Result<T>` may be familiar to Go developers, as it provides\n"
"  similar usage patterns and ergonomics to `(T, error)` from Go."
msgstr ""

#: src/testing.md:1
msgid "# Testing"
msgstr "# í…ŒìŠ¤íŒ…"

#: src/testing.md:3
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì™€ ì¹´ê³ (cargo)ëŠ” ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ì™€ í•¨ê»˜ ì œê³µë©ë‹ˆë‹¤:"

#: src/testing.md:5
msgid "* Unit tests are supported throughout your code."
msgstr "* ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì½”ë“œ ì „ë°˜ì—ì„œ ì§€ì›ë©ë‹ˆë‹¤."

#: src/testing.md:7
msgid "* Integration tests are supported via the `tests/` directory."
msgstr "* í†µí•©í…ŒìŠ¤íŠ¸ëŠ” `test/` ë””ë ‰í„°ë¦¬ë¥¼ í†µí•´ ì§€ì›ë©ë‹ˆë‹¤."

#: src/testing/unit-tests.md:1
msgid "# Unit Tests"
msgstr "# ë‹¨ìœ„ í…ŒìŠ¤íŠ¸"

#: src/testing/unit-tests.md:3
msgid "Mark unit tests with `#[test]`:"
msgstr "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” `#[test]` ë¡œ í‘œì‹œí•©ë‹ˆë‹¤:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:13
msgid ""
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:18
msgid ""
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}"
msgstr ""

#: src/testing/unit-tests.md:23
msgid ""
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
msgid "Use `cargo test` to find and run the unit tests."
msgstr "`cargo test` ì»¤ë§¨ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì°¾ì•„ì„œ ì‹¤í–‰í•©ë‹ˆë‹¤."

#: src/testing/test-modules.md:1
msgid "# Test Modules"
msgstr "# í…ŒìŠ¤íŠ¸ ëª¨ë“ˆ"

#: src/testing/test-modules.md:3
msgid ""
"Unit tests are often put in a nested module (run tests on the\n"
"[Playground](https://play.rust-lang.org/)):"
msgstr "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì›ë˜ ëª¨ë“ˆ ë°‘ì— ì„œë¸Œ ëª¨ë“ˆë¡œ ë§Œë“œëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤. ([í”Œë ˆì´ê·¸ë¼ìš´ë“œ](https://play.rust-lang.org/)ì—ì„œ ë‹¤ìŒ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•´ ë³´ì„¸ìš”):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}"
msgstr ""

#: src/testing/test-modules.md:11
msgid ""
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}"
msgstr ""

#: src/testing/test-modules.md:19
msgid ""
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
msgid ""
"* This lets you unit test private helpers.\n"
"* The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"* ì´ë ‡ê²Œ ì„œë¸Œ ëª¨ë“ˆë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“¤ë©´ privateí•œ í—¬í¼ í•¨ìˆ˜ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
"* `#[cfg(test)]` ì–´íŠ¸ë¦¬ë·°íŠ¸ê°€ ì¶”ê°€ëœ í•­ëª©ì€ `cargo test`ë¥¼ ìˆ˜í–‰í–ˆì„ ê²½ìš°ì—ë§Œ ë™ì‘í•©ë‹ˆë‹¤."

#: src/testing/doc-tests.md:1
msgid "# Documentation Tests"
msgstr "ë¬¸ì„œí™”ì£¼ì„ í…ŒìŠ¤íŠ¸"

#: src/testing/doc-tests.md:3
msgid "Rust has built-in support for documentation tests:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë¬¸ì„œí™”ì£¼ì„ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ë¥¼ ë‚´ì¥í•˜ì—¬ ì œê³µí•©ë‹ˆë‹¤:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
msgid ""
"* Code blocks in `///` comments are automatically seen as Rust code.\n"
"* The code will be compiled and executed as part of `cargo test`.\n"
"* Test the above code on the [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"* `///` ì£¼ì„ì•ˆì˜ ì½”ë“œ ë¸”ë¡ì€ ìë™ìœ¼ë¡œ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œë¡œ ì¸ì‹ë©ë‹ˆë‹¤.\n"
"* ì´ ì½”ë“œ ë¸”ë¡ì€ `cargo test` í˜¸ì¶œí•˜ë©´ ìë™ìœ¼ë¡œ ì»´íŒŒì¼ë˜ê³  ì‹¤í–‰ë©ë‹ˆë‹¤.\n"
"* ìœ„ ì½”ë“œë¥¼ [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)ì—ì„œ í…ŒìŠ¤íŠ¸ í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/testing/integration-tests.md:1
msgid "# Integration Tests"
msgstr "# í†µí•© í…ŒìŠ¤íŠ¸"

#: src/testing/integration-tests.md:3
msgid "If you want to test your library as a client, use an integration test."
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©ì ì…ì¥ì—ì„œ í…ŒìŠ¤íŠ¸ í•˜ë ¤ë©´, í†µí•© í…ŒìŠ¤íŠ¸ë¥¼ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/testing/integration-tests.md:5
msgid "Create a `.rs` file under `tests/`:"
msgstr "`test/`ë””ë ‰í„°ë¦¬ ì•„ë˜ì— `.rs`íŒŒì¼ì„ í•˜ë‚˜ ë§Œë“œì„¸ìš”:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;"
msgstr ""

#: src/testing/integration-tests.md:10
msgid ""
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
msgid "These tests only have access to the public API of your crate."
msgstr "ì´ í…ŒìŠ¤íŠ¸ëŠ” í¬ë ˆì´íŠ¸ì˜ ê³µê°œ APIì—ë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsafe.md:1
msgid "# Unsafe Rust"
msgstr "# ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸"

#: src/unsafe.md:3
msgid "The Rust language has two parts:"
msgstr "ëŸ¬ìŠ¤íŠ¸ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì€ í¬ê²Œ ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰©ë‹ˆë‹¤:"

#: src/unsafe.md:5
msgid ""
"* **Safe Rust:** memory safe, no undefined behavior possible.\n"
"* **Unsafe Rust:** can trigger undefined behavior if preconditions are violated."
msgstr ""
"* **ì•ˆì „í•œ ëŸ¬ìŠ¤íŠ¸:** ë©”ëª¨ë¦¬ ê´€ë ¨ ì˜¤ë¥˜ ë°œìƒ ë¶ˆê°€ëŠ¥, ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ ì—†ìŒ.\n"
"* **ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸:** íŠ¹ë³„í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šì€ì±„ë¡œ ì‚¬ìš©ë˜ë©´ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ ìœ ë°œí•  ìˆ˜ ìˆìŒ."

#: src/unsafe.md:8
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to know\n"
"what Unsafe Rust is."
msgstr "ì´ ê°•ì˜ëŠ” ëŒ€ë¶€ë¶„ ì•ˆì „í•œ ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•´ ë‹¤ë£¨ì§€ë§Œ ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ê°€ ë¬´ì—‡ì¸ì§€ëŠ” ì•Œì•„ ë‘ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe.md:11
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be carefully\n"
"documented. It is usually wrapped in a safe abstraction layer."
msgstr "ë³´í†µ, ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œëŠ” í¬ê¸°ê°€ ì‘ìœ¼ë©°, ë…ë¦½ì ìœ¼ë¡œ ì¡´ì¬í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì½”ë“œê°€ ì™œ ì˜ ì‘ë™í•˜ëŠ”ì§€ì— ëŒ€í•´ ì„¸ë°€í•˜ê²Œ ë¬¸ì„œí™”ê°€ ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³ , ë§ì€ ê²½ìš° ì•ˆì „í•œ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µí•´ì„œ ì¶”ìƒí™”ë¥¼ ì‹œí‚¨ í›„ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/unsafe.md:14
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ë‹¤ì„¯ ê°€ì§€ ê²ƒë“¤ì´ ê°€ëŠ¥í•´ ì§‘ë‹ˆë‹¤:"

#: src/unsafe.md:16
msgid ""
"* Dereference raw pointers.\n"
"* Access or modify mutable static variables.\n"
"* Access `union` fields.\n"
"* Call `unsafe` functions, including `extern` functions.\n"
"* Implement `unsafe` traits."
msgstr ""
"* ì›ì‹œ í¬ì¸í„° ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)\n"
"* ì •ì  ê°€ë³€ë³€ìˆ˜ ì ‘ê·¼ ë° ìˆ˜ì •\n"
"* `union` í•„ë“œ ì ‘ê·¼\n"
"* `extern` í•¨ìˆ˜ë¥¼ í¬í•¨í•œ `unsafe` í•¨ìˆ˜ í˜¸ì¶œ\n"
"* `unsafe` íŠ¸ë ˆì‡ êµ¬í˜„."

#: src/unsafe.md:22
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see\n"
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)\n"
"and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr "ìœ„ ê¸°ëŠ¥ë“¤ì— ëŒ€í•´ ê°„ëµíˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´, 19.1ì ˆ](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)ê³¼ [Rustonomicon](https://doc.rust-lang.org/nomicon/)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/unsafe.md:28
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers have\n"
"turned off the compiler safety features and have to write correct code by\n"
"themselves. It means the compiler no longer enforces Rust's memory-safety rules."
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ë¼ê³  í•´ì„œ ì½”ë“œê°€ ë¶€ì •í™• í•˜ë‹¤ëŠ” ëœ»ì€ ì•„ë‹™ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì•ˆì „í•˜ì§€ ì•Šë‹¤ì˜ ì˜ë¯¸ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ì œê³µí•´ì£¼ëŠ” ì•ˆì „ ì¥ì¹˜ë“¤ì´ êº¼ì§„ ìƒíƒœì´ë©°, ê°œë°œìê°€ ìŠ¤ìŠ¤ë¡œ ì •í™•í•˜ê³  ì•ˆì „í•œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë” ì´ìƒ ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ì•ˆì „ê³¼ ê´€ë ¨ëœ ê·œì¹™ë“¤ì„ ì ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/unsafe/raw-pointers.md:1
msgid "# Dereferencing Raw Pointers"
msgstr "# ì›ì‹œ í¬ì¸í„° ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)"

#: src/unsafe/raw-pointers.md:3
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "í¬ì¸í„°ë¥¼ ë§Œë“œëŠ” ê²ƒì€ ì•ˆì „í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)í•  ê²½ìš° `unsafe`ê°€ í•„ìš”í•©ë‹ˆë‹¤:"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;"
msgstr ""

#: src/unsafe/raw-pointers.md:9
msgid ""
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = &num as *const i32;"
msgstr ""

#: src/unsafe/raw-pointers.md:12
msgid ""
"    // Safe because r1 and r2 were obtained from references and so are guaranteed to be non-null and\n"
"    // properly aligned, the objects underlying the references from which they were obtained are\n"
"    // live throughout the whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"    // ì•„ë˜ ì½”ë“œëŠ” ì•ˆì „í•©ë‹ˆë‹¤. r1ê³¼ r2ëŠ” ì°¸ì¡°ë¡œ ë¶€í„° ë§Œë“¤ì–´ ì¡Œê¸° ë•Œë¬¸ì— nullì´ ì•„ë‹ˆë©° alignì´ ë§ë‹¤ëŠ” ê²ƒì´ ë³´ì¥ë©ë‹ˆë‹¤.\n"
"    // ì°¸ì¡°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°ì²´ë“¤ì€ unsafe ë¸”ëŸ­ì´ ìˆ˜í–‰ë˜ëŠ” ë™ì•ˆ ë©”ëª¨ë¦¬ì— ì‚´ì•„ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì´ ê°ì²´ë“¤ì€ r1ê³¼ r2ê°€ ì•„ë‹Œ ë‹¤ë¥¸\n"
"    // ì–´ë–¤ ì°¸ì¡°ë‚˜ í¬ì¸í„°ë¡œë„ ì ‘ê·¼ì´ ì•ˆë˜ê³  ìˆìŠµë‹ˆë‹¤.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe/raw-pointers.md:26
msgid ""
"It is good practice (and required by the Android Rust style guide) to write a comment for each\n"
"`unsafe` block explaining how the code inside it satisfies the safety requirements of the unsafe\n"
"operations it is doing."
msgstr "ëª¨ë“  `unsafe` ë¸”ëŸ­ì— ëŒ€í•´ ì™œ ê·¸ ì½”ë“œê°€ ì•ˆì „í•œì§€ì— ëŒ€í•œ ì„¤ëª…ì„ ì£¼ì„ìœ¼ë¡œ ë‹¤ëŠ” ê²ƒì€ ì¢‹ì€ ìŠµê´€ì…ë‹ˆë‹¤(ì‚¬ì‹¤ ì•ˆë“œë¡œì´ë“œì˜ ëŸ¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ê°€ì´ë“œì—ì„œëŠ” ì´ê²Œ í•„ìˆ˜ì…ë‹ˆë‹¤)."

#: src/unsafe/raw-pointers.md:30
msgid ""
"In the case of pointer dereferences, this means that the pointers must be\n"
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr "í¬ì¸í„° ì—­ì°¸ì¡°ë¥¼ í•  ê²½ìš°, í¬ì¸í„°ê°€ [_ìœ íš¨_](https://doc.rust-lang.org/std/ptr/index.html#safety)í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:"

#: src/unsafe/raw-pointers.md:33
msgid ""
" * The pointer must be non-null.\n"
" * The pointer must be _dereferenceable_ (within the bounds of a single allocated object).\n"
" * The object must not have been deallocated.\n"
" * There must not be concurrent accesses to the same location.\n"
" * If the pointer was obtained by casting a reference, the underlying object must be live and no\n"
"   reference may be used to access the memory."
msgstr ""
" * í¬ì¸í„°ëŠ” nullì´ë©´ ì•ˆë©ë‹ˆë‹¤.\n"
" * í¬ì¸í„°ëŠ” ë”°ë¼ê°€ê¸°ê°€ ê°€ëŠ¥í•´ì•¼ í•©ë‹ˆë‹¤ (ê°ì²´ì˜ ì–´ëŠ í•œ ë¶€ë¶„ì„ ê°€ë¦¬í‚¤ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤).\n"
" * ì´ë¯¸ ë°˜í™˜ëœ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ë©´ ì•ˆë©ë‹ˆë‹¤.\n"
" * ê°™ì€ ìœ„ì¹˜ì— ëŒ€í•´ ë™ì‹œì ì¸ ì ‘ê·¼ì´ ìˆìœ¼ë©´ ì•ˆë©ë‹ˆë‹¤.\n"
" * ì°¸ì¡°ë¥¼ ìºìŠ¤íŒ… í•´ì„œ í¬ì¸í„°ë¥¼ ë§Œë“¤ì—ˆë‹¤ë©´, ê·¸ ì°¸ì¡°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°ì²´ëŠ” ì‚´ì•„ ìˆì–´ì•¼ í•˜ë©°, ê·¸ ê°ì²´ì˜ ë©”ëª¨ë¦¬ë¥¼ ì ‘ê·¼í•˜ëŠ” ì°¸ì¡°ê°€ í•˜ë‚˜ë„ ì—†ì–´í– í•©ë‹ˆë‹¤."

#: src/unsafe/raw-pointers.md:40
msgid "In most cases the pointer must also be properly aligned."
msgstr "ëŒ€ë¶€ë¶„ì˜ ê²½ìš° í¬ì¸í„°ëŠ” alignë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe/mutable-static-variables.md:1
msgid "# Mutable Static Variables"
msgstr "# ì •ì  ê°€ë³€ ë³€ìˆ˜"

#: src/unsafe/mutable-static-variables.md:3
msgid "It is safe to read an immutable static variable:"
msgstr "ë¶ˆë³€ ì •ì ë³€ìˆ˜ë¥¼ ì½ëŠ” ê²ƒì€ ì•ˆì „í•©ë‹ˆë‹¤:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";"
msgstr ""

#: src/unsafe/mutable-static-variables.md:8
msgid ""
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable\n"
"static variables:"
msgstr "í•˜ì§€ë§Œ, ë°ì´í„° ë ˆì´ìŠ¤ê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì •ì  ê°€ë³€ë³€ìˆ˜ë¥¼ ì½ê³  ì“°ëŠ” ê²ƒì€ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;"
msgstr ""

#: src/unsafe/mutable-static-variables.md:19
msgid ""
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}"
msgstr ""

#: src/unsafe/mutable-static-variables.md:23
msgid ""
"fn main() {\n"
"    add_to_counter(42);"
msgstr ""

#: src/unsafe/mutable-static-variables.md:26
msgid ""
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases where it might make sense\n"
"in low-level `no_std` code, such as implementing a heap allocator or working with some C APIs."
msgstr "ì¼ë°˜ì ìœ¼ë¡œ ì´ì•¼ê¸° í•´ì„œ, ì •ì  ê°€ë³€ ë³€ìˆ˜ë¥¼ ì“°ëŠ” ê²ƒì€ ì¢‹ì€ ì•„ì´ë””ì–´ê°€ ì•„ë‹™ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ `no_std`ì™€ ê°™ì€ ì €ìˆ˜ì¤€ ì½”ë”©ì„ í•  ê²½ìš°ì—ëŠ” í•„ìš”í•˜ê¸°ë„ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í™ í• ë‹¹ê¸°ë¥¼ êµ¬í˜„í•˜ê±°ë‚˜, C APIë¥¼ ì‚¬ìš©í•˜ëŠ” ê²Œ ê·¸ëŸ° ê²½ìš°ì…ë‹ˆë‹¤."

#: src/unsafe/unions.md:1
msgid "# Unions"
msgstr "# ìœ ë‹ˆì˜¨"

#: src/unsafe/unions.md:3
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "ìœ ë‹ˆì˜¨ íƒ€ì…ì€ ì—´ê±°í˜•(enum)ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ì–´ë–¤ í•„ë“œì— í•´ë‹¹í•˜ëŠ” ê°’ì„ ê°€ì§€ê³  ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í”„ë¡œê·¸ë˜ë¨¸ê°€ ìˆ˜ë™ìœ¼ë¡œ ì¶”ì í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}"
msgstr ""

#: src/unsafe/unions.md:12
msgid ""
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally needed\n"
"for interacting with C library APIs."
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ëŠ” ì—´ê±°í˜•ì´ ìˆê¸° ë•Œë¬¸ì— ìœ ë‹ˆì˜¨ì´ í•„ìš”í•œ ê²½ìš°ëŠ” ê·¹íˆ ë“œë­…ë‹ˆë‹¤. ìœ ë‹ˆì˜¨ì€ C ë¼ì´ë¸ŒëŸ¬ë¦¬ APIë¥¼ ì‚¬ìš©í•  ë•Œ ê°€ë” í•„ìš”í•©ë‹ˆë‹¤."

#: src/unsafe/unions.md:24
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want\n"
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) or a safe\n"
"wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy) crate."
msgstr "ë°”ì´íŠ¸ë“¤ì„ íŠ¹ì • íƒ€ì…ìœ¼ë¡œ ì¬í•´ì„ í•˜ê³  ì‹¶ë‹¤ë©´ `std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html)ë‚˜ ì¢€ ë” ì•ˆì „í•œ [`zerocopy`](https://crates.io/crates/zerocopy) í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/unsafe/calling-unsafe-functions.md:1
msgid "# Calling Unsafe Functions"
msgstr "# ì•ˆì „í•˜ì§€ ì•Šì€' í•¨ìˆ˜ í˜¸ì¶œ"

#: src/unsafe/calling-unsafe-functions.md:3
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions you\n"
"must uphold to avoid undefined behaviour:"
msgstr "í•¨ìˆ˜ë‚˜ ë©”ì„œë“œê°€ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ìœ¼ë¡œ ë¹ ì§€ì§€ ì•Šê²Œ í•˜ê¸° ìœ„í•´ì„œ ë§Œì¡±í•´ì•¼ í•˜ëŠ” ì „ì œ ì¡°ê±´ì´ ìˆëŠ” ê²½ìš°, ê·¸ í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ `unsafe`ë¡œ í‘œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"ğŸ—»âˆˆğŸŒ\";"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:10
msgid ""
"    // Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }"
msgstr ""
"    // ì¸ë±ìŠ¤ë“¤ì´ ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ìˆìœ¼ë©°, ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì˜ ë²”ìœ„ ì•ˆì— ìˆê³ , UTF-8 ì‹œí€€ìŠ¤ì˜ ë²”ìœ„ ì•ˆì—\n"
"    // ìˆê¸° ë•Œë¬¸ì— ì•ˆì „í•©ë‹ˆë‹¤.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }"

#: src/unsafe/calling-unsafe-functions.md:18
msgid "    println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..7) }));"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:20
msgid ""
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis.get_unchecked(0..3) }));\n"
"}"
msgstr ""

#: src/unsafe/calling-unsafe-functions.md:25
msgid ""
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:1
msgid "# Writing Unsafe Functions"
msgstr "# 'ì•ˆì „í•˜ì§€ ì•Šì€' í•¨ìˆ˜ ì‘ì„±í•˜ê¸°"

#: src/unsafe/writing-unsafe-functions.md:3
msgid ""
"You can mark your own functions as `unsafe` if they require particular conditions to avoid undefined\n"
"behaviour."
msgstr "ì—¬ëŸ¬ë¶„ì´ ì‘ì„±í•œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ë•Œ ì–´ë–¤ íŠ¹ë³„í•œ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤ë©´, `unsafe`ë¡œ ë§ˆí‚¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:18
msgid ""
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:22
msgid ""
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:27
msgid ""
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
msgid "We wouldn't actually use pointers for this because it can be done safely with references."
msgstr "ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ ì•ˆì „í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì‹¤ì œë¡œ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤."

#: src/unsafe/writing-unsafe-functions.md:35
msgid ""
"Note that unsafe code is allowed within an unsafe function without an `unsafe` block. We can\n"
"prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see what happens."
msgstr "unsafe ì½”ë“œê°€ unsafe í•¨ìˆ˜ì˜ ë‚´ë¶€ì—ì„œ í˜¸ì¶œë  ê²½ìš°ì—ëŠ” `unsafe`ë¸”ëŸ­ì„ ì§€ì •í•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤. `unsafe`ë¸”ëŸ­ì„ í•­ìƒ ì§€ì •í•˜ë„ë¡ í•˜ê³  ì‹¶ë‹¤ë©´ `#[deny(unsafe_op_in_unsafe_fn)]`ë¥¼ ì´ìš©í•˜ì„¸ìš”. ì´ ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì¶”ê°€í•´ ë³´ê³  ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/unsafe/extern-functions.md:1
msgid "# Calling External Code"
msgstr "# ì™¸ë¶€ ì½”ë“œ í˜¸ì¶œ"

#: src/unsafe/extern-functions.md:3
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling\n"
"them is thus unsafe:"
msgstr "ë‹¤ë¥¸ ì–¸ì–´ì˜ í•¨ìˆ˜ëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ë³´ì¦ì„ ìœ„ë°˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì´ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ 'ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤':"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}"
msgstr ""

#: src/unsafe/extern-functions.md:11
msgid ""
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
msgid ""
"This is usually only a problem for extern functions which do things with pointers which might\n"
"violate Rust's memory model, but in general any C function might have undefined behaviour under any\n"
"arbitrary circumstances."
msgstr "ì´ê²Œ ë¬¸ì œê°€ ë˜ëŠ” ê²½ìš°ëŠ” ëŒ€ë¶€ë¶„ ì™¸ë¶€ í•¨ìˆ˜ê°€ ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ëª¨ë¸ì„ ìœ„ë°˜í•˜ê³  ìˆì„ ê²½ìš°ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì–´ë–¤ Cí•¨ìˆ˜ë¼ë„ ì–´ë–¤ ì„ì˜ì˜ ìƒí™©ì—ì„œëŠ” ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì—„ë°€íˆ ë§í•´ì„œëŠ” ëª¨ë“  ì™¸ë¶€ í•¨ìˆ˜ì— ëŒ€í•´ì„œ ë¬¸ì œì…ë‹ˆë‹¤."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI;\n"
"[other ABIs are available too](https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr "ìœ„ ì˜ˆì œ ì½”ë“œì—ì„œ `\"C\"`ëŠ” ABIë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. [ë‹¤ë¥¸ ABIë„ ìˆìŠµë‹ˆë‹¤.](https://doc.rust-lang.org/reference/items/external-blocks.html)"

#: src/unsafe/unsafe-traits.md:1
msgid "# Implementing Unsafe Traits"
msgstr "# ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°"

#: src/unsafe/unsafe-traits.md:3
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation must guarantee\n"
"particular conditions to avoid undefined behaviour."
msgstr "í•¨ìˆ˜ì—ì„œì™€ ë§ˆì°¬ê°€ì§€ë¡œ íŠ¸ë ˆì‡ë„ `unsafe`ë¡œ ë§ˆí‚¹ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë§Œì•½ ê·¸ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•  ë•Œ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ í”¼í•˜ê¸° ìœ„í•´ íŠ¹ë³„í•œ ì¡°ê±´ì´ í•„ìš”í•˜ë‹¤ë©´ ë§ì´ì§€ìš”."

#: src/unsafe/unsafe-traits.md:6
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks\n"
"[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ `zerocopy` í¬ë ˆì´íŠ¸ì—ëŠ” [ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html)ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/unsafe/unsafe-traits.md:9
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;"
msgstr ""

#: src/unsafe/unsafe-traits.md:13
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/unsafe/unsafe-traits.md:24
msgid ""
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""

#: src/unsafe/unsafe-traits.md:30
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining the requirements for\n"
"the trait to be safely implemented."
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ì„ ë§Œë“¤ ë•Œì—ëŠ” ì£¼ì„ì— `# Safety` í•­ëª©ì´ ìˆì–´ì„œ ì´ íŠ¸ë ˆì‡ì„ ì•ˆì „í•˜ê²Œ êµ¬í˜„í•˜ë ¤ë©´ ì–´ë–¤ ìš”êµ¬ì‚¬í•­ë“¤ì„ ë§Œì¡±í•´ì•¼ í•˜ëŠ”ì§€ë¥¼ ì„¤ëª…í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe/unsafe-traits.md:33
msgid "The actual safety section for `AsBytes` is rather longer and more complicated."
msgstr "`AsBytes`ì—ì„œ ì§€ì¼œì•¼ í•  ì•ˆì „ì„±ì— ëŒ€í•œ ì‹¤ì œ ì„¤ëª…ì€ ì¢€ ë” ê¸¸ê³  ë³µì¡í•©ë‹ˆë‹¤."

#: src/unsafe/unsafe-traits.md:35
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "ë¹ŒíŠ¸ì¸ íŠ¸ë ˆì‡ì¸ `Send`ì™€ `Sync`ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ ì…ë‹ˆë‹¤."

#: src/exercises/day-3/afternoon.md:1
msgid "# Day 3: Afternoon Exercises"
msgstr "# 3ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-3/afternoon.md:3
msgid "Let us build a safe wrapper for reading directory content!"
msgstr "ë””ë ‰í„°ë¦¬ì˜ ë‚´ìš©ì„ ì½ëŠ” ì•ˆì „í•œ ë˜í¼ ì½”ë“œë¥¼ ì‘ì„±í•´ ë´…ì‹œë‹¤!"

#: src/exercises/day-3/afternoon.md:7
msgid "After looking at the exercise, you can look at the [solution] provided."
msgstr "ì—°ìŠµë¬¸ì œë¥¼ ì‚´í´ ë³¸ í›„, ì œê³µëœ [solutions]ì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-3/afternoon.md:9
msgid "[solution]: solutions-afternoon.md"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:1
msgid "# Safe FFI Wrapper"
msgstr "# FFIë˜í¼"

#: src/exercises/day-3/safe-ffi-wrapper.md:3
msgid ""
"Rust has great support for calling functions through a _foreign function\n"
"interface_ (FFI). We will use this to build a safe wrapper for the `libc`\n"
"functions you would use from C to read the filenames of a directory."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” _ì™¸ë¶€ ê¸°ëŠ¥ í˜¸ì¶œ(FFI)_ì„ ì§€ì›í•©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ë¥¼ ì´ìš©í•˜ì—¬ ë””ë ‰í„°ë¦¬ì—ì„œ íŒŒì¼ ì´ë¦„ì„ ì½ì–´ì˜¤ëŠ” `libc` í•¨ìˆ˜ì— ëŒ€í•œ ì•ˆì „í•œ ë˜í¼ë¥¼ ë§Œë“¤ ê²ƒì…ë‹ˆë‹¤."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
msgid "You will want to consult the manual pages:"
msgstr "ì•„ë˜ ë¦¬ëˆ…ìŠ¤ ë©”ë‰´ì–¼ ë¬¸ì„œë“¤ì„ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
msgid ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr ""
"* [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)\n"
"* [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)\n"
"* [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
msgid ""
"You will also want to browse the [`std::ffi`] module, particular for [`CStr`]\n"
"and [`CString`] types which are used to hold NUL-terminated strings coming from\n"
"C. The [Nomicon] also has a very useful chapter about FFI."
msgstr "[`std::ffi`] ëª¨ë“ˆì„ íƒìƒ‰í•˜ëŠ”ê²Œ í•„ìš”í•  ì§€ë„ ëª¨ë¥´ê² ìŠµë‹ˆë‹¤. Cì—ì„œ ì‚¬ìš©ë˜ëŠ” NUL-terminated ë¬¸ìì—´ì„ ë‹´ê¸° ìœ„í•œ [`CStr`]ê³¼ [`CString`] íƒ€ì…ì„ í™•ì¸í•´ ë³´ì„¸ìš”. [Nomicon]ë¬¸ì„œ ë˜í•œ FFIì— ëŒ€í•œ ìœ ìš©í•œ ë‚´ìš©ì„ ë‹´ê³  ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-3/safe-ffi-wrapper.md:17
msgid ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"
msgstr ""
"[`std::ffi`]: https://doc.rust-lang.org/std/ffi/\n"
"[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html\n"
"[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html\n"
"[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html"

#: src/exercises/day-3/safe-ffi-wrapper.md:22
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing\n"
"functions and methods:"
msgstr "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  ë¹ ì§„ í•¨ìˆ˜ì™€ ë©”ì„œë“œë¥¼ ì±„ì›Œë´…ë‹ˆë‹¤:"

#: src/exercises/day-3/safe-ffi-wrapper.md:29
msgid ""
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:32
#: src/exercises/day-3/solutions-afternoon.md:26
msgid ""
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n"
"    }"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:39
#: src/exercises/day-3/solutions-afternoon.md:33
msgid ""
"    // Layout as per readdir(3) and definitions in /usr/include/x86_64-linux-gnu.\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_long,\n"
"        pub d_off: c_ulong,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_char,\n"
"        pub d_name: [c_char; 256],\n"
"    }"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:49
#: src/exercises/day-3/solutions-afternoon.md:43
msgid ""
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:56
#: src/exercises/day-3/solutions-afternoon.md:50
msgid ""
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:59
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:65
msgid ""
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:73
msgid ""
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:81
msgid ""
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:88
msgid ""
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-4.md:1
msgid "# Welcome to Day 4"
msgstr "# 4ì¼ì°¨ ê°œìš”"

#: src/welcome-day-4.md:3
msgid "Today we will look at two main topics:"
msgstr "ì˜¤ëŠ˜ ê°•ì˜ëŠ” ë‘ ê°€ì§€ ì£¼ì œë¥¼ ë‹¤ë£¹ë‹ˆë‹¤:"

#: src/welcome-day-4.md:5
msgid "* Concurrency: threads, channels, shared state, `Send` and `Sync`."
msgstr "* ë™ì‹œì„±: ì“°ë ˆë“œ, ì±„ë„, ìƒíƒœ ê³µìœ , `Send`ì™€ `Sync`."

#: src/welcome-day-4.md:7
msgid ""
"* Android: building binaries and libraries, using AIDL, logging, and\n"
"  interoperability with C, C++, and Java."
msgstr "* ì•ˆë“œë¡œì´ë“œ: ë°”ì´ë„ˆë¦¬ì™€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë§Œë“œëŠ” ë°©ë²•, AIDL ì‚¬ìš©ë²•, ë¡œê¹…í•˜ëŠ” ë°©ë²•, C/C++, ìë°”ì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±."

#: src/welcome-day-4.md:10
msgid ""
"> We will attempt to call Rust from one of your own projects today. So try to\n"
"> find a little corner of your code base where we can move some lines of code to\n"
"> Rust. The fewer dependencies and \"exotic\" types the better. Something that\n"
"> parses some raw bytes would be ideal."
msgstr "> ìš°ë¦¬ëŠ” ì˜¤ëŠ˜ ì—¬ëŸ¬ë¶„ì˜ í”„ë¡œì íŠ¸ì—ì„œ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œë¥¼ í˜¸ì¶œí•´ë³¼ ê²ƒì…ë‹ˆë‹¤. ê·¸ í”„ë¡œì íŠ¸ì—ì„œ ëŸ¬ìŠ¤íŠ¸ë¡œ ì˜®ê¸¸ë§Œ í•œ ì‘ì€ ë¶€ë¶„ì„ ì •í•˜ì„¸ìš”. ì˜ì¡´ì„±ì´ ì ê³  \"íŠ¹ì´í•œ\" íƒ€ì…ì´ ì ì„ ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤. ë°”ì´íŠ¸ ëª‡ ê°œë¥¼ íŒŒì‹±í•˜ëŠ” ì½”ë“œë¼ë©´ ì™„ë²½í•©ë‹ˆë‹¤."

#: src/concurrency.md:1
msgid "# Fearless Concurrency"
msgstr "# ê²‚ì—†ëŠ” ë™ì‹œì„±"

#: src/concurrency.md:3
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and\n"
"channels."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë™ì‹œì„± ì§€ì›ì´ ë§‰ê°•í•©ë‹ˆë‹¤. ìš´ì˜ì²´ì œ ë ˆë²¨ì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ë©°, ë®¤íƒìŠ¤ì™€ ì±„ë„ë„ ì§€ì›í•©ë‹ˆë‹¤."

#: src/concurrency.md:6
msgid ""
"The Rust type system plays an important role in making many concurrency bugs\n"
"compile time bugs. This is often referred to as _fearless concurrency_ since you\n"
"can rely on the compiler to ensure correctness at runtime."
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ íƒ€ì… ì‹œìŠ¤í…œì€ í”„ë¡œê·¸ë¨ì— ë™ì‹œì„± ë²„ê·¸ê°€ ìˆì„ ê²½ìš°, ì»´íŒŒì¼ ì‹œì— ì—ëŸ¬ê°€ ë°œìƒí•˜ë„ë¡ í•´ ì¤ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ë¥¼ ì´ìš©í•´ì„œ í”„ë¡œê·¸ë¨ì´ ìˆ˜í–‰ì‹œì— ì •í™•íˆ ë™ì‘í•¨ì„ ë¯¸ë¦¬ ë³´ì¥í•´ ì£¼ê¸° ë•Œë¬¸ì—, ì‚¬ëŒë“¤ì€ ì´ë¥¼ ì¢…ì¢… _ê²ì—†ëŠ” ë™ì‹œì„±_ ì´ë¼ê³  í•©ë‹ˆë‹¤."

#: src/concurrency/threads.md:1
msgid "# Threads"
msgstr "# ìŠ¤ë ˆë“œ"

#: src/concurrency/threads.md:3
msgid "Rust threads work similarly to threads in other languages:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ìŠ¤ë ˆë“œëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ ìŠ¤ë ˆë“œì™€ ìœ ì‚¬í•˜ê²Œ ë™ì‘í•©ë‹ˆë‹¤:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/concurrency/threads.md:9
msgid ""
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });"
msgstr ""

#: src/concurrency/threads.md:17
msgid ""
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
msgid ""
"* Threads are all daemon threads, the main thread does not wait for them.\n"
"* Thread panics are independent of each other.\n"
"  * Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"* ìŠ¤ë ˆë“œëŠ” ëª¨ë‘ ë°ëª¬ ìŠ¤ë ˆë“œì…ë‹ˆë‹¤. ë”°ë¼ì„œ ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ì´ ìŠ¤ë ˆë“œë“¤ì´ ëë‚˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"* í•œ ìŠ¤ë ˆë“œì—ì„œ ë°œìƒí•œ íŒ¨ë‹‰ì€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ì˜í–¥ì„ ë¼ì¹˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"  * íŒ¨ë‹‰ì€ ì¶”ê°€ì •ë³´(í˜ì´ë¡œë“œ)ë¥¼ í¬í•¨í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” `downcast_ref`ë¡œ í’€ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:32
msgid ""
"* Notice that the thread is stopped before it reaches 10 â€” the main thread is\n"
"  not waiting."
msgstr "* ë©”ì¸ ìŠ¤ë ˆë“œê°€ ìì‹ ìŠ¤ë ˆë“œë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•Šê¸° ë•Œë¬¸ì— ìì‹ ìŠ¤ë ˆë“œì˜ forë¬¸ì€ 10ê¹Œì§€ ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:35
msgid ""
"* Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for\n"
"  the thread to finish."
msgstr "* ë§Œì•½ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ìì‹ ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¬ê¸°ë¥¼ ì›í•œë‹¤ë©´ `let handle = thread::spawn(...)`ìœ¼ë¡œ ìŠ¤ë ˆë“œë¥¼ ì„ ì–¸í•œ í›„ `handle.join()`ë¡œ ì—°ê²°í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/concurrency/threads.md:38
msgid "* Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "* ìì‹ ìŠ¤ë ˆë“œì—ì„œ ë°œìƒí•œ íŒ¨ë‹‰ì´ ë©”ì¸ ìŠ¤ë ˆë“œì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŒì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/concurrency/threads.md:40
msgid ""
"* Use the `Result` return value from `handle.join()` to get access to the panic\n"
"  payload. This is a good time to talk about [`Any`]."
msgstr "* `handle.join()`ì‚¬ìš©ì‹œ `Result` ë°˜í™˜ê°’ì„ í†µí•´ íŒ¨ë‹‰ì˜ ì¶”ê°€ì •ë³´ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì‹œì ì—ì„œ [`Any`]ì— ëŒ€í•´ ì´ì•¼ê¸°ë¥¼ í•´ ë³´ë©´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:43
msgid "[`Any`]: https://doc.rust-lang.org/std/any/index.html"
msgstr ""

#: src/concurrency/scoped-threads.md:1
msgid "# Scoped Threads"
msgstr "# ë²”ìœ„ ìŠ¤ë ˆë“œ(Scoped Threads)"

#: src/concurrency/scoped-threads.md:3
msgid "Normal threads cannot borrow from their environment:"
msgstr "ë³´í†µ, ìŠ¤ë ˆë“œëŠ” ìŠ¤ë ˆë“œ ë°–ì—ì„œ ë°ì´í„°ë¥¼ ë¹Œë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;"
msgstr ""

#: src/concurrency/scoped-threads.md:8 src/concurrency/scoped-threads.md:22
msgid ""
"fn main() {\n"
"    let s = String::from(\"Hello\");"
msgstr ""

#: src/concurrency/scoped-threads.md:11
msgid ""
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:17
msgid "However, you can use a [scoped thread][1] for this:"
msgstr "í•˜ì§€ë§Œ, [scoped thread][1]ì—ì„œëŠ” ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/concurrency/scoped-threads.md:19
msgid ""
"```rust,editable\n"
"use std::thread;"
msgstr ""

#: src/concurrency/scoped-threads.md:25
msgid ""
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:33
msgid "[1]: https://doc.rust-lang.org/std/thread/fn.scope.html"
msgstr ""

#: src/concurrency/scoped-threads.md:35
msgid ""
"<details>\n"
"    \n"
"* The reason for that is that when the `thread::scope` function completes, all the threads are guaranteed to be joined, so they can return borrowed data.\n"
"* Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by any number of threads.\n"
"    \n"
"</details>"
msgstr ""
"<details>\n"
"    \n"
"* `thread::scope` í•¨ìˆ˜ê°€ ì™„ë£Œë˜ë©´ ê·¸ ì•ˆì—ì„œ ìƒì„±ëœ ëª¨ë“  ìŠ¤ë ˆë“œë“¤ì´ ì¢…ë£Œí–ˆìŒì´ ë³´ì¥ë˜ê¸° ë•Œë¬¸ì—, ê·¸ ë•Œ ë¹Œë ¸ë˜ ë°ì´í„°ë“¤ì„ ë‹¤ì‹œ ë°˜í™˜í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"
"* ì¼ë°˜ì ì¸ ëŸ¬ìŠ¤íŠ¸ì˜ ë¹Œë¦¼ ê·œì¹™ì´ ì ìš©ë©ë‹ˆë‹¤: í•œ ìŠ¤ë ˆë“œì— ì˜í•œ ê°€ë³€ ë¹Œë¦¼ ë˜ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œì— ëŒ€í•œ ë¶ˆë³€ ë¹Œë¦¼ì¤‘ í•˜ë‚˜ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.\n"
"    \n"
"</details>"

#: src/concurrency/channels.md:1
msgid "# Channels"
msgstr "# ì±„ë„"

#: src/concurrency/channels.md:3
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two parts\n"
"are connected via the channel, but you only see the end-points."
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ì±„ë„ì€ `Sender<T>` ì™€ `Receiver<T>` ë‘ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. ì´ ë‘˜ì€ ì±„ë„ì„ í†µí•´ ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆì§€ë§Œ, ìš°ë¦¬ëŠ” ì±„ë„ì„ ë³¼ ìˆ˜ëŠ” ì—†ê³  ì´ ì–‘ ëë‹¨ë§Œì„ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;"
msgstr ""

#: src/concurrency/channels.md:10 src/concurrency/channels/unbounded.md:10
msgid ""
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();"
msgstr ""

#: src/concurrency/channels.md:13
msgid ""
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();"
msgstr ""

#: src/concurrency/channels.md:16
msgid ""
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());"
msgstr ""

#: src/concurrency/channels.md:19
msgid ""
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
msgid ""
"* `mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` implement `Clone` (so\n"
"  you can make multiple producers) but `Receiver` does not.\n"
"* `send()` and `recv()` return `Result`. If they return `Err`, it means the counterpart `Sender` or\n"
"  `Receiver` is dropped and the channel is closed."
msgstr ""
"* `mpsc`ëŠ” â€œMulti-Produce, Single-Consumerâ€ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. `Sender`ì™€ `SyncSender`ëŠ” `Clone`ì„ êµ¬í˜„í•˜ì§€ë§Œ (ì¦‰, ì—¬ëŸ¬ê°œì˜ producerë¥¼ ë§Œë“¤ìˆ˜ ìˆìŠµë‹ˆë‹¤) `Receiver`ëŠ” `Clone`ì„ êµ¬í˜„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"* `send()`ì™€ `recv()`ëŠ” `Result`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë§Œì¼ `Err`ê°€ ë°˜í™˜ëœë‹¤ë©´, ìƒëŒ€ë°©ì˜ `Sender`ë˜ëŠ” `Receiver`ê°€ ì‚­ì œë˜ì—ˆê³  ì±„ë„ì´ ë‹«í˜”ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤."

#: src/concurrency/channels/unbounded.md:1
msgid "# Unbounded Channels"
msgstr "# ë¬´ê²½ê³„ ì±„ë„(Unbounded Channels)"

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "`mpsc::channel()` í•¨ìˆ˜ëŠ” ê²½ê³„ê°€ ì—†ëŠ” ë¹„ë™ê¸° ì±„ë„ì„ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/concurrency/channels/unbounded.md:5
#: src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/concurrency/channels/unbounded.md:13
#: src/concurrency/channels/bounded.md:13
msgid ""
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));"
msgstr ""

#: src/concurrency/channels/unbounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {}\", msg);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:1
msgid "# Bounded Channels"
msgstr "# ê²½ê³„ê°€ ìˆëŠ” ì±„ë„(Bounded Channels)"

#: src/concurrency/channels/bounded.md:3
msgid "Bounded and synchronous channels make `send` block the current thread:"
msgstr "ê²½ê³„ê°€ ìˆëŠ” ë™ê¸° ì±„ë„ì€ `send`ê°€ í˜„ì œ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹ í•˜ë„ë¡ ë§Œë“­ë‹ˆë‹¤:"

#: src/concurrency/channels/bounded.md:10
msgid ""
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);"
msgstr ""

#: src/concurrency/channels/bounded.md:23
msgid ""
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state.md:1
msgid "# Shared State"
msgstr "# ìƒíƒœ ê³µìœ (Shared State)"

#: src/concurrency/shared_state.md:3
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is\n"
"primarily done via two types:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì£¼ë¡œ ì•„ë˜ ë‘ ê°€ì§€ íƒ€ì…ì„ ì´ìš©í•´ì„œ ê³µìœ  ë°ì´í„° ë™ê¸°í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤:"

#: src/concurrency/shared_state.md:6
msgid ""
"* [`Arc<T>`][1], atomic reference counted `T`: handles sharing between threads and\n"
"  takes care to deallocate `T` when the last reference is dropped,\n"
"* [`Mutex<T>`][2]: ensures mutually exclusive access to the `T` value."
msgstr ""
"* [`Arc<T>`][1], `T`ì— ëŒ€í•œ ì•„í† ë¯¹ ì°¸ì¡° ì¹´ìš´íŠ¸: ì´ ì°¸ì¡°ëŠ” ë‹¤ìˆ˜ì˜ ìŠ¤ë ˆë“œ ì‚¬ì´ì—ì„œ ê³µìœ ë  ìˆ˜ ìˆê³ , ì°¸ì¡°í•˜ë˜ ë§ˆì§€ë§‰ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œí•  ê²½ìš° `T`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
"* [`Mutex<T>`][2]: `T`ê°’ì— ëŒ€í•œ ìƒí˜¸ ë°°ì œ ì—‘ì„¸ìŠ¤ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤."

#: src/concurrency/shared_state.md:10
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"
msgstr ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html"

#: src/concurrency/shared_state/arc.md:1
msgid "# `Arc`"
msgstr "# `Arc`"

#: src/concurrency/shared_state/arc.md:3
msgid "[`Arc<T>`][1] allows shared read-only access via its `clone` method:"
msgstr "[`Arc<T>`][1]ì˜ `clone` ë©”ì„œë“œë¥¼ ì´ìš©í•˜ë©´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ í•œ ë°ì´í„°ë¥¼ ë™ì‹œì— (_ì—­ì£¼_: ê·¸ë¦¬ê³  ì•ˆì „í•˜ê²Œ. ìŠ¤ë ˆë“œê°€ í•˜ë‚˜ë¼ë„ ì‚´ì•„ìˆëŠ” ë™ì•ˆì—ëŠ” `T`ê°€ ë°˜í™˜ë˜ì§€ ì•ŠìŒ) ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;"
msgstr ""

#: src/concurrency/shared_state/arc.md:9
msgid ""
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = v.clone();\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/arc.md:20
msgid ""
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:25
msgid "[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr ""

#: src/concurrency/shared_state/arc.md:29
msgid ""
"* `Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` that uses atomic\n"
"  operations.\n"
"* `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` and `Sync` iff `T`\n"
"  implements them both.\n"
"* `Arc::clone()` has the cost of atomic operations that get executed, but after that the use of the\n"
"  `T` is free.\n"
"* Beware of reference cycles, `Arc` does not use a garbage collector to detect them.\n"
"    * `std::sync::Weak` can help."
msgstr ""
"* `Arc`ëŠ” \"Atomic Reference Counted\"ë¥¼ ì˜ë¯¸í•˜ë©°, ìŠ¤ë ˆë“œ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ëŠ” `Rc`ë¼ê³  ìƒê°í•˜ë©´ ë©ë‹ˆë‹¤.\n"
"* `T`ê°€ `Clone`ì„ êµ¬í˜„í•˜ë“  ì•ˆí•˜ë“  `Arc<T>`ëŠ” `Clone`ì„ êµ¬í˜„í•©ë‹ˆë‹¤. `Send`ì™€ `Sync`ëŠ” `T`ê°€ ì´ë“¤ì„ êµ¬í˜„í•˜ëŠ” ê²½ìš°ì—ë§Œ êµ¬í˜„ë©ë‹ˆë‹¤.\n"
"* `Arc::clone()`ëŠ” ì•„í† ë¯¹ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— ê·¸ ë•Œ ì½”ìŠ¤íŠ¸ê°€ ì¢€ ìˆì§€ë§Œ, ì¼ë‹¨ `clone()`ì´ ëë‚œ í›„ `T`ë¥¼ ì‚¬ìš©í•˜ëŠ” ëŒ€ì—ëŠ” ì•„ë¬´ëŸ° ì˜¤ë²„í—¤ë“œê°€ ì—†ìŠµë‹ˆë‹¤.\n"
"* ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ìˆœí™˜ ì°¸ì¡°ë¥¼ ê°ì§€í•˜ëŠ” ê°€ë¹„ì§€ ì»¬ë™í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n"
"    * ìˆœí™˜ ì°¸ì¡°ë¥¼ í”¼í•˜ëŠ”ë° `std::sync::Weak`ê°€ ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:1
msgid "# `Mutex`"
msgstr "# `Mutex`"

#: src/concurrency/shared_state/mutex.md:3
msgid ""
"[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`\n"
"behind a read-only interface:"
msgstr "[`Mutex<T>`][1]ë¥¼ ì´ìš©í•˜ë©´ ë¶ˆë³€ ì°¸ì¡°ë¥¼ í†µí•´ì„œë„ `T`ì˜ ê°’ì„ ìˆ˜ì •í•  ìˆ˜ê°€ ìˆìœ¼ë©°, _ì´ì— ë”í•´ì„œ_ í•œ ë²ˆì— í•œ ìŠ¤ë ˆë“œë§Œ `T`ì˜ ê°’ì„ ì ‘ê·¼(ì½ê±°ë‚˜ ì“°ê±°ë‚˜)í•¨ì„ ë³´ì¥í•´ ì¤ë‹ˆë‹¤:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;"
msgstr ""

#: src/concurrency/shared_state/mutex.md:9
msgid ""
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());"
msgstr ""

#: src/concurrency/shared_state/mutex.md:13
msgid ""
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }"
msgstr ""
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }"

#: src/concurrency/shared_state/mutex.md:18
msgid ""
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket\n"
"implementation."
msgstr "ëª¨ë“  `Mutex<T>`ëŠ” [`impl<T: Send> Sync for Mutex<T>`][2]ë¥¼ ìë™ìœ¼ë¡œ êµ¬í˜„í•¨ì„ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/concurrency/shared_state/mutex.md:25
msgid ""
"[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n"
"[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E\n"
"[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html"
msgstr ""

#: src/concurrency/shared_state/mutex.md:29
msgid ""
"<details>\n"
"    \n"
"* `Mutex` in Rust looks like a collection with just one element - the protected data.\n"
"    * It is not possible to forget to acquire the mutex before accessing the protected data.\n"
"* You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The `MutexGuard` ensures that the\n"
"  `&mut T` doesn't outlive the lock being held.\n"
"* `Mutex<T>` implements both `Send` and `Sync` iff `T` implements `Send`.\n"
"* A read-write lock counterpart - `RwLock`.\n"
"* Why does `lock()` return a `Result`? \n"
"    * If the thread that held the `Mutex` panicked, the `Mutex` becomes \"poisoned\" to signal that\n"
"      the data it protected might be in an inconsistent state. Calling `lock()` on a poisoned mutex\n"
"      fails with a [`PoisonError`]. You can call `into_inner()` on the error to recover the data\n"
"      regardless."
msgstr ""
"<details>\n"
"    \n"
"* ëŸ¬ìŠ¤íŠ¸ì˜ `Mutex`ëŠ” ì˜¤ì§ í•˜ë‚˜ì˜ ë°ì´í„°ë§Œ ë‹´ì„ ìˆ˜ ìˆëŠ” ì»¬ë ‰ì…˜ì²˜ëŸ¼ ë³¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì»¬ë ‰ì…˜ê³¼ ë‹¤ë¥¸ ì ì€, ê·¸ ë°ì´í„°ê°€ ë™ì‹œì„± ë¬¸ì œë¡œë¶€í„° ììœ ë¡­ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.\n"
"  * `Mutex`ëŠ” ë®¤í…ìŠ¤ë¥¼ íšë“í•˜ì§€ ì•Šìœ¼ë©´ ë³´í˜¸ëœ ë°ì´í„°ì— ì ‘ê·¼í•˜ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥  í•˜ë„ë¡ ë””ìì¸ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.\n"
"* `&Mutex<T>`ì— ëŒ€í•´ lockì„ íšë“í•˜ë©´ `&mut T`ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `MutexGuard`ëŠ” `&mut T`ê°€ íšë“í•œ lockë³´ë‹¤ ì˜¤ë˜ ì‚´ì•„ë‚¨ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤.\n"
"* `Mutex<T>`ëŠ” ì˜¤ì§ `T`ê°€ `Send`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²½ìš°ì—ë§Œ `Send`ì™€ `Sync`ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.\n"
"* ì½ê¸°-ì“°ê¸° lockì€ `RwLock`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\n"
"* ì™œ `lock()`ì´ `Result`ë¥¼ ë°˜í™˜í• ê¹Œìš”?\n"
"  * `Mutex`ë¥¼ íšë“í•œ ìŠ¤ë ˆë“œì—ì„œ íŒ¨ë‹‰ì´ ë°œìƒí•˜ë©´, ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ìƒí™©ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ `Mutex`ê°€ \"ì¤‘ë…(poisoned)\" ë˜ì—ˆë‹¤ê³  í‘œí˜„í•˜ë©°, ì¤‘ë…ëœ ë®¤í…ìŠ¤ì—ì„œ `lock()`ì„ í˜¸ì¶œí•˜ë©´ ì‹¤íŒ¨í•˜ê³  [`PoisonError`]ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì˜¤ë¥˜ë¡œë¶€í„° ë°ì´í„°ë¥¼ ë³µêµ¬í•˜ê¸° ìœ„í•´ `into_inner()`ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:43
msgid ""
"[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html  \n"
"    \n"
"</details>"
msgstr ""

#: src/concurrency/shared_state/example.md:3
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "`Arc`ì™€ `Mutex`ì˜ ë™ì‘ì„ ì‚´í´ë´…ì‹œë‹¤:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};"
msgstr ""

#: src/concurrency/shared_state/example.md:9
msgid ""
"fn main() {\n"
"    let mut v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);"
msgstr ""

#: src/concurrency/shared_state/example.md:16
msgid ""
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid ""
"Possible solution:\n"
"    \n"
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"
msgstr ""
"ê°€ëŠ¥í•œ í•´ê²°ë°©ë²•ì…ë‹ˆë‹¤.:\n"
"    \n"
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;"

#: src/concurrency/shared_state/example.md:29
msgid ""
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));"
msgstr ""

#: src/concurrency/shared_state/example.md:32
msgid ""
"    let v2 = v.clone();\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });"
msgstr ""

#: src/concurrency/shared_state/example.md:38
msgid ""
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }"
msgstr ""

#: src/concurrency/shared_state/example.md:43
msgid "    handle.join().unwrap();"
msgstr ""

#: src/concurrency/shared_state/example.md:45
msgid ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"Notable parts:"
msgstr ""
"    {\n"
"        let v = v.lock().unwrap();\n"
"        println!(\"v: {v:?}\");\n"
"    }\n"
"}\n"
"```\n"
"    \n"
"ì°¸ê³  ì‚¬í•­:"

#: src/concurrency/shared_state/example.md:54
msgid ""
"* `v` is wrapped in both `Arc` and `Mutex`, because their concerns are orthogonal.\n"
"  * Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state between threads.\n"
"* `v: Arc<_>` needs to be cloned as `v2` before it can be moved into another thread. Note `move` was added to the lambda signature.\n"
"* Blocks are introduced to narrow the scope of the `LockGuard` as much as possible.\n"
"* We still need to acquire the `Mutex` to print our `Vec`."
msgstr ""
"* `v`ëŠ” `Arc`ì™€ `Mutex` ëª¨ë‘ì— í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” `Arc`ì™€ `Mutex`ê°€ ì„œë¡œ ì™„ì „íˆ ë‹¤ë¥¸ ë¬¸ì œë¥¼ ìœ„í•œ ë„êµ¬ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"
"  * `Mutex`ë¥¼ `Arc`ë¡œ ë˜í•‘í•˜ëŠ” ê²ƒì€ ê°€ë³€ ìƒíƒœë¥¼ ìŠ¤ë ˆë“œë“¤ ê°„ì— ê³µìœ í•  ë•Œ í”íˆ ì‚¬ìš©í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.\n"
"* `v: Arc<_>`ë¥¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‚¬ìš©í•˜ë ¤ë©´, ë¨¼ì € `v2`ë¡œ ë³µì‚¬ë¥¼ í•˜ê³  ì´ë¥¼ ê·¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ ëŒë‹¤ì˜ ì‹œê·¸ë‹ˆì²˜ì— `move`ê°€ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤.\n"
"* ë¸”ë¡ì€ `LockGuard`ì˜ ë²”ìœ„ë¥¼ ìµœëŒ€í•œ ì¢íˆê¸° ìœ„í•´ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.\n"
"* `Vec`ì„ ë‹¨ìˆœíˆ ì¶œë ¥í•˜ê¸° ìœ„í•´ì„œë„ ì—¬ì „íˆ `Mutex`ë¥¼ íšë“í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/concurrency/send-sync.md:1
msgid "# `Send` and `Sync`"
msgstr "# `Send`ì™€ `Sync`"

#: src/concurrency/send-sync.md:3
msgid "How does Rust know to forbid shared access across thread? The answer is in two traits:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì–´ë–»ê²Œ í•´ì„œ ìŠ¤ë ˆë“œ ê°„ì— íŠ¹ì • ë°ì´í„° íƒ€ì…ì´ ê³µìœ ë  ìˆ˜ ìˆê±°ë‚˜, ì•ˆëœë‹¤ëŠ” ê²ƒì„ ì•Œê¹Œìš”? ì •ë‹µì€ ë‹¤ìŒ ë‘ íŠ¸ë ˆì‡ì— ìˆìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync.md:5
msgid ""
"* [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a thread\n"
"  boundary.\n"
"* [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a thread\n"
"  boundary."
msgstr ""
"* [`Send`][1]: `T`ê°€ ìŠ¤ë ˆë“œ ê°„ ì´ë™ì´ ì•ˆì „í•˜ë‹¤ë©´, `T`ì˜ íƒ€ì…ì€ `Send`ì…ë‹ˆë‹¤.\n"
"* [`Sync`][2]: `&T`ê°€ ìŠ¤ë ˆë“œ ê°„ ì´ë™ì´ ì•ˆì „í•˜ë‹¤ë©´, `&T`ì˜ íƒ€ì…ì€ `Sync`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync.md:10
msgid ""
"`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically derive them for your types\n"
"as long as they only contain `Send` and `Sync` types. You can also implement them manually when you\n"
"know it is valid."
msgstr "`Send`ì™€ `Sync` íŠ¸ë ˆì‡ì€ [ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡][3]ì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ì˜ ìš”ì†Œë“¤ì´ ëª¨ë‘ `Send`ì™€ `Sync` íƒ€ì…ì´ë©´ ìë™ìœ¼ë¡œ ì´ íŠ¸ë ˆì‡ë“¤ì„ ì ìš©ì‹œì¼œ ì¤ë‹ˆë‹¤. ë¬¼ë¡  ì—¬ëŸ¬ë¶„ ìŠ¤ìŠ¤ë¡œ ë§ë‹¤ê³  ì•Œê³  ìˆë‹¤ë©´ ì§ì ‘ êµ¬í˜„í•´ë„ ë©ë‹ˆë‹¤."

#: src/concurrency/send-sync.md:14
msgid ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"
msgstr ""
"[1]: https://doc.rust-lang.org/std/marker/trait.Send.html\n"
"[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n"
"[3]: ../unsafe/unsafe-traits.md"

#: src/concurrency/send-sync.md:20
msgid ""
"* One can think of these traits as markers that the type has certain thread-safety properties.\n"
"* They can be used in the generic constraints as normal traits.\n"
"  \n"
"</details>"
msgstr ""
"* `Sync`ì™€ `Send`ëŠ” ì–´ë–¤ íƒ€ì…ì´ íŠ¹ì •í•œ ìŠ¤ë ˆë“œ-ì•ˆì „ ì†ì„±ì„ ê°€ì§ì„ ë‚˜íƒ€ë‚´ëŠ” ë§ˆì»¤ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"* ì´ ë‘ íŠ¸ë ˆì‡ì€ ì œë„¤ë¦­ì—ì„œ ì œì•½ ì¡°ê±´ì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¸ë ˆì‡ë¡œ ì‚¬ìš©ë  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.\n"
"\n"
"</details>"

#: src/concurrency/send-sync/send.md:1
msgid "# `Send`"
msgstr "# `Send`"

#: src/concurrency/send-sync/send.md:3
msgid "> A type `T` is [`Send`][1] if it is safe to move a `T` value to another thread."
msgstr "> `T`ê°€ ìŠ¤ë ˆë“œ ê°„ì— ì•ˆì „í•˜ê²Œ ì´ë™ë  ìˆ˜ ìˆë‹¤ë©´, `T`ì˜ íƒ€ì…ì€ `Send`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/send.md:5
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will run\n"
"in that thread. So the question is when you can allocate a value in one thread\n"
"and deallocate it in another."
msgstr "ì†Œìœ ê¶Œì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™í•˜ë©´ ì†Œë©¸ìê°€ í•´ë‹¹ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì˜ë¬¸ì€ \"ì–¸ì œ í•œ ìŠ¤ë ˆë“œì—ì„œ ê°’ì„ í• ë‹¹í•˜ê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ê°’ì„ í• ë‹¹ í•´ì œí•  ìˆ˜ ìˆëŠ”ê°€\" ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/send.md:9
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Send.html"
msgstr ""

#: src/concurrency/send-sync/sync.md:1
msgid "# `Sync`"
msgstr "# `Sync`"

#: src/concurrency/send-sync/sync.md:3
msgid ""
"> A type `T` is [`Sync`][1] if it is safe to access a `T` value from multiple\n"
"> threads at the same time."
msgstr "> `&T`ê°€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ì•ˆì „í•˜ê²Œ ì ‘ê·¼ë  ìˆ˜ ìˆë‹¤ë©´, `&T`ì˜ íƒ€ì…ì€ `Sync`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/sync.md:6
msgid "More precisely, the definition is:"
msgstr "ì¢€ ë” ì •í™•í•œ ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/sync.md:8
msgid "> `T` is `Sync` if and only if `&T` is `Send`"
msgstr "`&T`ê°€ `Send`ì¸ ê²½ìš°ì—ë§Œ `T`ì˜ íƒ€ì…ì´ `Sync`ê°€ ë©ë‹ˆë‹¤"

#: src/concurrency/send-sync/sync.md:10
msgid "[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html"
msgstr ""

#: src/concurrency/send-sync/sync.md:14
msgid "This statement is essentially a shorthand way of saying that if a type is thread-safe for shared use, it is also thread-safe to pass references of it across threads."
msgstr "ìœ„ ë¬¸ì¥ì„ í’€ì–´ì„œ ì´ì•¼ê¸° í•˜ë©´, ì–´ë–¤ íƒ€ì…ì´ ìŠ¤ë ˆë“œ ê°„ì— ê³µìœ ë˜ì–´ì„œ ì‚¬ìš©ë˜ê¸°ì— ì•ˆì „í•˜ë‹¤ë©´ ê·¸ íƒ€ì…ì˜ ì°¸ì¡° íƒ€ì…ì€ ìŠ¤ë ˆë“œ ê°„ì— ì´ë™ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/sync.md:16
msgid "This is because if a type is Sync it means that it can be shared across multiple threads without the risk of data races or other synchronization issues, so it is safe to move it to another thread. A reference to the type is also safe to move to another thread, because the data it references can be accessed from any thread safely."
msgstr "ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¦ëª…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤: ì–´ë–¤ íƒ€ì…ì´ `Sync`ë¼ëŠ” ë§ì€ ê³§ ê·¸ íƒ€ì…ì´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë“¤ ì‚¬ì´ì—ì„œ ë°ì´í„° ë ˆì´ìŠ¤ë‚˜ ì—¬íƒ€ ë™ê¸°í™” ë¬¸ì œ ì—†ì´ ê³µìœ  ê°€ëŠ¥í•˜ë‹¤ëŠ” ë§ì…ë‹ˆë‹¤. ìŠ¤ë ˆë“œ ê°„ ê³µìœ ê°€ ì•ˆì „í•˜ë‹¤ë©´, ìŠ¤ë ˆë“œê°„ ì´ë™ë„ ì•ˆì „í•  ìˆ˜ ë°–ì— ì—†ìŠµë‹ˆë‹¤. ì–´ë–¤ íƒ€ì…ì˜ ìŠ¤ë ˆë“œê°„ ì´ë™ì´ ì•ˆì „í•˜ë‹¤ë©´, ê·¸ íƒ€ì…ì˜ ì°¸ì¡° ë˜í•œ ìŠ¤ë ˆë“œê°„ ì´ë™ì´ ì•ˆì „í•  ìˆ˜ ë°–ì— ì—†ìŠµë‹ˆë‹¤."

#: src/concurrency/send-sync/examples.md:1
msgid "# Examples"
msgstr "# ì˜ˆì œ"

#: src/concurrency/send-sync/examples.md:3
msgid "## `Send + Sync`"
msgstr ""

#: src/concurrency/send-sync/examples.md:5
msgid "Most types you come across are `Send + Sync`:"
msgstr "ì—¬ëŸ¬ë¶„ì´ ë‹¤ë£¨ê²Œ ë  ëŒ€ë¶€ë¶„ì˜ íƒ€ì…ì€ `Send + Sync`ì…ë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:7
msgid ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: Explicitly thread-safe via atomic reference count.\n"
"* `Mutex<T>`: Explicitly thread-safe via internal locking.\n"
"* `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"* `i8`, `f32`, `bool`, `char`, `&str`, ...\n"
"* `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...\n"
"* `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...\n"
"* `Arc<T>`: ì°¸ì¡° ì¹´ìš´íŠ¸ ì¡°ì‘ì„ ì•„í† ë¯¹ í•˜ê¸° ë•Œë¬¸ì— ìŠ¤ë ˆë“œ ì•ˆì „í•¨.\n"
"* `Mutex<T>`: ê°’ì„ ì ‘ê·¼í•˜ê¸° ìœ„í•´ ë®¤íƒìŠ¤ë¥¼ ì ê¶ˆì•¼ í•˜ê¸° ë•Œë¬¸ì— ìŠ¤ë ˆë“œ ì•ˆì „í•¨.\n"
"* `AtomicBool`, `AtomicU8`, ...: ê°’ì„ ì ‘ê·¼í•  ë•Œ íŠ¹ë³„í•œ ì•„í† ë¯¹ ëª…ë ¹ì–´ë“¤ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/concurrency/send-sync/examples.md:14
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are\n"
"`Send + Sync`."
msgstr "ì œë„¤ë¦­ íƒ€ì…ì€ ì¼ë°˜ì ìœ¼ë¡œ íƒ€ì… íŒŒë¼ë©”í„°ê°€ `Send + Sync`ì´ë©´ `Send + Sync` ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/examples.md:17
msgid "## `Send + !Sync`"
msgstr ""

#: src/concurrency/send-sync/examples.md:19
msgid ""
"These types can be moved to other threads, but they're not thread-safe.\n"
"Typically because of interior mutability:"
msgstr "ì•„ë˜ íƒ€ì…ë“¤ì€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ë  ìˆ˜ ìˆì§€ë§Œ ë‚´ë¶€ì ìœ¼ë¡œ ê°’ì´ ë³€ê²½ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:22
msgid ""
"* `mpsc::Sender<T>`\n"
"* `mpsc::Receiver<T>`\n"
"* `Cell<T>`\n"
"* `RefCell<T>`"
msgstr ""

#: src/concurrency/send-sync/examples.md:27
msgid "## `!Send + Sync`"
msgstr ""

#: src/concurrency/send-sync/examples.md:29
msgid "These types are thread-safe, but they cannot be moved to another thread:"
msgstr "ì•„ë˜ íƒ€ì…ë“¤ì€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ë§Œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:31
msgid ""
"* `MutexGuard<T>`: Uses OS level primitives which must be deallocated on the\n"
"  thread which created them."
msgstr "* `MutexGuard<T>`: ë‚´ë¶€ì ìœ¼ë¡œ, ìš´ì˜ì²´ì œê°€ ì œê³µí•˜ëŠ” primitiveë¥¼ ì‚¬ìš©í•˜ëŠ”ë°, ì´ primitiveëŠ” ìƒì„±ëœ ìŠ¤ë ˆë“œì—ì„œ í•´ì œê°€ ì´ë£¨ì–´ì ¸ì•¼ í•©ë‹ˆë‹¤. (_ì—­ì£¼_: ê·¸ë˜ì„œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì˜®ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.)"

#: src/concurrency/send-sync/examples.md:34
msgid "## `!Send + !Sync`"
msgstr ""

#: src/concurrency/send-sync/examples.md:36
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr "ì•„ë˜ íƒ€ì…ë“¤ì€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ë„ ì•Šê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ë  ìˆ˜ë„ ì—†ìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:38
msgid ""
"* `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a\n"
"  non-atomic reference count.\n"
"* `*const T`, `*mut T`: Rust assumes raw pointers may have special\n"
"  concurrency considerations."
msgstr ""
"* `Rc<T>`: `Rc<T>` ëŠ” ì•„í† ë¯¹í•˜ì§€ ì•Šì€ ë°©ì‹ìœ¼ë¡œ ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ì¡°ì‘í•˜ëŠ” `RcBox<T>`ë¥¼ ì°¸ì¡°í•©ë‹ˆë‹¤.\n"
"* `*const T`, `*mut T`: ëŸ¬ìŠ¤íŠ¸ëŠ” í¬ì¸í„°ê°€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•Šë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤."

#: src/exercises/day-4/morning.md:1 src/exercises/day-4/afternoon.md:1
msgid "# Exercises"
msgstr "# ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-4/morning.md:3
msgid "Let us practice our new concurrency skills with"
msgstr "ë™ì‹œì„± ê¸°ë²•ë“¤ì„ ì—°ìŠµí•´ ë´…ì‹œë‹¤"

#: src/exercises/day-4/morning.md:5
msgid "* Dining philosophers: a classic problem in concurrency."
msgstr "* ì‹ì‚¬í•˜ëŠ” ì² í•™ì ë¬¸ì œ: ê³ ì ì ì¸ ë™ì‹œì„± ë¬¸ì œì…ë‹ˆë‹¤."

#: src/exercises/day-4/morning.md:7
msgid ""
"* Multi-threaded link checker: a larger project where you'll use Cargo to\n"
"  download dependencies and then check links in parallel."
msgstr "* ë©€í‹° ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°: ë³‘ë ¬ì ìœ¼ë¡œ ì›¹í˜ì´ì§€ì˜ ë§í¬ë“¤ì„ ì²´í¬í•©ë‹ˆë‹¤. ì¹´ê³ ë¥¼ í†µí•´ ëª‡ ê°€ì§€ ì˜ì¡´ì„±ë“¤ì„ ë‹¤ìš´ë„ë¥´ ë°›ì•„ì•¼ í•˜ëŠ” í° í”„ë¡œì íŠ¸ ì…ë‹ˆë‹¤."

#: src/exercises/day-4/dining-philosophers.md:1
msgid "# Dining Philosophers"
msgstr "# ì‹ì‚¬í•˜ëŠ” ì² í•™ìë“¤"

#: src/exercises/day-4/dining-philosophers.md:3
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "ì‹ì‚¬í•˜ëŠ” ì² í•™ì ë¬¸ì œëŠ” ë™ì‹œì„±ì— ìˆì–´ì„œ ê³ ì „ì ì¸ ë¬¸ì œì…ë‹ˆë‹¤:"

#: src/exercises/day-4/dining-philosophers.md:5
msgid ""
"> Five philosophers dine together at the same table. Each philosopher has their\n"
"> own place at the table. There is a fork between each plate. The dish served is\n"
"> a kind of spaghetti which has to be eaten with two forks. Each philosopher can\n"
"> only alternately think and eat. Moreover, a philosopher can only eat their\n"
"> spaghetti when they have both a left and right fork. Thus two forks will only\n"
"> be available when their two nearest neighbors are thinking, not eating. After\n"
"> an individual philosopher finishes eating, they will put down both forks."
msgstr ""
"> 5ëª…ì˜ ì² í•™ìê°€ ì›íƒì—ì„œ ì‹ì‚¬ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤. \n"
"> ì² í•™ìëŠ” ì›íƒì—ì„œ ìì‹ ì˜ ìë¦¬ì— ì•‰ì•„ìˆìŠµë‹ˆë‹¤.\n"
"> í¬í¬ëŠ” ê° ì ‘ì‹œ ì‚¬ì´ì— ìˆìŠµë‹ˆë‹¤. \n"
"> ì œê³µë˜ëŠ” ìš”ë¦¬ë¥¼ ë¨¹ê¸° ìœ„í•´ì„œëŠ” ë‘ ê°œì˜ í¬í¬ë¥¼ ëª¨ë‘ ì‚¬ìš©í•´ì•¼í•©ë‹ˆë‹¤.\n"
"> ì² í•™ìëŠ” ìƒê°ì„ í•˜ë‹¤ê°€ ë°°ê°€ ê³ í”„ë©´ ìì‹ ì˜ ì¢Œ,ìš°ì˜ í¬í¬ë¥¼ ë“¤ì–´ ìš”ë¦¬ë¥¼ ë¨¹ìŠµë‹ˆë‹¤.\n"
"> ì² í•™ìëŠ” ìš”ë¦¬ë¥¼ ë¨¹ì€ í›„ì—ëŠ” í¬í¬ë¥¼ ë‹¤ì‹œ ìë¦¬ì— ë‚´ë ¤ë†“ìŠµë‹ˆë‹¤.\n"
"> ì² í•™ìëŠ” ìì‹ ì˜ ì¢Œ,ìš°ì— í¬í¬ê°€ ìˆì„ë•Œë§Œ ìš”ë¦¬ë¥¼ ë¨¹ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"> ë”°ë¼ì„œ ë‘ ê°œì˜ í¬í¬ëŠ” ì˜¤ì§ ìì‹ ì˜ ì¢Œ,ìš° ì² í•™ìê°€ ìƒê°ì„ í•  ë•Œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-4/dining-philosophers.md:13
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) for\n"
"this exercise. Copy the code below to `src/main.rs` file, fill out the blanks,\n"
"and test that `cargo run` does not deadlock:"
msgstr "ì´ë²ˆ í›ˆë ¨ì—ì„œëŠ” [ì¹´ê³  ì„¤ì¹˜í•˜ê¸°](../../cargo/running-locally.md)ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ë³µì‚¬í•´ì„œ `src/main.rs`ì— ë¶™ì—¬ë†“ê³  ë¹ˆ ë¶€ë¶„ì„ ì±„ìš°ê³ , `cargo run` ì»¤ë§¨ë“œë¡œ í…ŒìŠ¤íŠ¸ í•´ì„œ êµì°©ìƒíƒœ(ë°ë“œë½)ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/exercises/day-4/dining-philosophers.md:17
msgid ""
"```rust,compile_fail\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:23
#: src/exercises/day-4/solutions-morning.md:28
msgid "struct Fork;"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:25
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:32
msgid ""
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:39
msgid ""
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:46
#: src/exercises/day-4/solutions-morning.md:60
msgid ""
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:49
msgid ""
"fn main() {\n"
"    // Create forks"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:52
msgid "    // Create philosophers"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:54
msgid "    // Make them think and eat"
msgstr ""

#: src/exercises/day-4/dining-philosophers.md:56
msgid ""
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:1
msgid "# Multi-threaded Link Checker"
msgstr "# ë©€í‹°ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°"

#: src/exercises/day-4/link-checker.md:3
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It should\n"
"start at a webpage and check that links on the page are valid. It should\n"
"recursively check other pages on the same domain and keep doing this until all\n"
"pages have been validated."
msgstr "ìƒˆë¡œ ë°°ìš´ê²ƒë“¤ì„ í™œìš©í•´ì„œ ë©€í‹° ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°ë¥¼ ë§Œë“­ë‹ˆë‹¤. ì´ ê²€ì‚¬ê¸°ëŠ” ì›¹í˜ì´ì§€ ì•ˆì— ìˆëŠ” ë§í¬ë“¤ì´ ìœ íš¨í•œì§€ í™•ì¸í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì¬ê·€ì ìœ¼ë¡œ ë™ì¼ ë„ë©”ì¸ì˜ ë‹¤ë¥¸ ëª¨ë“  í˜ì´ì§€ê°€ ìœ íš¨í•œì§€ í™•ì¸í•©ë‹ˆë‹¤."

#: src/exercises/day-4/link-checker.md:8
msgid ""
"For this, you will need an HTTP client such as [`reqwest`][1]. Create a new\n"
"Cargo project and `reqwest` it as a dependency with:"
msgstr "ì´ë¥¼ ìœ„í•´ì„œ [`reqwest`][1]ì™€ ê°™ì€ HTTP í´ë¼ì´ì–¸íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤. ìƒˆë¡œìš´ ë¡œì»¬ í”„ë¡œì íŠ¸ë¥¼ ë§Œë“¤ê³  [`reqwest`][1]ë¥¼ ì˜ì¡´ì„±ì— ì¶”ê°€í•˜ì‹­ì‹œìš”:"

#: src/exercises/day-4/link-checker.md:11
msgid ""
"```shell\n"
"$ cargo new link-checker\n"
"$ cd link-checker\n"
"$ cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:17
msgid ""
"> If `cargo add` fails with `error: no such subcommand`, then please edit the\n"
"> `Cargo.toml` file by hand. Add the dependencies listed below."
msgstr "> ë§Œì¼ `cargo add` ì»¤ë§¨ë“œê°€ `error: no such subcommand` ë¡œ ì‹¤íŒ¨í•œë‹¤ë©´ `Cargo.toml` íŒŒì¼ì„ ì§ì ‘ ìˆ˜ì •í•´ë„ ë©ë‹ˆë‹¤. ì•„ë˜ì— ì „ì²´ ì˜ì¡´ì„± ë‚´ìš©ì´ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-4/link-checker.md:20
msgid "You will also need a way to find links. We can use [`scraper`][2] for that:"
msgstr "ë§í¬ë¥¼ ì°¾ê¸° ìœ„í•´ì„œ [`scraper`][2]ë„ ì¶”ê°€í•©ë‹ˆë‹¤:"

#: src/exercises/day-4/link-checker.md:22
msgid ""
"```shell\n"
"$ cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:26
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`][3] for\n"
"that:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ ì˜¤ë¥˜ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ [`thiserror`][3]ë„ ì¶”ê°€í•©ë‹ˆë‹¤:"

#: src/exercises/day-4/link-checker.md:29
msgid ""
"```shell\n"
"$ cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:33
msgid "The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "ëª¨ë“  `cargo add`ê°€ ëë‚˜ë©´ `Cargo.toml`ì— ì•„ë˜ ë‚´ìš©ì´ ì¶”ê°€ë©ë‹ˆë‹¤:"

#: src/exercises/day-4/link-checker.md:35
msgid ""
"```toml\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:42
msgid ""
"You can now download the start page. Try with a small site such as\n"
"`https://www.google.org/`."
msgstr "ì´ì œ `https://www.google.org/` ê°™ì€ ì›¹ í˜ì´ì§€ë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-4/link-checker.md:45
msgid "Your `src/main.rs` file should look something like this:"
msgstr "`rc/main.rs`íŒŒì¼ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/exercises/day-4/link-checker.md:47
msgid ""
"```rust,compile_fail\n"
"use reqwest::blocking::{get, Response};\n"
"use reqwest::Url;\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;"
msgstr ""

#: src/exercises/day-4/link-checker.md:53
msgid ""
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"}"
msgstr ""

#: src/exercises/day-4/link-checker.md:59
msgid ""
"fn extract_links(response: Response) -> Result<Vec<Url>, Error> {\n"
"    let base_url = response.url().to_owned();\n"
"    let document = response.text()?;\n"
"    let html = Html::parse_document(&document);\n"
"    let selector = Selector::parse(\"a\").unwrap();"
msgstr ""

#: src/exercises/day-4/link-checker.md:65
msgid ""
"    let mut valid_urls = Vec::new();\n"
"    for element in html.select(&selector) {\n"
"        if let Some(href) = element.value().attr(\"href\") {\n"
"            match base_url.join(href) {\n"
"                Ok(url) => valid_urls.push(url),\n"
"                Err(err) => {\n"
"                    println!(\"On {base_url}: could not parse {href:?}: {err} (ignored)\",);\n"
"                }\n"
"            }\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-4/link-checker.md:77
msgid ""
"    Ok(valid_urls)\n"
"}"
msgstr ""

#: src/exercises/day-4/link-checker.md:80
msgid ""
"fn main() {\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let response = get(start_url).unwrap();\n"
"    match extract_links(response) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:90
msgid "Run the code in `src/main.rs` with"
msgstr "ì•„ë˜ ì»¤ë§¨ë“œë¡œ ì†ŒìŠ¤ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤"

#: src/exercises/day-4/link-checker.md:92
msgid ""
"```shell\n"
"$ cargo run\n"
"```"
msgstr ""

#: src/exercises/day-4/link-checker.md:96
msgid "## Tasks"
msgstr "## í•  ì¼"

#: src/exercises/day-4/link-checker.md:98
msgid ""
"* Use threads to check the links in parallel: send the URLs to be checked to a\n"
"  channel and let a few threads check the URLs in parallel.\n"
"* Extend this to recursively extract links from all pages on the\n"
"  `www.google.org` domain. Put an upper limit of 100 pages or so so that you\n"
"  don't end up being blocked by the site."
msgstr ""
"* ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë§í¬ë¥¼ ë³‘ë ¬ë¡œ í™•ì¸í•©ë‹ˆë‹¤: URLì„ ì±„ë„ë¡œ ë³´ë‚´ì„œ ëª‡ ê°œì˜ ìŠ¤ë ˆë“œê°€ URLì„ ë³‘ë ¬ë¡œ ì²´í¬í•˜ë„ë¡ í•©ë‹ˆë‹¤.\n"
"* `www.google.org`ë„ë©”ì¸ì˜ ëª¨ë“  í˜ì´ì§€ë¥¼ ì¬ê·€ì ìœ¼ë¡œ í™•ì¸í•˜ê¸° ìœ„í•´ ì½”ë“œë¥¼ í™•ì¥í•´ì„œ ì‘ì„±í•©ë‹ˆë‹¤: ì°¨ë‹¨ë‹¹í•˜ì§€ ì•Šë„ë¡ 100í˜ì´ì§€ ì •ë„ë¡œ ì œí•œì„ ë‘ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/exercises/day-4/link-checker.md:104
msgid ""
"[1]: https://docs.rs/reqwest/\n"
"[2]: https://docs.rs/scraper/\n"
"[3]: https://docs.rs/thiserror/"
msgstr ""

#: src/android.md:1
msgid "# Android"
msgstr "# ì•ˆë“œë¡œì´ë“œ"

#: src/android.md:3
msgid ""
"Rust is supported for native platform development on Android. This means that\n"
"you can write new operating system services in Rust, as well as extending\n"
"existing services."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì•ˆë“œë¡œì´ë“œ ë„¤ì´í‹°ë¸Œ í”Œë«í¼ ê°œë°œì„ ì§€ì›í•©ë‹ˆë‹¤. ê¸°ì¡´ì˜ OS ì„œë¹„ìŠ¤ë¥¼ í™•ì¥í•˜ê±°ë‚˜, ìƒˆë¡œìš´ ì„œë¹„ìŠ¤ë¥¼ ë§Œë“œëŠ”ë° ëŸ¬ìŠ¤íŠ¸ë¥¼ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/android/setup.md:1
msgid "# Setup"
msgstr "# ì„¤ì¹˜"

#: src/android/setup.md:3
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you have\n"
"access to one or create a new one with:"
msgstr "ì•ˆë“œë¡œì´ë“œ ê°€ìƒ ë””ë°”ì´ìŠ¤(Android Virtual Device)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ë¶„ì˜ ì½”ë“œë¥¼ ìˆ˜í–‰í•  ê²ë‹ˆë‹¤. ìƒˆë¡œìš´ ê°€ìƒ ë””ë°”ì´ìŠ¤ë¥¼ ìƒì„±í•˜ë ¤ë©´ ì•„ë˜ì˜ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"$ source build/envsetup.sh\n"
"$ lunch aosp_cf_x86_64_phone-userdebug\n"
"$ acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
msgid ""
"Please see the [Android Developer\n"
"Codelab](https://source.android.com/docs/setup/start) for details."
msgstr "ìì„¸í•œ ë‚´ìš©ì€ [Android Developer Codelab](https://source.android.com/docs/setup/start)ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/android/build-rules.md:1
msgid "# Build Rules"
msgstr "# ë¹Œë“œ ê·œì¹™(Build Rules)"

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr "ì•ˆë“œë¡œì´ë“œ ë¹Œë“œ ì‹œìŠ¤í…œ(Soong)ì€ ë‹¤ìŒê³¼ ê°™ì€ ì—¬ëŸ¬ ëª¨ë“ˆì„ í†µí•´ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/android/build-rules.md:5
msgid ""
"| Module Type       | Description                                                                                        |\n"
"|-------------------|----------------------------------------------------------------------------------------------------|\n"
"| `rust_binary`     | Produces a Rust binary.                                                                            |\n"
"| `rust_library`    | Produces a Rust library, and provides both `rlib` and `dylib` variants.                            |\n"
"| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and provides both static and shared variants.    |\n"
"| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are analogous to compiler plugins.                     |\n"
"| `rust_test`       | Produces a Rust test binary that uses the standard Rust test harness.                              |\n"
"| `rust_fuzz`       | Produces a Rust fuzz binary leveraging `libfuzzer`.                                                |\n"
"| `rust_protobuf`   | Generates source and produces a Rust library that provides an interface for a particular protobuf. |\n"
"| `rust_bindgen`    | Generates source and produces a Rust library containing Rust bindings to C libraries.              |"
msgstr ""
"| Module Type       | Description                                          |\n"
"|-------------------|------------------------------------------------------|\n"
"| `rust_binary`     | ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|\n"
"| `rust_library`    | ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬(rlibí˜¹ì€ dylib)ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|\n"
"| `rust_ffi`        | cc ëª¨ë“ˆì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” C library (ì •ì  í˜¹ì€ ë™ì )ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|\n"
"| `rust_proc_macro` | `proc-macro`ë¥¼ êµ¬í˜„í•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ì˜ í”ŒëŸ¬ê·¸ì¸ìœ¼ë¡œ ìƒê°í•´ë„ ì¢‹ìŠµë‹ˆë‹¤.|\n"
"| `rust_test`       | í‘œì¤€ ëŸ¬ìŠ¤íŠ¸ í…ŒìŠ¤íŠ¸ ëŸ¬ë„ˆë¥¼ ì‚¬ìš©í•˜ëŠ” í…ŒìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|\n"
"| `rust_fuzz`       | `libfuzzer`ë¥¼ ì‚¬ìš©í•˜ì—¬ fuzz ë°”ì´ë„ˆë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|\n"
"| `rust_protobuf`   | í”„ë¡œí† ë²„í”„(protobuf) ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|\n"
"| `rust_bindgen`    | C ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ ëŸ¬ìŠ¤íŠ¸ ë°”ì¸ë”©ì„ ì œê³µí•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.|"

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "ë‹¤ìŒì€ `rust_binary`ì™€ `rust_library`ë¥¼ ì‚´í´ë´…ë‹ˆë‹¤."

#: src/android/build-rules/binary.md:1
msgid "# Rust Binaries"
msgstr "# ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬"

#: src/android/build-rules/binary.md:3
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, create\n"
"the following files:"
msgstr "ê°„ë‹¨í•œ ì‘ìš© í”„ë¡œê·¸ë¨ìœ¼ë¡œ ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤. AOSP ì²´í¬ì•„ì›ƒì˜ ë£¨íŠ¸ì—ì„œ ë‹¤ìŒ íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr ""

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr ""

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo."
msgstr ""

#: src/android/build-rules/binary.md:21
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ, ì´ ë°”ì´ë„ˆë¦¬ë¥¼ ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ì— ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"$ m hello_rust\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
msgid "# Rust Libraries"
msgstr "# ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/android/build-rules/library.md:3
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "`rust_library`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆë“œë¡œì´ë“œìš© ìƒˆ ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤."

#: src/android/build-rules/library.md:5
msgid "Here we declare a dependency on two libraries:"
msgstr "ì—¬ê¸°ì„œ ë‘ ê°œì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ ì˜ì¡´ì„±ì„ ì„ ì–¸í•©ë‹ˆë‹¤:"

#: src/android/build-rules/library.md:7
msgid ""
"* `libgreeting`, which we define below,\n"
"* `libtextwrap`, which is a crate already vendored in\n"
"  [`external/rust/crates/`][crates]."
msgstr ""
"* ì•„ë˜ì— ì •ì˜í•œ `libgreeting`.\n"
"* [`external/rust/crates/`][crates]ì— ì¡´ì¬í•˜ëŠ” `libtextwrap`."

#: src/android/build-rules/library.md:11
msgid "[crates]: https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"
msgstr ""

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}"
msgstr ""

#: src/android/build-rules/library.md:27
msgid ""
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo."
msgstr ""

#: src/android/build-rules/library.md:39
msgid ""
"use greetings::greeting;\n"
"use textwrap::fill;"
msgstr ""

#: src/android/build-rules/library.md:42
msgid ""
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr ""

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library."
msgstr ""

#: src/android/build-rules/library.md:53
msgid ""
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "ì´ì „ì²˜ëŸ¼, ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ë¡œ ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:1
msgid "# AIDL"
msgstr "# AIDL"

#: src/android/aidl.md:3
msgid ""
"The [Android Interface Definition Language\n"
"(AIDL)](https://developer.android.com/guide/components/aidl) is supported in Rust:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” [ì•ˆë“œë¡œì´ë“œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜ ì–¸ì–´(AIDL)](https://developer.android.com/guide/components/aidl)ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/android/aidl.md:6
msgid ""
"* Rust code can call existing AIDL servers,\n"
"* You can create new AIDL servers in Rust."
msgstr ""
"* ëŸ¬ìŠ¤íŠ¸ ì½”ë“œì—ì„œ ê¸°ì¡´ AIDL ì„œë²„ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. \n"
"* ëŸ¬ìŠ¤íŠ¸ì—ì„œ ìƒˆë¡œìš´ AIDL ì„œë²„ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/android/aidl/interface.md:1
msgid "# AIDL Interfaces"
msgstr "# AIDL ì¸í„°í˜ì´ìŠ¤"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "AIDL ì¸í„°í˜ì´ìŠ¤ë¥¼ ì´ìš©í•´ì„œ ì„œë¹„ìŠ¤ì˜ APIë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤:"

#: src/android/aidl/interface.md:5
msgid "*birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl*:"
msgstr ""

#: src/android/aidl/interface.md:7 src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;"
msgstr ""

#: src/android/aidl/interface.md:10
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:17
msgid "*birthday_service/aidl/Android.bp*:"
msgstr ""

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the vendor\n"
"partition."
msgstr "AIDL íŒŒì¼ì´ ë²¤ë” íŒŒí‹°ì…˜ì— ìˆëŠ” ë°”ì´ë„ˆë¦¬ì—ì„œ ì‚¬ìš©ë  ê²½ìš° `vendor_available: true`ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤."

#: src/android/aidl/implementation.md:1
msgid "# Service Implementation"
msgstr "# ì„œë¹„ìŠ¤ êµ¬í˜„"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "ì´ì œ AIDLì„œë¹„ìŠ¤ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/implementation.md:5
msgid "*birthday_service/src/lib.rs*:"
msgstr ""

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/implementation.md:12
msgid ""
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;"
msgstr ""

#: src/android/aidl/implementation.md:15
msgid "impl binder::Interface for BirthdayService {}"
msgstr ""

#: src/android/aidl/implementation.md:17
msgid ""
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
msgid "*birthday_service/Android.bp*:"
msgstr ""

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
msgid "# AIDL Server"
msgstr "# AIDL ì„œë²„"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ì„œë²„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/server.md:5
msgid "*birthday_service/src/server.rs*:"
msgstr ""

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/server.md:13 src/android/aidl/client.md:12
msgid "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";"
msgstr ""

#: src/android/aidl/server.md:15
msgid ""
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:1
msgid "# Deploy"
msgstr "# ë°°í¬"

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "ì„œë¹„ìŠ¤ë¥¼ ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ì— ë„£ê³ , ì‹œì‘ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
msgid "In another terminal, check that the service runs:"
msgstr "ë‹¤ë¥¸ í„°ë¯¸ë„ì„ ë„ì›Œì„œ ì„œë¹„ìŠ¤ê°€ ì˜ ìˆ˜í–‰ë˜ê³  ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"$ adb shell service check birthdayservice\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:18
msgid "You can also call the service with `service call`:"
msgstr "`service call`ëª…ë ì–´ë¡œ ì„œë¹„ìŠ¤ë¥¼ í˜¸ì¶œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/deploy.md:20
msgid ""
"```shell\n"
"$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
msgid "# AIDL Client"
msgstr "# AIDL í´ë¼ì´ì–¸íŠ¸"

#: src/android/aidl/client.md:3
msgid "Finally, we can create a Rust client for our new service."
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ, ì•„ê¹Œ ì¶”ê°€í•œ ì„œë¹„ìŠ¤ì— ëŒ€í•œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ëŸ¬ìŠ¤íŠ¸ë¡œ ë§Œë“¤ê² ìŠµë‹ˆë‹¤."

#: src/android/aidl/client.md:5
msgid "*birthday_service/src/client.rs*:"
msgstr ""

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;"
msgstr ""

#: src/android/aidl/client.md:14
msgid ""
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}"
msgstr ""

#: src/android/aidl/client.md:19
msgid ""
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);"
msgstr ""

#: src/android/aidl/client.md:29
msgid ""
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "í´ë¼ì´ì–¸íŠ¸ëŠ” `libbirthdayservice`ì— ì˜ì¡´í•˜ì§€ ì•ŠìŒì— ì£¼ëª©í•˜ì„¸ìš”."

#: src/android/aidl/client.md:54
msgid "Build, push, and run the client on your device:"
msgstr "ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ë¡œ ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"$ m birthday_client\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp\n"
"$ adb shell /data/local/tmp/birthday_client Charlie 60\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:1
msgid "# Changing API"
msgstr "# API ìˆ˜ì •"

#: src/android/aidl/changing.md:3
msgid ""
"Let us extend the API with more functionality: we want to let clients specify a\n"
"list of lines for the birthday card:"
msgstr "APIë¥¼ í™•ì¥í•˜ì—¬ ë” ë§ì€ ê¸°ëŠ¥ì„ ì œê³µí•´ ë´…ì‹œë‹¤. í´ë¼ì´ì–¸íŠ¸ê°€ ìƒì¼ ì¹´ë“œì— ë‹´ê¸¸ ë‚´ìš©ì„ ì§€ì •í•  ìˆ˜ ìˆë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤:"

#: src/android/aidl/changing.md:9
msgid ""
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:1
msgid "# Logging"
msgstr "# ë¡œê¹…"

#: src/android/logging.md:3
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) or\n"
"`stdout` (on-host):"
msgstr "`log` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ ì•ˆë“œë¡œì´ë“œ ë””ë°”ì´ìŠ¤ ì•ˆì—ì„œ ìˆ˜í–‰ë  ë•Œì—ëŠ” `logcat`ìœ¼ë¡œ, í˜¸ìŠ¤íŠ¸ì—ì„œ ìˆ˜í–‰ë  ë•Œì—ëŠ” `stdout`ìœ¼ë¡œ ë¡œê·¸ê°€ ìë™ìœ¼ë¡œ ì¶œë ¥ì´ ë˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr ""

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
msgid "_hello_rust_logs/src/main.rs_:"
msgstr ""

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo."
msgstr ""

#: src/android/logging.md:27
msgid "use log::{debug, error, info};"
msgstr ""

#: src/android/logging.md:29
msgid ""
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
msgid "Build, push, and run the binary on your device:"
msgstr "ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ì— ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
msgid "The logs show up in `adb logcat`:"
msgstr "`adb logcat`ì»¤ë§¨ë“œë¡œ ë¡œê·¸ë¥¼ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"$ adb logcat -s rust\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:1
msgid "# Interoperability"
msgstr "# ìƒí˜¸ìš´ìš©ì„±(Interoperability)"

#: src/android/interoperability.md:3
msgid ""
"Rust has excellent support for interoperability with other languages. This means\n"
"that you can:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë‹¤ë¥¸ ì–¸ì–´ì™€ì˜ ìƒí˜¸ìš´ìš©ì„±ì„ í›Œë¥­íˆ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/android/interoperability.md:6
msgid ""
"* Call Rust functions from other languages.\n"
"* Call functions written in other languages from Rust."
msgstr ""
"* íƒ€ ì–¸ì–´ì—ì„œ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.\n"
"* íƒ€ ì–¸ì–´ì˜ í•¨ìˆ˜ë¥¼ ëŸ¬ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œí•©ë‹ˆë‹¤."

#: src/android/interoperability.md:9
msgid ""
"When you call functions in a foreign language we say that you're using a\n"
"_foreign function interface_, also known as FFI."
msgstr "íƒ€ ì–¸ì–´ì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ FFI(foreign function interface)ë¼ê³  í•©ë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:1
msgid "# Interoperability with C"
msgstr "# Cì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention.\n"
"Similarly, you can export Rust functions and call them from C."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” C í˜¸ì¶œê·œì•½ì„ ë”°ë¥´ëŠ” ì˜¤ë¸Œì íŠ¸ íŒŒì¼ê³¼ ë§í‚¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ, ë°˜ëŒ€ë¡œ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ë‚´ë³´ë‚´ì„œ Cì—ì„œ í˜¸ì¶œ í•  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "ì›í•œë‹¤ë©´ ì•„ë˜ì™€ ê°™ì´ ìˆ˜ë™ìœ¼ë¡œ ì½”ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}"
msgstr ""

#: src/android/interoperability/with-c.md:13
msgid ""
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper\n"
"exercise](../../exercises/day-3/safe-ffi-wrapper.md)."
msgstr "ìš°ë¦¬ëŠ” ì´ë¯¸ [Safe FFI ë˜í¼ ì—°ìŠµë¬¸ì œ](../../exercises/day-3/safe-ffi-wrapper.md)ì—ì„œ ì´ë¥¼ ë‹¤ë£¨ì—ˆìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:23
msgid ""
"> This assumes full knowledge of the target platform. Not recommended for\n"
"> production."
msgstr "> ì´ëŸ¬í•œ ë°©ë²•ì€ íƒ€ê²Ÿ í”Œë«í¼ì˜ ëª¨ë“  ë¶€ë¶„ì„ ì‚¬ì „ì— ì•Œê³  ìˆë‹¤ëŠ” ì „ì œë¥¼ ê¹”ê³  ìˆìŠµë‹ˆë‹¤. ìƒìš© í”„ë¡œì íŠ¸ì—ì„œëŠ” ê¶Œì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "ì¢€ ë” ë‚˜ì€ ì˜µì…˜ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c/bindgen.md:1
msgid "# Using Bindgen"
msgstr "# Bindgen ì‚¬ìš©í•˜ê¸°"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) tool\n"
"can auto-generate bindings from a C header file."
msgstr "[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)ëŠ” C í—¤ë”íŒŒì¼ì—ì„œ ëŸ¬ìŠ¤íŠ¸ ë°”ì¸ë”©ì„ ìë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ë„êµ¬ì…ë‹ˆë‹¤."

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "ë¨¼ì € ì‘ì€ Cë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:16
msgid ""
"void print_card(const card* card);\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:25
msgid ""
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr "`Android.bp` íŒŒì¼ì— ì•„ë˜ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
msgid "_interoperability/bindgen/Android.bp_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this\n"
"example):"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ í—¤ë” íŒŒì¼ì„ ë§Œë“­ë‹ˆë‹¤(ì´ ì˜ˆì‹œì—ì„œëŠ” ë°˜ë“œì‹œ í•„ìš”í•œ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤.):"

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "ì´ì œ ë°”ì¸ë”©ì„ ìë™ìœ¼ë¡œ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "ë§ˆì¹¨ë‚´, ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ì—ì„œ ë°”ì¸ë”©ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo."
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:84
msgid "use birthday_bindgen::{card, print_card};"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:86
msgid ""
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"$ m print_birthday_card\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp\n"
"$ adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ, ë°”ì¸ë”©ì´ ì˜ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´, ìë™ ìƒì„±ëœ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"$ atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
msgid "# Calling Rust"
msgstr "# Cì—ì„œ ëŸ¬ìŠ¤íŠ¸ í˜¸ì¶œ"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ íƒ€ì…ê³¼ í•¨ìˆ˜ë¥¼ Cë¡œ ë‚´ë³´ë‚´ëŠ” ê²ƒì€ ê°„ë‹¨í•©ë‹ˆë‹¤:"

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]"
msgstr ""

#: src/android/interoperability/with-c/rust.md:11
msgid "use std::os::raw::c_int;"
msgstr ""

#: src/android/interoperability/with-c/rust.md:13
msgid ""
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H"
msgstr ""

#: src/android/interoperability/with-c/rust.md:30
msgid ""
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}"
msgstr ""

#: src/android/interoperability/with-c/rust.md:34
msgid ""
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "ì´ì œ ì´ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ Cë°”ì´ë„ˆë¦¬ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:55
msgid ""
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"$ m analyze_numbers\n"
"$ adb push $ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp\n"
"$ adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol will just be the name of\n"
"the function. You can also use `#[export_name = \"some_name\"]` to specify whatever name you want."
msgstr "`#[no_mangle]`ì€ ëŸ¬ìŠ¤íŠ¸ì˜ ë„¤ì„ ë§¹ê¸€ë§(name mangling)ì„ ë¹„í™œì„±í™”í•˜ë¯€ë¡œ ì™¸ë¶€ë¡œ ë…¸ì¶œë˜ëŠ” ì‹¬ë³¼ì˜ ì´ë¦„ì€ í•¨ìˆ˜ì˜ ì´ë¦„ ê·¸ëŒ€ë¡œê°€ ë©ë‹ˆë‹¤. ì‹¬ë³¼ ì´ë¦„ì„ ë°”ê¾¸ê³  ì‹¶ë‹¤ë©´ `#[export_name = \"some_name\"]`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/android/interoperability/cpp.md:1
msgid "# With C++"
msgstr "# C++ ì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate][1] makes it possible to do safe interoperability between Rust\n"
"and C++."
msgstr "[CXX í¬ë ˆì´íŠ¸][1]ëŠ” ëŸ¬ìŠ¤íŠ¸ì™€ C++ ì‚¬ì´ì˜ ì•ˆì „í•œ ìƒí˜¸ìš´ìš©ì„±ì„ ê°€ëŠ¥í•˜ê²Œ í•´ì¤ë‹ˆë‹¤."

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "ì „ì²´ì ì¸ ì ‘ê·¼ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/android/interoperability/cpp.md:8
msgid "<img src=\"cpp/overview.svg\">"
msgstr ""

#: src/android/interoperability/cpp.md:10
msgid "See the [CXX tutorial][2] for an full example of using this."
msgstr "ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ì„œëŠ”[CXX íŠœí† ë¦¬ì–¼][2] ë¥¼ ì°¸ì¡°í•©ë‹ˆë‹¤."

#: src/android/interoperability/cpp.md:12
msgid ""
"[1]: https://cxx.rs/\n"
"[2]: https://cxx.rs/tutorial.html"
msgstr ""

#: src/android/interoperability/java.md:1
msgid "# Interoperability with Java"
msgstr "# Javaì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface\n"
"(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). The [`jni`\n"
"crate](https://docs.rs/jni/) allows you to create a compatible library."
msgstr "ìë°”ëŠ” [Java Native Interface(JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface)ë¥¼ í†µí•´ ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. [`jni` í¬ë ˆì´íŠ¸](https://docs.rs/jni/)ë¥¼ ì‚¬ìš©í•˜ì—¬ JNI ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/android/interoperability/java.md:7
msgid "First, we create a Rust function to export to Java:"
msgstr "ë¨¼ì €, ìë°”ë¡œ ë‚´ë³´ë‚¼ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/android/interoperability/java.md:9
msgid "_interoperability/java/src/lib.rs_:"
msgstr ""

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo."
msgstr ""

#: src/android/interoperability/java.md:14
msgid ""
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;"
msgstr ""

#: src/android/interoperability/java.md:18
msgid ""
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
msgid "_interoperability/java/Android.bp_:"
msgstr ""

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
msgid "Finally, we can call this function from Java:"
msgstr "ìë°”ì—ì„œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/java.md:45
msgid "_interoperability/java/HelloWorld.java_:"
msgstr ""

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);"
msgstr ""

#: src/android/interoperability/java.md:51
msgid ""
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }"
msgstr ""

#: src/android/interoperability/java.md:55
msgid ""
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
msgid "Finally, you can build, sync, and run the binary:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ ë°”ì´ë„ˆë¦¬ë¥¼ ë¹Œë“œ, ì‹±í¬, ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"$ m helloworld_jni\n"
"$ adb sync  # requires adb root && adb remount\n"
"$ adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/day-4/afternoon.md:3
msgid ""
"For the last exercise, we will look at one of the projects you work with. Let us\n"
"group up and do this together. Some suggestions:"
msgstr "ë§ˆì§€ë§‰ ì—°ìŠµë¬¸ì œëŠ” ì—¬ëŸ¬ë¶„ì´ ì‘ì—…í•˜ê³  ìˆëŠ” í”„ë¡œì íŠ¸ ì¤‘ í•˜ë‚˜ë¥¼ FFIë¡œ ëŸ¬ìŠ¤íŠ¸ì™€ ì—°ê³„ í•´ë³´ëŠ” ê²ƒì…ë‹ˆë‹¤. ëª‡ ê°€ì§€ ì˜ˆì‹œì…ë‹ˆë‹¤:"

#: src/exercises/day-4/afternoon.md:6
msgid "* Call your AIDL service with a client written in Rust."
msgstr "* ë‹¹ì‹ ì˜ AIDLì„œë¹„ìŠ¤ë¥¼ ëŸ¬ìŠ¤íŠ¸ í´ë¼ì´ì–¸íŠ¸ì—ì„œ í˜¸ì¶œí•´ë´…ë‹ˆë‹¤."

#: src/exercises/day-4/afternoon.md:8
msgid "* Move a function from your project to Rust and call it."
msgstr "* ë‹¹ì‹ ì˜ í”„ë¡œì íŠ¸ì˜ í•¨ìˆ˜ë¥¼ ëŸ¬ìŠ¤íŠ¸ë¡œ ì˜®ê¸°ê³  í˜¸ì¶œí•´ë´…ë‹ˆë‹¤."

#: src/exercises/day-4/afternoon.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone in\n"
"the class having a piece of code which you can turn in to Rust on the fly."
msgstr "ì´ ì—°ìŠµë¬¸ì œëŠ” ì—´ë ¤ìˆê¸° ë•Œë¬¸ì— í•´ë‹µì´ ì œê³µë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í´ë˜ìŠ¤ì—ì„œ ì œì¶œëœ ì½”ë“œì— ì˜ì¡´í•©ë‹ˆë‹¤."

#: src/thanks.md:1
msgid "# Thanks!"
msgstr "# ê°ì‚¬ì¸ì‚¬"

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust ğŸ¦€!_ We hope you enjoyed it and that it\n"
"was useful."
msgstr "Comprehensive Rust ğŸ¦€ë¥¼ ì´ìš©í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤. ì¦ê²ê³  ìœ ìµí•œ ì‹œê°„ì´ì—ˆê¸°ë¥¼ ë°”ëë‹ˆë‹¤."

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not perfect,\n"
"so if you spotted any mistakes or have ideas for improvements, please get in\n"
"[contact with us on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). We would love\n"
"to hear from you."
msgstr "ê°•ì˜ê°€ ì™„ë²½í•˜ì§„ ì•Šìœ¼ë‹ˆ ì‹¤ìˆ˜ë‚˜ ê°œì„ ì ì´ ìˆë‹¤ë©´ ì–¸ì œë“ ì§€ [ê¹ƒí—ˆë¸Œ](https://github.com/google/comprehensive-rust/discussions)ë¡œ ì—°ë½ì£¼ì„¸ìš”."

#: src/other-resources.md:1
msgid "# Other Rust Resources"
msgstr "# ëŸ¬ìŠ¤íŠ¸ ì°¸ê³  ìë£Œ"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources\n"
"online."
msgstr "ëŸ¬ìŠ¤íŠ¸ ì»¤ë®¤ë‹ˆí‹°ëŠ” ì˜¨ë¼ì¸ì—ì„œ ê³ í’ˆì§ˆì˜ ë¬´ë£Œ ì†ŒìŠ¤ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤."

#: src/other-resources.md:6
msgid "## Official Documentation"
msgstr "## ê³µì‹ ë¬¸ì„œë“¤"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "ëŸ¬ìŠ¤íŠ¸ í”„ë¡œì íŠ¸ì—ëŠ” ì°¸ì¡°í•  ë§Œí•œ ìë£Œê°€ ë§ìŠµë‹ˆë‹¤. ì¼ë°˜ì ì¸ ë‚´ìš©ì„ ë‹¤ë£¨ëŠ” ëª‡ê°€ì§€ ì°¸ê³  ë¬¸ì„œë“¤ì…ë‹ˆë‹¤:"

#: src/other-resources.md:10
msgid ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): the\n"
"  canonical free book about Rust. Covers the language in detail and includes a\n"
"  few projects for people to build.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the Rust\n"
"  syntax via a series of examples which showcase different constructs. Sometimes\n"
"  includes small exercises where you are asked to expand on the code in the\n"
"  examples.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): full documentation of\n"
"  the standard library for Rust.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete book\n"
"  which describes the Rust grammar and memory model."
msgstr ""
"* [The Rust Programming Language](https://doc.rust-lang.org/book/): ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•œ ë¬´ë£Œ í‘œì¤€ ì„œì ì…ë‹ˆë‹¤. ì–¸ì–´ì— ëŒ€í•œ ìì„¸í•œ ì„¤ëª…ê³¼ ì‚¬ëŒë“¤ì´ ë¹Œë“œ í• ìˆ˜ ìˆëŠ” ëª‡ê°€ì§€ í”„ë¡œì íŠ¸ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.\n"
"* [Rust By Example](https://doc.rust-lang.org/rust-by-example/): ì—¬ëŸ¬ ì˜ˆì œë¥¼ í†µí•´ ëŸ¬ìŠ¤íŠ¸ì˜ ë¬¸ë²•ì„ ë³´ì—¬ì£¼ë©° ë•Œë•Œë¡œ ì½”ë“œë¥¼ í™•ì¥í•˜ëŠ” ì•½ê°„ì˜ ì—°ìŠµë¬¸ì œë“¤ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.\n"
"* [Rust Standard Library](https://doc.rust-lang.org/std/): ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì „ì²´ ë¬¸ì„œì…ë‹ˆë‹¤.\n"
"* [The Rust Reference](https://doc.rust-lang.org/reference/): ë©”ëª¨ë¦¬ ëª¨ë¸ë§ê³¼ ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•ì„ ì„¤ëª…í•˜ëŠ” ë¬¸ì„œì…ë‹ˆë‹¤.(ì•„ì§ ë¶ˆì™„ì „í•˜ë‹¤í•¨)"

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "ì¢€ ë” ì „ë¬¸ì ì¸ ê³µì‹ ê°€ì´ë“œì…ë‹ˆë‹¤:"

#: src/other-resources.md:24
msgid ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust,\n"
"  including working with raw pointers and interfacing with other languages\n"
"  (FFI).\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/):\n"
"  covers the new asynchronous programming model which was introduced after the\n"
"  Rust Book was written.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an\n"
"  introduction to using Rust on embedded devices without an operating system."
msgstr ""
"* [The Rustonomicon](https://doc.rust-lang.org/nomicon/): ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸, FFI, rawí¬ì¸í„° ì‘ì—…ì„ ë‹¤ë£¹ë‹ˆë‹¤.\n"
"* [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): ëŸ¬ìŠ¤íŠ¸ ë¶ì´ ì‘ì„± ëœ ì´í›„ ë„ì…ëœ ìƒˆë¡œìš´ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ë‹¤ë£¹ë‹ˆë‹¤.\n"
"* [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): ìš´ì˜ì²´ì œê°€ ì—†ëŠ” ì„ë² ë””ë“œ ì¥ì¹˜ì—ì„œì˜ ëŸ¬ìŠ¤íŠ¸ ì‚¬ìš©ë²•ì„ ì†Œê°œí•©ë‹ˆë‹¤."

#: src/other-resources.md:33
msgid "## Unofficial Learning Material"
msgstr "## ë¹„ê³µì‹ì  í•™ìŠµ ìë£Œ"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•œ ê¸°íƒ€ ì•ˆë‚´ì„œì™€ íŠœí† ë¦¬ì–¼ì˜ ì¼ë¶€ì…ë‹ˆë‹¤:"

#: src/other-resources.md:37
msgid ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust\n"
"  from the perspective of low-level C programmers.\n"
"* [Rust for Embedded C\n"
"  Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): covers Rust from\n"
"  the perspective of developers who write firmware in C.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/):\n"
"  covers the syntax of Rust using side-by-side comparisons with other languages\n"
"  such as C, C++, Java, JavaScript, and Python.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help\n"
"  you learn Rust.\n"
"* [Ferrous Teaching\n"
"  Material](https://ferrous-systems.github.io/teaching-material/index.html): a\n"
"  series of small presentations covering both basic and advanced part of the\n"
"  Rust language. Other topics such as WebAssembly, and async/await are also\n"
"  covered.\n"
"* [Beginner's Series to\n"
"  Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/) and\n"
"  [Take your first steps with\n"
"  Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): two\n"
"  Rust guides aimed at new developers. The first is a set of 35 videos and the\n"
"  second is a set of 11 modules which covers Rust syntax and basic constructs.\n"
"* [Learn Rust With Entirely Too Many Linked\n"
"  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth\n"
"  exploration of Rust's memory management rules, through implementing a few\n"
"  different types of list structures."
msgstr ""
"* [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): Cì–¸ì–´ í”„ë¡œê·¸ë˜ë¨¸ ê´€ì ì—ì„œ ëŸ¬ìŠ¤íŠ¸ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.\n"
"* [Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/rust_for_c/): ì„ë² ë””ë“œ Cê°œë°œì(íŒì›¨ì–´ ê°œë°œì)ë¥¼ ìœ„í•œ ëŸ¬ìŠ¤íŠ¸ ê°€ì´ë“œì…ë‹ˆë‹¤.\n"
"* [Rust for professionals](https://overexact.com/rust-for-professionals/): ë‹¤ë¥¸ ì–¸ì–´(C/C++, Java, Python, Javascript)ì™€ì˜ ë³‘ë ¬ë¹„êµë¥¼ ì‚¬ìš©í•˜ì—¬ ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.\n"
"* [Rust on Exercism](https://exercism.org/tracks/rust): ëŸ¬ìŠ¤íŠ¸ë¥¼ ë°°ìš°ëŠ”ë° ë„ì›€ì´ ë˜ëŠ” 100ê°œ ì´ìƒì˜ ì—°ìŠµë¬¸ì œ\n"
"* [Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-material/index.html): ëŸ¬ìŠ¤íŠ¸ ì–¸ì–´ì˜ ê¸°ë³¸ë¶€í„° ê³ ê¸‰ì„ ì „ë¶€ ë‹¤ë£¨ëŠ” ì¼ë ¨ì˜ ì‘ì€ í”„ë ˆì  í…Œì´ì…˜, ì›¹ ì–´ì…ˆë¸”ë¦¬, async/await ê°™ì€ ë¶€ë¶„ë„ í•¨ê»˜ ë‹¤ë£¹ë‹ˆë‹¤.\n"
"* [Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/), [Take your first steps with Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/): ì²«ë²ˆì§¸ëŠ” 35ê°œì˜ ì‹œë¦¬ì¦ˆ ì˜ìƒì´ë©° ë‘ë²ˆì§¸ëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ë¬¸ë²•ê³¼ êµ¬ì¡°ë¥¼ ë‹¤ë£¨ëŠ” 11ê°œì˜ ëª¨ë“ˆ ì„¸íŠ¸ì…ë‹ˆë‹¤.\n"
"* [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/): ëª‡ê°€ì§€ ìœ í˜•ì˜ ë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡°ë¥¼ êµ¬í˜„í•´ë³´ë©´ì„œ ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê·œì¹™ë“¤ì„ ê¹Šì´ìˆê²Œ íƒìƒ‰í•©ë‹ˆë‹¤."

#: src/other-resources.md:63
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) for\n"
"even more Rust books."
msgstr "[Little Book of Rust Books](https://lborb.github.io/book/)ì—ì„œ ë” ë§ì€ ëŸ¬ìŠ¤íŠ¸ ë¶ì„ í™•ì¸í•´ë³´ì„¸ìš”."

#: src/credits.md:1
msgid "# Credits"
msgstr "# Credits"

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust documentation.\n"
"See the page on [other resources](other-resources.md) for a full list of useful\n"
"resources."
msgstr "ì´ ìë£ŒëŠ” ë§ì€ í›Œë¥­í•œ ëŸ¬ìŠ¤íŠ¸ ë¬¸ì„œë“¤ì˜ ë„ì›€ì„ ë°›ì•„ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ìœ ìš©í•œ ìë£Œì˜ ì „ì²´ ëª©ë¡ì€ [other resources](other-resources.md)ì—ì„œ ì‚´í´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:7
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache 2.0\n"
"license, please see [`LICENSE`](../LICENSE) for details."
msgstr "Comprehensive Rustì˜ ìë£ŒëŠ” Apache 2.0 ë¼ì´ì„ ìŠ¤ë¥¼ ë”°ë¦…ë‹ˆë‹¤. ìì„¸í•œê±´ [`LICENSE`](../LICENSE) í™•ì¸í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:10
msgid "## Rust by Example"
msgstr ""

#: src/credits.md:12
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by\n"
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the\n"
"`third_party/rust-by-example/` directory for details, including the license\n"
"terms."
msgstr "ì¼ë¶€ ì˜ˆì œì™€ ì—°ìŠµë¬¸ì œëŠ” [Rust by Example](https://doc.rust-lang.org/rust-by-example/)ì„ ì°¸ì¡°í•˜ì˜€ìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ ì¡°í•­ì„ í¬í•¨í•˜ì—¬ ì €ì¥ì†Œì˜ `third_party/rust-by-example/` í´ë”ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:17
msgid "## Rust on Exercism"
msgstr ""

#: src/credits.md:19
msgid ""
"Some exercises have been copied and adapted from [Rust on\n"
"Exercism](https://exercism.org/tracks/rust). Please see the\n"
"`third_party/rust-on-exercism/` directory for details, including the license\n"
"terms."
msgstr "ì¼ë¶€ ì—°ìŠµë¬¸ì œëŠ” [Rust on Exercism](https://exercism.org/tracks/rust)ì„ ì°¸ì¡°í•˜ì˜€ìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ ì¡°í•­ì„ í¬í•¨í•˜ì—¬ ì €ì¥ì†Œì˜ `third_party/rust-on-exercism/`í´ë”ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:24
msgid "## CXX"
msgstr ""

#: src/credits.md:26
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section uses an\n"
"image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` directory\n"
"for details, including the license terms."
msgstr "4ì¼ì°¨ ì˜¤í›„ ê°•ì˜ ì¤‘ [Interoperability with C++](android/interoperability/cpp.md)ì—ì„œëŠ” [CXX](https://cxx.rs/)ì˜ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ ì¡°í•­ì„ í¬í•¨í•˜ì—¬ ì €ì¥ì†Œì˜ `third_party/cxx/`í´ë”ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/exercises/solutions.md:1
msgid "# Solutions"
msgstr "# í•´ë‹µ"

#: src/exercises/solutions.md:3
msgid "You will find solutions to the exercises on the following pages."
msgstr "ì—°ìŠµë¬¸ì œì˜ í•´ë‹µì€ ë‹¤ìŒ í˜ì´ì§€ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/solutions.md:5
msgid ""
"Feel free to ask questions about the solutions [on\n"
"GitHub](https://github.com/google/comprehensive-rust/discussions). Let us know\n"
"if you have a different or better solution than what is presented here."
msgstr "[ê¹ƒí—ˆë¸Œ](https://github.com/google/comprehensive-rust/discussions)ì—ì„œ ì´ì— ëŒ€í•´ ììœ ë¡­ê²Œ ì§ˆë¬¸í•˜ì‹œê³  ë” ë‚˜ì€ ì†”ë£¨ì…˜ì´ ìˆë‹¤ë©´ ì•Œë ¤ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/exercises/solutions.md:10
msgid ""
"> **Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label`\n"
"> comments you see in the solutions. They are there to make it possible to\n"
"> re-use parts of the solutions as the exercises."
msgstr "> **ì°¸ê³ :** `// ANCHOR: label`ê³¼ `// ANCHOR_END: label` ì£¼ì„ì€ ë¬¸ì œë¥¼ êµ¬ì„±í•˜ê¸° ìœ„í•œ ë©”íƒ€ ì£¼ì„ìœ¼ë¡œ ë¬´ì‹œí•˜ì‹œë©´ ë©ë‹ˆë‹¤."

#: src/exercises/day-1/solutions-morning.md:1
msgid "# Day 1 Morning Exercises"
msgstr "# 1ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-1/solutions-morning.md:3
msgid "## Arrays and `for` Loops"
msgstr "## ë°°ì—´ê³¼ `for`ë°˜ë³µë¬¸"

#: src/exercises/day-1/solutions-morning.md:5
msgid "([back to exercise](for-loops.md))"
msgstr "([ì—°ìŠµë¬¸ì œë¡œ ëŒì•„ê°€ê¸°](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
#: src/exercises/day-1/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-morning.md:7
#: src/exercises/day-2/solutions-afternoon.md:7
#: src/exercises/day-2/solutions-afternoon.md:102
#: src/exercises/day-3/solutions-morning.md:7
#: src/exercises/day-3/solutions-afternoon.md:7
#: src/exercises/day-4/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License."
msgstr ""

#: src/exercises/day-1/solutions-morning.md:22
msgid ""
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:34
msgid ""
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:42
msgid ""
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:62
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:73
msgid ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```\n"
"### Bonus question"
msgstr ""
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```\n"
"\n"
"### ë³´ë„ˆìŠ¤ ë¬¸ì œ"

#: src/exercises/day-1/solutions-morning.md:80
msgid "It requires more advanced concepts. It might seem that we could use a slice-of-slices (`&[&[i32]]`) as the input type to transpose and thus make our function handle any size of matrix. However, this quickly breaks down: the return type cannot be `&[&[i32]]` since it needs to own the data you return."
msgstr "ì‚¬ì‹¤ ì´ ë¬¸ì œëŠ” ê³ ê¸‰ ê°œë…ì´ í•„ìš”í•©ë‹ˆë‹¤. ìŠ¬ë¼ì´ìŠ¤ì˜ ìŠ¬ë¼ì´ìŠ¤(slice-of-slices, `&[&[i32]]`)ë¥¼ ì…ë ¥ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ëª¨ë“  í¬ê¸°ì˜ í–‰ë ¬ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆì„ê²ƒ ê°™ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì œë¡œ í•´ë³´ë©´ ê¸ˆë°© ì•ˆëœë‹¤ëŠ” ê±¸ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜í™˜ê°’ì„ ì†Œìœ í•´ì•¼ í•˜ê¸°ë•Œë¬¸ì— `&[&[i32]]` ë°˜í™˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/exercises/day-1/solutions-morning.md:82
msgid "You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to `&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr "`Vec<Vec<i32>>`ì™€ ê°™ì€ íƒ€ì…ì„ ì‚¬ìš©í•˜ë ¤ê³  ì‹œë„í•  ìˆ˜ë„ ìˆì§€ë§Œ ì—­ì‹œ ì‰½ê²Œ ë˜ì§„ ì•ŠìŠµë‹ˆë‹¤. `Vec<Vec<i32>>` íƒ€ì…ì„ `&[&[i32]]`ë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì´ ì–´ë µê¸° ë•Œë¬¸ì— `pretty_print`ì„ ì‚¬ìš©í•˜ëŠ”ë° ì–´ë ¤ì›€ì´ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-1/solutions-morning.md:84
msgid "Once we get to traits and generics, we'll be able to use the [`std::convert::AsRef`][1] trait to abstract over anything that can be referenced as a slice."
msgstr "íŠ¸ë ˆì‡ë‚˜ ì œë„¤ë¦­ì„ ë‹¤ë£¨ê³  ë‚˜ë©´ [`std::convert::AsRef`][1] íŠ¸ë ˆì‡ì„ ì‚¬ìš©í•˜ì—¬ ìŠ¬ë¼ì´ìŠ¤ì²˜ëŸ¼ ì‚¬ìš©ë  ìˆ˜ ìˆëŠ” íƒ€ì…ì„ ì¶”ìƒí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:90
msgid ""
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:103
msgid ""
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
msgid "In addition, the type itself would not enforce that the child slices are of the same length, so such variable could contain an invalid matrix."
msgstr "ë˜í•œ, ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…ì€ ê¸¸ì´ë¥¼ í¬í•¨í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— í•œ ë‹¨ê³„ ì•„ë˜ì˜ ìŠ¬ë¼ì´ìŠ¤ë“¤ì´ ê°™ì€ ê¸¸ì´ì„ì„ ë³´ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë•Œë¬¸ì— ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…ì˜ ë³€ìˆ˜ì—ëŠ” ì˜ëª»ëœ í–‰ë ¬ì´ ì „ë‹¬ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/day-1/solutions-morning.md:115
msgid "[1]: https://doc.rust-lang.org/std/convert/trait.AsRef.html"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:1
msgid "# Day 1 Afternoon Exercises"
msgstr "# 1ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-1/solutions-afternoon.md:3
msgid "## Designing a Library"
msgstr "## ë„ì„œê´€ ì„¤ê³„"

#: src/exercises/day-1/solutions-afternoon.md:5
msgid "([back to exercise](book-library.md))"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:22
msgid ""
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:42
msgid ""
"// This makes it possible to print Book values with {}.\n"
"impl std::fmt::Display for Book {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"{} ({})\", self.title, self.year)\n"
"    }\n"
"}\n"
"// ANCHOR_END: setup"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:50
msgid ""
"// ANCHOR: Library_new\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:57
msgid ""
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:66
msgid ""
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:75
msgid ""
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:84
msgid ""
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}\", book);\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:95
msgid ""
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    unimplemented!()\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        self.books.iter().min_by_key(|book| book.year)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:105
msgid ""
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();"
msgstr ""
"// ì•„ë˜ ì†ŒìŠ¤ ì£¼ì„ì„ ì œê±°í•˜ê³  ëˆ„ë½ëœ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì„¸ìš”\n"
"// ë¯¸êµ¬í˜„ ë©”ì„œë“œë„ ì¡´ì¬í•˜ë¯€ë¡œ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì—…ë°ì´íŠ¸ í•˜ì„¸ìš”(self í¬í•¨)\n"
"fn main() {\n"
"    let library = Library::new();"

#: src/exercises/day-1/solutions-afternoon.md:113
msgid ""
"    //println!(\"Our library is empty: {}\", library.is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"My oldest book is {book}\"),\n"
"    //    None => println!(\"My library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"Our library has {} books\", library.len());\n"
"}\n"
"// ANCHOR_END: main"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:129
msgid ""
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:135
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:141
msgid ""
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:146
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:150
msgid ""
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:160
msgid ""
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:165
msgid ""
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:171
msgid ""
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", 1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
msgid "# Day 2 Morning Exercises"
msgstr "# 2ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-2/solutions-morning.md:3
msgid "## Points and Polygons"
msgstr "## ì ê³¼ ë‹¤ê°í˜•"

#: src/exercises/day-2/solutions-morning.md:5
msgid "([back to exercise](points-polygons.md))"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:22
msgid ""
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:30
msgid ""
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:37
msgid ""
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:41
msgid ""
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:49
msgid ""
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:57
msgid ""
"impl std::ops::Sub for Point {\n"
"    type Output = Self;"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:60
msgid ""
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:68
msgid ""
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:74
msgid ""
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:81
msgid ""
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:85
msgid ""
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:89
msgid ""
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:93
msgid ""
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:98
msgid ""
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:109
msgid ""
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:116
msgid ""
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:123
msgid ""
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:127
msgid ""
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:132
msgid ""
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:139
msgid ""
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:145
msgid ""
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:151
msgid ""
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:160
msgid ""
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:213
msgid ""
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""

#: src/exercises/day-2/solutions-morning.md:233
#: src/exercises/day-2/solutions-afternoon.md:174
msgid ""
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
msgid "# Day 2 Afternoon Exercises"
msgstr "# 2ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-2/solutions-afternoon.md:3
msgid "## Luhn Algorithm"
msgstr "## ë£¬ ì•Œê³ ë¦¬ì¦˜"

#: src/exercises/day-2/solutions-afternoon.md:5
msgid "([back to exercise](luhn.md))"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:22
msgid ""
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ').enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:42
msgid ""
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:46
msgid ""
"    sum % 10 == 0\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:49
msgid ""
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {} a valid credit card number? {}\",\n"
"        cc_number,\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:58
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:89
msgid ""
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:98
msgid "## Strings and Iterators"
msgstr "## ë¬¸ìì—´ê³¼ ë°˜ë³µì"

#: src/exercises/day-2/solutions-afternoon.md:100
msgid "([back to exercise](strings-iterators.md))"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:117
msgid ""
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"    let prefixes = prefix.split('/');\n"
"    let request_paths = request_path\n"
"        .split('/')\n"
"        .map(|p| Some(p))\n"
"        .chain(std::iter::once(None));"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:126
msgid ""
"    for (prefix, request_path) in prefixes.zip(request_paths) {\n"
"        match request_path {\n"
"            Some(request_path) => {\n"
"                if (prefix != \"*\") && (prefix != request_path) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"    true\n"
"}"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:139
msgid ""
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/books\"));"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:166
msgid ""
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
msgid "# Day 3 Morning Exercise"
msgstr "# 3ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-3/solutions-morning.md:3
msgid "## A Simple GUI Library"
msgstr "## ê°„ë‹¨í•œ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/exercises/day-3/solutions-morning.md:5
msgid "([back to exercise](simple-gui.md))"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:22
msgid ""
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:82
msgid "// ANCHOR_END: setup"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:84
msgid ""
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:94
msgid ""
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:102
msgid "        let window_width = self.width();"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:104
msgid ""
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^window_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<window_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:window_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<window_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:117
msgid ""
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:124
msgid ""
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:131
msgid ""
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:139
msgid ""
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:150
msgid ""
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:157
msgid ""
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo.\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
msgid "# Day 3 Afternoon Exercises"
msgstr "# 3ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-3/solutions-afternoon.md:3
msgid "## Safe FFI Wrapper"
msgstr "## FFIë˜í¼"

#: src/exercises/day-3/solutions-afternoon.md:5
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:22
msgid ""
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int, c_long, c_ulong, c_ushort};"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:53
msgid ""
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:60
msgid ""
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: {err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:77
msgid ""
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:97
msgid ""
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:111
msgid ""
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:1
msgid "# Day 4 Morning Exercise"
msgstr "# 4ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/day-4/solutions-morning.md:3
msgid "## Dining Philosophers"
msgstr "## ì‹ì‚¬í•˜ëŠ” ì² í•™ìë“¤"

#: src/exercises/day-4/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:22
msgid ""
"// ANCHOR: Philosopher\n"
"use std::sync::mpsc;\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:30
msgid ""
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:38
msgid ""
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:47
msgid ""
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:54
msgid ""
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:63
msgid ""
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:67
msgid ""
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:71
msgid ""
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = forks[i].clone();\n"
"        let mut right_fork = forks[(i + 1) % forks.len()].clone();"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:76
msgid ""
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:83
msgid ""
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:90
msgid ""
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }"
msgstr ""

#: src/exercises/day-4/solutions-morning.md:98
msgid ""
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#~ msgid ""
#~ "* `len()` returns the size of the `String` in bytes, not its length in characters.\n"
#~ "* `chars()` returns an iterator over the actual characters."
#~ msgstr ""
#~ "* `len()`ì€ `String`ì˜ ê¸€ì ê¸¸ì´ê°€ ì•„ë‹Œ ë°”ì´íŠ¸ ì‚¬ì´ì¦ˆë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.\n"
#~ "* `chars()`ì€ ì‹¤ì œ ë¬¸ìë“¤ì— ëŒ€í•œ ë°˜ë³µìë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "<details>\n"
#~ "    \n"
#~ "Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` explicitly.\n"
#~ "As always with Rust type inference, the `T` was established during the first `push` call."
#~ msgstr ""
#~ "<details>\n"
#~ "    \n"
#~ "`Vec<T>` ì—­ì‹œ ì œë„¤ë¦­ íƒ€ì…ì„ì„ ì£¼ëª©í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. í•˜ì§€ë§Œ ëŸ¬ìŠ¤íŠ¸ëŠ” ì²« `push`ë¥¼ í†µí•´ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ `T`ë¥¼ í•­ìƒ ëª…ì‹œí•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "`vec![...]` is a canonical macro to use instead of `Vec::new()` and it supports\n"
#~ "adding initial elements to the vector."
#~ msgstr "`vec![...]` í‘œì¤€ ë§¤í¬ë¡œë¡œ `Vec::new()`ë¥¼ ëŒ€ì²´í•˜ê³ , ë²¡í„°ì— ì¶”ê°€ ì´ˆê¸°ìš”ì†Œë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "* `Box` is like `std::unique_ptr` in C++.\n"
#~ "* In the above example, you can even leave out the `*` in the `println!` statement thanks to `Deref`."
#~ msgstr ""
#~ "* `Box`ëŠ” C++ì˜ `std::unique_ptr`ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤.\n"
#~ "* ìœ„ì˜ ì˜ˆì œì—ì„œ `Deref` ë•ë¶„ì— `println!`êµ¬ë¬¸ì—ì„œ  `*`ë¥¼ ìƒëµí•  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Both traits are not to be implemented. They are implemented automatically when \n"
#~ "the compiler determines itâ€™s appropriate."
#~ msgstr "ì´ íŠ¸ë ˆì‡ì€ í”„ë¡œê·¸ë˜ë¨¸ê°€ ìˆ˜ë™ìœ¼ë¡œ êµ¬í˜„ì„ í•´ì•¼ í•˜ëŠ” íŠ¸ë ˆì‡ì´ ì•„ë‹™ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì ë‹¹í•˜ë‹¤ê³  íŒë‹¨ë˜ë©´ ì´ ë‘ íŠ¸ë ˆì‡ì„ ìë™ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤."
