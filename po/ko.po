msgid ""
msgstr ""
"Project-Id-Version: [í•œêµ­ì–´]Comprehensive Rust ğŸ¦€\n"
"POT-Creation-Date: 2024-01-04T08:58:44-08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3 src/index.md:1
msgid "Welcome to Comprehensive Rust ğŸ¦€"
msgstr "Comprehensive Rustì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤ ğŸ¦€"

#: src/SUMMARY.md:5 src/running-the-course.md:1
msgid "Running the Course"
msgstr "ê°•ì˜ ì§„í–‰"

#: src/SUMMARY.md:6 src/running-the-course/course-structure.md:1
msgid "Course Structure"
msgstr "ê°•ì˜ êµ¬ì„±"

#: src/SUMMARY.md:7 src/running-the-course/keyboard-shortcuts.md:1
msgid "Keyboard Shortcuts"
msgstr "ë‹¨ì¶•í‚¤"

#: src/SUMMARY.md:8 src/running-the-course/translations.md:1
msgid "Translations"
msgstr "ë‹¤ë¥¸ ì–¸ì–´ë“¤"

#: src/SUMMARY.md:9 src/cargo.md:1
msgid "Using Cargo"
msgstr "ì¹´ê³  ì‚¬ìš©í•˜ê¸°"

#: src/SUMMARY.md:10
msgid "Rust Ecosystem"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„"

#: src/SUMMARY.md:11
msgid "Code Samples"
msgstr "ì½”ë“œ ìƒ˜í”Œ"

#: src/SUMMARY.md:12
msgid "Running Cargo Locally"
msgstr "ì¹´ê³ (Cargo) ìˆ˜í–‰í•˜ê¸°"

#: src/SUMMARY.md:16
msgid "Day 1: Morning"
msgstr "1ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:18 src/SUMMARY.md:44 src/SUMMARY.md:70 src/SUMMARY.md:93
#: src/SUMMARY.md:119 src/SUMMARY.md:138 src/SUMMARY.md:158 src/SUMMARY.md:184
#: src/SUMMARY.md:207 src/SUMMARY.md:244 src/SUMMARY.md:286 src/SUMMARY.md:337
msgid "Welcome"
msgstr "ê°œìš”"

#: src/SUMMARY.md:19 src/SUMMARY.md:21 src/hello-world.md:1
#: src/hello-world/hello-world.md:1
#, fuzzy
msgid "Hello, World"
msgstr "Hello World!"

#: src/SUMMARY.md:20 src/hello-world/what-is-rust.md:1
msgid "What is Rust?"
msgstr "ëŸ¬ìŠ¤íŠ¸ë€?"

#: src/SUMMARY.md:22 src/hello-world/benefits.md:1
msgid "Benefits of Rust"
msgstr ""

#: src/SUMMARY.md:23 src/hello-world/playground.md:1
msgid "Playground"
msgstr ""

#: src/SUMMARY.md:24 src/types-and-values.md:1
msgid "Types and Values"
msgstr ""

#: src/SUMMARY.md:25 src/types-and-values/variables.md:1
msgid "Variables"
msgstr "ë³€ìˆ˜"

#: src/SUMMARY.md:26 src/types-and-values/values.md:1
msgid "Values"
msgstr ""

#: src/SUMMARY.md:27 src/types-and-values/arithmetic.md:1
msgid "Arithmetic"
msgstr ""

#: src/SUMMARY.md:28 src/types-and-values/strings.md:1
msgid "Strings"
msgstr "ë¬¸ìì—´"

#: src/SUMMARY.md:29 src/types-and-values/inference.md:1
msgid "Type Inference"
msgstr "íƒ€ì… ì¶”ë¡ "

#: src/SUMMARY.md:30 src/types-and-values/exercise.md:1
msgid "Exercise: Fibonacci"
msgstr ""

#: src/SUMMARY.md:31 src/SUMMARY.md:40 src/SUMMARY.md:51 src/SUMMARY.md:56
#: src/SUMMARY.md:64 src/SUMMARY.md:75 src/SUMMARY.md:82 src/SUMMARY.md:89
#: src/SUMMARY.md:103 src/SUMMARY.md:113 src/SUMMARY.md:129 src/SUMMARY.md:134
#: src/SUMMARY.md:144 src/SUMMARY.md:152 src/SUMMARY.md:164 src/SUMMARY.md:171
#: src/SUMMARY.md:180 src/SUMMARY.md:192 src/SUMMARY.md:201
#: src/types-and-values/solution.md:1 src/control-flow-basics/solution.md:1
#: src/tuples-and-arrays/solution.md:1 src/references/solution.md:1
#: src/user-defined-types/solution.md:1 src/pattern-matching/solution.md:1
#: src/methods-and-traits/solution.md:1 src/generics/solution.md:1
#: src/std-types/solution.md:1 src/std-traits/solution.md:1
#: src/memory-management/solution.md:1 src/smart-pointers/solution.md:1
#: src/borrowing/solution.md:1 src/slices-and-lifetimes/solution.md:1
#: src/iterators/solution.md:1 src/modules/solution.md:1
#: src/testing/solution.md:1 src/error-handling/solution.md:1
#: src/unsafe-rust/solution.md:1
#, fuzzy
msgid "Solution"
msgstr "í•´ë‹µ"

#: src/SUMMARY.md:32 src/control-flow-basics.md:1
#, fuzzy
msgid "Control Flow Basics"
msgstr "íë¦„ ì œì–´"

#: src/SUMMARY.md:33 src/control-flow-basics/conditionals.md:1
msgid "Conditionals"
msgstr ""

#: src/SUMMARY.md:34 src/control-flow-basics/loops.md:1
#, fuzzy
msgid "Loops"
msgstr "ë°°ì—´ê³¼ `for` ë°˜ë³µë¬¸"

#: src/SUMMARY.md:35 src/control-flow-basics/break-continue.md:1
msgid "`break` and `continue`"
msgstr "`break`ì™€ `continue`"

#: src/SUMMARY.md:36 src/control-flow-basics/blocks-and-scopes.md:1
msgid "Blocks and Scopes"
msgstr ""

#: src/SUMMARY.md:37 src/control-flow-basics/functions.md:1
msgid "Functions"
msgstr "í•¨ìˆ˜"

#: src/SUMMARY.md:38 src/control-flow-basics/macros.md:1
msgid "Macros"
msgstr ""

#: src/SUMMARY.md:39 src/control-flow-basics/exercise.md:1
msgid "Exercise: Collatz Sequence"
msgstr ""

#: src/SUMMARY.md:42
msgid "Day 1: Afternoon"
msgstr "1ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:45 src/SUMMARY.md:46 src/tuples-and-arrays.md:1
#: src/tuples-and-arrays/tuples-and-arrays.md:1
msgid "Tuples and Arrays"
msgstr ""

#: src/SUMMARY.md:47 src/tuples-and-arrays/iteration.md:1
#, fuzzy
msgid "Array Iteration"
msgstr "Cargoì— í†µí•©ë¨"

#: src/SUMMARY.md:48 src/SUMMARY.md:71 src/tuples-and-arrays/match.md:1
#: src/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "íŒ¨í„´ ë§¤ì¹­"

#: src/SUMMARY.md:49 src/SUMMARY.md:72 src/tuples-and-arrays/destructuring.md:1
#: src/pattern-matching/destructuring.md:1
#, fuzzy
msgid "Destructuring"
msgstr "ì—´ê±°í˜• ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#: src/SUMMARY.md:50 src/tuples-and-arrays/exercise.md:1
msgid "Exercise: Nested Arrays"
msgstr ""

#: src/SUMMARY.md:52 src/references.md:1
msgid "References"
msgstr "ì°¸ì¡°"

#: src/SUMMARY.md:53 src/references/shared.md:1
#, fuzzy
msgid "Shared References"
msgstr "ì°¸ì¡°"

#: src/SUMMARY.md:54 src/references/exclusive.md:1
#, fuzzy
msgid "Exclusive References"
msgstr "í—ˆìƒ(dangling) ì°¸ì¡°"

#: src/SUMMARY.md:55 src/references/exercise.md:1
msgid "Exercise: Geometry"
msgstr ""

#: src/SUMMARY.md:57 src/user-defined-types.md:1
msgid "User-Defined Types"
msgstr ""

#: src/SUMMARY.md:58 src/user-defined-types/named-structs.md:1
#, fuzzy
msgid "Named Structs"
msgstr "êµ¬ì¡°ì²´"

#: src/SUMMARY.md:59 src/user-defined-types/tuple-structs.md:5
msgid "Tuple Structs"
msgstr "íŠœí”Œ"

#: src/SUMMARY.md:60 src/user-defined-types/enums.md:1
#: src/pattern-matching/destructuring.md:24
#: src/pattern-matching/destructuring.md:66
msgid "Enums"
msgstr "ì—´ê±°í˜•"

#: src/SUMMARY.md:61 src/user-defined-types/static-and-const.md:1
#, fuzzy
msgid "Static and Const"
msgstr "ì •ì ë³€ìˆ˜(static)ì™€ ìƒìˆ˜(const)"

#: src/SUMMARY.md:62 src/user-defined-types/aliases.md:1
msgid "Type Aliases"
msgstr ""

#: src/SUMMARY.md:63 src/user-defined-types/exercise.md:1
msgid "Exercise: Elevator Events"
msgstr ""

#: src/SUMMARY.md:68
msgid "Day 2: Morning"
msgstr "2ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:73 src/pattern-matching/let-control-flow.md:1
#, fuzzy
msgid "Let Control Flow"
msgstr "íë¦„ ì œì–´"

#: src/SUMMARY.md:74 src/pattern-matching/exercise.md:1
msgid "Exercise: Expression Evaluation"
msgstr ""

#: src/SUMMARY.md:76 src/methods-and-traits.md:1
#, fuzzy
msgid "Methods and Traits"
msgstr "Readì™€ Write"

#: src/SUMMARY.md:77 src/methods-and-traits/methods.md:1
msgid "Methods"
msgstr "ë©”ì„œë“œ"

#: src/SUMMARY.md:78 src/methods-and-traits/traits.md:1
msgid "Traits"
msgstr "íŠ¸ë ˆì‡(Trait)"

#: src/SUMMARY.md:79 src/methods-and-traits/deriving.md:1
#, fuzzy
msgid "Deriving"
msgstr "íŠ¸ë ˆì‡ ìƒì†í•˜ê¸°"

#: src/SUMMARY.md:80 src/methods-and-traits/trait-objects.md:1
msgid "Trait Objects"
msgstr "íŠ¸ë ˆì‡ ê°ì²´"

#: src/SUMMARY.md:81 src/methods-and-traits/exercise.md:1
#, fuzzy
msgid "Exercise: GUI Library"
msgstr "ê°„ë‹¨í•œ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:83 src/generics.md:1
msgid "Generics"
msgstr "ì œë„¤ë¦­"

#: src/SUMMARY.md:84 src/generics/generic-functions.md:1
#, fuzzy
msgid "Generic Functions"
msgstr "ì™¸ë¶€(ë‹¤ë¥¸ì–¸ì–´) í•¨ìˆ˜ë“¤"

#: src/SUMMARY.md:85 src/generics/generic-data.md:1
msgid "Generic Data Types"
msgstr "ì œë„¤ë¦­ ë°ì´í„° íƒ€ì…"

#: src/SUMMARY.md:86 src/generics/trait-bounds.md:1
msgid "Trait Bounds"
msgstr "ì œë„¤ë¦­ íƒ€ì… ì œí•œ(íŠ¸ë ˆì‡ ê²½ê³„)"

#: src/SUMMARY.md:87 src/generics/impl-trait.md:1
msgid "`impl Trait`"
msgstr "íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°(`impl Trait`)"

#: src/SUMMARY.md:88 src/generics/exercise.md:1
msgid "Exercise: Generic `min`"
msgstr ""

#: src/SUMMARY.md:91
msgid "Day 2: Afternoon"
msgstr "2ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:94 src/std-types.md:1
#, fuzzy
msgid "Standard Library Types"
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:95 src/std-types/std.md:1
msgid "Standard Library"
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:96 src/std-types/docs.md:1
#, fuzzy
msgid "Documentation"
msgstr "ë¬¸ì„œí™”ì£¼ì„ í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:97
#, fuzzy
msgid "`Option`"
msgstr "`Duration`"

#: src/SUMMARY.md:98
#, fuzzy
msgid "`Result`"
msgstr "`Option`, `Result`"

#: src/SUMMARY.md:99 src/android/interoperability/cpp/type-mapping.md:5
#, fuzzy
msgid "`String`"
msgstr "String"

#: src/SUMMARY.md:100 src/std-types/vec.md:1
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md:101 src/std-types/hashmap.md:1 src/bare-metal/no_std.md:46
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md:102 src/std-types/exercise.md:1
#, fuzzy
msgid "Exercise: Counter"
msgstr "ì—°ìŠµë¬¸ì œ"

#: src/SUMMARY.md:104 src/std-traits.md:1
#, fuzzy
msgid "Standard Library Traits"
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:105 src/std-traits/comparisons.md:1 src/async.md:17
#, fuzzy
msgid "Comparisons"
msgstr "ë¹„êµ"

#: src/SUMMARY.md:106 src/std-traits/operators.md:1
#, fuzzy
msgid "Operators"
msgstr "Iterators"

#: src/SUMMARY.md:107 src/std-traits/from-and-into.md:1
msgid "`From` and `Into`"
msgstr "`From`ê³¼ `Into`"

#: src/SUMMARY.md:108 src/std-traits/casting.md:1
#, fuzzy
msgid "Casting"
msgstr "í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:109 src/std-traits/read-and-write.md:1
msgid "`Read` and `Write`"
msgstr "`Read`ì™€ `Write`"

#: src/SUMMARY.md:110
msgid "`Default`, struct update syntax"
msgstr ""

#: src/SUMMARY.md:111 src/std-traits/closures.md:1
msgid "Closures"
msgstr "í´ë¡œì €(Closure)"

#: src/SUMMARY.md:112 src/std-traits/exercise.md:1
#, fuzzy
msgid "Exercise: ROT13"
msgstr "ì—°ìŠµë¬¸ì œ"

#: src/SUMMARY.md:117
msgid "Day 3: Morning"
msgstr "3ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:120 src/memory-management.md:1
msgid "Memory Management"
msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/SUMMARY.md:121 src/memory-management/review.md:1
msgid "Review of Program Memory"
msgstr ""

#: src/SUMMARY.md:122 src/memory-management/approaches.md:1
#, fuzzy
msgid "Approaches to Memory Management"
msgstr "ìë™ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#: src/SUMMARY.md:123 src/memory-management/ownership.md:1
msgid "Ownership"
msgstr "ì†Œìœ ê¶Œ"

#: src/SUMMARY.md:124 src/memory-management/move.md:1
msgid "Move Semantics"
msgstr "Move ë¬¸ë²•"

#: src/SUMMARY.md:125
msgid "`Clone`"
msgstr ""

#: src/SUMMARY.md:126 src/memory-management/copy-types.md:5
#, fuzzy
msgid "Copy Types"
msgstr "ë³µí•© íƒ€ì…"

#: src/SUMMARY.md:127
#, fuzzy
msgid "`Drop`"
msgstr "Drop"

#: src/SUMMARY.md:128 src/memory-management/exercise.md:1
msgid "Exercise: Builder Type"
msgstr ""

#: src/SUMMARY.md:130 src/smart-pointers.md:1
msgid "Smart Pointers"
msgstr ""

#: src/SUMMARY.md:131 src/smart-pointers/box.md:1
#: src/android/interoperability/cpp/type-mapping.md:9
#, fuzzy
msgid "`Box<T>`"
msgstr "`Box`"

#: src/SUMMARY.md:132 src/smart-pointers/rc.md:1
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md:133 src/smart-pointers/exercise.md:1
msgid "Exercise: Binary Tree"
msgstr ""

#: src/SUMMARY.md:136
msgid "Day 3: Afternoon"
msgstr "3ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:139 src/borrowing.md:1
msgid "Borrowing"
msgstr "ë¹Œë¦¼"

#: src/SUMMARY.md:140 src/borrowing/shared.md:1
#, fuzzy
msgid "Borrowing a Value"
msgstr "ë¹Œë¦¼"

#: src/SUMMARY.md:141 src/borrowing/borrowck.md:1
#, fuzzy
msgid "Borrow Checking"
msgstr "ë¹Œë¦¼"

#: src/SUMMARY.md:142 src/borrowing/interior-mutability.md:5
#, fuzzy
msgid "Interior Mutability"
msgstr "ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:143 src/borrowing/exercise.md:1
#, fuzzy
msgid "Exercise: Health Statistics"
msgstr "ê±´ê°•ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"

#: src/SUMMARY.md:145 src/slices-and-lifetimes.md:1
#, fuzzy
msgid "Slices and Lifetimes"
msgstr "ìˆ˜ëª…"

#: src/SUMMARY.md:146
#, fuzzy
msgid "Slices: `&[T]`"
msgstr "ìŠ¬ë¼ì´ìŠ¤"

#: src/SUMMARY.md:147 src/slices-and-lifetimes/str.md:5
#, fuzzy
msgid "String References"
msgstr "í—ˆìƒ(dangling) ì°¸ì¡°"

#: src/SUMMARY.md:148 src/slices-and-lifetimes/lifetime-annotations.md:1
#, fuzzy
msgid "Lifetime Annotations"
msgstr "í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ìˆ˜ëª…"

#: src/SUMMARY.md:149
#, fuzzy
msgid "Lifetime Elision"
msgstr "ìˆ˜ëª…"

#: src/SUMMARY.md:150
#, fuzzy
msgid "Struct Lifetimes"
msgstr "ìˆ˜ëª…"

#: src/SUMMARY.md:151 src/slices-and-lifetimes/exercise.md:1
msgid "Exercise: Protobuf Parsing"
msgstr ""

#: src/SUMMARY.md:156
#, fuzzy
msgid "Day 4: Morning"
msgstr "1ì¼ì°¨ ì˜¤ì „"

#: src/SUMMARY.md:159 src/iterators.md:1
msgid "Iterators"
msgstr "Iterators"

#: src/SUMMARY.md:160 src/iterators/iterator.md:5 src/bare-metal/no_std.md:28
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md:161 src/iterators/intoiterator.md:1
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md:162
#, fuzzy
msgid "`FromIterator`"
msgstr "FromIterator"

#: src/SUMMARY.md:163 src/iterators/exercise.md:1
msgid "Exercise: Iterator Method Chaining"
msgstr ""

#: src/SUMMARY.md:165 src/SUMMARY.md:166 src/modules.md:1
#: src/modules/modules.md:1
msgid "Modules"
msgstr "ëª¨ë“ˆ"

#: src/SUMMARY.md:167 src/modules/filesystem.md:1
msgid "Filesystem Hierarchy"
msgstr "íŒŒì¼ì‹œìŠ¤í…œ ê³„ì¸µ"

#: src/SUMMARY.md:168 src/modules/visibility.md:1
msgid "Visibility"
msgstr "ê°€ì‹œì„±"

#: src/SUMMARY.md:169
msgid "`use`, `super`, `self`"
msgstr ""

#: src/SUMMARY.md:170 src/modules/exercise.md:1
msgid "Exercise: Modules for the GUI Library"
msgstr ""

#: src/SUMMARY.md:172 src/SUMMARY.md:253 src/testing.md:1
#: src/chromium/testing.md:1
msgid "Testing"
msgstr "í…ŒìŠ¤íŠ¸"

#: src/SUMMARY.md:173
msgid "Test Modules"
msgstr "í…ŒìŠ¤íŠ¸ ëª¨ë“ˆ"

#: src/SUMMARY.md:174 src/testing/other.md:1
#, fuzzy
msgid "Other Types of Tests"
msgstr "ë‹¤ë¥¸ í”„ë¡œì íŠ¸"

#: src/SUMMARY.md:175 src/SUMMARY.md:321 src/testing/useful-crates.md:1
msgid "Useful Crates"
msgstr "ìœ ìš©í•œ í¬ë ˆì´íŠ¸"

#: src/SUMMARY.md:176 src/testing/googletest.md:1
msgid "GoogleTest"
msgstr ""

#: src/SUMMARY.md:177 src/testing/mocking.md:1
msgid "Mocking"
msgstr ""

#: src/SUMMARY.md:178 src/testing/lints.md:1
msgid "Compiler Lints and Clippy"
msgstr ""

#: src/SUMMARY.md:179 src/testing/exercise.md:1
#, fuzzy
msgid "Exercise: Luhn Algorithm"
msgstr "ë£¬ ì•Œê³ ë¦¬ì¦˜"

#: src/SUMMARY.md:182
#, fuzzy
msgid "Day 4: Afternoon"
msgstr "1ì¼ì°¨ ì˜¤í›„"

#: src/SUMMARY.md:185 src/error-handling.md:1
msgid "Error Handling"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:186 src/error-handling/panics.md:1
msgid "Panics"
msgstr "íŒ¨ë‹‰"

#: src/SUMMARY.md:187 src/error-handling/try.md:1
#, fuzzy
msgid "Try Operator"
msgstr "Iterator"

#: src/SUMMARY.md:188 src/error-handling/try-conversions.md:1
#, fuzzy
msgid "Try Conversions"
msgstr "ë¬µì‹œì  í˜•ë³€í™˜"

#: src/SUMMARY.md:189
#, fuzzy
msgid "`Error` Trait"
msgstr "`Error`"

#: src/SUMMARY.md:190 src/error-handling/thiserror-and-anyhow.md:1
#, fuzzy
msgid "`thiserror` and `anyhow`"
msgstr "`From`ê³¼ `Into`"

#: src/SUMMARY.md:191
#, fuzzy
msgid "Exercise: Rewriting with `Result`"
msgstr "`Result`ë¥¼ ì´ìš©í•œ êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:193 src/unsafe-rust.md:1 src/unsafe-rust/unsafe.md:1
msgid "Unsafe Rust"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸"

#: src/SUMMARY.md:194
#, fuzzy
msgid "Unsafe"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸"

#: src/SUMMARY.md:195 src/unsafe-rust/dereferencing.md:1
msgid "Dereferencing Raw Pointers"
msgstr "ì›ì‹œ í¬ì¸í„° ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)"

#: src/SUMMARY.md:196 src/unsafe-rust/mutable-static.md:1
msgid "Mutable Static Variables"
msgstr "ì •ì  ê°€ë³€ ë³€ìˆ˜"

#: src/SUMMARY.md:197 src/unsafe-rust/unions.md:1
msgid "Unions"
msgstr "Unions"

#: src/SUMMARY.md:198 src/unsafe-rust/unsafe-functions.md:1
#, fuzzy
msgid "Unsafe Functions"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ í˜¸ì¶œ"

#: src/SUMMARY.md:199
#, fuzzy
msgid "Unsafe Traits"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°"

#: src/SUMMARY.md:200
#, fuzzy
msgid "Exercise: FFI Wrapper"
msgstr "FFIë˜í¼"

#: src/SUMMARY.md:203 src/SUMMARY.md:327 src/bare-metal/android.md:1
msgid "Android"
msgstr "ì•ˆë“œë¡œì´ë“œ"

#: src/SUMMARY.md:208 src/SUMMARY.md:245 src/android/setup.md:1
#: src/chromium/setup.md:1
msgid "Setup"
msgstr "ì„¤ì¹˜"

#: src/SUMMARY.md:209 src/SUMMARY.md:248 src/android/build-rules.md:1
msgid "Build Rules"
msgstr "ë¹Œë“œ ê·œì¹™"

#: src/SUMMARY.md:210
msgid "Binary"
msgstr "ë°”ì´ë„ˆë¦¬"

#: src/SUMMARY.md:211
msgid "Library"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/SUMMARY.md:212 src/android/aidl.md:1
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:213
msgid "Interface"
msgstr "AIDL ì¸í„°í˜ì´ìŠ¤"

#: src/SUMMARY.md:214
msgid "Implementation"
msgstr "ì„œë¹„ìŠ¤ êµ¬í˜„"

#: src/SUMMARY.md:215
msgid "Server"
msgstr "AIDL ì„œë²„"

#: src/SUMMARY.md:216 src/android/aidl/deploy.md:1
msgid "Deploy"
msgstr "ë°°í¬"

#: src/SUMMARY.md:217
msgid "Client"
msgstr "í´ë¼ì´ì–¸íŠ¸"

#: src/SUMMARY.md:218 src/android/aidl/changing.md:1
msgid "Changing API"
msgstr "API ìˆ˜ì •"

#: src/SUMMARY.md:219 src/SUMMARY.md:317 src/android/logging.md:1
#: src/bare-metal/aps/logging.md:1
msgid "Logging"
msgstr "ë¡œê¹…"

#: src/SUMMARY.md:220 src/android/interoperability.md:1
msgid "Interoperability"
msgstr "ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:221
msgid "With C"
msgstr "Cì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:222
msgid "Calling C with Bindgen"
msgstr "Bindgenì„ ì‚¬ìš©í•œ Cí˜¸ì¶œ"

#: src/SUMMARY.md:223
msgid "Calling Rust from C"
msgstr "Cì—ì„œ ëŸ¬ìŠ¤íŠ¸ í˜¸ì¶œ"

#: src/SUMMARY.md:224
#, fuzzy
msgid "With C++)"
msgstr "C++ì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:225 src/android/interoperability/cpp/bridge.md:1
#, fuzzy
msgid "The Bridge Module"
msgstr "í…ŒìŠ¤íŠ¸ ëª¨ë“ˆ"

#: src/SUMMARY.md:226
#, fuzzy
msgid "Rust Bridge"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬"

#: src/SUMMARY.md:227 src/android/interoperability/cpp/generated-cpp.md:1
msgid "Generated C++"
msgstr ""

#: src/SUMMARY.md:228
msgid "C++ Bridge"
msgstr ""

#: src/SUMMARY.md:229 src/android/interoperability/cpp/shared-types.md:1
#, fuzzy
msgid "Shared Types"
msgstr "ìŠ¤ì¹¼ë¼ íƒ€ì…"

#: src/SUMMARY.md:230 src/android/interoperability/cpp/shared-enums.md:1
msgid "Shared Enums"
msgstr ""

#: src/SUMMARY.md:231 src/android/interoperability/cpp/rust-result.md:1
#, fuzzy
msgid "Rust Error Handling"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:232 src/android/interoperability/cpp/cpp-exception.md:1
#, fuzzy
msgid "C++ Error Handling"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:233 src/android/interoperability/cpp/type-mapping.md:1
msgid "Additional Types"
msgstr ""

#: src/SUMMARY.md:234
msgid "Building for Android: C++"
msgstr ""

#: src/SUMMARY.md:235
msgid "Building for Android: Genrules"
msgstr ""

#: src/SUMMARY.md:236
msgid "Building for Android: Rust"
msgstr ""

#: src/SUMMARY.md:237
msgid "With Java"
msgstr "Javaì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:238 src/SUMMARY.md:300 src/SUMMARY.md:329 src/SUMMARY.md:351
#: src/SUMMARY.md:373 src/exercises/android/morning.md:1
#: src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1
#: src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
msgid "Exercises"
msgstr "ì—°ìŠµë¬¸ì œ"

#: src/SUMMARY.md:240
msgid "Chromium"
msgstr ""

#: src/SUMMARY.md:246 src/chromium/cargo.md:1
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr ""

#: src/SUMMARY.md:247
msgid "Policy"
msgstr ""

#: src/SUMMARY.md:249
#, fuzzy
msgid "Unsafe Code"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸"

#: src/SUMMARY.md:250 src/chromium/build-rules/depending.md:1
msgid "Depending on Rust Code from Chromium C++"
msgstr ""

#: src/SUMMARY.md:251 src/chromium/build-rules/vscode.md:1
msgid "Visual Studio Code"
msgstr ""

#: src/SUMMARY.md:252 src/SUMMARY.md:257 src/SUMMARY.md:265 src/SUMMARY.md:278
#: src/exercises/chromium/third-party.md:1
#, fuzzy
msgid "Exercise"
msgstr "ì—°ìŠµë¬¸ì œ"

#: src/SUMMARY.md:254 src/chromium/testing/rust-gtest-interop.md:1
msgid "`rust_gtest_interop` Library"
msgstr ""

#: src/SUMMARY.md:255 src/chromium/testing/build-gn.md:1
msgid "GN Rules for Rust Tests"
msgstr ""

#: src/SUMMARY.md:256 src/chromium/testing/chromium-import-macro.md:1
msgid "`chromium::import!` Macro"
msgstr ""

#: src/SUMMARY.md:258 src/chromium/interoperability-with-cpp.md:1
#, fuzzy
msgid "Interoperability with C++"
msgstr "Cì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/SUMMARY.md:259
#: src/chromium/interoperability-with-cpp/example-bindings.md:1
#, fuzzy
msgid "Example Bindings"
msgstr "ì˜ˆì œ"

#: src/SUMMARY.md:260
#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:1
msgid "Limitations of CXX"
msgstr ""

#: src/SUMMARY.md:261
#: src/chromium/interoperability-with-cpp/error-handling.md:1
#, fuzzy
msgid "CXX Error Handling"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:262
#, fuzzy
msgid "Error Handling: QR Example"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:263
#, fuzzy
msgid "Error Handling: PNG Example"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/SUMMARY.md:264
msgid "Using CXX in Chromium"
msgstr ""

#: src/SUMMARY.md:266 src/chromium/adding-third-party-crates.md:1
msgid "Adding Third Party Crates"
msgstr ""

#: src/SUMMARY.md:267
msgid "Configuring Cargo.toml"
msgstr ""

#: src/SUMMARY.md:268
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:1
msgid "Configuring `gnrt_config.toml`"
msgstr ""

#: src/SUMMARY.md:269
#: src/chromium/adding-third-party-crates/downloading-crates.md:1
msgid "Downloading Crates"
msgstr ""

#: src/SUMMARY.md:270
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:1
msgid "Generating `gn` Build Rules"
msgstr ""

#: src/SUMMARY.md:271
#: src/chromium/adding-third-party-crates/resolving-problems.md:1
msgid "Resolving Problems"
msgstr ""

#: src/SUMMARY.md:272
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:1
msgid "Build Scripts Which Generate Code"
msgstr ""

#: src/SUMMARY.md:273
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:1
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr ""

#: src/SUMMARY.md:274
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:1
msgid "Depending on a Crate"
msgstr ""

#: src/SUMMARY.md:275
msgid "Reviews and Audits"
msgstr ""

#: src/SUMMARY.md:276
msgid "Checking into Chromium Source Code"
msgstr ""

#: src/SUMMARY.md:277
#: src/chromium/adding-third-party-crates/keeping-up-to-date.md:1
msgid "Keeping Crates Up to Date"
msgstr ""

#: src/SUMMARY.md:279
msgid "Bringing It Together - Exercise"
msgstr ""

#: src/SUMMARY.md:280 src/exercises/chromium/solutions.md:1
#, fuzzy
msgid "Exercise Solutions"
msgstr "í•´ë‹µ"

#: src/SUMMARY.md:282
msgid "Bare Metal: Morning"
msgstr "Bare Metal ì˜¤ì „"

#: src/SUMMARY.md:287 src/bare-metal/no_std.md:1
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md:288
msgid "A Minimal Example"
msgstr "ì‘ì€ ì˜ˆì œ"

#: src/SUMMARY.md:289 src/bare-metal/no_std.md:12 src/bare-metal/alloc.md:1
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md:290 src/bare-metal/microcontrollers.md:1
msgid "Microcontrollers"
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬"

#: src/SUMMARY.md:291 src/bare-metal/microcontrollers/mmio.md:1
msgid "Raw MMIO"
msgstr "ì›ì‹œ MMIO"

#: src/SUMMARY.md:292
msgid "PACs"
msgstr "PAC"

#: src/SUMMARY.md:293
msgid "HAL Crates"
msgstr "HAL í¬ë ˆì´íŠ¸"

#: src/SUMMARY.md:294
msgid "Board Support Crates"
msgstr "ë³´ë“œ ì§€ì› í¬ë ˆì´íŠ¸"

#: src/SUMMARY.md:295
msgid "The Type State Pattern"
msgstr "Type State íŒ¨í„´"

#: src/SUMMARY.md:296 src/bare-metal/microcontrollers/embedded-hal.md:1
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md:297 src/bare-metal/microcontrollers/probe-rs.md:1
#, fuzzy
msgid "`probe-rs` and `cargo-embed`"
msgstr "`probe-rs`, `cargo-embed`"

#: src/SUMMARY.md:298 src/bare-metal/microcontrollers/debugging.md:1
msgid "Debugging"
msgstr "ë””ë²„ê¹…"

#: src/SUMMARY.md:299 src/SUMMARY.md:320
msgid "Other Projects"
msgstr "ë‹¤ë¥¸ í”„ë¡œì íŠ¸"

#: src/SUMMARY.md:301 src/exercises/bare-metal/compass.md:1
#: src/exercises/bare-metal/solutions-morning.md:3
msgid "Compass"
msgstr "ë‚˜ì¹¨ë°˜"

#: src/SUMMARY.md:302 src/SUMMARY.md:331 src/SUMMARY.md:354 src/SUMMARY.md:376
msgid "Solutions"
msgstr "í•´ë‹µ"

#: src/SUMMARY.md:304
msgid "Bare Metal: Afternoon"
msgstr "Bare Metal ì˜¤í›„"

#: src/SUMMARY.md:306
msgid "Application Processors"
msgstr "ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œ"

#: src/SUMMARY.md:307 src/bare-metal/aps/entry-point.md:1
msgid "Getting Ready to Rust"
msgstr "Rust ìˆ˜í–‰ ì¤€ë¹„"

#: src/SUMMARY.md:308
msgid "Inline Assembly"
msgstr "ì¸ë¼ì¸ ì–´ì…ˆë¸”ë¦¬"

#: src/SUMMARY.md:309
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md:310
msgid "Let's Write a UART Driver"
msgstr "UART ë“œë¼ì´ë²„ ì‘ì„±"

#: src/SUMMARY.md:311
msgid "More Traits"
msgstr "ë” ë§ì€ íŠ¸ë ˆì‡"

#: src/SUMMARY.md:312
msgid "A Better UART Driver"
msgstr "ë” ë‚˜ì€ UART ë“œë¼ì´ë²„"

#: src/SUMMARY.md:313 src/bare-metal/aps/better-uart/bitflags.md:1
msgid "Bitflags"
msgstr "ë¹„íŠ¸í”Œë˜ê·¸"

#: src/SUMMARY.md:314
msgid "Multiple Registers"
msgstr "ë” ë§ì€ ë ˆì§€ìŠ¤í„°"

#: src/SUMMARY.md:315 src/bare-metal/aps/better-uart/driver.md:1
msgid "Driver"
msgstr "ë“œë¼ì´ë²„"

#: src/SUMMARY.md:316 src/SUMMARY.md:318
msgid "Using It"
msgstr "ì‚¬ìš©í•´ ë³´ê¸°"

#: src/SUMMARY.md:319 src/bare-metal/aps/exceptions.md:1
msgid "Exceptions"
msgstr "ì˜ˆì™¸"

#: src/SUMMARY.md:322 src/bare-metal/useful-crates/zerocopy.md:1
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md:323 src/bare-metal/useful-crates/aarch64-paging.md:1
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md:324 src/bare-metal/useful-crates/buddy_system_allocator.md:1
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/SUMMARY.md:325 src/bare-metal/useful-crates/tinyvec.md:1
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md:326 src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "`spin`"
msgstr "íšŒì „"

#: src/SUMMARY.md:328
#, fuzzy
msgid "`vmbase`"
msgstr "vmbase"

#: src/SUMMARY.md:330
msgid "RTC Driver"
msgstr "RTC ë“œë¼ì´ë²„"

#: src/SUMMARY.md:333
msgid "Concurrency: Morning"
msgstr "ë™ì‹œì„± ì˜¤ì „"

#: src/SUMMARY.md:338 src/concurrency/threads.md:1
msgid "Threads"
msgstr "ìŠ¤ë ˆë“œ"

#: src/SUMMARY.md:339 src/concurrency/scoped-threads.md:1
msgid "Scoped Threads"
msgstr "ë²”ìœ„ ìŠ¤ë ˆë“œ(Scoped Threads)"

#: src/SUMMARY.md:340 src/concurrency/channels.md:1
msgid "Channels"
msgstr "ì±„ë„"

#: src/SUMMARY.md:341 src/concurrency/channels/unbounded.md:1
msgid "Unbounded Channels"
msgstr "ë¬´ê²½ê³„ ì±„ë„"

#: src/SUMMARY.md:342 src/concurrency/channels/bounded.md:1
msgid "Bounded Channels"
msgstr "ê²½ê³„ ì±„ë„"

#: src/SUMMARY.md:343 src/concurrency/send-sync.md:1
msgid "`Send` and `Sync`"
msgstr "`Send`ì™€ `Sync`"

#: src/SUMMARY.md:344 src/concurrency/send-sync/send.md:1
msgid "`Send`"
msgstr "`Send`"

#: src/SUMMARY.md:345 src/concurrency/send-sync/sync.md:1
msgid "`Sync`"
msgstr "`Sync`"

#: src/SUMMARY.md:346 src/concurrency/send-sync/examples.md:1
msgid "Examples"
msgstr "ì˜ˆì œ"

#: src/SUMMARY.md:347 src/concurrency/shared_state.md:1
msgid "Shared State"
msgstr "ìƒíƒœ ê³µìœ "

#: src/SUMMARY.md:348 src/concurrency/shared_state/arc.md:1
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md:349 src/concurrency/shared_state/mutex.md:1
msgid "`Mutex`"
msgstr "`Mutex`"

#: src/SUMMARY.md:350 src/memory-management/review.md:16
#: src/error-handling/try-conversions.md:23
#: src/concurrency/shared_state/example.md:1
msgid "Example"
msgstr "ì˜ˆì œ"

#: src/SUMMARY.md:352 src/SUMMARY.md:374
#: src/exercises/concurrency/dining-philosophers.md:1
#: src/exercises/concurrency/solutions-morning.md:3
msgid "Dining Philosophers"
msgstr "ì‹ì‚¬í•˜ëŠ” ì² í•™ìë“¤"

#: src/SUMMARY.md:353 src/exercises/concurrency/link-checker.md:1
msgid "Multi-threaded Link Checker"
msgstr "ë©€í‹°ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°"

#: src/SUMMARY.md:356
msgid "Concurrency: Afternoon"
msgstr "ë™ì‹œì„± ì˜¤í›„"

#: src/SUMMARY.md:358
msgid "Async Basics"
msgstr "ë¹„ë™ê¸° ê´€ë ¨ ê¸°ë³¸ì‚¬í•­"

#: src/SUMMARY.md:359 src/async/async-await.md:1
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/SUMMARY.md:360 src/async/futures.md:1
msgid "Futures"
msgstr "Future"

#: src/SUMMARY.md:361 src/async/runtimes.md:1
msgid "Runtimes"
msgstr "ë¹„ë™ê¸° ëŸ°íƒ€ì„ë“¤"

#: src/SUMMARY.md:362 src/async/runtimes/tokio.md:1
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md:363 src/exercises/concurrency/link-checker.md:127
#: src/async/tasks.md:1 src/exercises/concurrency/chat-app.md:143
msgid "Tasks"
msgstr "íƒœìŠ¤í¬"

#: src/SUMMARY.md:364 src/async/channels.md:1
msgid "Async Channels"
msgstr "ë¹„ë™ê¸° ì±„ë„"

#: src/SUMMARY.md:365
msgid "Control Flow"
msgstr "íë¦„ ì œì–´"

#: src/SUMMARY.md:366 src/async/control-flow/join.md:1
msgid "Join"
msgstr "Join"

#: src/SUMMARY.md:367 src/async/control-flow/select.md:1
msgid "Select"
msgstr "Select"

#: src/SUMMARY.md:368
msgid "Pitfalls"
msgstr "í•¨ì •"

#: src/SUMMARY.md:369
msgid "Blocking the Executor"
msgstr "Executor ë¸”ë¡œí‚¹ í•˜ê¸°"

#: src/SUMMARY.md:370 src/async/pitfalls/pin.md:1
msgid "`Pin`"
msgstr ""

#: src/SUMMARY.md:371 src/async/pitfalls/async-traits.md:1
msgid "Async Traits"
msgstr "ë¹„ë™ê¸° íŠ¸ë ˆì‡"

#: src/SUMMARY.md:372 src/async/pitfalls/cancellation.md:1
msgid "Cancellation"
msgstr "ì·¨ì†Œ"

#: src/SUMMARY.md:375 src/exercises/concurrency/chat-app.md:1
#: src/exercises/concurrency/solutions-afternoon.md:95
msgid "Broadcast Chat Application"
msgstr "ì±„íŒ… ì• í”Œë¦¬ì¼€ì´ì…˜"

#: src/SUMMARY.md:378
msgid "Final Words"
msgstr "ëìœ¼ë¡œ..."

#: src/SUMMARY.md:382 src/thanks.md:1
msgid "Thanks!"
msgstr "ê°ì‚¬ì¸ì‚¬"

#: src/SUMMARY.md:383 src/glossary.md:1
msgid "Glossary"
msgstr ""

#: src/SUMMARY.md:384
msgid "Other Resources"
msgstr "ëŸ¬ìŠ¤íŠ¸ ì°¸ê³  ìë£Œ"

#: src/SUMMARY.md:385 src/credits.md:1
msgid "Credits"
msgstr "ë„ì™€ì£¼ì‹  ë¶„ë“¤"

#: src/index.md:3
#, fuzzy
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors)"

#: src/index.md:7
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"ì´ ê°•ì˜ëŠ” ë¬´ë£Œì´ë©°, Googleì˜ Android íŒ€ì´ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ ë¬¸ë²•ë¶€í„° ì œë„¤"
"ë¦­, ì—ëŸ¬ í•¸ë“¤ë§ê³¼ ê°™ì€ ê³ ê¸‰ì£¼ì œê¹Œì§€ ëŸ¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ê²ƒì„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/index.md:11
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""

#: src/index.md:15
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"ê°•ì˜ëŠ” ë‹¹ì‹ ì´ ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•´ì„œ ì•„ë¬´ê²ƒë„ ëª¨ë¥¸ë‹¤ê³  ê°€ì •í•˜ê³  ì•„ë˜ì˜ ëª©í‘œë¥¼ ê°€ì§€"
"ê³  ìˆìŠµë‹ˆë‹¤:"

#: src/index.md:18
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "ëŸ¬ìŠ¤íŠ¸ êµ¬ë¬¸ê³¼ ì–¸ì–´ì— ëŒ€í•œ í¬ê´„ì ì¸ ì´í•´ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/index.md:19
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr "ê¸°ì¡´ í”„ë¡œê·¸ë¨ì„ ìˆ˜ì •í•˜ê³  ëŸ¬ìŠ¤íŠ¸ì—ì„œ ìƒˆ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/index.md:20
msgid "Show you common Rust idioms."
msgstr "ì¼ë°˜ì ì¸ ëŸ¬ìŠ¤íŠ¸ ê´€ìš©êµ¬ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/index.md:22
#, fuzzy
msgid "We call the first four course days Rust Fundamentals."
msgstr "ê°•ì˜ì˜ ì²« 3ì¼ ë™ì•ˆì—ëŠ” Rustì˜ ê¸°ì´ˆë¥¼ ë‹¤ì§‘ë‹ˆë‹¤."

#: src/index.md:24
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr "ê·¸ í›„ì—ëŠ”, ì•„ë˜ì™€ ê°™ì€ ê°œë³„ ì£¼ì œë¥¼ ì‹¬í™”í•´ì„œ ê³µë¶€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/index.md:26
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md): Android í”Œë«í¼ ê°œë°œ(AOSP) ì‹œ Rust ì‚¬ìš©ì— ê´€í•œ ë°˜ë‚˜ì ˆ "
"ê³¼ì •ì…ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” C, C++, Javaì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±ì´ í¬í•¨ë©ë‹ˆë‹¤."

#: src/index.md:28
#, fuzzy
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[Android](android.md): Android í”Œë«í¼ ê°œë°œ(AOSP) ì‹œ Rust ì‚¬ìš©ì— ê´€í•œ ë°˜ë‚˜ì ˆ "
"ê³¼ì •ì…ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” C, C++, Javaì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±ì´ í¬í•¨ë©ë‹ˆë‹¤."

#: src/index.md:31
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md): bare-metal(ì„ë² ë””ë“œ) ê°œë°œ ì‹œ Rust ì‚¬ìš©ì— ê´€í•œ ì¢…"
"ì¼ ê³¼ì •ì…ë‹ˆë‹¤. ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì™€ ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œë¥¼ ëª¨ë‘ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/index.md:34
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[ë™ì‹œì„±](concurrency.md): Rustì˜ ë™ì‹œì„±ì— ê´€í•œ ì¢…ì¼ ê³¼ì •ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ê³ ì „"
"ì ì¸ ë™ì‹œì„±(ìŠ¤ë ˆë“œì™€ ë®¤í…ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„ ì í˜• ìŠ¤ì¼€ì¤„ë§ì„ í•˜ëŠ” ê²ƒ)ê³¼ async/"
"await ë™ì‹œì„±(futureë¥¼ ì‚¬ìš©í•˜ëŠ” í˜‘ë ¥ì ì¸ ë©€í‹°íƒœìŠ¤í‚¹)ì„ ëª¨ë‘ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/index.md:38
msgid "Non-Goals"
msgstr "ì œì™¸ì‚¬í•­"

#: src/index.md:40
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ë©°ì¹ ë§Œì— ëª¨ë“  ê²ƒì„ ë‹¤ë£¨ê¸°ì—ëŠ” ë„ˆë¬´ í° ì–¸ì–´ì…ë‹ˆë‹¤. ê·¸ë˜ì„œ ì•„ë˜ì™€ ê°™ì€"
"ê²ƒì„ ëª©í‘œë¡œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/index.md:43
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"ë§¤í¬ë¡œ ë§Œë“¤ê¸°: ë§¤í¬ë¡œì™€ ê´€ë ¨í•œ ìì„¸í•œ ë‚´ìš©ì€ [ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´, 19.1ì ˆ]"
"(https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)ê³¼ [Rustonomicon]"
"(https://doc.rust-lang.org/nomicon/)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/index.md:48
msgid "Assumptions"
msgstr "ë…ì ìˆ˜ì¤€ì— ëŒ€í•œ ê°€ì •"

#: src/index.md:50
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"ë³¸ ê°•ì˜ëŠ” ì—¬ëŸ¬ë¶„ì´ í”„ë¡œê·¸ë˜ë° ìì²´ì— ëŒ€í•´ì„œëŠ” ì•Œê³  ìˆë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸"
"ëŠ” ì •ì íƒ€ì… ì–¸ì–´ì´ë©°, ê°•ì¢Œì—ì„œëŠ” C/C++ ì™€ì˜ ë¹„êµ, ëŒ€ì¡°ë¥¼ í†µí•´ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì„¤ëª…"
"í•  ê²ƒì…ë‹ˆë‹¤."

#: src/index.md:54
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"C/C++ì„ ëª¨ë¥´ë”ë¼ë„ ë™ì  íƒ€ì… ì–¸ì–´(Pythonì´ë‚˜ JavaScript ë“±) í”„ë¡œê·¸ë˜ë° ê²½í—˜"
"ì´ ìˆë‹¤ë©´ ë”°ë¼ì˜¤ëŠ”ë° í° ë¬¸ì œëŠ” ì—†ì„ ê²ƒì…ë‹ˆë‹¤."

#: src/index.md:59
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"ì´ê²ƒì€ \"ë°œí‘œì ë…¸íŠ¸\"ì˜ ì˜ˆì œì…ë‹ˆë‹¤. ì´ ë¶€ë¶„ì„ ì´ìš©í•´ì„œ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆ"
"ë‹¤. ì£¼ë¡œ ê°•ì˜ì‹¤ì—ì„œ ì œê¸°ë˜ëŠ” ì¼ë°˜ì ì¸ ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ê³¼ ê°•ì‚¬ê°€ ë‹¤ë£¨ì–´ì•¼ í•  "
"í‚¤ í¬ì¸íŠ¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "This page is for the course instructor."
msgstr "ê°•ì‚¬ë¥¼ ìœ„í•œ ì•ˆë‚´ í˜ì´ì§€ì…ë‹ˆë‹¤."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"ë‹¤ìŒì€ êµ¬ê¸€ ë‚´ë¶€ì—ì„œ ì´ ê³¼ì •ì„ ì–´ë–¤ì‹ìœ¼ë¡œ ìš´ì˜í•´ì™”ëŠ”ì§€ì— ëŒ€í•œ ë°°ê²½ ì •ë³´ì…ë‹ˆ"
"ë‹¤."

#: src/running-the-course.md:8
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""

#: src/running-the-course.md:13
msgid "Before you run the course, you will want to:"
msgstr "ê°•ì˜ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì¤€ë¹„:"

#: src/running-the-course.md:15
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"ê°•ì˜ ìë£Œë¥¼ ìˆ™ì§€í•©ë‹ˆë‹¤. ì£¼ìš” ìš”ì ì„ ê°•ì¡°í•˜ê¸° ìœ„í•´ ê°•ì˜ ì°¸ì¡° ë…¸íŠ¸ë¥¼ í¬í•¨í•˜ì˜€ìŠµ"
"ë‹ˆë‹¤. (ì¶”ê°€ì ì¸ ë…¸íŠ¸ë¥¼ ì‘ì„±í•˜ì—¬ ì œê³µí•´ ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.) ê°•ì˜ ì°¸ì¡° ë…¸íŠ¸"
"ì˜ ë§í¬ë¥¼ ëˆ„ë¥´ë©´ ë³„ë„ì˜ íŒì—…ìœ¼ë¡œ ë¶„ë¦¬ê°€ ë˜ë©°, ë©”ì¸ í™”ë©´ì—ì„œëŠ” ì‚¬ë¼ì§‘ë‹ˆë‹¤. ê¹”"
"ë”í•œ í™”ë©´ìœ¼ë¡œ ê°•ì˜ë¥¼ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course.md:21
#, fuzzy
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"ê°•ì˜ ë‚ ì§œë¥¼ ì •í•©ë‹ˆë‹¤. ìµœì†Œ 3ì¼ì— ê±¸ì³ì„œ ì§„í–‰ì´ ë˜ê¸° ë•Œë¬¸ì—, ë‘ ì£¼ì— ê±¸ì³ì„œ ìŠ¤"
"ì¼€ì¤„ì„ ì¡ëŠ” ê²ƒì„ ê¶Œí•©ë‹ˆë‹¤. ê¸°ì¡´ ê°•ì˜ ìˆ˜ê°•ìƒë“¤ì˜ í”¼ë“œë°±ì— ë”°ë¥´ë©´, ì—°ë‹¬ì•„ì„œ ê°•"
"ì˜ë¥¼ ì§„í–‰í•˜ëŠ” ê²ƒ ë³´ë‹¤, ê°•ì˜ë¥¼ ë„ì—„ë„ì—„ í•˜ëŠ” ê²ƒì´ ê°•ì˜ ë‚´ìš©ì„ ì†Œí™”í•˜ëŠ”ë° ë” ë„"
"ì›€ì´ ë˜ì—ˆë‹¤ê³  í•©ë‹ˆë‹¤."

#: src/running-the-course.md:26
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"ì¶©ë¶„í•œ ê³µê°„ì„ í™•ë³´í•©ë‹ˆë‹¤. 15ì—ì„œ 20ëª… ê·œëª¨ì˜ ê³µê°„ì„ ì¶”ì²œí•©ë‹ˆë‹¤. ìˆ˜ê°•ìƒê³¼ ê°•ì‚¬"
"ê°€ ì§ˆì˜ë¥¼ í•˜ê¸°ì— ì¶©ë¶„í•œ ì‹œê°„ê³¼ ê³µê°„ì´ì–´ì•¼ í•©ë‹ˆë‹¤. ê°•ì‚¬ë‚˜ ìˆ˜ê°•ìƒ ëª¨ë‘ \\_ì±…ìƒ_"
"ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê°•ì˜ì‹¤ì´ë©´ ì¢‹ìŠµë‹ˆë‹¤. ê°•ì˜ ì¤‘ì— ê°•ì‚¬ê°€ ë¼ì´ë¸Œ ì½”ë”©ì„ í•˜ê²Œ "
"ë  ê²½ìš°ê°€ ë§ìœ¼ë©°, ì´ë•Œ ìë¦¬ì— ì•‰ì•„ ë…¸íŠ¸ë¶ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë„ì›€ì´ ë©ë‹ˆë‹¤."

#: src/running-the-course.md:34
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"ê°•ì˜ ë‹¹ì¼ ì¡°ê¸ˆ ì¼ì° ì™€ì„œ ì¤€ë¹„í•©ë‹ˆë‹¤. ê°•ì‚¬ ë…¸íŠ¸ë¶ì—ì„œ `mdbook serve`ë¥¼ ì´ìš©í•´ "
"ì§ì ‘ í”„ë ˆì  í…Œì´ì…˜ í•˜ë©´ í˜ì´ì§€ ì´ë™ ì‹œì˜ ì§€ì—°ì´ ì—†ìŠµë‹ˆë‹¤.([ì„¤ì¹˜ ë°©ë²•](https://"
"github.com/google/comprehensive-rust#building)ì„ ì°¸ì¡°í•˜ì„¸ìš”.) ë˜í•œ, ê·¸ë ‡ê²Œ í•˜"
"ë©´ ê°•ì˜ ë„ì¤‘ ì˜¤íƒ€ë¥¼ ë°œê²¬í–ˆì„ ë•Œ ê·¸ ìë¦¬ì—ì„œ ë°”ë¡œ ìˆ˜ì • ê°€ëŠ¥í•˜ë‹¤ëŠ” ì¥ì ë„ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/running-the-course.md:40
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"ìˆ˜ê°•ìƒë“¤ì´ ì§ì ‘ (ê°œë³„ í˜¹ì€ ê·¸ë£¹ìœ¼ë¡œ) ì—°ìŠµë¬¸ì œë¥¼ í’€ë„ë¡ í•©ë‹ˆë‹¤. ëŒ€ì²´ë¡œ ì˜¤ì „, "
"ì˜¤í›„ì— ê°ê° 30-45ë¶„ ì •ë„ë¥¼ ì—°ìŠµë¬¸ì œì— í• ë‹¹í•©ë‹ˆë‹¤ (ì´ëŠ” í•´ë‹µì„ ë³´ê³  ì„¤ëª…í•˜ëŠ” "
"ì‹œê°„ê¹Œì§€ í¬í•¨í•©ë‹ˆë‹¤). ë§‰í˜€ ë„ì›€ì„ í•„ìš”ë¡œ í•˜ëŠ” ìˆ˜ê°•ìƒì´ ì—†ëŠ”ì§€ ìˆ˜ì‹œë¡œ í™•ì¸í•©ë‹ˆ"
"ë‹¤. ë§Œì•½ ê°™ì€ ë¬¸ì œë¥¼ ì—¬ëŸ¬ ì‚¬ëŒì´ ê²ªê³  ìˆë‹¤ë©´, ê·¸ ë¬¸ì œë¥¼ ê°•ì˜ì‹¤ ì „ì²´ ì¸ì›ì—ê²Œ "
"ì•Œë¦¬ê³  í•´ê²°ì±…ì„ ì œì‹œí•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì–´ë””ì— ê°€ë©´ ê·¸ ë¬¸ì œì— "
"ëŒ€í•œ í•´ë‹µì„ ì°¾ì„ ìˆ˜ ìˆëŠ”ì§€ ì•Œë ¤ ì¤ë‹ˆë‹¤."

#: src/running-the-course.md:48
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"ì´ì œ ì¤€ë¹„ëŠ” ëë‚¬ìŠµë‹ˆë‹¤. ìš°ë¦¬ê°€ ê·¸ë¬ë“¯ì´ ì—¬ëŸ¬ë¶„ë“¤ë„ ì´ ê°•ì˜ë¥¼ ì¦ê¸°ì‹œê¸¸ ë°”ëë‹ˆ"
"ë‹¤!"

#: src/running-the-course.md:51
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"ê°•ì˜ë¥¼ ê³„ì† ê°œì„ í•  ìˆ˜ ìˆë„ë¡ [í”¼ë“œë°±](https://github.com/google/"
"comprehensive-rust/discussions/86)ì„ ì œê³µí•´ ì£¼ì‹­ì‹œì˜¤. ìš°ë¦¬ëŠ” ë¬´ì—‡ì´ ì¢‹ì•˜ê³ , "
"ë¬´ì—‡ì´ ëª¨ìëëŠ”ì§€ ë“£ê³  ì‹¶ìŠµë‹ˆë‹¤. ìˆ˜ê°•ìƒë“¤ë¡œ ë¶€í„°ì˜ [í”¼ë“œë°±](https://github."
"com/google/comprehensive-rust/discussions/100)ë„ í™˜ì˜í•©ë‹ˆë‹¤!"

#: src/running-the-course/course-structure.md:5
#, fuzzy
msgid "Rust Fundamentals"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬"

#: src/running-the-course/course-structure.md:7
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""

#: src/running-the-course/course-structure.md:10
msgid "{{%course outline Fundamentals}}"
msgstr ""

#: src/running-the-course/course-structure.md:12
msgid "Deep Dives"
msgstr "ì‹¬í™” í•™ìŠµ"

#: src/running-the-course/course-structure.md:14
#, fuzzy
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr "Rust ê¸°ì´ˆì— ê´€í•œ 3ì¼ ê³¼ì • ì´í›„ì—ëŠ”, ë‹¤ìŒê³¼ ê°™ì€ ì „ë¬¸ ì£¼ì œë¥¼ ë‹¤ë£¹ë‹ˆë‹¤:"

#: src/running-the-course/course-structure.md:17
#, fuzzy
msgid "Rust in Android"
msgstr "1ì¼ì°¨ ê°œìš”"

#: src/running-the-course/course-structure.md:19
#, fuzzy
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[Android ì‹¬í™” í•™ìŠµ](../android.md)ëŠ” Android í”Œë«í¼ ê°œë°œ ì‹œ Rust ì‚¬ìš©ì— ê´€í•œ "
"ë°˜ë‚˜ì ˆ ê³¼ì •ì…ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” C, C++, Javaì™€ì˜ ìƒí˜¸ ìš´ìš©ì„±ì´ í¬í•¨ë©ë‹ˆë‹¤."

#: src/running-the-course/course-structure.md:23
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"[AOSP ì½”ë“œ](https://source.android.com/docs/setup/download/downloading)ë¥¼ ì—¬"
"ëŸ¬ë¶„ì˜ ì»´í“¨í„°ì— ì²´í¬ì•„ì›ƒí•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ, ê·¸ ì»´í“¨í„°ì—ì„œ [ê³¼ì • ì €ì¥ì†Œ]"
"(https://github.com/google/comprehensive-rust)ë¥¼ ì²´í¬ì•„ì›ƒí•˜ê³  `src/android/` "
"ë””ë ‰í„°ë¦¬ë¥¼ AOSP ì½”ë“œì˜ ë£¨íŠ¸ë¡œ ì´ë™í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì•ˆë“œë¡œì´ë“œ ë¹Œë“œ ì‹œìŠ¤í…œ"
"ì—ì„œ ê³¼ì œìš©ìœ¼ë¡œ ì¶”ê°€ëœ `Android.bp`íŒŒì¼ì„ ì¸ì‹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course/course-structure.md:28
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"`adb sync` ëª…ë ì–´ê°€ ì—ë®¬ë ˆì´í„° í˜¹ì€ ì‹¤ì œ ì¥ì¹˜ì™€ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ê·¸ë¦¬"
"ê³  `src/android/build_all.sh`ë¥¼ ìˆ˜í–‰í•´ì„œ ëª¨ë“  ì•ˆë“œë¡œì´ë“œ ì˜ˆì œë¥¼ ë¯¸ë¦¬ ë¹Œë“œí•´ "
"ë³´ì„¸ìš”. ê·¸ ì‰˜ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì½ê³ , ê·¸ ì•ˆì—ì„œ ìˆ˜í–‰ë˜ëŠ” ëª…ë ¹ì–´ë“¤ì„ í™•ì¸í•œ í›„ ê° ëª…"
"ë ¹ì–´ë“¤ì„ ìˆ˜ë™ìœ¼ë¡œ ì‹¤í–‰í•´ë„ ì˜ ë˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/running-the-course/course-structure.md:35
#, fuzzy
msgid "Rust in Chromium"
msgstr "Rust on Exercism"

#: src/running-the-course/course-structure.md:37
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""

#: src/running-the-course/course-structure.md:42
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""

#: src/running-the-course/course-structure.md:46
#, fuzzy
msgid "Bare-Metal Rust"
msgstr "Bare-Metal"

#: src/running-the-course/course-structure.md:48
#, fuzzy
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[Bare-Metal ì‹¬í™” í•™ìŠµ](../bare-metal.md): bare-metal(ì„ë² ë””ë“œ) ê°œë°œ ì‹œ Rust "
"ì‚¬ìš©ì— ê´€í•œ ì¢…ì¼ ê³¼ì •ì…ë‹ˆë‹¤. ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì™€ ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œë¥¼ ëª¨ë‘ "
"ë‹¤ë£¹ë‹ˆë‹¤."

#: src/running-the-course/course-structure.md:52
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ íŒŒíŠ¸ë¥¼ ì§„í–‰í•˜ê¸° ìœ„í•´ì„œëŠ” [BBC micro:bit](https://microbit."
"org/) v2 ê°œë°œ ë³´ë“œë¥¼ ë¯¸ë¦¬ êµ¬ë§¤í•´ì•¼ í•©ë‹ˆë‹¤. ëª¨ë“  ì‚¬ìš©ìëŠ” [ì‹œì‘ í˜ì´ì§€](../"
"bare-metal.md)ì— ì„¤ëª…ëœ ëŒ€ë¡œ ê°ì¢… íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/running-the-course/course-structure.md:57
#, fuzzy
msgid "Concurrency in Rust"
msgstr "Welcome to Comprehensive Rust ğŸ¦€"

#: src/running-the-course/course-structure.md:59
#, fuzzy
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[ë™ì‹œì„± ì‹¬í™”í•™ìŠµ](../concurrency.md)ì€ ê³ ì „ì ì¸ ë™ì‹œì„± ë° `async`/`await` ë™"
"ì‹œì„±ì„ ë‹¤ë£¨ëŠ” ì¢…ì¼ ê³¼ì •ì…ë‹ˆë‹¤."

#: src/running-the-course/course-structure.md:62
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"ìƒˆ í¬ë ˆì´íŠ¸ë¥¼ ì„¤ì •í•˜ê³  ëª‡ ê°€ì§€ ì˜ì¡´ì„±ì„ ë‹¤ìš´ë¡œë“œí•´ ë‘ì–´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ "
"ì˜ˆì œë¥¼ `src/main.rs`ì— ë³µì‚¬/ë¶™ì—¬ë„£ê¸° í•˜ì—¬ í…ŒìŠ¤íŠ¸ í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/running-the-course/course-structure.md:73
msgid "Format"
msgstr "ê°•ì˜ í˜•ì‹"

#: src/running-the-course/course-structure.md:75
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"ì´ ê°•ì˜ëŠ” ê°•ì‚¬ì™€ ìˆ˜ê°•ìƒì´ ì–‘ë°©í–¥ìœ¼ë¡œ ì†Œí†µí•˜ë©´ì„œ ì§„í–‰í•˜ë„ë¡ ë””ìì¸ ë˜ì—ˆìŠµë‹ˆ"
"ë‹¤. ë‹¤ì–‘í•œ ì§ˆë¬¸ì„ í†µí•´ ëŸ¬ìŠ¤íŠ¸ì˜ ì—¬ëŸ¬ ë¶€ë¶„ì„ íƒí—˜í•  ìˆ˜ ìˆë„ë¡ í•˜ì„¸ìš”!"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "ë‹¤ìŒì€, mdBook ì‹œìŠ¤í…œ(í˜„ ì‚¬ì´íŠ¸)ì—ì„œ ìœ ìš©í•œ ë‹¨ì¶•í‚¤ë“¤ ì…ë‹ˆë‹¤:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid "Arrow-Left"
msgstr "ì™¼ìª½ í™”ì‚´í‘œ"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ": Navigate to the previous page."
msgstr ": ì´ì „ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤."

#: src/running-the-course/keyboard-shortcuts.md:6
msgid "Arrow-Right"
msgstr "ì˜¤ë¥¸ìª½ í™”ì‚´í‘œ"

#: src/running-the-course/keyboard-shortcuts.md:6
msgid ": Navigate to the next page."
msgstr ": ë‹¤ìŒ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤."

#: src/running-the-course/keyboard-shortcuts.md:7 src/cargo/code-samples.md:19
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md:7
msgid ": Execute the code sample that has focus."
msgstr ": í˜„ì¬ í¬ì»¤ìŠ¤ë¥¼ ë°›ì€ ì½”ë“œ ìƒ˜í”Œ ë¸”ë¡ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."

#: src/running-the-course/keyboard-shortcuts.md:8
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md:8
msgid ": Activate the search bar."
msgstr ""
": ê²€ìƒ‰ì°½ì„ í™œì„±í™”í•©ë‹ˆë‹¤.(mdBook ë¬¸ì œë¡œ 23.01.19 ê¸°ì¤€ ì˜ì–´ë¡œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.)"

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"ì´ ê³¼ì •ì€ ë‹¤ë¥¸ ì–¸ì–´ë¡œë„ ì œê³µë©ë‹ˆë‹¤. ê´„í˜¸ ì•ˆì€ ë²ˆì—­ì— ë„ì›€ ì£¼ì‹  ë¶„ë“¤ì…ë‹ˆë‹¤:"

#: src/running-the-course/translations.md:6
#, fuzzy
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[ë¸Œë¼ì§ˆ í¬ë¥´íˆ¬ê°ˆì–´](https://google.github.io/comprehensive-rust/pt-BR/): "
"[@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) ê·¸ë¦¬ê³  "
"[@henrif75](https://github.com/henrif75)ê°€ ì œê³µ."

#: src/running-the-course/translations.md:8
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""

#: src/running-the-course/translations.md:10
#, fuzzy
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[ë¸Œë¼ì§ˆ í¬ë¥´íˆ¬ê°ˆì–´](https://google.github.io/comprehensive-rust/pt-BR/): "
"[@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) ê·¸ë¦¬ê³  "
"[@henrif75](https://github.com/henrif75)ê°€ ì œê³µ."

#: src/running-the-course/translations.md:12
#, fuzzy
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""
"[í•œêµ­ì–´](https://google.github.io/comprehensive-rust/ko/): [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) ê·¸ë¦¬ê³  "
"[@jooyunghan](https://github.com/jooyunghan)ê°€ ì œê³µ."

#: src/running-the-course/translations.md:13
#, fuzzy
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[ë²µê°ˆì–´](https://google.github.io/comprehensive-rust/bn/): [@raselmandol]"
"(https://github.com/raselmandol) ì œê³µ."

#: src/running-the-course/translations.md:15
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr "í˜ì´ì§€ ì˜¤ë¥¸ìª½ ìœ„ì˜ ë©”ë‰´ë¥¼ í†µí•´ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/running-the-course/translations.md:17
msgid "Incomplete Translations"
msgstr "ë²ˆì—­ ë¬¸ì œ"

#: src/running-the-course/translations.md:19
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""
"ì§„í–‰ ì¤‘ì¸ ë²ˆì—­ì´ ë§ìŠµë‹ˆë‹¤. ìµœê·¼ì— ì—…ë°ì´íŠ¸ëœ ë²ˆì—­ë³¸ìœ¼ë¡œ ì—°ê²°ë˜ëŠ” ë§í¬ëŠ” ë‹¤ìŒ"
"ê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/running-the-course/translations.md:22
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[ë²µê°ˆì–´](https://google.github.io/comprehensive-rust/bn/): [@raselmandol]"
"(https://github.com/raselmandol) ì œê³µ."

#: src/running-the-course/translations.md:23
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""
"[í”„ë‘ìŠ¤ì–´](https://google.github.io/comprehensive-rust/fr/): [@KookaS]"
"(https://github.com/KookaS) ë° [@vcaen](https://github.com/vcaen) ì œê³µ."

#: src/running-the-course/translations.md:24
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[ë…ì¼ì–´](https://google.github.io/comprehensive-rust/de/): [@Throvn](https://"
"github.com/Throvn) ë° [@ronaldfw](https://github.com/ronaldfw) ì œê³µ."

#: src/running-the-course/translations.md:25
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[ì¼ë³¸ì–´](https://google.github.io/comprehensive-rust/ja/): [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) ë° [@momotaro1105](https://github.com/"
"momotaro1105) ì œê³µ."

#: src/running-the-course/translations.md:27
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"ì´ ê³¼ì •ì˜ ë²ˆì—­ ì‘ì—…ì— ë„ì›€ì„ ì£¼ê³  ì‹¶ë‹¤ë©´ [ì—¬ê¸°](https://github.com/google/"
"comprehensive-rust/blob/main/TRANSLATIONS.md) ì„¤ëª…ëœ ë‚´ìš©ì„ ì°¸ê³ í•˜ì„¸ìš”. ì§„í–‰ "
"ì¤‘ì¸ ë²ˆì—­ ì‘ì—…ì— ëŒ€í•œ ë‚´ìš©ì€ [ì´ìŠˆ íŠ¸ë˜ì»¤](https://github.com/google/"
"comprehensive-rust/issues/282)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”."

#: src/cargo.md:3
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ë¥¼ ì‹œì‘í•˜ë ¤ê³ í•˜ë©´ ë‹¹ì‹ ì€ ê³§ [Cargo](https://doc.rust-lang.org/cargo/)ë¼"
"ëŠ”, ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„ì—ì„œ ì‚¬ìš©í•˜ëŠ” í‘œì¤€ ë¹Œë“œ/ì‹¤í–‰ ë„êµ¬ë¥¼ ë§Œë‚  ê²ƒ ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ"
"ëŠ” ì¹´ê³ ê°€ ë¬´ì—‡ì¸ì§€, ê·¸ë¦¬ê³  ì¹´ê³ ê°€ ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„ì—ì„œ ì–´ë–¤ ì—­í• ì„ í•˜ëŠ”ì§€, ê·¸ë¦¬"
"ê³  ì´ ê°•ì˜ì—ì„œ ì–´ë–»ê²Œ ì‚¬ìš©ë  ì§€ì— ëŒ€í•´ ê°„ëµíˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤."

#: src/cargo.md:9
msgid "Installation"
msgstr "ì„¤ì¹˜í•˜ê¸°"

#: src/cargo.md:11
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**<https://rustup.rs/>ì˜ ì„¤ì¹˜ ë°©ë²•ì„ ë”°ë¥´ì„¸ìš”.**"

#: src/cargo.md:13
#, fuzzy
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"ìœ„ ì„¤ì¹˜ ë°©ë²•ì„ ë”°ë¥´ë©´, ë¹Œë“œ ì‹œìŠ¤í…œì¸ ì¹´ê³ (`cargo`)ì™€ ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬(`rustc`)"
"ê°€ ì„¤ì¹˜ë©ë‹ˆë‹¤. ì´ì™€ í•¨ê»˜, `rustup`ë„ ì„¤ì¹˜ë˜ëŠ”ë° ì´ íˆ´ì€ íˆ´ì²´ì¸ì„ ì„¤ì¹˜í•˜ê³ , ë‹¤"
"ë¥¸ íˆ´ì²´ì¸ìœ¼ë¡œ ì „í™˜í•˜ê³ , í¬ë¡œìŠ¤ ì»´íŒŒì¼ ì„¤ì •ì„ í•˜ëŠ” ì¼ì„ ë‹´ë‹¹í•˜ëŠ” ì»¤ë§¨ë“œ ë¼ì¸ "
"ìœ í‹¸ë¦¬í‹° ì…ë‹ˆë‹¤."

#: src/cargo.md:17
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""

#: src/cargo.md:25
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"ë°ë¹„ì•ˆ/ìš°ë¶„íˆ¬ ì‹œìŠ¤í…œì—ì„œëŠ” `apt`ë¥¼ ì´ìš©í•´ì„œ ì¹´ê³ , ëŸ¬ìŠ¤íŠ¸ ì†ŒìŠ¤, [ëŸ¬ìŠ¤íŠ¸ í¬ë§¤"
"í„°](https://github.com/rust-lang/rustfmt)ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ ë°©"
"ë²•ì„ ë”°ë¥¼ ê²½ìš° ìµœì‹  ë²„ì „ì´ ì•„ë‹Œ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©ê²Œë˜ë©°, ê·¸ ê²°ê³¼ ì˜ˆìƒì¹˜ ëª»í•œ ë¬¸ì œ"
"ë¥¼ ê²ªì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì„¤ì¹˜ ëª…ë ¹ì–´ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/cargo/rust-ecosystem.md:1
msgid "The Rust Ecosystem"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„"

#: src/cargo/rust-ecosystem.md:3
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì˜ ìƒíƒœê³„ëŠ” ì—¬ëŸ¬ê°€ì§€ ë„êµ¬ë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ê·¸ ì¤‘ ì¤‘ìš”í•œ ê²ƒë“¤ì€ ì•„ë˜"
"ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/cargo/rust-ecosystem.md:5
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"`rustc`: `.rs` í™•ì¥ì íŒŒì¼ì„ ë°”ì´ë„ˆë¦¬ í˜¹ì€ ë‹¤ë¥¸ ì¤‘ê°„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•´ì£¼ëŠ” "
"Rust ì»´íŒŒì¼ëŸ¬ì…ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`: ëŸ¬ìŠ¤íŠ¸ ì˜ì¡´ì„± ê´€ë¦¬ìì´ì ë¹Œë“œ ì‹œìŠ¤í…œ ì…ë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ í”„ë¡œì íŠ¸ì— ëª…"
"ì‹œëœ ì˜ì¡´ì„±ë“¤ì„ <https://crates.io>ì—ì„œ ìë™ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œ ë°›ê³ , ê·¸ ì†ŒìŠ¤ì½”ë“œ"
"ë¥¼ `rustc`ë¡œ ì „ë‹¬í•˜ì—¬ ë¹Œë“œë¥¼ ì‹œí‚µë‹ˆë‹¤. ë˜í•œ ìœ ë‹› í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ëŠ” í…ŒìŠ¤íŠ¸ ëŸ¬"
"ë„ˆë¥¼ ë‚´ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:13
#, fuzzy
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`: ëŸ¬ìŠ¤íŠ¸ íˆ´ì²´ì¸ ì„¤ì¹˜ í”„ë¡œê·¸ë¨ì´ì ì—…ë°ì´íŠ¸ í”„ë¡œê·¸ë¨ ì…ë‹ˆë‹¤. ì´ ë„êµ¬"
"ëŠ” ìƒˆ ë²„ì „ì˜ ëŸ¬ìŠ¤íŠ¸ê°€ ì¶œì‹œë  ë•Œ `rustc` ë° `cargo` ì„¤ì¹˜í•˜ê³  ì—…ë°ì´íŠ¸í•˜ëŠ” ë° "
"ì‚¬ìš©ë©ë‹ˆë‹¤. ë˜í•œ `rustup`ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ ë¬¸ì„œë¥¼ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ë„ ìˆ"
"ìŠµë‹ˆë‹¤. í•œ ë²ˆì— ì—¬ëŸ¬ ë²„ì „ì˜ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ìˆìœ¼ë©° `rustup`ì„ ì´ìš©í•´ì„œ ì‹¤"
"ì œë¡œ ì‚¬ìš©í•  ë²„ì „ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:21 src/hello-world/hello-world.md:25
#: src/tuples-and-arrays/tuples-and-arrays.md:38 src/references/exclusive.md:19
#: src/pattern-matching/destructuring.md:68 src/memory-management/move.md:152
#: src/error-handling/try.md:52 src/android/setup.md:18
#: src/concurrency/threads.md:30 src/async/async-await.md:25
msgid "Key points:"
msgstr "í‚¤ í¬ì¸íŠ¸:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” 6ì£¼ë§ˆë‹¤ ìƒˆë¡œìš´ ë¦´ë¦¬ì¦ˆê°€ ë°œí‘œë˜ë©° ì´ì „ ë¦´ë¦¬ì¦ˆì™€ì˜ í˜¸í™˜ì„±ì„ ìœ ì§€í•˜ê³  "
"ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:27
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""
"ë¦´ë¦¬ì¦ˆëŠ” 3ê°€ì§€ ë²„ì „ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤: \"stable\", \"beta\" ê·¸ë¦¬ê³  \"nightly\"."

#: src/cargo/rust-ecosystem.md:29
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""
"ìƒˆë¡œìš´ ê¸°ëŠ¥ì€ \"nightly\" -> \"beta\" -(6ì£¼ í›„)-> \"stable\" ë¡œ ë³€ê²½ë©ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:32
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"ì˜ì¡´ì„±ì€ ë‹¤ì–‘í•œ [ì €ì¥ì†Œ](registries), git í”„ë¡œì íŠ¸, ë””ë ‰í„°ë¦¬ ë“±ì—ì„œ ì œê³µë  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:35
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” [ì—ë””ì…˜](https://doc.rust-lang.org/edition-guide/)ìœ¼ë¡œ êµ¬ë¶„ë©ë‹ˆë‹¤. "
"í˜„ì¬ëŠ” Rust 2021 ì—ë””ì…˜ì…ë‹ˆë‹¤. ì´ ì „ ì—ë””ì…˜ìœ¼ë¡œ Rust 2015ì™€ Rust 2018ì´ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:38
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr "ì—ë””ì…˜ì€ ì´ì „ ì—ë””ì…˜ê³¼ í˜¸í™˜ì´ ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:41
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"ì—ë””ì…˜ì´ ë°”ë€Œë©´ì„œ í”„ë¡œê·¸ë¨ì´ ì˜ë„ì¹˜ ì•Šê²Œ ê¹¨ì§€ëŠ” ë¬¸ì œë¥¼ ë§‰ê¸° ìœ„í•´, ê° í”„ë¡œê·¸ë¨"
"ì€ ìì‹ ì´ ë¹Œë“œë  ì—ë””ì…˜ì„ ëª…ì‹œì ìœ¼ë¡œ `Cargo.toml`ì— ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:44
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„ê°€ ì—ë””ì…˜ ë³„ë¡œ íŒŒí¸íšŒ ë˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´, ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ì„œ"
"ë¡œ ë‹¤ë¥¸ ì—ë””ì…˜ì—ì„œ ì‘ì„±ëœ ì½”ë“œë“¤ì„ í•˜ë‚˜ì˜ ë°”ì´ë„ˆë¦¬ë¡œ ë¬¶ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:47
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"`cargo`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì»´íŒŒì¼ëŸ¬ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŒì„ ì–¸ê¸‰í•´ ì£¼"
"ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo/rust-ecosystem.md:50
#, fuzzy
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr ""
"ì¹´ê³  ìì²´ê°€ ë§¤ìš° ê°•ë ¥í•˜ê³  í¬ê´„ì ì¸ ë„êµ¬ì„ì„ ì ê·¹ì ìœ¼ë¡œ ì•Œë¦¬ì„¸ìš”. ì¹´ê³ ëŠ” ë‹¤ìŒ"
"ê³¼ ê°™ì€ ë‹¤ì–‘í•œ ê³ ê¸‰ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤: "

#: src/cargo/rust-ecosystem.md:53
msgid "Project/package structure"
msgstr "í”„ë¡œì íŠ¸/íŒ¨í‚¤ì§€ êµ¬ì¡°í™”"

#: src/cargo/rust-ecosystem.md:54
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""
"[ì›Œí¬ìŠ¤í˜ì´ìŠ¤](https://doc.rust-lang.org/cargo/reference/workspaces.html)"

#: src/cargo/rust-ecosystem.md:55
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "ê°œë°œ/ëŸ°íƒ€ì„ ì¢…ì†ì„± ê´€ë¦¬ ë° ìºì‹±"

#: src/cargo/rust-ecosystem.md:56
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""
"[ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸](https://doc.rust-lang.org/cargo/reference/build-scripts.html)"

#: src/cargo/rust-ecosystem.md:57
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""
"[ì „ì—­ ì„¤ì¹˜](https://doc.rust-lang.org/cargo/commands/cargo-install.html)"

#: src/cargo/rust-ecosystem.md:58
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"[cargo clippy](https://github.com/rust-lang/rust-clippy)ì™€ ê°™ì€ í•˜ìœ„ í”ŒëŸ¬ê·¸ì¸"
"ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥."

#: src/cargo/rust-ecosystem.md:60
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""
"[ê³µì‹ Cargo Book](https://doc.rust-lang.org/cargo/)ì—ì„œ ìì„¸í•œ ì‚¬í•­ì„ í™•ì¸í•˜"
"ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo/code-samples.md:1
msgid "Code Samples in This Training"
msgstr "ê°•ì˜ì—ì„œì˜ ì½”ë“œ ìƒ˜í”Œ"

#: src/cargo/code-samples.md:3
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"ì´ ê°•ì˜ìë£Œì— ìˆëŠ” ëª¨ë“  ì˜ˆì œëŠ” ë¸Œë¼ìš°ì €ì—ì„œ ë°”ë¡œ ìˆ˜í–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•œ "
"ì´ìœ ëŠ”, ì¤€ë¹„ ê³¼ì •ì„ ë‹¨ìˆœí™” ì‹œí‚¤ê³ , ëª¨ë‘ê°€ ê°™ì€ í™˜ê²½ì—ì„œ ì‘ì—…í•  ìˆ˜ ìˆë„ë¡ í•˜"
"ê¸° ìœ„í•¨ì…ë‹ˆë‹¤."

#: src/cargo/code-samples.md:7
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ , ì¹´ê³ (cargo)ë¥¼ ì§ì ‘ ì„¤ì¹˜í•˜ëŠ” ê²ƒì„ ê°•ë ¥ ê¶Œì¥í•©ë‹ˆë‹¤. ì´ê²Œ ê³¼"
"ì œ ì‘ì„±ì— ë” ë„ì›€ì´ ë ê²ë‹ˆë‹¤. ë˜í•œ, ë§ˆì§€ë§‰ ë‚ ì—ëŠ” ì˜ì¡´ì„±ì´ ìˆëŠ” ì˜ˆì œë¥¼ ì‘ì—…í•˜"
"ê²Œ ë  í…ë°, ê·¸ ë•Œì—ëŠ” ì–´ì°¨í”¼ ì¹´ê³ ê°€ í•„ìš”í•©ë‹ˆë‹¤."

#: src/cargo/code-samples.md:11
msgid "The code blocks in this course are fully interactive:"
msgstr "ì´ ê°•ì˜ ìë£Œì˜ ì½”ë“œ ë¸”ë¡ë“¤ì€ ì „ë¶€ ì¸í„°ì—‘í‹°ë¸Œ í•©ë‹ˆë‹¤:"

#: src/cargo/code-samples.md:15 src/cargo/running-locally.md:46
msgid "\"Edit me!\""
msgstr ""

#: src/cargo/code-samples.md:19
msgid "You can use "
msgstr "ì½”ë“œ ë¸”ë¡ì— í¬ì»¤ìŠ¤ë¥¼ ë‘ê³  "

#: src/cargo/code-samples.md:19
msgid " to execute the code when focus is in the text box."
msgstr " ë¥¼ ëˆŒëŸ¬ ì‹¤í–‰í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/code-samples.md:24
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"ê°•ì˜ì—ì„œ ëŒ€ë¶€ë¶„ì˜ ì½”ë“œ ìƒ˜í”Œì€ ìœ„ì™€ ê°™ì´ ìˆ˜ì •í• ìˆ˜ ìˆì§€ë§Œ ì¼ë¶€ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™"
"ì€ ì´ìœ ë¡œ ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/cargo/code-samples.md:27
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"ìœ ë‹› í…ŒìŠ¤íŠ¸ëŠ” ë‚´ì¥ í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ì´ ì•ˆë©ë‹ˆë‹¤. ì™¸ë¶€ í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì‚¬"
"ì´íŠ¸ì— ë¶™ì—¬ë„£ì–´ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/cargo/code-samples.md:30
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"ë‚´ì¥ëœ í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œëŠ” í˜ì´ì§€ ì´ë™ì‹œ ì‘ì„±ëœ ëª¨ë“  ë‚´ìš©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤. ë”°ë¼"
"ì„œ ë¡œì»¬ í™˜ê²½ì´ë‚˜ ì™¸ë¶€ í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì‚¬ì´íŠ¸ì—ì„œ ì—°ìŠµë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµ"
"ë‹ˆë‹¤."

#: src/cargo/running-locally.md:1
msgid "Running Code Locally with Cargo"
msgstr "ë¡œì»¬ í™˜ê²½ì˜ ì¹´ê³ "

#: src/cargo/running-locally.md:3
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"ë§Œì•½ ê°œì¸ìš© ì»´í“¨í„°ì—ì„œ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë ¤ë©´ ë¨¼ì € ëŸ¬ìŠ¤íŠ¸ë¥¼ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. "
"[Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html)ì˜ ì§€ì¹¨"
"ì— ë”°ë¼ `rustc`ì™€ `cargo`ë¥¼ í•¨ê»˜ ì„¤ì¹˜ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì„¤ì¹˜ í›„ ì•„ë˜ ì»¤ë§¨ë“œë¥¼ "
"í†µí•´ ê° íˆ´ì˜ ë²„ì „ì„ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/cargo/running-locally.md:16
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""
"ì´ ë²„ì „ë³´ë‹¤ ë” ìµœì‹ ì˜ ë²„ì „ì´ì–´ë„ ìƒê´€ ì—†ìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” í•˜ìœ„ í˜¸í™˜ì„±ì„ ì§€ì›í•©"
"ë‹ˆë‹¤."

#: src/cargo/running-locally.md:18
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"ì •ìƒì ìœ¼ë¡œ ì„¤ì¹˜ê°€ ë˜ì—ˆìœ¼ë©´, ê°•ì˜ ì˜ˆì œì¤‘ í•˜ë‚˜ë¥¼ ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬ë¡œ ë¹Œë“œí•´ ë´…ì‹œ"
"ë‹¤:"

#: src/cargo/running-locally.md:21
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "ì˜ˆì‹œ ë¸”ë¡ì— ìˆëŠ” \"Copy to clipboard\" ë²„íŠ¼ì„ í´ë¦­í•´ì„œ ë³µì‚¬í•©ë‹ˆë‹¤."

#: src/cargo/running-locally.md:23
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""
"í„°ë¯¸ë„ì—ì„œ `cargo new exercise`ë¥¼ ì…ë ¥í•´ì„œ ìƒˆë¡œìš´ `exercise/` í´ë”ë¥¼ ë§Œë“­ë‹ˆ"
"ë‹¤:"

#: src/cargo/running-locally.md:30
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr "`exercise/` í´ë”ë¡œ ì´ë™í•œ í›„, `cargo run` ì»¤ë§¨ë“œë¡œ ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/cargo/running-locally.md:41
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"`src/main.rs`ì— ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì´ì „ í˜ì´ì§€ì˜ ì†ŒìŠ¤ë¥¼ ì•„ë˜ì™€ ê°™"
"ì´ `src/main.rs`ì— ì‘ì„±í•©ë‹ˆë‹¤"

#: src/cargo/running-locally.md:50
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "`cargo run`ì»¤ë§¨ë“œë¡œ ì†ŒìŠ¤ë¥¼ ë¹Œë“œí•˜ê³  ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/cargo/running-locally.md:60
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"`cargo check`ì»¤ë§¨ë“œëŠ” ë¹ ë¥´ê²Œ ì—ëŸ¬ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `cargo build`ëŠ” ì‹¤í–‰"
"ì—†ì´ ì»´íŒŒì¼ë§Œ í•©ë‹ˆë‹¤. ì´ ê²½ìš°ì— `target/debug/`í´ë”ì—ì„œ outputì„ í™•ì¸ í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. `cargo build --release`ì»¤ë§¨ë“œëŠ” ë¦´ë¦¬ì¦ˆ ë²„ì „ìš© ìµœì í™”ë¥¼ ì¼œì„œ ì»´íŒŒì¼"
"í•˜ë©° `target/release/`í´ë”ì—ì„œ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/cargo/running-locally.md:65
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"`Cargo.toml`íŒŒì¼ì—ëŠ” ì˜ì¡´ì„± íŒ¨í‚¤ì§€ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `cargo`ì»¤ë§¨ë“œë¥¼ ì‹¤í–‰"
"í•˜ë©´ ìë™ìœ¼ë¡œ ì˜ì¡´ì„± íŒ¨í‚¤ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ê³  ì»´íŒŒì¼ ê¹Œì§€ í•´ ì¤ë‹ˆë‹¤."

#: src/cargo/running-locally.md:73
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"ìˆ˜ê°•ìƒë“¤ì´ ì¹´ê³ ë¥¼ ì„¤ì¹˜í•˜ê³  ë¡œì»¬ í¸ì§‘ê¸°ë¥¼ ì´ìš©í•˜ë„ë¡ ë…ë ¤í•˜ì„¸ìš”. ì¡°ê¸ˆ ê·€ì°®ì„ "
"ìˆ˜ë„ ìˆì§€ë§Œ, ì´ë ‡ê²Œ í•´ì•¼ë§Œ ì¢€ ë” ì‹¤ì œì™€ ê°€ê¹Œìš´ ê°œë°œí™˜ê²½ì„ ê°–ì¶”ê²Œ ë˜ëŠ” ê²ƒì…ë‹ˆ"
"ë‹¤."

#: src/welcome-day-1.md:1
msgid "Welcome to Day 1"
msgstr "1ì¼ì°¨ ê°œìš”"

#: src/welcome-day-1.md:3
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr "ê°•ì˜ ì²« ë‚ ì…ë‹ˆë‹¤. ì˜¤ëŠ˜ ë°°ìš¸ ê²ƒì´ ì°¸ ë§ìŠµë‹ˆë‹¤:"

#: src/welcome-day-1.md:5
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ ê¸°ë³¸ ë¬¸ë²•: ë³€ìˆ˜, ìŠ¤ì¹¼ë¼ / ë³µí•© íƒ€ì…, ì—´ê±°í˜•, êµ¬ì¡°ì²´, ì°¸ì¡°í˜•, í•¨ìˆ˜ì™€ ë©”"
"ì„œë“œ."

#: src/welcome-day-1.md:7
#, fuzzy
msgid "Types and type inference."
msgstr "íƒ€ì… ì¶”ë¡ "

#: src/welcome-day-1.md:8
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr ""

#: src/welcome-day-1.md:9
msgid "User-defined types: structs and enums."
msgstr ""

#: src/welcome-day-1.md:10
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr "íŒ¨í„´ ë§¤ì¹­: ì—´ê±°í˜•, êµ¬ì¡°ì²´ ê·¸ë¦¬ê³  ë°°ì—´ ë¶„í•´."

#: src/welcome-day-1.md:12 src/welcome-day-2.md:12 src/welcome-day-3.md:9
#: src/welcome-day-4.md:11
msgid "Schedule"
msgstr ""

#: src/welcome-day-1.md:14 src/welcome-day-1-afternoon.md:3
#: src/welcome-day-2.md:14 src/welcome-day-2-afternoon.md:3
#: src/welcome-day-3.md:11 src/welcome-day-3-afternoon.md:3
#: src/welcome-day-4.md:13 src/welcome-day-4-afternoon.md:3
msgid "{{%session outline}}"
msgstr ""

#: src/welcome-day-1.md:18
msgid "Please remind the students that:"
msgstr "í•™ìƒë“¤ì—ê²Œ ë‹¤ìŒì„ ìƒê¸°ì‹œì¼œ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/welcome-day-1.md:20
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr "ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ë©´ ì£¼ì €í•˜ì§€ ë§ê³  ì§ˆë¬¸ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/welcome-day-1.md:21
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr "ì´ ìˆ˜ì—…ì€ ìƒí˜¸ì‘ìš©ì´ ìš”í•©ë‹ˆë‹¤. í† ë¡ ì„ ë§ì„¤ì´ì§€ ë§ˆì„¸ìš”!"

#: src/welcome-day-1.md:22
#, fuzzy
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"ê°•ì‚¬ë¡œì„œ í† ë¡ ì´ ì˜†ê¸¸ë¡œ ìƒˆì§€ ì•Šê²Œ ì£¼ì˜í•˜ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´ ëŸ¬ìŠ¤íŠ¸ì™€ ë‹¤ë¥¸ ì–¸ì–´ë“¤"
"ì„ ë¹„êµí•œë‹¤ë“ ì§€ í•˜ëŠ” ê²ƒì€ ì¢‹ìŠµë‹ˆë‹¤. ì ì ˆí•œ ê· í˜•ì„ ì°¾ê¸° ì• ë§¤í•œ ê²½ìš°ë¼ë©´ í† ë¡ "
"ì„ í—ˆìš©í•˜ëŠ” ìª½ì´ ì¼ë°©ì ì¸ ê°•ì˜ë³´ë‹¤ëŠ” ë” ë§ì€ ì‚¬ëŒë“¤ì˜ ì°¸ì—¬ë¥¼ ì´ëŒì–´ ë‚¼ ìˆ˜ ìˆ"
"ìŠµë‹ˆë‹¤."

#: src/welcome-day-1.md:26
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr "ì§ˆë¬¸ì´ ìŠ¬ë¼ì´ë“œë³´ë‹¤ ì•ì„œê°€ë„ ê´œì°®ìŠµë‹ˆë‹¤."

#: src/welcome-day-1.md:27
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"í•™ìŠµì— ìˆì–´ì„œ ë°˜ë³µì€ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ìŠ¬ë¼ì´ë“œëŠ” ê·¸ì € ë„ì›€ì„ ì¤„ ë¿, ì›í•˜ëŠ” ëŒ€"
"ë¡œ ê±´ë„ˆë„ì–´ë„ ë©ë‹ˆë‹¤."

#: src/welcome-day-1.md:31
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""

#: src/welcome-day-1.md:35
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""

#: src/hello-world.md:3 src/types-and-values.md:3 src/control-flow-basics.md:3
#: src/tuples-and-arrays.md:3 src/references.md:3 src/user-defined-types.md:3
#: src/pattern-matching.md:3 src/methods-and-traits.md:3 src/generics.md:3
#: src/std-types.md:3 src/std-traits.md:3 src/memory-management.md:3
#: src/smart-pointers.md:3 src/borrowing.md:3 src/slices-and-lifetimes.md:3
#: src/iterators.md:3 src/modules.md:3 src/testing.md:3 src/error-handling.md:3
#: src/unsafe-rust.md:3
msgid "{{%segment outline}}"
msgstr ""

#: src/hello-world/what-is-rust.md:3
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” 2015ë…„ì— [ë²„ì „ 1.0](https://blog.rust-lang.org/2015/05/15/Rust-1.0."
"html)ì„ ë¦´ë¦¬ì¦ˆ í•œ ìƒˆë¡œìš´ í”„ë¡œê·¸ë¨ ì–¸ì–´ì…ë‹ˆë‹¤:"

#: src/hello-world/what-is-rust.md:5
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” C++ì™€ ìœ ì‚¬í•œ ì •ì  ì»´íŒŒì¼ ì–¸ì–´ì…ë‹ˆë‹¤"

#: src/hello-world/what-is-rust.md:6
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc`ëŠ” LLVMì„ ë°±ì—”ë“œë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/hello-world/what-is-rust.md:7
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ì–‘í•œ í”Œë«í¼ê³¼ ì•„í‚¤í…ì³ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/hello-world/what-is-rust.md:9
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/hello-world/what-is-rust.md:10
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/hello-world/what-is-rust.md:11
msgid "Rust is used for a wide range of devices:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ì–‘í•œ ì¥ì¹˜ì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/hello-world/what-is-rust.md:12
msgid "firmware and boot loaders,"
msgstr "íŒì›¨ì–´ì™€ ë¶€íŠ¸ë¡œë”(ì„ë² ë””ë“œ)"

#: src/hello-world/what-is-rust.md:13
msgid "smart displays,"
msgstr "ìŠ¤ë§ˆíŠ¸ ë””ìŠ¤í”Œë ˆì´,"

#: src/hello-world/what-is-rust.md:14
msgid "mobile phones,"
msgstr "ìŠ¤ë§ˆíŠ¸í°,"

#: src/hello-world/what-is-rust.md:15
msgid "desktops,"
msgstr "ë°ìŠ¤í¬íƒ‘,"

#: src/hello-world/what-is-rust.md:16
msgid "servers."
msgstr "ì„œë²„."

#: src/hello-world/what-is-rust.md:20
msgid "Rust fits in the same area as C++:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” C++ê°€ ì‚¬ìš©ë˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ê³³ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/hello-world/what-is-rust.md:22
msgid "High flexibility."
msgstr "ë†’ì€ ìœ ì—°ì„±."

#: src/hello-world/what-is-rust.md:23
msgid "High level of control."
msgstr "ë†’ì€ ìˆ˜ì¤€ì˜ ì œì–´."

#: src/hello-world/what-is-rust.md:24
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ê°™ì€ ë§¤ìš° ì œí•œëœ ì¥ì¹˜ë¡œ ìŠ¤ì¼€ì¼ ë‹¤ìš´ ê°€ëŠ¥."

#: src/hello-world/what-is-rust.md:25
msgid "Has no runtime or garbage collection."
msgstr "ë³„ë„ì˜ ëŸ°íƒ€ì„ì„ í•„ìš”ë¡œ í•˜ì§€ ì•Šìœ¼ë©°, ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ë„ ì—†ìŒ."

#: src/hello-world/what-is-rust.md:26
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr "ì„±ëŠ¥ì„ íƒ€í˜‘í•˜ì§€ ì•Šìœ¼ë©´ì„œë„ ì•ˆì •ì„±ê³¼ ì•ˆì „ì— ì¤‘ì ì„ ë‘ ."

#: src/hello-world/hello-world.md:3
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"ê°€ì¥ ê°„ë‹¨í•œ ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ìœ¼ë¡œì¨, ê³ ì „ì ì¸ Hello World ë¥¼ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/hello-world/hello-world.md:8
msgid "\"Hello ğŸŒ!\""
msgstr ""

#: src/hello-world/hello-world.md:12
msgid "What you see:"
msgstr "í™•ì¸í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤:"

#: src/hello-world/hello-world.md:14
msgid "Functions are introduced with `fn`."
msgstr "í•¨ìˆ˜ëŠ” `fn`ìœ¼ë¡œ ì„ ì–¸í•©ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:15
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "C/C++ ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì¤‘ê´„í˜¸`{}`ë¡œ ë¸”ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:16
msgid "The `main` function is the entry point of the program."
msgstr "`main` í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ ì§„ì…ì ì…ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:17
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ë˜‘ë˜‘í•œ ë§¤í¬ë¡œ(hygienic macros) ì‹œìŠ¤í…œì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. `println!`"
"ëŠ” ê·¸ ì˜ˆì‹œì…ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:18
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì˜ ë¬¸ìì—´ì€ UTF-8ë¡œ ì¸ì½”ë”©ë˜ë©° ì´ëª¨ì§€ì™€ ê°™ì€ ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ í¬í•¨í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/hello-world/hello-world.md:22
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"ì´ ìŠ¬ë¼ì´ë“œëŠ” í•™ìƒë“¤ì´ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œì— ìµìˆ™í•´ì§€ê¸° ìœ„í•´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì•ìœ¼ë¡œ 3"
"ì¼ ë™ì•ˆ ë§ì€ ì½”ë“œë¥¼ ì ‘í•  ê²ƒì´ê¸° ë•Œë¬¸ì— ìš°ì„  ì¹œìˆ™í•œ ì½”ë“œë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:27
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” C/C++/Javaì™€ ê°™ì€ ì „í†µì ì¸ ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ì ˆ"
"ì°¨ì  ì–¸ì–´ì…ë‹ˆë‹¤. ì •ë§ë¡œ í•„ìš”í•œ ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´, ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²ƒì„ "
"ìƒˆë¡œ êµ¬í˜„í•˜ë ¤ê³  í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/hello-world/hello-world.md:30
msgid "Rust is modern with full support for things like Unicode."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ìœ ë‹ˆì½”ë“œ ì§€ì›ê³¼ ê°™ì€ í˜„ëŒ€ ì–¸ì–´ì˜ íŠ¹ì§•ì„ ì „ë¶€ ì§€ì›í•©ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:32
#, fuzzy
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì¸ìì˜ ê°œìˆ˜ë¥¼ ì‚¬ì „ì— ì§€ì •í•  ìˆ˜ ì—†ëŠ” ìƒí™©ì—ì„œ í•¨ìˆ˜ [ì˜¤ë²„ë¡œë”©](basic-"
"syntax/functions-interlude.md)ëŒ€ì‹  ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/hello-world/hello-world.md:35
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"ë˜‘ë˜‘í•œ ë§¤í¬ë¡œ(hygienic macro)ëŠ” ë§¤í¬ë¡œê°€ ì‚¬ìš©ë˜ëŠ” ìŠ¤ì½”í”„ì—ì„œ ì˜ë„ì¹˜ ì•Šê²Œ ë³€ìˆ˜"
"ë¥¼ ê°€ë¡œì±„ì§€ ì•ŠìŠµë‹ˆë‹¤. ì‚¬ì‹¤ ëŸ¬ìŠ¤íŠ¸ ë§¤í¬ë¡œëŠ” ì™„ì „íˆ hygenicí•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. [ë§"
"í¬](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html)ë¥¼ ì°¸"
"ê³ í•˜ì„¸ìš”."

#: src/hello-world/hello-world.md:39
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ë©€í‹° íŒ¨ëŸ¬ë‹¤ì„ ì–¸ì–´ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ê°•ë ¥í•œ [ê°ì²´ ì§€í–¥ í”„ë¡œê·¸ë˜ë° ê¸°"
"ëŠ¥](https://doc.rust-lang.org/book/ch17-00-oop.html)ì„ ì§€ì›í•˜ê¸°ë„ í•˜ë©°, í•¨ìˆ˜"
"í˜• ì–¸ì–´ë¡œ ë¶„ë¥˜ë˜ì§€ëŠ” ì•Šì§€ë§Œ í­ë„“ì€ ë²”ìœ„ì˜ [í•¨ìˆ˜í˜• ì»¨ì…‰](https://doc.rust-"
"lang.org/book/ch13-00-functional-features.html)ì„ ì§€ì›í•©ë‹ˆë‹¤."

#: src/hello-world/benefits.md:3
msgid "Some unique selling points of Rust:"
msgstr "ëŸ¬ìŠ¤íŠ¸ë§Œì˜ ë…íŠ¹í•œ ì„¸ì¼ì¦ˆ í¬ì¸íŠ¸(ì¥ì ):"

#: src/hello-world/benefits.md:5
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr ""

#: src/hello-world/benefits.md:7
msgid "No uninitialized variables."
msgstr "ì´ˆê¸°í™”ë˜ì§€ ì•ŠëŠ” ë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/hello-world/benefits.md:8
msgid "No double-frees."
msgstr "ë©”ëª¨ë¦¬ ì´ì¤‘ í•´ì œê°€ ì›ì²œì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥ í•©ë‹ˆë‹¤."

#: src/hello-world/benefits.md:9
msgid "No use-after-free."
msgstr "ë©”ëª¨ë¦¬ í•´ì œ í›„ ì‚¬ìš©ì´ ì›ì²œì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥ í•©ë‹ˆë‹¤."

#: src/hello-world/benefits.md:10
msgid "No `NULL` pointers."
msgstr "`NULL`í¬ì¸í„°ëŠ” ì—†ìŠµë‹ˆë‹¤."

#: src/hello-world/benefits.md:11
msgid "No forgotten locked mutexes."
msgstr "ë®¤í…ìŠ¤ë¥¼ ì ê¶ˆ ë†“ê³  ì—¬ëŠ” ê²ƒì„ ìŠëŠ” ì‹¤ìˆ˜ë¥¼ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/hello-world/benefits.md:12
msgid "No data races between threads."
msgstr "ìŠ¤ë ˆë“œê°„ ë°ì´í„° ë ˆì´ìŠ¤ë¥¼ ë§‰ì•„ì¤ë‹ˆë‹¤."

#: src/hello-world/benefits.md:13
msgid "No iterator invalidation."
msgstr "ë°˜ë³µìê°€ ê°‘ìê¸° ë¬´íš¨í™” ë˜ëŠ” ê²½ìš°ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/hello-world/benefits.md:15
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr ""

#: src/hello-world/benefits.md:17
msgid "Array access is bounds checked."
msgstr "ë°°ì—´ ì ‘ê·¼ì‹œ ê²½ê³„ ì²´í¬."

#: src/hello-world/benefits.md:18
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "ì •ìˆ˜í˜• íƒ€ì…ì˜ ë³€ìˆ˜ì—ì„œ ì˜¤ë²„í”Œë¡œìš° ë°œìƒì‹œ ë™ì‘ì´ ì˜ ì •ì˜ë˜ì–´ìˆìŠµë‹ˆë‹¤."

#: src/hello-world/benefits.md:20
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr ""

#: src/hello-world/benefits.md:22
msgid "Enums and pattern matching."
msgstr "ì—´ê±°í˜•ê³¼ íŒ¨í„´ ë§¤ì¹­."

#: src/hello-world/benefits.md:23
msgid "Generics."
msgstr "ì œë„¤ë¦­."

#: src/hello-world/benefits.md:24
msgid "No overhead FFI."
msgstr "FFI ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ ì—†ìŒ."

#: src/hello-world/benefits.md:25
msgid "Zero-cost abstractions."
msgstr "ë¹„ìš©ì´ ë“¤ì§€ ì•ŠëŠ” ì¶”ìƒí™”."

#: src/hello-world/benefits.md:26
msgid "Great compiler errors."
msgstr "ì¹œì ˆí•œ ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ë©”ì‹œì§€."

#: src/hello-world/benefits.md:27
msgid "Built-in dependency manager."
msgstr "ë‚´ì¥ ì¢…ì†ì„± ê´€ë¦¬ì."

#: src/hello-world/benefits.md:28
msgid "Built-in support for testing."
msgstr "ë‚´ì¥ í…ŒìŠ¤íŠ¸ ì§€ì›."

#: src/hello-world/benefits.md:29
msgid "Excellent Language Server Protocol support."
msgstr "LSP (Language Server Protocol, ì–¸ì–´ ì„œë²„ í”„ë¡œí† ì½œ) ì§€ì›ì´ ì˜ë˜ì–´ ìˆìŒ."

#: src/hello-world/benefits.md:33
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr ""

#: src/hello-world/benefits.md:36
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"ìˆ˜ê°•ìƒë“¤ì—ê²Œ ì–´ë–¤ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ì‚¬ìš©í–ˆëŠ”ì§€ ë¬¼ì–´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤. ì–´ë–¤ ì–¸ì–´"
"ë¥¼ ì‚¬ìš©í–ˆëŠëƒì— ë”°ë¼ ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì–´ë–¤ ì ì„ ê°•ì¡°í•´ì•¼ í• ì§€ë¥¼ ê³ ë¯¼í•´ ë³´ì„¸ìš”:"

#: src/hello-world/benefits.md:39
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"C/C++: ëŸ¬ìŠ¤íŠ¸ëŠ” 'ë¹Œë¦¼'ê²€ì‚¬ê¸°ë¥¼ í†µí•´ì„œ ìˆ˜í–‰ì¤‘ì— ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ì—ëŸ¬ë¥¼ ì œ"
"ê±°í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” Cì™€ C++ê³¼ ë¹„ìŠ·í•œ ìˆ˜ì¤€ì˜ ì„±ëŠ¥ì„ ë³´ì—¬ì£¼ë©´ì„œë„, ê·¸ ì–¸ì–´ë“¤ì—"
"ì„œ ì¢…ì¢… ë°œìƒí•˜ëŠ” ë©”ëª¨ë¦¬ ê´€ë ¨ ì˜¤ë¥˜ê°€ ì—†ìŠµë‹ˆë‹¤. ë˜í•œ, íŒ¨í„´ ë§¤ì¹­ì´ë‚˜, ê¸°ë³¸ì ìœ¼"
"ë¡œ ì œê³µë˜ëŠ” ì¢…ì†ì„± ê´€ë¦¬ì™€ ê°™ì€ í˜„ëŒ€ì ì¸ ì–¸ì–´ì˜ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/hello-world/benefits.md:44
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"Java, Go, Python, JavaScript: ì´ ì–¸ì–´ë“¤ê³¼ ë™ì¼í•œ ë©”ëª¨ë¦¬ ì•ˆì •ì„±ê³¼ í•¨ê»˜, 'í•˜ì´"
"ë ˆë²¨'ì–¸ì–´ì˜ ëŠë‚Œì„ ëŠë‚„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê±°ê¸°ì— ë”í•´, ê°€ë¹„ì§€ ì»¬ë ‰í„°ê°€ ì—†ëŠ” C/C+"
"+ì™€ ìœ ì‚¬í•œ ìˆ˜ì¤€ì˜ ë¹ ë¥´ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì„±ëŠ¥ì„ ê¸°ëŒ€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  í•„ìš”"
"í•œ ê²½ìš° ì €ìˆ˜ì¤€ í•˜ë“œì›¨ì–´ë¥¼ ë‹¤ë£¨ëŠ” ì½”ë“œë¡œ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/hello-world/playground.md:3
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""

#: src/hello-world/playground.md:8
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr ""

#: src/hello-world/playground.md:11
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""

#: src/hello-world/playground.md:15
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr ""

#: src/hello-world/playground.md:20
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""

#: src/types-and-values/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì •ì  íƒ€ì´í•‘ì„ í†µí•´ íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤. ë³€ìˆ˜ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë¶ˆë³€"
"(immutable)í•©ë‹ˆë‹¤:"

#: src/types-and-values/variables.md:9 src/control-flow-basics/loops.md:30
#: src/control-flow-basics/break-continue.md:34
#: src/control-flow-basics/blocks-and-scopes.md:16
msgid "\"x: {x}\""
msgstr ""

#: src/types-and-values/variables.md:10
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""

#: src/types-and-values/variables.md:17
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""

#: src/types-and-values/variables.md:20
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""

#: src/types-and-values/values.md:3
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr ""

#: src/types-and-values/values.md:6
#: src/tuples-and-arrays/tuples-and-arrays.md:7 src/unsafe-rust/exercise.md:16
msgid "Types"
msgstr "íƒ€ì…"

#: src/types-and-values/values.md:6
#: src/tuples-and-arrays/tuples-and-arrays.md:7
msgid "Literals"
msgstr "ë¦¬í„°ëŸ´ ê°’"

#: src/types-and-values/values.md:8
msgid "Signed integers"
msgstr "ë¶€í˜¸ìˆëŠ” ì •ìˆ˜"

#: src/types-and-values/values.md:8
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"

#: src/types-and-values/values.md:8
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`, `0`, `1_000`, `123_i64`"

#: src/types-and-values/values.md:9
msgid "Unsigned integers"
msgstr "ë¶€í˜¸ì—†ëŠ” ì •ìˆ˜"

#: src/types-and-values/values.md:9
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"

#: src/types-and-values/values.md:9
msgid "`0`, `123`, `10_u16`"
msgstr "`0`, `123`, `10_u16`"

#: src/types-and-values/values.md:10
msgid "Floating point numbers"
msgstr "ë¶€ë™ì†Œìˆ˜"

#: src/types-and-values/values.md:10
msgid "`f32`, `f64`"
msgstr "`f32`, `f64`"

#: src/types-and-values/values.md:10
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`, `-10.0e20`, `2_f32`"

#: src/types-and-values/values.md:11
msgid "Unicode scalar values"
msgstr "ìœ ë‹ˆì½”ë“œ ë¬¸ì"

#: src/types-and-values/values.md:11
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md:11
msgid "`'a'`, `'Î±'`, `'âˆ'`"
msgstr "`'a'`, `'Î±'`, `'âˆ'`"

#: src/types-and-values/values.md:12
msgid "Booleans"
msgstr "ë¶ˆë¦¬ì–¸"

#: src/types-and-values/values.md:12
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md:12
msgid "`true`, `false`"
msgstr "`true`, `false`"

#: src/types-and-values/values.md:14
msgid "The types have widths as follows:"
msgstr "ê° íƒ€ì…ì˜ í¬ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/types-and-values/values.md:16
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN`, `fN`ì€ ëª¨ë‘ _N_ë¹„íŠ¸ ì…ë‹ˆë‹¤."

#: src/types-and-values/values.md:17
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` ì™€ `usize` ëŠ” í¬ì¸í„°ì™€ ê°™ì€ í¬ê¸°ì…ë‹ˆë‹¤,"

#: src/types-and-values/values.md:18
msgid "`char` is 32 bits wide,"
msgstr "`char` 32 ë¹„íŠ¸ ì…ë‹ˆë‹¤,"

#: src/types-and-values/values.md:19
msgid "`bool` is 8 bits wide."
msgstr "`bool`ì€ 8 ë¹„íŠ¸ ì…ë‹ˆë‹¤."

#: src/types-and-values/values.md:23
msgid "There are a few syntaxes which are not shown above:"
msgstr "ìœ„ì— í‘œì‹œë˜ì§€ ì•Šì€ ëª‡ ê°€ì§€ ë¬¸ë²•ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/types-and-values/values.md:25
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."

#: src/types-and-values/arithmetic.md:9
msgid "\"result: {}\""
msgstr ""

#: src/types-and-values/arithmetic.md:15
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""

#: src/types-and-values/arithmetic.md:19
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr ""

#: src/types-and-values/arithmetic.md:21
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do different things on different platforms or "
"compilers. In Rust, it's defined."
msgstr ""

#: src/types-and-values/arithmetic.md:25
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""

#: src/types-and-values/arithmetic.md:30
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""

#: src/types-and-values/strings.md:3
msgid ""
"Rust has two types to represent strings, both of which will be covered in "
"more depth later. Both _always_ store UTF-8 encoded strings."
msgstr ""

#: src/types-and-values/strings.md:6
#, fuzzy
msgid "`String` - a modifiable, owned string."
msgstr "`String`ì€ ë¬¸ìì—´ì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ë²„í¼ì…ë‹ˆë‹¤."

#: src/types-and-values/strings.md:7
msgid "`&str` - a read-only string. String literals have this type."
msgstr ""

#: src/types-and-values/strings.md:11
msgid "\"Greetings\""
msgstr ""

#: src/types-and-values/strings.md:12
msgid "\"ğŸª\""
msgstr ""

#: src/types-and-values/strings.md:15
msgid "\", \""
msgstr ""

#: src/types-and-values/strings.md:17
msgid "\"final sentence: {}\""
msgstr ""

#: src/types-and-values/strings.md:18 src/async/control-flow/join.md:30
msgid "\"{:?}\""
msgstr ""

#: src/types-and-values/strings.md:19
msgid "//println!(\"{:?}\", &sentence[12..13]);\n"
msgstr ""

#: src/types-and-values/strings.md:25
msgid ""
"This slide introduces strings. Everything here will be covered in more depth "
"later, but this is enough for subsequent slides and exercises to use strings."
msgstr ""

#: src/types-and-values/strings.md:28
msgid "Invalid UTF-8 in a string is UB, and this not allowed in safe Rust."
msgstr ""

#: src/types-and-values/strings.md:30
msgid ""
"`String` is a user-defined type with a constructor (`::new()`) and methods "
"like `s.push_str(..)`."
msgstr ""

#: src/types-and-values/strings.md:33
msgid ""
"The `&` in `&str` indicates that this is a reference. We will cover "
"references later, so for now just think of `&str` as a unit meaning \"a read-"
"only string\"."
msgstr ""

#: src/types-and-values/strings.md:36
msgid ""
"The commented-out line is indexing into the string by byte position. "
"`12..13` does not end on a character boundary, so the program panics. Adjust "
"it to a range that does, based on the error message."
msgstr ""

#: src/types-and-values/strings.md:40
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"

#: src/types-and-values/inference.md:3
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë³€ìˆ˜ê°€ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ë¥¼ ë³´ê³  ê·¸ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•©ë‹ˆë‹¤:"

#: src/types-and-values/inference.md:28
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""
"ì´ ìŠ¬ë¼ì´ë“œëŠ”, ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ê°€ ë³€ìˆ˜ê°€ ì–´ë–»ê²Œ ì„ ì–¸ë˜ì–´ ìˆê³ , ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”"
"ì§€ë¥¼ ì œì•½ ì¡°ê±´ìœ¼ë¡œ ì‚¼ì•„ì„œ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ëŠ” ëª¨ìŠµì„ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/types-and-values/inference.md:31
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê²ƒì€, ì´ë ‡ê²Œ ëª…ì‹œì ì¸ íƒ€ì…ì„ ìƒëµí•˜ê³  ì„ ì–¸ë˜ì—ˆë‹¤ê³  í•´ì„œ \"ì–´ë–¤ "
"íƒ€ì…\"ì´ë¼ë„ ë‹¤ ë‹´ì„ ìˆ˜ ìˆëŠ” íƒ€ì…ì´ ë˜ëŠ” ê²ƒì€ ì•„ë‹ˆë¼ëŠ” ì ì…ë‹ˆë‹¤. ëª…ì‹œì ì¸ íƒ€"
"ì… ì„ ì–¸ì´ ìˆë˜ ì—†ë˜, ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•œ ë¨¸ì‹ ì½”ë“œëŠ” ë™ì¼í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¨"
"ì§€ íƒ€ì… ì„ ì–¸ì„ ìƒëµí•  ìˆ˜ ìˆë„ë¡ í•´ì„œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ë” ê°„ê²°í•œ ì½”ë“œë¥¼ ì“¸ ìˆ˜ ìˆë„"
"ë¡ ë„ì™€ì¤„ ë¿ì…ë‹ˆë‹¤."

#: src/types-and-values/inference.md:36
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""

#: src/types-and-values/inference.md:45
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr ""

#: src/types-and-values/exercise.md:3
msgid ""
"The first and second Fibonacci numbers are both `1`. For n>2, the n'th "
"Fibonacci number is calculated recursively as the sum of the n-1'th and "
"n-2'th Fibonacci numbers."
msgstr ""

#: src/types-and-values/exercise.md:7
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr ""

#: src/types-and-values/exercise.md:13
msgid "// The base case.\n"
msgstr ""

#: src/types-and-values/exercise.md:14 src/types-and-values/exercise.md:17
#: src/control-flow-basics/exercise.md:27
#: src/control-flow-basics/exercise.md:31
#, fuzzy
msgid "\"Implement this\""
msgstr "ì„œë¹„ìŠ¤ êµ¬í˜„"

#: src/types-and-values/exercise.md:16
msgid "// The recursive case.\n"
msgstr ""

#: src/types-and-values/exercise.md:23 src/types-and-values/solution.md:14
msgid "\"fib(n) = {}\""
msgstr ""

#: src/control-flow-basics/conditionals.md:3
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "ëŒ€ë¶€ë¶„ì˜ ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•ì€ C/C++/Java ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤:"

#: src/control-flow-basics/conditionals.md:5
#, fuzzy
msgid "Blocks are delimited by curly braces."
msgstr "ë¸”ë¡ê³¼ ë²”ìœ„ëŠ” ì¤‘ê´„í˜¸`{}`ë¡œ í‘œí˜„í•©ë‹ˆë‹¤."

#: src/control-flow-basics/conditionals.md:6
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr "ì¸ë¼ì¸ ì£¼ì„ì€ `//`, ë¸”ë¡ ì£¼ì„ì€ `/* ... */`ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/control-flow-basics/conditionals.md:8
msgid "Keywords like `if` and `while` work the same."
msgstr "`if`ë‚˜ `while`ê°™ì€ í‚¤ì›Œë“œë„ ë™ì¼í•©ë‹ˆë‹¤."

#: src/control-flow-basics/conditionals.md:9
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr "ë³€ìˆ˜ í• ë‹¹ì€ `=`, ë¹„êµëŠ” `==`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/control-flow-basics/conditionals.md:11
msgid "`if` expressions"
msgstr "`if` í‘œí˜„ì‹"

#: src/control-flow-basics/conditionals.md:13
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"ë‹¤ë¥¸ ì–¸ì–´ì˜ `if` ë¬¸ê³¼ ë˜‘ê°™ì´ [`if` í‘œí˜„ì‹](https://doc.rust-lang.org/"
"reference/expressions/if-expr.html#if-expressions)ì„ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/control-flow-basics/conditionals.md:21
#: src/control-flow-basics/conditionals.md:36
msgid "\"small\""
msgstr ""

#: src/control-flow-basics/conditionals.md:23
msgid "\"biggish\""
msgstr ""

#: src/control-flow-basics/conditionals.md:25
msgid "\"huge\""
msgstr ""

#: src/control-flow-basics/conditionals.md:30
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"ê²Œë‹¤ê°€ `if`ëŠ” í‘œí˜„ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ ì½”ë“œëŠ” ìœ„ì™€ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/control-flow-basics/conditionals.md:36
msgid "\"large\""
msgstr ""

#: src/control-flow-basics/conditionals.md:37
msgid "\"number size: {}\""
msgstr ""

#: src/control-flow-basics/conditionals.md:43
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"`if`ëŠ” í‘œí˜„ì‹ì´ê³  íƒ€ì…ì„ ê°€ì ¸ì•¼ í•˜ë¯€ë¡œ ë¶„ê¸° ë¸”ë¡ì€ ëª¨ë‘ ê°™ì€ íƒ€ì…ì„ ê°€ì ¸ì•¼ í•©"
"ë‹ˆë‹¤. ë‘ë²ˆì§¸ ì˜ˆì‹œì˜ `x / 2` ë’¤ì— `;`ë¥¼ ì¶”ê°€í•˜ì—¬ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ í™•ì¸í•´ ë³´ì‹œê¸° "
"ë°”ëë‹ˆë‹¤."

#: src/control-flow-basics/conditionals.md:47
msgid ""
"When `if` is used in an expression, the expression must have a `;` to "
"separate it from the next statement. Remove the `;` before `println!` to see "
"the compiler error."
msgstr ""

#: src/control-flow-basics/loops.md:3
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr ""

#: src/control-flow-basics/loops.md:5
#, fuzzy
msgid "`while`"
msgstr "`while` ë°˜ë³µë¬¸"

#: src/control-flow-basics/loops.md:7
#, fuzzy
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"[`while` í‚¤ì›Œë“œ](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#predicate-loops)ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§¤ìš° ë¹„ìŠ·í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤:"

#: src/control-flow-basics/loops.md:18
msgid "\"Final x: {x}\""
msgstr ""

#: src/control-flow-basics/loops.md:22
#, fuzzy
msgid "`for`"
msgstr "ë°°ì—´ê³¼ `for` ë°˜ë³µë¬¸"

#: src/control-flow-basics/loops.md:24
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values:"
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) íŠ¸ë ˆì‡ì€ ì†Œë©¸ì "
"ì •ì˜ì— ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/control-flow-basics/loops.md:35
msgid "`loop`"
msgstr ""

#: src/control-flow-basics/loops.md:37
#, fuzzy
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) íŠ¸ë ˆì‡ì€ ì†Œë©¸ì "
"ì •ì˜ì— ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/control-flow-basics/loops.md:45
msgid "\"{i}\""
msgstr ""

#: src/control-flow-basics/loops.md:55
msgid ""
"We will discuss iteration later; for now, just stick to range expressions."
msgstr ""

#: src/control-flow-basics/loops.md:56
msgid ""
"Note that the `for` loop only iterates to `4`. Show the `1..=5` syntax for "
"an inclusive range."
msgstr ""

#: src/control-flow-basics/break-continue.md:3
#, fuzzy
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). For "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"ë£¨í”„ë¥¼ ì¡°ê¸°ì— ì¢…ë£Œí•˜ë ¤ë©´ [`break`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#break-expressions)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤,"

#: src/control-flow-basics/break-continue.md:8
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"ë‹¤ìŒ ë°˜ë³µì„ ì¦‰ì‹œ ì‹œì‘í•˜ë ¤ë©´ [`continue`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#continue-expressions)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/control-flow-basics/break-continue.md:24
msgid "\"{result}\""
msgstr ""

#: src/control-flow-basics/break-continue.md:28
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ê°€ë ¤ë©´ `break`ë¥¼, ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ë„˜ì–´ê°€ê¸° ìœ„í•´ì„œëŠ” `continue`ë¥¼ "
"ì‚¬ìš©í•©ë‹ˆë‹¤. ì¤‘ì²© ë£¨í”„ì—ì„œëŠ” ë ˆì´ë¸”ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/control-flow-basics/break-continue.md:37
msgid "\"x: {x}, i: {i}\""
msgstr ""

#: src/control-flow-basics/break-continue.md:47
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"ìœ„ ì˜ˆì œëŠ” ë‚´ë¶€ì˜ `while` ë£¨í”„ë¥¼ 3íšŒ ë°˜ë³µí•œ í›„ ë°”ê¹¥ ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ê°‘ë‹ˆë‹¤."

#: src/control-flow-basics/break-continue.md:51
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"`loop`ëŠ” non-trivial ê°’ì„ ë°˜í™˜í•˜ëŠ” ìœ ì¼í•œ ë°˜ë³µë¬¸ì…ë‹ˆë‹¤. ì´ëŠ” `while` ë° "
"`for` ë°˜ë³µë¬¸ê³¼ ë‹¬ë¦¬ ìµœì†Œí•œ í•œ ë²ˆì€ ë£¨í”„ë¬¸ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ë³´ì¥ë˜ê¸° ë•Œë¬¸ì…ë‹ˆ"
"ë‹¤."

#: src/control-flow-basics/blocks-and-scopes.md:3
msgid "Blocks"
msgstr "ë¸”ë¡"

#: src/control-flow-basics/blocks-and-scopes.md:5
msgid ""
"A block in Rust contains a sequence of expressions. Each block has a value "
"and a type, which are those of the last expression of the block:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì—ì„œ ë¸”ë¡ì€ ê°’ê³¼ íƒ€ì…ì„ ê°–ìŠµë‹ˆë‹¤. ë¸”ë¡ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì´ ë¸”ë¡ì˜ ê°’ì´ ë©"
"ë‹ˆë‹¤:"

#: src/control-flow-basics/blocks-and-scopes.md:13
msgid "\"y: {y}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:20
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""
"ìœ„ì˜ `main` í•¨ìˆ˜ëŠ” ë§ˆì§€ë§‰ í‘œí˜„ì‹ì´ `;`ë¡œ ëë‚˜ê¸° ë•Œë¬¸ì— ë°˜í™˜ë˜ëŠ” ê°’ê³¼ íƒ€ì…ì´ "
"`()`ì…ë‹ˆë‹¤."

#: src/control-flow-basics/blocks-and-scopes.md:22
msgid "Scopes and Shadowing"
msgstr "ë²”ìœ„(Scopes)ì™€ ì‰ë„ì‰(Shadowing)"

#: src/control-flow-basics/blocks-and-scopes.md:24
msgid "A variable's scope is limited to the enclosing block."
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:26
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"í˜„ì¬ ë²”ìœ„ì— ìˆëŠ” ë³€ìˆ˜ì™€, ë°”ê¹¥ ë²”ìœ„ì— ìˆëŠ” ë³€ìˆ˜ ëª¨ë‘ ê°€ë¦´(ì‰ë„ì‰)ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/control-flow-basics/blocks-and-scopes.md:32
msgid "\"before: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:34
#: src/std-traits/from-and-into.md:7 src/std-traits/from-and-into.md:19
#: src/slices-and-lifetimes/solution.md:225
msgid "\"hello\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:35
msgid "\"inner scope: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:38
msgid "\"shadowed in inner scope: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:41
msgid "\"after: {a}\""
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:47
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"ë¸”ë¡ ë§ˆì§€ë§‰ ì¤„ì„ ìˆ˜ì •í•˜ë©´ì„œ ë¸”ë¡ì˜ ê°’ì´ ì–´ë–»ê²Œ ë°”ë€ŒëŠ”ì§€ ë³´ì—¬ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤"
"ì–´, ì„¸ë¯¸ì½œë¡ ì„ ë„£ê±°ë‚˜ ëº€ë‹¤ë“ ì§€, ì•„ë‹ˆë©´ `return`ì„ ì‚¬ìš©í•´ ë³´ì„¸ìš”."

#: src/control-flow-basics/blocks-and-scopes.md:49
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""

#: src/control-flow-basics/blocks-and-scopes.md:51
#, fuzzy
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variable's memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"ì‰ë„ì‰ì€ ê¸°ì¡´ ë³€ìˆ˜ì— ìƒˆë¡œìš´ ê°’ì„ í• ë‹¹í•˜ëŠ” ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤. ì‰ë„ì‰ì„ í•˜ë©´ ìƒˆë¡œ"
"ìš´ ë³€ìˆ˜ê°€ ìƒê¸°ë©°, ì´ì „ ë³€ìˆ˜ì™€ ìƒˆ ë³€ìˆ˜ëŠ” ë©”ëª¨ë¦¬ì˜ ì„œë¡œ ë‹¤ë¥¸ ìœ„ì¹˜ì— ì¡´ì¬í•©ë‹ˆ"
"ë‹¤. ê·¸ ë‘ ë³€ìˆ˜ëŠ” ë‹¨ì§€ ì´ë¦„ì´ ê°™ì€ ë¿ì´ë©°, ì½”ë“œ ì¤‘ ì–´ë””ì—ì„œ ê·¸ ì´ë¦„ì´ ì‚¬ìš©ë˜ì—ˆ"
"ëŠëƒì— ë”°ë¼ ì–´ë–¤ ë³€ìˆ˜ë¥¼ ì§€ì¹­í•˜ëŠ” ì§€ê°€ ê²°ì •ë©ë‹ˆë‹¤. "

#: src/control-flow-basics/blocks-and-scopes.md:54
#, fuzzy
msgid "A shadowing variable can have a different type."
msgstr "ì‰ë„ì‰ ì‹œ íƒ€ì…ì„ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "

#: src/control-flow-basics/blocks-and-scopes.md:55
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"ì²˜ìŒì— ì‰ë„ì‰ì„ ë³´ë©´ ì½”ë“œë¥¼ ë” ëª¨í˜¸í•˜ê²Œ ë§Œë“ ë‹¤ê³  ìƒê°í•  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬"
"ë‚˜ ì‹¤ì œë¡œ ì‰ë„ì‰ì„ ì´ìš©í•˜ë©´, ì–´ë–¤ ë³€ìˆ˜ì—ì„œ `.unwrap()` ëœ ê°’ì„ ìƒˆë¡œìš´ ë³€ìˆ˜ì— "
"ë‹´ì„ ê²½ìš° ìƒˆë¡œìš´ ì´ë¦„ì„ ì§€ì„ í•„ìš” ì—†ì´ ê¸°ì¡´ ì´ë¦„ì„ ìœ ì§€í•  ìˆ˜ ìˆì–´ì„œ í¸ë¦¬í•©ë‹ˆ"
"ë‹¤."

#: src/control-flow-basics/functions.md:21
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""
"ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œì—ëŠ” ì´ë¦„ì„ ë¨¼ì € ì“°ê³ , íƒ€ì…ì„ ë‚˜ì¤‘ì— ì”ë‹ˆë‹¤. ì´ë¦„ê³¼ íƒ€ì…"
"ì€ `:` ë¡œ êµ¬ë¶„í•©ë‹ˆë‹¤. ì´ëŠ” ì¼ë¶€ ì–¸ì–´(ì˜ˆë¥¼ ë“¤ì–´ C)ì™€ ë°˜ëŒ€ì„ì— ìœ ì˜í•˜ì‹œê¸° ë°”ë"
"ë‹ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ, ë¦¬í„´ íƒ€ì…ë„ í•¨ìˆ˜ì˜ ì‹œì‘ì´ ì•„ë‹Œ ê°€ì¥ ë’·ë¶€ë¶„ì— ì„ ì–¸í•©ë‹ˆë‹¤."

#: src/control-flow-basics/functions.md:23
#, fuzzy
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"í•¨ìˆ˜ ë³¸ë¬¸ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì€ ë°˜í™˜ ê°’ì´ ë©ë‹ˆë‹¤. ê°„ë‹¨íˆ, ì‹ ëì— ìˆëŠ” `;`ë¥¼ ìƒëµ"
"í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/control-flow-basics/functions.md:27
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"ë°˜í™˜ê°’ì´ ì—†ëŠ” í•¨ìˆ˜ì˜ ê²½ìš°, ìœ ë‹› íƒ€ì… `()`ì„ ë°˜í™˜í•©ë‹ˆë‹¤. `-> ()`ê°€ ìƒëµëœ ê²½"
"ìš° ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì¶”ë¡ í•©ë‹ˆë‹¤."

#: src/control-flow-basics/functions.md:29
#, fuzzy
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr "ê°œë³„í•¨ìˆ˜ëŠ” ë‹¨ì¼ êµ¬í˜„ë§Œ ê°–ìŠµë‹ˆë‹¤:"

#: src/control-flow-basics/functions.md:30
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr ""

#: src/control-flow-basics/functions.md:32
#, fuzzy
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr "íŒŒë¼ë§¤í„°ë“¤ì˜ íƒ€ì…ì€ í•­ìƒ ê³ ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/control-flow-basics/macros.md:3
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""

#: src/control-flow-basics/macros.md:7
#, fuzzy
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr "ì—°ì‚°ì ì˜¤ë²„ë¡œë“œëŠ” `std::ops`ì— ìˆëŠ” ë‹¤ì–‘í•œ íŠ¸ë ˆì‡ë“¤ì„ í†µí•´ êµ¬í˜„ë©ë‹ˆë‹¤:"

#: src/control-flow-basics/macros.md:9
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""

#: src/control-flow-basics/macros.md:11
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr ""

#: src/control-flow-basics/macros.md:12
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr ""

#: src/control-flow-basics/macros.md:14
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""

#: src/control-flow-basics/macros.md:32
msgid "\"{n}! = {}\""
msgstr ""

#: src/control-flow-basics/macros.md:38
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""

#: src/control-flow-basics/macros.md:42
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr ""

#: src/control-flow-basics/exercise.md:3
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n"
msgstr ""

#: src/control-flow-basics/exercise.md:4 src/control-flow-basics/exercise.md:10
#, fuzzy
msgid "1"
msgstr "12"

#: src/control-flow-basics/exercise.md:4
msgid " greater than zero:"
msgstr ""

#: src/control-flow-basics/exercise.md:6 src/control-flow-basics/exercise.md:7
#: src/control-flow-basics/exercise.md:8
msgid "If _n"
msgstr ""

#: src/control-flow-basics/exercise.md:6 src/control-flow-basics/exercise.md:7
#: src/control-flow-basics/exercise.md:8
msgid "i"
msgstr ""

#: src/control-flow-basics/exercise.md:6
msgid "_ is 1, then the sequence terminates at _n"
msgstr ""

#: src/control-flow-basics/exercise.md:6
msgid "_."
msgstr ""

#: src/control-flow-basics/exercise.md:7
msgid "_ is even, then _n"
msgstr ""

#: src/control-flow-basics/exercise.md:7 src/control-flow-basics/exercise.md:8
msgid "i+1"
msgstr ""

#: src/control-flow-basics/exercise.md:7
msgid " = n"
msgstr ""

#: src/control-flow-basics/exercise.md:7
msgid " / 2_."
msgstr ""

#: src/control-flow-basics/exercise.md:8
msgid "_ is odd, then _n"
msgstr ""

#: src/control-flow-basics/exercise.md:8
msgid " = 3 * n"
msgstr ""

#: src/control-flow-basics/exercise.md:8
msgid " + 1_."
msgstr ""

#: src/control-flow-basics/exercise.md:10
msgid "For example, beginning with _n"
msgstr ""

#: src/control-flow-basics/exercise.md:10
msgid "_ = 3:"
msgstr ""

#: src/control-flow-basics/exercise.md:12
msgid "3 is odd, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:12
#, fuzzy
msgid "2"
msgstr "12"

#: src/control-flow-basics/exercise.md:12
msgid "_ = 3 * 3 + 1 = 10;"
msgstr ""

#: src/control-flow-basics/exercise.md:13
msgid "10 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:13 src/bare-metal/aps/better-uart.md:22
msgid "3"
msgstr "3"

#: src/control-flow-basics/exercise.md:13
msgid "_ = 10 / 2 = 5;"
msgstr ""

#: src/control-flow-basics/exercise.md:14
msgid "5 is odd, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:14 src/bare-metal/aps/better-uart.md:10
msgid "4"
msgstr "4"

#: src/control-flow-basics/exercise.md:14
msgid "_ = 3 * 15 + 1 = 16;"
msgstr ""

#: src/control-flow-basics/exercise.md:15
msgid "16 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:15
msgid "5"
msgstr ""

#: src/control-flow-basics/exercise.md:15
msgid "_ = 16 / 2 = 8;"
msgstr ""

#: src/control-flow-basics/exercise.md:16
msgid "8 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:16 src/bare-metal/aps/better-uart.md:14
#: src/bare-metal/aps/better-uart.md:17
msgid "6"
msgstr "6"

#: src/control-flow-basics/exercise.md:16
msgid "_ = 8 / 2 = 4;"
msgstr ""

#: src/control-flow-basics/exercise.md:17
msgid "4 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:17
msgid "7"
msgstr ""

#: src/control-flow-basics/exercise.md:17
msgid "_ = 4 / 2 = 2;"
msgstr ""

#: src/control-flow-basics/exercise.md:18
msgid "2 is even, so _n"
msgstr ""

#: src/control-flow-basics/exercise.md:18 src/bare-metal/aps/better-uart.md:12
#: src/bare-metal/aps/better-uart.md:15
msgid "8"
msgstr "8"

#: src/control-flow-basics/exercise.md:18
msgid "_ = 1; and"
msgstr ""

#: src/control-flow-basics/exercise.md:19
msgid "the sequence terminates."
msgstr ""

#: src/control-flow-basics/exercise.md:21
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr ""

#: src/control-flow-basics/exercise.md:25 src/control-flow-basics/solution.md:4
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr ""

#: src/control-flow-basics/solution.md:20 src/concurrency/scoped-threads.md:11
#: src/concurrency/scoped-threads.md:30
msgid "\"Length: {}\""
msgstr ""

#: src/welcome-day-1-afternoon.md:1 src/welcome-day-2-afternoon.md:1
#: src/welcome-day-3-afternoon.md:1 src/welcome-day-4-afternoon.md:1
#, fuzzy
msgid "Welcome Back"
msgstr "ê°œìš”"

#: src/tuples-and-arrays/tuples-and-arrays.md:3
msgid ""
"Tuples and arrays are the first \"compound\" types we have seen. All "
"elements of an array have the same type, while tuples can accommodate "
"different types. Both types have a size fixed at compile time."
msgstr ""

#: src/tuples-and-arrays/tuples-and-arrays.md:9
#: src/tuples-and-arrays/destructuring.md:27
msgid "Arrays"
msgstr "ë°°ì—´"

#: src/tuples-and-arrays/tuples-and-arrays.md:9
msgid "`[T; N]`"
msgstr "`[T; N]`"

#: src/tuples-and-arrays/tuples-and-arrays.md:9
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr "`[20, 30, 40]`, `[0; 3]`"

#: src/tuples-and-arrays/tuples-and-arrays.md:10
#: src/tuples-and-arrays/destructuring.md:9
msgid "Tuples"
msgstr "íŠœí”Œ"

#: src/tuples-and-arrays/tuples-and-arrays.md:10
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr "`()`, `(T,)`, `(T1, T2)`, ..."

#: src/tuples-and-arrays/tuples-and-arrays.md:10
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr "`()`, `('x',)`, `('x', 1.2)`, ..."

#: src/tuples-and-arrays/tuples-and-arrays.md:12
msgid "Array assignment and access:"
msgstr "ë°°ì—´ ì„ ì–¸ê³¼ ì ‘ê·¼:"

#: src/tuples-and-arrays/tuples-and-arrays.md:24
msgid "Tuple assignment and access:"
msgstr "íŠœí”Œ ì„ ì–¸ê³¼ ì ‘ê·¼:"

#: src/tuples-and-arrays/tuples-and-arrays.md:40
msgid "Arrays:"
msgstr "ë°°ì—´:"

#: src/tuples-and-arrays/tuples-and-arrays.md:42
#, fuzzy
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"ë°°ì—´ì€, ê°™ì€ íƒ€ì… `T`ì˜ ê°’ì´ `N`ê°œ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ `N`ì€ ì»´íŒŒì¼ íƒ€ì„ì— "
"ê²°ì •ëœ ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ ê¸¸ì´ë„ íƒ€ì…ì˜ ì¼ë¶€ì…ë‹ˆë‹¤. ë”°ë¼ì„œ, `[u8; 3]`ì™€ "
"`[u8; 4]`ì€ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì…ë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:48
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""

#: src/tuples-and-arrays/tuples-and-arrays.md:52
msgid "We can use literals to assign values to arrays."
msgstr "ë¦¬í„°ëŸ´ì„ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ì— ê°’ì„ í• ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:54
#, fuzzy
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"í¬ë§¤íŒ… ë¬¸ìì—´ì—ì„œ `?`ëŠ” ë””ë²„ê¹… ì¶œë ¥ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. `{}`ëŠ” ê¸°ë³¸ ì¶œë ¥ì´ë©°, `{:?}"
"`ëŠ” ë””ë²„ê¹… ì¶œë ¥ì…ë‹ˆë‹¤. `{a}`, `{a:?}`ì™€ ê°™ì´ ì¶œë ¥í•  ë³€ìˆ˜ ì´ë¦„ì„ í¬ë§¤íŒ… ë¬¸ìì—´"
"ì— í¬í•¨ì‹œí‚¬ ìˆ˜ë„ ìˆìœ¼ë©°, ì´ ê²½ìš° ì¸ì `a`ëŠ” ë³„ë„ì˜ ì¸ìë¡œ ì¶”ê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:59
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"`#`ì„ ì¶”ê°€í•˜ë©´(`{a:#?}`) ì¢€ ë” ì½ê¸° ì‰¬ìš´ \"ì´ìœ\" í˜•íƒœë¡œ ì¶œë ¥ì´ ë©ë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:62
msgid "Tuples:"
msgstr "íŠœí”Œ:"

#: src/tuples-and-arrays/tuples-and-arrays.md:64
msgid "Like arrays, tuples have a fixed length."
msgstr "ë°°ì—´ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ íŠœí”Œì€ ê³ ì • ê¸¸ì´ë¥¼ ê°–ìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:66
msgid "Tuples group together values of different types into a compound type."
msgstr "íŠœí”Œì€ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì˜ ê°’ë“¤ì„ í•˜ë‚˜ì˜ ë³µí•© íƒ€ì…ìœ¼ë¡œ ë¬¶ìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:68
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr "íŠœí”Œì— ì†í•œ ê°’ì€ `t.0`, `t.1`ê³¼ ê°™ì´ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/tuples-and-arrays.md:71
#, fuzzy
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type --- that is to say both the type and "
"its value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide."
msgstr ""
"ë¹„ì–´ìˆëŠ” íŠœí”Œ`()`ì€ ë‹¨ìœ„ íƒ€ì…(unit type)ì´ë¼ê³ ë„ í•©ë‹ˆë‹¤. ì´ëŠ” íƒ€ì…ì´ë©´ì„œ í•´"
"ë‹¹ íƒ€ì…ì˜ ìœ ì¼í•˜ë©° ìœ íš¨í•œ ê°’ì…ë‹ˆë‹¤. ì¦‰ íƒ€ì…ê³¼ ê°’ì´ ëª¨ë‘ `()`ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤"
"ì–´ í•¨ìˆ˜ë‚˜ ì‹ì—ì„œ ë°˜í™˜ ê°’ì´ ì—†ìŒì„ ë‚˜íƒ€ë‚¼ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. "

#: src/tuples-and-arrays/tuples-and-arrays.md:75
#, fuzzy
msgid ""
"You can think of it as `void` that can be familiar to you from other "
"programming languages."
msgstr "ë‹¤ë¥¸ ì–¸ì–´ì—ì„œ ìµìˆ™í•œ `void` ê°œë…ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/iteration.md:3
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr ""

#: src/tuples-and-arrays/iteration.md:18
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr ""

#: src/tuples-and-arrays/iteration.md:21
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked while, debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""

#: src/tuples-and-arrays/match.md:3
#, fuzzy
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"`match`í‚¤ì›Œë“œëŠ” ê°’ì„ ì—¬ëŸ¬ í˜•íƒœì˜ íŒ¨í„´ê³¼ ë§¤ì¹˜ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§¨ ìœ„ íŒ¨í„´ë¶€í„° "
"í•˜ë‚˜ì”© ë§¤ì¹˜ë˜ëŠ”ì§€ ê²€ì‚¬í•˜ë©°, ì²˜ìŒìœ¼ë¡œ ë§¤ì¹˜ë˜ëŠ” íŒ¨í„´ì´ ì„ íƒë©ë‹ˆë‹¤."

#: src/tuples-and-arrays/match.md:6
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "C/C++ì˜ `switch`ì™€ ë¹„ìŠ·í•˜ê²Œ ê°’ì„ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/tuples-and-arrays/match.md:11
msgid "'x'"
msgstr ""

#: src/tuples-and-arrays/match.md:13
msgid "'q'"
msgstr ""

#: src/tuples-and-arrays/match.md:13
msgid "\"Quitting\""
msgstr ""

#: src/tuples-and-arrays/match.md:14 src/std-traits/solution.md:16
#: src/error-handling/exercise.md:62 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:62 src/error-handling/solution.md:64
msgid "'a'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "'s'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "'w'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "'d'"
msgstr ""

#: src/tuples-and-arrays/match.md:14
msgid "\"Moving around\""
msgstr ""

#: src/tuples-and-arrays/match.md:15 src/error-handling/exercise.md:54
#: src/error-handling/exercise.md:56 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:54 src/error-handling/solution.md:56
#: src/error-handling/solution.md:64
msgid "'0'"
msgstr ""

#: src/tuples-and-arrays/match.md:15 src/error-handling/exercise.md:54
#: src/error-handling/exercise.md:56 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:54 src/error-handling/solution.md:56
#: src/error-handling/solution.md:64
msgid "'9'"
msgstr ""

#: src/tuples-and-arrays/match.md:15
msgid "\"Number input\""
msgstr ""

#: src/tuples-and-arrays/match.md:16
msgid "\"Lowercase: {key}\""
msgstr ""

#: src/tuples-and-arrays/match.md:17
msgid "\"Something else\""
msgstr ""

#: src/tuples-and-arrays/match.md:22
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be irrefutable, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""

#: src/tuples-and-arrays/match.md:26
#, fuzzy
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"`if let`ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë§¤ì¹˜ì˜ ëª¨ë“  íŒ”(arm)ì€ ê°™ì€ íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤. íŒ”ì´ ë¸”ë¡"
"ì´ë¼ë©´ ë¸”ë¡ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì´ ê·¸ íƒ€ì…ì´ ë©ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì œì—ì„œ ë§¤ì¹˜ í‘œí˜„ì‹ì˜ "
"íƒ€ì…ì€ `()`ì…ë‹ˆë‹¤."

#: src/tuples-and-arrays/match.md:30
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr ""

#: src/tuples-and-arrays/match.md:33
msgid "A match guard causes the arm to match only if the condition is true."
msgstr ""

#: src/tuples-and-arrays/match.md:37 src/user-defined-types/named-structs.md:34
#: src/user-defined-types/enums.md:28 src/methods-and-traits/methods.md:68
msgid "Key Points:"
msgstr "í‚¤ í¬ì¸íŠ¸:"

#: src/tuples-and-arrays/match.md:39
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr "íŒ¨í„´ì—ì„œ ì‚¬ìš©ë˜ëŠ” íŠ¹ìˆ˜ ë¬¸ìë“¤ì„ ì•Œë ¤ì£¼ì„¸ìš”"

#: src/tuples-and-arrays/match.md:41
msgid "`|` as an `or`"
msgstr "`|`: or ê¸°í˜¸ì…ë‹ˆë‹¤"

#: src/tuples-and-arrays/match.md:42
msgid "`..` can expand as much as it needs to be"
msgstr "`..`: í•„ìš”í•œ ë§Œí¼ í™•ì¥í•©ë‹ˆë‹¤"

#: src/tuples-and-arrays/match.md:43
msgid "`1..=5` represents an inclusive range"
msgstr "`1..=5`: ë ê°’(ì—¬ê¸°ì„œëŠ” 5)ì„ í¬í•¨í•˜ëŠ” ë²”ìœ„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤"

#: src/tuples-and-arrays/match.md:44
msgid "`_` is a wild card"
msgstr "`_`: ì™€ì¼ë“œì¹´ë“œì…ë‹ˆë‹¤"

#: src/tuples-and-arrays/match.md:46
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"ë§¤ì¹˜ ê°€ë“œëŠ” ë³„ë„ì˜ ë¬¸ë²• ìš”ì†Œë¡œì„œ íŒ¨í„´ ìì²´ë§Œìœ¼ë¡œ í‘œí˜„í•˜ê¸° ì–´ë ¤ìš´ ë³µì¡í•œ ê²½ìš°"
"ë¥¼ ê°„ê²°í•˜ê²Œ í‘œí˜„í•˜ê³ ì í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤."

#: src/tuples-and-arrays/match.md:48
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"ë§¤ì¹˜ì˜ ê° íŒ”(í˜¹ì€ ê°€ì§€) ì•ˆì— ë”°ë¡œ `if`ë¥¼ ì‚¬ìš©í•œ ê²ƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. ë§¤ì¹˜ ê°€ì§€ì˜ "
"`=>` ë’¤ì— ì‚¬ìš©ëœ `if` í‘œí˜„ì‹ì€ í•´ë‹¹ ê°€ì§€ê°€ ì„ íƒëœ ë‹¤ìŒì— ì‹¤í–‰ë©ë‹ˆë‹¤. ë”°ë¼ì„œ "
"ì—¬ê¸°ì„œ `if` ì¡°ê±´ì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì›ë˜ `match`ì˜ ë‹¤ë¥¸ ê°€ì§€ëŠ” ê³ ë ¤ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/tuples-and-arrays/match.md:52
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr "ê°€ë“œì— ì •ì˜ëœ ì¡°ê±´ì€ `|` ë¥¼ í¬í•¨í•˜ëŠ” íŒ¨í„´ì˜ ëª¨ë“  í‘œí˜„ì‹ì— ì ìš©ë©ë‹ˆë‹¤."

#: src/tuples-and-arrays/destructuring.md:3
msgid ""
"Destructuring is a way of extracting data from a data structure by writing a "
"pattern that is matched up to the data structure, binding variables to "
"subcomponents of the data structure."
msgstr ""

#: src/tuples-and-arrays/destructuring.md:7
#, fuzzy
msgid "You can destructure tuples and arrays by matching on their elements:"
msgstr ""
"ë°°ì—´ì´ë‚˜ íŠœí”Œ, ìŠ¬ë¼ì´ìŠ¤ë„ ê·¸ ìš”ì†Œë“¤ì— ëŒ€í•´ íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/tuples-and-arrays/destructuring.md:18
msgid "\"on Y axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:19
msgid "\"on X axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:20
msgid "\"left of Y axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:21
msgid "\"below X axis\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:22
msgid "\"first quadrant\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:33
msgid "\"Tell me about {triple:?}\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:35
msgid "\"First is 0, y = {y}, and z = {z}\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:36
msgid "\"First is 1 and the rest were ignored\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:37
msgid "\"All elements were ignored\""
msgstr ""

#: src/tuples-and-arrays/destructuring.md:44
#, fuzzy
msgid "Create a new array pattern using `_` to represent an element."
msgstr "`_`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìš”ì†Œë¥¼ ë§¤ì¹­í•˜ëŠ” íŒ¨í„´ì„ ì¶”ê°€í•´ë³´ì„¸ìš”. "

#: src/tuples-and-arrays/destructuring.md:45
msgid "Add more values to the array."
msgstr "ë°°ì—´ì— ê°’ì„ ë” ì¶”ê°€í•´ë³´ì„¸ìš”."

#: src/tuples-and-arrays/destructuring.md:46
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr "`..`ê°€ ìš”ì†Œ ê°œìˆ˜ì— ìƒê´€ì—†ì´ ë§¤ì¹˜ë  ìˆ˜ ìˆìŒì„ ì•Œë ¤ì£¼ì„¸ìš”."

#: src/tuples-and-arrays/destructuring.md:48
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""
"`[.., b]`ë‚˜ `[a@.., b]`ì™€ ê°™ì€ íŒ¨í„´ìœ¼ë¡œ ê¼¬ë¦¬ ë¶€ë¶„ì„ ë§¤ì¹­í•˜ëŠ” ê²ƒì„ ë³´ì—¬ì£¼ì„¸ìš”"

#: src/tuples-and-arrays/exercise.md:3
msgid "Arrays can contain other arrays:"
msgstr ""

#: src/tuples-and-arrays/exercise.md:9
#, fuzzy
msgid "What is the type of this variable?"
msgstr "ë§¤ ë£¨í”„ì—ì„œ `word`ì˜ íƒ€ì…ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#: src/tuples-and-arrays/exercise.md:11
#, fuzzy
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"ìœ„ ì½”ë“œë¥¼ ì´ìš©í•´ì„œ, í–‰ë ¬ì„ ì˜ˆì˜ê²Œ ì¶œë ¥í•˜ëŠ” `pretty_print`í•¨ìˆ˜ì™€, í–‰ë ¬ì„ ì „ì¹˜"
"(í–‰ê³¼ ì—´ì„ ì„œë¡œ ë°”ê¾¸ëŠ”)ì‹œí‚¤ëŠ” `transpose`í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/tuples-and-arrays/exercise.md:22
msgid "Hard-code both functions to operate on 3 Ã— 3 matrices."
msgstr "ë‘ í•¨ìˆ˜ ëª¨ë‘ í–‰ë ¬ì˜ í¬ê¸°ëŠ” 3 x 3 ìœ¼ë¡œ í•˜ë“œì½”ë”© í•©ë‹ˆë‹¤."

#: src/tuples-and-arrays/exercise.md:24
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤:"

#: src/tuples-and-arrays/exercise.md:28 src/methods-and-traits/exercise.md:20
#: src/borrowing/exercise.md:14 src/unsafe-rust/exercise.md:51
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr ""

#: src/tuples-and-arrays/exercise.md:37 src/tuples-and-arrays/solution.md:34
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr ""

#: src/tuples-and-arrays/exercise.md:42 src/tuples-and-arrays/solution.md:39
msgid "\"matrix: {:#?}\""
msgstr ""

#: src/tuples-and-arrays/exercise.md:44 src/tuples-and-arrays/solution.md:41
msgid "\"transposed: {:#?}\""
msgstr ""

#: src/tuples-and-arrays/solution.md:17 src/tuples-and-arrays/solution.md:25
msgid "//\n"
msgstr ""

#: src/references/shared.md:3
msgid ""
"A reference provides a way to access another value without taking "
"responsibility for the value, and is also called \"borrowing\". Shared "
"references are read-only, and the referenced data cannot change."
msgstr ""

#: src/references/shared.md:20
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""

#: src/references/shared.md:24
msgid "Rust will statically forbid dangling references:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” í—ˆìƒ(dangling) ì°¸ì¡°ë¥¼ ì»´íŒŒì¼ëŸ¬ ë‹¨ê³„ì—ì„œ ì°¾ì•„ë‚´ê³  ê¸ˆì§€í•©ë‹ˆë‹¤:"

#: src/references/shared.md:37
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""

#: src/references/shared.md:42
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""

#: src/references/shared.md:47
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr ""

#: src/references/shared.md:50
#, fuzzy
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.count_ones()`). There is no need for an `->` operator like "
"in C++."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” íŠ¹ì •í•œ ê²½ìš°(ë©”ì„œë“œ í˜¸ì¶œ)ì— ìë™ìœ¼ë¡œ ì—­ì°¸ì¡°ë¥¼ í•©ë‹ˆë‹¤.(`ref_x."
"count_one()`ì„ í•˜ë©´ `*ref_x`ê°€ `count_one`ì˜ ì¸ìë¡œ ì „ë‹¬ë©ë‹ˆë‹¤.)"

#: src/references/shared.md:53
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""

#: src/references/shared.md:57
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr ""

#: src/references/shared.md:60
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""

#: src/references/shared.md:65
msgid "We will talk more about borrowing when we get to ownership."
msgstr ""
"ì†Œìœ ê¶Œì— ëŒ€í•œ ì£¼ì œë¥¼ ë‹¤ë£° ë•Œ ì´ ë¹Œë¦¼ì— ëŒ€í•´ ë” ìì„¸íˆ ì´ì•¼ê¸° í•˜ê² ìŠµë‹ˆë‹¤."

#: src/references/exclusive.md:3
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""

#: src/references/exclusive.md:21
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""

#: src/references/exclusive.md:26
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"`let mut ref_x: &i32`ì™€ `let ref_x: &mut i32`ì˜ ì°¨ì´ì ì— ì£¼ì˜ í•˜ì‹œê¸° ë°”ëë‹ˆ"
"ë‹¤. ì²«ë²ˆì§¸ ê°’ì€ ë‹¤ë¥¸ ê°’ì— ë°”ì¸ë”© ë  ìˆ˜ ìˆëŠ” ê°€ë³€ ì°¸ì¡°ì´ê³ , ë‘ë²ˆì§¸ ê°’ì€ ê°€ë³€ "
"ê°’ì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤."

#: src/references/exercise.md:3
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""

#: src/references/exercise.md:7
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""

#: src/references/exercise.md:15
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""

#: src/references/exercise.md:23
msgid "// Use the following `main` to test your work.\n"
msgstr ""

#: src/references/exercise.md:27 src/references/solution.md:22
msgid "\"Magnitude of a unit vector: {}\""
msgstr ""

#: src/references/exercise.md:30 src/references/solution.md:25
msgid "\"Magnitude of {v:?}: {}\""
msgstr ""

#: src/references/exercise.md:32 src/references/solution.md:27
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr ""

#: src/references/solution.md:4
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr ""

#: src/references/solution.md:12
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr ""

#: src/user-defined-types/named-structs.md:3
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "C/C++ ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ëŸ¬ìŠ¤íŠ¸ëŠ” ì»¤ìŠ¤í…€ êµ¬ì¡°ì²´ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/user-defined-types/named-structs.md:12
msgid "\"{} is {} years old\""
msgstr ""

#: src/user-defined-types/named-structs.md:16
#: src/android/interoperability/with-c/bindgen.md:87
msgid "\"Peter\""
msgstr ""

#: src/user-defined-types/named-structs.md:22
msgid "\"Avery\""
msgstr ""

#: src/user-defined-types/named-structs.md:27
msgid "\"Jackie\""
msgstr ""

#: src/user-defined-types/named-structs.md:36
msgid "Structs work like in C or C++."
msgstr "êµ¬ì¡°ì²´ëŠ” C/C++ ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤."

#: src/user-defined-types/named-structs.md:37
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""
"C++ ì™€ ê°™ì§€ë§Œ Cì™€ëŠ” ë‹¬ë¦¬ íƒ€ì…ì„ ì •ì˜í•˜ê¸° ìœ„í•´ 'typedef'ê°€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/user-defined-types/named-structs.md:38
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "C++ ì™€ ë‹¬ë¦¬ êµ¬ì¡°ì²´ ê°„ ìƒì†ì€ ì—†ìŠµë‹ˆë‹¤."

#: src/user-defined-types/named-structs.md:39
#, fuzzy
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr ""
"ì‚¬ëŒë“¤ì—ê²Œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ êµ¬ì¡°ì²´ê°€ ìˆìŒì„ ì•Œê²Œ í•˜ê¸°ì— ì¢‹ì€ ì‹œê°„ì¼ ê²ƒì…ë‹ˆë‹¤. "

#: src/user-defined-types/named-structs.md:41
#, fuzzy
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but donâ€™t have any data that you want to store in the "
"value itself."
msgstr ""
"0 í¬ê¸° êµ¬ì¡°ì²´(ì˜ˆ: `struct Foo;`)ëŠ” ë°ì´í„°ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šì§€ë§Œ íŠ¹ì • íƒ€ì…ì˜ íŠ¸"
"ë ˆì‡ì„ êµ¬í˜„í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤. "

#: src/user-defined-types/named-structs.md:44
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""
"ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œëŠ” í•„ë“œ ì´ë¦„ì´ ëœ ì¤‘ìš”í•  ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íŠœí”Œ êµ¬ì¡°ì²´ë¥¼ ì†Œ"
"ê°œí•©ë‹ˆë‹¤."

#: src/user-defined-types/named-structs.md:46
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr ""
"êµ¬ì¡°ì²´ í•„ë“œì™€ ë™ì¼í•œ ì´ë¦„ì˜ ë³€ìˆ˜ê°€ ìˆë‹¤ë©´ ì•„ë˜ì™€ ê°™ì´ \"ì§§ì€ ë¬¸ë²•\"ìœ¼ë¡œ êµ¬ì¡°"
"ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/user-defined-types/named-structs.md:48
#, fuzzy
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"`..peter` ë¬¸ë²•ì€ í•œ êµ¬ì¡°ì²´ì—ì„œ ë‹¤ë¥¸ êµ¬ì¡°ì²´ë¡œ ëŒ€ë¶€ë¶„ì˜ ê°’ì„ ë³µì‚¬í•˜ë ¤ê³  í•˜ëŠ” ê²½"
"ìš°ì— í•˜ë‚˜í•˜ë‚˜ íƒ€ì´í•‘í•˜ëŠ” ìˆ˜ê³ ë¥¼ ëœì–´ì¤ë‹ˆë‹¤. ë°˜ë“œì‹œ ë§¨ ë§ˆì§€ë§‰ì— ì™€ì•¼ í•©ë‹ˆë‹¤."

#: src/user-defined-types/tuple-structs.md:7
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "ê° í•„ë“œ ì´ë¦„ì´ ì¤‘ìš”í•˜ì§€ ì•Šë‹¤ë©´ íŠœí”Œ êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/user-defined-types/tuple-structs.md:14
msgid "\"({}, {})\""
msgstr ""

#: src/user-defined-types/tuple-structs.md:18
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"íŠœí”Œ êµ¬ì¡°ì²´ëŠ” ì¢…ì¢… ë‹¨ì¼ í•„ë“œì˜ ë˜í¼(wrapper, ëŸ¬ìŠ¤íŠ¸ì—ì„œ ë‰´íƒ€ì…(newtype)ì´ë¼"
"ê³  ë¶€ë¦„)ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤:"

#: src/user-defined-types/tuple-structs.md:25
msgid "\"Ask a rocket scientist at NASA\""
msgstr ""

#: src/user-defined-types/tuple-structs.md:29
#: src/android/interoperability/cpp/cpp-bridge.md:50
#: src/bare-metal/microcontrollers/type-state.md:14
#: src/async/pitfalls/cancellation.md:98 src/async/pitfalls/cancellation.md:101
msgid "// ...\n"
msgstr ""

#: src/user-defined-types/tuple-structs.md:40
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"ë‰´íƒ€ì…ì€ ê¸°ë³¸ íƒ€ì…ì— ë¶€ê°€ì ì¸ ì˜ë¯¸ë¥¼ ë”í•˜ëŠ” ì¢‹ì€ ë°©ë²•ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:"

#: src/user-defined-types/tuple-structs.md:42
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr "ìˆ«ìê°’ì— ë‹¨ìœ„ë¥¼ í‘œì‹œí•  ìˆ˜ ìˆìŒ: ìœ„ì—ì„œ `Newtons`ì´ ê·¸ ì˜ˆì…ë‹ˆë‹¤."

#: src/user-defined-types/tuple-structs.md:43
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"ê°’ì´ ìƒì„±ë  ë•Œ ì´ë¯¸ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í†µê³¼ í–ˆìœ¼ë¯€ë¡œ ì¶”ê°€ì ì¸ ê²€ì‚¬ê°€ í•„ìš”ì—†ìŠµë‹ˆ"
"ë‹¤: `PhoneNumber(String)`ë˜ëŠ” `OddNumber(u32)`."

#: src/user-defined-types/tuple-structs.md:46
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr "`Newtons` íƒ€ì…ì˜ ê°’ì— `f64` ê°’ì„ ë”í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì£¼ì„¸ìš”."

#: src/user-defined-types/tuple-structs.md:48
msgid ""
"Rust generally doesnâ€™t like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ë¶„ëª…í•˜ì§€ ì•Šì€ ê²ƒì„ ì‹«ì–´í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ë©´ ìë™ìœ¼ë¡œ unwrapí•˜ê±°ë‚˜ ë¶ˆë¦¬"
"ì–¸ ê°’ì„ ì •ìˆ˜ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒë“¤ì´ ê·¸ë ‡ìŠµë‹ˆë‹¤."

#: src/user-defined-types/tuple-structs.md:50
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "ì—°ì‚°ì ì¬ì •ì˜ëŠ” 3ì¼ì°¨ ì œë„¤ë¦­ ë¶€ë¶„ì—ì„œ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/user-defined-types/tuple-structs.md:51
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"ì´ëŠ” [í™”ì„± ê¸°í›„ ê¶¤ë„ì„  (Mars Climate Orbiter)](https://en.wikipedia.org/wiki/"
"Mars_Climate_Orbiter)ì˜ ì‹¤íŒ¨ ì›ì¸ìœ¼ë¡œ ì§€ëª©ëœ ë„ëŸ‰í˜• ì…ë ¥ ì˜¤ë¥˜ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/user-defined-types/enums.md:3
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr "`enum` í‚¤ì›Œë“œëŠ” ëª‡ê°€ì§€ ìœ í˜•(variant)ìœ¼ë¡œ í‘œí˜„ë˜ëŠ” íƒ€ì…ì„ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/user-defined-types/enums.md:15
msgid "// Simple variant\n"
msgstr ""

#: src/user-defined-types/enums.md:16
msgid "// Tuple variant\n"
msgstr ""

#: src/user-defined-types/enums.md:17
msgid "// Struct variant\n"
msgstr ""

#: src/user-defined-types/enums.md:22
msgid "\"On this turn: {:?}\""
msgstr ""

#: src/user-defined-types/enums.md:30
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type."
msgstr "ì—´ê±°í˜•ì€ ê°’ë“¤ì˜ ì§‘í•©ì„ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤"

#: src/user-defined-types/enums.md:31
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""

#: src/user-defined-types/enums.md:33
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""

#: src/user-defined-types/enums.md:36
#, fuzzy
msgid "This might be a good time to compare structs and enums:"
msgstr "êµ¬ì¡°ì²´ì™€ ì—´ê±°í˜•ì„ ë¹„êµí•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/user-defined-types/enums.md:37
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜• ëª¨ë‘, í•„ë“œê°€ í•˜ë‚˜ë„ ì—†ëŠ” ë‹¨ìˆœí•œ í˜•íƒœë„ ê°€ëŠ¥ í•˜ê³ , ì—¬ëŸ¬ íƒ€ì…"
"ì˜ í•„ë“œë¥¼ ê°€ì§ˆ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. "

#: src/user-defined-types/enums.md:39
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldnâ€™t be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"ì—´ê±°í˜• íƒ€ì…ì˜ ê° variantë¥¼ ë³„ë„ì˜ êµ¬ì¡°ì²´ë¡œ ì •ì˜í•  ìˆ˜ë„ ìˆì§€ë§Œ, ê·¸ëŸ¬ë©´ ì—´ê±°í˜•"
"ì„ ì‚¬ìš©í–ˆì„ ë•Œì²˜ëŸ¼ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ ì·¨ê¸‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. "

#: src/user-defined-types/enums.md:42
msgid "Rust uses minimal space to store the discriminant."
msgstr ""

#: src/user-defined-types/enums.md:43
msgid "If necessary, it stores an integer of the smallest required size"
msgstr ""

#: src/user-defined-types/enums.md:44
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""

#: src/user-defined-types/enums.md:48
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr "Cì™€ì˜ ì—°ë™ì„ ìœ„í•´ ì‹ë³„ì ê°’ì„ ì§ì ‘ ì§€ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/user-defined-types/enums.md:66
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"`repr` ì†ì„±ì´ ì—†ë‹¤ë©´ 10001ì´ 2 ë°”ì´íŠ¸ë¡œ í‘œí˜„ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ì‹ë³„ìì˜ íƒ€ì… í¬"
"ê¸°ëŠ” 2 ë°”ì´íŠ¸ê°€ ë©ë‹ˆë‹¤."

#: src/user-defined-types/enums.md:69
#: src/user-defined-types/static-and-const.md:75
#: src/memory-management/review.md:50 src/memory-management/move.md:99
#: src/smart-pointers/box.md:83 src/borrowing/shared.md:32
msgid "More to Explore"
msgstr ""

#: src/user-defined-types/enums.md:71
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr ""

#: src/user-defined-types/enums.md:73
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"ë„í¬ì¸í„° ìµœì í™”: [ì–´ë–¤ íƒ€ì…ë“¤](https://doc.rust-lang.org/std/option/"
"#representation)ì— ëŒ€í•´ì„œ ëŸ¬ìŠ¤íŠ¸ëŠ” `size_of::<T>()`ê°€ `size_of::"
"<Option<T>>()`ì™€ ê°™ì€ ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤."

#: src/user-defined-types/enums.md:77
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"ì‹¤ì œë¡œ ë„í¬ì¸í„° ìµœì í™”ê°€ ì ìš©ëœ ê²ƒì„ í™•ì¸í•˜ê³  ì‹¶ë‹¤ë©´ ì•„ë˜ì˜ ì˜ˆì œì½”ë“œë¥¼ ì‚¬ìš©í•˜"
"ì„¸ìš”. ì£¼ì˜í•  ì ì€, ì—¬ê¸°ì—ì„œ ë³´ì—¬ì£¼ëŠ” ë¹„íŠ¸ íŒ¨í„´ì´ ì»´íŒŒì¼ëŸ¬ê°€ ë³´ì¥í•´ ì£¼ëŠ” ê²ƒì€ "
"ì•„ë‹ˆë¼ëŠ” ì ì…ë‹ˆë‹¤. ì—¬ê¸°ì— ì˜ì¡´í•˜ëŠ” ê²ƒì€ ì™„ì „íˆ unsafeí•©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:3
#, fuzzy
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program."
msgstr ""
"ì •ì  ë³€ìˆ˜ì™€ ìƒìˆ˜ëŠ” ì „ì—­ ìŠ¤ì½”í”„ì—ì„œ ê°’ì„ ìƒì„±í•˜ëŠ” ë‘ ê°€ì§€ ë°©ë²•ì…ë‹ˆë‹¤. ì „ì—­ ìŠ¤"
"ì½”í”„ì— ìƒì„±ëœ ê°’ì€ í”„ë¡œê·¸ë¨ ìˆ˜í–‰ ë„ì¤‘ì— ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì´ë™ë˜ì§€ ì•Šìœ¼ë©°, ë©”ëª¨ë¦¬ "
"ìƒì—ì„œ ê·¸ ìœ„ì¹˜ê°€ ë³€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. "

#: src/user-defined-types/static-and-const.md:6
msgid "`const`"
msgstr "ìƒìˆ˜(`const`)"

#: src/user-defined-types/static-and-const.md:8
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr ""
"ìƒìˆ˜ëŠ” ì»´íŒŒì¼ í•  ë•Œ ê·¸ ê°’ì´ ì •í•´ì§‘ë‹ˆë‹¤. ê·¸ë¦¬ê³  ê·¸ ê°’ì€ ê·¸ ìƒìˆ˜ê°€ ì‚¬ìš©ë˜ëŠ” ëª¨"
"ë“  ë¶€ë¶„ì—ì„œ ì¸ë¼ì¸ ë©ë‹ˆë‹¤:"

#: src/user-defined-types/static-and-const.md:31
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"[Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static.html)"
"ì— ë”°ë¥´ë©´ ìƒìˆ˜ëŠ”, ê·¸ ìƒìˆ˜ê°€ ì‚¬ìš©ë˜ëŠ” ê³³ì— ì¸ë¼ì¸ ë©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:33
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"`const` ê°’ì„ ìƒì„±í•  ë•Œì—ëŠ” `const`ë¡œ ë§ˆí‚¹ëœ í•¨ìˆ˜ë§Œì´ í˜¸ì¶œ ê°€ëŠ¥í•˜ë©°, ì´ í•¨ìˆ˜ë“¤"
"ì€ ì»´íŒŒì¼ ì‹œì— í˜¸ì¶œì´ ë©ë‹ˆë‹¤. ë¬¼ë¡  `const`í•¨ìˆ˜ë“¤ì„ ëŸ°íƒ€ì„ì— í˜¸ì¶œí•˜ëŠ” ê²ƒë„ ê°€"
"ëŠ¥í•©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:36
msgid "`static`"
msgstr "ì •ì ë³€ìˆ˜(`static`)"

#: src/user-defined-types/static-and-const.md:38
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""
"ì •ì  ë³€ìˆ˜ëŠ” í”„ë¡œê·¸ë¨ì´ ìˆ˜í–‰ë˜ëŠ” ë™ì•ˆ ìœ ì§€ê°€ ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ë‹¤ë¥¸ ë³€ìˆ˜ë¡œ ì´ë™"
"(move)ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/user-defined-types/static-and-const.md:42
#, fuzzy
msgid "\"Welcome to RustOS 3.14\""
msgstr "1ì¼ì°¨ ê°œìš”"

#: src/user-defined-types/static-and-const.md:45
msgid "\"{BANNER}\""
msgstr ""

#: src/user-defined-types/static-and-const.md:49
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"[Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static.html)ì—"
"ì„œ ì–¸ê¸‰í•œ ë°”ì™€ ê°™ì´, ì •ì  ë³€ìˆ˜ëŠ” ë³„ë„ì˜ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°€ì§€ë©°, ì¸ë¼ì¸ ë˜ì§€ ì•Š"
"ìŠµë‹ˆë‹¤. ì •ì  ë³€ìˆ˜ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€(unsafe) ëŸ¬ìŠ¤íŠ¸ì™€ ì„ë² ë””ë“œ ì‹œìŠ¤í…œìš© ì½”ë“œì—"
"ì„œ ìœ ìš©í•©ë‹ˆë‹¤. ì´ë“¤ì˜ ìˆ˜ëª…ì€ í”„ë¡œê·¸ë¨ì´ ìˆ˜í–‰ë˜ëŠ” ì „ì²´ ì‹œê°„ê³¼ ë™ì¼í•©ë‹ˆë‹¤. ì „"
"ì—­ ìŠ¤ì½”í”„ë¥¼ ê°€ì§„ ì–´ë–¤ ê°’ì´, ë©”ëª¨ë¦¬ ìƒì— ë‹¨ í•˜ë‚˜ë§Œ ì¡´ì¬í•´ì•¼ í•œë‹¤ëŠ” ìš”êµ¬ì¡°ê±´ì´ "
"ì—†ë‹¤ë©´, ì •ì  ë³€ìˆ˜ ëŒ€ì‹  `const`ë¥¼ ì“°ëŠ” ê²ƒì´ ì˜³ìŠµë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:57
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ `const`ëŠ” C++ì˜ `constexpr`ê³¼ ë§¤ìš° ë¹„ìŠ·í•©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:58
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"ë°˜ë©´ì— ëŸ¬ìŠ¤íŠ¸ì˜ `static`ì€ C++ì˜ `const`ë‚˜ ê°€ë³€ ì •ì  ë³€ìˆ˜(mutable global "
"variable)ì™€ í›¨ì”¬ ë” ìœ ì‚¬í•©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:60
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"`static`ì€ ê°ì²´ì— ì •ì²´ì„±ì„ ë¶€ì—¬í•©ë‹ˆë‹¤. ì •ì²´ì •ì´ë€ ë©”ëª¨ë¦¬ ìƒì—ì„œì˜ ì£¼ì†Œ, ê·¸ë¦¬"
"ê³  ë‚´ë¶€ ìƒíƒœë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:62
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì‹œ ê·¸ ê°’ì´ ì •í•´ì§€ëŠ” ìƒìˆ˜ê°€ í•„ìš”í•œ ê²½ìš°ëŠ” ë“œë­…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ë ‡ë‹¤"
"ê³  í•´ë„, ì •ì  ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ ë³´ë‹¤ëŠ” ë” ìœ ìš©í•˜ê³  ì•ˆì „í•©ë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:65
msgid "Properties table:"
msgstr "ì†ì„± ë¹„êµ í…Œì´ë¸”:"

#: src/user-defined-types/static-and-const.md:67
#: src/chromium/adding-third-party-crates.md:6
msgid "Property"
msgstr "ì†ì„±"

#: src/user-defined-types/static-and-const.md:67
msgid "Static"
msgstr "ì •ì (static) ë³€ìˆ˜"

#: src/user-defined-types/static-and-const.md:67
msgid "Constant"
msgstr "ìƒìˆ˜(constant)"

#: src/user-defined-types/static-and-const.md:69
msgid "Has an address in memory"
msgstr "ë©”ëª¨ë¦¬ ìƒì— ì£¼ì†Œê°€ ìˆëŠ”ê°€"

#: src/user-defined-types/static-and-const.md:69
#: src/user-defined-types/static-and-const.md:70
#: src/user-defined-types/static-and-const.md:72
#: src/user-defined-types/static-and-const.md:73
#: src/chromium/adding-third-party-crates/resolving-problems.md:12
#: src/chromium/adding-third-party-crates/resolving-problems.md:13
#: src/chromium/adding-third-party-crates/resolving-problems.md:14
msgid "Yes"
msgstr "ì˜ˆ"

#: src/user-defined-types/static-and-const.md:69
msgid "No (inlined)"
msgstr "ì•„ë‹ˆì˜¤(ì¸ë¼ì¸ ë¨)"

#: src/user-defined-types/static-and-const.md:70
msgid "Lives for the entire duration of the program"
msgstr "í”„ë¡œê·¸ë¨ì´ ìˆ˜í–‰ë˜ëŠ” ë™ì•ˆ ê³„ì† ì‚´ì•„ ìˆëŠ”ê°€"

#: src/user-defined-types/static-and-const.md:70
#: src/user-defined-types/static-and-const.md:71
#: src/user-defined-types/static-and-const.md:73
#: src/chromium/adding-third-party-crates/resolving-problems.md:15
#: src/chromium/adding-third-party-crates/resolving-problems.md:16
msgid "No"
msgstr "ì•„ë‹ˆì˜¤"

#: src/user-defined-types/static-and-const.md:71
msgid "Can be mutable"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œê°€"

#: src/user-defined-types/static-and-const.md:71
msgid "Yes (unsafe)"
msgstr "ì˜ˆ (ê·¸ëŸ¬ë‚˜ ì•ˆì „í•˜ì§€ ì•ŠìŒ)"

#: src/user-defined-types/static-and-const.md:72
msgid "Evaluated at compile time"
msgstr "ì»´íŒŒì¼ì‹œ ê·¸ ê°’ì´ ê²°ì •ë˜ëŠ”ê°€"

#: src/user-defined-types/static-and-const.md:72
msgid "Yes (initialised at compile time)"
msgstr "ì˜ˆ (ì»´íŒŒì¼ì‹œ ì´ˆê¸°í™” ë¨)"

#: src/user-defined-types/static-and-const.md:73
msgid "Inlined wherever it is used"
msgstr "ì‚¬ìš©ë˜ëŠ” ê³³ì— ì¸ë¼ì¸ ë˜ëŠ”ê°€"

#: src/user-defined-types/static-and-const.md:77
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"`static`ë³€ìˆ˜ë“¤ì€ ì–´ë–¤ ìŠ¤ë ˆë“œì—ì„œë„ ì ‘ê·¼ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì—, `Sync`íŠ¸ë ˆì‡ì„ êµ¬í˜„"
"í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ë³€ìˆ˜ë¥¼ ì½ê³  ì“°ë ¤ë©´ [`Mutex`](https://doc.rust-lang.org/std/"
"sync/struct.Mutex.html)ë¡œ ê°ì‹¸ê±°ë‚˜, atomic ì—°ì‚°ì„ ì¨ì•¼ í•©ë‹ˆë‹¤. `static` ë³€ìˆ˜"
"ë¥¼ mutableí•˜ê²Œ ì„ ì–¸í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì´ ê²½ìš° ë™ê¸°í™” ì‘ì—…ì„ ìˆ˜ë™ìœ¼ë¡œ í•´ ì£¼ì–´ì•¼ "
"í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ ê·¸ëŸ¬í•œ ë³€ìˆ˜ë¥¼ ì ‘ê·¼í•˜ëŠ” ì½”ë“œëŠ”`unsafe`ë¡œ ëª…ì‹œì ìœ¼ë¡œ í‘œì‹œê°€ ë˜ì–´"
"ì•¼ í•©ë‹ˆë‹¤. \"ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸\"ë¥¼ ë°°ìš¸ ë•Œ [mutable statics](../unsafe/"
"mutable-static-variables.md) ë¶€ë¶„ì—ì„œ ì¢€ ë” ìì„¸íˆ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤."

#: src/user-defined-types/static-and-const.md:82
#, fuzzy
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr ""
"`thread_local` ë°ì´í„°ëŠ” `std::thread_local` ë§¤í¬ë¡œë¥¼ ì´ìš©í•˜ì—¬ ìƒì„±í•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/user-defined-types/aliases.md:3
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr ""

#: src/user-defined-types/aliases.md:13
msgid "// Aliases are more useful with long, complex types:\n"
msgstr ""

#: src/user-defined-types/aliases.md:22
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr ""

#: src/user-defined-types/exercise.md:3
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""

#: src/user-defined-types/exercise.md:7
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""

#: src/user-defined-types/exercise.md:12 src/user-defined-types/solution.md:4
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""

#: src/user-defined-types/exercise.md:15
msgid "// TODO: add required variants\n"
msgstr ""

#: src/user-defined-types/exercise.md:17 src/user-defined-types/solution.md:22
msgid "/// A direction of travel.\n"
msgstr ""

#: src/user-defined-types/exercise.md:24 src/user-defined-types/solution.md:39
msgid "/// The car has arrived on the given floor.\n"
msgstr ""

#: src/user-defined-types/exercise.md:29 src/user-defined-types/solution.md:44
msgid "/// The car doors have opened.\n"
msgstr ""

#: src/user-defined-types/exercise.md:34 src/user-defined-types/solution.md:49
msgid "/// The car doors have closed.\n"
msgstr ""

#: src/user-defined-types/exercise.md:39 src/user-defined-types/solution.md:54
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr ""

#: src/user-defined-types/exercise.md:44 src/user-defined-types/solution.md:59
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr ""

#: src/user-defined-types/exercise.md:52 src/user-defined-types/solution.md:67
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:55 src/user-defined-types/solution.md:70
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:56 src/user-defined-types/solution.md:71
msgid "\"The car door opened: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:58 src/user-defined-types/solution.md:73
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:61 src/user-defined-types/solution.md:76
msgid "\"The car door closed: {:?}\""
msgstr ""

#: src/user-defined-types/exercise.md:62 src/user-defined-types/solution.md:77
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr ""

#: src/user-defined-types/solution.md:7
msgid "/// A button was pressed.\n"
msgstr ""

#: src/user-defined-types/solution.md:10
msgid "/// The car has arrived at the given floor.\n"
msgstr ""

#: src/user-defined-types/solution.md:13
msgid "/// The car's doors have opened.\n"
msgstr ""

#: src/user-defined-types/solution.md:16
msgid "/// The car's doors have closed.\n"
msgstr ""

#: src/user-defined-types/solution.md:19
msgid "/// A floor is represented as an integer.\n"
msgstr ""

#: src/user-defined-types/solution.md:29
msgid "/// A user-accessible button.\n"
msgstr ""

#: src/user-defined-types/solution.md:33
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr ""

#: src/user-defined-types/solution.md:36
msgid "/// A floor button within the car.\n"
msgstr ""

#: src/welcome-day-2.md:1
msgid "Welcome to Day 2"
msgstr "2ì¼ì°¨ ê°œìš”"

#: src/welcome-day-2.md:3
#, fuzzy
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr "ìƒë‹¹í•œ ë¶„ëŸ‰ì˜ ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•´ ë³´ì•˜ê³ , ì´ì–´ì„œ ì˜¤ëŠ˜ ê°•ì˜ë¥¼ ì§„í–‰í•˜ê² ìŠµë‹ˆë‹¤:"

#: src/welcome-day-2.md:6
#, fuzzy
msgid "Pattern matching: extracting data from structures."
msgstr "íŒ¨í„´ ë§¤ì¹­: ì—´ê±°í˜•, êµ¬ì¡°ì²´ ê·¸ë¦¬ê³  ë°°ì—´ ë¶„í•´."

#: src/welcome-day-2.md:7
msgid "Methods: associating functions with types."
msgstr ""

#: src/welcome-day-2.md:8
msgid "Traits: behaviors shared by multiple types."
msgstr ""

#: src/welcome-day-2.md:9
msgid "Generics: parameterizing types on other types."
msgstr ""

#: src/welcome-day-2.md:10
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr ""

#: src/pattern-matching/destructuring.md:3
msgid "Like tuples, structs and enums can also be destructured by matching:"
msgstr ""

#: src/pattern-matching/destructuring.md:5
#: src/pattern-matching/destructuring.md:58
msgid "Structs"
msgstr "êµ¬ì¡°ì²´"

#: src/pattern-matching/destructuring.md:17
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr ""

#: src/pattern-matching/destructuring.md:18
msgid "\"y = 2, x = {i:?}\""
msgstr ""

#: src/pattern-matching/destructuring.md:19
msgid "\"y = {y}, other fields were ignored\""
msgstr ""

#: src/pattern-matching/destructuring.md:26
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜• ê°’ì˜ ì¼ë¶€ë¥¼ íŒ¨í„´ ë§¤ì¹˜ë¥¼ í†µí•´ ë³€ìˆ˜ì— ë°”ì¸ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°„"
"ë‹¨í•œ `enum` íƒ€ì…ì„ ë¨¼ì € ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/pattern-matching/destructuring.md:39
msgid "\"cannot divide {n} into two equal parts\""
msgstr ""

#: src/pattern-matching/destructuring.md:46
msgid "\"{n} divided in two is {half}\""
msgstr ""

#: src/pattern-matching/destructuring.md:47
msgid "\"sorry, an error happened: {msg}\""
msgstr ""

#: src/pattern-matching/destructuring.md:52
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"`match`êµ¬ë¬¸ì—ì„œ `divide_in_two`í•¨ìˆ˜ì—ì„œ ë°˜í™˜ë˜ëŠ” `Result` ê°’ì„ ë‘ ê°œì˜ íŒ”(í˜¹"
"ì€ ê°€ì§€)ë¡œ _ë¶„í•´(destructure)_ í•˜ì˜€ìŠµë‹ˆë‹¤. ì²«ë²ˆì§¸ íŒ”ì—ì„œ `half`ëŠ” `Ok` "
"variantì— ë‹´ê¸´ ê°’ìœ¼ë¡œ ë°”ì¸ë”©ë©ë‹ˆë‹¤. ë‘ë²ˆì§¸ íŒ”ì—ì„œ `msg`ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ ë¬¸ìì—´"
"ì— ë°”ì¸ë”©ë©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring.md:60
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr "`foo`ì˜ ë¦¬í„°ëŸ´ ê°’ì„ ë‹¤ë¥¸ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ë„ë¡ ë³€ê²½í•©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring.md:61
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr "`Foo`ì— ìƒˆ í•„ë“œë¥¼ ì¶”ê°€í•˜ê³  í•„ìš”ì— ë”°ë¼ íŒ¨í„´ì„ ë³€ê²½í•©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring.md:62
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"ìº¡ì²˜ì™€ ìƒìˆ˜ í‘œí˜„ì‹ì€ êµ¬ë¶„í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‘ ë²ˆì§¸ ë¶€ë¬¸ì˜ `2`ë¥¼ ë³€ìˆ˜"
"ë¡œ ë³€ê²½í•´ ë³´ê³  ì‘ë™í•˜ì§€ ì•ŠëŠ” ê²ƒì„ í™•ì¸í•˜ì„¸ìš”. `const`ë¡œ ë³€ê²½í•˜ê³  ë‹¤ì‹œ ì‘ë™í•˜"
"ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring.md:70
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr ""
"`if`/`else` í‘œí˜„ì‹ì€ ì—´ê±°í˜•ì„ ë°˜í™˜í•˜ê³ , ì´ ê°’ì€ ë‚˜ì¤‘ì— `match`ë¡œ ë¶„í•´ë©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring.md:72
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"ì—´ê±°í˜•ì— ì„¸ë²ˆì§¸ variantë¥¼ ì¶”ê°€í•˜ê³  ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ ì˜¤ë¥˜ë¥¼ í‘œì‹œí•´ë³´ì„¸ìš”. ì½”ë“œ "
"ì–´ëŠ ë¶€ë¶„ì— ëˆ„ë½ì´ ìˆëŠ”ì§€, ê·¸ë¦¬ê³  ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–¤ ì‹ìœ¼ë¡œ íŒíŠ¸ë¥¼ ì£¼ëŠ”ì§€ ê°™ì´ "
"ì‚´í´ë³´ì„¸ìš”."

#: src/pattern-matching/destructuring.md:75
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`."
msgstr ""
"ì—´ê±°í˜• ì•ˆì˜ ê°’ì€ íŒ¨í„´ ë§¤ì¹­ì´ ë˜ê³  ë‚œ ì´í›„ì—ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ ê°’ì— ëŒ€í•œ "
"ë ˆí¼ëŸ°ìŠ¤ëŠ” `=>` ì´í›„ì— ì‚¬ìš©ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/pattern-matching/destructuring.md:78
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"ë§¤ì¹­ íŒ¨í„´ë“¤ì´ ë¶ˆì¶©ë¶„ í•˜ë‹¤ë©´ ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì„¤ëª…í•˜ì„¸ìš”. ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬"
"ëŠ” ëª¨ë“  ê°€ëŠ¥í•œ ì¼€ì´ìŠ¤ë“¤ì´ í•¸ë“¤ë§ ë˜ëŠ”ì§€ ì²´í¬í•œë‹¤ëŠ” ì ì„ ìƒê¸°ì‹œí‚¤ì„¸ìš”. "

#: src/pattern-matching/let-control-flow.md:3
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""

#: src/pattern-matching/let-control-flow.md:6
#: src/pattern-matching/let-control-flow.md:10
msgid "`if let` expressions"
msgstr "`if let` í‘œí˜„ì‹"

#: src/pattern-matching/let-control-flow.md:7
#, fuzzy
msgid "`while let` expressions"
msgstr "while let í‘œí˜„ì‹"

#: src/pattern-matching/let-control-flow.md:8
msgid "`match` expressions"
msgstr "`match` í‘œí˜„ì‹"

#: src/pattern-matching/let-control-flow.md:12
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"[`if let` í‘œí˜„ì‹](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions)ì„ ì‚¬ìš©í•˜ë©´ ê°’ì´ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ì— ë”°ë¼ ë‹¤ë¥¸ ì½”ë“œ"
"ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/pattern-matching/let-control-flow.md:24
msgid "\"slept for {:?}\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:33
#, fuzzy
msgid "`let else` expressions"
msgstr "`if let` í‘œí˜„ì‹"

#: src/pattern-matching/let-control-flow.md:35
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""

#: src/pattern-matching/let-control-flow.md:45
#: src/pattern-matching/let-control-flow.md:107
msgid "\"got None\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:51
#: src/pattern-matching/let-control-flow.md:111
msgid "\"got empty string\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:57
#: src/pattern-matching/let-control-flow.md:115
msgid "\"not a hex digit\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:62
#: src/pattern-matching/solution.md:113
msgid "\"result: {:?}\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:62
#: src/methods-and-traits/exercise.md:114
#: src/methods-and-traits/exercise.md:115
#: src/methods-and-traits/exercise.md:116 src/generics/trait-bounds.md:16
#: src/smart-pointers/solution.md:87 src/smart-pointers/solution.md:90
#: src/testing/googletest.md:11 src/testing/googletest.md:12
#: src/testing/solution.md:83
msgid "\"foo\""
msgstr ""

#: src/pattern-matching/let-control-flow.md:66
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ, ë¬´í•œ ë£¨í”„ë¥¼ ë§Œë“œëŠ” [`loop` í‚¤ì›Œë“œ](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#infinite-loops)ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/pattern-matching/let-control-flow.md:82
#, fuzzy
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"`v.into_iter()`ê°€ ë°˜í™˜í•œ ë°˜ë³µìëŠ” `next()`ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ `Option<i32>`ë¥¼ ë°˜"
"í™˜í•©ë‹ˆë‹¤. ë°˜ë³µìê°€ ì™„ë£Œë  ë•Œê¹Œì§€ëŠ” `Some(x)`ë¥¼ ë°˜í™˜í•˜ê³  ë§ˆì§€ë§‰ì—” `None`ì„ ë°˜"
"í™˜í•©ë‹ˆë‹¤. `while let`ì„ í†µí•´ ë°˜ë³µìì˜ ëª¨ë“  ì•„ì´í…œì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/pattern-matching/let-control-flow.md:89
msgid "if-let"
msgstr ""

#: src/pattern-matching/let-control-flow.md:91
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"`if let`ì´ `match`ë³´ë‹¤ ë” ê°„ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: í•œê°€ì§€ ë¸Œëœì¹˜ë§Œ í¥ë¯¸ë¡œìš´ ê²½"
"ìš°). ì´ì™€ ë‹¬ë¦¬ `match`ì—ì„œëŠ” ëª¨ë“  ë¸Œëœì¹˜ê°€ ì²˜ë¦¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/pattern-matching/let-control-flow.md:93
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr "ì¼ë°˜ì  ì‚¬ìš©ë²•ì€ `Option`ì„ ì‚¬ìš©í•  ë•Œ `Some` ê°’ì„ ì²˜ë¦¬í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/pattern-matching/let-control-flow.md:94
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"`match`ì™€ ë‹¬ë¦¬ `if let`ì€ íŒ¨í„´ ì¼ì¹˜ë¥¼ ìœ„í•œ ë³´í˜¸ ì ˆì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/pattern-matching/let-control-flow.md:96
msgid "let-else"
msgstr ""

#: src/pattern-matching/let-control-flow.md:98
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""

#: src/pattern-matching/let-control-flow.md:102
msgid "The rewritten version is:"
msgstr ""

#: src/pattern-matching/let-control-flow.md:122
#, fuzzy
msgid "while-let"
msgstr "`while let` ë°˜ë³µë¬¸"

#: src/pattern-matching/let-control-flow.md:124
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr "`while let`ì€ ê°’ì´ íŒ¨í„´ì— ë§¤ì¹˜ë˜ëŠ” ë™ì•ˆ ê³„ì†ë©ë‹ˆë‹¤."

#: src/pattern-matching/let-control-flow.md:126
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"`while let` ë£¨í”„ ëŒ€ì‹  ë¬´í•œ ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ê³  `iter.next()`ê°€ ë¹ˆ ê°’ì„ ë°˜í™˜í•  ë•Œ "
"ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ì˜¤ë„ë¡ ì‘ì„±í• ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. `while let`ì€ ê·¸ëŸ¬í•œ ê²½ìš°ë¥¼ ìœ„í•œ ë¬¸"
"ë²•ì  í¸ì˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/pattern-matching/exercise.md:3
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr ""

#: src/pattern-matching/exercise.md:5
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""

#: src/pattern-matching/exercise.md:10
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""

#: src/pattern-matching/exercise.md:15
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""

#: src/pattern-matching/exercise.md:26
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""

#: src/pattern-matching/exercise.md:30 src/pattern-matching/solution.md:4
msgid "/// An operation to perform on two subexpressions.\n"
msgstr ""

#: src/pattern-matching/exercise.md:38 src/pattern-matching/solution.md:12
msgid "/// An expression, in tree form.\n"
msgstr ""

#: src/pattern-matching/exercise.md:42 src/pattern-matching/solution.md:16
msgid "/// An operation on two subexpressions.\n"
msgstr ""

#: src/pattern-matching/exercise.md:45 src/pattern-matching/solution.md:19
msgid "/// A literal value\n"
msgstr ""

#: src/pattern-matching/exercise.md:104 src/pattern-matching/solution.md:40
#: src/pattern-matching/solution.md:102
msgid "\"division by zero\""
msgstr ""

#: src/pattern-matching/solution.md:112
msgid "\"expr: {:?}\""
msgstr ""

#: src/methods-and-traits/methods.md:3
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì„ ì–¸ëœ íƒ€ì…ì— ëŒ€í•´ `impl`ë¸”ë¡ì— í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ì—¬ ë©”ì„œë“œë¥¼ ì—°ê²° í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/methods-and-traits/methods.md:14
msgid "// No receiver, a static method\n"
msgstr ""

#: src/methods-and-traits/methods.md:19
msgid "// Exclusive borrowed read-write access to self\n"
msgstr ""

#: src/methods-and-traits/methods.md:24
msgid "// Shared and read-only borrowed access to self\n"
msgstr ""

#: src/methods-and-traits/methods.md:26
msgid "\"Recorded {} laps for {}:\""
msgstr ""

#: src/methods-and-traits/methods.md:28
msgid "\"Lap {idx}: {lap} sec\""
msgstr ""

#: src/methods-and-traits/methods.md:32
msgid "// Exclusive ownership of self\n"
msgstr ""

#: src/methods-and-traits/methods.md:35
msgid "\"Race {} is finished, total lap time: {}\""
msgstr ""

#: src/methods-and-traits/methods.md:40
msgid "\"Monaco Grand Prix\""
msgstr ""

#: src/methods-and-traits/methods.md:47
msgid "// race.add_lap(42);\n"
msgstr ""

#: src/methods-and-traits/methods.md:51
#, fuzzy
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"`&self`ëŠ” ë©”ì„œë“œê°€ ê°ì²´ë¥¼ ë¶ˆë³€í•˜ê²Œ ë¹Œë ¤ì˜´ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ë©”ì„œë“œì˜ ë¦¬ì‹œë²„ëŠ” ë‹¤"
"ìŒì˜ í˜•íƒœë“¤ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/methods-and-traits/methods.md:54
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&self`: í˜¸ì¶œìë¡œë¶€í„° ê³µìœ ê°€ëŠ¥í•œ ë¶ˆë³€ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ ê°ì²´ë¥¼ ë¹Œë ¤ì˜´ì„ ë‚˜íƒ€ëƒ…ë‹ˆ"
"ë‹¤. ê°ì²´ëŠ” ë©”ì†Œë“œ í˜¸ì¶œ ë’¤ì—ë„ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:56
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"`&mut self`: í˜¸ì¶œìë¡œë¶€í„° ìœ ì¼í•œ ê°€ë³€ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ ê°ì²´ë¥¼ ë¹Œë ¤ì˜´ì„ ë‚˜íƒ€ëƒ…ë‹ˆ"
"ë‹¤. ê°ì²´ëŠ” ë©”ì†Œë“œ í˜¸ì¶œ ë’¤ì—ë„ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:58
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"`self`: í˜¸ì¶œìë¡œë¶€í„° ê°ì²´ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜¤ê³  ê°ì²´ëŠ” í˜¸ì¶œìë¡œë¶€í„° ë©”ì†Œë“œë¡œ ì´"
"ë™ë©ë‹ˆë‹¤. ë©”ì†Œë“œê°€ ê°ì²´ë¥¼ ì†Œìœ í•˜ê²Œ ë˜ë©° ë”°ë¼ì„œ ëª…ì‹œì ìœ¼ë¡œ ì†Œìœ ê¶Œì„ ë‹¤ë¥¸ ê³³ìœ¼"
"ë¡œ ì „ë‹¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë©”ì„œë“œ ì¢…ë£Œì™€ í•¨ê»˜ ê°ì²´ëŠ” drop(í•´ì œ)ë©ë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:62
#, fuzzy
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr ""
"`mut self`: ìœ„ì™€ ë™ì¼í•˜ì§€ë§Œ ë©”ì„œë“œê°€ ê°ì²´ì˜ ì†Œìœ ê¶Œì„ ê°€ì§€ë©´ì„œ ë™ì‹œì— ê°ì²´ë¥¼ "
"ìˆ˜ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì†Œìœ ê¶Œì„ ê°€ì§€ëŠ” ê²ƒì´ ìˆ˜ì •í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•˜ëŠ” ê²ƒì€ ì•„"
"ë‹™ë‹ˆë‹¤. "

#: src/methods-and-traits/methods.md:63
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"ë¦¬ì‹œë²„ ì—†ìŒ: êµ¬ì¡°ì²´ì˜ ì •ì  ë©”ì„œë“œê°€ ë©ë‹ˆë‹¤. ì£¼ë¡œ ìƒì„±ìë¥¼ ë§Œë“¤ë•Œ ì‚¬ìš©í•˜ê²Œ ë˜"
"ë©°, ìƒì„±ìëŠ” í”íˆ `new`ë¼ê³  ì´ë¦„ë¶™ì…ë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:70
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "ë©”ì„œë“œë¥¼ í•¨ìˆ˜ì™€ ë¹„êµí•˜ì—¬ ì†Œê°œí•˜ëŠ” ê²ƒë„ ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:71
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"ë©”ì„œë“œëŠ” êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜•ê³¼ ê°™ì€ íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ í˜¸ì¶œ ë˜ë©°, ì²«ë²ˆì§¸ ë§¤ê°œë³€"
"ìˆ˜(íŒŒë¼ë©”í„°)ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ `self`ë¡œ í‘œê¸°í•©ë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:73
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"ë©”ì„œë“œë¥¼ ì´ìš©í•˜ë©´ receiver ë¬¸ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê³  ì½”ë“œë¥¼ ì¢€ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë©”ì„œë“œë“¤ì´ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ìœ„ì¹˜ì— ëª¨ì—¬ ìˆìœ¼ë‹ˆ ì°¾ê¸° ì‰½ìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:76
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "ë©”ì„œë“œ receiverì¸ `self` í‚¤ì›Œë“œ ì‚¬ìš©ì„ ì–¸ê¸‰í•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:77
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr ""
"ì˜ˆì œì˜ ê²½ìš° `self: &Self`ì˜ ì¤„ì¸ ë²„ì „ì„ì„ ì•Œë ¤ì£¼ê³ , êµ¬ì¡°ì²´ì˜ ì´ë¦„ì„ ì§ì ‘ ì‚¬ìš©"
"í•˜ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ë³´ì—¬ì£¼ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:79
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"`impl` ë¸”ë¡ ë‚´ë¶€ì—ì„œëŠ” `Self`ê°€ í•´ë‹¹ íƒ€ì…ì˜ ì´ë¦„ ëŒ€ìš©ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒì„ ì•Œ"
"ë ¤ì£¼ì„¸ìš”."

#: src/methods-and-traits/methods.md:81
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"êµ¬ì¡°ì²´ì˜ í•„ë“œë¥¼ ì ‘ê·¼í•  ë•Œ ì  í‘œê¸°ë¥¼ ì‚¬ìš©í•˜ë“¯ì´ `self`ì— ì  í‘œê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°œ"
"ë³„ í•„ë“œë“¤ì„ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:83
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"`say_hello` í•¨ìˆ˜ê°€ ë‘ ë²ˆ í˜¸ì¶œë˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì—¬ `&self`ì™€ `self`ê°€ ì–´ë–»"
"ê²Œ ë‹¤ë¥¸ì§€ ë³´ì—¬ì£¼ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤."

#: src/methods-and-traits/methods.md:85
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"`self`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ê°™ì€ ë³€í˜•ë“¤ ì™¸ì—ë„ `Box<Self>`ì™€ ê°™ì´ ë¦¬ì‹œë²„ íƒ€ì…ìœ¼ë¡œ í—ˆ"
"ìš©ë˜ëŠ” [íŠ¹ë³„í•œ ë˜í¼ íƒ€ì…](https://doc.rust-lang.org/reference/special-types-"
"and-traits.html)ì´ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/traits.md:3
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "íŠ¸ë ˆì‡ì€ íƒ€ì…ì„ ì¶”ìƒí™” í•˜ëŠ”ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì¸í„°í˜ì´ìŠ¤ì™€ ë¹„ìŠ·í•©ë‹ˆë‹¤:"

#: src/methods-and-traits/traits.md:18
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr ""

#: src/methods-and-traits/traits.md:24
#: src/methods-and-traits/trait-objects.md:20
msgid "\"Woof, my name is {}!\""
msgstr ""

#: src/methods-and-traits/traits.md:30
#: src/methods-and-traits/trait-objects.md:26
msgid "\"Miau!\""
msgstr ""

#: src/methods-and-traits/traits.md:36
#: src/methods-and-traits/trait-objects.md:33
msgid "\"Fido\""
msgstr ""

#: src/methods-and-traits/traits.md:45
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr ""

#: src/methods-and-traits/traits.md:48
msgid "Traits are implemented in an `impl <trait> for <type> { .. }` block."
msgstr ""

#: src/methods-and-traits/traits.md:50
#, fuzzy
msgid ""
"Traits may specify pre-implemented (provided) methods and methods that users "
"are required to implement themselves. Provided methods can rely on required "
"methods. In this case, `greet` is provided, and relies on `talk`."
msgstr ""
"íŠ¸ë ˆì‡ì€, ê·¸ íŠ¸ë ˆì‡ì´ ì •ì˜ëœ ìœ„ì¹˜ì—ì„œ ì§ì ‘ êµ¬í˜„ë˜ëŠ” ë””í´íŠ¸ ë©”ì„œë“œì™€, ê±°ê¸°ì—ì„œ"
"ëŠ” ì„ ì–¸ë§Œ ì¡´ì¬í•˜ê³  ê·¸ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì—ì„œ êµ¬í˜„í•´ì•¼ í•˜ëŠ”, ë‘ ì¢…ë¥˜ì˜ ë©”"
"ì„œë“œë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë””í´íŠ¸ ë©”ì„œë“œë¥¼ êµ¬í˜„í•  ë•Œì—ëŠ”, ë‘ ì¢…ë¥˜ì˜ ë©”ì„œë“œ ëª¨"
"ë‘ ì‚¬ìš©(í˜¸ì¶œ)í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/deriving.md:3
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr ""

#: src/methods-and-traits/deriving.md:15
msgid "// Default trait adds `default` constructor.\n"
msgstr ""

#: src/methods-and-traits/deriving.md:16
msgid "// Clone trait adds `clone` method.\n"
msgstr ""

#: src/methods-and-traits/deriving.md:17
msgid "\"EldurScrollz\""
msgstr ""

#: src/methods-and-traits/deriving.md:18
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr ""

#: src/methods-and-traits/deriving.md:19
msgid "\"{:?} vs. {:?}\""
msgstr ""

#: src/methods-and-traits/deriving.md:25
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""

#: src/methods-and-traits/trait-objects.md:3
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"íŠ¸ë ˆì‡ ê°ì²´ëŠ” íƒ€ì…ì´ ë‹¤ë¥¸ ê°’(ì˜ˆë¥¼ ë“¤ì–´ ì»¬ë ‰ì…˜ì— ì†í•œ ê° ê°’)ë“¤ì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤:"

#: src/methods-and-traits/trait-objects.md:36
msgid "\"Hello, who are you? {}\""
msgstr ""

#: src/methods-and-traits/trait-objects.md:41
msgid "Memory layout after allocating `pets`:"
msgstr "`pets`ë¥¼ í• ë‹¹í•œ ì´í›„ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:"

#: src/methods-and-traits/trait-objects.md:43
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" ìŠ¤íƒ                             í™\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    "
"pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------"
"+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  "
"|           :\n"
":                           :     :     | |   |     +---------------"
"+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                 :\n"
"                                  :     | |   |     +----------------------"
"+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    : \n"
"                                  :     | "
"|                                     : \n"
"                                  :     | |   +-"
"+                               :   \n"
"                                  :     | '-->|"
"\\|                               :     \n"
"                                  :     |     +-"
"+                               :    \n"
"                                  :     "
"|                                       : \n"
"                                  :     |     +----------------------"
"+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" "
"|          : \n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"\n"
"```"

#: src/methods-and-traits/trait-objects.md:77
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"ì—¬ëŸ¬ íƒ€ì…ì´ ê°™ì€ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë”ë¼ë„ ê·¸ í¬ê¸°ëŠ” ì„œë¡œ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜"
"ì„œ `Vec<Greeet>`ê°™ì€ ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/methods-and-traits/trait-objects.md:79
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"`dyn Pet`ì´ë¼ê³  í•˜ë©´ì´ íƒ€ì…ì˜ í¬ê¸°ëŠ” ë™ì ì´ë©° `Pet`ì„ êµ¬í˜„í•˜ê³  ìˆë‹¤ê³  ì»´íŒŒì¼"
"ëŸ¬ì—ê²Œ ì•Œë ¤ì£¼ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/methods-and-traits/trait-objects.md:81
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""

#: src/methods-and-traits/trait-objects.md:83
#, fuzzy
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"ì˜ˆì œì—ì„œ `pets`ëŠ” `Pet`ì„ êµ¬í˜„í•˜ëŠ” ê°ì²´ë“¤ì˜ _Fat í¬ì¸í„°_ë¥¼ ë‹´ê³  ìˆìŠµë‹ˆë‹¤. "
"Fat í¬ì¸í„°ëŠ” ì‹¤ì œ ê°ì²´ì— ëŒ€í•œ í¬ì¸í„°ì™€ ê·¸ ê°ì²´ê°€ `Pet`ì„ êµ¬í˜„í•˜ê³  ìˆëŠ” ê°€ìƒ "
"í•¨ìˆ˜ í…Œì´ë¸”ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ê°€ì§‘ë‹ˆë‹¤."

#: src/methods-and-traits/trait-objects.md:86
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""

#: src/methods-and-traits/trait-objects.md:88
msgid "Compare these outputs in the above example:"
msgstr "ì•„ë˜ ì½”ë“œì˜ ê²°ê³¼ì™€ ë¹„êµí•´ë³´ì„¸ìš”:"

#: src/methods-and-traits/trait-objects.md:90
#: src/methods-and-traits/trait-objects.md:91 src/std-traits/closures.md:62
msgid "\"{} {}\""
msgstr ""

#: src/methods-and-traits/trait-objects.md:92
#: src/methods-and-traits/trait-objects.md:93
#: src/methods-and-traits/solution.md:112 src/std-traits/exercise.md:23
#: src/std-traits/solution.md:29 src/modules/solution.md:78
#: src/android/build-rules/library.md:44
#: src/android/interoperability/cpp/rust-bridge.md:17
#: src/async/pitfalls/cancellation.md:59
msgid "\"{}\""
msgstr ""

#: src/methods-and-traits/exercise.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and "
"trait objects. We'll only implement the drawing of it (as text) for "
"simplicity."
msgstr ""
"ì´ë²ˆ ì—°ìŠµë¬¸ì œì—ì„œëŠ” íŠ¸ë ˆì‡ì™€ íŠ¸ë ˆì‡ ê°ì²´ì— ëŒ€í•´ ë°°ìš´ê²ƒì„ í™œìš©í•˜ì—¬ ê³ ì „ì ì¸ "
"GUI ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ê³„í•  ê²ƒì…ë‹ˆë‹¤."

#: src/methods-and-traits/exercise.md:6
msgid "We will have a number of widgets in our library:"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” ëª‡ ê°€ì§€ ìœ„ì ¯ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/methods-and-traits/exercise.md:8
msgid "`Window`: has a `title` and contains other widgets."
msgstr ""
"`Window`: `title` ì†ì„±ì„ ê°€ì§€ê³  ìˆìœ¼ë©°, ë‹¤ë¥¸ ìœ„ì ¯ë“¤ì„ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/exercise.md:9
msgid ""
"`Button`: has a `label`. In reality, it would also take a callback function "
"to allow the program to do something when the button is clicked but we won't "
"include that since we're only drawing the GUI."
msgstr ""

#: src/methods-and-traits/exercise.md:12
msgid "`Label`: has a `label`."
msgstr "`Label`: `label` ì†ì„±ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤."

#: src/methods-and-traits/exercise.md:14
msgid "The widgets will implement a `Widget` trait, see below."
msgstr "ìœ„ì ¯ë“¤ì€ ëª¨ë‘ `Widget` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/methods-and-traits/exercise.md:16
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  ëˆ„ë½ëœ `draw_into`ë©”ì„œë“œ"
"ë¥¼ ì±„ì›Œ ë„£ì–´ `Widget` íŠ¸ë ˆì‡ì„ ì™„ì„±í•´ë´…ì‹œë‹¤:"

#: src/methods-and-traits/exercise.md:24 src/methods-and-traits/solution.md:5
#: src/modules/solution.md:36
msgid "/// Natural width of `self`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:27 src/methods-and-traits/solution.md:8
#: src/modules/solution.md:39
msgid "/// Draw the widget into a buffer.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:30 src/methods-and-traits/solution.md:11
#: src/modules/solution.md:42
msgid "/// Draw the widget on standard output.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:34 src/methods-and-traits/solution.md:15
#: src/modules/solution.md:46
msgid "\"{buffer}\""
msgstr ""

#: src/methods-and-traits/exercise.md:79
msgid "// TODO: Implement `Widget` for `Label`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:81
msgid "// TODO: Implement `Widget` for `Button`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:83
msgid "// TODO: Implement `Widget` for `Window`.\n"
msgstr ""

#: src/methods-and-traits/exercise.md:87 src/methods-and-traits/solution.md:117
#: src/modules/solution.md:183
msgid "\"Rust GUI Demo 1.23\""
msgstr ""

#: src/methods-and-traits/exercise.md:88 src/methods-and-traits/solution.md:118
#: src/modules/solution.md:185
msgid "\"This is a small text GUI demo.\""
msgstr ""

#: src/methods-and-traits/exercise.md:89 src/methods-and-traits/solution.md:119
#: src/modules/solution.md:186
msgid "\"Click me!\""
msgstr ""

#: src/methods-and-traits/exercise.md:94
msgid "The output of the above program can be something simple like this:"
msgstr "ìœ„ í”„ë¡œê·¸ë¨ì˜ ì¶œë ¥ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/methods-and-traits/exercise.md:106
msgid ""
"If you want to draw aligned text, you can use the [fill/alignment](https://"
"doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting operators. In "
"particular, notice how you can pad with different characters (here a `'/'`) "
"and how you can control alignment:"
msgstr ""
"í…ìŠ¤íŠ¸ë¥¼ ì¤„ë§ì¶¤ í•´ì„œ ê·¸ë¦¬ë ¤ë©´ [fill/alignment](https://doc.rust-lang.org/std/"
"fmt/index.html#fillalignment)ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. íŠ¹ìˆ˜ ë¬¸ì(ì—¬ê¸°ì„œëŠ” "
"`'/'`)ë¡œ íŒ¨ë”©ì„ ì£¼ëŠ” ë°©ë²•ê³¼ ì •ë ¬ì„ ì œì–´í•˜ëŠ” ë°©ë²•ì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/methods-and-traits/exercise.md:114
msgid "\"left aligned:  |{:/<width$}|\""
msgstr ""

#: src/methods-and-traits/exercise.md:115
msgid "\"centered:      |{:/^width$}|\""
msgstr ""

#: src/methods-and-traits/exercise.md:116
msgid "\"right aligned: |{:/>width$}|\""
msgstr ""

#: src/methods-and-traits/exercise.md:120
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr "ìœ„ì˜ ì •ë ¬ íŠ¸ë¦­ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ ì¶œë ¥ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/methods-and-traits/solution.md:63
msgid "// Add 4 paddings for borders\n"
msgstr ""

#: src/methods-and-traits/solution.md:75 src/modules/solution.md:162
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""

#: src/methods-and-traits/solution.md:78 src/methods-and-traits/solution.md:84
#: src/modules/solution.md:165 src/modules/solution.md:171
msgid "\"+-{:-<inner_width$}-+\""
msgstr ""

#: src/methods-and-traits/solution.md:78 src/methods-and-traits/solution.md:80
#: src/methods-and-traits/solution.md:84 src/methods-and-traits/solution.md:98
#: src/methods-and-traits/solution.md:102 src/modules/solution.md:110
#: src/modules/solution.md:114 src/modules/solution.md:165
#: src/modules/solution.md:167 src/modules/solution.md:171
#: src/testing/unit-tests.md:27 src/testing/solution.md:89
msgid "\"\""
msgstr ""

#: src/methods-and-traits/solution.md:79 src/modules/solution.md:166
msgid "\"| {:^inner_width$} |\""
msgstr ""

#: src/methods-and-traits/solution.md:80 src/modules/solution.md:167
msgid "\"+={:=<inner_width$}=+\""
msgstr ""

#: src/methods-and-traits/solution.md:82 src/modules/solution.md:169
msgid "\"| {:inner_width$} |\""
msgstr ""

#: src/methods-and-traits/solution.md:90 src/modules/solution.md:100
msgid "// add a bit of padding\n"
msgstr ""

#: src/methods-and-traits/solution.md:98 src/methods-and-traits/solution.md:102
#: src/modules/solution.md:110 src/modules/solution.md:114
msgid "\"+{:-<width$}+\""
msgstr ""

#: src/methods-and-traits/solution.md:100 src/modules/solution.md:112
msgid "\"|{:^width$}|\""
msgstr ""

#: src/generics/generic-functions.md:3
#, fuzzy
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì œë„¤ë¦­ì„ ì§€ì›í•©ë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ì•Œê³ ë¦¬ì¦˜(ì •ë ¬ê³¼ ê°™ì€)ì´ë‚˜ ë°ì´í„° "
"êµ¬ì¡°(ì´ì§„ íŠ¸ë¦¬ ê°™ì€)ë¥¼ ì¶”ìƒí™” í•˜ì—¬ íŠ¹ì • íƒ€ì…ì— ì˜ì¡´í•˜ì§€ ì•Šë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/generics/generic-functions.md:7
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr ""

#: src/generics/generic-functions.md:17
msgid "\"picked a number: {:?}\""
msgstr ""

#: src/generics/generic-functions.md:18
msgid "\"picked a tuple: {:?}\""
msgstr ""

#: src/generics/generic-functions.md:18
msgid "\"dog\""
msgstr ""

#: src/generics/generic-functions.md:18
msgid "\"cat\""
msgstr ""

#: src/generics/generic-functions.md:24
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr ""

#: src/generics/generic-functions.md:26
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""

#: src/generics/generic-functions.md:32
#, fuzzy
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"ì´ê²ƒì´ ë°”ë¡œ ë¹„ìš©ì´ ë“¤ì§€ ì•ŠëŠ” (zero-cost) ì¶”ìƒí™” ì…ë‹ˆë‹¤: ëŸ¬ìŠ¤íŠ¸ì˜ ì œë„¤ë¦­ì€ ì¶”"
"ìƒí™”ë¥¼ ê±°ì¹˜ì§€ ì•Šê³  ì§ì ‘ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì¨ì„œ ì½”ë”©í•œ ê²ƒê³¼ ì •í™•íˆ ë™ì¼í•œ ê²°ê³¼"
"ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/generics/generic-data.md:3
msgid "You can use generics to abstract over the concrete field type:"
msgstr "ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ì—¬ í•„ë“œì˜ íƒ€ì…ì„ ì¶”ìƒí™” í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/generics/generic-data.md:17
msgid "// fn set_x(&mut self, x: T)\n"
msgstr ""

#: src/generics/generic-data.md:23
msgid "\"{integer:?} and {float:?}\""
msgstr ""

#: src/generics/generic-data.md:24
msgid "\"coords: {:?}\""
msgstr ""

#: src/generics/generic-data.md:30
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr "_ì§ˆë¬¸:_ `impl<T> Point<T> {}`ì—ì„œ `T`ê°€ ì™œ ë‘ ë²ˆ ì‚¬ìš©ë©ë‹ˆê¹Œ?"

#: src/generics/generic-data.md:32
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"ì œë„¤ë¦­ íƒ€ì…ì— ëŒ€í•œ ì œë„¤ë¦­ êµ¬í˜„ ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ ë‘ ì œë„¤ë¦­ì€ ì„œë¡œ ë…ë¦½ì ì…"
"ë‹ˆë‹¤."

#: src/generics/generic-data.md:34
msgid "It means these methods are defined for any `T`."
msgstr ""
"ì´ëŠ” ì„ì˜ì˜ ëª¨ë“  `T`ì— ëŒ€í•´ì„œ ì´ ë©”ì†Œë“œë“¤ì´ ì •ì˜ëœë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/generics/generic-data.md:35
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "`impl Point<u32> { .. }`ì™€ ê°™ì´ ì‘ì„±í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•©ë‹ˆë‹¤. "

#: src/generics/generic-data.md:36
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point`ëŠ” ì—¬ì „íˆ ì œë„¤ë¦­ì´ë©° `Point<f64>`ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆì§€ë§Œ ì´ ë¸”ë¡ì˜ ë©”ì„œ"
"ë“œëŠ” `Point<u32>`ë§Œ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/generic-data.md:39
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""

#: src/generics/trait-bounds.md:3
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"ì œë„¤ë¦­ì„ ì´ìš©í•˜ë‹¤ ë³´ë©´ íƒ€ì…ì´ ì–´ë–¤ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆì–´ì•¼ í•˜ëŠ” ê²½ìš°ê°€ ìˆìŠµ"
"ë‹ˆë‹¤. ê·¸ë˜ì•¼ ê·¸ íŠ¸ë ˆì‡ì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/generics/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "`T: Trait` í˜¹ì€ `impl Trait`ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤:"

#: src/generics/trait-bounds.md:12
msgid "// struct NotClonable;\n"
msgstr ""

#: src/generics/trait-bounds.md:18
msgid "\"{pair:?}\""
msgstr ""

#: src/generics/trait-bounds.md:24
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr ""

#: src/generics/trait-bounds.md:26
msgid "When multiple traits are necessary, use `+` to join them."
msgstr ""

#: src/generics/trait-bounds.md:28
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""
"`where` ë¬¸ë²•ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ìˆ˜ê°•ìƒë“¤ë„ ì½”ë“œë¥¼ ì½ë‹¤ê°€ ê·¸ ë¬¸ë²•ì„ ë§ˆì£¼"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/trait-bounds.md:39
msgid "It declutters the function signature if you have many parameters."
msgstr ""
"ì´ë¥¼ ì´ìš©í•˜ë©´ íƒ€ì… íŒŒë¼ë©”í„°ê°€ ë§ì€ ê²½ìš° í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•˜ëŠ” ë° "
"ë„ì›€ì´ ë©ë‹ˆë‹¤."

#: src/generics/trait-bounds.md:40
msgid "It has additional features making it more powerful."
msgstr "ì¢€ ë” ê°•ë ¥í•œ ì¶”ê°€ ê¸°ëŠ¥ë„ ì œê³µí•©ë‹ˆë‹¤."

#: src/generics/trait-bounds.md:41
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr "`:` ì™¼ìª½ì— ì„ì˜ì˜ íƒ€ì…(ì˜ˆë¥¼ ë“¤ì–´ `Option<T>`)ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/generics/trait-bounds.md:44
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""

#: src/generics/impl-trait.md:3
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"íŠ¸ë ˆì‡ ë°”ìš´ë“œì™€ ìœ ì‚¬í•˜ê²Œ `impl Trait` ë¬¸ë²•ì€ í•¨ìˆ˜ì˜ ì¸ìì™€ ë°˜í™˜ê°’ì—ë„ ì ìš© ê°€"
"ëŠ¥í•©ë‹ˆë‹¤:"

#: src/generics/impl-trait.md:7
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""

#: src/generics/impl-trait.md:19
msgid "\"{many}\""
msgstr ""

#: src/generics/impl-trait.md:21
msgid "\"{many_more}\""
msgstr ""

#: src/generics/impl-trait.md:23
msgid "\"debuggable: {debuggable:?}\""
msgstr ""

#: src/generics/impl-trait.md:29
#, fuzzy
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr "`impl Trait`ëŠ” ì–´ë””ì— ì‚¬ìš©ë˜ì—ˆëŠëƒì— ë”°ë¼ ì˜ë¯¸ê°€ ì¡°ê¸ˆì”© ë‹¤ë¦…ë‹ˆë‹¤."

#: src/generics/impl-trait.md:32
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"í•¨ìˆ˜ ì¸ìì˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆì„ ê²½ìš°ì—ëŠ” `impl Trait`ëŠ” íŠ¸ë ˆì‡ ê²½ê³„ê°€ ìˆëŠ” ìµ"
"ëª…ì˜ ì œë„¤ë¦­ íƒ€ì…ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/generics/impl-trait.md:35
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"ë¦¬í„´ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆì„ ê²½ìš°ì—ëŠ”, ê·¸ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” êµ¬ì²´ì ì¸ íƒ€ì…ì¸ë°, íƒ€"
"ì… ì´ë¦„ì„ í”„ë¡œê·¸ë˜ë¨¸ê°€ ì§“ì§€ ì•Šì•˜ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ê·¸ êµ¬ì²´ì ì¸ íƒ€ì… "
"ì´ë¦„ì„ APIë¡œ ê³µê°œí•˜ê³  ì‹¶ì§€ ì•Šì€ ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤."

#: src/generics/impl-trait.md:39
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"í•¨ìˆ˜ê°€ ë¦¬í„´ë˜ëŠ” ê³³ì—ì„œì˜ íƒ€ì… ì¶”ë¡ ì€ ì–´ë µìŠµë‹ˆë‹¤. ì–´ë–¤ í•¨ìˆ˜ì˜ ë¦¬í„´ íƒ€ì…ì´ "
"`impl Foo`ë¡œ ì„ ì–¸ë˜ì–´ ìˆì„ ê²½ìš°, ê·¸ í•¨ìˆ˜ê°€ ì‹¤ì œë¡œ ë¦¬í„´í•˜ëŠ” íƒ€ì…ì€ ì†ŒìŠ¤ ì½”ë“œ "
"ìƒ ì–´ë””ì—ë„ ë‚˜íƒ€ë‚˜ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. `collect<B<() -> B`ì™€ ê°™ì´ ì œë„ˆë¦­ íƒ€ì…ì„ ë¦¬"
"í„´í•˜ëŠ” í•¨ìˆ˜ëŠ” `B`ë¥¼ ë§Œì¡±í•˜ëŠ” ì–´ë–¤ íƒ€ì…ë„ ë¦¬í„´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš°, í˜¸ì¶œí•˜"
"ëŠ” ì¸¡ì—ì„œëŠ” `let x: Vec<_> = foo.collect()`ë‚˜ í„°ë³´í”¼ì‹œ ë¬¸ë²•ì„ ì¨ì„œ `foo."
"collect::<Vec<_>>()`ì™€ ê°™ì´ ë¦¬í„´ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì¨ ì£¼ì–´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/generics/impl-trait.md:46
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""

#: src/generics/exercise.md:3
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using a `LessThan` trait."
msgstr ""

#: src/generics/exercise.md:8 src/generics/solution.md:5
msgid "/// Return true if self is less than other.\n"
msgstr ""

#: src/generics/exercise.md:29
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr ""

#: src/generics/exercise.md:33 src/generics/solution.md:36
msgid "\"Shapiro\""
msgstr ""

#: src/generics/exercise.md:34 src/generics/exercise.md:35
#: src/generics/solution.md:37 src/generics/solution.md:38
msgid "\"Baumann\""
msgstr ""

#: src/std-types.md:7
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""

#: src/std-types/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ëŸ¬ìŠ¤íŠ¸ë¡œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ í”„ë¡œê·¸ë¨ì„ ì‘ì„±"
"í•  ë•Œ ê³µí†µì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ íƒ€ì…ë“¤ì„ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì„œ"
"ë¡œ ë‹¤ë¥¸ ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¼ í•˜ë”ë¼ë„ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ”ë° í° ì–´ë ¤ì›€ì´ ì—†ê²Œ ë©ë‹ˆë‹¤. ì˜ˆ"
"ë¥¼ ë“¤ë©´ ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë‘ ê°™ì€ `String` íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/std-types/std.md:7
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr ""
"ì‚¬ì‹¤, ëŸ¬ìŠ¤íŠ¸ì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `core`, `alloc`, `std`ì™€ ê°™ì´ ê³„ì¸µ(layer)ìœ¼"
"ë¡œ ë‚˜ëˆ ì§‘ë‹ˆë‹¤. "

#: src/std-types/std.md:10
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core`ëŠ” `libc`ë‚˜ í• ë‹¹ì(allocator), ì‹¬ì§€ì–´ OSì—ë„ ì˜ì¡´í•˜ì§€ ì•ŠëŠ” ê°€ì¥ ê¸°ë³¸ì "
"ì¸ í•¨ìˆ˜ì™€ íƒ€ì…ì„ í¬í•¨í•©ë‹ˆë‹¤. "

#: src/std-types/std.md:12
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"`alloc`ì€ `Vec`, `Box`, `Arc`ì™€ ê°™ì´ ì „ì—­ í™ í• ë‹¹ì´ í•„ìš”í•œ íƒ€ì…ì„ í¬í•¨í•©ë‹ˆë‹¤."

#: src/std-types/std.md:14
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"ì„ë² ë””ë“œ ëŸ¬ìŠ¤íŠ¸ ì‘ìš©í”„ë¡œê·¸ë¨ì€ ì£¼ë¡œ `core`ë§Œ ì‚¬ìš©í•˜ê±°ë‚˜ ê°€ë” `alloc`ì„ í•¨ê»˜ "
"ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/std-types/docs.md:3
msgid "Rust comes with extensive documentation. For example:"
msgstr ""

#: src/std-types/docs.md:5
#, fuzzy
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"ë£¨í”„ë¥¼ ì¡°ê¸°ì— ì¢…ë£Œí•˜ë ¤ë©´ [`break`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#break-expressions)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤,"

#: src/std-types/docs.md:7
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""

#: src/std-types/docs.md:9
#, fuzzy
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html)ê³¼ [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/std-types/docs.md:13
msgid "In fact, you can document your own code:"
msgstr ""

#: src/std-types/docs.md:16
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""

#: src/std-types/docs.md:27
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"ì½˜í…ì¸ ëŠ” ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤. ê²Œì‹œëœ ëª¨ë“  Rust ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬ë ˆì´íŠ¸ëŠ” "
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) ë„êµ¬ë¥¼ ì‚¬ìš©"
"í•˜ì—¬ [`docs.rs`](https://docs.rs)ì— ìë™ìœ¼ë¡œ ë¬¸ì„œí™”ë©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ APIì˜ "
"ëª¨ë“  ê³µê°œ í•­ëª©ì€ ì´ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì„œí™”ë©ë‹ˆë‹¤."

#: src/std-types/docs.md:32
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""

#: src/std-types/docs.md:36
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr ""

#: src/std-types/docs.md:41
#, fuzzy
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"[`docs.rs/rand`](https://docs.rs/rand)ì—ì„œ `rand` í¬ë ˆì´íŠ¸ìš©ìœ¼ë¡œ ìƒì„±ëœ ë¬¸ì„œ"
"ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#: src/std-types/option.md:1
#, fuzzy
msgid "Option"
msgstr "ì˜ˆì™¸"

#: src/std-types/option.md:3
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""

#: src/std-types/option.md:10
msgid "\"LÃ¶we è€è™ LÃ©opard Gepardi\""
msgstr ""

#: src/std-types/option.md:11
msgid "'Ã©'"
msgstr ""

#: src/std-types/option.md:12 src/std-types/option.md:15
msgid "\"find returned {position:?}\""
msgstr ""

#: src/std-types/option.md:14
msgid "'Z'"
msgstr ""

#: src/std-types/option.md:16
msgid "\"Character not found\""
msgstr ""

#: src/std-types/option.md:22
#, fuzzy
msgid "`Option` is widely used, not just in the standard library."
msgstr ""
"`Option`ê³¼ `Result`ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¿ë§Œì•„ë‹ˆë¼ ë§¤ìš° ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©ë˜ëŠ” íƒ€ì…"
"ì…ë‹ˆë‹¤."

#: src/std-types/option.md:23
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""

#: src/std-types/option.md:25
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr ""

#: src/std-types/option.md:27
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""

#: src/std-types/option.md:29
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr ""

#: src/std-types/result.md:1
msgid "Result"
msgstr ""

#: src/std-types/result.md:3
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different type. This is similar to the `Res` defined "
"in the expression exercise, but generic: `Result<T, E>` where `T` is used in "
"the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""

#: src/std-types/result.md:13
msgid "\"diary.txt\""
msgstr ""

#: src/std-types/result.md:18
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr ""

#: src/std-types/result.md:20
msgid "\"Could not read file content\""
msgstr ""

#: src/std-types/result.md:24
msgid "\"The diary could not be opened: {err}\""
msgstr ""

#: src/std-types/result.md:32
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"`Option`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ, ì„±ê³µí•œ ê²½ìš°ì˜ ê°’ì€ `Result` ë‚´ë¶€ì— ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ, "
"ê°œë°œìëŠ” ëª…ì‹œì ìœ¼ë¡œ ì´ë¥¼ ì¶”ì¶œí•˜ì—¬ì•¼ í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•¨ìœ¼ë¡œì¨ ê°’ì„ ì½ê¸° ì „ì— ì˜¤"
"ë¥˜ ë°œìƒ ì—¬ë¶€ë¥¼ ë°˜ë“œì‹œ ì²´í¬í•˜ë„ë¡ ìœ ë„í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë§Œì¼ ì˜¤ë¥˜ê°€ ì ˆëŒ€ ë°œìƒí•˜"
"ì§€ ì•ŠëŠ” ê²½ìš°ë¼ë©´ `unwrap()`ì´ë‚˜ `expect()`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ê°œë°œìì˜ "
"ì˜ë„(_ì—­ì£¼_: ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ì—†ìŒ)ì„ ëª…ì‹œì ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•ì´ê¸°ë„ í•©ë‹ˆë‹¤."

#: src/std-types/result.md:36
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"ìˆ˜ì—…ì¤‘ì—” ì•„ë‹ˆì§€ë§Œ `Result`ì˜ API ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì½ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤. í•¨ìˆ˜í˜• í”„ë¡œ"
"ê·¸ë˜ë° ìŠ¤íƒ€ì¼ì— ë„ì›€ì´ ë˜ëŠ” í¸ë¦¬í•œ ë©”ì„œë“œì™€ í•¨ìˆ˜ë¥¼ ë§ì´ ë°°ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "

#: src/std-types/result.md:39
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr ""
"`Result`ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ í‘œì¤€ íƒ€ì…ì…ë‹ˆë‹¤. 3ì¼ì°¨ ê³¼ì •ì—ì„œ ì‚´í´ë´…ë‹ˆë‹¤."

#: src/std-types/string.md:1
msgid "String"
msgstr "String"

#: src/std-types/string.md:3
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html)ì€ í™ì— í• "
"ë‹¹ë˜ê³  ê°€ë³€ ê¸¸ì´ì˜ í‘œì¤€ UTF-8 ë¬¸ìì—´ ë²„í¼ì…ë‹ˆë‹¤:"

#: src/std-types/string.md:8 src/std-traits/read-and-write.md:35
#: src/memory-management/review.md:23 src/memory-management/review.md:57
#: src/testing/unit-tests.md:32 src/testing/unit-tests.md:37
#: src/concurrency/scoped-threads.md:9 src/concurrency/scoped-threads.md:26
msgid "\"Hello\""
msgstr ""

#: src/std-types/string.md:9
msgid "\"s1: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/string.md:13
msgid "'!'"
msgstr ""

#: src/std-types/string.md:14
msgid "\"s2: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/string.md:16
msgid "\"ğŸ‡¨ğŸ‡­\""
msgstr ""

#: src/std-types/string.md:17
msgid "\"s3: len = {}, number of chars = {}\""
msgstr ""

#: src/std-types/string.md:21
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String`ì€ [`Deref<Target = str>`](https://doc.rust-lang.org/std/string/"
"struct.String.html#deref-methods-str)ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” , `String` ê°’ì— ëŒ€í•´"
"ì„œë„ `str`ì˜ ëª¨ë“  ë©”ì„œë“œë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ ì…ë‹ˆë‹¤."

#: src/std-types/string.md:29
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"`String::new`ëŠ” ìƒˆë¡œìš´ ë¹ˆ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤. `String::with_capacity`ëŠ” ìƒˆ"
"ë¡œ ë§Œë“¤ ë¬¸ìì—´ ë²„í¼ì— ë„£ì„ ë°ì´í„° í¬ê¸°ë¥¼ ì•Œê³  ìˆëŠ” ê²½ìš°ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/string.md:31
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"`String::len`ì€ `String`ì˜ ë°”ì´íŠ¸ í¬ê¸°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. (ì‹¤ì œ ë¬¸ì ê°œìˆ˜ì™€ëŠ” ë‹¤"
"ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)"

#: src/std-types/string.md:33
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"`String::chars`ëŠ” ì‹¤ì œ ë¬¸ì(character)ë“¤ì— ëŒ€í•œ ì´í„°ë ˆì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. "
"`char`ë¡œ í‘œí˜„ë˜ëŠ” ë¬¸ìëŠ” ìš°ë¦¬ê°€ ì‹¤ì œë¡œ ì¸ì‹í•˜ê³  ì‚¬ìš©í•˜ëŠ” ë¬¸ìì™€ëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆ"
"ìŠµë‹ˆë‹¤. ìì†Œ ê²°í•©ìœ¼ë¡œ ë¬¸ìë¥¼ í‘œí˜„í•˜ëŠ” ê²½ìš°ê°€ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” "
"[Grapheme Cluster](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”."

#: src/std-types/string.md:36
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr "ì‚¬ëŒë“¤ì´ ë¬¸ìì—´ì´ë¼ê³  ë§í•  ë•Œì—ëŠ” `&str`ì´ê±°ë‚˜ `String`ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/string.md:38
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"ì–´ë–¤ íƒ€ì…ì´ `Deref<Target = T>`ë¥¼ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©´, ì»´íŒŒì¼ëŸ¬ëŠ” ì—¬ëŸ¬ë¶„ì´ `T`ì˜ "
"ë©”ì†Œë“œë“¤ì„ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ ë„ì™€ì¤ë‹ˆë‹¤."

#: src/std-types/string.md:40
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr ""

#: src/std-types/string.md:42
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"`String`ì€ `Deref<Target = str>`ì„ êµ¬í˜„í•˜ê³  ìˆê¸° ë•Œë¬¸ì— `String`ì— ëŒ€í•´ì„œë„ "
"`str` ë©”ì†Œë“œë“¤ì„ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/string.md:44
#, fuzzy
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "`let s3 = s1.deref();`ì™€ `let s3 = &*s1;`ì„ ë¹„êµí•´ë³´ì„¸ìš”."

#: src/std-types/string.md:45
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"`String`ì€ ë°”ì´íŠ¸ ë²¡í„°ì˜ ë˜í¼ë¡œ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë²¡í„°ê°€ ì§€ì›í•˜ëŠ” ì—¬ëŸ¬ê°€ì§€ "
"ì—°ì‚°ë“¤ì„ `String`ë„ ì§€ì›í•©ë‹ˆë‹¤. ë‹¤ë§Œ `String`ì€ ëª‡ê°€ì§€ ë³´ì¥ ë‚´ìš©ì´ ë” ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/std-types/string.md:48
msgid "Compare the different ways to index a `String`:"
msgstr "`String`ì„ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•˜ëŠ” ë°©ë²•ë“¤ì„ ë¹„êµí•´ë³´ì„¸ìš”:"

#: src/std-types/string.md:49
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""
"`s3.chars().nth(i).unwrap()`ë¥¼ ì´ìš©í•˜ì—¬ í•œ ë¬¸ìë¥¼ ì„ íƒí•˜ëŠ” ê²½ìš°, `i`ê°’ì´ ë²”ìœ„"
"ë¥¼ ë²—ì–´ë‚  ë•Œ, ë²—ì–´ë‚˜ì§€ ì•Šì„ ë•Œ ë™ì‘ì„ ì„¤ëª…í•˜ì„¸ìš”."

#: src/std-types/string.md:51
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"`s3[0..4]`ë¥¼ ì´ìš©í•´ì„œ ë¬¸ìì—´ì˜ ì¼ë¶€ë¥¼ ì„ íƒí•˜ëŠ”ë°, ìŠ¬ë¼ì´ìŠ¤ê°€ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ "
"ê²½ê³„ì— ë”± ë§ì§€ ì•Šì„ ê²½ìš° ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ì„¤ëª…í•˜ì„¸ìš”."

#: src/std-types/vec.md:3
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) ëŠ” í™ì— í• ë‹¹ëœ í‘œ"
"ì¤€ ê°€ë³€ í¬ê¸° ë²„í¼ì…ë‹ˆë‹¤:"

#: src/std-types/vec.md:9
msgid "\"v1: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/vec.md:14
msgid "\"v2: len = {}, capacity = {}\""
msgstr ""

#: src/std-types/vec.md:16
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr ""

#: src/std-types/vec.md:19
msgid "// Retain only the even elements.\n"
msgstr ""

#: src/std-types/vec.md:21 src/std-types/vec.md:25
msgid "\"{v3:?}\""
msgstr ""

#: src/std-types/vec.md:23
msgid "// Remove consecutive duplicates.\n"
msgstr ""

#: src/std-types/vec.md:29
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec`ì€ [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#deref-methods-%5BT%5D)ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” `Vec`ì—ì„œ ìŠ¬ë¼ì´ìŠ¤ ë©”ì„œë“œë¥¼ í˜¸"
"ì¶œ í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#: src/std-types/vec.md:37
#, fuzzy
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"`Vec`ì€ `String`ì´ë‚˜ `HashMap`ê³¼ ê°™ì€ ì»¬ë ‰ì…˜ íƒ€ì…ì…ë‹ˆë‹¤. ë²¡í„°ëŠ” ë°ì´í„°ë¥¼ í™"
"ì— ì €ì¥í•©ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ ì‹œì ì— ë°ì´í„° í¬ê¸°ë¥¼ ì•Œ í•„ìš”ê°€ ì—†ë‹¤ëŠ” ì˜ë¯¸ê³ , ëŸ°íƒ€"
"ì„ì— ë” ì»¤ì§ˆ ìˆ˜ë„ ì‘ì•„ì§ˆ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/vec.md:40
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"`Vec<T>`ëŠ” ì œë„¤ë¦­ íƒ€ì…ì´ê¸°ë„ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ `T`ë¥¼ ê¼­ ì§€ì •í•´ì¤„ í•„ìš”ëŠ” ì—†ìŠµë‹ˆ"
"ë‹¤. ì´ ê²½ìš°, ëŸ¬ìŠ¤íŠ¸ íƒ€ì… ì¶”ë¡ ì´ ë²¡í„°ì— ì²˜ìŒ `push`í•˜ëŠ” ë°ì´í„°ë¡œ `T`ë¥¼ ì•Œ ìˆ˜ "
"ìˆì—ˆìŠµë‹ˆë‹¤."

#: src/std-types/vec.md:43
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"`vec![...]`ëŠ” `Vec::new()` ëŒ€ì‹  ì“¸ ìˆ˜ ìˆëŠ” í‘œì¤€ ë§¤í¬ë¡œë¡œì„œ, ì´ˆê¸° ë°ì´í„°ë¥¼ ì¶”"
"ê°€í•œ ë²¡í„°ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/vec.md:45
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"ë²¡í„°ëŠ” `[` `]`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜"
"ë©´ íŒ¨ë‹‰ì´ ë°œìƒí•©ë‹ˆë‹¤. ëŒ€ì‹  `get`ì„ ì‚¬ìš©í•˜ë©´ `Option`ì„ ë°˜í™˜í•©ë‹ˆë‹¤. `pop` í•¨ìˆ˜"
"ëŠ” ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ì œê±°í•©ë‹ˆë‹¤."

#: src/std-types/vec.md:48
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""

#: src/std-types/hashmap.md:3
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "HashDoS ê³µê²©ìœ¼ë¡œë¶€í„° ë³´í˜¸ë˜ëŠ” í‘œì¤€ í•´ì‹œ ë§µì…ë‹ˆë‹¤:"

#: src/std-types/hashmap.md:10
msgid "\"Adventures of Huckleberry Finn\""
msgstr ""

#: src/std-types/hashmap.md:11
msgid "\"Grimms' Fairy Tales\""
msgstr ""

#: src/std-types/hashmap.md:12 src/std-types/hashmap.md:21
#: src/std-types/hashmap.md:29
msgid "\"Pride and Prejudice\""
msgstr ""

#: src/std-types/hashmap.md:14
msgid "\"Les MisÃ©rables\""
msgstr ""

#: src/std-types/hashmap.md:16
msgid "\"We know about {} books, but not Les MisÃ©rables.\""
msgstr ""

#: src/std-types/hashmap.md:21 src/std-types/hashmap.md:29
msgid "\"Alice's Adventure in Wonderland\""
msgstr ""

#: src/std-types/hashmap.md:23
msgid "\"{book}: {count} pages\""
msgstr ""

#: src/std-types/hashmap.md:24
msgid "\"{book} is unknown.\""
msgstr ""

#: src/std-types/hashmap.md:28
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr ""

#: src/std-types/hashmap.md:34
msgid "\"{page_counts:#?}\""
msgstr ""

#: src/std-types/hashmap.md:40
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""
"`HashMap`ì€ preludeì— ì •ì˜ë˜ì–´ ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€í•´ì¤˜ì•¼ í•©ë‹ˆë‹¤."

#: src/std-types/hashmap.md:41
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”. ì²« ë¬¸ì¥ì—ì„œëŠ” í•´ì‹œë§µì— ì±…ì´ ìˆëŠ”ì§€ ê²€ì‚¬í•˜ì—¬, ì—†ìœ¼"
"ë©´ ë””í´íŠ¸ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ë‘ë²ˆ ì§¸ ë¬¸ì¥ì—ì„œëŠ” í•´ì‹œë§µì— í•´ë‹¹ ì±…ì´ ì—†ëŠ” ê²½ìš°, "
"ì§€ì •í•œ ê°’ì„ í•´ì‹œë§µì— ì¶”ê°€í•œ ë’¤ ê·¸ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/std-types/hashmap.md:47 src/std-types/hashmap.md:59
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr ""

#: src/std-types/hashmap.md:50 src/std-types/hashmap.md:60
msgid "\"The Hunger Games\""
msgstr ""

#: src/std-types/hashmap.md:53
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr "ì•ˆíƒ€ê¹ì§€ë§Œ `hashmap!`ê°™ì€ ë§¤í¬ë¡œê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/std-types/hashmap.md:54
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ 1.56ë¶€í„°ëŠ” `HashMap`ì´ [`From<[(K, V); N]>`](https://doc.rust-lang."
"org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);"
"+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E)ì„ êµ¬í˜„í•˜ê¸° ë•Œë¬¸ì— ë°°ì—´ ë¦¬í„°ëŸ´ì„ "
"ì´ìš©í•˜ì—¬ ì‰½ê²Œ í•´ì‹œë§µì„ ì´ˆê¸°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/std-types/hashmap.md:64
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr "í‚¤-ê°’ ìŒì— ëŒ€í•œ `Iterator`ë¡œ í•´ì‹œë§µì„ ë§Œë“¤ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/hashmap.md:66
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"ì˜ˆì œ ì½”ë“œì—ì„œëŠ” í¸ì˜ìƒ í•´ì‹œë§µì˜ í‚¤ë¡œ `&str`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¬¼ë¡  ì»¬ë ‰"
"ì…˜ì— ì°¸ì¡°ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë‹¤ë§Œ ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ë¹Œë¦¼ ê²€ì‚¬ê¸° ë•Œë¬¸"
"ì— ë³µì¡í•´ ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-types/hashmap.md:69
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"ì˜ˆì œ ì½”ë“œì—ì„œ `to_string()`ì„ ì—†ì• ë„ ì»´íŒŒì¼ì— ë¬¸ì œê°€ ì—†ëŠ”ì§€ í™•ì¸í•´ë³´ì„¸ìš”. ì–´"
"ë–¤ ë¬¸ì œì— ë¶€ë”ªíê¹Œìš”?"

#: src/std-types/hashmap.md:72
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"í•´ì‹œë§µì˜ ëª‡ ëª‡ ë©”ì„œë“œëŠ” í•´ì‹œë§µ ë‚´ë¶€ì˜ íŠ¹ë³„í•œ íƒ€ì…(ì˜ˆë¥¼ ë“¤ì–´ `std::"
"collections::hash_map::Keys`)ë“¤ì„ ë¦¬í„´í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ íƒ€ì…ë“¤ì€ Rust ë¬¸ì„œì—ì„œ"
"ë„ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìˆ˜ê°•ìƒë“¤ì—ê²Œ ì´ íƒ€ì…ë“¤ì— ëŒ€í•œ ë¬¸ì„œë¥¼ ë³´ì—¬ì£¼ê³ , ì´ ë¬¸ì„œ"
"ì— `keys` ë©”ì„œë“œë¡œì˜ ì—­ ë§í¬ê°€ ìˆìŒì„ ì•Œë ¤ì£¼ì„¸ìš”."

#: src/std-types/exercise.md:3
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""

#: src/std-types/exercise.md:9
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""

#: src/std-types/exercise.md:13
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""

#: src/std-types/exercise.md:20 src/std-types/solution.md:6
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr ""

#: src/std-types/exercise.md:27 src/std-types/solution.md:13
msgid "/// Create a new Counter.\n"
msgstr ""

#: src/std-types/exercise.md:34 src/std-types/solution.md:18
msgid "/// Count an occurrence of the given value.\n"
msgstr ""

#: src/std-types/exercise.md:43 src/std-types/solution.md:23
msgid "/// Return the number of times the given value has been seen.\n"
msgstr ""

#: src/std-types/exercise.md:59 src/std-types/solution.md:39
msgid "\"saw {} values equal to {}\""
msgstr ""

#: src/std-types/exercise.md:63 src/std-types/exercise.md:65
#: src/std-types/exercise.md:66 src/std-types/solution.md:43
#: src/std-types/solution.md:45 src/std-types/solution.md:46
msgid "\"apple\""
msgstr ""

#: src/std-types/exercise.md:64 src/std-types/solution.md:44
msgid "\"orange\""
msgstr ""

#: src/std-types/exercise.md:66 src/std-types/solution.md:46
msgid "\"got {} apples\""
msgstr ""

#: src/std-traits.md:7
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr ""

#: src/std-traits.md:10
msgid "This section is long. Take a break midway through."
msgstr ""

#: src/std-traits/comparisons.md:3
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""

#: src/std-traits/comparisons.md:6
msgid "`PartialEq` and `Eq`"
msgstr ""

#: src/std-traits/comparisons.md:8
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""

#: src/std-traits/comparisons.md:23
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""

#: src/std-traits/comparisons.md:27
#, fuzzy
msgid "`PartialOrd` and `Ord`"
msgstr "`Read`ì™€ `Write`"

#: src/std-traits/comparisons.md:29
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""

#: src/std-traits/comparisons.md:49
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr ""

#: src/std-traits/comparisons.md:53
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr ""

#: src/std-traits/comparisons.md:68
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr ""

#: src/std-traits/operators.md:3
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr "ì—°ì‚°ì ì˜¤ë²„ë¡œë“œëŠ” `std::ops`ì— ìˆëŠ” ë‹¤ì–‘í•œ íŠ¸ë ˆì‡ë“¤ì„ í†µí•´ êµ¬í˜„ë©ë‹ˆë‹¤:"

#: src/std-traits/operators.md:23
msgid "\"{:?} + {:?} = {:?}\""
msgstr ""

#: src/std-traits/operators.md:29 src/memory-management/drop.md:47
msgid "Discussion points:"
msgstr "ë…¼ì˜ì :"

#: src/std-traits/operators.md:31
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr ""
"`&Point`ê°€ `Add`ë¥¼ êµ¬í˜„í•˜ë„ë¡ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ê²Œ ì–´ë–¤ ê²½ìš°ì— ìœ ìš©í• ê¹Œìš”? "

#: src/std-traits/operators.md:32
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"ë‹µ: `Add:add`ëŠ” `self`ë¥¼ ì†Œëª¨í•©ë‹ˆë‹¤. ë§Œì•½ íƒ€ì… `T`ê°€ `Copy`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  "
"ìˆì§€ ì•Šë‹¤ë©´ `&T`ì— ëŒ€í•´ì„œë„ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ í˜¸"
"ì¶œë¶€ì—ì„œ ë¶ˆí•„ìš”í•œ ë³µì‚¬ë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-traits/operators.md:35
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr "ì™œ `Output`ì´ ì—°ê´€ëœ íƒ€ì…ì¸ê°€ìš”? íƒ€ì… íŒŒë¼ë©”í„°ë¡œ ë§Œë“¤ ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/std-traits/operators.md:37
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"ë‹µ: íƒ€ì… íŒŒë¼ë©”í„°ë¥¼ í˜¸ì¶œí•˜ëŠ” ìª½ì—ì„œ ê²°ì •í•©ë‹ˆë‹¤. ë°˜ë©´ ì—°ê´€ëœ íƒ€ì…(`Output`ê°™"
"ì€) ì€ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ìª½ì—ì„œ ì œì–´ ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/std-traits/operators.md:40
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"`Add`ë¥¼ ì´ìš©í•´ì„œ ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ íƒ€ì…ì„ ë”í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ "
"`impl Add<(i32, i32)> for Point`ëŠ” íŠœí”Œì„ `Point`ì— ë”í•  ìˆ˜ ìˆê²Œ í•´ ì¤ë‹ˆë‹¤."

#: src/std-traits/from-and-into.md:3
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"íƒ€ì…ì€ ìš©ì´í•œ í˜•ë³€í™˜ì„ ìœ„í•´ [`From`](https://doc.rust-lang.org/std/convert/"
"trait.From.html)ê³¼ [`Into`](https://doc.rust-lang.org/std/convert/trait.Into."
"html)ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤:"

#: src/std-traits/from-and-into.md:11 src/std-traits/from-and-into.md:23
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr ""

#: src/std-traits/from-and-into.md:15
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html)ì´ êµ¬í˜„ë˜ë©´ "
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) ì—­ì‹œ ìë™ìœ¼"
"ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤:"

#: src/std-traits/from-and-into.md:29
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr ""
"ê·¸ë ‡ê¸° ë•Œë¬¸ì— ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì˜ ê²½ìš°ì—ë„ `From` ë§Œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆ"
"ë‹¤."

#: src/std-traits/from-and-into.md:31
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"\"`String`ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²ƒ\"ê³¼ ê°™ì€ í•¨ìˆ˜ì˜ ì¸ìˆ˜ íƒ€ì…ì„ ì„ ì–¸í•  ë•Œì—"
"ëŠ” `Into`ë¥¼ ì‚¬ìš©í•´ì•¼ í•¨ì„ ì¡°ì‹¬í•˜ì„¸ìš”. ê·¸ë˜ì•¼ë§Œ, í•¨ìˆ˜ëŠ” `From`ì„ êµ¬í˜„í•œ íƒ€ì…"
"ê³¼ `Into` _ë§Œ_ êµ¬í˜„í•œ íƒ€ì… ëª¨ë‘ë¥¼ ì¸ìë¡œ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-traits/casting.md:3
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""

#: src/std-traits/casting.md:9
msgid "\"as u16: {}\""
msgstr ""

#: src/std-traits/casting.md:10
msgid "\"as i16: {}\""
msgstr ""

#: src/std-traits/casting.md:11
msgid "\"as u8: {}\""
msgstr ""

#: src/std-traits/casting.md:15
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""

#: src/std-traits/casting.md:19
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""

#: src/std-traits/casting.md:25
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""

#: src/std-traits/casting.md:32
msgid "Consider taking a break after this slide."
msgstr ""

#: src/std-traits/casting.md:34
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""

#: src/std-traits/casting.md:37
msgid "This is common in casting integers to `usize` for use as an index."
msgstr ""

#: src/std-traits/read-and-write.md:3
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html)ì™€ [`BufRead`]"
"(https://doc.rust-lang.org/std/io/trait.BufRead.html)ë¥¼ ì‚¬ìš©í•˜ë©´ `u8` íƒ€ì…ì˜ "
"ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/std-traits/read-and-write.md:14
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr ""

#: src/std-traits/read-and-write.md:15
msgid "\"lines in slice: {}\""
msgstr ""

#: src/std-traits/read-and-write.md:18
msgid "\"lines in file: {}\""
msgstr ""

#: src/std-traits/read-and-write.md:23
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr "ì´ì™€ ë¹„ìŠ·í•˜ê²Œ, `Write`ë¥¼ ì‚¬ì˜¹í•˜ë©´ `u8` íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/std-traits/read-and-write.md:30
msgid "\"\\n\""
msgstr ""

#: src/std-traits/read-and-write.md:36 src/slices-and-lifetimes/str.md:12
msgid "\"World\""
msgstr ""

#: src/std-traits/read-and-write.md:37
msgid "\"Logged: {:?}\""
msgstr ""

#: src/std-traits/default.md:1
msgid "The `Default` Trait"
msgstr "`Default` íŠ¸ë ˆì‡"

#: src/std-traits/default.md:3
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) íŠ¸ë ˆì‡"
"ì€ ì–´ë–¤ íƒ€ì…ì— ëŒ€í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/std-traits/default.md:18
msgid "\"John Smith\""
msgstr ""

#: src/std-traits/default.md:24
msgid "\"{default_struct:#?}\""
msgstr ""

#: src/std-traits/default.md:27
msgid "\"Y is set!\""
msgstr ""

#: src/std-traits/default.md:28
msgid "\"{almost_default_struct:#?}\""
msgstr ""

#: src/std-traits/default.md:31 src/slices-and-lifetimes/exercise.md:211
#: src/slices-and-lifetimes/solution.md:214
msgid "\"{:#?}\""
msgstr ""

#: src/std-traits/default.md:37
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""
"íŠ¸ë ˆì‡ì„ ì§ì ‘ êµ¬í˜„í•˜ê±°ë‚˜ `#[derive(Default)]`ë¥¼ ë¶™ì—¬ì„œ ì»´íŒŒì¼ëŸ¬ì—ê²Œ êµ¬í˜„ì„ ë§¡"
"ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-traits/default.md:38
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""
"ì»´íŒŒì¼ëŸ¬ê°€ ì œê³µí•˜ëŠ” ìë™ êµ¬í˜„ì˜ ê²½ìš° ëª¨ë“  í•„ë“œì— ëŒ€í•´ ê¸°ë³¸ ê°’ì„ ì„¤ì •í•œ ìƒˆ ì¸"
"ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/std-traits/default.md:40
msgid "This means all types in the struct must implement `Default` too."
msgstr ""
"ì´ëŠ” êµ¬ì¡°ì²´ì˜ ê° í•„ë“œ íƒ€ì…ë“¤ì´ ëª¨ë‘ `Default` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆ"
"ë‹¤."

#: src/std-traits/default.md:41
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ íƒ€ì…ë“¤ì€ ëŒ€ë¶€ë¶„ `Default`ë¥¼ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©°, ê¸°ë³¸ ê°’ì€ `0`ì´ë‚˜ "
"`\"\"`ì²˜ëŸ¼ ì˜ˆìƒ ê°€ëŠ¥í•œ ê°’ë“¤ì…ë‹ˆë‹¤."

#: src/std-traits/default.md:43
#, fuzzy
msgid "The partial struct initialization works nicely with default."
msgstr ""
"êµ¬ì¡°ì²´ì˜ ì¼ë¶€ë¶„ë§Œ ë³µì‚¬í•˜ê³  ì‹¶ì„ ë•Œ `default`ë¥¼ í¸ë¦¬í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-traits/default.md:44
#, fuzzy
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `Default` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•œ íƒ€ì…ì„ ìœ„í•œ í¸ì˜ ë©”ì„œë“œë¥¼ "
"ì œê³µí•˜ê¸°ë„ í•©ë‹ˆë‹¤."

#: src/std-traits/default.md:46
#, fuzzy
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"ì´ `..` ë¬¸ë²•ì€ [êµ¬ì¡°ì²´ ì—…ë°ì´íŠ¸ ë¬¸ë²•(struct update syntax)](https://doc.rust-"
"lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-"
"instances-with-struct-update-syntax)ë¼ê³  í•©ë‹ˆë‹¤"

#: src/std-traits/closures.md:3
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"í´ë¡œì € í˜¹ì€ ëŒë‹¤í‘œí˜„ì‹ì€ ìµëª…íƒ€ì…ì…ë‹ˆë‹¤. ì´ë“¤ì€ [`Fn`](https://doc.rust-lang."
"org/std/ops/trait.Fn.html),[`FnMut`](https://doc.rust-lang.org/std/ops/trait."
"FnMut.html), [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) "
"ë¼ëŠ” íŠ¹ë³„í•œ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤:"

#: src/std-traits/closures.md:10
#, fuzzy
msgid "\"Calling function on {input}\""
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ í˜¸ì¶œ"

#: src/std-traits/closures.md:16 src/std-traits/closures.md:17
msgid "\"add_3: {}\""
msgstr ""

#: src/std-traits/closures.md:24 src/std-traits/closures.md:25
msgid "\"accumulate: {}\""
msgstr ""

#: src/std-traits/closures.md:28
msgid "\"multiply_sum: {}\""
msgstr ""

#: src/std-traits/closures.md:34
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"`Fn`(ì˜ˆë¥¼ ë“¤ì–´ `add_3`)ì€ ìº¡ì²˜ëœ ê°’ì„ ì†Œëª¨ë„ ë³€ê²½ë„ í•˜ì§€ ì•Šê³ , í˜¹ì€ ì–´ë–¤ ê²ƒ"
"ë„ ìº¡ì³í•˜ì§€ ì•Šì•˜ì„ ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì— ë™ì‹œì— ì—¬ëŸ¬ë²ˆ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-traits/closures.md:37
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"`FnMut`(ì˜ˆë¥¼ ë“¤ì–´ `accumulate`)ëŠ” ìº¡ì²˜ëœ ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œ"
"ì€ ê°€ëŠ¥í•˜ì§€ë§Œ ë™ì‹œì— í˜¸ì¶œ í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤."

#: src/std-traits/closures.md:40
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"`FnOnce` (ì˜ˆë¥¼ ë“¤ì–´ `multiply_sum`)ëŠ” í•œë²ˆë§Œ í˜¸ì¶œë˜ë©° ìº¡ì²˜ëœ ê°’ì„ ì†Œëª¨í•©ë‹ˆë‹¤."

#: src/std-traits/closures.md:43
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` ëŠ” `FnOnce`ì˜ í•˜ìœ„íƒ€ì…ì…ë‹ˆë‹¤. `Fn`ì€ `FnMut`ê³¼ `FnOnce`ì˜ í•˜ìœ„ íƒ€ì…ì…"
"ë‹ˆë‹¤. ì¦‰, `FnMut`ëŠ” `FnOnce`ê°€ í˜¸ì¶œë˜ëŠ” ê³³ì´ë©´ ì–´ë””ì„œë‚˜ ì‚¬ìš© í•  ìˆ˜ ìˆê³  `Fn`"
"ì€ `FnMut`ì™€ `FnOnce`ê°€ í˜¸ì¶œë˜ëŠ” ê³³ì´ë©´ ì–´ë””ë“  ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/std-traits/closures.md:47
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""

#: src/std-traits/closures.md:51
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(it can be passed everywhere), then `FnMut`, and lastly `FnOnce`."
msgstr ""

#: src/std-traits/closures.md:54
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"ì»´íŒŒì¼ëŸ¬ëŠ” í´ë¡œì €ê°€ ë¬´ì—‡ì„ ìº¡ì³í•˜ëŠ”ì§€ì— ë”°ë¼ `Copy`(ì˜ˆë¥¼ ë“¤ì–´ `add_3`)ê³¼ "
"`Clone`(ì˜ˆë¥¼ ë“¤ì–´ `multiply_sum`)ì„ ì•Œì•„ì„œ ì¶”ë¡ í•©ë‹ˆë‹¤."

#: src/std-traits/closures.md:57
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"ê¸°ë³¸ì ìœ¼ë¡œ í´ë¡œì ¸ëŠ”, ê°€ëŠ¥í•˜ë‹¤ë©´, ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ì—¬ ìº¡ì³ë¥¼ í•©ë‹ˆë‹¤. `move` í‚¤ì›Œë“œ"
"ë¥¼ ì“°ë©´ ê°’ìœ¼ë¡œ ìº¡ì³ê°€ ë©ë‹ˆë‹¤."

#: src/std-traits/closures.md:66
msgid "\"Hi\""
msgstr ""

#: src/std-traits/closures.md:67
msgid "\"there\""
msgstr ""

#: src/std-traits/exercise.md:3
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""

#: src/std-traits/exercise.md:15
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr ""

#: src/std-traits/exercise.md:20 src/std-traits/exercise.md:33
#: src/std-traits/solution.md:26 src/std-traits/solution.md:39
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr ""

#: src/std-traits/exercise.md:36 src/std-traits/solution.md:42
msgid "\"To get to the other side!\""
msgstr ""

#: src/std-traits/exercise.md:55
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""

#: src/std-traits/solution.md:16
msgid "'A'"
msgstr ""

#: src/welcome-day-3.md:1
msgid "Welcome to Day 3"
msgstr "3ì¼ì°¨ ê°œìš”"

#: src/welcome-day-3.md:3
msgid "Today, we will cover:"
msgstr ""

#: src/welcome-day-3.md:5
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr ""

#: src/welcome-day-3.md:7
msgid "Smart pointers: standard library pointer types."
msgstr ""

#: src/memory-management/review.md:3
msgid "Programs allocate memory in two ways:"
msgstr ""

#: src/memory-management/review.md:5
msgid "Stack: Continuous area of memory for local variables."
msgstr "ìŠ¤íƒ: ë¡œì»¬ ë³€ìˆ˜ë¥¼ ìœ„í•œ ì—°ì†ì ì¸ ë©”ëª¨ë¦¬ ì˜ì—­."

#: src/memory-management/review.md:6
msgid "Values have fixed sizes known at compile time."
msgstr "ì—¬ê¸° ì €ì¥ë˜ëŠ” ê°’ì€ ì»´íŒŒì¼ ì‹œ ê²°ì •ë˜ëŠ” ê³ ì • í¬ê¸°ë¥¼ ê°–ìŠµë‹ˆë‹¤."

#: src/memory-management/review.md:7
msgid "Extremely fast: just move a stack pointer."
msgstr ""
"ë§¤ìš° ë¹ ë¦„: ë©”ëª¨ë¦¬ í• ë‹¹/ë°˜í™˜ì´ ë‹¨ì§€ ìŠ¤íƒ í¬ì¸í„°ì˜ ì´ë™ë§Œìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤."

#: src/memory-management/review.md:8
msgid "Easy to manage: follows function calls."
msgstr "ê´€ë¦¬ê°€ ì‰¬ì›€: í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´ í• ë‹¹ë˜ê³ , ë¦¬í„´í•˜ë©´ ë°˜í™˜ë©ë‹ˆë‹¤."

#: src/memory-management/review.md:9
msgid "Great memory locality."
msgstr "ìŠ¤íƒì— ìˆëŠ” ê°’ë“¤ì€ ë§¤ìš° ë†’ì€ ë©”ëª¨ë¦¬ ì¸ì ‘ì„±ì„ ê°€ì§‘ë‹ˆë‹¤."

#: src/memory-management/review.md:11
msgid "Heap: Storage of values outside of function calls."
msgstr "í™: í•¨ìˆ˜ í˜¸ì¶œ/ë¦¬í„´ê³¼ ìƒê´€ ì—†ì´ ìœ ì§€ë˜ëŠ” ê°’ì´ ì €ì¥ë˜ëŠ” ê³³."

#: src/memory-management/review.md:12
msgid "Values have dynamic sizes determined at runtime."
msgstr "ì—¬ê¸° ì €ì¥ë˜ëŠ” ê°’ì€ í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì‹œ ê·¸ í¬ê¸°ê°€ ê²°ì •ë©ë‹ˆë‹¤."

#: src/memory-management/review.md:13
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "ìŠ¤íƒ ë³´ë‹¤ëŠ” ëŠë¦¼: ë©”ëª¨ë¦¬ í• ë‹¹/ë°˜í™˜ì‹œ í•´ì•¼ í•  ì¼ì´ ì¢€ ë” ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/review.md:14
msgid "No guarantee of memory locality."
msgstr "ë©”ëª¨ë¦¬ ì¸ì ‘ì„±ì„ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/memory-management/review.md:18
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"`String`ì„ í•˜ë‚˜ ë§Œë“¤ê²Œ ë˜ë©´, ìŠ¤íƒì—ëŠ” ê³ ì •ëœ í¬ê¸°ì˜ ë©”íƒ€ ë°ì´í„°ê°€ ìƒì„±ë˜ê³ , "
"í™ì—ëŠ” ê°€ë³€ í¬ê¸°ì˜ ë°ì´í„°, ì¦‰, ì‹¤ì œ ë¬¸ìì—´, ì´ ìƒì„±ë©ë‹ˆë‹¤:"

#: src/memory-management/review.md:43
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"ë¬¸ìì—´(`String`)ì€ ì‹¤ì œë¡œëŠ” `Vec`ì…ë‹ˆë‹¤. í¬ê¸°(capacity)ì™€ í˜„ì¬ ê¸¸ì´(length) "
"ì •ë³´ë¥¼ ê°€ì§€ë©°, ë” í° í¬ê¸°ê°€ í•„ìš”í•  ê²½ìš° í™ì—ì„œ ì¬ í• ë‹¹ì„ í•©ë‹ˆë‹¤."

#: src/memory-management/review.md:46
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"í™ì€ ê¸°ë³¸ì ìœ¼ë¡œ [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html)ë¥¼ í†µí•´ í• ë‹¹ë©ë‹ˆë‹¤. ê·¸ë¦¬ê³  [Allocator API](https://doc."
"rust-lang.org/std/alloc/index.html)ë¥¼ ì´ìš©í•´ì„œ ì»¤ìŠ¤í…€ ë©”ëª¨ë¦¬ í• ë‹¹ìë¥¼ ë§Œë“¤ ìˆ˜"
"ë„ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/review.md:52
#, fuzzy
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"ì•„ë˜ì™€ ê°™ì€ `unsafe` ì½”ë“œë¡œ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬¼ë¡  ì´ ì½”"
"ë“œê°€ ì•ˆì „í•˜ì§€ ì•Šë‹¤ëŠ” ì ì„ ì•Œë ¤ì£¼ì„¸ìš”!"

#: src/memory-management/review.md:58 src/testing/unit-tests.md:15
msgid "' '"
msgstr ""

#: src/memory-management/review.md:59
msgid "\"world\""
msgstr ""

#: src/memory-management/review.md:60
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""

#: src/memory-management/review.md:65
msgid "\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\""
msgstr ""

#: src/memory-management/approaches.md:3
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "ì „í†µì ìœ¼ë¡œ, ë‘ ì¢…ë¥˜ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/memory-management/approaches.md:5
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr ""
"ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ í”„ë¡œê·¸ë˜ë¨¸ì˜ ì™„ì „í•œ í†µì œí•˜ì— ìˆì§€ë§Œ ìˆ˜ë™(ê·¸ë˜ì„œ ì•ˆì „í•˜ì§€ ì•Šì„ "
"ìˆ˜ ìˆëŠ”)ì¸ ì–¸ì–´: C, C++, Pascal, ..."

#: src/memory-management/approaches.md:6
msgid "Programmer decides when to allocate or free heap memory."
msgstr ""

#: src/memory-management/approaches.md:7
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr ""

#: src/memory-management/approaches.md:8
msgid "Studies show, programmers make mistakes."
msgstr ""

#: src/memory-management/approaches.md:9
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ëŸ°íƒ€ì„ì— ì˜í•´ ë˜ë¯€ë¡œ ì•ˆì „í•˜ì§€ë§Œ ìë™(ê·¸ë˜ì„œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ê°œì…"
"í•  ì—¬ì§€ê°€ ì ê±°ë‚˜ ì—†ëŠ”)ì¸ ì–¸ì–´: Java, Python, Go, Haskell, ..."

#: src/memory-management/approaches.md:11
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr ""

#: src/memory-management/approaches.md:13
msgid ""
"Typically implemented with reference counting, garbage collection, or RAII."
msgstr ""

#: src/memory-management/approaches.md:15
msgid "Rust offers a new mix:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ ë‘˜ì„ í˜¼í•©í•œ ìƒˆë¡œìš´ í˜•íƒœì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ë²•ì„ ì œê³µí•©ë‹ˆë‹¤:"

#: src/memory-management/approaches.md:17
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"ì»´íŒŒì¼ ì‹œ ì˜¬ë°”ë¥¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ê°•ì œí•¨ìœ¼ë¡œì¨ ì™„ì „í•œ í†µì œì™€ ì•ˆì „ì„± _ëª¨ë‘_ ì œê³µ."

#: src/memory-management/approaches.md:20
msgid "It does this with an explicit ownership concept."
msgstr "ì´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ì»¨ì…‰ì€ ëª…ì‹œì ì¸ ì†Œìœ ê¶Œì…ë‹ˆë‹¤."

#: src/memory-management/approaches.md:24
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr ""

#: src/memory-management/approaches.md:27
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""

#: src/memory-management/approaches.md:31
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""

#: src/memory-management/approaches.md:36
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""

#: src/memory-management/approaches.md:41
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""

#: src/memory-management/ownership.md:3
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"ëª¨ë“  ë³€ìˆ˜ ë°”ì¸ë”©ì€ ìœ íš¨í•œ \"ë²”ìœ„(ìŠ¤ì½”í”„)\"ë¥¼ ê°€ì§€ë©°, ë²”ìœ„ ë°–ì—ì„œ ë³€ìˆ˜ ì‚¬ìš©í•˜"
"ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/memory-management/ownership.md:20
#, fuzzy
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr "ì´ê²ƒì„ ë‘ê³  ë³€ìˆ˜ê°€ ê°’ì„ \"ì†Œìœ \"í•œë‹¤ê³  í‘œí˜„í•©ë‹ˆë‹¤."

#: src/memory-management/ownership.md:23
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr ""
"ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ë³€ìˆ˜ëŠ” \"ì‚­ì œ(drop)\"ë˜ì—ˆë‹¤ê³  í•˜ë©° ê·¸ ë³€ìˆ˜ì˜ ë°ì´í„°ëŠ” ë©”ëª¨"
"ë¦¬ì—ì„œ í•´ì œë©ë‹ˆë‹¤."

#: src/memory-management/ownership.md:28
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""

#: src/memory-management/move.md:3
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "(ë³€ìˆ˜ì˜) í• ë‹¹ì€ \\_ì†Œìœ ê¶Œ_ì„ ë³€ìˆ˜ ê°„ì— ì´ë™ì‹œí‚µë‹ˆë‹¤:"

#: src/memory-management/move.md:7
#, fuzzy
msgid "\"Hello!\""
msgstr "Hello World!"

#: src/memory-management/move.md:9 src/slices-and-lifetimes/str.md:16
#: src/slices-and-lifetimes/str.md:18
msgid "\"s2: {s2}\""
msgstr ""

#: src/memory-management/move.md:10
msgid "// println!(\"s1: {s1}\");\n"
msgstr ""

#: src/memory-management/move.md:14
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "`s1`ì„ `s2`ì— í• ë‹¹í•˜ì—¬ ì†Œìœ ê¶Œì„ ì´ì „ì‹œí‚µë‹ˆë‹¤."

#: src/memory-management/move.md:15
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"`s1`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ì•„ë¬´ ì¼ë„ ì—†ìŠµë‹ˆë‹¤: ì™œëƒí•˜ë©´ `s1`ì€ ì•„ë¬´ëŸ° ì†Œìœ ê¶Œì´ "
"ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/memory-management/move.md:16
msgid "When `s2` goes out of scope, the string data is freed."
msgstr "`s2`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ë¬¸ìì—´ ë°ì´í„°ëŠ” í•´ì œë©ë‹ˆë‹¤."

#: src/memory-management/move.md:18
msgid "Before move to `s2`:"
msgstr "`s2`ë¡œ ì´ë™ ì „ ë©”ëª¨ë¦¬:"

#: src/memory-management/move.md:35
msgid "After move to `s2`:"
msgstr "`s2`ë¡œ ì´ë™ í›„ ë©”ëª¨ë¦¬:"

#: src/memory-management/move.md:37
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/memory-management/move.md:58
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"ê°’ì„ í•¨ìˆ˜ì— ì „ë‹¬í• ë•Œ, ê·¸ ê°’ì€ ë§¤ê°œë³€ìˆ˜ì— í• ë‹¹ë©ë‹ˆë‹¤. ì´ë•Œ ì†Œìœ ê¶Œì˜ ì´ë™ì´ ì¼"
"ì–´ë‚©ë‹ˆë‹¤:"

#: src/memory-management/move.md:63
msgid "\"Hello {name}\""
msgstr ""

#: src/memory-management/move.md:67 src/android/interoperability/java.md:57
#, fuzzy
msgid "\"Alice\""
msgstr "ìŠ¬ë¼ì´ìŠ¤"

#: src/memory-management/move.md:69
msgid "// say_hello(name);\n"
msgstr ""

#: src/memory-management/move.md:75
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"ì´ëŠ” C++ê³¼ ì •ë°˜ëŒ€ ì„ì„ ì„¤ëª…í•˜ì„¸ìš”. C++ì—ì„œëŠ” ë³µì‚¬ê°€ ê¸°ë³¸ì´ê³ , `std::move` ë¥¼ "
"ì´ìš©í•´ì•¼ë§Œ (ê·¸ë¦¬ê³  ì´ë™ ìƒì„±ìê°€ ì •ì˜ë˜ì–´ ìˆì–´ì•¼ë§Œ!) ì†Œìœ ê¶Œ ì´ì „ì´ ë©ë‹ˆë‹¤."

#: src/memory-management/move.md:78
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"ì‹¤ì œë¡œ ì´ë™ë˜ëŠ” ê²ƒì€ ì†Œìœ ê¶Œì¼ ë¿ì…ë‹ˆë‹¤. ë¨¸ì‹  ì½”ë“œ ë ˆë²¨ì—ì„œ ë°ì´í„° ë³µì‚¬ê°€ ì¼ì–´"
"ë‚  ì§€ ë§ ì§€ì— ëŒ€í•œ ê²ƒì€ ì»´íŒŒì¼ëŸ¬ ë‚´ë¶€ì—ì„œ ì¼ì–´ë‚˜ëŠ” ìµœì í™” ë¬¸ì œì…ë‹ˆë‹¤. ì´ëŸ° ë³µ"
"ì‚¬ëŠ” ìµœì í™” ê³¼ì •ì—ì„œ ì œê±°ê°€ ë©ë‹ˆë‹¤."

#: src/memory-management/move.md:82
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""
"ì •ìˆ˜ì™€ ê°™ì€ ê°„ë‹¨í•œ ê°’ë“¤ì€ `Copy` (ë’¤ì— ì„¤ëª…í•©ë‹ˆë‹¤)ë¡œ ë§ˆí‚¹ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/move.md:84
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ë³µì‚¬í• ë•Œì—ëŠ” ëª…ì‹œì ìœ¼ë¡œ `clone`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/memory-management/move.md:86
msgid "In the `say_hello` example:"
msgstr ""

#: src/memory-management/move.md:88
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"`say_hello`í•¨ìˆ˜ì˜ ì²«ë²ˆì§¸ í˜¸ì¶œì‹œ `main`í•¨ìˆ˜ëŠ” ìì‹ ì´ ê°€ì§„ `name`ì— ëŒ€í•œ ì†Œìœ ê¶Œ"
"ì„ í¬ê¸°í•˜ë¯€ë¡œ, ì´í›„ `main`í•¨ìˆ˜ì—ì„œëŠ” `name`ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/memory-management/move.md:90
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr "`name`ì— í• ë‹¹ë˜ìˆëŠ” í™ ë©”ëª¨ë¦¬ëŠ” `say_hello`í•¨ìˆ˜ì˜ ëì—ì„œ í•´ì œë©ë‹ˆë‹¤."

#: src/memory-management/move.md:92
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"`main`í•¨ìˆ˜ì—ì„œ `name`ì„ ì°¸ì¡°ë¡œ ì „ë‹¬(ë¹Œë¦¼)í•˜ê³ (`&name`), `say_hello`ì—ì„œ ë§¤ê°œ"
"ë³€ìˆ˜ë¥¼ ì°¸ì¡°í˜•ìœ¼ë¡œ ìˆ˜ì •í•œë‹¤ë©´ `main`í•¨ìˆ˜ëŠ” `name`ì˜ ì†Œìœ ê¶Œì„ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/memory-management/move.md:94
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"ë˜ëŠ” ì²«ë²ˆì§¸ í˜¸ì¶œ ì‹œ `main`í•¨ìˆ˜ì—ì„œ `name`ì„ ë³µì œí•˜ì—¬ ì „ë‹¬í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."
"(`name.clone()`)"

#: src/memory-management/move.md:96
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì´ë™ì„ ê¸°ë³¸ìœ¼ë¡œ í•˜ê³  ë³µì œë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í•˜ë„ë¡ ë§Œë“¬ìœ¼ë¡œ, ì˜ë„ì¹˜ "
"ì•Šê²Œ ë³µì‚¬ë³¸ì„ ë§Œë“œëŠ” ê²ƒì´ C++ì—ì„œë³´ë‹¤ ì–´ë µìŠµë‹ˆë‹¤."

#: src/memory-management/move.md:101
#, fuzzy
msgid "Defensive Copies in Modern C++"
msgstr "Modern C++ì—ì„œ ì´ì¤‘í•´ì œ ë¬¸ì œ"

#: src/memory-management/move.md:103
msgid "Modern C++ solves this differently:"
msgstr "Modern C++ì€ ì´ ë¬¸ì œë¥¼ ë‹¤ë¥´ê²Œ í•´ê²°í•©ë‹ˆë‹¤:"

#: src/memory-management/move.md:106
msgid "\"Cpp\""
msgstr ""

#: src/memory-management/move.md:107
msgid "// Duplicate the data in s1.\n"
msgstr ""

#: src/memory-management/move.md:110
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr "`s1`ì˜ í™ ë°ì´í„°ëŠ” ë³µì œë˜ê³ , `s2`ëŠ” ë…ë¦½ì ì¸ ë³µì‚¬ë³¸ì„ ì–»ìŠµë‹ˆë‹¤."

#: src/memory-management/move.md:111
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr "`s1` ì™€ `s2`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ê°ê°ì˜ ë©”ëª¨ë¦¬ê°€ í•´ì œë©ë‹ˆë‹¤."

#: src/memory-management/move.md:113
msgid "Before copy-assignment:"
msgstr "ë³µì‚¬ ì „:"

#: src/memory-management/move.md:129
msgid "After copy-assignment:"
msgstr "ë³µì‚¬ í›„:"

#: src/memory-management/move.md:154
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""

#: src/memory-management/move.md:158
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""

#: src/memory-management/move.md:163
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""

#: src/memory-management/clone.md:1
msgid "Clone"
msgstr ""

#: src/memory-management/clone.md:3
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr ""

#: src/memory-management/clone.md:23
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `Vec::new` or `Box::"
"new`."
msgstr ""

#: src/memory-management/clone.md:26
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""

#: src/memory-management/copy-types.md:7
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr "ì´ë™ì´ ê¸°ë³¸ ì„¤ì •ì´ì§€ë§Œ, íŠ¹ì • íƒ€ì…ì€ ë³µì‚¬ë©ë‹ˆë‹¤:"

#: src/memory-management/copy-types.md:20
msgid "These types implement the `Copy` trait."
msgstr "ì´ëŸ¬í•œ íƒ€ì…ë“¤ì€ `Copy` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/memory-management/copy-types.md:22
msgid "You can opt-in your own types to use copy semantics:"
msgstr "ì§ì ‘ ë§Œë“  íƒ€ì…ë“¤ë„ `Copy`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ì—¬ ë³µì‚¬ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/memory-management/copy-types.md:38
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "í• ë‹¹ í›„, `p1`ì™€ `p2`ëŠ” ìì‹ ì˜ ë°ì´í„°ë¥¼ ì†Œìœ í•©ë‹ˆë‹¤."

#: src/memory-management/copy-types.md:39
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "ëª…ì‹œì ìœ¼ë¡œ `p1.clone()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ë³µì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/copy-types.md:43
msgid "Copying and cloning are not the same thing:"
msgstr "ë³µì‚¬(copy)ì™€ ë³µì œ(clone)ëŠ” ê°™ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/memory-management/copy-types.md:45
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"ë³µì‚¬ëŠ” ë©”ëª¨ë¦¬ì˜ ë‚´ìš©ì„ ê·¸ëŒ€ë¡œ í•œ ë²Œ ë” ë§Œë“œëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë©°, ì•„ë¬´ ê°ì²´ì—ì„œë‚˜ "
"ë‹¤ ì§€ì›í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤."

#: src/memory-management/copy-types.md:47
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"ë³µì‚¬ëŠ” ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (C++ì—ì„œ ë³µì‚¬ ìƒì„±ìë¥¼ í†µí•´ ë³µì‚¬ ë™ì‘ì„ "
"ì„ì˜ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ê²ƒê³¼ ë¹„êµê°€ ë©ë‹ˆë‹¤.)"

#: src/memory-management/copy-types.md:48
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"ë³µì œëŠ” ë³´ë‹¤ ì¼ë°˜ì ì¸ ì‘ì—…ì´ë©°, `Clone`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ì—¬ ë³µì œì‹œ ë™ì‘ì„ ì»¤ìŠ¤í„°"
"ë§ˆì´ì¦ˆ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/memory-management/copy-types.md:50
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr "`Drop` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•œ íƒ€ì…ì€ ë³µì‚¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/memory-management/copy-types.md:52
msgid "In the above example, try the following:"
msgstr "ìœ„ì˜ ì˜ˆì‹œì—ì„œ ë‹¤ìŒì„ ì‹œë„í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/memory-management/copy-types.md:54
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"`Point`êµ¬ì¡°ì²´ì— `String`í•„ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”. ì»´íŒŒì¼ ë˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤. ì™œëƒí•˜"
"ë©´ `String`ì€ `Copy`íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/memory-management/copy-types.md:56
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"`derive` ì†ì„±ì—ì„œ `Copy`ë¥¼ ì œê±°í•´ ë³´ì„¸ìš”. `p1`ì„ `println!` í•  ë•Œ ì»´íŒŒì¼ ì—ëŸ¬"
"ê°€ ë°œìƒí•  ê²ƒì…ë‹ˆë‹¤."

#: src/memory-management/copy-types.md:58
msgid "Show that it works if you clone `p1` instead."
msgstr "`p1`ì„ ë³µì œí•˜ë©´ ì˜ ë™ì‘í•¨ì„ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/memory-management/drop.md:1
msgid "The `Drop` Trait"
msgstr "`Drop` íŠ¸ë ˆì‡"

#: src/memory-management/drop.md:3
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html)íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜"
"ë©´, ê·¸ ê°’ì´ ìŠ¤ì½”í”„ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ë•Œ ì‹¤í–‰ë  ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/memory-management/drop.md:13
msgid "\"Dropping {}\""
msgstr ""

#: src/memory-management/drop.md:18
#: src/exercises/concurrency/link-checker.md:93
#: src/exercises/concurrency/solutions-morning.md:125
msgid "\"a\""
msgstr ""

#: src/memory-management/drop.md:20 src/testing/googletest.md:12
msgid "\"b\""
msgstr ""

#: src/memory-management/drop.md:22
msgid "\"c\""
msgstr ""

#: src/memory-management/drop.md:23
msgid "\"d\""
msgstr ""

#: src/memory-management/drop.md:24
msgid "\"Exiting block B\""
msgstr ""

#: src/memory-management/drop.md:26
msgid "\"Exiting block A\""
msgstr ""

#: src/memory-management/drop.md:29
msgid "\"Exiting main\""
msgstr ""

#: src/memory-management/drop.md:35
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr ""

#: src/memory-management/drop.md:36
msgid "Values are automatically dropped when they go out of scope."
msgstr ""

#: src/memory-management/drop.md:37
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""

#: src/memory-management/drop.md:39
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr ""

#: src/memory-management/drop.md:40
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""

#: src/memory-management/drop.md:44
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr ""

#: src/memory-management/drop.md:49
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "`Drop::drop`ì€ ì™œ `self`ë¥¼ ì¸ìë¡œ ë°›ì§€ ì•ŠìŠµë‹ˆê¹Œ?"

#: src/memory-management/drop.md:50
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"ì§§ì€ ëŒ€ë‹µ: ë§Œì•½ ê·¸ë ‡ê²Œ ëœë‹¤ë©´ `std::mem::drop`ì´ ë¸”ë¡ì˜ ëì—ì„œ í˜¸ì¶œë˜ê³ , ë‹¤"
"ì‹œ `Drop::drop`ì„ í˜¸ì¶œí•˜ê²Œ ë˜ì–´, ìŠ¤íƒ ì˜¤ë²„í”Œë¡œê°€ ë°œìƒí•©ë‹ˆë‹¤!"

#: src/memory-management/drop.md:52
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "`drop(a)`ë¥¼ `a.drop()`ë¡œ ë³€ê²½í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/memory-management/exercise.md:3
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""

#: src/memory-management/exercise.md:7
msgid "Fill in the missing pieces."
msgstr ""

#: src/memory-management/exercise.md:22 src/memory-management/solution.md:16
msgid "/// A representation of a software package.\n"
msgstr ""

#: src/memory-management/exercise.md:34 src/memory-management/solution.md:28
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""

#: src/memory-management/exercise.md:37
msgid "\"1\""
msgstr ""

#: src/memory-management/exercise.md:40 src/memory-management/solution.md:37
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""

#: src/memory-management/exercise.md:46
msgid "\"2\""
msgstr ""

#: src/memory-management/exercise.md:49 src/memory-management/solution.md:52
msgid "/// Set the package version.\n"
msgstr ""

#: src/memory-management/exercise.md:55 src/memory-management/solution.md:58
msgid "/// Set the package authors.\n"
msgstr ""

#: src/memory-management/exercise.md:57
msgid "\"3\""
msgstr ""

#: src/memory-management/exercise.md:60 src/memory-management/solution.md:64
msgid "/// Add an additional dependency.\n"
msgstr ""

#: src/memory-management/exercise.md:62
msgid "\"4\""
msgstr ""

#: src/memory-management/exercise.md:65 src/memory-management/solution.md:70
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr ""

#: src/memory-management/exercise.md:67
msgid "\"5\""
msgstr ""

#: src/memory-management/exercise.md:76 src/memory-management/solution.md:82
msgid "\"base64\""
msgstr ""

#: src/memory-management/exercise.md:76 src/memory-management/solution.md:82
msgid "\"0.13\""
msgstr ""

#: src/memory-management/exercise.md:77 src/memory-management/solution.md:83
msgid "\"base64: {base64:?}\""
msgstr ""

#: src/memory-management/exercise.md:79 src/memory-management/solution.md:85
msgid "\"log\""
msgstr ""

#: src/memory-management/exercise.md:79 src/memory-management/solution.md:85
msgid "\"0.4\""
msgstr ""

#: src/memory-management/exercise.md:80 src/memory-management/solution.md:86
msgid "\"log: {log:?}\""
msgstr ""

#: src/memory-management/exercise.md:81 src/memory-management/solution.md:87
msgid "\"serde\""
msgstr ""

#: src/memory-management/exercise.md:82 src/memory-management/solution.md:88
msgid "\"djmitche\""
msgstr ""

#: src/memory-management/exercise.md:83 src/memory-management/solution.md:89
msgid "\"4.0\""
msgstr ""

#: src/memory-management/exercise.md:87 src/memory-management/solution.md:93
msgid "\"serde: {serde:?}\""
msgstr ""

#: src/memory-management/solution.md:45
msgid "\"0.1\""
msgstr ""

#: src/smart-pointers/box.md:3
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html)ëŠ” í™ ë°ì´í„°ì— ëŒ€"
"í•œ ì†Œìœ  í¬ì¸í„°ì…ë‹ˆë‹¤:"

#: src/smart-pointers/box.md:9
msgid "\"five: {}\""
msgstr ""

#: src/smart-pointers/box.md:26
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>`ì€ [`Deref<Target = T>`](https://doc.rust-lang.org/std/ops/trait."
"Deref.html#more-on-deref-coercion)ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” [`Box<T>`ì—ì„œ `T` ë©”ì„œ"
"ë“œë¥¼ ì§ì ‘ í˜¸ì¶œ](https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-"
"deref-coercion) í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#: src/smart-pointers/box.md:30
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "ì¬ê·€ ë°ì´í„°ë‚˜ ë™ì í¬ê¸°ì˜ ë°ì´í„° íƒ€ì…ì€ `Box`íƒ€ì…ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/smart-pointers/box.md:35
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr ""

#: src/smart-pointers/box.md:37
msgid "/// An empty list.\n"
msgstr ""

#: src/smart-pointers/box.md:44 src/smart-pointers/box.md:97
msgid "\"{list:?}\""
msgstr ""

#: src/smart-pointers/box.md:48
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
"  ìŠ¤íƒ                             í™\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/box.md:63
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"`Box`ëŠ” C++ì˜ `std::unique_ptr`ê³¼ ë¹„ìŠ·í•©ë‹ˆë‹¤. ì°¨ì´ë¼ë©´ `Box`ëŠ” ë„ì´ ì•„ë‹˜ì„ ë³´"
"ì¥í•œë‹¤ëŠ” ì ì…ë‹ˆë‹¤. "

#: src/smart-pointers/box.md:65
msgid "A `Box` can be useful when you:"
msgstr "`Box`ëŠ” ì•„ë˜ì˜ ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤:"

#: src/smart-pointers/box.md:66
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr "íƒ€ì… í¬ê¸°ë¥¼ ì»´íŒŒì¼ ì‹œì ì— ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš°."

#: src/smart-pointers/box.md:68
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"ì•„ì£¼ í° ë°ì´í„°ì˜ ì†Œìœ ê¶Œì„ ì „ë‹¬í•˜ê³  ì‹¶ì€ ê²½ìš°. ìŠ¤íƒì— ìˆëŠ” í° ë°ì´í„°ë¥¼ ë³µì‚¬í•˜"
"ëŠ” ëŒ€ì‹  `Box`ë¥¼ ì´ìš©í•˜ì—¬ ë°ì´í„°ëŠ” í™ì— ì €ì¥í•˜ê³  í¬ì¸í„°ë§Œ ì´ë™í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/smart-pointers/box.md:72
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not compute a fixed size of the struct in memory "
"(`List` would be of infinite size)."
msgstr ""
"ë§Œì¼ `Box`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  `List`ì— ì§ì ‘ `List`ë¥¼ í¬í•¨í•˜ë ¤ê³  ì‹œë„í•œë‹¤ë©´, ì»´íŒŒ"
"ì¼ëŸ¬ëŠ” êµ¬ì¡°ì²´ì˜ ê³ ì • í¬ê¸°ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ë³´ê¸°ì— ë¬´í•œëŒ€ì˜ í¬"
"ê¸°ë¡œ ë³´ì¼ ê²ƒì…ë‹ˆë‹¤."

#: src/smart-pointers/box.md:76
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box`ëŠ” ì¼ë°˜ í¬ì¸í„°ì™€ í¬ê¸°ê°€ ê°™ê¸° ë•Œë¬¸ì— í¬ê¸°ë¥¼ ê³„ì‚°í•˜ëŠ” ë° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. "
"ë‹¤ë§Œ í™ì— ìœ„ì¹˜í•œ `List`ì˜ ë‹¤ìŒ ìš”ì†Œë¥¼ ê°€ë¦¬í‚¬ ë¿ì…ë‹ˆë‹¤."

#: src/smart-pointers/box.md:79
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"`List` ì •ì˜ì—ì„œ `Box`ë¥¼ ì œê±°í•˜ë©´ ì–´ë–¤ ì»´íŒŒì¼ëŸ¬ ì—ëŸ¬ê°€ ë‚˜ì˜¤ëŠ”ì§€ ê°™ì´ ì‚´í´ë³´ì„¸"
"ìš”. â€œRecursive with indirectionâ€ë¼ëŠ” ë©”ì‹œì§€ë¥¼ ë³´ë©´, ê°’ì„ ì§ì ‘ ì €ì¥í•˜ëŠ” ëŒ€ì‹  "
"`Box`ë‚˜ ë¹„ìŠ·í•œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì°¸ì¡° íƒ€ì…ì´ í•„ìš”í•˜ë‹¤ëŠ” íŒíŠ¸ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/smart-pointers/box.md:85
msgid "Niche Optimization"
msgstr "ë‹ˆì¹˜(í‹ˆìƒˆ) ìµœì í™”(Niche Optimization)"

#: src/smart-pointers/box.md:101
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box`ëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ í¬ì¸í„°ëŠ” í•­ìƒ ìœ íš¨í•˜ë©° `null`ì´ ì•„ë‹™ë‹ˆ"
"ë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ìµœì í™” í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤:"

#: src/smart-pointers/box.md:104
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - -.\n"
":                            :     :                           :\n"
":    list                    :     :                           :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":                            :     :                           :\n"
":                            :     :                           :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/smart-pointers/rc.md:3
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html)ëŠ” ì°¸ì¡° ì¹´ìš´íŒ… ê³µìœ  í¬"
"ì¸í„°ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ë™ì¼í•œ ë°ì´í„°ë¥¼ ì°¸ì¡°í•´ì•¼í•  ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/smart-pointers/rc.md:13
msgid "\"a: {a}\""
msgstr ""

#: src/smart-pointers/rc.md:14
msgid "\"b: {b}\""
msgstr ""

#: src/smart-pointers/rc.md:18
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì‘ì—…í•˜ëŠ” ê²½ìš° [`Arc`](../concurrency/shared_state/arc.md)"
"ì™€ [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)ë¥¼ ì°¸ì¡°í•˜ì„¸"
"ìš”."

#: src/smart-pointers/rc.md:19
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"drop ê°€ëŠ¥í•œ ìˆœí™˜ êµ¬ì¡°ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ê³µìœ  í¬ì¸í„°ë¥¼ [`Weak`](https://doc.rust-"
"lang.org/std/rc/struct.Weak.html) í¬ì¸í„°ë¡œ _ë‹¤ìš´ê·¸ë ˆì´ë“œ_í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/smart-pointers/rc.md:29
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr ""
"`Rc`ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ í†µí•´ ì°¸ì¡°ê°€ ìˆëŠ” ë™ì•ˆì€ `Rc`ê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ê°’ì´ ë©”ëª¨ë¦¬"
"ì—ì„œ í•´ì œë˜ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤."

#: src/smart-pointers/rc.md:31
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "C++ì˜ `std::shared_ptr`ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤."

#: src/smart-pointers/rc.md:32
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`clone`ì€ ë¹„ìš©ì´ ê±°ì˜ ë“¤ì§€ ì•ŠìŠµë‹ˆë‹¤. ê°™ì€ ê³³ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ í•˜ë‚˜ ë” ë§Œë“¤"
"ê³ , ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ëŠ˜ë¦½ë‹ˆë‹¤. í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ ìì²´ê°€ ë³µì œ(ê¹Šì€ ë³µì œ)ë˜ì§€"
"ëŠ” ì•Šìœ¼ë©°, ê·¸ë˜ì„œ ì½”ë“œì—ì„œ ì„±ëŠ¥ ë¬¸ì œê°€ ìˆëŠ”ì§€ ê²€í† í•  ë•Œ ì¼ë°˜ì ìœ¼ë¡œ `Rc`ë¥¼ "
"`clone`í•˜ëŠ” ê²ƒì€ ë¬´ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/smart-pointers/rc.md:35
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut`ëŠ” ì‹¤ì œë¡œ í•„ìš”í•œ ê²½ìš°ì— ë‚´ë¶€ ê°’ì„ ë³µì œí•˜ê³ (\"clone-on-write\") ê°€"
"ë³€ ì°¸ì¡°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/smart-pointers/rc.md:37
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ í™•ì¸í•˜ë ¤ë©´ `Rc::strong_count`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/smart-pointers/rc.md:38
#, fuzzy
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc`ëŠ” `downgrade()`ë¡œ ë‹¤ìš´ê·¸ë ˆì´ë“œí•˜ì—¬ _ì•½í•˜ê²Œ ì°¸ì¡° ì¹´ìš´íŠ¸ë˜ëŠ”(weekly "
"reference-counted)_ ê°ì²´ê°€ ë  ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ìˆœí™˜êµ¬ì¡°ë¼ í•˜ë”ë¼ë„ dropì´ ê°€"
"ëŠ¥í•©ë‹ˆë‹¤. (ì•„ë§ˆë„ `RefCell` ì„ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•  ê²ƒì…ë‹ˆë‹¤.)"

#: src/smart-pointers/exercise.md:3
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""

#: src/smart-pointers/exercise.md:8
msgid "Implement the following types, so that the given tests pass."
msgstr ""

#: src/smart-pointers/exercise.md:10
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr ""

#: src/smart-pointers/exercise.md:14 src/smart-pointers/solution.md:5
msgid "/// A node in the binary tree.\n"
msgstr ""

#: src/smart-pointers/exercise.md:21 src/smart-pointers/solution.md:13
msgid "/// A possibly-empty subtree.\n"
msgstr ""

#: src/smart-pointers/exercise.md:25 src/smart-pointers/solution.md:17
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""

#: src/smart-pointers/exercise.md:33
msgid "// Implement `new`, `insert`, `len`, and `has`.\n"
msgstr ""

#: src/smart-pointers/exercise.md:48 src/smart-pointers/solution.md:105
msgid "// not a unique item\n"
msgstr ""

#: src/smart-pointers/solution.md:89 src/testing/googletest.md:11
msgid "\"bar\""
msgstr ""

#: src/borrowing/shared.md:3
#, fuzzy
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr ""
"í•¨ìˆ˜ í˜¸ì¶œì‹œ ê°’ì˜ ì†Œìœ ê¶Œì„ ì´ë™í•˜ëŠ” ëŒ€ì‹ ì˜ í•¨ìˆ˜ê°€ ê°’ì„ _ë¹Œë ¤ì˜¬ ìˆ˜_ ìˆìŠµë‹ˆë‹¤:"

#: src/borrowing/shared.md:24
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr ""
"`add` í•¨ìˆ˜ëŠ” ë‘ `Point` ê°ì²´ ê°’ì„ \\_ë¹Œë ¤_ì™€ì„œ ìƒˆë¡œìš´ `Point` ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤."

#: src/borrowing/shared.md:25
msgid "The caller retains ownership of the inputs."
msgstr "`p1`ê³¼ `p2`ì˜ ì†Œìœ ê¶Œì€ ì—¬ì „íˆ í˜¸ì¶œì(`main`í•¨ìˆ˜)ì— ìˆìŠµë‹ˆë‹¤."

#: src/borrowing/shared.md:29
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""

#: src/borrowing/shared.md:34
msgid "Notes on stack returns:"
msgstr "ìŠ¤íƒì— í• ë‹¹ëœ ê°’ì„ ë¦¬í„´í•˜ëŠ” ê²ƒì— ëŒ€í•œ ì°¸ê³ :"

#: src/borrowing/shared.md:36
#, fuzzy
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"`add`ì—ì„œ ê°’ì„ ë°˜í™˜í•˜ëŠ” ê²ƒì€ ë§¤ìš° ê°’ì´ ì‹¸ë‹¤ëŠ” ê²ƒì„ ì„¤ëª…í•˜ì„¸ìš”. ì™œëƒí•˜ë©´, ì»´íŒŒ"
"ì¼ëŸ¬ê°€ ë³µì‚¬ ê³¼ì •ì„ ìƒëµí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ìœ„ ì½”ë“œë¥¼ ìŠ¤íƒ ì£¼ì†Œë¥¼ ì¶œë ¥í•˜ë„"
"ë¡ ìˆ˜ì •í•˜ê³  [Playground](https://play.rust-lang.org/)ì—ì„œ ìˆ˜í–‰í•´ ë³´ì„¸ìš”. ë˜"
"ëŠ” [Godbolt](https://rust.godbolt.org/)ì—ì„œ ì–´ì…ˆë¸”ë¦¬ë¥¼ í™•ì¸í•´ ë³´ì„¸ìš”. ìµœì í™” "
"ë ˆë²¨ì´ \"DEBUG\" ì¼ ë•Œì—ëŠ” ì£¼ì†Œê°€ ë°”ë€Œì§€ë§Œ, \"RELEASE\" ë ˆë²¨ì—ì„œëŠ” ë°”ë€Œì§€ ì•Š"
"ìŠµë‹ˆë‹¤:"

#: src/borrowing/shared.md:62
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ë°˜í™˜ê°’ ìµœì í™”(RVO)ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/borrowing/shared.md:63
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"C++ì—ì„œ copy elisionì€ ìƒì„±ìì˜ ë¶€ìˆ˜íš¨ê³¼ ê°€ëŠ¥ì„±ì´ ìˆì–´ ì–¸ì–´ë ˆë²¨ì˜ ì •ì˜ê°€ í•„ìš”"
"í•˜ì§€ë§Œ ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë§Œì•½ RVOê°€ ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ëŸ¬ìŠ¤íŠ¸"
"ëŠ” í•­ìƒ ê°„ë‹¨í•˜ê³  íš¨ìœ¨ì ì¸ `memcpy`ë³µì‚¬ë¥¼ ìˆ˜í–‰í•  ê²ƒì…ë‹ˆë‹¤."

#: src/borrowing/borrowck.md:3
#, fuzzy
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ê°’ì„ ë¹Œë¦´ ë•Œ ë‹¤ìŒê³¼ ê°™ì€ ì œì•½ì¡°ê±´ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/borrowing/borrowck.md:6
#, fuzzy
msgid "You can have one or more shared references to the value, _or_"
msgstr "í•œë²ˆì— í•˜ë‚˜ ì´ìƒì˜ `&T` ê°’ì„ ê°€ì§€ê±°ë‚˜, _ë˜ëŠ”_"

#: src/borrowing/borrowck.md:7
#, fuzzy
msgid "You can have exactly one exclusive reference to the value."
msgstr "ì •í™•íˆ í•˜ë‚˜ì˜ `&mut T` ê°’ë§Œì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/borrowing/borrowck.md:28
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""

#: src/borrowing/borrowck.md:30
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"ìœ„ ì½”ë“œ ì»´íŒŒì¼ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ `c`ëŠ” `a`ë¥¼ ê°€ë³€ ë³€ìˆ˜ë¡œ ë¹Œë ¸ê³ , ì´ì™€ "
"ë™ì‹œì— `b`ëŠ” `a`ë¥¼ ë¶ˆë³€ ë³€ìˆ˜ë¡œ ë¹Œë ¸ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/borrowing/borrowck.md:32
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"`b`ì— ëŒ€í•œ `println!` êµ¬ë¶„ì„ `c`ê°€ ìˆëŠ” ìŠ¤ì½”í”„ ì•ìœ¼ë¡œ ì´ë™í•˜ë©´ ì»´íŒŒì¼ì´ ë©ë‹ˆ"
"ë‹¤."

#: src/borrowing/borrowck.md:34
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"ì´ë ‡ê²Œ ë°”ê¾¸ë©´, ì»´íŒŒì¼ëŸ¬ëŠ” `c`ê°€ `a`ë¥¼ ê°€ë³€ ë³€ìˆ˜ë¡œ ë¹Œë¦¬ê¸° ì „ì—ë§Œ `b`ê°€ ì‚¬ìš©ëœ"
"ë‹¤ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¹Œë¦¼ ê²€ì‚¬ê¸°ì˜ ì´ëŸ¬í•œ ê¸°ëŠ¥ì„ \"non-lexical "
"lifetime\" ì´ë¼ê³  í•©ë‹ˆë‹¤."

#: src/borrowing/borrowck.md:37
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""

#: src/borrowing/borrowck.md:41
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""

#: src/borrowing/interior-mutability.md:7
msgid ""
"Rust provides a few safe means of modifying a value given only a shared "
"reference to that value. All of these replace compile-time checks with "
"runtime checks."
msgstr ""

#: src/borrowing/interior-mutability.md:11
msgid "`Cell` and `RefCell`"
msgstr "`Cell`ê³¼ `RefCell`"

#: src/borrowing/interior-mutability.md:13
#, fuzzy
msgid ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) and [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implement what Rust "
"calls _interior mutability:_ mutation of values in an immutable context."
msgstr ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html ê³¼ [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html)ì€ ëŸ¬ìŠ¤íŠ¸ì—ì„œ _ë‚´ì  "
"ê°€ë³€ì„±(interior mutability)_ì´ë¼ê³  ë¶€ë¥´ëŠ” ê²ƒì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ë¶ˆë³€"
"ì¸ ê°ì²´ì˜ ê°’ì„ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/borrowing/interior-mutability.md:18
msgid ""
"`Cell` is typically used for simple types, as it requires copying or moving "
"values. More complex interior types typically use `RefCell`, which tracks "
"shared and exclusive references at runtime and panics if they are misused."
msgstr ""
"`Cell`ì€ ê°„ë‹¨í•œ íƒ€ì…ì— ëŒ€í•´ì„œ ì£¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. ì™œëƒí•˜ë©´ `Cell`ì— ìˆëŠ” ê°’ì„ ì½"
"ê±°ë‚˜ ì“¸ë•Œì—ëŠ” ë³µì‚¬ í˜¹ì€ ì´ë™ì„ í•´ì•¼ë§Œ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë³µì¡í•œ íƒ€ì…ì´ë¼ë©´ "
"`RefCell`ì´ ë” ë³´í¸ì ì…ë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ì°¸ì¡°ë¥¼ í†µí•´ ê°’ì„ ì½ê±°ë‚˜ ì“°ê²Œ í•´ ì£¼"
"ëŠ” ëŒ€ì‹ , ê·¸ ì°¸ì¡°ë“¤ì´ ì˜¬ë°”ë¥¸ì§€ë¥¼ ëŸ°íƒ€ì„ì— ì²´í¬í•˜ê³ , ì œëŒ€ë¡œ ì‚¬ìš©ë˜ì§€ ì•Šì„ ê²½ìš° "
"íŒ¨ë‹‰ì„ ë°œìƒì‹œí‚µë‹ˆë‹¤."

#: src/borrowing/interior-mutability.md:50
msgid "\"graph: {root:#?}\""
msgstr ""

#: src/borrowing/interior-mutability.md:51
msgid "\"graph sum: {}\""
msgstr ""

#: src/borrowing/interior-mutability.md:57
msgid ""
"If we were using `Cell` instead of `RefCell` in this example, we would have "
"to move the `Node` out of the `Rc` to push children, then move it back in. "
"This is safe because there's always one, un-referenced value in the cell, "
"but it's not ergonomic."
msgstr ""
"ì´ ì˜ˆì œì—ì„œ `RefCell`ëŒ€ì‹  `Cell`ì„ ì¼ì—ˆë‹¤ë©´, `Node`ì— ìì‹ ë…¸ëŠë¥¼ ì¶”ê°€í•˜ê¸° ìœ„"
"í•´ì„œ, `Node`ë¥¼ `Rc`ë°–ìœ¼ë¡œ ì´ë™ì‹œí‚¨ ë‹¤ìŒ, ìì‹ ë…¸ë“œë¥¼ ì¶”ê°€í•˜ê³ , ë‹¤ì‹œ `Rc`ì•ˆìœ¼"
"ë¡œ ì´ë™ì‹œì¼œì•¼ í–ˆì„ ê²ë‹ˆë‹¤. ì´ë ‡ê²Œ í•´ì•¼ë§Œ í•˜ëŠ” ì´ìœ ëŠ” ì•ˆì „ ë•Œë¬¸ì…ë‹ˆë‹¤. Cell ë‚´"
"ë¶€ì˜ ê·¸ ê°’ì´ ì˜¤ì§ í•˜ë‚˜ ì¡´ì¬í•˜ë©°, ê·¸ ê°’ì— ëŒ€í•œ ì°¸ì¡°ê°€ ì—†ë‹¤ëŠ” ê²ƒì´ ë³´ì¥ë˜ê¸° ë•Œ"
"ë¬¸ì…ë‹ˆë‹¤. ë¬¼ë¡  í¸ë¦¬í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤."

#: src/borrowing/interior-mutability.md:61
msgid ""
"To do anything with a Node, you must call a `RefCell` method, usually "
"`borrow` or `borrow_mut`."
msgstr ""
"ë…¸ë“œë¥¼ ì´ë™í•˜ê±°ë‚˜ ë³µì‚¬í•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” `RefCell`ë¡œ ê°ì‹¼ë‹¤"
"ìŒ `borrow`ë‚˜ `borrow_mut`ë©”ì„œë“œë¥¼ ì´ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/borrowing/interior-mutability.md:63
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children` (don't try to print it!)."
msgstr ""
"`root`ë¥¼ `subtree.children`ì— ì¶”ê°€í•´ì„œ ìˆœí™˜ ì°¸ì¡°ê°€ ìƒê¸¸ ìˆ˜ ìˆìŒì„ ë³´ì—¬ì£¼ì„¸ìš” "
"(ê·¸ë˜í”„ë¥¼ ì¶œë ¥í•˜ì§€ëŠ” ë§ˆì„¸ìš”!)."

#: src/borrowing/interior-mutability.md:65
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""
"`self.value`ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” ë©”ì„œë“œì¸`fn inc(&mut self)`ë¥¼ ì¶”ê°€í•˜ê³  ê·¸ ë©”ì„œë“œë¥¼ "
"ìì‹ë…¸ë“œì—ì„œ í˜¸ì¶œí•˜ì„¸ìš”. ê·¸ëŸ¬ë©´ `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'` ëŸ°íƒ€ì„ íŒ¨ë‹‰ì´ ë°œìƒí•¨ì„ ë³´ì´ì„¸ìš”."

#: src/borrowing/exercise.md:3
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"ë‹¹ì‹ ì€ ê±´ê°• ìƒíƒœë¥¼ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ëŠ” ì¼ì„ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ê·¸ ì¼í™˜"
"ìœ¼ë¡œ ë‹¹ì‹ ì€ ì‚¬ìš©ìì˜ ê±´ê°• ìƒíƒœ í†µê³„ë¥¼ ì¶”ì í•´ì•¼í•©ë‹ˆë‹¤."

#: src/borrowing/exercise.md:6
#, fuzzy
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"ë‹¹ì‹ ì˜ ëª©í‘œëŠ” `User` êµ¬ì¡°ì²´ì˜ `impl` ë¸”ë¡ì˜ ë¹ˆ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/borrowing/exercise.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ ë¹ ì§„ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ë©´ "
"ë©ë‹ˆë‹¤:"

#: src/borrowing/exercise.md:51
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr ""

#: src/borrowing/exercise.md:56 src/borrowing/exercise.md:62
#: src/borrowing/exercise.md:68 src/borrowing/solution.md:58
#: src/borrowing/solution.md:64 src/borrowing/solution.md:70
#: src/android/build-rules/library.md:44 src/android/aidl/client.md:22
msgid "\"Bob\""
msgstr ""

#: src/borrowing/exercise.md:57 src/borrowing/solution.md:59
msgid "\"I'm {} and my age is {}\""
msgstr ""

#: src/slices-and-lifetimes/slices.md:1
msgid "Slices"
msgstr "ìŠ¬ë¼ì´ìŠ¤"

#: src/slices-and-lifetimes/slices.md:3
msgid "A slice gives you a view into a larger collection:"
msgstr "ìŠ¬ë¼ì´ìŠ¤ëŠ” í° ì»¬ë™ì…˜ì˜ ì¼ë¶€(í˜¹ì€ ì „ì²´)ë¥¼ ë³´ì—¬ì£¼ëŠ” ë·°(view)ì…ë‹ˆë‹¤:"

#: src/slices-and-lifetimes/slices.md:18
msgid "Slices borrow data from the sliced type."
msgstr "ìŠ¬ë¼ì´ìŠ¤ëŠ” ë‹¤ë¥¸(ìŠ¬ë¼ì´ìŠ¤ ëœ) íƒ€ì…ìœ¼ë¡œë¶€í„° ë°ì´í„°ë¥¼ 'ë¹Œë ¤'ì˜µë‹ˆë‹¤."

#: src/slices-and-lifetimes/slices.md:19
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr "ì§ˆë¬¸: `s`ë¥¼ ì¶œë ¥í•˜ê¸° ì „ì— `a[3]`ì„ ìˆ˜ì •í•˜ë©´ ë¬´ìŠ¨ ì¼ì´ ìˆì–´ë‚ ê¹Œìš”?"

#: src/slices-and-lifetimes/slices.md:23
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"ìŠ¬ë¼ì´ìŠ¤ëŠ” ìš°ì„  `a`ë¥¼ ë¹Œë¦°ë‹¤ìŒ, ì‹œì‘ê³¼ ë ì¸ë±ìŠ¤ë¥¼ ë¸Œë˜í‚·(`[]`)ì•ˆì— ì§€ì •í•´ì„œ "
"ë§Œë“­ë‹ˆë‹¤."

#: src/slices-and-lifetimes/slices.md:26
msgid ""
"If the slice starts at index 0, Rustâ€™s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"ìŠ¬ë¼ì´ìŠ¤ê°€ ì¸ë±ìŠ¤ 0ë¶€í„° ì‹œì‘í•œë‹¤ë©´ ì‹œì‘ ì¸ë±ìŠ¤ëŠ” ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì¦‰ `&a[0.."
"a.len()]`ì™€ `&a[..a.len()]` ëŠ” ë™ì¼í•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/slices.md:30
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë„ ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ `&a[2..a.len()]` ì™€ `&a[2..]`ëŠ” ë™ì¼"
"í•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/slices.md:33
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "ë”°ë¼ì„œ ì „ì²´ ë°°ì—´ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ëŠ” `&a[..]`ê°€ ë©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/slices.md:35
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"`s`ëŠ” `i32`ë“¤ë¡œ ì´ë£¨ì–´ì§„ ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤. `s`ì˜ íƒ€ì…(`&[i32]`)ì— "
"ë°°ì—´ì˜ í¬ê¸°ê°€ ë¹ ì ¸ìˆìŒì— ì£¼ëª©í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì¦‰, ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì´ìš©í•˜ë©´ ë‹¤ì–‘í•œ "
"ê¸¸ì´ì˜ ë°ì´í„°ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/slices-and-lifetimes/slices.md:39
#, fuzzy
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"ìŠ¬ë¼ì´ìŠ¤ëŠ” í•­ìƒ ë‹¤ë¥¸ ê°ì²´ë¡œë¶€í„° 'ë¹Œë ¤' ì˜µë‹ˆë‹¤. ì´ ì˜ˆì‹œì—ì„œ ê°ì²´ `a`ëŠ” ìŠ¬ë¼ì´"
"ìŠ¤ `s`ë³´ë‹¤ ë” ì˜¤ë˜ ì‚´ì•„ ìˆì–´ì•¼ë§Œ í•©ë‹ˆë‹¤. "

#: src/slices-and-lifetimes/slices.md:42
#, fuzzy
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"`a[3]`ì˜ ê°’ì„ ë°”ê¿€ ìˆ˜ ìˆëƒëŠ” ì§ˆë¬¸ì€ ì¢‹ì€ ì§ˆë¬¸ì…ë‹ˆë‹¤. ì—¬ê¸°ì— ëŒ€í•œ ë‹µì€ `a`ì™€ "
"`s`ë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ëŠ” ìˆì§€ë§Œ ìˆ˜ì •í•  ìˆ˜ëŠ” ì—†ìœ¼ë©°, ì´ëŠ” ë©”ëª¨ë¦¬ ì•ˆì „ì„ "
"ìœ„í•´ì„œë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ê·¸ëŸ°ë°, ìŠ¬ë¼ì´ìŠ¤ê°€ ì‚¬ìš©ë˜ì§€ ì•Šì„ ë•Œ, ì¦‰ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë§Œë“¤"
"ê¸° ì „ì´ë‚˜, í˜¹ì€ `println`ì´í›„ì—ëŠ” `a[3]`ì„ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì™œ ê·¸ëŸ°ì§€ì— ëŒ€"
"í•œ ì¢€ë” êµ¬ì²´ì ì¸ ë‹µì€ ë¹Œë¦¼ ê²€ì‚¬ ë¶€ë¶„ì—ì„œ ìì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:7
msgid ""
"We can now understand the two string types in Rust: `&str` is almost like "
"`&[char]`, but with its data stored in a variable-length encoding (UTF-8)."
msgstr ""

#: src/slices-and-lifetimes/str.md:13
msgid "\"s1: {s1}\""
msgstr ""

#: src/slices-and-lifetimes/str.md:15
#, fuzzy
msgid "\"Hello \""
msgstr "Hello World!"

#: src/slices-and-lifetimes/str.md:21
msgid "\"s3: {s3}\""
msgstr ""

#: src/slices-and-lifetimes/str.md:25
msgid "Rust terminology:"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìš©ì–´:"

#: src/slices-and-lifetimes/str.md:27
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str`ì€ ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•œ (ë¶ˆë³€) ì°¸ì¡°ì…ë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:28
msgid "`String` a mutable string buffer."
msgstr "`String`ì€ ë¬¸ìì—´ì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ë²„í¼ì…ë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:32
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`â€Helloâ€`), are stored in the programâ€™s binary."
msgstr ""
"`&str`ì€ ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì…ë‹ˆë‹¤. ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ëŠ” UTF-8ë¡œ ì¸ì½”ë”©ëœ ë¬¸ìì—´ ë°"
"ì´í„°ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ë¬¸ìì—´ ë¦¬í„°ëŸ´(`\"Hello\"`)ì€ í”„ë¡œê·¸ë¨ ë°”ì´ë„ˆë¦¬ì— ì €ì¥ë©ë‹ˆ"
"ë‹¤."

#: src/slices-and-lifetimes/str.md:36
msgid ""
"Rustâ€™s `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì˜ `String`íƒ€ì…ì€ ì‹¤ì œë¡œëŠ” ë¬¸ìì—´ì„ ì´ë£¨ëŠ” ë°”ì´íŠ¸ì— ëŒ€í•œ ë°±í„°"
"(`Vec<u8>`)ì…ë‹ˆë‹¤. `Vec<T>`ê°€ `T`ë¥¼ ì†Œìœ í•˜ê³  ìˆë“¯ì´, `String`ì´ ê°€ë¦¬í‚¤ê³  ìˆ"
"ëŠ” ë¬¸ìì—´ì€ `String`ì˜ ì†Œìœ ì…ë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:39
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"ë‹¤ë¥¸ ë§ì€ íƒ€ì…ë“¤ì²˜ëŸ¼ `String::from`ëŠ” ë¬¸ìì—´ ë¦¬í„°ëŸ´ë¡œë¶€í„° ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆ"
"ë‹¤. `String::new()`ëŠ” ìƒˆë¡œìš´ ë¹ˆ ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤. `push()`ì™€ `push_str()`"
"ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¬¸ìì—´ ë°ì´í„°ë¥¼ ì¶”ê°€ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:43
#, fuzzy
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"`format!()` ë§¤í¬ë¡œëŠ” ë³€ìˆ˜ì˜ ê°’ì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ëŠ” í¸ë¦¬í•œ ë°©ë²•ì…ë‹ˆë‹¤. ì´ ë§¤í¬"
"ë¡œëŠ” `println!()` ë§¤í¬ë¡œì™€ ë™ì¼í•œ í¬ë§·íŒ… í˜•ì‹ì„ ì§€ì›í•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:46
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""

#: src/slices-and-lifetimes/str.md:51
#, fuzzy
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"ë‹¹ì‹ ì´ C++ í”„ë¡œê·¸ë˜ë¨¸ ë¼ë©´: `&str`ëŠ” C++ì˜ `const char*`ì™€ ìœ ì‚¬í•˜ì§€ë§Œ í•­ìƒ ìœ "
"íš¨í•œ ë¬¸ìì—´ì„ ê°€ë¦¬í‚¨ë‹¤ëŠ” ì ì´ ë‹¤ë¦…ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì˜ `String`ì€ C++ì˜ `std::"
"string` ê³¼ ëŒ€ëµ ê±°ì˜ ë™ì¼í•©ë‹ˆë‹¤. (ì£¼ìš” ì°¨ì´ì : ëŸ¬ìŠ¤íŠ¸ì˜ `String`ì€ UTF-8 ì¸ì½”"
"ë”© ë°”ì´íŠ¸ë§Œ í¬í•¨í•  ìˆ˜ ìˆìœ¼ë©° ì‘ì€ ë¬¸ìì—´ ìµœì í™”(small-string optimization)ëŠ” "
"êµ¬í˜„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/slices-and-lifetimes/str.md:56
#, fuzzy
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr "Byte strings allow you to create a `&[u8]` value directly:"

#: src/slices-and-lifetimes/lifetime-annotations.md:3
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:6
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:11
#, fuzzy
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr ""
"ìˆ˜ëª… í‘œê¸°(`'`)ì€ ìˆ˜ëª… ì¶”ë¡ ì‹œ ì œì•½ì¡°ê±´ì´ ë©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì´ ì œì•½ì¡°ê±´ì„ ë§Œì¡±"
"ì‹œí‚¤ëŠ” ìœ ìš”í•œ ìˆ˜ëª…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆëŠ”ì§€ ê²€ì‚¬ë¥¼ í•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/lifetime-annotations.md:15
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:36
msgid "// What is the lifetime of p3?\n"
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:37
msgid "\"p3: {p3:?}\""
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:43
msgid ""
"In this example, the the compiler does not know what lifetime to infer for "
"`p3`. Looking inside the function body shows that it can only safely assume "
"that `p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, "
"Rust requires explicit annotations of lifetimes on function arguments and "
"return values."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:49
msgid "Add `'a` appropriately to `left_most`:"
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:55
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""

#: src/slices-and-lifetimes/lifetime-annotations.md:58
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:1
msgid "Lifetimes in Function Calls"
msgstr "í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ìˆ˜ëª…"

#: src/slices-and-lifetimes/lifetime-elision.md:3
#, fuzzy
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"ì›ë˜, í•¨ìˆ˜ì˜ ì¸ìì™€ ë¦¬í„´ê°’ì—ëŠ” ìˆ˜ëª…ì„ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ [ëª‡ ê°€ì§€ ì¡°ê±´]"
"(https://doc.rust-lang.org/nomicon/lifetime-elision.html)ì„ ë§Œì¡±í•˜ëŠ” ëŒ€ë¶€ë¶„"
"ì˜ ê²½ìš°ì—ëŠ” ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/slices-and-lifetimes/lifetime-elision.md:8
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:9
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:11
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:52
msgid "In this example, `cab_distance` is trivially elided."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:54
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:57
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:63
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""

#: src/slices-and-lifetimes/lifetime-elision.md:67
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:1
msgid "Lifetimes in Data Structures"
msgstr "êµ¬ì¡°ì²´ì—ì„œì˜ ìˆ˜ëª…"

#: src/slices-and-lifetimes/struct-lifetimes.md:3
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"ì–´ë–¤ íƒ€ì…ì´ ë¹Œë ¤ì˜¨ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ìˆë‹¤ë©´, ë°˜ë“œì‹œ ìˆ˜ëª…ì„ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/slices-and-lifetimes/struct-lifetimes.md:10
msgid "\"Bye {text}!\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:14
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:17
msgid "// erase(text);\n"
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:18
msgid "\"{fox:?}\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:19
msgid "\"{dog:?}\""
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md:25
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"ìœ„ì˜ ì˜ˆì œì—ì„œ `Highlight`ì˜ ì–´ë…¸í…Œì´ì…˜(`<'doc>`)ì€ ì ì–´ë„ `Highlight` ì¸ìŠ¤í„´"
"ìŠ¤ê°€ ì‚´ì•„ìˆëŠ” ë™ì•ˆì—ëŠ” ê·¸ ë‚´ë¶€ì˜ `&str`ê°€ ê°€ë¦¬í‚¤ëŠ” ë°ì´í„° ì—­ì‹œ ì‚´ì•„ìˆì–´ì•¼ í•œ"
"ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/struct-lifetimes.md:28
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"ë§Œì•½ `text`ê°€ `fox` (í˜¹ì€ `dog`)ì˜ ìˆ˜ëª…ì´ ë‹¤í•˜ê¸° ì „ì— `erase`í•¨ìˆ˜ í˜¸ì¶œ ë“±ìœ¼"
"ë¡œ ì‚¬ë¼ì§€ê²Œ ëœë‹¤ë©´ ë¹Œë¦¼ ê²€ì‚¬ê¸°ê°€ ì—ëŸ¬ë¥¼ ë°œìƒí•©ë‹ˆë‹¤."

#: src/slices-and-lifetimes/struct-lifetimes.md:30
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"ë¹Œë¦° ë°ì´í„°ë¥¼ ê°€ì§€ê³  ìˆëŠ” íƒ€ì…ì€ ì‚¬ìš©ìë¡œ í•˜ì—¬ê¸ˆ ì›ë³¸ ë°ì´í„°ë¥¼ ìœ ì§€í•˜ë„ë¡ ê°•"
"ì œí•©ë‹ˆë‹¤. ì´ëŸ° íƒ€ì…ì€ ê²½ëŸ‰ ë·°(lightweight view)ë¥¼ ë§Œë“œëŠ”ë° ìœ ìš©í•˜ì§€ë§Œ, ì´ ì œ"
"ì•½ ì¡°ê±´ ë•Œë¬¸ì— ì´ëŸ° íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì‰½ì§€ë§Œì€ ì•ŠìŠµë‹ˆë‹¤."

#: src/slices-and-lifetimes/struct-lifetimes.md:33
msgid "When possible, make data structures own their data directly."
msgstr ""
"ë”°ë¼ì„œ, ê°€ëŠ¥í•˜ë‹¤ë©´, êµ¬ì¡°ì²´ê°€ ìì‹ ì˜ ë°ì´í„°ë¥¼ ì§ì ‘ ì†Œìœ í•˜ë„ë¡ í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆ"
"ë‹¤."

#: src/slices-and-lifetimes/struct-lifetimes.md:34
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"í•œ êµ¬ì¡°ì²´ì•ˆì— ì—¬ëŸ¬ ì°¸ì¡°ê°€ ìˆìœ¼ë©´ì„œ, ì´ ì°¸ì¡°ë“¤ì˜ ìˆ˜ëª…ì´ ì„œë¡œ ë‹¤ë¥´ê²Œ ì§€ì •ë˜ëŠ” "
"ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì°¸ì¡°ì™€ ê·¸ êµ¬ì¡°ì²´ ê°„ì˜ ê´€ê³„ ë¿ë§Œì´ ì•„ë‹ˆë¼, ê·¸ ì°¸ì¡°ë“¤ ì‚¬"
"ì´ì˜ ìˆ˜ëª… ê´€ê³„ë¥¼ ì„¤ëª…í•´ì•¼ í•  ê²½ìš°ì— í•„ìš”í•©ë‹ˆë‹¤. ë§¤ìš° ê³ ê¸‰ ê¸°ìˆ ì…ë‹ˆë‹¤."

#: src/slices-and-lifetimes/exercise.md:3
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:8
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:13
msgid "We'll use the following proto:"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:28
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:33
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:38
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""

#: src/slices-and-lifetimes/exercise.md:49
#: src/slices-and-lifetimes/solution.md:11
msgid "\"Invalid varint\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:51
#: src/slices-and-lifetimes/solution.md:13
msgid "\"Invalid wire-type\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:53
#: src/slices-and-lifetimes/solution.md:15
msgid "\"Unexpected EOF\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:55
#: src/slices-and-lifetimes/solution.md:17
msgid "\"Invalid length\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:57
#: src/slices-and-lifetimes/solution.md:19
msgid "\"Unexpected wire-type)\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:59
#: src/slices-and-lifetimes/solution.md:21
msgid "\"Invalid string (not UTF-8)\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:62
#: src/slices-and-lifetimes/solution.md:24
msgid "/// A wire type as seen on the wire.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:65
#: src/slices-and-lifetimes/solution.md:27
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:67
#: src/slices-and-lifetimes/solution.md:29
msgid ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:71
#: src/slices-and-lifetimes/solution.md:33
msgid ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    /// little-endian order containing a 32-bit signed integer.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:76
#: src/slices-and-lifetimes/solution.md:38
msgid "/// A field's value, typed based on the wire type.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:80
#: src/slices-and-lifetimes/solution.md:42
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:85
#: src/slices-and-lifetimes/solution.md:47
msgid "/// A field, containing the field number and its value.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:102
#: src/slices-and-lifetimes/solution.md:64
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:132
#: src/slices-and-lifetimes/solution.md:94
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:140
#: src/slices-and-lifetimes/solution.md:102
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:150
#: src/slices-and-lifetimes/solution.md:112
msgid "// More than 7 bytes is invalid.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:153
#: src/slices-and-lifetimes/solution.md:115
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:161
#: src/slices-and-lifetimes/solution.md:122
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:167
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:169
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md:171
#: src/slices-and-lifetimes/solution.md:153
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""

#: src/slices-and-lifetimes/exercise.md:198
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md:146
msgid "// Unwrap error because `value` is definitely 4 bytes long.\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md:187
#: src/slices-and-lifetimes/solution.md:198
msgid "// skip everything else\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md:225
#: src/slices-and-lifetimes/solution.md:232
#: src/slices-and-lifetimes/solution.md:239
msgid "b\"hello\""
msgstr ""

#: src/welcome-day-4.md:1
msgid "Welcome to Day 4"
msgstr "4ì¼ì°¨ ê°œìš”"

#: src/welcome-day-4.md:3
#, fuzzy
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr "ì˜¤ëŠ˜ì€ ëª‡ ê°€ì§€ ê³ ê¸‰ ì£¼ì œë¥¼ ë‹¤ë£¹ë‹ˆë‹¤:"

#: src/welcome-day-4.md:5
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr "ë°˜ë³µì: `Iterator` íŠ¸ë ˆì‡ ì‹¬ì¸µ ë¶„ì„"

#: src/welcome-day-4.md:6
msgid "Modules and visibility."
msgstr "ëª¨ë“ˆê³¼ ê°€ì‹œì„±"

#: src/welcome-day-4.md:7
#, fuzzy
msgid "Testing."
msgstr "í…ŒìŠ¤íŠ¸"

#: src/welcome-day-4.md:8
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "ì˜¤ë¥˜ì²˜ë¦¬(ì—ëŸ¬ í•¸ë“¤ë§): íŒ¨ë‹‰, `Result`, `?` ì—°ì‚°ì."

#: src/welcome-day-4.md:9
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr ""
"ì•ˆì „í•˜ì§€ ì•Šì€ Rust: ì•ˆì „í•œ Rustë¡œ ì›í•˜ëŠ” ê²ƒì„ í‘œí˜„í•  ìˆ˜ ì—†ì„ ë•Œì—ë§Œ ì‚¬ìš©í•˜ì„¸"
"ìš”."

#: src/iterators/iterator.md:7
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""
"ì»¬ë™ì…˜ì— ìˆëŠ” ê°’ë“¤ì„ ì ‘ê·¼í•˜ê¸° ìœ„í•´ì„œëŠ” [`Iterator`](https://doc.rust-lang."
"org/std/iter/trait.Iterator.html) íŠ¸ë ˆì‡ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ íŠ¸ë ˆì‡ì€ `next` ë©”"
"ì„œë“œë¥¼ ë¹„ë¡¯í•œ ë§ì€ ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ë§ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ íƒ€ì…ì´ "
"`Iterator`ë¥¼ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©°, ì—¬ëŸ¬ë¶„ë„ ì—¬ëŸ¬ë¶„ì˜ íƒ€ì…ì´ ì´ íŠ¸ë ˆì‡ì„ ì§ì ‘ êµ¬í˜„"
"í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/iterators/iterator.md:31
msgid "\"fib({i}): {n}\""
msgstr "\"fib({i}): {n}\""

#: src/iterators/iterator.md:38
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"`Iterator` íŠ¸ë ˆì‡ì€ ì»¬ë ‰ì…˜ì— ëŒ€í•œ ì—¬ëŸ¬ ì¼ë°˜ì ì¸ í•¨ìˆ˜ í”„ë¡œê·¸ë˜ë° ì‘ì—…(ì˜ˆ: "
"`map`, `filter`, `reduce` ë“±)ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŠ” ê´€ë ¨ ë¬¸ì„œë¥¼ ëª¨ë‘ ì°¾ì„ ìˆ˜ ìˆ"
"ëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤. Rustì—ì„œëŠ” ì´ëŸ¬í•œ í•¨ìˆ˜ê°€, ì´ì™€ ë™ì¼í•œ ì¼ì„ í•˜ëŠ” ëª…ë ¹í˜• êµ¬í˜„"
"ë§Œí¼ íš¨ìœ¨ì ì¸ ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/iterators/iterator.md:43
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator`ëŠ” ë£¨í”„ë¥¼ ì‘ë™í•˜ê²Œ ë§Œë“œëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤. ì´ëŠ” `Vec<T>`ì™€ ê°™ì€ ì»¬"
"ë ‰ì…˜ íƒ€ì…ê³¼ `&Vec<T>` ë° `&[T]`ì™€ ê°™ì€ ì´ì— ëŒ€í•œ ì°¸ì¡°ì— ì˜í•´ êµ¬í˜„ë©ë‹ˆë‹¤. ë²”ìœ„"
"ë„ ì´ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ëŸ° ì´ìœ ë¡œ `for i in some_vec { .. }`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë²¡í„°ë¥¼ "
"ë°˜ë³µí•  ìˆ˜ ìˆì§€ë§Œ `some_vec.next()`ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/iterators/intoiterator.md:3
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"`Iterator` íŠ¸ë ˆì‡ì€ ìƒì„±ëœ ë°˜ë³µìë¥¼ _ì‚¬ìš©_í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤. ë°˜ë©´ "
"`IntoIterator` íŠ¸ë ˆì‡ì€ ë°˜ë³µìë¥¼ _ìƒì„±_í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤ë‹ˆë‹¤:"

#: src/iterators/intoiterator.md:49
msgid "\"point = {x}, {y}\""
msgstr "\"point = {x}, {y}\""

#: src/iterators/intoiterator.md:56
#, fuzzy
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr "`IntoIterator`ì˜ ëª¨ë“  êµ¬í˜„ì€ ë°˜ë“œì‹œ ë‹¤ìŒì˜ ë‘ íƒ€ì…ì„ ì„ ì–¸í•´ì•¼í•©ë‹ˆë‹¤:"

#: src/iterators/intoiterator.md:59
#, fuzzy
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "`Item`: `i8`ê³¼ ê°™ì´ ë°˜ë³µë˜ëŠ” ê°’ì˜ íƒ€ì…,"

#: src/iterators/intoiterator.md:60
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "`IntoIter`: `into_iter` ë©”ì„œë“œì—ì„œ ë°˜í™˜ë˜ëŠ” `Iterator`íƒ€ì…."

#: src/iterators/intoiterator.md:62
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"`IntoIter`ì—ëŠ” `Item`ì´ ì—°ê²°ë˜ì–´ ìˆìŒì„ ì£¼ëª©í•˜ì„¸ìš”. `IntoIter` ë°˜ë³µìëŠ” "
"`Item` íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ê°€ë¦¬ì¼œì•¼ í•©ë‹ˆë‹¤. ì¦‰, ë°˜ë³µìëŠ” `Option<Item>`ì„ ë¦¬í„´í•©"
"ë‹ˆë‹¤"

#: src/iterators/intoiterator.md:65
msgid "The example iterates over all combinations of x and y coordinates."
msgstr "ì´ ì˜ˆëŠ” x ë° y ì¢Œí‘œì˜ ëª¨ë“  ì¡°í•©ì„ ìˆœíšŒí•©ë‹ˆë‹¤."

#: src/iterators/intoiterator.md:67
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""
"`main`ì—ì„œ ê·¸ë¦¬ë“œë¥¼ ë‘ ë²ˆ ë°˜ë³µí•´ ë³´ì„¸ìš”. ì™œ ì‹¤íŒ¨í•˜ë‚˜ìš”? `IntoIterator::"
"into_iter`ëŠ” 'self'ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜µë‹ˆë‹¤."

#: src/iterators/intoiterator.md:70
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""
"`&Grid`ì— `IntoIterator`ë¥¼ êµ¬í˜„í•˜ê³  `GridIter`ì— `Grid` ì°¸ì¡°ë¥¼ ì €ì¥í•˜ì—¬ ì´ ë¬¸"
"ì œë¥¼ í•´ê²°í•˜ì„¸ìš”."

#: src/iterators/intoiterator.md:73
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ íƒ€ì…ì—ì„œ ë™ì¼í•œ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `for e in "
"some_vector`ëŠ” `some_vector`ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì™€ í•´ë‹¹ ë²¡í„°ì—ì„œ ì†Œìœ í•œ ìš”ì†Œë¥¼ ë°˜"
"ë³µí•©ë‹ˆë‹¤. `some_vector`ì˜ ìš”ì†Œì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ë°˜ë³µí•˜ë ¤ë©´ ëŒ€ì‹  `for e in "
"&some_vector`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/iterators/fromiterator.md:1
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/fromiterator.md:3
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"ì–´ë–¤ ì»¬ë ‰ì…˜ì´ [`FromIterator`](https://doc.rust-lang.org/std/iter/trait."
"FromIterator.html)ë¥¼ êµ¬í˜„í•˜ê³  ìˆë‹¤ë©´ [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)ë¡œë¶€í„° ê·¸ ì»¬ë ‰ì…˜ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/iterators/fromiterator.md:9
msgid "\"prime_squares: {prime_squares:?}\""
msgstr "\"prime_squares: {prime_squares:?}\""

#: src/iterators/fromiterator.md:15
#, fuzzy
msgid "`Iterator` implements"
msgstr "`Iterator`"

#: src/iterators/fromiterator.md:24
msgid "There are two ways to specify `B` for this method:"
msgstr "ì´ ë©”ì„œë“œì— `B`ë¥¼ ì§€ì •í•˜ëŠ” ë°©ë²•ì—ëŠ” ë‘ ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/iterators/fromiterator.md:26
#, fuzzy
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""
"\"turbofish' ì‚¬ìš©: ë‹¤ìŒê³¼ ê°™ì´ `some_iterator.collect::<COLLECTION_TYPE>()`"
"ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì—¬ê¸°ì— ì‚¬ìš©ëœ `_` ëŠ” Rustê°€ `Vec` ì— ë“¤ì–´ê°ˆ ìš”ì†Œë“¤ì˜ íƒ€ì…ì„ ì¶”"
"ë¡ í•˜ë„ë¡í•©ë‹ˆë‹¤. "

#: src/iterators/fromiterator.md:28
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""
"íƒ€ì… ì¶”ë¡  ì‚¬ìš©: `let prime_squares: Vec<_> = some_iterator.collect()`ë¥¼ ì‚¬ìš©"
"í•©ë‹ˆë‹¤. ì´ ë°©ë²•ìœ¼ë¡œ ì˜ˆì œë¥¼ ë‹¤ì‹œ ì‘ì„±í•´ ë³´ì„¸ìš”."

#: src/iterators/fromiterator.md:31
#, fuzzy
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"`Iterator<Item = Result<V, E>>`ì„ `Result<Vec<V>, E>`ë¡œ ë³€í™˜í•  ìˆ˜ ìˆëŠ” ë©‹ì§„ "
"ê¸°ëŠ¥ë“¤ë„ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/iterators/exercise.md:3
#, fuzzy
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr "`Iterator`íŠ¸ë ˆì‡ì„ ì—¬ëŸ¬ë¶„ì´ ì •ì˜í•œ íƒ€ì…ì—ì„œ êµ¬í˜„í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/iterators/exercise.md:6
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•´ ë³´ì‹œê¸° "
"ë°”ëë‹ˆë‹¤. ì¤‘ê°„ ê²°ê³¼ê°’ì„ `Vec`ì— í• ë‹¹í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/iterators/exercise.md:11 src/iterators/solution.md:4
#, fuzzy
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""
"/// `values`ì˜ ëì—ì„œ ì‹œì‘ê¹Œì§€\n"
"/// ë˜í•‘í•˜ì—¬ `offset`ì„ ê¸°ì¤€ìœ¼ë¡œ `values` ì˜¤í”„ì…‹ ìš”ì†Œ ê°„ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•©ë‹ˆ"
"ë‹¤.\n"
"///\n"
"/// ê²°ê³¼ì˜ ìš”ì†Œ `n`ì€ `values[(n+offset)%len] - values[n]`ì…ë‹ˆë‹¤.\n"

#: src/modules/modules.md:3
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr "`impl`ë¸”ë¡ì€ í•´ë‹¹ íƒ€ì…ì˜ í•¨ìˆ˜ë“¤ì— ëŒ€í•œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/modules/modules.md:5
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "ë§ˆì°¬ê°€ì§€ë¡œ, `mod`ëŠ” íƒ€ì…ê³¼ í•¨ìˆ˜ë“¤ì— ëŒ€í•´ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤:"

#: src/modules/modules.md:10
msgid "\"In the foo module\""
msgstr "\"foo ëª¨ë“ˆ ë‚´ë¶€\""

#: src/modules/modules.md:16
msgid "\"In the bar module\""
msgstr "\"bar ëª¨ë“ˆ ë‚´ë¶€\""

#: src/modules/modules.md:28
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"íŒ¨í‚¤ì§€ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•˜ë©° í•˜ë‚˜ì˜ ëŒ€í‘œ `Cargo.toml` íŒŒì¼ì„ í¬í•¨í•©ë‹ˆë‹¤. íŒ¨í‚¤ì§€"
"ë¥¼ êµ¬ì„±í•˜ëŠ” í¬ë ˆì´íŠ¸ë“¤ì„ ë¹Œë“œí•˜ëŠ” ë°©ë²•ì´ ì´ íŒŒì¼ì— ê¸°ìˆ ë©ë‹ˆë‹¤."

#: src/modules/modules.md:30
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"í¬ë ˆì´íŠ¸ëŠ” ëª¨ë“ˆì˜ íŠ¸ë¦¬ì…ë‹ˆë‹¤. ë°”ì´ë„ˆë¦¬ í¬ë ˆì´íŠ¸ëŠ” ì‹¤í–‰íŒŒì¼ë¡œ ë¹Œë“œë˜ê³ , ë¼ì´ë¸Œ"
"ëŸ¬ë¦¬ í¬ë ˆì´íŠ¸ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ë¹Œë“œë©ë‹ˆë‹¤."

#: src/modules/modules.md:32
msgid "Modules define organization, scope, and are the focus of this section."
msgstr "ëª¨ë“ˆì€ ì½”ë“œë¥¼ ì¡°ì§í™”í•˜ê³  ìŠ¤ì½”í”„ë¥¼ ì •ì˜í•˜ëŠ” ë‹¨ìœ„ì…ë‹ˆë‹¤."

#: src/modules/filesystem.md:3
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""
"ëª¨ë“ˆì˜ ë‚´ìš©ì„ ê¸°ìˆ í•˜ì§€ ì•Šìœ¼ë©´, ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ë¥¸ íŒŒì¼ì—ì„œ ê·¸ ë‚´ìš©ì„ ì½ìŠµë‹ˆë‹¤:"

#: src/modules/filesystem.md:9
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"ìœ„ ì½”ë“œëŠ” ëŸ¬ìŠ¤íŠ¸ë¡œ í•˜ì—¬ê¸ˆ `garden`ëª¨ë“ˆì˜ ë‚´ìš©ì„ `src/garden.rs`ì—ì„œ ì°¾ë„ë¡ í•©"
"ë‹ˆë‹¤. ë¹„ìŠ·í•˜ê²Œ, `garden::vegetables` ëª¨ë“ˆì€ `src/garden/vegetables.rs`ì—ì„œ ì°¾"
"ìŠµë‹ˆë‹¤."

#: src/modules/filesystem.md:13
msgid "The `crate` root is in:"
msgstr "`crate(í¬ë ˆì´íŠ¸)`ì˜ ë£¨íŠ¸ëŠ” ì•„ë˜ ê²½ë¡œ ì…ë‹ˆë‹¤:"

#: src/modules/filesystem.md:15
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬ë ˆì´íŠ¸)"

#: src/modules/filesystem.md:16
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (ë°”ì´ë„ˆë¦¬ í¬ë ˆì´íŠ¸)"

#: src/modules/filesystem.md:18
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"ëª¨ë“ˆë„ \"ë‚´ë¶€ ë¬¸ì„œ ì£¼ì„\"ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì„œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ëª¨ë“ˆì€ ëª¨ë“ˆ"
"ì´ í¬í•¨ëœ í•­ëª©(ì´ ê²½ìš°ì—ëŠ” ëª¨ë“ˆ)ì„ ë¬¸ì„œí™”í•©ë‹ˆë‹¤."

#: src/modules/filesystem.md:22
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr "//! ì´ ëª¨ë“ˆì€ ì •ì›ì„ êµ¬í˜„í•©ë‹ˆë‹¤.\n"

#: src/modules/filesystem.md:24
msgid "// Re-export types from this module.\n"
msgstr "// ì´ ëª¨ë“ˆì—ì„œ íƒ€ì…ì„ ë‹¤ì‹œ ë‚´ë³´ëƒ…ë‹ˆë‹¤.\n"

#: src/modules/filesystem.md:28
msgid "/// Sow the given seed packets.\n"
msgstr "/// ì£¼ì–´ì§„ ì”¨ì•— íŒ¨í‚·ì„ ë¿Œë¦½ë‹ˆë‹¤.\n"

#: src/modules/filesystem.md:33
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr "/// ì¤€ë¹„ëœ ë†ì‘ë¬¼ì„ ì •ì›ì—ì„œ ìˆ˜í™•í•©ë‹ˆë‹¤.\n"

#: src/modules/filesystem.md:42
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"`module/mod.rs`ë¥¼ `module.rs`ë¡œ ë°”ê¾¼ë‹¤ í•˜ë”ë¼ë„ Rust 2018ì—ì„œëŠ” í•˜ìœ„ ëª¨ë“ˆì„ "
"ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/filesystem.md:45
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"`filename.rs`ë¥¼ `filename/mod.rs`ëŒ€ì‹  ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì£¼ëœ ì´ìœ ëŠ”, "
"`mod.rs`ë¼ëŠ” ì´ë¦„ì„ ê°€ì§„ íŒŒì¼ì´ ë§ì„ ê²½ìš° IDEì—ì„œ ì´ë“¤ì„ ì„œë¡œ êµ¬ë³„í•˜ëŠ”ê²Œ í˜ë“¤"
"ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/modules/filesystem.md:48
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""
"í´ë”ë¥¼ ì´ìš©í•´ì„œ ë” ê¹Šì€ ê³„ì¸µ êµ¬ì¡°ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹¬ì§€ì–´ëŠ” ë©”ì¸ ëª¨ë“ˆì´ "
"íŒŒì¼ì´ë”ë¼ë„ìš”:"

#: src/modules/filesystem.md:58
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr "ëŸ¬ìŠ¤íŠ¸ê°€ ì–´ë””ì„œ ëª¨ë“ˆë“¤ì„ ì°¾ì„ì§€ëŠ” ì»´íŒŒì¼ëŸ¬ ë””ë ‰í‹°ë¸Œë¡œ ë³€ê²½ ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/modules/filesystem.md:61
#, fuzzy
msgid "\"some/path.rs\""
msgstr "\"some/path.rs\""

#: src/modules/filesystem.md:65
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"ì´ëŠ” Goì–¸ì–´ ì—ì„œì²˜ëŸ¼ ì–´ë–¤ ëª¨ë“ˆì˜ í…ŒìŠ¤íŠ¸ë¥¼ `some_module_test.rs` ê°™ì€ íŒŒì¼ì— "
"ë‘ê³  ì‹¶ì€ ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤."

#: src/modules/visibility.md:3
msgid "Modules are a privacy boundary:"
msgstr "ëª¨ë“ˆì˜ íƒ€ì…ì´ë‚˜ í•¨ìˆ˜ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë°”ê¹¥ì— ë…¸ì¶œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/modules/visibility.md:5
msgid "Module items are private by default (hides implementation details)."
msgstr "ë”°ë¼ì„œ ëª¨ë“ˆì˜ ì„¸ë¶€ êµ¬í˜„ ë‚´ìš©ì´ ê°ì¶°ì§‘ë‹ˆë‹¤."

#: src/modules/visibility.md:6
msgid "Parent and sibling items are always visible."
msgstr "ë¶€ëª¨ì™€ ì´ì›ƒ í•­ëª©ì€ ì–¸ì œë‚˜ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/modules/visibility.md:7
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"ì¦‰, ëª¨ë“ˆ `foo`ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•œ í•­ëª©ì´ë¼ë©´ `foo` ì•„ë˜ì˜ ëª¨ë“  ëª¨ë“ˆì—ì„œ ì ‘ê·¼ê°€ëŠ¥"
"í•©ë‹ˆë‹¤."

#: src/modules/visibility.md:13
msgid "\"outer::private\""
msgstr "\"outer::private\""

#: src/modules/visibility.md:17
msgid "\"outer::public\""
msgstr "\"outer::public\""

#: src/modules/visibility.md:22
msgid "\"outer::inner::private\""
msgstr "\"outer::inner::private\""

#: src/modules/visibility.md:26
msgid "\"outer::inner::public\""
msgstr "\"outer::inner::public\""

#: src/modules/visibility.md:39
msgid "Use the `pub` keyword to make modules public."
msgstr "`pub` í‚¤ì›Œë“œëŠ” ëª¨ë“ˆì—ë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/visibility.md:41
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""
"ë˜í•œ, ê³ ê¸‰ ê¸°ëŠ¥ìœ¼ë¡œ `pub(...)` ì§€ì •ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê³µê°œ ë²”ìœ„ë¥¼ ì œí•œí•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/modules/visibility.md:44
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"[ê³µì‹ ë¬¸ì„œ](https://doc.rust-lang.org/reference/visibility-and-privacy."
"html#pubin-path-pubcrate-pubsuper-and-pubself)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”."

#: src/modules/visibility.md:46
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "`pub(crate)`ë¡œ ê°€ì‹œì„±ì„ ì§€ì •í•˜ëŠ” ê²ƒì´ ìì£¼ ì“°ì…ë‹ˆë‹¤."

#: src/modules/visibility.md:47
msgid "Less commonly, you can give visibility to a specific path."
msgstr "ìì£¼ ì“°ì´ì§„ ì•Šì§€ë§Œ íŠ¹ì • ê²½ë¡œì— ëŒ€í•´ì„œë§Œ ê°€ì‹œì„±ì„ ë¶€ì—¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/visibility.md:48
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""
"ì–´ë–¤ ê²½ìš°ì´ë“  ê°€ì‹œì„±ì´ ë¶€ì—¬ë˜ë©´ í•´ë‹¹ ëª¨ë“ˆì„ í¬í•¨í•˜ì—¬ í•˜ìœ„ì˜ ëª¨ë“  ëª¨ë“ˆì´ ì ìš©"
"ë°›ìŠµë‹ˆë‹¤."

#: src/modules/paths.md:1
msgid "use, super, self"
msgstr "use, super, self"

#: src/modules/paths.md:3
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"ëª¨ë“ˆì€ `use`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ë¥¸ ëª¨ë“ˆì˜ ì‹¬ë³¼ì„ ë‚´ ìŠ¤ì½”í”„ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¼"
"ë°˜ì ìœ¼ë¡œ ê° ëª¨ë“ˆì˜ ìƒë‹¨ì— ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì´ ì˜µë‹ˆë‹¤:"

#: src/modules/paths.md:11
msgid "Paths"
msgstr "ê²½ë¡œ"

#: src/modules/paths.md:13
msgid "Paths are resolved as follows:"
msgstr "ê²½ë¡œëŠ” ì•„ë˜ì™€ ê°™ì´ êµ¬ë¶„í•©ë‹ˆë‹¤:"

#: src/modules/paths.md:15
msgid "As a relative path:"
msgstr "ìƒëŒ€ ê²½ë¡œ:"

#: src/modules/paths.md:16
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` ë˜ëŠ” `self::foo`ëŠ” í˜„ì¬ ëª¨ë“ˆ ë‚´ë¶€ì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤,"

#: src/modules/paths.md:17
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "`super::foo`ëŠ” ë¶€ëª¨ ëª¨ë“ˆì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤."

#: src/modules/paths.md:19
msgid "As an absolute path:"
msgstr "ì ˆëŒ€ ê²½ë¡œ:"

#: src/modules/paths.md:20
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo`ëŠ” í˜„ì¬ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤,"

#: src/modules/paths.md:21
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "`bar::foo`ëŠ” `bar`í¬ë ˆì´íŠ¸ì˜ `foo`ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤."

#: src/modules/paths.md:25
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""
"ë” ì§§ì€ ê²½ë¡œì—ì„œ ê¸°í˜¸ë¥¼ 'ë‹¤ì‹œ ë‚´ë³´ë‚´ê¸°'í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í¬ë ˆ"
"ì´íŠ¸ì˜ ìµœìƒìœ„ `lib.rs`ëŠ”"

#: src/modules/paths.md:35
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""
"í¸ë¦¬í•˜ê³  ì§§ì€ ê²½ë¡œë¡œ ë‹¤ë¥¸ í¬ë ˆì´íŠ¸ì—ì„œ `DiskStorage` ë° `NetworkStorage`ë¥¼ ì‚¬"
"ìš©í•  ìˆ˜ ìˆë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/modules/paths.md:38
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ëª¨ë“ˆì— ë‚˜íƒ€ë‚˜ëŠ” í•­ëª©ë§Œ 'use' ì²˜ë¦¬ ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ íŠ¸ë ˆì‡"
"ì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì´ ì´ë¯¸ ë²”ìœ„ ë‚´ì— ìˆë”ë¼ë„ í•´ë‹¹ íŠ¸ë ˆì‡ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë ¤"
"ë©´ íŠ¸ë ˆì‡ì´ ë²”ìœ„ ë‚´ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `Read` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…"
"ì—ì„œ `read_to_string` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ `use std::io::Read`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆ"
"ë‹¤."

#: src/modules/paths.md:44
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""
"`use` ë¬¸ì—ëŠ” ì™€ì¼ë“œ ì¹´ë“œ(`use std::io::*`)ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ê°€ì ¸ì˜¤"
"ëŠ” í•­ëª©ì´ ëª…í™•í•˜ì§€ ì•Šê³  ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ë³€ê²½ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê¶Œì¥ë˜ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤."

#: src/modules/exercise.md:3
msgid ""
"In this exercise, you will reorganize the GUI Library exercise from the "
"\"Methods and Traits\" segment of the course into a collection of modules. "
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""
"ì´ ì—°ìŠµì—ì„œëŠ” 'ë©”ì„œë“œ ë° íŠ¸ë ˆì‡' ì„¸ê·¸ë¨¼íŠ¸ì˜ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—°ìŠµì„ ëª¨ë“ˆ ì»¬ë ‰ì…˜"
"ìœ¼ë¡œ ì¬êµ¬ì„±í•©ë‹ˆë‹¤. ê° íƒ€ì… ë˜ëŠ” ë°€ì ‘í•˜ê²Œ ê´€ë ¨ëœ íƒ€ì… ì§‘í•©ì„ ìì²´ ëª¨ë“ˆì— ë°°ì¹˜"
"í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë¯€ë¡œ ê° ìœ„ì ¯ íƒ€ì…ì€ ìì²´ ëª¨ë“ˆì„ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤."

#: src/modules/exercise.md:8
msgid ""
"If you no longer have your version, that's fine - refer back to the "
"[provided solution](../methods-and-traits/solution.html)."
msgstr ""
"ì˜ˆì „ì— ì‘ì—…í–ˆë˜ ë²„ì „ì´ ì—†ì–´ë„ ê´œì°®ìŠµë‹ˆë‹¤. [ì œê³µëœ ì†”ë£¨ì…˜](../methods-and-"
"traits/solution.html)ì„ ë‹¤ì‹œ ì°¸ê³ í•˜ì„¸ìš”."

#: src/modules/exercise.md:11
#, fuzzy
msgid "Cargo Setup"
msgstr "ì„¤ì¹˜"

#: src/modules/exercise.md:13
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""
"Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œëŠ” í•˜ë‚˜ì˜ íŒŒì¼ë§Œ ì§€ì›í•˜ë¯€ë¡œ ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œì— Cargo í”„ë¡œ"
"ì íŠ¸ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/modules/exercise.md:22
msgid ""
"Edit `src/main.rs` to add `mod` statements, and add additional files in the "
"`src` directory."
msgstr ""
"`src/main.rs`ë¥¼ ìˆ˜ì •í•˜ì—¬ `mod` ë¬¸ì„ ì¶”ê°€í•˜ê³  `src` ë””ë ‰í„°ë¦¬ì— íŒŒì¼ì„ ì¶”ê°€í•©ë‹ˆ"
"ë‹¤."

#: src/modules/exercise.md:27
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""
"í•™ìƒë“¤ì—ê²ŒëŠ” ë³¸ì¸ì—ê²Œ ìì—°ìŠ¤ëŸ¬ìš´ ë°©ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ë‚˜ëˆ„ë„ë¡ ê¶Œì¥í•˜ì„¸ìš”. ê·¸ë¦¬ê³ "
"ë‚˜ì„œ í•„ìš”í•œ `mod`, `use`, `pub` ì„ ì–¸ì— ìµìˆ™í•´ì§€ë„ë¡ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ì–´ë–¤ êµ¬"
"ì„±ì´ ê°€ì¥ ìì—°ìŠ¤ëŸ¬ìš´ì§€ ë…¼ì˜í•©ë‹ˆë‹¤."

#: src/modules/solution.md:30
msgid "// ---- src/widgets.rs ----\n"
msgstr "// ---- src/widgets.rs ----\n"

#: src/modules/solution.md:56
msgid "// ---- src/widgets/label.rs ----\n"
msgstr "// ---- src/widgets/label.rs ----\n"

#: src/modules/solution.md:71
msgid "// ANCHOR_END: Label-width\n"
msgstr "// ANCHOR_END: Label-width\n"

#: src/modules/solution.md:75
msgid "// ANCHOR: Label-draw_into\n"
msgstr "// ANCHOR: Label-draw_into\n"

#: src/modules/solution.md:77
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr "// ANCHOR_END: Label-draw_into\n"

#: src/modules/solution.md:84
msgid "// ---- src/widgets/button.rs ----\n"
msgstr "// ---- src/widgets/button.rs ----\n"

#: src/modules/solution.md:99
msgid "// ANCHOR_END: Button-width\n"
msgstr "// ANCHOR_END: Button-width\n"

#: src/modules/solution.md:103
msgid "// ANCHOR: Button-draw_into\n"
msgstr "// ANCHOR: Button-draw_into\n"

#: src/modules/solution.md:105
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr "// ANCHOR_END: Button-draw_into\n"

#: src/modules/solution.md:120
msgid "// ---- src/widgets/window.rs ----\n"
msgstr "// ---- src/widgets/window.rs ----\n"

#: src/modules/solution.md:147
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""
"// ANCHOR_END: Window-width\n"
"        // í…Œë‘ë¦¬ì— íŒ¨ë”© 4ê°œ ì¶”ê°€\n"

#: src/modules/solution.md:152
msgid "// ANCHOR: Window-draw_into\n"
msgstr "// ANCHOR: Window-draw_into\n"

#: src/modules/solution.md:154
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr "// ANCHOR_END: Window-draw_into\n"

#: src/modules/solution.md:177
msgid "// ---- src/main.rs ----\n"
msgstr "// ---- src/main.rs ----\n"

#: src/testing/unit-tests.md:1
msgid "Unit Tests"
msgstr "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸"

#: src/testing/unit-tests.md:3
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì™€ ì¹´ê³ (cargo)ëŠ” ê°„ë‹¨í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ì™€ í•¨ê»˜ ì œê³µë©ë‹ˆë‹¤:"

#: src/testing/unit-tests.md:5
msgid "Unit tests are supported throughout your code."
msgstr "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì½”ë“œ ì „ë°˜ì—ì„œ ì§€ì›ë©ë‹ˆë‹¤."

#: src/testing/unit-tests.md:7
msgid "Integration tests are supported via the `tests/` directory."
msgstr "í†µí•© í…ŒìŠ¤íŠ¸ëŠ” `tests/` ë””ë ‰í„°ë¦¬ë¥¼ í†µí•´ ì§€ì›ë©ë‹ˆë‹¤."

#: src/testing/unit-tests.md:9
#, fuzzy
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""
"í…ŒìŠ¤íŠ¸ëŠ” `#[test]`ë¡œ í‘œì‹œë©ë‹ˆë‹¤.  ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì¢…ì¢… ì¤‘ì²©ëœ `tests` ëª¨ë“ˆì— ë°°"
"ì¹˜ë˜ë©° í…ŒìŠ¤íŠ¸ë¥¼ ë¹Œë“œí•  ë•Œë§Œ `#[cfg(test)]`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¡°ê±´ë¶€ë¡œ ì»´íŒŒì¼í•©ë‹ˆë‹¤."

#: src/testing/unit-tests.md:37
#, fuzzy
msgid "\"Hello World\""
msgstr "Hello World!"

#: src/testing/unit-tests.md:42
msgid "This lets you unit test private helpers."
msgstr ""
"ì´ë ‡ê²Œ ì„œë¸Œ ëª¨ë“ˆë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“¤ë©´ privateí•œ í—¬í¼ í•¨ìˆ˜ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë„ "
"ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/testing/unit-tests.md:43
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"`#[cfg(test)]` ì–´íŠ¸ë¦¬ë·°íŠ¸ê°€ ì¶”ê°€ëœ í•­ëª©ì€ `cargo test`ë¥¼ ìˆ˜í–‰í–ˆì„ ê²½ìš°ì—ë§Œ ë™"
"ì‘í•©ë‹ˆë‹¤."

#: src/testing/unit-tests.md:47
msgid "Run the tests in the playground in order to show their results."
msgstr "í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì—¬ ê²°ê³¼ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

#: src/testing/other.md:3
msgid "Integration Tests"
msgstr "í†µí•© í…ŒìŠ¤íŠ¸"

#: src/testing/other.md:5
msgid "If you want to test your library as a client, use an integration test."
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©ì ì…ì¥ì—ì„œ í…ŒìŠ¤íŠ¸ í•˜ë ¤ë©´, í†µí•© í…ŒìŠ¤íŠ¸ë¥¼ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/testing/other.md:7
msgid "Create a `.rs` file under `tests/`:"
msgstr "`test/`ë””ë ‰í„°ë¦¬ ì•„ë˜ì— `.rs`íŒŒì¼ì„ í•˜ë‚˜ ë§Œë“œì„¸ìš”:"

#: src/testing/other.md:10
msgid "// tests/my_library.rs\n"
msgstr "// tests/my_library.rs\n"

#: src/testing/other.md:19
msgid "These tests only have access to the public API of your crate."
msgstr "ì´ í…ŒìŠ¤íŠ¸ëŠ” í¬ë ˆì´íŠ¸ì˜ ê³µê°œ APIì—ë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/testing/other.md:21
msgid "Documentation Tests"
msgstr "ë¬¸ì„œí™”ì£¼ì„ í…ŒìŠ¤íŠ¸"

#: src/testing/other.md:23
msgid "Rust has built-in support for documentation tests:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë¬¸ì„œí™”ì£¼ì„ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ë¥¼ ë‚´ì¥í•˜ì—¬ ì œê³µí•©ë‹ˆë‹¤:"

#: src/testing/other.md:26
#, fuzzy
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"

#: src/testing/other.md:38
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr "`///` ì£¼ì„ì•ˆì˜ ì½”ë“œ ë¸”ë¡ì€ ìë™ìœ¼ë¡œ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œë¡œ ì¸ì‹ë©ë‹ˆë‹¤."

#: src/testing/other.md:39
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "ì´ ì½”ë“œ ë¸”ë¡ì€ `cargo test` í˜¸ì¶œí•˜ë©´ ìë™ìœ¼ë¡œ ì»´íŒŒì¼ë˜ê³  ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/testing/other.md:40
#, fuzzy
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr "ì½”ë“œì— `# `ì„ ì¶”ê°€í•˜ë©´ ë¬¸ì„œì—ì„œëŠ” ìˆ¨ê²¨ì§€ì§€ë§Œ ì»´íŒŒì¼/ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/testing/other.md:42
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"ìœ„ ì½”ë“œë¥¼ [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)"
"ì—ì„œ í…ŒìŠ¤íŠ¸ í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/testing/useful-crates.md:3
msgid "Rust comes with only basic support for writing tests."
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” í…ŒìŠ¤íŠ¸ ì‘ì„±ê³¼ ê´€ë ¨í•´ì„œëŠ” ê¸°ë³¸ì ì¸ ê¸°ëŠ¥ë§Œ ì§€ì›í•©ë‹ˆë‹¤."

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr "ë‹¤ìŒì€ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•  ë•Œ ê¶Œì¥ë˜ëŠ” ì¶”ê°€ í¬ë ˆì´íŠ¸ì…ë‹ˆë‹¤:"

#: src/testing/useful-crates.md:7
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""
"[googletest](https://docs.rs/googletest): C++ìš© GoogleTestì˜ ë°©ì‹ì„ ë”°ë¥´ëŠ” í…Œ"
"ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì…ë‹ˆë‹¤."

#: src/testing/useful-crates.md:9
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr "[proptest](https://docs.rs/proptest): Rustìš© ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤."

#: src/testing/useful-crates.md:10
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""
"[rstest](https://docs.rs/rstest): í”½ìŠ¤ì²˜ ë° ë§¤ê°œë³€ìˆ˜í™”ëœ í…ŒìŠ¤íŠ¸ë¥¼ ì§€ì›í•©ë‹ˆë‹¤."

#: src/testing/googletest.md:3
#, fuzzy
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"[googletest](https://docs.rs/googletest): C++ìš© GoogleTestì˜ ë°©ì‹ì„ ë”°ë¥´ëŠ” í…Œ"
"ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì…ë‹ˆë‹¤."

#: src/testing/googletest.md:11
msgid "\"baz\""
msgstr "\"baz\""

#: src/testing/googletest.md:12
msgid "\"xyz\""
msgstr "\"xyz\""

#: src/testing/googletest.md:16
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""
"ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ `'!'`ë¡œ ë³€ê²½í•˜ë©´ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í•˜ê³  ì˜¤ë¥˜ë¥¼ ì •í™•íˆ ê°€ë¦¬í‚¤ëŠ” êµ¬ì¡°"
"í™”ëœ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ í‘œì‹œë©ë‹ˆë‹¤."

#: src/testing/googletest.md:36
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""
"GoogleTestëŠ” Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œì˜ ì¼ë¶€ê°€ ì•„ë‹ˆë¯€ë¡œ ë¡œì»¬ í™˜ê²½ì—ì„œ ì´ ì˜ˆë¥¼ ì‹¤í–‰"
"í•´ì•¼ í•©ë‹ˆë‹¤. `cargo add googletest`ë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ì¡´ Cargo í”„ë¡œì íŠ¸ì— ë¹ ë¥´ê²Œ "
"ì¶”ê°€í•˜ì„¸ìš”."

#: src/testing/googletest.md:40
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""
"`use googletest::prelude::*;` ì¤„ì€ [ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë§¤í¬ë¡œ ë° íƒ€ì…]"
"(https://docs.rs/googletest/latest/googletest/prelude/index.html)ì„ ì—¬ëŸ¬ ê°œ "
"ê°€ì ¸ì˜µë‹ˆë‹¤."

#: src/testing/googletest.md:43
msgid "This just scratches the surface, there are many builtin matchers."
msgstr "ì´ëŠ” ì¼ë¶€ì¼ ë¿ì´ë©° ë‚´ì¥ëœ ë§¤ì²˜ê°€ ë§ì´ ìˆìŠµë‹ˆë‹¤."

#: src/testing/googletest.md:45
msgid ""
"A particularly nice feature is that mismatches in multi-line strings strings "
"are shown as a diff:"
msgstr "íŠ¹íˆ ì¢‹ì€ ê¸°ëŠ¥ì€ ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´ì˜ ë¶ˆì¼ì¹˜ê°€ diffë¡œ í‘œì‹œëœë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/testing/googletest.md:51
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""
"\"Memory safete found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""

#: src/testing/googletest.md:56
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""

#: src/testing/googletest.md:63
msgid "shows a color-coded diff (colors not shown here):"
msgstr ""
"ìƒ‰ìƒìœ¼ë¡œ êµ¬ë¶„ëœ diffë¥¼ í‘œì‹œí•©ë‹ˆë‹¤(ì—¬ê¸°ì—ì„œëŠ” ìƒ‰ìƒì´ í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤)."

#: src/testing/googletest.md:80
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""
"í¬ë ˆì´íŠ¸ëŠ” [C++ìš© GoogleTest](https://google.github.io/googletest/)ì˜ Rust í¬"
"íŠ¸ì…ë‹ˆë‹¤."

#: src/testing/googletest.md:85
msgid "GoogleTest is available for use in AOSP."
msgstr "GoogleTestëŠ” AOSPì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/testing/mocking.md:3
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""
"ëª¨ì˜ ì²˜ë¦¬ì˜ ê²½ìš° ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ [Mockall](https://docs.rs/"
"mockall/)ì´ ìˆìŠµë‹ˆë‹¤. íŠ¸ë ˆì‡ì„ ì‚¬ìš©í•˜ë„ë¡ ì½”ë“œë¥¼ ë¦¬íŒ©í„°ë§í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤"
"ìŒ ë¹ ë¥´ê²Œ ëª¨ì˜ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/testing/mocking.md:26
msgid ""
"The advice here is for Android (AOSP) where Mockall is the recommended "
"mocking library. There are other [mocking libraries available on crates.io]"
"(https://crates.io/keywords/mock), in particular in the area of mocking HTTP "
"services. The other mocking libraries work in a similar fashion as Mockall, "
"meaning that they make it easy to get a mock implementation of a given trait."
msgstr ""
"ì´ ê¶Œì¥ì‚¬í•­ì€ Mockallì´ ê¶Œì¥ë˜ëŠ” ëª¨ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ Android(AOSP)ë¥¼ ìœ„í•œ ê²ƒì…"
"ë‹ˆë‹¤. íŠ¹íˆ HTTP ì„œë¹„ìŠ¤ë¥¼ ëª¨ì˜ ì²˜ë¦¬í•˜ëŠ” ì˜ì—­ì—ëŠ” ë‹¤ë¥¸ [crates.ioì—ì„œ ì‚¬ìš© ê°€ëŠ¥"
"í•œ ëª¨ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬](https://crates.io/keywords/mock)ê°€ ìˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ëª¨ì˜ ë¼"
"ì´ë¸ŒëŸ¬ë¦¬ëŠ” Mockallê³¼ ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤. ì¦‰, íŠ¹ì • íŠ¸ë ˆì‡ì˜ ëª¨ì˜ êµ¬í˜„"
"ì„ ì‰½ê²Œ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/testing/mocking.md:33
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""
"ëª¨ì˜ ì²˜ë¦¬ëŠ” ë‹¤ì†Œ _ë…¼ë€ì˜ ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤_. ëª¨ì˜ë¥¼ ì‚¬ìš©í•˜ë©´ í…ŒìŠ¤íŠ¸ë¥¼ ì¢…ì† í•­ëª©"
"ì—ì„œ ì™„ì „íˆ ë¶„ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ ê²°ê³¼ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ì´ ë”ìš± ë¹ ë¥´ê³  ì•ˆì •ì ìœ¼ë¡œ "
"ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ë°˜ë©´ì— ëª¨ì˜ëŠ” ì˜ëª» êµ¬ì„±ë˜ì–´ ì‹¤ì œ ì¢…ì† í•­ëª©ì´ ì‹¤í–‰í•˜ëŠ” ê²ƒê³¼ ë‹¤"
"ë¥¸ ì¶œë ¥ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/testing/mocking.md:38
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""
"ê°€ëŠ¥í•˜ë©´ ì‹¤ì œ ì¢…ì† í•­ëª©ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ë§ì€ ë°ì´í„°ë² ì´ìŠ¤"
"ì—ì„œëŠ” ë©”ëª¨ë¦¬ ë‚´ ë°±ì—”ë“œë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¦‰, í…ŒìŠ¤íŠ¸ì—ì„œ ì˜¬ë°”ë¥¸ ë™ì‘ì„ ê°€"
"ì ¸ì˜¬ ë¿ë§Œ ì•„ë‹ˆë¼ ì†ë„ê°€ ë¹ ë¥´ê³  ìë™ìœ¼ë¡œ ì •ë¦¬ë©ë‹ˆë‹¤."

#: src/testing/mocking.md:43
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""
"ë§ˆì°¬ê°€ì§€ë¡œ ë§ì€ ì›¹ í”„ë ˆì„ì›Œí¬ì—ì„œë„ `localhost`ì˜ ì„ì˜ í¬íŠ¸ì— ë°”ì¸ë”©ë˜ëŠ” í”„ë¡œ"
"ì„¸ìŠ¤ ë‚´ ì„œë²„ë¥¼ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í”„ë ˆì„ì›Œí¬ë¥¼ ëª¨ì˜ ì²˜ë¦¬í•˜ëŠ” ê²ƒë³´ë‹¤ëŠ” í•­ìƒ "
"ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ì‹¤ì œ í™˜ê²½ì—ì„œ ì½”ë“œë¥¼ í…ŒìŠ¤íŠ¸í•˜ëŠ” ë° ë„ì›€ì´ "
"ë©ë‹ˆë‹¤."

#: src/testing/mocking.md:47
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""
"Mockallì€ Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œì˜ ì¼ë¶€ê°€ ì•„ë‹ˆë¯€ë¡œ ë¡œì»¬ í™˜ê²½ì—ì„œ ì´ ì˜ˆë¥¼ ì‹¤í–‰í•´"
"ì•¼ í•©ë‹ˆë‹¤. Mockallì„ ê¸°ì¡´ Cargo í”„ë¡œì íŠ¸ì— ë¹ ë¥´ê²Œ ì¶”ê°€í•˜ë ¤ë©´ `cargo add "
"mockall`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/testing/mocking.md:51
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""
"Mockallì—ëŠ” ë” ë§ì€ ê¸°ëŠ¥ì´ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ ì „ë‹¬ëœ ì¸ìˆ˜ì— ë”°ë¼ ê¸°ëŒ€ì¹˜ë¥¼ ì„¤ì •í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ë§ˆì§€ë§‰ìœ¼ë¡œ ë¨¹ì´ë¥¼ ë¨¹ê³  3ì‹œê°„ì´ ì§€ë‚˜ë©´ ë°°ê³ íŒŒì§€ëŠ” ê³ ì–‘ì´"
"ë¥¼ ëª¨ì˜í•˜ëŠ” ë° ì´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/testing/mocking.md:69
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""
"`.times(n)`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ì˜ ë©”ì„œë“œê°€ í˜¸ì¶œë  ìˆ˜ ìˆëŠ” íšŸìˆ˜ë¥¼ `n`ìœ¼ë¡œ ì œí•œí•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì´ ì¡°ê±´ì´ ì¶©ì¡±ë˜ì§€ ì•Šìœ¼ë©´ ëª¨ì˜ ë©”ì„œë“œê°€ ì‚­ì œë  ë•Œ ìë™ìœ¼ë¡œ íŒ¨ë‹‰ ìƒ"
"íƒœê°€ ë©ë‹ˆë‹¤."

#: src/testing/lints.md:3
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""
"Rust ì»´íŒŒì¼ëŸ¬ëŠ” ìœ ìš©í•œ ë‚´ì¥ ë¦°íŠ¸ë¿ ì•„ë‹ˆë¼ ë©‹ì§„ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. "
"[Clippy](https://doc.rust-lang.org/clippy/)ëŠ” í”„ë¡œì íŠ¸ë³„ë¡œ ì‚¬ìš© ì„¤ì •í•  ìˆ˜ ìˆ"
"ëŠ” ê·¸ë£¹ìœ¼ë¡œ êµ¬ì„±ëœ ë” ë§ì€ ë¦°íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/testing/lints.md:14
msgid "\"X probably fits in a u16, right? {}\""
msgstr "\"XëŠ” u16ì— ë§ì§€ ì•Šì„ê¹Œìš”? {}\""

#: src/testing/lints.md:20
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""
"ì½”ë“œ ìƒ˜í”Œì„ ì‹¤í–‰í•˜ê³  ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤. ì—¬ê¸°ì—ë„ ë¦°íŠ¸ê°€ í‘œì‹œë˜ì§€ë§Œ ì½”"
"ë“œê°€ ì»´íŒŒì¼ë˜ê³  ë‚˜ë©´ í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì‚¬ì´íŠ¸ë¡œ ì „í™˜í•˜ì—¬ ì´ëŸ¬"
"í•œ ë¦°íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

#: src/testing/lints.md:24
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""
"ë¦°íŠ¸ë¥¼ í•´ê²°í•œ í›„ í”Œë ˆì´ê·¸ë¼ìš´ë“œ ì‚¬ì´íŠ¸ì—ì„œ `clippy`ë¥¼ ì‹¤í–‰í•˜ì—¬ clippy ê²½ê³ ë¥¼ "
"í‘œì‹œí•©ë‹ˆë‹¤. ClippyëŠ” ë¦°íŠ¸ì— ê´€í•œ ê´‘ë²”ìœ„í•œ ë¬¸ì„œë¥¼ ë³´ìœ í•˜ê³  ìˆìœ¼ë©° í•­ìƒ ìƒˆë¡œìš´ "
"ë¦°íŠ¸(default-deny ë¦°íŠ¸ í¬í•¨)ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤."

#: src/testing/lints.md:28
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""
"`help: ...`ê°€ í¬í•¨ëœ ì˜¤ë¥˜ë‚˜ ê²½ê³ ëŠ” `cargo fix` ë˜ëŠ” í¸ì§‘ê¸°ë¥¼ í†µí•´ ìˆ˜ì •í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤."

#: src/testing/exercise.md:3
msgid "Luhn Algorithm"
msgstr "ë£¬ ì•Œê³ ë¦¬ì¦˜"

#: src/testing/exercise.md:5
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[ë£¬(Luhn) ì•Œê³ ë¦¬ì¦˜](https://ko.wikipedia.org/wiki/"
"%EB%A3%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)ì€ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ ê²€ì¦ì— ì‚¬ìš©ë˜"
"ëŠ” ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤. ì´ ì•Œê³ ë¦¬ì¦˜ì€ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ë¥¼ `ë¬¸ìì—´`ë¡œ ì…ë ¥ë°›ê³ , ì•„ë˜"
"ì˜ ìˆœì„œì— ë”°ë¼ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ì˜ ìœ íš¨ì„±ì„ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/testing/exercise.md:9
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr "ëª¨ë“  ê³µë°±ì„ ë¬´ì‹œí•©ë‹ˆë‹¤. 2ìë¦¬ ë¯¸ë§Œ ìˆ«ìëŠ” ë¬´ì‹œí•©ë‹ˆë‹¤."

#: src/testing/exercise.md:11
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"**ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ** ì´ë™í•˜ë©° 2ë²ˆì§¸ ìë¦¬ë§ˆë‹¤ ìˆ«ìë¥¼ 2ë°° ì¦ê°€ì‹œí‚µë‹ˆë‹¤. ì˜ˆ"
"ë¥¼ ë“¤ì–´ `1234`ì—ì„œ `3`ê³¼ `1`ì— ê°ê° 2ë¥¼ ê³±í•©ë‹ˆë‹¤."

#: src/testing/exercise.md:14
#, fuzzy
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"ë‘ë°°ë¡œ ë§Œë“  ìˆ«ìê°€ 2ìë¦¬ë¼ë©´ ê° ìë¦¬ ìˆ«ìë¥¼ ë”í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `7`ì€ ë‘ë°°"
"ë¡œ ë§Œë“¤ë©´ `14`ì´ë¯€ë¡œ `5`ê°€ ë©ë‹ˆë‹¤."

#: src/testing/exercise.md:17
msgid "Sum all the undoubled and doubled digits."
msgstr "ëª¨ë“  ìë¦¬ì˜ ìˆ«ìë¥¼ ë”í•©ë‹ˆë‹¤."

#: src/testing/exercise.md:19
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "í•©ê³„ì˜ ëìë¦¬ê°€ `0`ì¸ ê²½ìš° ìœ íš¨í•œ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ì…ë‹ˆë‹¤."

#: src/testing/exercise.md:21
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most the algorithm is "
"implemented correctly."
msgstr ""
"ì œê³µëœ ì½”ë“œëŠ” ëŒ€ë¶€ë¶„ì˜ ì•Œê³ ë¦¬ì¦˜ì´ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë‘ ê°€ì§€ ê¸°"
"ë³¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì™€ í•¨ê»˜ luhn ì•Œê³ ë¦¬ì¦˜ì˜ ë²„ê·¸ê°€ ìˆëŠ” êµ¬í˜„ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/testing/exercise.md:25
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  ë¹ ì§„ í•¨ìˆ˜ì™€ ë©”ì„œë“œë¥¼ ì±„"
"ì›Œë´…ë‹ˆë‹¤:"

#: src/testing/exercise.md:57 src/testing/solution.md:69
msgid "\"4263 9826 4026 9299\""
msgstr "\"4263 9826 4026 9299\""

#: src/testing/exercise.md:58 src/testing/solution.md:70
msgid "\"4539 3195 0343 6467\""
msgstr "\"4539 3195 0343 6467\""

#: src/testing/exercise.md:59 src/testing/solution.md:71
msgid "\"7992 7398 713\""
msgstr "\"7992 7398 713\""

#: src/testing/exercise.md:64 src/testing/solution.md:76
msgid "\"4223 9826 4026 9299\""
msgstr "\"4223 9826 4026 9299\""

#: src/testing/exercise.md:65 src/testing/solution.md:77
msgid "\"4539 3195 0343 6476\""
msgstr "\"4539 3195 0343 6476\""

#: src/testing/exercise.md:66 src/testing/solution.md:78
msgid "\"8273 1232 7352 0569\""
msgstr "\"8273 1232 7352 0569\""

#: src/testing/solution.md:4
msgid "// This is the buggy version that appears in the problem.\n"
msgstr "// ë¬¸ì œì— í‘œì‹œë˜ëŠ” ë²„ê·¸ê°€ ìˆëŠ” ë²„ì „ì…ë‹ˆë‹¤.\n"

#: src/testing/solution.md:27
msgid "// This is the solution and passes all of the tests below.\n"
msgstr "// ì†”ë£¨ì…˜ì´ë©° ì•„ë˜ì˜ ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•©ë‹ˆë‹¤.\n"

#: src/testing/solution.md:56
msgid "\"1234 5678 1234 5670\""
msgstr "\"1234 5678 1234 5670\""

#: src/testing/solution.md:58
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr "\"{cc_number}ì€(ëŠ”) ìœ íš¨í•œ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ì¸ê°€ìš”? {}\""

#: src/testing/solution.md:59
msgid "\"yes\""
msgstr "\"ì˜ˆ\""

#: src/testing/solution.md:59
msgid "\"no\""
msgstr "\"ì•„ë‹ˆìš”\""

#: src/testing/solution.md:84
msgid "\"foo 0 0\""
msgstr "\"foo 0 0\""

#: src/testing/solution.md:90
msgid "\" \""
msgstr "\" \""

#: src/testing/solution.md:91
msgid "\"  \""
msgstr "\"  \""

#: src/testing/solution.md:92
msgid "\"    \""
msgstr "\"    \""

#: src/testing/solution.md:97
msgid "\"0\""
msgstr "\"0\""

#: src/testing/solution.md:102
msgid "\" 0 0 \""
msgstr "\" 0 0 \""

#: src/error-handling/panics.md:3
msgid "Rust handles fatal errors with a \"panic\"."
msgstr "RustëŠ” 'íŒ¨ë‹‰'ìœ¼ë¡œ ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤."

#: src/error-handling/panics.md:5
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ìˆ˜í–‰ ì¤‘ ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ë¥¼ ë§Œë‚˜ë©´ íŒ¨ë‹‰ì„ ë°œìƒí•  ê²ƒì…ë‹ˆë‹¤:"

#: src/error-handling/panics.md:10
msgid "\"v[100]: {}\""
msgstr "\"v[100]: {}\""

#: src/error-handling/panics.md:14
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "íŒ¨ë‹‰ì€ ë³µêµ¬í•  ìˆ˜ ì—†ê³  ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ì…ë‹ˆë‹¤."

#: src/error-handling/panics.md:15
msgid "Panics are symptoms of bugs in the program."
msgstr "íŒ¨ë‹‰ì€ í”„ë¡œê·¸ë¨ì— ë²„ê·¸ê°€ ìˆë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/error-handling/panics.md:16
msgid "Runtime failures like failed bounds checks can panic"
msgstr "ê²½ê³„ ê²€ì‚¬ ì‹¤íŒ¨ì™€ ê°™ì€ ëŸ°íƒ€ì„ ì‹¤íŒ¨ë¡œ ì¸í•´ íŒ¨ë‹‰ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/panics.md:17
msgid "Assertions (such as `assert!`) panic on failure"
msgstr "ì‹¤íŒ¨ ì‹œ ì–´ì„¤ì…˜(ì˜ˆ: `assert!`) íŒ¨ë‹‰"

#: src/error-handling/panics.md:18
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr "ëª©ì ë³„ íŒ¨ë‹‰ì€ `panic!` ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/panics.md:19
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr "íŒ¨ë‹‰ì€ ìŠ¤íƒì„ 'í•´ì œ'í•˜ì—¬ í•¨ìˆ˜ê°€ ë°˜í™˜ëœ ê²ƒì²˜ëŸ¼ ê°’ì„ ì‚­ì œí•©ë‹ˆë‹¤."

#: src/error-handling/panics.md:21
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"ì¶©ëŒ(í¬ë˜ì‹œ)ì„ í—ˆìš©í•˜ì§€ ì•Šì•„ì•¼ í•˜ëŠ” ê²½ìš°, íŒ¨ë‹‰ì„ ìœ ë°œí•˜ì§€ ì•ŠëŠ” API(`Vec::get`"
"ë“±)ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/error-handling/panics.md:25
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"ê¸°ë³¸ì ìœ¼ë¡œ, íŒ¨ë‹‰ì´ ë°œìƒí•˜ë©´ ìŠ¤íƒ ë˜ê°ê¸°ë¥¼ í•©ë‹ˆë‹¤. ìŠ¤íƒ ë˜ê°ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ì´ "
"ìºì¹˜ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/error-handling/panics.md:31
msgid "\"No problem here!\""
msgstr "\"ê´œì°®ìŠµë‹ˆë‹¤.\""

#: src/error-handling/panics.md:32 src/error-handling/panics.md:37
msgid "\"{result:?}\""
msgstr "\"{result:?}\""

#: src/error-handling/panics.md:35
msgid "\"oh no!\""
msgstr "\"ì´ëŸ°\""

#: src/error-handling/panics.md:41
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr ""
"í¬ì°©ì€ í”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `catch_unwind`ë¡œ ì˜ˆì™¸ë¥¼ êµ¬í˜„í•˜ë ¤ê³  ì‹œë„í•˜ì§€ ë§ˆì„¸ìš”."

#: src/error-handling/panics.md:43
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"ì´ê²ƒì€ ë‹¨ì¼ ìš”ì²­ì´ í¬ë˜ì‹œ ë˜ë”ë¼ë„ í”„ë¡œê·¸ë¨ì´ ê³„ì† ì‹¤í–‰ë˜ì•¼ í•˜ëŠ” ì„œë²„ì— ìœ ìš©"
"í•©ë‹ˆë‹¤."

#: src/error-handling/panics.md:45
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"ë§Œì•½ `Cargo.toml`ì„¤ì •íŒŒì¼ì— `panic = abort`ì„ ì„¤ì •í–ˆë‹¤ë©´ í¬ë˜ì‹œë¥¼ ìºì¹˜í•  ìˆ˜ "
"ì—†ìŠµë‹ˆë‹¤."

#: src/error-handling/try.md:3
#, fuzzy
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"ì—°ê²° ê±°ë¶€ ë˜ëŠ” íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒê³¼ ê°™ì€ ëŸ°íƒ€ì„ ì˜¤ë¥˜ëŠ” `Result` íƒ€ì…ìœ¼ë¡œ ì²˜"
"ë¦¬ë˜ì§€ë§Œ ëª¨ë“  í˜¸ì¶œì—ì„œ ì´ íƒ€ì…ì„ ì¼ì¹˜ì‹œí‚¤ëŠ” ê²ƒì€ ë²ˆê±°ë¡œìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  try "
"ì—°ì‚°ì `?`ëŠ” í˜¸ì¶œìì—ê²Œ ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì¼ë°˜ì ì¸"

#: src/error-handling/try.md:15
msgid "into the much simpler"
msgstr "ì´ë ‡ê²Œ ì§§ê²Œ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/error-handling/try.md:21
msgid "We can use this to simplify our error handling code:"
msgstr "ì´ì œ ìš°ë¦¬ ì˜ˆì œì— ì ìš©í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/error-handling/try.md:42
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"alice\").unwrap();\n"

#: src/error-handling/try.md:43 src/error-handling/try-conversions.md:65
#: src/error-handling/thiserror-and-anyhow.md:33
msgid "\"config.dat\""
msgstr "\"config.dat\""

#: src/error-handling/try.md:44 src/error-handling/try-conversions.md:66
msgid "\"username or error: {username:?}\""
msgstr "\"ì‚¬ìš©ì ì´ë¦„ ë˜ëŠ” ì˜¤ë¥˜: {username:?}\""

#: src/error-handling/try.md:50
msgid "Simplify the `read_username` function to use `?`."
msgstr "`?`ë¥¼ ì‚¬ìš©í•˜ë„ë¡ `read_username` í•¨ìˆ˜ë¥¼ ë‹¨ìˆœí™”í•©ë‹ˆë‹¤."

#: src/error-handling/try.md:54
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "`username` ë³€ìˆ˜ëŠ” `Ok(string)`ì´ê±°ë‚˜ `Err(error)`ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/try.md:55
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"`fs::write` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ íŒŒì¼ì´ ì—†ê±°ë‚˜, ë¹„ì—ˆê±°ë‚˜, ì¤‘ë³µë˜ëŠ” ê²½ìš° ë“±ì„ í…Œ"
"ìŠ¤íŠ¸í•´ ë´…ë‹ˆë‹¤."

#: src/error-handling/try.md:57
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process:Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""
"`main`ì€ `std::process:Termination`ì„ êµ¬í˜„í•˜ëŠ” í•œ `Result<(), E>`ë¥¼ ë°˜í™˜í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹¤ì œë¡œëŠ” `E`ê°€ `Debug`ë¥¼ êµ¬í˜„í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì‹¤í–‰ íŒŒì¼"
"ì€ `Err` ë³€í˜•ì„ ì¶œë ¥í•˜ê³  ì˜¤ë¥˜ ë°œìƒ ì‹œ 0ì´ ì•„ë‹Œ ì¢…ë£Œ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/error-handling/try-conversions.md:3
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr "ì‹¤ì œë¡œ `?`ê°€ ì ìš©ë˜ëŠ” ê³¼ì •ì€ ì•„ê¹Œ ì„¤ëª…í•œ ê²ƒ ë³´ë‹¤ ì¢€ ë” ë³µì¡í•©ë‹ˆë‹¤:"

#: src/error-handling/try-conversions.md:10
msgid "works the same as"
msgstr "ìœ„ í‘œí˜„ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤"

#: src/error-handling/try-conversions.md:19
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"`From::from`ì„ í†µí•´ ì›ë˜ì˜ ì—ëŸ¬ íƒ€ì…ì„ ì´ í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ ë³€í™˜"
"í•˜ê³  ìˆìŠµë‹ˆë‹¤:"

#: src/error-handling/try-conversions.md:42
msgid "\"IO error: {e}\""
msgstr "\"IO ì˜¤ë¥˜: {e}\""

#: src/error-handling/try-conversions.md:43
#, fuzzy
msgid "\"Found no username in {path}\""
msgstr "\"{0}ì—ì„œ ì‚¬ìš©ì ì´ë¦„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\""

#: src/error-handling/try-conversions.md:64
#: src/error-handling/thiserror-and-anyhow.md:32
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/try-conversions.md:72
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""

#: src/error-handling/try-conversions.md:78
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""
"`From` êµ¬í˜„ì˜ ì¼ë°˜ì ì¸ ëŒ€ì•ˆì€ íŠ¹íˆ ë³€í™˜ì´ í•œ ê³³ì—ì„œë§Œ ë°œìƒí•˜ëŠ” ê²½ìš° `Result::"
"map_err`ì…ë‹ˆë‹¤."

#: src/error-handling/try-conversions.md:81
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""

#: src/error-handling/try-conversions.md:85
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""

#: src/error-handling/error.md:1
msgid "Dynamic Error Types"
msgstr "ë™ì ì¸ ì—ëŸ¬ íƒ€ì…"

#: src/error-handling/error.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"ë•Œë•Œë¡œ ìš°ë¦¬ëŠ”, ë°œìƒ ê°€ëŠ¥í•œ ëª¨ë“  ì—ëŸ¬ë¥¼ ì¼ì¼íˆ ì—´ê±°í•˜ì§€ ì•Šê³ , ì–´ë–¤ ì¢…ë¥˜ì˜ ì—ëŸ¬"
"ë¼ë„ ìƒê´€ì—†ì´ ë¦¬í„´í•˜ê³  ì‹¶ì„ ë•Œê°€ ìˆìŠµë‹ˆë‹¤. `std::error::Error`ë¥¼ ì´ìš©í•˜ë©´ ì‰½"
"ìŠµë‹ˆë‹¤."

#: src/error-handling/error.md:20 src/error-handling/error.md:21
msgid "\"count.dat\""
msgstr "\"count.dat\""

#: src/error-handling/error.md:20
msgid "\"1i3\""
msgstr "\"1i3\""

#: src/error-handling/error.md:22
msgid "\"Count: {count}\""
msgstr "\"ê°œìˆ˜: {count}\""

#: src/error-handling/error.md:23
msgid "\"Error: {err}\""
msgstr "\"ì˜¤ë¥˜: {err}\""

#: src/error-handling/error.md:30
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""
"`read_count` í•¨ìˆ˜ëŠ” `std::io::Error`(íŒŒì¼ ì‘ì—…ì—ì„œ) ë˜ëŠ” `std::num::"
"ParseIntError`(`String::parse`ì—ì„œ)ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/error.md:33
#, fuzzy
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"ì´ë ‡ê²Œ í•˜ë©´ ì½”ë“œì˜ ì–‘ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì„œë¡œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì—ëŸ¬ë¥¼ êµ¬ë³„"
"í•˜ì—¬ ë‹¤ë¥´ê²Œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•´ ì§‘ë‹ˆë‹¤. ë•Œë¬¸ì—, `Box<dyn Error>`ë¥¼ ë¼ì´ë¸Œ"
"ëŸ¬ë¦¬ì˜ APIë¡œ ë…¸ì¶œí•˜ëŠ”ê²Œ ì¢‹ì€ ë””ìì¸ì€ ì•„ë‹™ë‹ˆë‹¤. ì—ëŸ¬ ë°œìƒ ì‹œ, ê·¸ì € ì—ëŸ¬ ë©”ì‹œ"
"ì§€ë¥¼ ì¶œë ¥í•˜ê³  ì‹¶ì€ ê²½ìš°ì™€ ê°™ì´ ì œí•œëœ ìƒí™©ì—ì„œëŠ” ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/error.md:39
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:3
#, fuzzy
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling. `thiserror` "
"helps create custom error types that implement `From<T>`. `anyhow` helps "
"with error handling in functions, including adding contextual information to "
"your errors."
msgstr ""
"[`thiserror`](https://docs.rs/thiserror/) ë° [`anyhow`](https://docs.rs/"
"anyhow/) í¬ë ˆì´íŠ¸ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ë‹¨ìˆœí™”í•˜ëŠ” ë° ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤. `thiserror`ëŠ” "
"`From<T>`ë¥¼ êµ¬í˜„í•˜ëŠ” ë§ì¶¤ ì˜¤ë¥˜ íƒ€ì…ì„ ë§Œë“œëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. `anyhow`ë¥¼ ì‚¬"
"ìš©í•˜ë©´ ì˜¤ë¥˜ì— ì»¨í…ìŠ¤íŠ¸ ì •ë³´ë¥¼ ì¶”ê°€í•˜ëŠ” ë“± í•¨ìˆ˜ì˜ ì˜¤ë¥˜ ì²˜ë¦¬ì— ë„ì›€ì´ ë©ë‹ˆë‹¤."

#: src/error-handling/thiserror-and-anyhow.md:16
msgid "\"Found no username in {0}\""
msgstr "\"{0}ì—ì„œ ì‚¬ìš©ì ì´ë¦„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\""

#: src/error-handling/thiserror-and-anyhow.md:22
msgid "\"Failed to open {path}\""
msgstr "\"{path}ì„(ë¥¼) ì—´ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\""

#: src/error-handling/thiserror-and-anyhow.md:24
msgid "\"Failed to read\""
msgstr "\"ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\""

#: src/error-handling/thiserror-and-anyhow.md:34
msgid "\"Username: {username}\""
msgstr "\"ì‚¬ìš©ì ì´ë¦„: {username}\""

#: src/error-handling/thiserror-and-anyhow.md:35
msgid "\"Error: {err:?}\""
msgstr "\"ì˜¤ë¥˜: {err:?}\""

#: src/error-handling/thiserror-and-anyhow.md:42
#, fuzzy
msgid "`thiserror`"
msgstr "`Error`"

#: src/error-handling/thiserror-and-anyhow.md:44
#, fuzzy
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""
"`Error` íŒŒìƒ ë§¤í¬ë¡œëŠ” `thiserror`ì—ì„œ ì œê³µí•˜ë©° ìœ ìš©í•œ ì˜¤ë¥˜ íƒ€ì…ì„ ì •ì˜í•˜ëŠ” "
"ë° ë„ì›€ì´ ë˜ëŠ” `#[error]`ì™€ ê°™ì€ ìœ ìš©í•œ ì†ì„±ì´ ë§ìŠµë‹ˆë‹¤."

#: src/error-handling/thiserror-and-anyhow.md:46
msgid "The `std::error::Error` trait is derived automatically."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:47
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:49
msgid "`anyhow`"
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md:51
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"`anyhow::Error`ëŠ” `Box<dyn Error>`ì˜ ë˜í¼ íƒ€ì…ì´ë¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë¼"
"ì´ë¸ŒëŸ¬ë¦¬ì˜ ê³µê°œ APIë¡œì„œ ì‚¬ìš©í•˜ê¸°ì— ë¶€ì í•©í•˜ë‹¤ê³  í•  ìˆ˜ ìˆì§€ë§Œ ë§ì€ ì• í”Œë¦¬ì¼€ì´"
"ì…˜ì— ë„ë¦¬ ì‚¬ìš©ë˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/error-handling/thiserror-and-anyhow.md:54
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"`anyhow::Result<V>`ëŠ” `Result<V, anyhow::Error>`ì˜ íƒ€ì… ì•¨ë¦¬ì–´ìŠ¤(alias)ì…ë‹ˆ"
"ë‹¤."

#: src/error-handling/thiserror-and-anyhow.md:55
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"í•„ìš”í•˜ë‹¤ë©´ `anyhow::Error`ì— ì €ì¥ëœ ì§„ì§œ ì—ëŸ¬ íƒ€ì…ì„ êº¼ë‚´ì–´ ê²€ì‚¬í•  ìˆ˜ë„ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/error-handling/thiserror-and-anyhow.md:56
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"`anyhow::Result<T>`ê°€ ì œê³µí•˜ëŠ” ê¸°ëŠ¥ë“¤ì´ Go ì–¸ì–´ ê°œë°œìë“¤ì—ê²ŒëŠ” ìµìˆ™í•  ê²ƒì…ë‹ˆ"
"ë‹¤. Goì–¸ì–´ì—ì„œ ë°˜í™˜ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” `(T, error)` íŒ¨í„´ê³¼ ë¹„ìŠ·í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/error-handling/thiserror-and-anyhow.md:59
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""

#: src/error-handling/exercise.md:1
#, fuzzy
msgid "Exercise: Rewriting with Result"
msgstr "ì—°ìŠµë¬¸ì œ: ê²°ê³¼ë¡œ ë‹¤ì‹œ ì‘ì„±"

#: src/error-handling/exercise.md:3
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""
"ë‹¤ìŒì€ í‘œí˜„ì‹ ì–¸ì–´ì˜ ë§¤ìš° ê°„ë‹¨í•œ íŒŒì„œë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ íŒ¨ë‹‰ì„ í†µí•´ ì˜¤ë¥˜"
"ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤. ëŒ€ì‹  ê´€ìš©ì ì¸ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ì‚¬ìš©í•˜ê³  ì˜¤ë¥˜ë¥¼ `main`ì˜ ë°˜í™˜ìœ¼ë¡œ ì „"
"íŒŒí•˜ë„ë¡ ë‹¤ì‹œ ì‘ì„±í•©ë‹ˆë‹¤. `thiserror` ë° `anyhow`ë¥¼ ì–¼ë§ˆë“ ì§€ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/error-handling/exercise.md:8
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""
"íŒíŠ¸: ë¨¼ì € `parse` í•¨ìˆ˜ì—ì„œ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìˆ˜ì •í•˜ì„¸ìš”. ì œëŒ€ë¡œ ì‘ë™í•˜ë©´ "
"`Iterator<Item=Result<Token, TokenizerError>>`ë¥¼ êµ¬í˜„í•˜ë„ë¡ `Tokenizer`ë¥¼ ì—…"
"ë°ì´íŠ¸í•˜ê³  íŒŒì„œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤."

#: src/error-handling/exercise.md:15 src/error-handling/solution.md:9
msgid "/// An arithmetic operator.\n"
msgstr "/// ì‚°ìˆ  ì—°ì‚°ìì…ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:22 src/error-handling/solution.md:16
msgid "/// A token in the expression language.\n"
msgstr "/// í‘œí˜„ì‹ ì–¸ì–´ì˜ í† í°ì…ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:30 src/error-handling/solution.md:24
msgid "/// An expression in the expression language.\n"
msgstr "/// í‘œí˜„ì‹ ì–¸ì–´ì˜ í‘œí˜„ì‹ì…ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:34 src/error-handling/solution.md:28
msgid "/// A reference to a variable.\n"
msgstr "/// ë³€ìˆ˜ ì°¸ì¡°ì…ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:36 src/error-handling/solution.md:30
msgid "/// A literal number.\n"
msgstr "/// ë¦¬í„°ëŸ´ ìˆ«ìì…ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:38 src/error-handling/solution.md:32
msgid "/// A binary operation.\n"
msgstr "/// ì´ì§„ ì—°ì‚°ì…ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:62 src/error-handling/exercise.md:64
#: src/error-handling/solution.md:62 src/error-handling/solution.md:64
msgid "'z'"
msgstr "'z'"

#: src/error-handling/exercise.md:64 src/error-handling/solution.md:64
msgid "'_'"
msgstr "'_'"

#: src/error-handling/exercise.md:70 src/error-handling/solution.md:70
msgid "'+'"
msgstr "'+'"

#: src/error-handling/exercise.md:71 src/error-handling/solution.md:71
msgid "'-'"
msgstr "'-'"

#: src/error-handling/exercise.md:72
msgid "\"Unexpected character {c}\""
msgstr "\"ì˜ˆê¸°ì¹˜ ì•Šì€ ë¬¸ì {c}\""

#: src/error-handling/exercise.md:82 src/error-handling/solution.md:81
msgid "\"Unexpected end of input\""
msgstr "\"ì˜ˆê¸°ì¹˜ ì•Šì€ ì…ë ¥ ì¢…ë£Œ\""

#: src/error-handling/exercise.md:86
msgid "\"Invalid 32-bit integer'\""
msgstr "\"ì˜ëª»ëœ 32ë¹„íŠ¸ ì •ìˆ˜ì…ë‹ˆë‹¤.'\""

#: src/error-handling/exercise.md:90 src/error-handling/exercise.md:100
msgid "\"Unexpected token {tok:?}\""
msgstr "\"ì˜ˆê¸°ì¹˜ ì•Šì€ í† í° {tok:?}\""

#: src/error-handling/exercise.md:92 src/error-handling/solution.md:104
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr "// ì´ì§„ ì—°ì‚°ì´ ìˆëŠ” ê²½ìš° ì´ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.\n"

#: src/error-handling/exercise.md:108 src/error-handling/solution.md:121
msgid "\"10+foo+20-30\""
msgstr "\"10+foo+20-30\""

#: src/error-handling/exercise.md:109 src/error-handling/solution.md:122
msgid "\"{expr:?}\""
msgstr "\"{expr:?}\""

#: src/error-handling/solution.md:42
msgid "\"Unexpected character '{0}' in input\""
msgstr "\"ì…ë ¥ì— ì˜ˆìƒì¹˜ ëª»í•œ ë¬¸ì '{0}'ì´(ê°€) ìˆìŠµë‹ˆë‹¤.\""

#: src/error-handling/solution.md:79
msgid "\"Tokenizer error: {0}\""
msgstr "\"í† í°ë‚˜ì´ì € ì˜¤ë¥˜: {0}\""

#: src/error-handling/solution.md:83
msgid "\"Unexpected token {0:?}\""
msgstr "\"ì˜ˆê¸°ì¹˜ ì•Šì€ í† í° {0:?}\""

#: src/error-handling/solution.md:85
msgid "\"Invalid number\""
msgstr "\"ì˜ëª»ëœ ë²ˆí˜¸\""

#: src/unsafe-rust/unsafe.md:3
msgid "The Rust language has two parts:"
msgstr "ëŸ¬ìŠ¤íŠ¸ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì€ í¬ê²Œ ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰©ë‹ˆë‹¤:"

#: src/unsafe-rust/unsafe.md:5
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr ""
"**ì•ˆì „í•œ ëŸ¬ìŠ¤íŠ¸:** ë©”ëª¨ë¦¬ ê´€ë ¨ ì˜¤ë¥˜ ë°œìƒ ë¶ˆê°€ëŠ¥, ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ ì—†ìŒ."

#: src/unsafe-rust/unsafe.md:6
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸:** íŠ¹ë³„í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šì€ì±„ë¡œ ì‚¬ìš©ë˜ë©´ ì •ì˜ë˜ì§€ "
"ì•Šì€ ë™ì‘ì„ ìœ ë°œí•  ìˆ˜ ìˆìŒ."

#: src/unsafe-rust/unsafe.md:8
#, fuzzy
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"ì´ ê°•ì˜ëŠ” ëŒ€ë¶€ë¶„ ì•ˆì „í•œ ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•´ ë‹¤ë£¨ì§€ë§Œ ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ê°€ ë¬´ì—‡ì¸"
"ì§€ëŠ” ì•Œì•„ ë‘ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe-rust/unsafe.md:11
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"ë³´í†µ, ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œëŠ” í¬ê¸°ê°€ ì‘ìœ¼ë©°, ë…ë¦½ì ìœ¼ë¡œ ì¡´ì¬í•©ë‹ˆë‹¤. ê·¸ë¦¬"
"ê³  ì½”ë“œê°€ ì™œ ì˜ ì‘ë™í•˜ëŠ”ì§€ì— ëŒ€í•´ ì„¸ë°€í•˜ê²Œ ë¬¸ì„œí™”ê°€ ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³ , ë§"
"ì€ ê²½ìš° ì•ˆì „í•œ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µí•´ì„œ ì¶”ìƒí™”ë¥¼ ì‹œí‚¨ í›„ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/unsafe-rust/unsafe.md:14
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr ""
"ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ë‹¤ì„¯ ê°€ì§€ ê²ƒë“¤ì´ ê°€ëŠ¥í•´ ì§‘ë‹ˆë‹¤:"

#: src/unsafe-rust/unsafe.md:16
msgid "Dereference raw pointers."
msgstr "ì›ì‹œ í¬ì¸í„° ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)"

#: src/unsafe-rust/unsafe.md:17
msgid "Access or modify mutable static variables."
msgstr "ì •ì  ê°€ë³€ë³€ìˆ˜ ì ‘ê·¼ ë° ìˆ˜ì •."

#: src/unsafe-rust/unsafe.md:18
msgid "Access `union` fields."
msgstr "`union` í•„ë“œ ì ‘ê·¼."

#: src/unsafe-rust/unsafe.md:19
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "`extern` í•¨ìˆ˜ë¥¼ í¬í•¨í•œ `unsafe` í•¨ìˆ˜ í˜¸ì¶œ."

#: src/unsafe-rust/unsafe.md:20
msgid "Implement `unsafe` traits."
msgstr "`unsafe` íŠ¸ë ˆì‡ êµ¬í˜„."

#: src/unsafe-rust/unsafe.md:22
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"ìœ„ ê¸°ëŠ¥ë“¤ì— ëŒ€í•´ ê°„ëµíˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë˜ë° ì–¸"
"ì–´, 19.1ì ˆ](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)ê³¼ "
"[Rustonomicon](https://doc.rust-lang.org/nomicon/)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/unsafe-rust/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸ë¼ê³  í•´ì„œ ì½”ë“œê°€ ë¶€ì •í™• í•˜ë‹¤ëŠ” ëœ»ì€ ì•„ë‹™ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì•ˆì „"
"í•˜ì§€ ì•Šë‹¤ì˜ ì˜ë¯¸ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ì œê³µí•´ì£¼ëŠ” ì•ˆì „ ì¥ì¹˜ë“¤ì´ êº¼ì§„ ìƒíƒœì´ë©°, ê°œë°œì"
"ê°€ ìŠ¤ìŠ¤ë¡œ ì •í™•í•˜ê³  ì•ˆì „í•œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ "
"ë” ì´ìƒ ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ì•ˆì „ê³¼ ê´€ë ¨ëœ ê·œì¹™ë“¤ì„ ì ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/unsafe-rust/dereferencing.md:3
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"í¬ì¸í„°ë¥¼ ë§Œë“œëŠ” ê²ƒì€ ì•ˆì „í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)í•  ê²½ìš° `unsafe`ê°€ í•„"
"ìš”í•©ë‹ˆë‹¤:"

#: src/unsafe-rust/dereferencing.md:7
msgid "\"careful!\""
msgstr "\"ì¡°ì‹¬í•˜ì„¸ìš”!\""

#: src/unsafe-rust/dereferencing.md:12
#, fuzzy
msgid ""
"// Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
msgstr ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"

#: src/unsafe-rust/dereferencing.md:18
msgid "\"r1 is: {}\""
msgstr "\"r1ì€ {}ì…ë‹ˆë‹¤.\""

#: src/unsafe-rust/dereferencing.md:19
msgid "\"uhoh\""
msgstr "\"ì´ëŸ°\""

#: src/unsafe-rust/dereferencing.md:20
msgid "\"r2 is: {}\""
msgstr "\"r2ëŠ” {}ì…ë‹ˆë‹¤.\""

#: src/unsafe-rust/dereferencing.md:23
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""
"// ì•ˆì „í•˜ì§€ ì•ŠìŒ. ì´ë ‡ê²Œ í•˜ì§€ ë§ˆì„¸ìš”.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"

#: src/unsafe-rust/dereferencing.md:34
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"ëª¨ë“  `unsafe` ë¸”ë¡ì— ëŒ€í•´ ì™œ ê·¸ ì½”ë“œê°€ ì•ˆì „í•œì§€ì— ëŒ€í•œ ì„¤ëª…ì„ ì£¼ì„ìœ¼ë¡œ ë‹¤ëŠ” "
"ê²ƒì€ ì¢‹ì€ ìŠµê´€ì…ë‹ˆë‹¤(ì‚¬ì‹¤ ì•ˆë“œë¡œì´ë“œì˜ ëŸ¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ê°€ì´ë“œì—ì„œëŠ” ì´ê²Œ í•„ìˆ˜ì…"
"ë‹ˆë‹¤)."

#: src/unsafe-rust/dereferencing.md:38
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"í¬ì¸í„° ì—­ì°¸ì¡°ë¥¼ í•  ê²½ìš°, í¬ì¸í„°ê°€ [_ìœ íš¨_](https://doc.rust-lang.org/std/ptr/"
"index.html#safety)í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:"

#: src/unsafe-rust/dereferencing.md:41
msgid "The pointer must be non-null."
msgstr "í¬ì¸í„°ëŠ” nullì´ë©´ ì•ˆë©ë‹ˆë‹¤."

#: src/unsafe-rust/dereferencing.md:42
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"í¬ì¸í„°ëŠ” ë”°ë¼ê°€ê¸°ê°€ ê°€ëŠ¥í•´ì•¼ í•©ë‹ˆë‹¤ (ê°ì²´ì˜ ì–´ëŠ í•œ ë¶€ë¶„ì„ ê°€ë¦¬í‚¤ê³  ìˆì–´ì•¼ í•©"
"ë‹ˆë‹¤)."

#: src/unsafe-rust/dereferencing.md:44
msgid "The object must not have been deallocated."
msgstr "ì´ë¯¸ ë°˜í™˜ëœ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ë©´ ì•ˆë©ë‹ˆë‹¤."

#: src/unsafe-rust/dereferencing.md:45
msgid "There must not be concurrent accesses to the same location."
msgstr "ê°™ì€ ìœ„ì¹˜ì— ëŒ€í•´ ë™ì‹œì ì¸ ì ‘ê·¼ì´ ìˆìœ¼ë©´ ì•ˆë©ë‹ˆë‹¤."

#: src/unsafe-rust/dereferencing.md:46
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"ì°¸ì¡°ë¥¼ ìºìŠ¤íŒ… í•´ì„œ í¬ì¸í„°ë¥¼ ë§Œë“¤ì—ˆë‹¤ë©´, ê·¸ ì°¸ì¡°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°ì²´ëŠ” ì‚´ì•„ ìˆì–´"
"ì•¼ í•˜ë©°, ê·¸ ê°ì²´ì˜ ë©”ëª¨ë¦¬ë¥¼ ì ‘ê·¼í•˜ëŠ” ì°¸ì¡°ê°€ í•˜ë‚˜ë„ ì—†ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe-rust/dereferencing.md:49
msgid "In most cases the pointer must also be properly aligned."
msgstr "ëŒ€ë¶€ë¶„ì˜ ê²½ìš° í¬ì¸í„°ëŠ” alignë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe-rust/dereferencing.md:51
#, fuzzy
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""
"\"ì•ˆì „í•˜ì§€ ì•ŠìŒ' ì„¹ì…˜ì€ ì¼ë°˜ì ì¸ UB ë²„ê·¸ì˜ ì˜ˆë¥¼ ì œê³µí•©ë‹ˆë‹¤. `*r1`ì€ "
"`'static` ì „ì²´ ê¸°ê°„ì„ ê°€ì§€ë¯€ë¡œ `r3`ì˜ íƒ€ì…ì€ `&'static String`ì´ë©° `s`ë³´ë‹¤ ì˜¤"
"ë˜ ì§€ì†ë©ë‹ˆë‹¤. í¬ì¸í„°ì—ì„œ ì°¸ì¡°ë¥¼ ë§Œë“¤ë ¤ë©´ _ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤_."

#: src/unsafe-rust/mutable-static.md:3
msgid "It is safe to read an immutable static variable:"
msgstr "ë¶ˆë³€ ì •ì ë³€ìˆ˜ë¥¼ ì½ëŠ” ê²ƒì€ ì•ˆì „í•©ë‹ˆë‹¤:"

#: src/unsafe-rust/mutable-static.md:6
#, fuzzy
msgid "\"Hello, world!\""
msgstr "Hello World!"

#: src/unsafe-rust/mutable-static.md:9
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr "\"HELLO_WORLD: {HELLO_WORLD}\""

#: src/unsafe-rust/mutable-static.md:13
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"í•˜ì§€ë§Œ, ë°ì´í„° ë ˆì´ìŠ¤ê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì •ì  ê°€ë³€ë³€ìˆ˜ë¥¼ ì½ê³  ì“°ëŠ” ê²ƒì€ ì•ˆ"
"ì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/unsafe-rust/mutable-static.md:29
msgid "\"COUNTER: {COUNTER}\""
msgstr "\"COUNTER: {COUNTER}\""

#: src/unsafe-rust/mutable-static.md:36
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"ì´ í”„ë¡œê·¸ë¨ì€ ë‹¨ì¼ ìŠ¤ë ˆë“œì´ë¯€ë¡œ ì•ˆì „í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ Rust ì»´íŒŒì¼ëŸ¬ëŠ” ë³´ìˆ˜ì ì´"
"ë©° ìµœì•…ì˜ ìƒí™©ì„ ê°€ì •í•©ë‹ˆë‹¤. `unsafe`ë¥¼ ì‚­ì œí•´ ë³´ê³  ì»´íŒŒì¼ëŸ¬ê°€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—"
"ì„œ staticì„ ë³€ê²½í•˜ëŠ” ê²ƒì´ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì´ë¼ê³  ì–´ë–»ê²Œ ì„¤ëª…í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸"
"ìš”."

#: src/unsafe-rust/mutable-static.md:41
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ ì´ì•¼ê¸° í•´ì„œ, ì •ì  ê°€ë³€ ë³€ìˆ˜ë¥¼ ì“°ëŠ” ê²ƒì€ ì¢‹ì€ ì•„ì´ë””ì–´ê°€ ì•„ë‹™ë‹ˆë‹¤. "
"ê·¸ëŸ¬ë‚˜ `no_std`ì™€ ê°™ì€ ì €ìˆ˜ì¤€ ì½”ë”©ì„ í•  ê²½ìš°ì—ëŠ” í•„ìš”í•˜ê¸°ë„ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤"
"ì–´ í™ í• ë‹¹ê¸°ë¥¼ êµ¬í˜„í•˜ê±°ë‚˜, C APIë¥¼ ì‚¬ìš©í•˜ëŠ” ê²Œ ê·¸ëŸ° ê²½ìš°ì…ë‹ˆë‹¤."

#: src/unsafe-rust/unions.md:3
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"ìœ ë‹ˆì˜¨ íƒ€ì…ì€ ì—´ê±°í˜•(enum)ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ì–´ë–¤ í•„ë“œì— í•´ë‹¹í•˜ëŠ” ê°’ì„ ê°€ì§€ê³  ìˆ"
"ëŠ”ì§€ ì—¬ë¶€ë¥¼ í”„ë¡œê·¸ë˜ë¨¸ê°€ ìˆ˜ë™ìœ¼ë¡œ ì¶”ì í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/unsafe-rust/unions.md:14
msgid "\"int: {}\""
msgstr "\"int: {}\""

#: src/unsafe-rust/unions.md:15
msgid "\"bool: {}\""
msgstr "\"ë¶€ìš¸: {}\""

#: src/unsafe-rust/unions.md:15
#, fuzzy
msgid "// Undefined behavior!\n"
msgstr "ëŸ°íƒ€ì„ ì‹œ ì •ì˜ë˜ì§€ ì•ŠìŒ(undefined) ë™ì‘ ì—†ìŒ:"

#: src/unsafe-rust/unions.md:21
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì—ëŠ” ì—´ê±°í˜•ì´ ìˆê¸° ë•Œë¬¸ì— ìœ ë‹ˆì˜¨ì´ í•„ìš”í•œ ê²½ìš°ëŠ” ê·¹íˆ ë“œë­…ë‹ˆë‹¤. ìœ ë‹ˆì˜¨"
"ì€ C ë¼ì´ë¸ŒëŸ¬ë¦¬ APIë¥¼ ì‚¬ìš©í•  ë•Œ ê°€ë” í•„ìš”í•©ë‹ˆë‹¤."

#: src/unsafe-rust/unions.md:24
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"ë°”ì´íŠ¸ë“¤ì„ íŠ¹ì • íƒ€ì…ìœ¼ë¡œ ì¬í•´ì„ í•˜ê³  ì‹¶ë‹¤ë©´ [`std::mem::transmute`](https://"
"doc.rust-lang.org/stable/std/mem/fn.transmute.html)ë‚˜ ì¢€ ë” ì•ˆì „í•œ "
"[`zerocopy`](https://crates.io/crates/zerocopy) í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/unsafe-rust/unsafe-functions.md:3 src/unsafe-rust/unsafe-functions.md:74
msgid "Calling Unsafe Functions"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ í˜¸ì¶œ"

#: src/unsafe-rust/unsafe-functions.md:5
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"í•¨ìˆ˜ë‚˜ ë©”ì„œë“œê°€ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ìœ¼ë¡œ ë¹ ì§€ì§€ ì•Šê²Œ í•˜ê¸° ìœ„í•´ì„œ ë§Œì¡±í•´ì•¼ í•˜ëŠ” "
"ì „ì œ ì¡°ê±´ì´ ìˆëŠ” ê²½ìš°, ê·¸ í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ `unsafe`ë¡œ í‘œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/unsafe-rust/unsafe-functions.md:9 src/unsafe-rust/exercise.md:91
#: src/unsafe-rust/solution.md:41 src/android/interoperability/with-c.md:9
#: src/android/interoperability/with-c/rust.md:15
#: src/android/interoperability/with-c/rust.md:30
#: src/android/interoperability/cpp/cpp-bridge.md:29
#: src/android/interoperability/cpp/cpp-bridge.md:38
#: src/exercises/chromium/build-rules.md:8
#: src/exercises/chromium/build-rules.md:21
#: src/bare-metal/aps/inline-assembly.md:19
#: src/bare-metal/aps/better-uart/using.md:24
#: src/bare-metal/aps/logging/using.md:23 src/exercises/bare-metal/rtc.md:49
#: src/exercises/bare-metal/rtc.md:104 src/exercises/bare-metal/rtc.md:110
#: src/exercises/bare-metal/rtc.md:118 src/exercises/bare-metal/rtc.md:124
#: src/exercises/bare-metal/rtc.md:130 src/exercises/bare-metal/rtc.md:136
#: src/exercises/bare-metal/rtc.md:142 src/exercises/bare-metal/rtc.md:148
#: src/exercises/bare-metal/solutions-afternoon.md:43
msgid "\"C\""
msgstr "\"C\""

#: src/unsafe-rust/unsafe-functions.md:14
msgid "\"ğŸ—»âˆˆğŸŒ\""
msgstr "\"ğŸ—»âˆˆğŸŒ\""

#: src/unsafe-rust/unsafe-functions.md:16
msgid ""
"// Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""
"// ìƒ‰ì¸ì´ ì˜¬ë°”ë¥¸ ìˆœì„œì´ê³  ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì˜ ê²½ê³„ ë‚´ì—\n"
"    // ìˆìœ¼ë©° UTF-8 ì‹œí€€ìŠ¤ ê²½ê³„ì— ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/unsafe-functions.md:19
#: src/unsafe-rust/unsafe-functions.md:20
#: src/unsafe-rust/unsafe-functions.md:21
msgid "\"emoji: {}\""
msgstr "\"ì´ëª¨í‹°ì½˜: {}\""

#: src/unsafe-rust/unsafe-functions.md:24
msgid "\"char count: {}\""
msgstr "\"ë¬¸ì ìˆ˜: {}\""

#: src/unsafe-rust/unsafe-functions.md:27
#, fuzzy
msgid "// Undefined behavior if abs misbehaves.\n"
msgstr "ëŸ°íƒ€ì„ ì‹œ ì •ì˜ë˜ì§€ ì•ŠìŒ(undefined) ë™ì‘ ì—†ìŒ:"

#: src/unsafe-rust/unsafe-functions.md:28
msgid "\"Absolute value of -3 according to C: {}\""
msgstr "\"Cì— ë”°ë¥¸ ì ˆëŒ“ê°’ -3: {}\""

#: src/unsafe-rust/unsafe-functions.md:31
#, fuzzy
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""
"// UTF-8 ì¸ì½”ë”© ìš”êµ¬ì‚¬í•­ì„ ì¤€ìˆ˜í•˜ì§€ ì•Šìœ¼ë©´ ë©”ëª¨ë¦¬ ì•ˆì „ì´ ì¤‘ë‹¨ë©ë‹ˆë‹¤.\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"

#: src/unsafe-rust/unsafe-functions.md:42
#: src/unsafe-rust/unsafe-functions.md:86
msgid "Writing Unsafe Functions"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ ì‘ì„±í•˜ê¸°"

#: src/unsafe-rust/unsafe-functions.md:44
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"ì—¬ëŸ¬ë¶„ì´ ì‘ì„±í•œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ë•Œ ì–´ë–¤ íŠ¹ë³„í•œ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤ë©´, `unsafe`"
"ë¡œ ë§ˆí‚¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/unsafe-rust/unsafe-functions.md:48
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""
"/// ì§€ì •ëœ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ì„ ë°”ê¿‰ë‹ˆë‹¤.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// í¬ì¸í„°ëŠ” ìœ íš¨í•˜ê³  ì˜¬ë°”ë¥´ê²Œ ì •ë ¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/unsafe-functions.md:63
msgid "// Safe because ...\n"
msgstr "// ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/unsafe-functions.md:68
msgid "\"a = {}, b = {}\""
msgstr "\"a = {}, b = {}\""

#: src/unsafe-rust/unsafe-functions.md:76
#, fuzzy
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"ì´ê²Œ ë¬¸ì œê°€ ë˜ëŠ” ê²½ìš°ëŠ” ëŒ€ë¶€ë¶„ ì™¸ë¶€ í•¨ìˆ˜ê°€ ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ëª¨ë¸ì„ ìœ„ë°˜í•˜ê³  ìˆ"
"ì„ ê²½ìš°ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì–´ë–¤ Cí•¨ìˆ˜ë¼ë„ ì–´ë–¤ ì„ì˜ì˜ ìƒí™©ì—ì„œëŠ” ì •ì˜ë˜ì§€ ì•Šì€ ë™"
"ì‘ì„ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì—„ë°€íˆ ë§í•´ì„œëŠ” ëª¨ë“  ì™¸ë¶€ í•¨ìˆ˜ì— ëŒ€í•´ì„œ ë¬¸ì œì…ë‹ˆë‹¤."

#: src/unsafe-rust/unsafe-functions.md:83
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"ìœ„ ì˜ˆì œ ì½”ë“œì—ì„œ `\"C\"`ëŠ” ABIë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. [ë‹¤ë¥¸ ABIë„ ìˆìŠµë‹ˆë‹¤.](https://"
"doc.rust-lang.org/reference/items/external-blocks.html)"

#: src/unsafe-rust/unsafe-functions.md:88
#, fuzzy
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr ""
"ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ ì•ˆì „í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì‹¤ì œë¡œ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•  í•„ìš”"
"ëŠ” ì—†ìŠµë‹ˆë‹¤."

#: src/unsafe-rust/unsafe-functions.md:91
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"ì•ˆì „í•˜ì§€ ì•Šì€(unsafe) ì½”ë“œê°€ ì•ˆì „í•˜ì§€ ì•Šì€(unsafe) í•¨ìˆ˜ì˜ ë‚´ë¶€ì—ì„œ í˜¸ì¶œë  ê²½"
"ìš°ì—ëŠ” `unsafe`ë¸”ë¡ì„ ì§€ì •í•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤. `unsafe`ë¸”ë¡ì„ í•­ìƒ ì§€ì •í•˜ë„ë¡ "
"í•˜ê³  ì‹¶ë‹¤ë©´ `#[deny(unsafe_op_in_unsafe_fn)]`ë¥¼ ì´ìš©í•˜ì„¸ìš”. ì´ ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ "
"ì¶”ê°€í•´ ë³´ê³  ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/unsafe-rust/unsafe-traits.md:1
msgid "Implementing Unsafe Traits"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°"

#: src/unsafe-rust/unsafe-traits.md:3
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"í•¨ìˆ˜ì—ì„œì™€ ë§ˆì°¬ê°€ì§€ë¡œ íŠ¸ë ˆì‡ë„ `unsafe`ë¡œ ë§ˆí‚¹ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë§Œì•½ ê·¸ íŠ¸ë ˆì‡ì„ "
"êµ¬í˜„í•  ë•Œ ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ì„ í”¼í•˜ê¸° ìœ„í•´ íŠ¹ë³„í•œ ì¡°ê±´ì´ í•„ìš”í•˜ë‹¤ë©´ ë§ì´ì§€ìš”."

#: src/unsafe-rust/unsafe-traits.md:6
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´ `zerocopy` í¬ë ˆì´íŠ¸ì—ëŠ” [ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡](https://docs.rs/"
"zerocopy/latest/zerocopy/trait.AsBytes.html)ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/unsafe-rust/unsafe-traits.md:12
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""
"/// ...\n"
"/// # Safety\n"
"/// íƒ€ì…ì—ëŠ” ì •ì˜ëœ í‘œí˜„ì´ ìˆì–´ì•¼ í•˜ë©° íŒ¨ë”©ì€ ì—†ì–´ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/unsafe-traits.md:26
msgid "// Safe because u32 has a defined representation and no padding.\n"
msgstr "// u32ì— ì •ì˜ëœ í‘œí˜„ì´ ìˆê³  íŒ¨ë”©ì´ ì—†ìœ¼ë¯€ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/unsafe-traits.md:33
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ì„ ë§Œë“¤ ë•Œì—ëŠ” ì£¼ì„ì— `# Safety` í•­ëª©ì´ ìˆì–´ì„œ ì´ íŠ¸ë ˆì‡"
"ì„ ì•ˆì „í•˜ê²Œ êµ¬í˜„í•˜ë ¤ë©´ ì–´ë–¤ ìš”êµ¬ì‚¬í•­ë“¤ì„ ë§Œì¡±í•´ì•¼ í•˜ëŠ”ì§€ë¥¼ ì„¤ëª…í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/unsafe-rust/unsafe-traits.md:36
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"`AsBytes`ì—ì„œ ì§€ì¼œì•¼ í•  ì•ˆì „ì„±ì— ëŒ€í•œ ì‹¤ì œ ì„¤ëª…ì€ ì¢€ ë” ê¸¸ê³  ë³µì¡í•©ë‹ˆë‹¤."

#: src/unsafe-rust/unsafe-traits.md:38
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "ë¹ŒíŠ¸ì¸ íŠ¸ë ˆì‡ì¸ `Send`ì™€ `Sync`ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡ ì…ë‹ˆë‹¤."

#: src/unsafe-rust/exercise.md:1
msgid "Safe FFI Wrapper"
msgstr "FFIë˜í¼"

#: src/unsafe-rust/exercise.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” \\_ì™¸ë¶€ ê¸°ëŠ¥ í˜¸ì¶œ(FFI)\\_ì„ ì§€ì›í•©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ë¥¼ ì´ìš©í•˜ì—¬ ë””ë ‰í„°"
"ë¦¬ì—ì„œ íŒŒì¼ ì´ë¦„ì„ ì½ì–´ì˜¤ëŠ” `libc` í•¨ìˆ˜ì— ëŒ€í•œ ì•ˆì „í•œ ë˜í¼ë¥¼ ë§Œë“¤ ê²ƒì…ë‹ˆë‹¤."

#: src/unsafe-rust/exercise.md:7
msgid "You will want to consult the manual pages:"
msgstr "ì•„ë˜ ë¦¬ëˆ…ìŠ¤ ë©”ë‰´ì–¼ ë¬¸ì„œë“¤ì„ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤:"

#: src/unsafe-rust/exercise.md:9
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md:10
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md:11
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md:13
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"ì•„ë§ˆ [`std::ffi`](https://doc.rust-lang.org/std/ffi/)ëª¨ë“ˆì„ ì°¸ì¡°í•  í•„ìš”ê°€ ìˆ"
"ì„ ê²ƒì…ë‹ˆë‹¤. ê±°ê¸°ì—ëŠ” ì´ë²ˆ ì˜ˆì œë¥¼ ìˆ˜í–‰í•˜ëŠ”ë° í•„ìš”í•œ ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ ë¬¸ìì—´ íƒ€ì…"
"ë“¤ì´ ì†Œê°œë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#: src/unsafe-rust/exercise.md:16
msgid "Encoding"
msgstr "ì¸ì½”ë”©"

#: src/unsafe-rust/exercise.md:16
msgid "Use"
msgstr "ì‚¬ìš©"

#: src/unsafe-rust/exercise.md:18
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html)ê³¼ [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md:18
msgid "UTF-8"
msgstr "UTF-8"

#: src/unsafe-rust/exercise.md:18
msgid "Text processing in Rust"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œì˜ ë¬¸ìì—´ ì²˜ë¦¬"

#: src/unsafe-rust/exercise.md:19
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html)ê³¼ [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md:19
msgid "NUL-terminated"
msgstr "ë„(NUL)ë¡œ ëë‚¨"

#: src/unsafe-rust/exercise.md:19
msgid "Communicating with C functions"
msgstr "Cí•¨ìˆ˜ì™€ ì—°ë™í•˜ê¸°"

#: src/unsafe-rust/exercise.md:20
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html)ì™€ [`OsString`]"
"(https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md:20
msgid "OS-specific"
msgstr "OSê°€ ì •ì˜í•¨"

#: src/unsafe-rust/exercise.md:20
msgid "Communicating with the OS"
msgstr "OSì™€ ì—°ë™í•˜ê¸° ìœ„í•œ ë¬¸ìì—´"

#: src/unsafe-rust/exercise.md:22
msgid "You will convert between all these types:"
msgstr "ì´ íƒ€ì…ë“¤ ê°„ì˜ ë³€í™˜ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/unsafe-rust/exercise.md:24
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""
"`&str`ì—ì„œ `CString`ìœ¼ë¡œì˜ ë³€í™˜: ë§¨ ë§ˆì§€ë§‰ì˜ `\\0` ë¬¸ìë¥¼ ì €ì¥í•˜ê¸° ìœ„í•œ ê³µê°„"
"ì„ í• ë‹¹í•´ì•¼ í•©ë‹ˆë‹¤,"

#: src/unsafe-rust/exercise.md:25
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""
"`CString`ì—ì„œ `*const i8`ë¡œì˜ ë³€í™˜: Cí•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê¸° ìœ„í•´ì„œëŠ” í¬ì¸í„°ê°€ í•„ìš”í•©"
"ë‹ˆë‹¤,"

#: src/unsafe-rust/exercise.md:26
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"`*const i8`ì—ì„œ `&CStr`ë¡œì˜ ë³€í™˜: ì£¼ì–´ì§„ ë°”ì´íŠ¸ ì‹œí€€ìŠ¤ê°€ `\\0`ë¡œ ëë‚˜ëŠ”ì§€ í™•"
"ì¸í•˜ê³  ì‹¶ì€ ê²½ìš°,"

#: src/unsafe-rust/exercise.md:28
#, fuzzy
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"`&CStr`ì—ì„œ `&[u8]`ë¡œì˜ ë³€í™˜: ë°”ì´íŠ¸ ìŠ¬ë¼ì´ìŠ¤ëŠ” \"ì•Œìˆ˜ì—†ëŠ” ë°ì´í„°\"ì— ëŒ€í•œ ì¼"
"ë°˜ì ì¸ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤,"

#: src/unsafe-rust/exercise.md:30
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"`&[u8]`ì—ì„œ `&OsStr`ë¡œì˜ ë³€í™˜: `&OsStr`ëŠ” `OsString`ìœ¼ë¡œ ê°€ê¸° ìœ„í•œ ì¤‘ê°„ ë‹¨ê³„ "
"ì…ë‹ˆë‹¤. [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait."
"OsStrExt.html)ë¥¼ ì‚¬ìš©í•´ì„œ  `OsStr`ë¥¼ ìƒì„±í•˜ì„¸ìš”,"

#: src/unsafe-rust/exercise.md:33
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"`&OsStr`ì—ì„œ `OsString`ìœ¼ë¡œì˜ ë³€í™˜: `&OsStr`ì´ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ë°ì´í„°ë¥¼ ë³µì‚¬í•¨"
"ìœ¼ë¡œì¨, ì´ ë°ì´í„°ë¥¼ ë¦¬í„´í•˜ê³ , `readdir`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ ì¤"
"ë‹ˆë‹¤."

#: src/unsafe-rust/exercise.md:36
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html)ì— FFIì™€ ê´€ë ¨í•œ ì•„ì£¼ ìœ "
"ìš©í•œ ì±•í„°ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/unsafe-rust/exercise.md:47
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•˜ê³  ë¹ ì§„ í•¨ìˆ˜ì™€ ë©”ì„œë“œë¥¼ ì±„"
"ì›Œë´…ë‹ˆë‹¤:"

#: src/unsafe-rust/exercise.md:56 src/unsafe-rust/exercise.md:69
#: src/unsafe-rust/exercise.md:80 src/unsafe-rust/exercise.md:94
#: src/unsafe-rust/exercise.md:102 src/unsafe-rust/solution.md:6
#: src/unsafe-rust/solution.md:19 src/unsafe-rust/solution.md:30
#: src/unsafe-rust/solution.md:44 src/unsafe-rust/solution.md:52
msgid "\"macos\""
msgstr "\"ë§¤í¬ë¡œ\""

#: src/unsafe-rust/exercise.md:59 src/unsafe-rust/solution.md:9
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr ""
"// ë¶ˆíˆ¬ëª… íƒ€ì…ì…ë‹ˆë‹¤. https://doc.rust-lang.org/nomicon/ffi.htmlì„ ì°¸ê³ í•˜ì„¸"
"ìš”.\n"

#: src/unsafe-rust/exercise.md:66 src/unsafe-rust/solution.md:16
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""
"// readdir(3)ì˜ Linux man í˜ì´ì§€ì— ë”°ë¥¸ ë ˆì´ì•„ì›ƒì…ë‹ˆë‹¤.\n"
"    // ì—¬ê¸°ì„œ ino_t ë° off_tëŠ”\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}ì˜ ì •ì˜"
"ì— ë”°ë¼ í™•ì¸ë©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/exercise.md:79 src/unsafe-rust/solution.md:29
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr "// dir(5)ì˜ macOS man í˜ì´ì§€ì— ë”°ë¥¸ ë ˆì´ì•„ì›ƒì…ë‹ˆë‹¤.\n"

#: src/unsafe-rust/exercise.md:94 src/unsafe-rust/exercise.md:102
#: src/unsafe-rust/solution.md:44 src/unsafe-rust/solution.md:52
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/unsafe-rust/exercise.md:97 src/unsafe-rust/solution.md:47
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""
"// https://github.com/rust-lang/libc/issues/414 ë°\n"
" // stat(2)ì— ê´€í•œ macOS man í˜ì´ì§€ì˜ _DARWIN_FEATURE_64_BIT_INODE ì„¹ì…˜ì„ ì°¸"
"ê³ í•˜ì„¸ìš”.\n"
" //\n"
" // ' ì´ ì—…ë°ì´íŠ¸ê°€ ì œê³µë˜ê¸° ì „ì— ì¡´ì¬í–ˆë˜ í”Œë«í¼ì€'\n"
" // Intel ë° PowerPCì˜ macOS (iOS/wearOS ë“±ì´ ì•„ë‹˜)ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/exercise.md:103 src/unsafe-rust/solution.md:53
msgid "\"readdir$INODE64\""
msgstr "\"readdir$INODE64\""

#: src/unsafe-rust/exercise.md:121 src/unsafe-rust/solution.md:71
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""
"// opendirì„ í˜¸ì¶œí•˜ê³  ì œëŒ€ë¡œ ì‘ë™í•˜ë©´ Ok ê°’ì„ ë°˜í™˜í•˜ê³ \n"
"        // ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë©”ì‹œì§€ì™€ í•¨ê»˜ Errì„ ë°˜í™˜í•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/exercise.md:130
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr "// NULL í¬ì¸í„°ë¥¼ ë‹¤ì‹œ ê°€ì ¸ì˜¬ ë•Œê¹Œì§€ readdirì„ ê³„ì† í˜¸ì¶œí•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/exercise.md:137 src/unsafe-rust/solution.md:105
msgid "// Call closedir as needed.\n"
msgstr "// í•„ìš”ì— ë”°ë¼ closedirì„ í˜¸ì¶œí•©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/exercise.md:143 src/unsafe-rust/solution.md:116
#: src/unsafe-rust/solution.md:140 src/unsafe-rust/solution.md:155
#: src/android/interoperability/with-c/rust.md:44
msgid "\".\""
msgstr "\".\""

#: src/unsafe-rust/exercise.md:144 src/unsafe-rust/solution.md:117
msgid "\"files: {:#?}\""
msgstr "\"íŒŒì¼: {:#?}\""

#: src/unsafe-rust/solution.md:74
msgid "\"Invalid path: {err}\""
msgstr "\"ì˜ëª»ëœ ê²½ë¡œ: {err}\""

#: src/unsafe-rust/solution.md:75
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr "// SAFETY: path.as_ptr()ì€ NULLì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"

#: src/unsafe-rust/solution.md:78
msgid "\"Could not open {:?}\""
msgstr "\"{:?}ì„(ë¥¼) ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\""

#: src/unsafe-rust/solution.md:88
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""
"// NULL í¬ì¸í„°ë¥¼ ë‹¤ì‹œ ì–»ì„ ë•Œê¹Œì§€ readdirì„ ê³„ì† í˜¸ì¶œí•©ë‹ˆë‹¤.\n"
"        // SAFETY: self.dirì€ NULLì´ ì•„ë‹™ë‹ˆë‹¤.\n"

#: src/unsafe-rust/solution.md:92
msgid "// We have reached the end of the directory.\n"
msgstr "// ë””ë ‰í„°ë¦¬ì˜ ëì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤.\n"

#: src/unsafe-rust/solution.md:95
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""
"// SAFETY: direntëŠ” NULLì´ ì•„ë‹ˆë©° dirent.d_nameì€ NUL\n"
"        // ì¢…ë£Œë©ë‹ˆë‹¤.\n"

#: src/unsafe-rust/solution.md:107
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr "// SAFETY: self.dirì€ NULLì´ ì•„ë‹™ë‹ˆë‹¤.\n"

#: src/unsafe-rust/solution.md:109
msgid "\"Could not close {:?}\""
msgstr "\"{:?}ì„(ë¥¼) ë‹«ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\""

#: src/unsafe-rust/solution.md:128
msgid "\"no-such-directory\""
msgstr "\"no-such-directory\""

#: src/unsafe-rust/solution.md:136 src/unsafe-rust/solution.md:151
msgid "\"Non UTF-8 character in path\""
msgstr "\"ê²½ë¡œì— UTF-8ì´ ì•„ë‹Œ ë¬¸ìê°€ ìˆìŒ\""

#: src/unsafe-rust/solution.md:140 src/unsafe-rust/solution.md:155
msgid "\"..\""
msgstr "\"..\""

#: src/unsafe-rust/solution.md:147 src/unsafe-rust/solution.md:155
msgid "\"foo.txt\""
msgstr "\"foo.txt\""

#: src/unsafe-rust/solution.md:147
msgid "\"The Foo Diaries\\n\""
msgstr "\"Foo ë‹¤ì´ì–´ë¦¬\\n\""

#: src/unsafe-rust/solution.md:148 src/unsafe-rust/solution.md:155
msgid "\"bar.png\""
msgstr "\"bar.png\""

#: src/unsafe-rust/solution.md:148
msgid "\"<PNG>\\n\""
msgstr "\"<PNG>\\n\""

#: src/unsafe-rust/solution.md:149 src/unsafe-rust/solution.md:155
#, fuzzy
msgid "\"crab.rs\""
msgstr "\"crab.rs\""

#: src/unsafe-rust/solution.md:149
msgid "\"//! Crab\\n\""
msgstr "\"//! Crab\\n\""

#: src/android.md:1
#, fuzzy
msgid "Welcome to Rust in Android"
msgstr "1ì¼ì°¨ ê°œìš”"

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì•ˆë“œë¡œì´ë“œ ë„¤ì´í‹°ë¸Œ í”Œë«í¼ ê°œë°œì„ ì§€ì›í•©ë‹ˆë‹¤. ê¸°ì¡´ì˜ OS ì„œë¹„ìŠ¤ë¥¼ í™•"
"ì¥í•˜ê±°ë‚˜, ìƒˆë¡œìš´ ì„œë¹„ìŠ¤ë¥¼ ë§Œë“œëŠ”ë° ëŸ¬ìŠ¤íŠ¸ë¥¼ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/android.md:7
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"ìš°ë¦¬ëŠ” ì˜¤ëŠ˜ ì—¬ëŸ¬ë¶„ì˜ í”„ë¡œì íŠ¸ì—ì„œ ëŸ¬ìŠ¤íŠ¸ ì½”ë“œë¥¼ í˜¸ì¶œí•´ë³¼ ê²ƒì…ë‹ˆë‹¤. ê·¸ í”„ë¡œì "
"íŠ¸ì—ì„œ ëŸ¬ìŠ¤íŠ¸ë¡œ ì˜®ê¸¸ë§Œ í•œ ì‘ì€ ë¶€ë¶„ì„ ì •í•˜ì„¸ìš”. ì˜ì¡´ì„±ì´ ì ê³  \"íŠ¹ì´í•œ\" íƒ€ì…"
"ì´ ì ì„ ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤. ë°”ì´íŠ¸ ëª‡ ê°œë¥¼ íŒŒì‹±í•˜ëŠ” ì½”ë“œë¼ë©´ ì™„ë²½í•©ë‹ˆë‹¤."

#: src/android.md:14
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr ""

#: src/android.md:17
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""

#: src/android.md:20
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""

#: src/android.md:23
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""

#: src/android.md:26
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"ì•ˆë“œë¡œì´ë“œ ê°€ìƒ ë””ë°”ì´ìŠ¤(Android Virtual Device)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ë¶„ì˜ ì½”ë“œë¥¼ "
"ìˆ˜í–‰í•  ê²ë‹ˆë‹¤. ìƒˆë¡œìš´ ê°€ìƒ ë””ë°”ì´ìŠ¤ë¥¼ ìƒì„±í•˜ë ¤ë©´ ì•„ë˜ì˜ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”:"

#: src/android/setup.md:12
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"ìì„¸í•œ ë‚´ìš©ì€ [Android Developer Codelab](https://source.android.com/docs/"
"setup/start)ì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤."

#: src/android/setup.md:20
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""

#: src/android/setup.md:23
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""

#: src/android/build-rules.md:3
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"ì•ˆë“œë¡œì´ë“œ ë¹Œë“œ ì‹œìŠ¤í…œ(Soong)ì€ ë‹¤ìŒê³¼ ê°™ì€ ì—¬ëŸ¬ ëª¨ë“ˆì„ í†µí•´ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì§€ì›í•©"
"ë‹ˆë‹¤:"

#: src/android/build-rules.md:5
msgid "Module Type"
msgstr "Module Type"

#: src/android/build-rules.md:5
msgid "Description"
msgstr "Description"

#: src/android/build-rules.md:7
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md:7
msgid "Produces a Rust binary."
msgstr "ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:8
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md:8
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr "ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬(rlibí˜¹ì€ dylib)ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:9
msgid "`rust_ffi`"
msgstr "`rust_ffi`"

#: src/android/build-rules.md:9
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr "cc ëª¨ë“ˆì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” C library (ì •ì  í˜¹ì€ ë™ì )ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:10
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md:10
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""
"`proc-macro`ë¥¼ êµ¬í˜„í•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ì˜ í”ŒëŸ¬ê·¸ì¸ìœ¼"
"ë¡œ ìƒê°í•´ë„ ì¢‹ìŠµë‹ˆë‹¤."

#: src/android/build-rules.md:11
msgid "`rust_test`"
msgstr "`rust_test`"

#: src/android/build-rules.md:11
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr "í‘œì¤€ ëŸ¬ìŠ¤íŠ¸ í…ŒìŠ¤íŠ¸ ëŸ¬ë„ˆë¥¼ ì‚¬ìš©í•˜ëŠ” í…ŒìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:12
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md:12
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "`libfuzzer`ë¥¼ ì‚¬ìš©í•˜ì—¬ fuzz ë°”ì´ë„ˆë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:13
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md:13
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""
"í”„ë¡œí† ë²„í”„(protobuf) ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:14
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md:14
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""
"C ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ ëŸ¬ìŠ¤íŠ¸ ë°”ì¸ë”©ì„ ì œê³µí•˜ëŠ” ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/android/build-rules.md:16
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "ë‹¤ìŒì€ `rust_binary`ì™€ `rust_library`ë¥¼ ì‚´í´ë´…ë‹ˆë‹¤."

#: src/android/build-rules.md:20
msgid "Additional items speaker may mention:"
msgstr ""

#: src/android/build-rules.md:22
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr ""

#: src/android/build-rules.md:25
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""

#: src/android/build-rules.md:28
msgid ""
"Soong has many similarities to Bazel, which is the open-source variant of "
"Blaze (used in google3)."
msgstr ""

#: src/android/build-rules.md:31
msgid ""
"There is a plan to transition [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) to Bazel."
msgstr ""

#: src/android/build-rules.md:37
msgid "Learning Bazel-like build rules is useful for all Rust OS developers."
msgstr ""

#: src/android/build-rules.md:39
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr ""

#: src/android/build-rules/binary.md:1
msgid "Rust Binaries"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬"

#: src/android/build-rules/binary.md:3
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"ê°„ë‹¨í•œ ì‘ìš© í”„ë¡œê·¸ë¨ìœ¼ë¡œ ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤. AOSP ì²´í¬ì•„ì›ƒì˜ ë£¨íŠ¸ì—ì„œ ë‹¤ìŒ íŒŒ"
"ì¼ì„ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:10 src/android/build-rules/binary.md:11
msgid "\"hello_rust\""
msgstr ""

#: src/android/build-rules/binary.md:12 src/android/build-rules/library.md:19
#: src/android/logging.md:12
#, fuzzy
msgid "\"src/main.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:19 src/android/build-rules/library.md:37
msgid "//! Rust demo.\n"
msgstr ""

#: src/android/build-rules/binary.md:20 src/android/build-rules/library.md:41
msgid "/// Prints a greeting to standard output.\n"
msgstr ""

#: src/android/build-rules/binary.md:23 src/exercises/chromium/build-rules.md:9
msgid "\"Hello from Rust!\""
msgstr ""

#: src/android/build-rules/binary.md:27
msgid "You can now build, push, and run the binary:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ, ì´ ë°”ì´ë„ˆë¦¬ë¥¼ ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ì— ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/build-rules/binary.md:29
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/build-rules/library.md:1
msgid "Rust Libraries"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/android/build-rules/library.md:3
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"`rust_library`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆë“œë¡œì´ë“œìš© ìƒˆ ëŸ¬ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤."

#: src/android/build-rules/library.md:5
msgid "Here we declare a dependency on two libraries:"
msgstr "ì—¬ê¸°ì„œ ë‘ ê°œì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ ì˜ì¡´ì„±ì„ ì„ ì–¸í•©ë‹ˆë‹¤:"

#: src/android/build-rules/library.md:7
msgid "`libgreeting`, which we define below,"
msgstr "ì•„ë˜ì— ì •ì˜í•œ `libgreeting`."

#: src/android/build-rules/library.md:8
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"[`external/rust/crates/`](https://cs.android.com/android/platform/"
"superproject/+/master:external/rust/crates/)ì— ì¡´ì¬í•˜ëŠ” `libtextwrap`."

#: src/android/build-rules/library.md:17 src/android/build-rules/library.md:18
msgid "\"hello_rust_with_dep\""
msgstr ""

#: src/android/build-rules/library.md:21 src/android/build-rules/library.md:28
msgid "\"libgreetings\""
msgstr ""

#: src/android/build-rules/library.md:22
msgid "\"libtextwrap\""
msgstr ""

#: src/android/build-rules/library.md:24
msgid "// Need this to avoid dynamic link error.\n"
msgstr ""

#: src/android/build-rules/library.md:29
msgid "\"greetings\""
msgstr ""

#: src/android/build-rules/library.md:30 src/android/aidl/implementation.md:29
#: src/android/interoperability/java.md:39
#, fuzzy
msgid "\"src/lib.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/library.md:48
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:51
msgid "//! Greeting library.\n"
msgstr ""

#: src/android/build-rules/library.md:52
msgid "/// Greet `name`.\n"
msgstr ""

#: src/android/build-rules/library.md:55
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr ""

#: src/android/build-rules/library.md:59
msgid "You build, push, and run the binary like before:"
msgstr "ì´ì „ì²˜ëŸ¼, ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ë¡œ ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/build-rules/library.md:61
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_with_dep\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_with_dep\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"

#: src/android/aidl.md:3
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” [ì•ˆë“œë¡œì´ë“œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜ ì–¸ì–´(AIDL)](https://developer.android."
"com/guide/components/aidl)ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/android/aidl.md:8
msgid "Rust code can call existing AIDL servers,"
msgstr "ëŸ¬ìŠ¤íŠ¸ ì½”ë“œì—ì„œ ê¸°ì¡´ AIDL ì„œë²„ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "

#: src/android/aidl.md:9
msgid "You can create new AIDL servers in Rust."
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ ìƒˆë¡œìš´ AIDL ì„œë²„ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/android/aidl/interface.md:1
msgid "AIDL Interfaces"
msgstr "AIDL ì¸í„°í˜ì´ìŠ¤"

#: src/android/aidl/interface.md:3
msgid "You declare the API of your service using an AIDL interface:"
msgstr "AIDL ì¸í„°í˜ì´ìŠ¤ë¥¼ ì´ìš©í•´ì„œ ì„œë¹„ìŠ¤ì˜ APIë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤:"

#: src/android/aidl/interface.md:5
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:9 src/android/aidl/changing.md:8
msgid "/** Birthday service interface. */"
msgstr ""

#: src/android/aidl/interface.md:12 src/android/aidl/changing.md:11
msgid "/** Generate a Happy Birthday message. */"
msgstr ""

#: src/android/aidl/interface.md:17
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md:21
msgid "\"com.example.birthdayservice\""
msgstr ""

#: src/android/aidl/interface.md:22
#, fuzzy
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:25
msgid "// Rust is not enabled by default\n"
msgstr ""

#: src/android/aidl/interface.md:32
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"AIDL íŒŒì¼ì´ ë²¤ë” íŒŒí‹°ì…˜ì— ìˆëŠ” ë°”ì´ë„ˆë¦¬ì—ì„œ ì‚¬ìš©ë  ê²½ìš° `vendor_available: "
"true`ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤."

#: src/android/aidl/implementation.md:1
msgid "Service Implementation"
msgstr "ì„œë¹„ìŠ¤ êµ¬í˜„"

#: src/android/aidl/implementation.md:3
msgid "We can now implement the AIDL service:"
msgstr "ì´ì œ AIDLì„œë¹„ìŠ¤ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/implementation.md:5
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:8
msgid "//! Implementation of the `IBirthdayService` AIDL interface.\n"
msgstr ""

#: src/android/aidl/implementation.md:11
#, fuzzy
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "ì„œë¹„ìŠ¤ êµ¬í˜„"

#: src/android/aidl/implementation.md:19
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr ""

#: src/android/aidl/implementation.md:24 src/android/aidl/server.md:28
#: src/android/aidl/client.md:36
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md:28 src/android/aidl/server.md:38
#, fuzzy
msgid "\"libbirthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:30 src/android/aidl/server.md:13
#: src/android/aidl/client.md:12
#, fuzzy
msgid "\"birthdayservice\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:32 src/android/aidl/server.md:36
#: src/android/aidl/client.md:44
msgid "\"com.example.birthdayservice-rust\""
msgstr ""

#: src/android/aidl/implementation.md:33 src/android/aidl/server.md:37
#: src/android/aidl/client.md:45
msgid "\"libbinder_rs\""
msgstr ""

#: src/android/aidl/server.md:1
msgid "AIDL Server"
msgstr "AIDL ì„œë²„"

#: src/android/aidl/server.md:3
msgid "Finally, we can create a server which exposes the service:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ì„œë²„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/server.md:5
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md:8 src/android/aidl/client.md:8
msgid "//! Birthday service.\n"
msgstr ""

#: src/android/aidl/server.md:14
msgid "/// Entry point for birthday service.\n"
msgstr ""

#: src/android/aidl/server.md:23
msgid "\"Failed to register service\""
msgstr ""

#: src/android/aidl/server.md:32 src/android/aidl/server.md:33
#, fuzzy
msgid "\"birthday_server\""
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/server.md:34
#, fuzzy
msgid "\"src/server.rs\""
msgstr "ì„œë²„."

#: src/android/aidl/server.md:40 src/android/aidl/client.md:47
msgid "// To avoid dynamic link error.\n"
msgstr ""

#: src/android/aidl/deploy.md:3
msgid "We can now build, push, and start the service:"
msgstr "ì„œë¹„ìŠ¤ë¥¼ ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ì— ë„£ê³ , ì‹œì‘ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/deploy.md:5
#, fuzzy
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/deploy.md:12
msgid "In another terminal, check that the service runs:"
msgstr "ë‹¤ë¥¸ í„°ë¯¸ë„ì„ ë„ì›Œì„œ ì„œë¹„ìŠ¤ê°€ ì˜ ìˆ˜í–‰ë˜ê³  ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/android/aidl/deploy.md:22
msgid "You can also call the service with `service call`:"
msgstr "`service call`ëª…ë ì–´ë¡œ ì„œë¹„ìŠ¤ë¥¼ í˜¸ì¶œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/android/aidl/client.md:1
msgid "AIDL Client"
msgstr "AIDL í´ë¼ì´ì–¸íŠ¸"

#: src/android/aidl/client.md:3
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ, ì•„ê¹Œ ì¶”ê°€í•œ ì„œë¹„ìŠ¤ì— ëŒ€í•œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ëŸ¬ìŠ¤íŠ¸ë¡œ ë§Œë“¤ê² ìŠµë‹ˆë‹¤."

#: src/android/aidl/client.md:5
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:13
msgid "/// Connect to the BirthdayService.\n"
msgstr ""

#: src/android/aidl/client.md:19
msgid "/// Call the birthday service.\n"
msgstr ""

#: src/android/aidl/client.md:29
msgid "\"Failed to connect to BirthdayService\""
msgstr ""

#: src/android/aidl/client.md:31
msgid "\"{msg}\""
msgstr ""

#: src/android/aidl/client.md:40 src/android/aidl/client.md:41
#, fuzzy
msgid "\"birthday_client\""
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:42
#, fuzzy
msgid "\"src/client.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/aidl/client.md:51
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "í´ë¼ì´ì–¸íŠ¸ëŠ” `libbirthdayservice`ì— ì˜ì¡´í•˜ì§€ ì•ŠìŒì— ì£¼ëª©í•˜ì„¸ìš”."

#: src/android/aidl/client.md:53
msgid "Build, push, and run the client on your device:"
msgstr "ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ë¡œ ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/aidl/client.md:55
#, fuzzy
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/aidl/changing.md:3
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"APIë¥¼ í™•ì¥í•˜ì—¬ ë” ë§ì€ ê¸°ëŠ¥ì„ ì œê³µí•´ ë´…ì‹œë‹¤. í´ë¼ì´ì–¸íŠ¸ê°€ ìƒì¼ ì¹´ë“œì— ë‹´ê¸¸ ë‚´"
"ìš©ì„ ì§€ì •í•  ìˆ˜ ìˆë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤:"

#: src/android/logging.md:3
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"`log` í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ ì•ˆë“œë¡œì´ë“œ ë””ë°”ì´ìŠ¤ ì•ˆì—ì„œ ìˆ˜í–‰ë  ë•Œì—ëŠ” `logcat`ìœ¼"
"ë¡œ, í˜¸ìŠ¤íŠ¸ì—ì„œ ìˆ˜í–‰ë  ë•Œì—ëŠ” `stdout`ìœ¼ë¡œ ë¡œê·¸ê°€ ìë™ìœ¼ë¡œ ì¶œë ¥ì´ ë˜ë„ë¡ í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/logging.md:6
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:10 src/android/logging.md:11
#, fuzzy
msgid "\"hello_rust_logs\""
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:14
msgid "\"liblog_rust\""
msgstr ""

#: src/android/logging.md:15
msgid "\"liblogger\""
msgstr ""

#: src/android/logging.md:21
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid "//! Rust logging demo.\n"
msgstr ""

#: src/android/logging.md:27
msgid "/// Logs a greeting.\n"
msgstr ""

#: src/android/logging.md:32
msgid "\"rust\""
msgstr ""

#: src/android/logging.md:35
msgid "\"Starting program.\""
msgstr ""

#: src/android/logging.md:36
msgid "\"Things are going fine.\""
msgstr ""

#: src/android/logging.md:37
msgid "\"Something went wrong!\""
msgstr ""

#: src/android/logging.md:41 src/android/interoperability/with-c/bindgen.md:96
#: src/android/interoperability/with-c/rust.md:72
msgid "Build, push, and run the binary on your device:"
msgstr "ë¹Œë“œí•˜ê³ , ê°€ìƒ ë””ë°”ì´ìŠ¤ì— ë„£ê³ , ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/android/logging.md:43
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"$ m hello_rust_logs\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/hello_rust_logs\n"
"```"

#: src/android/logging.md:49
msgid "The logs show up in `adb logcat`:"
msgstr "`adb logcat`ì»¤ë§¨ë“œë¡œ ë¡œê·¸ë¥¼ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/android/interoperability.md:3
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë‹¤ë¥¸ ì–¸ì–´ì™€ì˜ ìƒí˜¸ìš´ìš©ì„±ì„ í›Œë¥­íˆ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/android/interoperability.md:6
msgid "Call Rust functions from other languages."
msgstr "íƒ€ ì–¸ì–´ì—ì„œ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤."

#: src/android/interoperability.md:7
msgid "Call functions written in other languages from Rust."
msgstr "íƒ€ ì–¸ì–´ì˜ í•¨ìˆ˜ë¥¼ ëŸ¬ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œí•©ë‹ˆë‹¤."

#: src/android/interoperability.md:9
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"íƒ€ ì–¸ì–´ì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ FFI(foreign function interface)ë¼ê³  "
"í•©ë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:1
msgid "Interoperability with C"
msgstr "Cì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/android/interoperability/with-c.md:3
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” C í˜¸ì¶œê·œì•½ì„ ë”°ë¥´ëŠ” ì˜¤ë¸Œì íŠ¸ íŒŒì¼ê³¼ ë§í‚¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ, ë°˜ëŒ€"
"ë¡œ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ë‚´ë³´ë‚´ì„œ Cì—ì„œ í˜¸ì¶œ í•  ìˆ˜ ë„ ìˆìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:6
msgid "You can do it by hand if you want:"
msgstr "ì›í•œë‹¤ë©´ ì•„ë˜ì™€ ê°™ì´ ìˆ˜ë™ìœ¼ë¡œ ì½”ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c.md:16
msgid "\"{x}, {abs_x}\""
msgstr ""

#: src/android/interoperability/with-c.md:20
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"ìš°ë¦¬ëŠ” ì´ë¯¸ [Safe FFI ë˜í¼ ì—°ìŠµë¬¸ì œ](../../exercises/day-3/safe-ffi-wrapper."
"md)ì—ì„œ ì´ë¥¼ ë‹¤ë£¨ì—ˆìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:23
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"ì´ëŸ¬í•œ ë°©ë²•ì€ íƒ€ê²Ÿ í”Œë«í¼ì˜ ëª¨ë“  ë¶€ë¶„ì„ ì‚¬ì „ì— ì•Œê³  ìˆë‹¤ëŠ” ì „ì œë¥¼ ê¹”ê³  ìˆìŠµë‹ˆ"
"ë‹¤. ìƒìš© í”„ë¡œì íŠ¸ì—ì„œëŠ” ê¶Œì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c.md:26
msgid "We will look at better options next."
msgstr "ì¢€ ë” ë‚˜ì€ ì˜µì…˜ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/android/interoperability/with-c/bindgen.md:1
msgid "Using Bindgen"
msgstr "Bindgen ì‚¬ìš©í•˜ê¸°"

#: src/android/interoperability/with-c/bindgen.md:3
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html)ëŠ” C í—¤"
"ë”íŒŒì¼ì—ì„œ ëŸ¬ìŠ¤íŠ¸ ë°”ì¸ë”©ì„ ìë™ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ë„êµ¬ì…ë‹ˆë‹¤."

#: src/android/interoperability/with-c/bindgen.md:6
msgid "First create a small C library:"
msgstr "ë¨¼ì € ì‘ì€ Cë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:8
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:22
msgid "<stdio.h>"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:23
#: src/android/interoperability/with-c/bindgen.md:50
msgid "\"libbirthday.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:26
#: src/android/interoperability/with-c/bindgen.md:29
msgid "\"+--------------\\n\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:27
msgid "\"| Happy Birthday %s!\\n\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:28
msgid "\"| Congratulations with the %i years!\\n\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
msgid "Add this to your `Android.bp` file:"
msgstr "`Android.bp` íŒŒì¼ì— ì•„ë˜ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:106
msgid "_interoperability/bindgen/Android.bp_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:39
#: src/android/interoperability/with-c/bindgen.md:63
msgid "\"libbirthday\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:40
msgid "\"libbirthday.c\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ëŒ€í•œ í—¤ë” íŒŒì¼ì„ ë§Œë“­ë‹ˆë‹¤(ì´ ì˜ˆì‹œì—ì„œëŠ” ë°˜ë“œì‹œ í•„ìš”í•œ ê²ƒì€ ì•„ë‹™"
"ë‹ˆë‹¤.):"

#: src/android/interoperability/with-c/bindgen.md:47
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
msgid "You can now auto-generate the bindings:"
msgstr "ì´ì œ ë°”ì¸ë”©ì„ ìë™ìœ¼ë¡œ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:59
#: src/android/interoperability/with-c/bindgen.md:75
msgid "\"libbirthday_bindgen\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:60
#, fuzzy
msgid "\"birthday_bindgen\""
msgstr "`rust_bindgen`"

#: src/android/interoperability/with-c/bindgen.md:61
msgid "\"libbirthday_wrapper.h\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:62
msgid "\"bindings\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "ë§ˆì¹¨ë‚´, ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ì—ì„œ ë°”ì¸ë”©ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:73
msgid "\"print_birthday_card\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:74
#, fuzzy
msgid "\"main.rs\""
msgstr "_hello_rust/src/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:79
msgid "_interoperability/bindgen/main.rs_:"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:82
msgid "//! Bindgen demo.\n"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:89
msgid "// SAFETY: `print_card` is safe to call with a valid `card` pointer.\n"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:98
#, fuzzy
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/interoperability/with-c/bindgen.md:104
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ, ë°”ì¸ë”©ì´ ì˜ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´, ìë™ ìƒì„±ëœ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰"
"í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/bindgen.md:110
#: src/android/interoperability/with-c/bindgen.md:112
msgid "\"libbirthday_bindgen_test\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:111
msgid "\":libbirthday_bindgen\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:113
msgid "\"general-tests\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:115
#: src/android/interoperability/with-c/bindgen.md:116
msgid "\"none\""
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:115
msgid "// Generated file, skip linting\n"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
msgid "Calling Rust"
msgstr "Cì—ì„œ ëŸ¬ìŠ¤íŠ¸ í˜¸ì¶œ"

#: src/android/interoperability/with-c/rust.md:3
msgid "Exporting Rust functions and types to C is easy:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ íƒ€ì…ê³¼ í•¨ìˆ˜ë¥¼ Cë¡œ ë‚´ë³´ë‚´ëŠ” ê²ƒì€ ê°„ë‹¨í•©ë‹ˆë‹¤:"

#: src/android/interoperability/with-c/rust.md:5
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:8
msgid "//! Rust FFI demo.\n"
msgstr ""

#: src/android/interoperability/with-c/rust.md:12
msgid "/// Analyze the numbers.\n"
msgstr ""

#: src/android/interoperability/with-c/rust.md:17
msgid "\"x ({x}) is smallest!\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:19
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:41
#: src/android/interoperability/with-c/rust.md:68
msgid "\"libanalyze_ffi\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:42
msgid "\"analyze_ffi\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:43
msgid "\"analyze.rs\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
msgid "We can now call this from a C binary:"
msgstr "ì´ì œ ì´ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ Cë°”ì´ë„ˆë¦¬ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/with-c/rust.md:50
msgid "_interoperability/rust/analyze/main.c_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:53
msgid "\"analyze.h\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr ""

#: src/android/interoperability/with-c/rust.md:66
msgid "\"analyze_numbers\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:67
msgid "\"main.c\""
msgstr ""

#: src/android/interoperability/with-c/rust.md:74
#, fuzzy
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"$ m birthday_server\n"
"$ adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"$ adb shell /data/local/tmp/birthday_server\n"
"```"

#: src/android/interoperability/with-c/rust.md:82
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]`ì€ ëŸ¬ìŠ¤íŠ¸ì˜ ë„¤ì„ ë§¹ê¸€ë§(name mangling)ì„ ë¹„í™œì„±í™”í•˜ë¯€ë¡œ ì™¸ë¶€ë¡œ "
"ë…¸ì¶œë˜ëŠ” ì‹¬ë³¼ì˜ ì´ë¦„ì€ í•¨ìˆ˜ì˜ ì´ë¦„ ê·¸ëŒ€ë¡œê°€ ë©ë‹ˆë‹¤. ì‹¬ë³¼ ì´ë¦„ì„ ë°”ê¾¸ê³  ì‹¶ë‹¤"
"ë©´ `#[export_name = \"some_name\"]`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/android/interoperability/cpp.md:1
msgid "With C++"
msgstr "C++ì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/android/interoperability/cpp.md:3
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX í¬ë ˆì´íŠ¸](https://cxx.rs/)ëŠ” ëŸ¬ìŠ¤íŠ¸ì™€ C++ ì‚¬ì´ì˜ ì•ˆì „í•œ ìƒí˜¸ìš´ìš©ì„±ì„ ê°€"
"ëŠ¥í•˜ê²Œ í•´ì¤ë‹ˆë‹¤."

#: src/android/interoperability/cpp.md:6
msgid "The overall approach looks like this:"
msgstr "ì „ì²´ì ì¸ ì ‘ê·¼ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/android/interoperability/cpp/bridge.md:3
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:9
msgid "\"org::blobstore\""
msgstr ""

#: src/android/interoperability/cpp/bridge.md:11
msgid "// Shared structs with fields visible to both languages.\n"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:17
#: src/android/interoperability/cpp/generated-cpp.md:6
msgid "// Rust types and signatures exposed to C++.\n"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:18
#: src/android/interoperability/cpp/rust-bridge.md:6
#: src/android/interoperability/cpp/generated-cpp.md:7
#: src/android/interoperability/cpp/rust-result.md:6
#: src/chromium/interoperability-with-cpp/example-bindings.md:9
#: src/chromium/interoperability-with-cpp/error-handling-qr.md:10
#: src/chromium/interoperability-with-cpp/error-handling-png.md:9
#, fuzzy
msgid "\"Rust\""
msgstr "Rustdoc"

#: src/android/interoperability/cpp/bridge.md:24
#: src/android/interoperability/cpp/cpp-bridge.md:6
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr ""

#: src/android/interoperability/cpp/bridge.md:25
#: src/android/interoperability/cpp/cpp-bridge.md:7
#: src/android/interoperability/cpp/cpp-exception.md:6
#: src/chromium/interoperability-with-cpp/example-bindings.md:15
msgid "\"C++\""
msgstr ""

#: src/android/interoperability/cpp/bridge.md:26
#: src/android/interoperability/cpp/cpp-bridge.md:8
msgid "\"include/blobstore.h\""
msgstr ""

#: src/android/interoperability/cpp/bridge.md:40
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:41
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:44
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""

#: src/android/interoperability/cpp/bridge.md:47
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:1
msgid "Rust Bridge Declarations"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:7
msgid "// Opaque type\n"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:8
msgid "// Method on `MyType`\n"
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:9
#, fuzzy
msgid "// Free function\n"
msgstr "í•¨ìˆ˜"

#: src/android/interoperability/cpp/rust-bridge.md:28
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr ""

#: src/android/interoperability/cpp/rust-bridge.md:30
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""

#: src/android/interoperability/cpp/generated-cpp.md:15
msgid "Results in (roughly) the following C++:"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:1
msgid "C++ Bridge Declarations"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:20
msgid "Results in (roughly) the following Rust:"
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:30
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:39
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:56
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""

#: src/android/interoperability/cpp/cpp-bridge.md:59
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:9
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:23
msgid "Only C-like (unit) enums are supported."
msgstr ""

#: src/android/interoperability/cpp/shared-types.md:24
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""

#: src/android/interoperability/cpp/shared-enums.md:15
#, fuzzy
msgid "Generated Rust:"
msgstr "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸"

#: src/android/interoperability/cpp/shared-enums.md:33
msgid "Generated C++:"
msgstr ""

#: src/android/interoperability/cpp/shared-enums.md:46
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:13
msgid "\"fallible1 requires depth > 0\""
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:16
msgid "\"Success!\""
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:22
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:24
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""

#: src/android/interoperability/cpp/rust-result.md:27
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:7
msgid "\"example/include/example.h\""
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:14
msgid "\"Error: {}\""
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:22
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""

#: src/android/interoperability/cpp/cpp-exception.md:24
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:3
#, fuzzy
msgid "Rust Type"
msgstr "Rust by Example"

#: src/android/interoperability/cpp/type-mapping.md:3
#, fuzzy
msgid "C++ Type"
msgstr "C++ ì˜ˆì œ"

#: src/android/interoperability/cpp/type-mapping.md:5
#, fuzzy
msgid "`rust::String`"
msgstr "`rust_bindgen`"

#: src/android/interoperability/cpp/type-mapping.md:6
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md:6
#, fuzzy
msgid "`rust::Str`"
msgstr "`rust_test`"

#: src/android/interoperability/cpp/type-mapping.md:7
#, fuzzy
msgid "`CxxString`"
msgstr "String"

#: src/android/interoperability/cpp/type-mapping.md:7
msgid "`std::string`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:8
msgid "`&[T]`/`&mut [T]`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:8
#, fuzzy
msgid "`rust::Slice`"
msgstr "`rust_ffi`"

#: src/android/interoperability/cpp/type-mapping.md:9
msgid "`rust::Box<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:10
msgid "`UniquePtr<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:10
msgid "`std::unique_ptr<T>`"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:11
#, fuzzy
msgid "`Vec<T>`"
msgstr "`Vec`"

#: src/android/interoperability/cpp/type-mapping.md:11
#, fuzzy
msgid "`rust::Vec<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md:12
#, fuzzy
msgid "`CxxVector<T>`"
msgstr "`Cell<T>`"

#: src/android/interoperability/cpp/type-mapping.md:12
#, fuzzy
msgid "`std::vector<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/android/interoperability/cpp/type-mapping.md:16
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:18
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:20
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:21
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr ""

#: src/android/interoperability/cpp/type-mapping.md:23
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:1
#: src/android/interoperability/cpp/android-cpp-genrules.md:1
#: src/android/interoperability/cpp/android-build-rust.md:1
msgid "Building in Android"
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:3
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:8
#: src/android/interoperability/cpp/android-build-rust.md:10
msgid "\"libcxx_test_cpp\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:9
msgid "\"cxx_test.cpp\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:11
msgid "\"cxx-bridge-header\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:12
#: src/android/interoperability/cpp/android-cpp-genrules.md:10
msgid "\"libcxx_test_bridge_header\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:14
#: src/android/interoperability/cpp/android-cpp-genrules.md:19
msgid "\"libcxx_test_bridge_code\""
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:20
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:23
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr ""

#: src/android/interoperability/cpp/android-build-cpp.md:25
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:3
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:7
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:11
#: src/android/interoperability/cpp/android-cpp-genrules.md:20
msgid "\"cxxbridge\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:12
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:13
#: src/android/interoperability/cpp/android-cpp-genrules.md:22
#: src/android/interoperability/cpp/android-build-rust.md:8
msgid "\"lib.rs\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:14
msgid "\"lib.rs.h\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:16
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:21
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:23
msgid "\"lib.rs.cc\""
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:29
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""

#: src/android/interoperability/cpp/android-cpp-genrules.md:31
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:3
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:7
msgid "\"cxx_test\""
msgstr ""

#: src/android/interoperability/cpp/android-build-rust.md:9
msgid "\"libcxx\""
msgstr ""

#: src/android/interoperability/java.md:1
msgid "Interoperability with Java"
msgstr "Javaì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/android/interoperability/java.md:3
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"ìë°”ëŠ” [Java Native Interface(JNI)](https://en.wikipedia.org/wiki/"
"Java_Native_Interface)ë¥¼ í†µí•´ ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. [`jni` í¬"
"ë ˆì´íŠ¸](https://docs.rs/jni/)ë¥¼ ì‚¬ìš©í•˜ì—¬ JNI ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/android/interoperability/java.md:8
msgid "First, we create a Rust function to export to Java:"
msgstr "ë¨¼ì €, ìë°”ë¡œ ë‚´ë³´ë‚¼ ëŸ¬ìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/android/interoperability/java.md:10
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md:13
msgid "//! Rust <-> Java FFI demo.\n"
msgstr ""

#: src/android/interoperability/java.md:18
msgid "/// HelloWorld::hello method implementation.\n"
msgstr ""

#: src/android/interoperability/java.md:21
msgid "\"system\""
msgstr ""

#: src/android/interoperability/java.md:27
msgid "\"Hello, {input}!\""
msgstr ""

#: src/android/interoperability/java.md:33
#: src/android/interoperability/java.md:63
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md:37
#: src/android/interoperability/java.md:70
msgid "\"libhello_jni\""
msgstr ""

#: src/android/interoperability/java.md:38
#: src/android/interoperability/java.md:53
msgid "\"hello_jni\""
msgstr ""

#: src/android/interoperability/java.md:40
msgid "\"libjni\""
msgstr ""

#: src/android/interoperability/java.md:44
msgid "Finally, we can call this function from Java:"
msgstr "ìë°”ì—ì„œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/android/interoperability/java.md:46
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:67
msgid "\"helloworld_jni\""
msgstr ""

#: src/android/interoperability/java.md:68
#, fuzzy
msgid "\"HelloWorld.java\""
msgstr "Hello World!"

#: src/android/interoperability/java.md:69
#, fuzzy
msgid "\"HelloWorld\""
msgstr "Hello World!"

#: src/android/interoperability/java.md:74
msgid "Finally, you can build, sync, and run the binary:"
msgstr "ë§ˆì§€ë§‰ìœ¼ë¡œ ë°”ì´ë„ˆë¦¬ë¥¼ ë¹Œë“œ, ì‹±í¬, ì‹¤í–‰í•©ë‹ˆë‹¤:"

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"ë§ˆì§€ë§‰ ì—°ìŠµë¬¸ì œëŠ” ì—¬ëŸ¬ë¶„ì´ ì‘ì—…í•˜ê³  ìˆëŠ” í”„ë¡œì íŠ¸ ì¤‘ í•˜ë‚˜ë¥¼ FFIë¡œ ëŸ¬ìŠ¤íŠ¸ì™€ ì—°"
"ê³„ í•´ë³´ëŠ” ê²ƒì…ë‹ˆë‹¤. ëª‡ ê°€ì§€ ì˜ˆì‹œì…ë‹ˆë‹¤:"

#: src/exercises/android/morning.md:6
msgid "Call your AIDL service with a client written in Rust."
msgstr "ë‹¹ì‹ ì˜ AIDLì„œë¹„ìŠ¤ë¥¼ ëŸ¬ìŠ¤íŠ¸ í´ë¼ì´ì–¸íŠ¸ì—ì„œ í˜¸ì¶œí•´ë´…ë‹ˆë‹¤."

#: src/exercises/android/morning.md:8
msgid "Move a function from your project to Rust and call it."
msgstr "ë‹¹ì‹ ì˜ í”„ë¡œì íŠ¸ì˜ í•¨ìˆ˜ë¥¼ ëŸ¬ìŠ¤íŠ¸ë¡œ ì˜®ê¸°ê³  í˜¸ì¶œí•´ë´…ë‹ˆë‹¤."

#: src/exercises/android/morning.md:12
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"ì´ ì—°ìŠµë¬¸ì œëŠ” ì—´ë ¤ìˆê¸° ë•Œë¬¸ì— í•´ë‹µì´ ì œê³µë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í´ë˜ìŠ¤ì—ì„œ ì œì¶œëœ ì½”"
"ë“œì— ì˜ì¡´í•©ë‹ˆë‹¤."

#: src/chromium.md:1
#, fuzzy
msgid "Welcome to Rust in Chromium"
msgstr "1ì¼ì°¨ ê°œìš”"

#: src/chromium.md:3
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""

#: src/chromium.md:6
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""

#: src/chromium/setup.md:3
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""

#: src/chromium/setup.md:13
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr ""

#: src/chromium/setup.md:16
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""

#: src/chromium/setup.md:21
msgid "It's also recommended that you have Visual Studio code installed."
msgstr ""

#: src/chromium/setup.md:23
msgid "About the exercises"
msgstr ""

#: src/chromium/setup.md:25
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""

#: src/chromium/cargo.md:3
msgid ""
"Rust community typically uses `cargo` and libraries from [crates.io](https://"
"crates.io/). Chromium is built using `gn` and `ninja` and a curated set of "
"dependencies."
msgstr ""

#: src/chromium/cargo.md:6
msgid "When writing code in Rust, your choices are:"
msgstr ""

#: src/chromium/cargo.md:8
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""

#: src/chromium/cargo.md:11
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""

#: src/chromium/cargo.md:13
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""

#: src/chromium/cargo.md:16
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""

#: src/chromium/cargo.md:20
#, fuzzy
msgid "Mini exercise"
msgstr "ì—°ìŠµë¬¸ì œ"

#: src/chromium/cargo.md:22
msgid "Split into small groups and:"
msgstr ""

#: src/chromium/cargo.md:24
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr ""

#: src/chromium/cargo.md:26
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""

#: src/chromium/cargo.md:31
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""

#: src/chromium/cargo.md:35
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr ""

#: src/chromium/cargo.md:38
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""

#: src/chromium/cargo.md:44
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""

#: src/chromium/cargo.md:46
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""

#: src/chromium/cargo.md:49
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""

#: src/chromium/cargo.md:56
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""

#: src/chromium/cargo.md:57
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr ""

#: src/chromium/cargo.md:59
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr ""

#: src/chromium/cargo.md:61
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""

#: src/chromium/cargo.md:66
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""

#: src/chromium/cargo.md:71
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr ""

#: src/chromium/cargo.md:72
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""

#: src/chromium/cargo.md:74
msgid "Fontations libraries like `font-types`"
msgstr ""

#: src/chromium/cargo.md:75
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""

#: src/chromium/cargo.md:77
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain.)"
msgstr ""

#: src/chromium/cargo.md:80
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, by `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""

#: src/chromium/cargo.md:84
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr ""

#: src/chromium/cargo.md:87
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""

#: src/chromium/cargo.md:90
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""

#: src/chromium/cargo.md:92
msgid "`cargo`, `rustfmt`, etc."
msgstr ""

#: src/chromium/cargo.md:93
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""

#: src/chromium/cargo.md:95
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr ""

#: src/chromium/cargo.md:96
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""

#: src/chromium/cargo.md:98
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr ""

#: src/chromium/policy.md:1
msgid "Chromium Rust policy"
msgstr ""

#: src/chromium/policy.md:3
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""

#: src/chromium/policy.md:7
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""

#: src/chromium/policy.md:12
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""

#: src/chromium/policy.md:15
#, fuzzy
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
"  ìŠ¤íƒ                            í™\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/chromium/policy.md:30
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""

#: src/chromium/policy.md:33
msgid "Because of this, today's course will be heavily focused on:"
msgstr ""

#: src/chromium/policy.md:35
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr ""

#: src/chromium/policy.md:36
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr ""

#: src/chromium/policy.md:38
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr ""

#: src/chromium/build-rules.md:1
#, fuzzy
msgid "Build rules"
msgstr "ë¹Œë“œ ê·œì¹™"

#: src/chromium/build-rules.md:3
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""

#: src/chromium/build-rules.md:7
msgid "Adding Rust code to Chromium"
msgstr ""

#: src/chromium/build-rules.md:9
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr ""

#: src/chromium/build-rules.md:11
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules.md:20
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""

#: src/chromium/build-rules.md:25
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""

#: src/chromium/build-rules.md:31
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""

#: src/chromium/build-rules.md:34
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""

#: src/chromium/build-rules/unsafe.md:1
msgid "Including `unsafe` Rust Code"
msgstr ""

#: src/chromium/build-rules/unsafe.md:3
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""

#: src/chromium/build-rules/unsafe.md:7
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules/depending.md:3
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr ""

#: src/chromium/build-rules/depending.md:5
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/build-rules/vscode.md:3
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""

#: src/chromium/build-rules/vscode.md:6
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""

#: src/chromium/build-rules/vscode.md:8
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr ""

#: src/chromium/build-rules/vscode.md:10
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr ""

#: src/chromium/build-rules/vscode.md:16
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""

#: src/chromium/build-rules/vscode.md:19
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""

#: src/chromium/build-rules/vscode.md:22
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr ""

#: src/chromium/build-rules/vscode.md:23
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""

#: src/chromium/build-rules/vscode.md:25
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""

#: src/chromium/build-rules/vscode.md:27
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""

#: src/chromium/build-rules/vscode.md:29
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""

#: src/chromium/build-rules/vscode.md:32
msgid ""
"Demo **type annotations** (there are quote a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""

#: src/chromium/build-rules/vscode.md:35
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""

#: src/exercises/chromium/build-rules.md:1
#, fuzzy
msgid "Build rules exercise"
msgstr "ë¹Œë“œ ê·œì¹™"

#: src/exercises/chromium/build-rules.md:3
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""

#: src/exercises/chromium/build-rules.md:13
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to to allow unsafe code in your `gn` "
"target."
msgstr ""

#: src/exercises/chromium/build-rules.md:16
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""

#: src/exercises/chromium/build-rules.md:24
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""

#: src/exercises/chromium/build-rules.md:28
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""

#: src/exercises/chromium/build-rules.md:32
#: src/exercises/chromium/interoperability-with-cpp.md:48
msgid "Where to find help"
msgstr ""

#: src/exercises/chromium/build-rules.md:34
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""

#: src/exercises/chromium/build-rules.md:35
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""

#: src/exercises/chromium/build-rules.md:36
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""

#: src/exercises/chromium/build-rules.md:37
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""

#: src/exercises/chromium/build-rules.md:38
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""

#: src/exercises/chromium/build-rules.md:44
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""

#: src/exercises/chromium/build-rules.md:48
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""

#: src/exercises/chromium/build-rules.md:52
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""

#: src/chromium/testing.md:3
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""

#: src/chromium/testing.md:17
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""

#: src/chromium/testing.md:22
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr ""

#: src/chromium/testing.md:24
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""

#: src/chromium/testing.md:26
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""

#: src/chromium/testing.md:29
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""

#: src/chromium/testing.md:35
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""

#: src/chromium/testing.md:39
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""

#: src/chromium/testing.md:42
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""

#: src/chromium/testing.md:47
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:3
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:5
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:7
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md:10
#, fuzzy
msgid "Example:"
msgstr "ì˜ˆì œ"

#: src/chromium/testing/build-gn.md:3
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""

#: src/chromium/testing/build-gn.md:6
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/build-gn.md:14
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""

#: src/chromium/testing/build-gn.md:17
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:3
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:12
msgid "\"//ui/base:my_rust_lib\""
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:18
msgid "Under the covers the macro expands to something similar to:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:26
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""

#: src/chromium/testing/chromium-import-macro.md:31
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""

#: src/exercises/chromium/testing.md:1
#, fuzzy
msgid "Testing exercise"
msgstr "Rust on Exercism"

#: src/exercises/chromium/testing.md:3
msgid "Time for another exercise!"
msgstr ""

#: src/exercises/chromium/testing.md:5
msgid "In your Chromium build:"
msgstr ""

#: src/exercises/chromium/testing.md:7
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""

#: src/exercises/chromium/testing.md:10
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr ""

#: src/exercises/chromium/testing.md:11
msgid "Add the new tests to `BUILD.gn`."
msgstr ""

#: src/exercises/chromium/testing.md:12
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:3
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:6
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:12
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""
"ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ì„œëŠ”[CXX íŠœí† ë¦¬ì–¼](https://cxx.rs/tutorial.html) ë¥¼ ì°¸ì¡°"
"í•©ë‹ˆë‹¤."

#: src/chromium/interoperability-with-cpp.md:19
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:23
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:27
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:31
msgid "The tool and the library can handle a set of core types - for example:"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:32
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""

#: src/chromium/interoperability-with-cpp.md:37
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""

#: src/chromium/interoperability-with-cpp.md:41
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:3
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:16
msgid "\"example/include/blobstore.h\""
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:24
msgid "// Definitions of Rust types and functions go here\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:30
msgid "Point out:"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:32
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:36
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:37
#, fuzzy
msgid "Native support for Rust slices in C++"
msgstr "ë‚´ì¥ í…ŒìŠ¤íŠ¸ ì§€ì›."

#: src/chromium/interoperability-with-cpp/example-bindings.md:38
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:39
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md:41
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:3
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:5
msgid "CXX fundamentally suits cases where:"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:7
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:8
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:11
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:14
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:26
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:28
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr ""

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md:29
msgid "Function pointers are awkward to use."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:3
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:6
msgid "The `T` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:7
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:9
msgid "A primitive type (like `u32` or `usize`)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:10
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:12
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:16
msgid "The `E` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:17
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md:19
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:1
#, fuzzy
msgid "CXX Error Handling: QR Example"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:3
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:8
msgid "\"qr_code_generator\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:23
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:27
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md:32
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data canâ€™t be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:1
#, fuzzy
msgid "CXX Error Handling: PNG Example"
msgstr "ì˜¤ë¥˜ì²˜ë¦¬"

#: src/chromium/interoperability-with-cpp/error-handling-png.md:3
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:7
msgid "\"gfx::rust_bindings\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:10
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:14
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:21
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:32
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md:37
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:1
msgid "Using cxx in Chromium"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:3
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:7
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:13
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:16
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:19
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:22
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:27
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:29
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md:36
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:1
#, fuzzy
msgid "Exercise: Interoperability with C++"
msgstr "Cì™€ì˜ ìƒí˜¸ìš´ìš©ì„±"

#: src/exercises/chromium/interoperability-with-cpp.md:3
msgid "Part one"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:5
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:8
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:10
msgid "Modify your `gn` target to build these bindings."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:11
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:13
msgid "Build and run!"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:15
msgid "Part two"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:17
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:20
#, fuzzy
msgid "Some things to try:"
msgstr "ì°¸ê³ ì‚¬í•­:"

#: src/exercises/chromium/interoperability-with-cpp.md:22
msgid "Call back into C++ from Rust. You will need:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:23
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:25
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:27
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:29
msgid "Pass a C++ string from C++ into Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:30
msgid "Pass a reference to a C++ object into Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:31
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:33
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:35
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:37
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:39
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:40
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:42
msgid "Part three"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:44
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:50
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:51
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:57
msgid "Some of the questions you may encounter:"
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:59
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""

#: src/exercises/chromium/interoperability-with-cpp.md:62
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""

#: src/chromium/adding-third-party-crates.md:3
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""

#: src/chromium/adding-third-party-crates.md:6
#, fuzzy
msgid "C++ library"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/chromium/adding-third-party-crates.md:6
#, fuzzy
msgid "Rust crate"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„"

#: src/chromium/adding-third-party-crates.md:8
#, fuzzy
msgid "Build system"
msgstr "ëŸ¬ìŠ¤íŠ¸ ìƒíƒœê³„"

#: src/chromium/adding-third-party-crates.md:8
#: src/chromium/adding-third-party-crates.md:10
msgid "Lots"
msgstr ""

#: src/chromium/adding-third-party-crates.md:8
msgid "Consistent: `Cargo.toml`"
msgstr ""

#: src/chromium/adding-third-party-crates.md:9
msgid "Typical library size"
msgstr ""

#: src/chromium/adding-third-party-crates.md:9
msgid "Large-ish"
msgstr ""

#: src/chromium/adding-third-party-crates.md:9
msgid "Small"
msgstr ""

#: src/chromium/adding-third-party-crates.md:10
msgid "Transitive dependencies"
msgstr ""

#: src/chromium/adding-third-party-crates.md:10
msgid "Few"
msgstr ""

#: src/chromium/adding-third-party-crates.md:12
msgid "For a Chromium engineer, this has pros and cons:"
msgstr ""

#: src/chromium/adding-third-party-crates.md:14
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""

#: src/chromium/adding-third-party-crates.md:16
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr ""

#: src/chromium/adding-third-party-crates.md:19
msgid "We'll discuss:"
msgstr ""

#: src/chromium/adding-third-party-crates.md:21
msgid "How to put a crate in the Chromium source code tree"
msgstr ""

#: src/chromium/adding-third-party-crates.md:22
msgid "How to make `gn` build rules for it"
msgstr ""

#: src/chromium/adding-third-party-crates.md:23
msgid "How to audit its source code for sufficient safety."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:1
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:3
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:6
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:14
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md:18
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:3
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:6
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:15
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:15
msgid "For instance,"
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:22
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md:25
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:3
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:6
msgid "To start, download the crate you want like this:"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:13
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:17
msgid "This `vendor` command may download:"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:19
#, fuzzy
msgid "Your crate"
msgstr "ìœ ìš©í•œ í¬ë ˆì´íŠ¸"

#: src/chromium/adding-third-party-crates/downloading-crates.md:20
msgid "Direct and transitive dependencies"
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:21
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""

#: src/chromium/adding-third-party-crates/downloading-crates.md:24
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:3
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:9
msgid "Now run `git status`. You should find:"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:11
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:13
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:15
msgid "An appropriate `README.chromium`"
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:17
#, fuzzy
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"ìì„¸í•œ ì‚¬í•­ì€ [ê³µì‹ë¬¸ì„œ](https://doc.rust-lang.org/reference/type-layout."
"html)ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:19
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr ""

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md:23
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:3
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:8
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:10
msgid "build script effect"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:10
msgid "Supported by our gn templates"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:10
msgid "Work required by you"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:12
msgid "Checking rustc version to configure features on and off"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:12
#: src/chromium/adding-third-party-crates/resolving-problems.md:13
msgid "None"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:13
msgid "Checking platform or CPU to configure features on and off"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:14
#, fuzzy
msgid "Generating code"
msgstr "ì œë„¤ë¦­"

#: src/chromium/adding-third-party-crates/resolving-problems.md:14
msgid "Yes - specify in `gnrt_config.toml`"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:15
msgid "Building C/C++"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:15
#: src/chromium/adding-third-party-crates/resolving-problems.md:16
msgid "Patch around it"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:16
msgid "Arbitrary other actions"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems.md:18
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:3
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:6
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:11
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md:17
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:3
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:8
msgid "So, your options are:"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:10
msgid "Avoid these crates"
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:11
msgid "Apply a patch to the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md:13
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:3
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:7
#, fuzzy
msgid "Specifically,"
msgstr "OSê°€ ì •ì˜í•¨"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:9
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md:17
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:1
msgid "Auditing Third Party Crates"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:3
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:9
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:11
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:13
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:17
msgid "Check each crate seems to be reasonably well maintained"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:18
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:21
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:22
msgid "Check for any use of `fs` or `net` APIs"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:23
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""

#: src/chromium/adding-third-party-crates/reviews-and-audits.md:27
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:1
msgid "Checking Crates into Chromium Source Code"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:3
msgid "`git status` should reveal:"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:5
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:6
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:9
msgid "Please also add an `OWNERS` file in the latter location."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:11
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:14
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""

#: src/chromium/adding-third-party-crates/checking-in.md:17
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md:3
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""

#: src/exercises/chromium/third-party.md:3
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""

#: src/exercises/chromium/third-party.md:7
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""

#: src/exercises/chromium/third-party.md:13
msgid "Students will need to download lots of transitive dependencies."
msgstr ""

#: src/exercises/chromium/third-party.md:15
msgid "The total crates needed are:"
msgstr ""

#: src/exercises/chromium/third-party.md:17
#, fuzzy
msgid "`instant`,"
msgstr "ìƒìˆ˜(constant)"

#: src/exercises/chromium/third-party.md:18
msgid "`lock_api`,"
msgstr ""

#: src/exercises/chromium/third-party.md:19
msgid "`parking_lot`,"
msgstr ""

#: src/exercises/chromium/third-party.md:20
msgid "`parking_lot_core`,"
msgstr ""

#: src/exercises/chromium/third-party.md:21
msgid "`redox_syscall`,"
msgstr ""

#: src/exercises/chromium/third-party.md:22
msgid "`scopeguard`,"
msgstr ""

#: src/exercises/chromium/third-party.md:23
msgid "`smallvec`, and"
msgstr ""

#: src/exercises/chromium/third-party.md:24
msgid "`uwuify`."
msgstr ""

#: src/exercises/chromium/third-party.md:26
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""

#: src/exercises/chromium/third-party.md:29
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:1
msgid "Bringing It Together --- Exercise"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:3
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:6
msgid "The Brief from Product Management"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:8
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:11
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:13
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:17
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:19
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:22
msgid "Steps"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:24
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:28
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:36
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:39
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:42
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:49
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""

#: src/exercises/chromium/bringing-it-together.md:52
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""

#: src/exercises/chromium/solutions.md:3
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""

#: src/bare-metal.md:1
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "Welcome to Comprehensive Rust ğŸ¦€"

#: src/bare-metal.md:3
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"ì´ ê³¼ì •ì€ Rustì— ëŒ€í•´ ì–´ëŠì •ë„ ê²½í—˜ì´ ìˆê³  (ì•„ë§ˆë„ Comprehensive Rust ê³¼ì •ì„ "
"í†µí•´) Cì™€ ê°™ì€ ë‹¤ë¥¸ ì–¸ì–´ë¡œ bare-metal í”„ë¡œê·¸ë˜ë°ì„ í•´ ë³¸ ì‚¬ìš©ìë¥¼ ëŒ€ìƒìœ¼ë¡œ í•˜"
"ëŠ” bare-metal Rustì— ê´€í•œ ë…ë¦½ì ì¸ 1ì¼ ê³¼ì •ì…ë‹ˆë‹¤."

#: src/bare-metal.md:8
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"ì˜¤ëŠ˜ì€ OSë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  Rust ì½”ë“œë¥¼ ì‹¤í–‰í•˜ëŠ” 'bare-metal' Rustì— ê´€í•´ ì•Œì•„"
"ë´…ë‹ˆë‹¤. ë³¸ ê°•ì˜ì˜ êµ¬ì„±ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/bare-metal.md:11
msgid "What is `no_std` Rust?"
msgstr "`no_std` Rustë€ ë¬´ì—‡ì¸ê°€ìš”?"

#: src/bare-metal.md:12
msgid "Writing firmware for microcontrollers."
msgstr "ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ìš© íŒì›¨ì–´ ì‘ì„±"

#: src/bare-metal.md:13
msgid "Writing bootloader / kernel code for application processors."
msgstr "ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œë¥¼ ìœ„í•œ ë¶€íŠ¸ë¡œë” / ì»¤ë„ ì½”ë“œ ì‘ì„±"

#: src/bare-metal.md:14
msgid "Some useful crates for bare-metal Rust development."
msgstr "bare-metal Rust ê°œë°œì„ ìœ„í•œ ìœ ìš©í•œ í¬ë ˆì´íŠ¸"

#: src/bare-metal.md:16
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"ì´ ê°•ì˜ì—ì„œëŠ” [BBC micro:bit](https://microbit.org/) v2ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì‚¬"
"ìš©í•©ë‹ˆë‹¤. ì´ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” Nordic nRF51822 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— ê¸°ë°˜í•œ [ê°œ"
"ë°œ ë³´ë“œ](https://tech.microbit.org/hardware/)ë¡œì¨, LEDì™€ ë²„íŠ¼, I2C ì—°ê²° ê°€ì†"
"ë„ê³„ ë° ë‚˜ì¹¨ë°˜, ì˜¨ë³´ë“œ SWD ë””ë²„ê±°ë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal.md:22
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""
"ì‹œì‘í•˜ê¸°ì „ì—, ì•ìœ¼ë¡œ ì‚¬ìš©í•  ë„êµ¬ë¥¼ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. gLinux ë˜ëŠ” Debianë¥¼ ì‚¬ìš©"
"í•˜ê³  ìˆë‹¤ë©´ ì•„ë˜ì™€ ê°™ì´ í•˜ì„¸ìš”."

#: src/bare-metal.md:34
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""
"`plugdev` ê·¸ë£¹ì˜ ì‚¬ìš©ìì—ê²Œ micro:bit í”„ë¡œê·¸ë˜ë¨¸ ì¥ì¹˜ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ ê¶Œí•œì„ ë¶€"
"ì—¬í•©ë‹ˆë‹¤."

#: src/bare-metal.md:44 src/bare-metal/microcontrollers/debugging.md:33
msgid "On MacOS:"
msgstr "MacOSì—ì„œ:"

#: src/bare-metal/no_std.md:7
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md:17
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md:24
msgid "Slices, `&str`, `CStr`"
msgstr "Slices, `&str`, `CStr`"

#: src/bare-metal/no_std.md:25
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md:26
msgid "`Option`, `Result`"
msgstr "`Option`, `Result`"

#: src/bare-metal/no_std.md:27
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`, `Debug`, `write!`..."

#: src/bare-metal/no_std.md:29
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`, `assert_eq!`..."

#: src/bare-metal/no_std.md:30
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` ë° ëª¨ë“  ì¼ë°˜ì ì¸ í¬ì¸í„° ê´€ë ¨ í•¨ìˆ˜"

#: src/bare-metal/no_std.md:31
msgid "`Future` and `async`/`await`"
msgstr "`Future` and `async`/`await`"

#: src/bare-metal/no_std.md:32
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."

#: src/bare-metal/no_std.md:33
msgid "`Duration`"
msgstr "`Duration`"

#: src/bare-metal/no_std.md:38
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`, `Cow`, `Arc`, `Rc`"

#: src/bare-metal/no_std.md:39
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"

#: src/bare-metal/no_std.md:40
msgid "`String`, `CString`, `format!`"
msgstr "`String`, `CString`, `format!`"

#: src/bare-metal/no_std.md:45
msgid "`Error`"
msgstr "`Error`"

#: src/bare-metal/no_std.md:47
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"

#: src/bare-metal/no_std.md:48
msgid "`File` and the rest of `fs`"
msgstr "`File` ë° ë‚˜ë¨¸ì§€ `fs`"

#: src/bare-metal/no_std.md:49
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`, `Read`, `Write`, `Stdin`, `Stdout` ë° ë‚˜ë¨¸ì§€ `io`"

#: src/bare-metal/no_std.md:50
msgid "`Path`, `OsString`"
msgstr "`Path`, `OsString`"

#: src/bare-metal/no_std.md:51
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md:52
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`, `Child`, `ExitCode`"

#: src/bare-metal/no_std.md:53
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`, `sleep` ë° ë‚˜ë¨¸ì§€ `thread`"

#: src/bare-metal/no_std.md:54
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`, `Instant`"

#: src/bare-metal/no_std.md:62
msgid "`HashMap` depends on RNG."
msgstr "`HashMap`ì€ RNGì— ì˜ì¡´í•©ë‹ˆë‹¤."

#: src/bare-metal/no_std.md:63
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std`ëŠ” `core` ë° `alloc`ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/bare-metal/minimal.md:1
msgid "A minimal `no_std` program"
msgstr "ìµœì†Œí•œì˜ `no_std` í”„ë¡œê·¸ë¨"

#: src/bare-metal/minimal.md:19
msgid "This will compile to an empty binary."
msgstr "ì´ ì½”ë“œëŠ” ë¹ˆ ë°”ì´ë„ˆë¦¬ë¡œ ì»´íŒŒì¼ë©ë‹ˆë‹¤."

#: src/bare-metal/minimal.md:20
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""
"`std`ëŠ” íŒ¨ë‹‰ í•¸ë“¤ëŸ¬ë¥¼ ì œê³µí•˜ì§€ë§Œ, ìš°ë¦¬ëŠ” ìì²´ì ìœ¼ë¡œ í•¸ë“¤ëŸ¬ë¥¼ ë§Œë“¤ì–´ì•¼í•©ë‹ˆë‹¤."

#: src/bare-metal/minimal.md:21
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "íŒ¨ë‹‰ í•¸ë“¤ëŸ¬ëŠ” `panic-halt`ì™€ ê°™ì€ í¬ë ˆì´íŠ¸ë¥¼ í†µí•´ì„œ ë§Œë“¤ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/minimal.md:22
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"íƒ€ê²Ÿì— ë”°ë¼ `panic = \"abort\"`ë¡œ ì»´íŒŒì¼í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” "
"`eh_personality`ì— ê´€í•œ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤."

#: src/bare-metal/minimal.md:24
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"`main` ê³¼ ê°™ì€ í”„ë¡œê·¸ë¨ ì§„ì…ì ì´ ì—†ìŠµë‹ˆë‹¤. ê°œë°œìê°€ ìì²´ì ìœ¼ë¡œ ì§„ì…ì ì„ ì •ì˜"
"í•´ì•¼ í•©ë‹ˆë‹¤. ì§„ì…ì ì„ ì •ì˜í•˜ëŠ” ì‘ì—…ì€, ì¼ë°˜ì ìœ¼ë¡œ ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸ì™€ ì–´ì…ˆë¸”ë¦¬ ì½”"
"ë“œë¥¼ í•„ìš”ë¡œ í•©ë‹ˆë‹¤."

#: src/bare-metal/alloc.md:3
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"`alloc`ì„ ì‚¬ìš©í•˜ë ¤ë©´ [ì „ì—­ (í™) í• ë‹¹ì](https://doc.rust-lang.org/stable/std/"
"alloc/trait.GlobalAlloc.html)ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/bare-metal/alloc.md:23
msgid ""
"// Safe because `HEAP` is only used here and `entry` is only called once.\n"
msgstr ""

#: src/bare-metal/alloc.md:25
msgid "// Give the allocator some memory to allocate.\n"
msgstr ""

#: src/bare-metal/alloc.md:29
msgid "// Now we can do things that require heap allocation.\n"
msgstr ""

#: src/bare-metal/alloc.md:31
#, fuzzy
msgid "\"A string\""
msgstr "String"

#: src/bare-metal/alloc.md:37
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator`ëŠ” ê°„ë‹¨í•œ ë²„ë”” ì‹œìŠ¤í…œ í• ë‹¹ìë¥¼ êµ¬í˜„í•˜ëŠ” ì„œë“œ íŒŒí‹° í¬"
"ë ˆì´íŠ¸ì…ë‹ˆë‹¤. ì´ ì™¸ì—ë„, ë‹¤ë¥¸ í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜, ì§ì ‘ í• ë‹¹ìë¥¼ ë§Œë“¤ê±°ë‚˜, "
"ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë‹¤ë¥¸ í• ë‹¹ìì— í›„í‚¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/alloc.md:40
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"`LockHeap` íƒ€ì…ì˜ const ë§¤ê°œë³€ìˆ˜ëŠ” í• ë‹¹ìì˜ ìµœëŒ€ í¬ê¸°ë¥¼ 2ì§„ìˆ˜ë¡œ í‘œí˜„í–ˆì„ ë•Œ"
"ì˜ ìë¦¿ìˆ˜ì…ë‹ˆë‹¤. ì¦‰, ì´ ê²½ìš°ì²˜ëŸ¼ 32ì¸ ê²½ìš° ìµœëŒ€ 2\\*\\*32ë°”ì´íŠ¸ í¬ê¸°ì˜ ì˜ì—­"
"ì„ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/alloc.md:42
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"í•œ ë°”ì´ë„ˆë¦¬ì—ì„œ `alloc`ì— ì˜ì¡´í•˜ëŠ” í¬ë ˆì´íŠ¸ê°€ í•˜ë‚˜ë¼ë„ ìˆë‹¤ë©´ ë°”ì´ë„ˆë¦¬ ì „ì²´ì—"
"ì„œ ì „ì—­ í• ë‹¹ìê°€ ë°˜ë“œì‹œ í•˜ë‚˜ ì¡´ì¬í•´ì•¼ í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì „ì—­ í• ë‹¹ìë¥¼ ì„ ì–¸í•˜"
"ëŠ” ì‘ì—…ì€ ìµœìƒìœ„ ë°”ì´ë„ˆë¦¬ í¬ë ˆì´íŠ¸ì—ì„œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤."

#: src/bare-metal/alloc.md:45
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"`panic_halt` í¬ë ˆì´íŠ¸ê°€ ì—°ê²°ë˜ì–´ íŒ¨ë‹‰ í•¸ë“¤ëŸ¬ë¥¼ ê°€ì ¸ì˜¤ë„ë¡ í•˜ë ¤ë©´ `extern "
"crate panic_halt as _`ê°€ í•„ìš”í•©ë‹ˆë‹¤."

#: src/bare-metal/alloc.md:47
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""
"ì´ ì˜ˆì‹œ ì½”ë“œëŠ” ë¹Œë“œëŠ” ë˜ì§€ë§Œ, ì§„ì…ì ì´ ì—†ê¸° ë•Œë¬¸ì— ì‹¤í–‰ë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers.md:3
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"'cortex_m_rt' í¬ë ˆì´íŠ¸ëŠ” Cortex M ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì´ˆê¸°í™” í•˜ëŠ” í•¸ë“¤ëŸ¬ë¥¼ ì œ"
"ê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers.md:24
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""
"ì´ì œ, ì£¼ë³€ì¥ì¹˜ì— ì•¡ì„¸ìŠ¤í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ê°€ì¥ ê¸°ê³„ì— ê°€ê¹Œìš´ ë‚®ì€ ë‹¨"
"ê³„ì—ì„œ ì‹œì‘í•´ì„œ ì ì  ì¶”ìƒí™” ìˆ˜ì¤€ì„ ì˜¬ë¦¬ê² ìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers.md:29
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"`cortex_m_rt::entry` ë§¤í¬ë¡œëŠ” ì§„ì…ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ê°€`fn() -> !` íƒ€ì…(ì¦‰, "
"ë¦¬í„´í•˜ì§€ ì•ŠëŠ”)ì„ì„ ìš”êµ¬í•©ë‹ˆë‹¤. ë§Œì•½, ë¦¬í„´í•˜ê²Œ ë˜ë©´, í”„ë¡œê·¸ë¨ ìˆ˜í–‰ í›„ ë¦¬ì…‹ í•¸"
"ë“¤ëŸ¬ë¡œ ëŒì•„ê°€ê²Œ ë˜ëŠ” ê²ƒì¸ë° ì´ëŠ” ë§ì´ ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers.md:31
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "`cargo embed --bin minimal`ì„ ì‚¬ìš©í•˜ì—¬ ì˜ˆì‹œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/mmio.md:3
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ë©”ëª¨ë¦¬ ë§¤í•‘ IOë¥¼ í†µí•´ ì£¼ë³€ê¸°ê¸°ì— ì•¡ì„¸ìŠ¤í•©ë‹ˆë‹¤. "
"micro:bitì—ì„œ LEDë¥¼ ì¼œë³´ê² ìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/mmio.md:16
msgid "/// GPIO port 0 peripheral address\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:19
msgid "// GPIO peripheral offsets\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:24
msgid "// PIN_CNF fields\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:34
#: src/bare-metal/microcontrollers/pacs.md:21
#: src/bare-metal/microcontrollers/hals.md:26
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:37
#: src/bare-metal/microcontrollers/mmio.md:59
msgid ""
"// Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:56
#: src/bare-metal/microcontrollers/pacs.md:39
#: src/bare-metal/microcontrollers/hals.md:30
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:72
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""
"GPIO 0 í•€ 21ì€ LED ë§¤íŠ¸ë¦­ìŠ¤ì˜ ì²« ë²ˆì§¸ ì—´ì— ì—°ê²°ë˜ê³  í•€ 28ì€ ì²« ë²ˆì§¸ í–‰ì— ì—°ê²°"
"ë©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/mmio.md:75
#: src/bare-metal/microcontrollers/pacs.md:61
#: src/bare-metal/microcontrollers/hals.md:44
#: src/bare-metal/microcontrollers/board-support.md:37
msgid "Run the example with:"
msgstr "ì•„ë˜ ëª…ë ¹ì–´ë¡œ ì˜ˆì œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì„¸ìš”."

#: src/bare-metal/microcontrollers/pacs.md:1
msgid "Peripheral Access Crates"
msgstr "ì£¼ë³€ê¸°ê¸° ì•¡ì„¸ìŠ¤ í¬ë ˆì´íŠ¸"

#: src/bare-metal/microcontrollers/pacs.md:3
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) í¬ë ˆì´íŠ¸ë¥¼ ì´ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ë§¤"
"í•‘ëœ ì£¼ë³€ì¥ì¹˜ë¥¼ ê¸°ìˆ í•˜ëŠ” [CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html) íŒŒì¼ë¡œë¶€í„° Rust ë˜í¼ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/pacs.md:49
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"SVD(System View Description) íŒŒì¼ì€ ì¼ë°˜ì ìœ¼ë¡œ ì‹¤ë¦¬ì½˜ ê³µê¸‰ì—…ì²´ì—ì„œ ì œê³µí•˜ëŠ” "
"XML íŒŒì¼ë¡œ, ê¸°ê¸°ì˜ ë©”ëª¨ë¦¬ ë§µì„ ê¸°ìˆ í•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/pacs.md:51
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"ì£¼ë³€ê¸°ê¸°, ë ˆì§€ìŠ¤í„°, í•„ë“œ, ê°’ìœ¼ë¡œ êµ¬ì„±ë˜ë©° ì´ë¦„, ì„¤ëª…, ì£¼ì†Œ ë“±ì´ í¬í•¨ë©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/pacs.md:53
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"SVD íŒŒì¼ì—ëŠ” ë²„ê·¸ê°€ ìˆì„ ìˆ˜ ìˆê³  ë¶ˆì™„ì „í•˜ê¸° ë•Œë¬¸ì—, ì´ëŸ¬í•œ ë¬¸ì œë“¤ì„ íŒ¨ì¹˜í•˜ëŠ” "
"ë‹¤ì–‘í•œ í”„ë¡œì íŠ¸ë“¤ì´ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/pacs.md:56
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt`ëŠ” ë¬´ì—‡ë³´ë‹¤ë„ ë²¡í„° í…Œì´ë¸”ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/pacs.md:57
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"`cargo install cargo-binutils`ì„ ì‹¤í–‰í•œ í›„, `cargo objdump --bin pac -- -d --"
"no-show-raw-insn`ì„ ì‹¤í–‰í•˜ì—¬ ìƒì„±ëœ ë°”ì´ë„ˆë¦¬ì˜ ë‚´ìš©ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/hals.md:1
msgid "HAL crates"
msgstr "HAL í¬ë ˆì´íŠ¸ë“¤"

#: src/bare-metal/microcontrollers/hals.md:3
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"ë‹¤ì–‘í•œ ì£¼ë³€ ì¥ì¹˜ì— ëŒ€í•œ ë˜í¼ë¥¼ ì œê³µí•˜ëŠ” [HAL í¬ë ˆì´íŠ¸](https://github.com/"
"rust-embedded/awesome-embedded-rust#hal-implementation-crates)ë“¤ì´ ìˆìŠµë‹ˆë‹¤. "
"ì´ í¬ë ˆì´íŠ¸ë“¤ì€ ì¼ë°˜ì ìœ¼ë¡œ [`embedded-hal`](https://crates.io/crates/"
"embedded-hal)ì˜ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/hals.md:23
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:40
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""
"`set_low` ë° `set_high`ëŠ” `embedded_hal` `OutputPin` íŠ¸ë ˆì‡ì˜ ë©”ì„œë“œì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/hals.md:41
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"ë‹¤ì–‘í•œ STM32, GD32, nRF, NXP, MSP430, AVR, PIC ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë¹„ë¡¯í•œ ë§"
"ì€ Cortex-M ë° RISC-V ê¸°ê¸°ë¥¼ ìœ„í•œ HAL í¬ë ˆì´íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤"

#: src/bare-metal/microcontrollers/board-support.md:1
#, fuzzy
msgid "Board support crates"
msgstr "ë³´ë“œ ì§€ì› í¬ë ˆì´íŠ¸"

#: src/bare-metal/microcontrollers/board-support.md:3
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""
"ë³´ë“œ ì§€ì› í¬ë ˆì´íŠ¸ë“¤ì€, íŠ¹ì • ë³´ë“œë¥¼ ë” ì†ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” ë” ë†’ì€ "
"ìˆ˜ì¤€ì˜ ì¶”ìƒí™”ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/board-support.md:31
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""
"ì´ ê²½ìš° ë³´ë“œ ì§€ì› í¬ë ˆì´íŠ¸ëŠ” ì¢€ ë” ì§ê´€ì ì¸ ì´ë¦„ë“¤ê³¼ ì ë‹¹í•œ ìˆ˜ì¤€ì˜ ì´ˆê¸°í™”ë¥¼ "
"ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/board-support.md:33
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""
"ì´ í¬ë ˆì´íŠ¸ëŠ” ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ ë°–ì— ìˆëŠ” (ì¦‰, ë³´ë“œì— ì„¤ì¹˜ëœ) ì¥ì¹˜ì— ëŒ€í•œ ë“œë¼ì´"
"ë²„ë„ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/board-support.md:35
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr ""
"`microbit-v2`ì—ëŠ” LED ë§¤íŠ¸ë¦­ìŠ¤ë¥¼ ìœ„í•œ ê°„ë‹¨í•œ ë“œë¼ì´ë²„ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/type-state.md:1
msgid "The type state pattern"
msgstr "íƒ€ì… ìƒíƒœ íŒ¨í„´"

#: src/bare-metal/microcontrollers/type-state.md:11
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:19
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:33
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"í•€ì€ `Copy` ë˜ëŠ” `Clone`ì„ êµ¬í˜„í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ê°ê° í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ ì¡´ì¬í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•€ì„ í¬íŠ¸ êµ¬ì¡°ì²´ ë°–ìœ¼ë¡œ ì´ë™í•˜ë©´ ì•„ë¬´ë„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/type-state.md:35
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"canâ€™t keep use the old instance afterwards."
msgstr ""
"í•€ êµ¬ì„±ì„ ë³€ê²½í•˜ë©´ ì´ì „ í•€ ì¸ìŠ¤í„´ìŠ¤ê°€ ì‚¬ìš©ë˜ë¯€ë¡œ ì´í›„ì— ì´ì „ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³„ì† "
"ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/type-state.md:37
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"ê°’ ìœ í˜•ì€ í˜„ì¬ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì´ ê²½ìš°ì—ëŠ” GPIO í•€ì˜ êµ¬ì„± ìƒíƒœì…"
"ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ìƒíƒœ ë¨¸ì‹ ì´ ìœ í˜• ì‹œìŠ¤í…œìœ¼ë¡œ ì¸ì½”ë”©ë˜ë©°, ë¨¼ì € ì˜¬ë°”ë¥´ê²Œ êµ¬ì„±"
"í•œ í›„ íŠ¹ì • ë°©ì‹ìœ¼ë¡œ í•€ì„ ì‚¬ìš©í•˜ë„ë¡ í•©ë‹ˆë‹¤. ì˜ëª»ëœ ìƒíƒœ ì „í™˜ì€ ì»´íŒŒì¼ ì‹œê°„ì— "
"í¬ì°©ë©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/type-state.md:42
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"ì…ë ¥ í•€ì—ì„œ `is_high`ë¥¼ í˜¸ì¶œí•˜ê³  ì¶œë ¥ í•€ì—ì„œ `set_high`ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆì§€ë§Œ "
"ê·¸ ë°˜ëŒ€ë¡œëŠ” ì•ˆ ë©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/type-state.md:44
msgid "Many HAL crates follow this pattern."
msgstr "ë§ì€ HAL í¬ë ˆì´íŠ¸ë“¤ì´ ì´ íŒ¨í„´ì„ ë”°ë¦…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/embedded-hal.md:3
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""
"[`embedded-hal`](https://crates.io/crates/embedded-hal) í¬ë ˆì´íŠ¸ëŠ” ë‹¤ì–‘í•œ ë§ˆ"
"ì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ê³µí†µì ìœ¼ë¡œ ì°¾ì•„ë³¼ ìˆ˜ ìˆëŠ” ì£¼ë³€ê¸°ê¸°ë¥¼ ì¶”ìƒíšŒ í•˜ëŠ” ë‹¤ì–‘í•œ íŠ¸"
"ë ˆì‡ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/embedded-hal.md:6
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md:7
msgid "ADC"
msgstr "ADC"

#: src/bare-metal/microcontrollers/embedded-hal.md:8
msgid "I2C, SPI, UART, CAN"
msgstr "I2C, SPI, UART, CAN"

#: src/bare-metal/microcontrollers/embedded-hal.md:9
msgid "RNG"
msgstr "RNG"

#: src/bare-metal/microcontrollers/embedded-hal.md:10
msgid "Timers"
msgstr "íƒ€ì´ë¨¸"

#: src/bare-metal/microcontrollers/embedded-hal.md:11
msgid "Watchdogs"
msgstr "ì›Œì¹˜ë…"

#: src/bare-metal/microcontrollers/embedded-hal.md:13
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"ê·¸ëŸ¬ë©´ ë‹¤ë¥¸ í¬ë ˆì´íŠ¸ëŠ” ì´ íŠ¸ë ˆì‡ë“¤ì„ í™œìš©í•˜ì—¬ [ë“œë¼ì´ë²„](https://github.com/"
"rust-embedded/awesome-embedded-rust#driver-crates)ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ê°€"
"ì†ë„ê³„ ë“œë¼ì´ë²„ë¥¼ êµ¬í˜„í•  ë–„ I2C ë˜ëŠ” SPI ë²„ìŠ¤ êµ¬í˜„ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/embedded-hal.md:20
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"ë¼ìŠ¤ë² ë¦¬ íŒŒì´ì—ì„œ ëŒì•„ê°€ëŠ” ë¦¬ëˆ…ìŠ¤ ê°™ì€ í”Œë«í¼ ë¿ë§Œ ì•„ë‹ˆë¼ ë‹¤ë¥¸ ì—¬ëŸ¬ ë§ˆì´í¬ë¡œ"
"ì»¨íŠ¸ë¡¤ëŸ¬ì— ëŒ€í•œ êµ¬í˜„ì´ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/embedded-hal.md:22
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""
"`embedded-hal`ì˜ 'async' ë²„ì „ì— ê´€í•œ ì‘ì—…ì´ ì§„í–‰ ì¤‘ì´ì§€ë§Œ ì•„ì§ ì•ˆì •ì ì´ì§€ ì•Š"
"ìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:3
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/)ëŠ” ì„ë² ë””ë“œ ì‹œìŠ¤í…œì„ ìœ„í•œ ë„êµ¬ ëª¨ì„ì…ë‹ˆë‹¤. "
"OpenOCDì™€ ë¹„ìŠ·í•˜ì§€ë§Œ, Rustì— ë” ì˜ í†µí•©ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:6
#, fuzzy
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr " ë° JTAG(CMSIS-DAP, ST-Link, J-Link í”„ë¡œë¸Œë¥¼ í†µí•¨)"

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:8
msgid "Cargo integration"
msgstr "Cargoì— í†µí•©ë¨"

#: src/bare-metal/microcontrollers/probe-rs.md:10
#, fuzzy
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
" ì¶œë ¥ì„ ê¸°ë¡í•˜ê³ , GDBë¥¼ ì—°ê²°í•´ ì¤ë‹ˆë‹¤. ì´ ëª…ë ¹ì–´ì˜ ì„¸ë¶€ ë™ì‘ì€ í”„ë¡œì íŠ¸ ë””ë ‰"
"í„°ë¦¬ì˜ `Embed.toml` íŒŒì¼ì„ í†µí•´ ì„¤ì •í•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:16
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html)ëŠ” Arm"
"ì—ì„œ ì •ì˜í•œ í”„ë¡œí† ì½œë¡œ, USBë¥¼ í†µí•´ Arm Cortex í”„ë¡œì„¸ì„œì˜ CoreSight ë””ë²„ê·¸ ì•¡"
"ì„¸ìŠ¤ í¬íŠ¸ì— ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•´ ì¤ë‹ˆë‹¤. BBC micro:bitì— ìˆëŠ” ì˜¨ë³´ë“œ ë””ë²„ê±°ë„ "
"ì´  í”„ë¡œí† ì½œì„ ì§€ì›í•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:20
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""
"ST-LinkëŠ” ST Microelectronicsì‚¬ì—ì„œ ë§Œë“  in-circuit ë””ë²„ê±°ë“¤ì´ë©°, J-LinkëŠ” "
"SEGGERì‚¬ì˜ in-circuit ë””ë²„ê±°ë“¤ì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:22
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""
"ë””ë²„ê·¸ ì•¡ì„¸ìŠ¤ í¬íŠ¸ì˜ ë¬¼ë¦¬ì ì¸ êµ¬ì„±ì€ ì¼ë°˜ì ìœ¼ë¡œ 5í•€ JTAG ì¸í„°í˜ì´ìŠ¤ í˜¹ì€, 2"
"í•€ Serial Wire Debug ì¸í„°í˜ì´ìŠ¤ ì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:24
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""
"probe-rsëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ êµ¬í˜„ë˜ì–´ ìˆì–´ì„œ, ë‹¤ë¥¸ ë„êµ¬ë“¤ì— í†µí•©ë˜ê¸°ê°€ ì‰½ìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:26
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"[Microsoft ë””ë²„ê·¸ ì–´ëŒ‘í„° í”„ë¡œí† ì½œ](https://microsoft.github.io/debug-adapter-"
"protocol/)ì„ ì‚¬ìš©í•˜ë©´ VSCodeë‚˜ ë‹¤ë¥¸ IDE ìƒì—ì„œ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ìˆ˜í–‰ì¤‘ì¸ "
"ì½”ë“œë¥¼ ë””ë²„ê¹… í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:30
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embedëŠ” probe-rs ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹Œë“œëœ ë°”ì´ë„ˆë¦¬ì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/probe-rs.md:31
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT(Real Time Transfers)ëŠ” ì—¬ëŸ¬ ë§ ë²„í¼ë¥¼ í†µí•´ ë””ë²„ê·¸ í˜¸ìŠ¤íŠ¸ì™€ íƒ€ê²Ÿ ê°„ì— ë°ì´"
"í„°ë¥¼ ì „ì†¡í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/debugging.md:3
#, fuzzy
msgid "_Embed.toml_:"
msgstr "Embed.toml:"

#: src/bare-metal/microcontrollers/debugging.md:15
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "`src/bare-metal/microcontrollers/examples/` ì•„ë˜ í•˜ë‚˜ì˜ í„°ë¯¸ë„ì—ì„œ:"

#: src/bare-metal/microcontrollers/debugging.md:23
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "ë‹¤ë¥¸ í„°ë¯¸ë„ì„ ë„ì›Œì„œ ì„œë¹„ìŠ¤ê°€ ì˜ ìˆ˜í–‰ë˜ê³  ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/bare-metal/microcontrollers/debugging.md:25
msgid "On gLinux or Debian:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:43
msgid "In GDB, try running:"
msgstr "GDBì—ì„œ ë‹¤ìŒì„ ì‹¤í–‰í•´ ë³´ì„¸ìš”."

#: src/bare-metal/microcontrollers/other-projects.md:1
#: src/bare-metal/aps/other-projects.md:1
msgid "Other projects"
msgstr "ë‹¤ë¥¸ í”„ë¡œì íŠ¸"

#: src/bare-metal/microcontrollers/other-projects.md:3
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md:4
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr ""
"\"ì‹¤ì‹œê°„ ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ë™ì‹œ ì‹¤í–‰(Real-Time Interrupt-driven Concurrency)\""

#: src/bare-metal/microcontrollers/other-projects.md:5
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr "ê³µìœ  ë¦¬ì†ŒìŠ¤ ê´€ë¦¬, ë©”ì‹œì§€ ì „ë‹¬, íƒœìŠ¤í¬ ìŠ¤ì¼€ì¤„ë§, íƒ€ì´ë¨¸ ëŒ€ê¸°ì—´ ì§€ì›"

#: src/bare-metal/microcontrollers/other-projects.md:6
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Embassy](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md:7
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "ìš°ì„ ìˆœìœ„, íƒ€ì´ë¨¸, ë„¤íŠ¸ì›Œí‚¹, USBê°€ í¬í•¨ëœ `async` ì‹¤í–‰ì"

#: src/bare-metal/microcontrollers/other-projects.md:8
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md:9
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr "ì„ ì í˜• ìŠ¤ì¼€ì¤„ë§ ë° MMUë¥¼ ì§€ì›í•˜ëŠ”, ë³´ì•ˆì— ì¤‘ì ì„ ë‘” ì‹¤ì‹œê°„ ìš´ì˜ì²´ì œ"

#: src/bare-metal/microcontrollers/other-projects.md:11
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md:12
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Oxide Computer Companyì—ì„œ ë§Œë“  ë§ˆì´í¬ë¡œì»¤ë„ ê¸°ë°˜ ì‹¤ì‹œê°„ ìš´ì˜ì²´ì œë¡œ, ë©”ëª¨ë¦¬ "
"ë³´í˜¸,  ê¶Œí•œì´ ì—†ì´ ìˆ˜í–‰ë˜ëŠ” ë“œë¼ì´ë²„ ë“±ì„ ì§€ì›í•¨."

#: src/bare-metal/microcontrollers/other-projects.md:14
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[FreeRTOSìš© ë°”ì¸ë”©](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md:15
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"`std`ê°€ êµ¬í˜„ëœ í”Œë«í¼ë„ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: [esp-idf](https://esp-rs.github.io/book/"
"overview/using-the-standard-library.html))."

#: src/bare-metal/microcontrollers/other-projects.md:20
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr ""
"RTICëŠ” ì‹¤ì‹œê°„ ìš´ì˜ì²´ì œë¡œ ë³¼ ìˆ˜ë„ ìˆê³ , ë™ì‹œì„± ì§€ì›ì„ ìœ„í•œ í”„ë ˆì„ì›Œí¬ë¡œ ë³¼ ìˆ˜"
"ë„ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/other-projects.md:21
msgid "It doesn't include any HALs."
msgstr "HALì„ í¬í•¨í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/other-projects.md:22
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"ìŠ¤ì¼€ì¤„ë§ì€ ì»¤ë„ì´ ì•„ë‹ˆë¼ Cortex-M NVIC(Nested Virtual Interrupt Controller)"
"ë¡œ êµ¬í˜„ì´ ë©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/other-projects.md:24
msgid "Cortex-M only."
msgstr "Cortex-M ì „ìš©ì…ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/other-projects.md:25
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""
"Googleì—ì„œëŠ” Titan ë³´ì•ˆ í‚¤ì— ì‚¬ìš©ë˜ëŠ” Haven ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ TockOSë¥¼ ì‚¬"
"ìš©í•©ë‹ˆë‹¤."

#: src/bare-metal/microcontrollers/other-projects.md:26
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""
"FreeRTOSëŠ” ëŒ€ë¶€ë¶„ Cë¡œ ì‘ì„±ë˜ì§€ë§Œ, ì• í”Œë¦¬ì¼€ì´ì…˜ì„ Rustë¡œ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ í•´ "
"ì£¼ëŠ” Rust ë°”ì¸ë”©ì´ ì œê³µë©ë‹ˆë‹¤."

#: src/exercises/bare-metal/morning.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""

#: src/exercises/bare-metal/morning.md:8
#: src/exercises/concurrency/morning.md:12
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr ""
"ì—°ìŠµë¬¸ì œë¥¼ ì‚´í´ ë³¸ í›„, ì œê³µëœ [í•´ë‹µ](solutions-afternoon.md)ì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/exercises/bare-metal/compass.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""

#: src/exercises/bare-metal/compass.md:7
msgid "Hints:"
msgstr ""

#: src/exercises/bare-metal/compass.md:9
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""

#: src/exercises/bare-metal/compass.md:13
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""

#: src/exercises/bare-metal/compass.md:14
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""

#: src/exercises/bare-metal/compass.md:15
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""

#: src/exercises/bare-metal/compass.md:19
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""

#: src/exercises/bare-metal/compass.md:22
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""

#: src/exercises/bare-metal/compass.md:26
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/compass.md:29 src/exercises/bare-metal/rtc.md:22
#, fuzzy
msgid "_src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/compass.md:47
#: src/exercises/bare-metal/solutions-morning.md:32
msgid "// Configure serial port.\n"
msgstr ""

#: src/exercises/bare-metal/compass.md:55
msgid ""
"// Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
msgstr ""

#: src/exercises/bare-metal/compass.md:58
#: src/exercises/bare-metal/solutions-morning.md:56
msgid "\"Ready.\""
msgstr ""

#: src/exercises/bare-metal/compass.md:61
msgid ""
"// Read compass data and log it to the serial port.\n"
"        // TODO\n"
msgstr ""

#: src/exercises/bare-metal/compass.md:67 src/exercises/bare-metal/rtc.md:387
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:89
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:105 src/exercises/bare-metal/rtc.md:988
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
msgid "See the serial output on Linux with:"
msgstr ""

#: src/exercises/bare-metal/compass.md:126
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""

#: src/exercises/bare-metal/compass.md:134
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "Bare Metal Rust Morning Exercise"
msgstr "Bare Metal Rust ì˜¤ì „ ì—°ìŠµ"

#: src/exercises/bare-metal/solutions-morning.md:5
msgid "([back to exercise](compass.md))"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:40
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:41
msgid "\"Setting up IMU...\""
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:49
msgid "// Set up display and timer.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:59
msgid "// Read compass data and log it to the serial port.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:67
msgid "\"{},{},{}\\t{},{},{}\""
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:105
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""

#: src/bare-metal/aps.md:1
msgid "Application processors"
msgstr "ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œ"

#: src/bare-metal/aps.md:3
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ Arm Cortex-M ì‹œë¦¬ì¦ˆì™€ ê°™ì€ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— ê´€í•´ ì•Œì•„ë´¤ìŠµë‹ˆë‹¤. ì´"
"ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œì¸ Cortex-Aë¥¼ ìœ„í•œ ì½”ë“œë¥¼ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤. í¸ì˜ìƒ "
"QEMUì˜ aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt."
"html) ë³´ë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/bare-metal/aps.md:10
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì—ëŠ” MMU ë˜ëŠ” ë‹¤ì¤‘ ë ˆë²¨ ê¶Œí•œ(Arm CPUì—ì„œëŠ” ìµì…‰ì…˜ "
"ë ˆë²¨(exception level), x86ì—ì„œëŠ” ë§(ring))ì´ ì—†ìŠµë‹ˆë‹¤. ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ì„œ"
"ëŠ” ì´ë“¤ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/aps.md:13
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMUëŠ” ì•„í‚¤í…ì²˜ë³„ë¡œ ë‹¤ì–‘í•œ ë¨¸ì‹  ë˜ëŠ” ë³´ë“œ ëª¨ë¸ì„ ì—ë®¬ë ˆì´ì…˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"'virt' ë³´ë“œëŠ” íŠ¹ì • ì‹¤ì œ í•˜ë“œì›¨ì–´ë¥¼ ì—ë®¬ë ˆì´ì…˜ í•˜ì§€ ì•Šìœ¼ë©°, ê°€ìƒ ë¨¸ì‹ ìš©ìœ¼ë¡œë§Œ "
"ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/entry-point.md:3
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""

#: src/bare-metal/aps/entry-point.md:5
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md:77
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""

#: src/bare-metal/aps/entry-point.md:79
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""

#: src/bare-metal/aps/entry-point.md:84
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""

#: src/bare-metal/aps/entry-point.md:86
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""

#: src/bare-metal/aps/entry-point.md:88
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""

#: src/bare-metal/aps/entry-point.md:92
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""

#: src/bare-metal/aps/entry-point.md:99
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""

#: src/bare-metal/aps/entry-point.md:103
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""

#: src/bare-metal/aps/entry-point.md:105
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:1
msgid "Inline assembly"
msgstr "ì¸ë¼ì¸ ì–´ì…ˆë¸”ë¦¬"

#: src/bare-metal/aps/inline-assembly.md:3
#, fuzzy
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"ê°€ë” Rust ì½”ë“œë¡œëŠ” êµ¬í˜„ì´ ë¶ˆê°€ëŠ¥í•œ ì‘ì—…ë“¤ì´ ìˆìœ¼ë©°, ì´ ê²½ìš° ì–´ì…ˆë¸”ë¦¬ë¥¼ ì‚¬ìš©í•´"
"ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ íŒì›¨ì–´ë¥¼ í–¥í•´ì„œ ì‹œìŠ¤í…œ ì „ì›ì„ ë„ë¼ê³  "

#: src/bare-metal/aps/inline-assembly.md:20
msgid ""
"// Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:23
msgid "\"hvc #0\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:24
msgid "\"w0\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:25
msgid "\"w1\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:26
msgid "\"w2\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:27
msgid "\"w3\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:28
msgid "\"w4\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:29
msgid "\"w5\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:30
msgid "\"w6\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:31
msgid "\"w7\""
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:40
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"ì‹¤ì œë¡œ ì´ë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ ì´ëŸ¬í•œ ëª¨ë“  í•¨ìˆ˜ë¥¼ ìœ„í•œ ë˜í¼ê°€ í¬í•¨ëœ [`smccc`]"
"(https://crates.io/crates/smccc) í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/bare-metal/aps/inline-assembly.md:45
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI (Power State Coordination Interface)ëŠ” ì‹œìŠ¤í…œ ë° CPU ì „ì› ìƒíƒœë¥¼ ê´€ë¦¬í•˜"
"ëŠ” Armì˜ í‘œì¤€ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ëŠ” EL3 íŒì›¨ì–´ì™€ í•˜ì´í¼ë°”ì´ì €ì— "
"ì˜í•´ êµ¬í˜„ë©ë‹ˆë‹¤."

#: src/bare-metal/aps/inline-assembly.md:48
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"`0 => _` ë¬¸ë²•ì€ ì¸ë¼ì¸ ì–´ì…ˆë¸”ë¦¬ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— ë ˆì§€ìŠ¤í„°ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”"
"í•˜ê³  ê·¸ í›„ì—ëŠ” ê·¸ ë ˆì§€ìŠ¤í„°ì˜ ê°’ì„ ë¬´ì‹œí•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. í˜¸ì¶œ ì‹œ ë ˆì§€ìŠ¤í„°ì˜ ê°’"
"ì´ ë®ì–´ ì¨ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ `in` ëŒ€ì‹  `inout`ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/bare-metal/aps/inline-assembly.md:52
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"ì´ `main` í•¨ìˆ˜ëŠ” `#[no_mangle]` ë° `extern \"C\"`ì—¬ì•¼ í•©ë‹ˆë‹¤.  ì™œëƒí•˜ë©´ ì´ í•¨"
"ìˆ˜ëŠ” Rust ì½”ë“œê°€ ì•„ë‹Œ, ì–´ì…ˆë¸”ëŸ¬ë¡œ ì‘ì„±ëœ `entry.S`ì—ì„œ í˜¸ì¶œë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/bare-metal/aps/inline-assembly.md:54
msgid ""
"`_x0`â€“`_x3` are the values of registers `x0`â€“`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`â€“`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`â€“`_x3`ëŠ” `x0`ì—ì„œ `x3` ë ˆì§€ìŠ¤í„°ë“¤ì˜ ê°’ì…ë‹ˆë‹¤. ì´ ë ˆì§€ìŠ¤í„°ë“¤ì€  ì¼ë°˜ì ìœ¼"
"ë¡œ ë¶€íŠ¸ë¡œë”ì—ì„œ  ë””ë°”ì´ìŠ¤ íŠ¸ë¦¬ì— ëŒ€í•œ í¬ì¸í„° ë“±ì„ ì „ë‹¬í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤. í‘œì¤€ "
"aarch64 í˜¸ì¶œ ê·œì•½(`extern \"C\"`ì—ì„œ ì‚¬ìš©í•˜ë„ë¡ ì§€ì •)ì— ë”°ë¼ ë ˆì§€ìŠ¤í„° `x0`ì—"
"ì„œ `x7`ì´ í•¨ìˆ˜ì— ì „ë‹¬ëœ ì²˜ìŒ 8ê°œ ì¸ìˆ˜ì— ì‚¬ìš©ë˜ë¯€ë¡œ `entry.S`ëŠ” ì´ëŸ¬í•œ ë ˆì§€ìŠ¤"
"í„°ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒ ì™¸ì—ëŠ” íŠ¹ë³„íˆ í•  ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/inline-assembly.md:60
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"`src/bare-metal/aps/examples`ì—ì„œ `make qemu_psci`ë¥¼ ì‚¬ìš©í•˜ì—¬ QEMUì—ì„œ ì˜ˆì‹œ"
"ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤."

#: src/bare-metal/aps/mmio.md:1
msgid "Volatile memory access for MMIO"
msgstr "MMIOë¥¼ ìœ„í•œ íœ˜ë°œì„±(volatile) ë©”ëª¨ë¦¬ ì•¡ì„¸ìŠ¤"

#: src/bare-metal/aps/mmio.md:3
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "`pointer::read_volatile` ë° `pointer::write_volatile`ì„ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/bare-metal/aps/mmio.md:4
msgid "Never hold a reference."
msgstr "ì°¸ì¡°ë¥¼ ìœ ì§€í•˜ì§€ ë§ˆì„¸ìš”."

#: src/bare-metal/aps/mmio.md:5
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""
"`addr_of!`ë¥¼ ì‚¬ìš©í•˜ë©´ ì„ì‹œ ìš©ë„ì˜ ì°¸ì¡°ë¥¼ ë§Œë“¤ì§€ ì•Šê³ ë„ êµ¬ì¡°ì²´ í•„ë“œë¥¼ ê°€ì ¸ì˜¬ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/mmio.md:10
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"íœ˜ë°œì„±(volatile) ì•¡ì„¸ìŠ¤: ì½ê¸° ë˜ëŠ” ì“°ê¸° ì‘ì—…ì´ ë¶€ìˆ˜ íš¨ê³¼(side effect)ë¥¼ ë™ë°˜"
"í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ëŸ¬ë‚˜ í•˜ë“œì›¨ì–´ê°€ ì„ì˜ë¡œ ì´ë¥¼ ì½ê¸° ì“°ê¸° ì‘ì—…ì˜ ìˆœì„œë¥¼ "
"ë°”ê¾¸ê±°ë‚˜, ì¤‘ë³µí•´ì„œ ìˆ˜í–‰í•˜ê±°ë‚˜ ë˜ëŠ” ì œê±°í•˜ì§€ ëª»í•˜ê²Œ í•©ë‹ˆë‹¤."

#: src/bare-metal/aps/mmio.md:12
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"ì¼ë°˜ì ìœ¼ë¡œ ì“°ê³  ë‚œ í›„ ì½ìœ¼ë©´(ì˜ˆ: ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ í†µí•´) ì»´íŒŒì¼ëŸ¬ëŠ” ì½ì€ ê°’"
"ì´ ë°©ê¸ˆ ì“´ ê°’ê³¼ ë™ì¼í•˜ë‹¤ê³  ê°€ì •í•˜ê³  ì‹¤ì œë¡œ ë©”ëª¨ë¦¬ë¥¼ ì½ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/mmio.md:15
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"í•˜ë“œì›¨ì–´ì— ëŒ€í•œ íœ˜ë°œì„± ì•¡ì„¸ìŠ¤ë¥¼ ìœ„í•œ ì¼ë¶€ ê¸°ì¡´ í¬ë ˆì´íŠ¸ëŠ” ì°¸ì¡°ë¥¼ ìœ ì§€í•˜ì§€ë§Œ "
"ì´ëŠ” ì˜¬ë°”ë¥¸ ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤. ì°¸ì¡°ê°€ ìˆì„ ë•Œë§ˆë‹¤ ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì—­ì°¸ì¡°í•˜ë„ë¡ ì„ "
"íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/mmio.md:18
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""
"`addr_of!` ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬ì¡°ì²´ í¬ì¸í„°ì—ì„œ êµ¬ì¡°ì²´ í•„ë“œ í¬ì¸í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆ"
"ë‹¤."

#: src/bare-metal/aps/uart.md:1
msgid "Let's write a UART driver"
msgstr "UART ë“œë¼ì´ë²„ ì‘ì„±"

#: src/bare-metal/aps/uart.md:3
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"QEMUì˜ 'virt' ë³´ë“œì—ëŠ” [PL011](https://developer.arm.com/documentation/"
"ddi0183/g) UARTê°€ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ ìœ„í•œ ë“œë¼ì´ë²„ë¥¼ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/uart.md:9
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:17 src/bare-metal/aps/better-uart/driver.md:13
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:29 src/bare-metal/aps/better-uart/driver.md:25
#: src/exercises/bare-metal/rtc.md:337
msgid "/// Writes a single byte to the UART.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:31 src/bare-metal/aps/better-uart/driver.md:27
#: src/exercises/bare-metal/rtc.md:339
msgid "// Wait until there is room in the TX buffer.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:34 src/bare-metal/aps/uart.md:46
msgid ""
"// Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:37 src/bare-metal/aps/better-uart/driver.md:33
#: src/exercises/bare-metal/rtc.md:345
msgid "// Write to the TX buffer.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:41 src/bare-metal/aps/better-uart/driver.md:37
#: src/exercises/bare-metal/rtc.md:349
msgid "// Wait until the UART is no longer busy.\n"
msgstr ""

#: src/bare-metal/aps/uart.md:55
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"`Uart::new`ëŠ” ì•ˆì „í•˜ì§€ ì•Šì§€ë§Œ(usafe), ê·¸ ì™¸ ë‹¤ë¥¸ ë©”ì„œë“œë“¤ì€ ì•ˆì „í•œ(safe) ì "
"ì— ì£¼ëª©í•˜ì„¸ìš”.ë‹¤ë¥¸ ë©”ì„œë“œë“¤ì´ ì•ˆì „í•  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ”, `Uart::new`ì˜ ì•ˆì „ ìš”êµ¬"
"ì‚¬í•­(ì¦‰, ì§€ì •ëœ UARTì˜ ë“œë¼ì´ë²„ ì¸ìŠ¤í„´ìŠ¤ê°€ í•˜ë‚˜ë§Œ ìˆìœ¼ë©° ì£¼ì†Œ ê³µê°„ì— ë³„ì¹­ì„ "
"ì§€ì •í•˜ëŠ” ë‹¤ë¥¸ í•­ëª©ì´ ì—†ìŒ) ì´ ë§Œì¡±ë˜ê¸°ë§Œ í•˜ë©´ `write_byte`ì™€ ê°™ì€ í•¨ìˆ˜ë¥¼ ì•ˆì „"
"í•˜ê²Œ í˜¸ì¶œí•˜ëŠ”ë° ìˆì–´ì„œ í•„ìš”í•œ ëª¨ë“  ì „ì œì¡°ê±´ì´ ë§Œì¡±ë˜ê¸°  ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/bare-metal/aps/uart.md:61
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"ë°˜ëŒ€ ë°©ë²•ìœ¼ë¡œë„ ì‹¤í–‰í•  ìˆ˜ ìˆì§€ë§Œ(`new`ë¥¼ ì•ˆì „í•˜ê²Œ ë§Œë“¤ê³  `write_byte`ë¥¼ ì•ˆì „"
"í•˜ì§€ ì•Šê²Œ ë§Œë“¦) ì´ëŠ” `write_byte`ë¥¼ í˜¸ì¶œí•˜ëŠ” ëª¨ë“  ìœ„ì¹˜ì—ì„œ ì•ˆì „ì„±ì— ê´€í•´ ì¶”ë¡ "
"í•´ì•¼ í•˜ë¯€ë¡œ ì‚¬ìš© í¸ì˜ì„±ì´ í›¨ì”¬ ë–¨ì–´ì§‘ë‹ˆë‹¤."

#: src/bare-metal/aps/uart.md:64
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"ì´ëŠ” ì•ˆì „í•˜ì§€ ì•Šì€ ì½”ë“œì˜ ì•ˆì „í•œ ë˜í¼ë¥¼ ì‘ì„±í•˜ëŠ” ì¼ë°˜ì ì¸ íŒ¨í„´ì…ë‹ˆë‹¤. ì•ˆì „ì— "
"ê´€í•œ ì¦ëª… ë¶€ë‹´ì„ ì—¬ëŸ¬ ë§ì€ ìœ„ì¹˜ì—ì„œ ì†Œìˆ˜ì˜ ìœ„ì¹˜ë¡œ ì˜®ê¸°ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "More traits"
msgstr "íŠ¸ë ˆì‡(Trait)"

#: src/bare-metal/aps/uart/traits.md:3
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:17 src/exercises/bare-metal/rtc.md:381
#: src/exercises/bare-metal/solutions-afternoon.md:223
msgid ""
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:25
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:27
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/better-uart.md:1
msgid "A better UART driver"
msgstr "ë” ë‚˜ì€ UART ë“œë¼ì´ë²„"

#: src/bare-metal/aps/better-uart.md:3
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"PL011ì—ëŠ” ì‹¤ì œë¡œ [í›¨ì”¬ ë” ë§ì€ ë ˆì§€ìŠ¤í„°](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers)ê°€ ìˆìœ¼ë©°, ì´"
"ì— ì•¡ì„¸ìŠ¤í•  í¬ì¸í„°ë¥¼ êµ¬ì„±í•˜ê¸° ìœ„í•´ ì˜¤í”„ì…‹ì„ ì¶”ê°€í•˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê¸° ì‰½ê³  ì½"
"ê¸° ì–´ë µìŠµë‹ˆë‹¤. ë˜í•œ ê·¸ì¤‘ ì¼ë¶€ëŠ” êµ¬ì¡°í™”ëœ ë°©ì‹ìœ¼ë¡œ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆëŠ” ë¹„íŠ¸ í•„ë“œ"
"ì…ë‹ˆë‹¤."

#: src/bare-metal/aps/better-uart.md:7
msgid "Offset"
msgstr "ì˜¤í”„ì…‹"

#: src/bare-metal/aps/better-uart.md:7
msgid "Register name"
msgstr "ë ˆì§€ìŠ¤í„° ì´ë¦„"

#: src/bare-metal/aps/better-uart.md:7
msgid "Width"
msgstr "ë„ˆë¹„"

#: src/bare-metal/aps/better-uart.md:9
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md:9
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md:9
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md:10
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md:10
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md:11
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md:11
msgid "FR"
msgstr "FR"

#: src/bare-metal/aps/better-uart.md:11
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md:12
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md:12
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md:13
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md:13
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md:13 src/bare-metal/aps/better-uart.md:16
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md:14
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md:14
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md:15
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md:15
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md:16
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md:16
msgid "CR"
msgstr "CR"

#: src/bare-metal/aps/better-uart.md:17
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md:17
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md:18
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md:18
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md:18 src/bare-metal/aps/better-uart.md:19
#: src/bare-metal/aps/better-uart.md:20 src/bare-metal/aps/better-uart.md:21
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md:19
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md:19
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md:20
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md:20
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md:21
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md:21
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md:22
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md:22
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md:26
msgid "There are also some ID registers which have been omitted for brevity."
msgstr "ê°„ê²°ì„±ì„ ìœ„í•´ ì¼ë¶€ ID ë ˆì§€ìŠ¤í„°ëŠ” ìƒëµë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/bare-metal/aps/better-uart/bitflags.md:3
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:10
#: src/exercises/bare-metal/rtc.md:241
msgid "/// Flags from the UART flag register.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:14
#: src/exercises/bare-metal/rtc.md:245
msgid "/// Clear to send.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:16
#: src/exercises/bare-metal/rtc.md:247
msgid "/// Data set ready.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:18
#: src/exercises/bare-metal/rtc.md:249
msgid "/// Data carrier detect.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:20
#: src/exercises/bare-metal/rtc.md:251
msgid "/// UART busy transmitting data.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:22
#: src/exercises/bare-metal/rtc.md:253
msgid "/// Receive FIFO is empty.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:24
#: src/exercises/bare-metal/rtc.md:255
msgid "/// Transmit FIFO is full.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:26
#: src/exercises/bare-metal/rtc.md:257
msgid "/// Receive FIFO is full.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:28
#: src/exercises/bare-metal/rtc.md:259
msgid "/// Transmit FIFO is empty.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:30
#: src/exercises/bare-metal/rtc.md:261
msgid "/// Ring indicator.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:38
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:1
#, fuzzy
msgid "Multiple registers"
msgstr "ë” ë§ì€ ë ˆì§€ìŠ¤í„°"

#: src/bare-metal/aps/better-uart/registers.md:3
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:43
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:3
msgid "Now let's use the new `Registers` struct in our driver."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:6
msgid "/// Driver for a PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:30
#: src/bare-metal/aps/better-uart/driver.md:54
#: src/exercises/bare-metal/rtc.md:342 src/exercises/bare-metal/rtc.md:366
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:41
#: src/exercises/bare-metal/rtc.md:353
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:48
#: src/exercises/bare-metal/rtc.md:360
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:63
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:1
#: src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "Using it"
msgstr "Bindgen ì‚¬ìš©í•˜ê¸°"

#: src/bare-metal/aps/better-uart/using.md:3
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:19
#: src/bare-metal/aps/logging/using.md:18 src/exercises/bare-metal/rtc.md:44
#: src/exercises/bare-metal/solutions-afternoon.md:33
msgid "/// Base address of the primary PL011 UART.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:25
#: src/bare-metal/aps/logging/using.md:24 src/exercises/bare-metal/rtc.md:50
#: src/exercises/bare-metal/solutions-afternoon.md:44
msgid ""
"// Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:29
#: src/bare-metal/aps/logging/using.md:29
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:35
msgid "b'\\r'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:36
#: src/async/pitfalls/cancellation.md:27
msgid "b'\\n'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:38
msgid "b'q'"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:44
msgid "\"Bye!\""
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:54
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/logging.md:3
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"[`log`](https://crates.io/crates/log) í¬ë ˆì´íŠ¸ì˜ ë¡œê¹… ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼"
"ë©´ ì¢‹ìŠµë‹ˆë‹¤. ì´ëŠ” `Log` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/bare-metal/aps/logging.md:26 src/exercises/bare-metal/rtc.md:193
msgid "\"[{}] {}\""
msgstr ""

#: src/bare-metal/aps/logging.md:35 src/exercises/bare-metal/rtc.md:202
msgid "/// Initialises UART logger.\n"
msgstr ""

#: src/bare-metal/aps/logging.md:48
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"`log`í•¨ìˆ˜ ì•ˆì—ì„œ `unwrap`í•˜ëŠ” ê²ƒì€ ê´œì°®ìŠµë‹ˆë‹¤.. ì™œëƒí•˜ë©´  `set_logger`ë¥¼ í˜¸ì¶œ"
"í•˜ê¸° ì „ì— `LOGGER`ë¥¼ ì´ˆê¸°í™”í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/bare-metal/aps/logging/using.md:3
msgid "We need to initialise the logger before we use it."
msgstr ""

#: src/bare-metal/aps/logging/using.md:38 src/exercises/bare-metal/rtc.md:72
#: src/exercises/bare-metal/solutions-afternoon.md:115
msgid "\"{info}\""
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
msgid "Note that our panic handler can now log details of panics."
msgstr ""

#: src/bare-metal/aps/logging/using.md:47
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/exceptions.md:3
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""

#: src/bare-metal/aps/exceptions.md:67
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""

#: src/bare-metal/aps/exceptions.md:68
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""

#: src/bare-metal/aps/exceptions.md:70
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""

#: src/bare-metal/aps/exceptions.md:72
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""

#: src/bare-metal/aps/other-projects.md:3
#, fuzzy
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md:4
#, fuzzy
msgid "\"coreboot without the C\""
msgstr "\"Cê°€ ì—†ëŠ” coreboot\""

#: src/bare-metal/aps/other-projects.md:5
#, fuzzy
msgid "Supports x86, aarch64 and RISC-V."
msgstr "x86, aarch64, RISC-Vë¥¼ ì§€ì›í•©ë‹ˆë‹¤."

#: src/bare-metal/aps/other-projects.md:6
#, fuzzy
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "ìì²´ì ìœ¼ë¡œ ì—¬ëŸ¬ ë“œë¼ì´ë²„ë¥¼ ë³´ìœ í•˜ëŠ” ëŒ€ì‹  LinuxBootì— ì˜ì¡´í•©ë‹ˆë‹¤."

#: src/bare-metal/aps/other-projects.md:7
#, fuzzy
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md:8
#, fuzzy
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"ì´ˆê¸°í™”, UART ë“œë¼ì´ë²„, ê°„ë‹¨í•œ ë¶€íŠ¸ë¡œë”, JTAG, ì˜ˆì™¸ ìˆ˜ì¤€, ì˜ˆì™¸ ì²˜ë¦¬, í˜ì´ì§€ í…Œ"
"ì´ë¸”"

#: src/bare-metal/aps/other-projects.md:10
#, fuzzy
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr "ì˜ ì‘ì„±ë˜ì§€ ì•Šì€ ê²ƒë„ ìˆìœ¼ë¯€ë¡œ ì£¼ì˜í•˜ì„¸ìš”."

#: src/bare-metal/aps/other-projects.md:12
#, fuzzy
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md:13
#, fuzzy
msgid "Static analysis to determine maximum stack usage."
msgstr "ìµœëŒ€ ìŠ¤íƒ ì‚¬ìš©ëŸ‰ì„ ê²°ì •í•˜ëŠ” ì •ì  ë¶„ì„"

#: src/bare-metal/aps/other-projects.md:17
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""

#: src/bare-metal/aps/other-projects.md:19
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""

#: src/bare-metal/aps/other-projects.md:23
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""

#: src/bare-metal/useful-crates.md:1
msgid "Useful crates"
msgstr "ìœ ìš©í•œ í¬ë ˆì´íŠ¸"

#: src/bare-metal/useful-crates.md:3
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""
"bare-metal í”„ë¡œê·¸ë˜ë°ì˜ ëª‡ ê°€ì§€ ì¼ë°˜ì ì¸ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” í¬ë ˆì´íŠ¸ë¥¼ ì‚´í´ë´…ë‹ˆ"
"ë‹¤."

#: src/bare-metal/useful-crates/zerocopy.md:3
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"FuchsiaíŒ€ì´ ë§Œë“  [`zerocopy`](https://docs.rs/zerocopy/) í¬ë ˆì´íŠ¸ëŠ” ë°”ì´íŠ¸ ì‹œ"
"í€€ìŠ¤ë¥¼ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë³€í™˜í•˜ê¸° ìœ„í•œ íŠ¸ë ˆì‡ ë° ë§¤í¬ë¡œë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/zerocopy.md:42
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"ì´ í¬ë ˆì´íŠ¸ëŠ” íœ˜ë°œì„±(volatile) ì½ê¸° ë° ì“°ê¸°ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ MMIOì— ì í•©í•˜"
"ì§€ ì•Šì§€ë§Œ, í•˜ë“œì›¨ì–´ì™€ ê³µìœ ë˜ê±°ë‚˜(ì˜ˆ: DMAì—ì„œ) ì™¸ì¥ ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ì „ì†¡ë˜"
"ëŠ” êµ¬ì¡°ì²´ë¥¼ ë‹¤ë£¨ëŠ” ë°ì—ëŠ” ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/useful-crates/zerocopy.md:48
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"ì–´ë–¤ íƒ€ì…ì´ ê°€ëŠ¥í•œ ëª¨ë“  ë°”ì´íŠ¸ íŒ¨í„´ë“¤ì— ëŒ€í•´ ì˜¬ë°”ë¥¸ ê°’ì„ ê°€ì§ˆ ë•Œì—ë§Œ , ê·¸ íƒ€"
"ì…ì´ `FromBytes`ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ê²Œ í•´ì„œ ì‹ ë¢°í•  ìˆ˜ ì—†ëŠ” ë°”ì´íŠ¸ ì‹œí€€"
"ìŠ¤ë¥¼ ì•ˆì „í•˜ê²Œ í•´ë‹¹ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/useful-crates/zerocopy.md:50
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"ìœ„ ì½”ë“œì—ì„œ ì •ì˜í•œ íƒ€ì…ì— ëŒ€í•´ `FromBytes`ë¥¼ êµ¬í˜„í•˜ë ¤ê³  í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆ"
"ë‹¤. `RequestType`ì€ ê°€ëŠ¥í•œ ëª¨ë“  u32 ê°’ì„ ì‹ë³„ìë¡œ ë°›ì•„ë“¤ì´ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆ"
"ë‹¤. ì¦‰ ëª¨ë“  ë°”ì´íŠ¸ íŒ¨í„´ì´ ìœ íš¨í•œ `RequestType`ê°’ì€ ì•„ë‹™ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/zerocopy.md:53
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""
"`zerocopy::byteorder`ì—ëŠ” ë°”ì´íŠ¸ ì˜¤ë”ì— ë”°ë¥¸ ì„œë¡œ ë‹¤ë¥¸ í‘œí˜„ ë°©ì‹ì„ ì§€ì›í•˜ëŠ” "
"ìˆ«ì íƒ€ì…ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/zerocopy.md:54
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"`src/bare-metal/useful-crates/zerocopy-example/`ì—ì„œ `cargo run`ì„ ì‚¬ìš©í•˜ì—¬ "
"ì˜ˆì‹œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤(ì¢…ì†ì„± ë¬¸ì œë¡œ ì¸í•´ í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤)."

#: src/bare-metal/useful-crates/aarch64-paging.md:3
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"[`aarch64-paging`](https://crates.io/crates/aarch64-paging) í¬ë ˆì´íŠ¸ë¥¼ ì‚¬ìš©í•˜"
"ë©´ AArch64 ê°€ìƒ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ì— ë”°ë¼ í˜ì´ì§€ í…Œì´ë¸”ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/bare-metal/useful-crates/aarch64-paging.md:14
msgid "// Create a new page table with identity mapping.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:16
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:21
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""
"í˜„ì¬ëŠ” EL1ë§Œ ì§€ì›í•˜ì§€ë§Œ ë‹¤ë¥¸ ìµì…‰ì…˜ ë ˆë²¨(Exception Level: EL)ë„ ì–´ë µì§€ ì•Šê²Œ "
"ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/useful-crates/aarch64-paging.md:30
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"Androidì—ì„œ [ë³´í˜¸ëœ VM íŒì›¨ì–´](https://cs.android.com/android/platform/"
"superproject/+/master:packages/modules/Virtualization/pvmfw/)ì— ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/aarch64-paging.md:31
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"ì´ ì˜ˆì‹œë¥¼ ê°„ë‹¨í•˜ê²Œ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì€ ì—†ìŠµë‹ˆë‹¤. ì‹¤ì œ í•˜ë“œì›¨ì–´ ë˜ëŠ” QEMUì—ì„œ ì‹¤í–‰"
"í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator)"
"ëŠ” ë²„ë”” ì‹œìŠ¤í…œ í• ë‹¹ìë¥¼ êµ¬í˜„í•˜ëŠ” ì„œë“œ íŒŒí‹° í¬ë ˆì´íŠ¸ì…ë‹ˆë‹¤. ì´ í¬ë ˆì´íŠ¸ì˜ "
"[`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html)ì€ [`GlobalAlloc`](https://doc."
"rust-lang.org/core/alloc/trait.GlobalAlloc.html)ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ì—¬ëŸ¬ë¶„"
"ì€ ë²„ë”” ì‹œìŠ¤í…œ í• ë‹¹ìë¥¼ 'alloc' í¬ë ˆì´íŠ¸ë¥¼ í†µí•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤([ì´ì „]"
"(../alloc.md)ì— í™•ì¸í•¨). ë˜ëŠ” ë‹¤ë¥¸ ì£¼ì†Œ ê³µê°„ì„ í• ë‹¹í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ PCI BARì— MMIO ê³µê°„ì„ í• ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:29
msgid "PCI BARs always have alignment equal to their size."
msgstr "PCI BARëŠ” BARì˜ì—­ì˜ í¬ê¸°ì— ë§ì¶”ì–´ ì •ë ¬ë©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/buddy_system_allocator.md:30
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"`src/bare-metal/useful-crates/allocator-example/`ì—ì„œ `cargo run`ì„ ì‚¬ìš©í•˜ì—¬ "
"ì˜ˆì‹œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤(ì¢…ì†ì„± ë¬¸ì œë¡œ ì¸í•´ í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤)."

#: src/bare-metal/useful-crates/tinyvec.md:3
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"í™ì— ë©”ëª¨ë¦¬ í• ë‹¹í•˜ì§€ ì•Šê³  í¬ê¸° ì¡°ì ˆì´ ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆ(ì˜ˆ: `Vec` ê°™ì€)ê°€ í•„ìš”"
"í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤. [`tinyvec`](https://crates.io/crates/tinyvec)ì„ ì‚¬ìš©í•˜ë©´ ë©"
"ë‹ˆë‹¤. `tinyvec`ì—ì„œ ë²¡í„°ëŠ” ë°°ì—´ ë˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¡œë¶€í„° ìƒì„±ì´ ë˜ë©°, ì´ë“¤ì€ ì •ì "
"ìœ¼ë¡œ í• ë‹¹ë˜ì—ˆê±°ë‚˜ ìŠ¤íƒì— í• ë‹¹ë˜ì–´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`tinyvec`ì€ í˜„ì¬ ë²¡í„° ì•ˆ"
"ì— ì–¼ë§ˆë‚˜ ë§ì€ ì—˜ë¦¬ë¨¼íŠ¸ë“¤ì´ ì¡´ì¬í•˜ëŠ” ì§€ë¥¼ ì¶”ì í•˜ê³  ìˆìœ¼ë©°, í• ë‹¹ëœ ì–‘ë³´ë‹¤ ë” "
"ë§ì´ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë©´ íŒ¨ë‹‰ì„ ë°œìƒì‹œí‚µë‹ˆë‹¤."

#: src/bare-metal/useful-crates/tinyvec.md:25
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""
"`tinyvec`ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì—˜ë¦¬ë¨¼íŠ¸ì˜ íƒ€ì…ì´ `Default`ë¥¼ í†µí•´ ì´ˆê¸°í™” ë  ìˆ˜ ìˆì–´"
"ì•¼ í•©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/tinyvec.md:27
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""
"Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ëŠ” `tinyvec`ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì´ ì˜ˆì‹œëŠ” ì¸ë¼ì¸ìœ¼ë¡œ ì‹¤"
"í–‰ë©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/spin.md:3
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"`std::sync::Mutex` ë° `std::sync`ì˜ ê¸°íƒ€ ë™ê¸°í™” í”„ë¦¬ë¯¸í‹°ë¸ŒëŠ” `core` ë˜ëŠ” "
"`alloc`ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ì–´ë–»ê²Œ ë™ê¸°í™” ë˜ëŠ” interior mutability"
"ì™€ ê°™ì€ ê¸°ëŠ¥ì´ í•„ìš”í•  ê²½ìš° ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”? "

#: src/bare-metal/useful-crates/spin.md:7
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"[`spin`](https://crates.io/crates/spin) í¬ë ˆì´íŠ¸ëŠ” ì´ëŸ¬í•œ ë™ê¸°í™” í”„ë¦¬ë¯¸í‹°ë¸Œë“¤"
"ì„ ìŠ¤í•€ë¡ìœ¼ë¡œ êµ¬í˜„í•˜ê³  ìˆìŠµë‹ˆë‹¤."

#: src/bare-metal/useful-crates/spin.md:26
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""
"ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ì—ì„œ ë½ì„ ê±¸ ê²½ìš°, êµì°© ìƒíƒœê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”."

#: src/bare-metal/useful-crates/spin.md:27
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"`spin`ì—ëŠ” í‹°ì¼“ ì ê¸ˆ ë®¤í…ìŠ¤ êµ¬í˜„ë„ ìˆìŠµë‹ˆë‹¤. `std::sync`ì˜ `RwLock`, "
"`Barrier`, `Once` ì— í•´ë‹¹í•˜ëŠ” ê²ƒë“¤ì´ ì œê³µë˜ë©°,  ì§€ì—°ëœ ì´ˆê¸°í™”ë¥¼ ìœ„í•œ `Lazy`"
"ì— í•´ë‹¹í•˜ëŠ” ê²ƒë„ ì œê³µë©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/spin.md:29
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"[`once_cell`](https://crates.io/crates/once_cell) í¬ë ˆì´íŠ¸ì—ëŠ” ì§€ì—°ëœ ì´ˆê¸°í™”"
"ë¥¼ ìœ„í•œ ëª‡ ê°€ì§€ ìœ ìš©í•œ íƒ€ì…ì´ ìˆëŠ”ë° `spin::once::Once`ì™€ëŠ” ì•½ê°„ ë‹¤ë¥¸ ì ‘ê·¼ ë°©"
"ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/bare-metal/useful-crates/spin.md:31
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""
"Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ëŠ” `spin`ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì´ ì˜ˆì‹œëŠ” ì¸ë¼ì¸ìœ¼ë¡œ ì‹¤í–‰"
"ë©ë‹ˆë‹¤."

#: src/bare-metal/android.md:3
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"AOSPì—ì„œ bare-metal Rust ë°”ì´ë„ˆë¦¬ë¥¼ ë¹Œë“œí•˜ë ¤ë©´ `rust_ffi_static` ì„ ì‚¬ìš©í•˜ì—¬ "
"Rust ì½”ë“œë¥¼ ë¹Œë“œí•˜ê³ , ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸ê°€ í¬í•¨ëœ `cc_binary`ë¥¼ ì‚¬ìš©í•˜ì—¬ ELF ë°”ì´"
"ë„ˆë¦¬ë¥¼ ìƒì„±í•˜ê³ , `raw_binary`ë¥¼ ì‚¬ìš©í•´ ELFë¥¼ ê³§ë°”ë¡œ ìˆ˜í–‰ë  ìˆ˜ ìˆëŠ” ì›ì‹œ(raw) "
"ë°”ì´ë„ˆë¦¬ë¡œ ë³€í™˜í•©ë‹ˆë‹¤."

#: src/bare-metal/android/vmbase.md:1
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md:3
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"[vmbase](https://android.googlesource.com/platform/packages/modules/"
"Virtualization/+/refs/heads/master/vmbase/) ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ”, aarch64ì˜ crosvmì—"
"ì„œ ì‹¤í–‰ë˜ëŠ” VMì„ íƒ€ê²Ÿí•˜ì—¬, ì§„ì…ì , UART ì½˜ì†” ë¡œê¹…, ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸, ë¹Œë“œ ë£° ë“±"
"ì— ëŒ€í•œ ê¸°ë³¸ êµ¬í˜„ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/bare-metal/android/vmbase.md:24
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr "`main!` ë§¤í¬ë¡œëŠ” `vmbase` ì§„ì…ì ì—ì„œ í˜¸ì¶œë  main í•¨ìˆ˜ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."

#: src/bare-metal/android/vmbase.md:26
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"`vmbase`ê°€ ì œê³µí•˜ëŠ” ì§„ì…ì ì€ ì½˜ì†”ì„ ì´ˆê¸°í™” í•˜ë©°, main í•¨ìˆ˜ê°€ ë¦¬í„´í•˜ë©´  "
"PSCI_SYSTEM_OFF ë©”ì‹œì§€ë¥¼ PSCIë¥¼ í†µí•´ ë³´ë‚´ì–´ì„œ  VMì„ ì¢…ë£Œì‹œí‚µë‹ˆë‹¤."

#: src/exercises/bare-metal/afternoon.md:3
msgid "We will write a driver for the PL031 real-time clock device."
msgstr ""

#: src/exercises/bare-metal/afternoon.md:7
#: src/exercises/concurrency/afternoon.md:13
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr ""
"ì—°ìŠµë¬¸ì œë¥¼ ì‚´í´ ë³¸ í›„, ì œê³µëœ [í•´ë‹µ](solutions-afternoon.md)ì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/exercises/bare-metal/rtc.md:1
#: src/exercises/bare-metal/solutions-afternoon.md:3
#, fuzzy
msgid "RTC driver"
msgstr "RTC ë“œë¼ì´ë²„"

#: src/exercises/bare-metal/rtc.md:3
#, fuzzy
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"QEMUì˜ 'virt' ë³´ë“œì—ëŠ” [PL011](https://developer.arm.com/documentation/"
"ddi0224/c) UARTê°€ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ ìœ„í•œ ë“œë¼ì´ë²„ë¥¼ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/exercises/bare-metal/rtc.md:6
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""

#: src/exercises/bare-metal/rtc.md:8
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""

#: src/exercises/bare-metal/rtc.md:11
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""

#: src/exercises/bare-metal/rtc.md:14
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""

#: src/exercises/bare-metal/rtc.md:15
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""

#: src/exercises/bare-metal/rtc.md:19
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/rtc.md:40
#: src/exercises/bare-metal/solutions-afternoon.md:29
msgid "/// Base addresses of the GICv3.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:55
#: src/exercises/bare-metal/solutions-afternoon.md:49
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:57
#: src/exercises/bare-metal/solutions-afternoon.md:51
msgid ""
"// Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:63
msgid "// TODO: Create instance of RTC driver and print current time.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:65
msgid "// TODO: Wait for 3 seconds.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:78
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:84 src/exercises/bare-metal/rtc.md:159
#: src/exercises/bare-metal/rtc.md:218 src/exercises/bare-metal/rtc.md:418
msgid ""
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:105
msgid "\"sync_exception_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:111
msgid "\"irq_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:113
msgid "\"No pending interrupt\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:114
msgid "\"IRQ {intid:?}\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:119
msgid "\"fiq_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:125
msgid "\"serr_current\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:131
msgid "\"sync_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:137
msgid "\"irq_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:143
msgid "\"fiq_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
msgid "\"serr_lower\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:154
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:172
msgid "// ANCHOR: main\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:213
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:236
msgid "// ANCHOR: Flags\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:264
msgid "// ANCHOR_END: Flags\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:268
msgid ""
"/// Flags from the UART Receive Status Register / Error Clear Register.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:272
msgid "/// Framing error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:274
msgid "/// Parity error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:276
msgid "/// Break error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:278
msgid "/// Overrun error.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:282
msgid "// ANCHOR: Registers\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:314
msgid "// ANCHOR_END: Registers\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:316
msgid ""
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:325
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:370
msgid "// ANCHOR_END: Uart\n"
msgstr ""

#: src/exercises/bare-metal/rtc.md:413
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:436 src/exercises/bare-metal/rtc.md:438
msgid "\"linux\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:437 src/exercises/bare-metal/rtc.md:439
msgid "\"CROSS_COMPILE\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:437
#, fuzzy
msgid "\"aarch64-linux-gnu\""
msgstr "aarch64-paging"

#: src/exercises/bare-metal/rtc.md:439
msgid "\"aarch64-none-elf\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:442
msgid "\"entry.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:443
#, fuzzy
msgid "\"exceptions.S\""
msgstr "ì˜ˆì™¸"

#: src/exercises/bare-metal/rtc.md:444
msgid "\"idmap.S\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:445
msgid "\"empty\""
msgstr ""

#: src/exercises/bare-metal/rtc.md:449
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:453
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:598
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:602
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:783
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:787
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:832
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:836
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:943
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:948
msgid "# Copyright 2023 Google LLC"
msgstr ""

#: src/exercises/bare-metal/rtc.md:962
msgid "$(shell uname -s)"
msgstr ""

#: src/exercises/bare-metal/rtc.md:964
#, fuzzy
msgid "aarch64-linux-gnu"
msgstr "aarch64-paging"

#: src/exercises/bare-metal/rtc.md:981
msgid "stdio -display none -kernel $< -s"
msgstr ""

#: src/exercises/bare-metal/rtc.md:984
msgid "cargo clean"
msgstr ""

#: src/exercises/bare-metal/rtc.md:999
msgid "Run the code in QEMU with `make qemu`."
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:1
msgid "Bare Metal Rust Afternoon"
msgstr "ì „Bare Metal ì˜¤í›„"

#: src/exercises/bare-metal/solutions-afternoon.md:5
msgid "([back to exercise](rtc.md))"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:7
#, fuzzy
msgid "_main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/solutions-afternoon.md:36
msgid "/// Base address of the PL031 RTC.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:38
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:57
msgid ""
"// Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:62
msgid "\"RTC: {time}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:70
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:73
#: src/exercises/bare-metal/solutions-afternoon.md:91
msgid "\"Waiting for {}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:75
#: src/exercises/bare-metal/solutions-afternoon.md:83
#: src/exercises/bare-metal/solutions-afternoon.md:96
#: src/exercises/bare-metal/solutions-afternoon.md:104
msgid "\"matched={}, interrupt_pending={}\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:87
#: src/exercises/bare-metal/solutions-afternoon.md:108
msgid "\"Finished waiting\""
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:89
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:121
msgid "_pl031.rs_:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:128
msgid "/// Data register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:130
msgid "/// Match register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:132
msgid "/// Load register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:134
msgid "/// Control register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:137
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:140
msgid "/// Raw Interrupt Status\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:143
msgid "/// Masked Interrupt Status\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:146
msgid "/// Interrupt Clear Register\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:150
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:158
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:170
msgid "/// Reads the current RTC value.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:172
#: src/exercises/bare-metal/solutions-afternoon.md:180
#: src/exercises/bare-metal/solutions-afternoon.md:188
#: src/exercises/bare-metal/solutions-afternoon.md:199
#: src/exercises/bare-metal/solutions-afternoon.md:211
#: src/exercises/bare-metal/solutions-afternoon.md:218
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:177
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:185
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:194
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:205
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:216
msgid "/// Clears a pending interrupt, if any.\n"
msgstr ""

#: src/concurrency.md:1
#, fuzzy
msgid "Welcome to Concurrency in Rust"
msgstr "Welcome to Comprehensive Rust ğŸ¦€"

#: src/concurrency.md:3
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ë™ì‹œì„± ì§€ì›ì´ ë§‰ê°•í•©ë‹ˆë‹¤. ìš´ì˜ì²´ì œ ë ˆë²¨ì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ë©°, ë®¤íƒìŠ¤"
"ì™€ ì±„ë„ë„ ì§€ì›í•©ë‹ˆë‹¤."

#: src/concurrency.md:6
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì˜ íƒ€ì… ì‹œìŠ¤í…œì€ í”„ë¡œê·¸ë¨ì— ë™ì‹œì„± ë²„ê·¸ê°€ ìˆì„ ê²½ìš°, ì»´íŒŒì¼ ì‹œì— ì—ëŸ¬"
"ê°€ ë°œìƒí•˜ë„ë¡ í•´ ì¤ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ë¥¼ ì´ìš©í•´ì„œ í”„ë¡œê·¸ë¨ì´ ìˆ˜í–‰ì‹œì— ì •í™•íˆ ë™ì‘"
"í•¨ì„ ë¯¸ë¦¬ ë³´ì¥í•´ ì£¼ê¸° ë•Œë¬¸ì—, ì‚¬ëŒë“¤ì€ ì´ë¥¼ ì¢…ì¢… _ê²ì—†ëŠ” ë™ì‹œì„±_ ì´ë¼ê³  í•©ë‹ˆ"
"ë‹¤."

#: src/concurrency/threads.md:3
msgid "Rust threads work similarly to threads in other languages:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ìŠ¤ë ˆë“œëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ ìŠ¤ë ˆë“œì™€ ìœ ì‚¬í•˜ê²Œ ë™ì‘í•©ë‹ˆë‹¤:"

#: src/concurrency/threads.md:12
msgid "\"Count in thread: {i}!\""
msgstr ""

#: src/concurrency/threads.md:18
msgid "\"Main thread: {i}\""
msgstr ""

#: src/concurrency/threads.md:24
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr ""
"ìŠ¤ë ˆë“œëŠ” ëª¨ë‘ ë°ëª¬ ìŠ¤ë ˆë“œì…ë‹ˆë‹¤. ë”°ë¼ì„œ ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ì´ ìŠ¤ë ˆë“œë“¤ì´ ëë‚˜ê¸°ë¥¼ "
"ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:25
msgid "Thread panics are independent of each other."
msgstr "í•œ ìŠ¤ë ˆë“œì—ì„œ ë°œìƒí•œ íŒ¨ë‹‰ì€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ì˜í–¥ì„ ë¼ì¹˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:26
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"íŒ¨ë‹‰ì€ ì¶”ê°€ì •ë³´(í˜ì´ë¡œë“œ)ë¥¼ í¬í•¨í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” `downcast_ref`ë¡œ í’€ì–´ë³¼ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:32
#, fuzzy
msgid ""
"Notice that the thread is stopped before it reaches 10 --- the main thread "
"is not waiting."
msgstr ""
"ë©”ì¸ ìŠ¤ë ˆë“œê°€ ìì‹ ìŠ¤ë ˆë“œë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•Šê¸° ë•Œë¬¸ì— ìì‹ ìŠ¤ë ˆë“œì˜ forë¬¸ì€ 10ê¹Œ"
"ì§€ ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/threads.md:35
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"ë§Œì•½ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ìì‹ ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¬ê¸°ë¥¼ ì›í•œë‹¤ë©´ `let "
"handle = thread::spawn(...)`ìœ¼ë¡œ ìŠ¤ë ˆë“œë¥¼ ì„ ì–¸í•œ í›„ `handle.join()`ë¡œ ì—°ê²°í•˜"
"ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/concurrency/threads.md:38
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr ""
"ìì‹ ìŠ¤ë ˆë“œì—ì„œ ë°œìƒí•œ íŒ¨ë‹‰ì´ ë©”ì¸ ìŠ¤ë ˆë“œì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŒì„ í™•ì¸í•˜ì‹œê¸° "
"ë°”ëë‹ˆë‹¤."

#: src/concurrency/threads.md:40
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"`handle.join()`ì‚¬ìš©ì‹œ `Result` ë°˜í™˜ê°’ì„ í†µí•´ íŒ¨ë‹‰ì˜ ì¶”ê°€ì •ë³´ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤. ì´ ì‹œì ì—ì„œ [`Any`](https://doc.rust-lang.org/std/any/index.html)ì— ëŒ€"
"í•´ ì´ì•¼ê¸°ë¥¼ í•´ ë³´ë©´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/concurrency/scoped-threads.md:3
msgid "Normal threads cannot borrow from their environment:"
msgstr "ë³´í†µ, ìŠ¤ë ˆë“œëŠ” ìŠ¤ë ˆë“œ ë°–ì—ì„œ ë°ì´í„°ë¥¼ ë¹Œë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/concurrency/scoped-threads.md:20
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"í•˜ì§€ë§Œ, [scoped thread](https://doc.rust-lang.org/std/thread/fn.scope.html)ì—"
"ì„œëŠ” ê°€ëŠ¥í•©ë‹ˆë‹¤:"

#: src/concurrency/scoped-threads.md:40
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"`thread::scope` í•¨ìˆ˜ê°€ ì™„ë£Œë˜ë©´ ê·¸ ì•ˆì—ì„œ ìƒì„±ëœ ëª¨ë“  ìŠ¤ë ˆë“œë“¤ì´ ì¢…ë£Œí–ˆìŒì´ "
"ë³´ì¥ë˜ê¸° ë•Œë¬¸ì—, ê·¸ ë•Œ ë¹Œë ¸ë˜ ë°ì´í„°ë“¤ì„ ë‹¤ì‹œ ë°˜í™˜í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/concurrency/scoped-threads.md:42
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"ì¼ë°˜ì ì¸ ëŸ¬ìŠ¤íŠ¸ì˜ ë¹Œë¦¼ ê·œì¹™ì´ ì ìš©ë©ë‹ˆë‹¤: í•œ ìŠ¤ë ˆë“œì— ì˜í•œ ê°€ë³€ ë¹Œë¦¼ ë˜ëŠ” ì—¬"
"ëŸ¬ ìŠ¤ë ˆë“œì— ëŒ€í•œ ë¶ˆë³€ ë¹Œë¦¼ì¤‘ í•˜ë‚˜ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/concurrency/channels.md:3
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì˜ ì±„ë„ì€ `Sender<T>` ì™€ `Receiver<T>` ë‘ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. ì´ ë‘˜ì€ "
"ì±„ë„ì„ í†µí•´ ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆì§€ë§Œ, ìš°ë¦¬ëŠ” ì±„ë„ì„ ë³¼ ìˆ˜ëŠ” ì—†ê³  ì´ ì–‘ ëë‹¨ë§Œì„ "
"ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/concurrency/channels.md:15 src/concurrency/channels.md:16
#: src/concurrency/channels.md:20
msgid "\"Received: {:?}\""
msgstr ""

#: src/concurrency/channels.md:26
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc`ëŠ” â€œMulti-Produce, Single-Consumerâ€ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. `Sender`ì™€ "
"`SyncSender`ëŠ” `Clone`ì„ êµ¬í˜„í•˜ì§€ë§Œ (ì¦‰, ì—¬ëŸ¬ê°œì˜ producerë¥¼ ë§Œë“¤ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤) `Receiver`ëŠ” `Clone`ì„ êµ¬í˜„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/concurrency/channels.md:29
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()`ì™€ `recv()`ëŠ” `Result`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë§Œì¼ `Err`ê°€ ë°˜í™˜ëœë‹¤ë©´, ìƒëŒ€ë°©"
"ì˜ `Sender`ë˜ëŠ” `Receiver`ê°€ ì‚­ì œë˜ì—ˆê³  ì±„ë„ì´ ë‹«í˜”ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤."

#: src/concurrency/channels/unbounded.md:3
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "`mpsc::channel()` í•¨ìˆ˜ëŠ” ê²½ê³„ê°€ ì—†ëŠ” ë¹„ë™ê¸° ì±„ë„ì„ ìƒì„±í•©ë‹ˆë‹¤:"

#: src/concurrency/channels/unbounded.md:16
#: src/concurrency/channels/bounded.md:16
msgid "\"Message {i}\""
msgstr ""

#: src/concurrency/channels/unbounded.md:17
#: src/concurrency/channels/bounded.md:17
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr ""

#: src/concurrency/channels/unbounded.md:19
#: src/concurrency/channels/bounded.md:19
msgid "\"{thread_id:?}: done\""
msgstr ""

#: src/concurrency/channels/unbounded.md:24
#: src/concurrency/channels/bounded.md:24
msgid "\"Main: got {msg}\""
msgstr ""

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "ê²½ê³„ê°€ ìˆëŠ” ë™ê¸° ì±„ë„ì€ `send`ê°€ í˜„ì œ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹ í•˜ë„ë¡ ë§Œë“­ë‹ˆë‹¤:"

#: src/concurrency/channels/bounded.md:31
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""

#: src/concurrency/channels/bounded.md:34
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""

#: src/concurrency/channels/bounded.md:36
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì–´ë–»ê²Œ í•´ì„œ ìŠ¤ë ˆë“œ ê°„ì— íŠ¹ì • ë°ì´í„° íƒ€ì…ì´ ê³µìœ ë  ìˆ˜ ìˆê±°ë‚˜, ì•ˆëœë‹¤"
"ëŠ” ê²ƒì„ ì•Œê¹Œìš”? ì •ë‹µì€ ë‹¤ìŒ ë‘ íŠ¸ë ˆì‡ì— ìˆìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync.md:6
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): `T`ê°€ ìŠ¤ë ˆë“œ "
"ê°„ ì´ë™ì´ ì•ˆì „í•˜ë‹¤ë©´, `T`ì˜ íƒ€ì…ì€ `Send`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync.md:8
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): `&T`ê°€ ìŠ¤ë ˆ"
"ë“œ ê°„ ì´ë™ì´ ì•ˆì „í•˜ë‹¤ë©´, `&T`ì˜ íƒ€ì…ì€ `Sync`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync.md:11
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Send`ì™€ `Sync` íŠ¸ë ˆì‡ì€ [ì•ˆì „í•˜ì§€ ì•Šì€ íŠ¸ë ˆì‡](../unsafe/unsafe-traits.md)ì…"
"ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ì˜ ìš”ì†Œë“¤ì´ ëª¨ë‘ `Send`ì™€ `Sync` íƒ€ì…ì´ë©´ ìë™ìœ¼ë¡œ ì´ íŠ¸"
"ë ˆì‡ë“¤ì„ ì ìš©ì‹œì¼œ ì¤ë‹ˆë‹¤. ë¬¼ë¡  ì—¬ëŸ¬ë¶„ ìŠ¤ìŠ¤ë¡œ ë§ë‹¤ê³  ì•Œê³  ìˆë‹¤ë©´ ì§ì ‘ êµ¬í˜„í•´"
"ë„ ë©ë‹ˆë‹¤."

#: src/concurrency/send-sync.md:21
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"`Sync`ì™€ `Send`ëŠ” ì–´ë–¤ íƒ€ì…ì´ íŠ¹ì •í•œ ìŠ¤ë ˆë“œ-ì•ˆì „ ì†ì„±ì„ ê°€ì§ì„ ë‚˜íƒ€ë‚´ëŠ” ë§ˆì»¤"
"ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/send-sync.md:23
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"ì´ ë‘ íŠ¸ë ˆì´íŠ¸ëŠ” ì œë„ˆë¦­ì—ì„œ ì œì•½ ì¡°ê±´ì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¸ë ˆì´íŠ¸ë¡œ ì‚¬ìš©ë  ìˆ˜ë„ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/concurrency/send-sync/send.md:3
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"`T`ê°€ ìŠ¤ë ˆë“œ ê°„ì— ì•ˆì „í•˜ê²Œ ì´ë™ë  ìˆ˜ ìˆë‹¤ë©´, `T`ì˜ íƒ€ì…ì€ `Send`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/send.md:5
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"ì†Œìœ ê¶Œì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™í•˜ë©´ ì†Œë©¸ìê°€ í•´ë‹¹ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤. ì—¬ê¸°ì„œ "
"ì˜ë¬¸ì€ \"ì–¸ì œ í•œ ìŠ¤ë ˆë“œì—ì„œ ê°’ì„ í• ë‹¹í•˜ê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ê°’ì„ í• ë‹¹ í•´ì œí•  "
"ìˆ˜ ìˆëŠ”ê°€\" ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´ SQLite ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—°ê²°ì€ ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œë§Œ ì•¡ì„¸ìŠ¤í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/concurrency/send-sync/sync.md:3
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"`&T`ê°€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ì•ˆì „í•˜ê²Œ ì ‘ê·¼ë  ìˆ˜ ìˆë‹¤ë©´, `&T`ì˜ íƒ€ì…ì€ `Sync`ì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/sync.md:6
msgid "More precisely, the definition is:"
msgstr "ì¢€ ë” ì •í™•í•œ ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/sync.md:8
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "`&T`ê°€ `Send`ì¸ ê²½ìš°ì—ë§Œ `T`ì˜ íƒ€ì…ì´ `Sync`ê°€ ë©ë‹ˆë‹¤"

#: src/concurrency/send-sync/sync.md:14
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"ìœ„ ë¬¸ì¥ì„ í’€ì–´ì„œ ì´ì•¼ê¸° í•˜ë©´, ì–´ë–¤ íƒ€ì…ì´ ìŠ¤ë ˆë“œ ê°„ì— ê³µìœ ë˜ì–´ì„œ ì‚¬ìš©ë˜ê¸°ì— "
"ì•ˆì „í•˜ë‹¤ë©´ ê·¸ íƒ€ì…ì˜ ì°¸ì¡° íƒ€ì…ì€ ìŠ¤ë ˆë“œ ê°„ì— ì´ë™ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/concurrency/send-sync/sync.md:18
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¦ëª…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤: ì–´ë–¤ íƒ€ì…ì´ `Sync`ë¼ëŠ” ë§ì€ ê³§ ê·¸ íƒ€ì…"
"ì´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë“¤ ì‚¬ì´ì—ì„œ ë°ì´í„° ë ˆì´ìŠ¤ë‚˜ ì—¬íƒ€ ë™ê¸°í™” ë¬¸ì œ ì—†ì´ ê³µìœ  ê°€ëŠ¥í•˜ë‹¤"
"ëŠ” ë§ì…ë‹ˆë‹¤. ìŠ¤ë ˆë“œ ê°„ ê³µìœ ê°€ ì•ˆì „í•˜ë‹¤ë©´, ìŠ¤ë ˆë“œê°„ ì´ë™ë„ ì•ˆì „í•  ìˆ˜ ë°–ì— ì—†ìŠµ"
"ë‹ˆë‹¤. ì–´ë–¤ íƒ€ì…ì˜ ìŠ¤ë ˆë“œê°„ ì´ë™ì´ ì•ˆì „í•˜ë‹¤ë©´, ê·¸ íƒ€ì…ì˜ ì°¸ì¡° ë˜í•œ ìŠ¤ë ˆë“œê°„ ì´"
"ë™ì´ ì•ˆì „í•  ìˆ˜ ë°–ì— ì—†ìŠµë‹ˆë‹¤."

#: src/concurrency/send-sync/examples.md:3
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md:5
msgid "Most types you come across are `Send + Sync`:"
msgstr "ì—¬ëŸ¬ë¶„ì´ ë‹¤ë£¨ê²Œ ë  ëŒ€ë¶€ë¶„ì˜ íƒ€ì…ì€ `Send + Sync`ì…ë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:7
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`, `f32`, `bool`, `char`, `&str`, ..."

#: src/concurrency/send-sync/examples.md:8
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."

#: src/concurrency/send-sync/examples.md:9
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."

#: src/concurrency/send-sync/examples.md:10
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr "`Arc<T>`: ì°¸ì¡° ì¹´ìš´íŠ¸ ì¡°ì‘ì„ ì•„í† ë¯¹ í•˜ê¸° ë•Œë¬¸ì— ìŠ¤ë ˆë“œ ì•ˆì „í•¨."

#: src/concurrency/send-sync/examples.md:11
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr ""
"`Mutex<T>`: ê°’ì„ ì ‘ê·¼í•˜ê¸° ìœ„í•´ ë®¤íƒìŠ¤ë¥¼ ì ê¶ˆì•¼ í•˜ê¸° ë•Œë¬¸ì— ìŠ¤ë ˆë“œ ì•ˆì „í•¨."

#: src/concurrency/send-sync/examples.md:12
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""
"`AtomicBool`, `AtomicU8`, ...: ê°’ì„ ì ‘ê·¼í•  ë•Œ íŠ¹ë³„í•œ ì•„í† ë¯¹ ëª…ë ¹ì–´ë“¤ì„ ì‚¬ìš©í•©"
"ë‹ˆë‹¤."

#: src/concurrency/send-sync/examples.md:14
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"ì œë„¤ë¦­ íƒ€ì…ì€ ì¼ë°˜ì ìœ¼ë¡œ íƒ€ì… íŒŒë¼ë©”í„°ê°€ `Send + Sync`ì´ë©´ `Send + Sync` ì…ë‹ˆ"
"ë‹¤."

#: src/concurrency/send-sync/examples.md:17
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md:19
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"ì•„ë˜ íƒ€ì…ë“¤ì€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ë  ìˆ˜ ìˆì§€ë§Œ ë‚´ë¶€ì ìœ¼ë¡œ ê°’ì´ ë³€ê²½ë  ìˆ˜ ìˆê¸° "
"ë•Œë¬¸ì— ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:22
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md:23
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md:24
msgid "`Cell<T>`"
msgstr "`Cell<T>`"

#: src/concurrency/send-sync/examples.md:25
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md:29
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr "ì•„ë˜ íƒ€ì…ë“¤ì€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ë§Œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T>`: ë‚´ë¶€ì ìœ¼ë¡œ, ìš´ì˜ì²´ì œê°€ ì œê³µí•˜ëŠ” primitiveë¥¼ ì‚¬ìš©í•˜ëŠ”ë°, ì´ "
"primitiveëŠ” ìƒì„±ëœ ìŠ¤ë ˆë“œì—ì„œ í•´ì œê°€ ì´ë£¨ì–´ì ¸ì•¼ í•©ë‹ˆë‹¤. (_ì—­ì£¼_: ê·¸ë˜ì„œ ë‹¤ë¥¸ "
"ìŠ¤ë ˆë“œë¡œ ì˜®ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.)"

#: src/concurrency/send-sync/examples.md:34
msgid "`!Send + !Sync`"
msgstr "`!Send + !Sync`"

#: src/concurrency/send-sync/examples.md:36
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"ì•„ë˜ íƒ€ì…ë“¤ì€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ë„ ì•Šê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™ë  ìˆ˜ë„ ì—†ìŠµë‹ˆë‹¤:"

#: src/concurrency/send-sync/examples.md:38
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`: `Rc<T>` ëŠ” ì•„í† ë¯¹í•˜ì§€ ì•Šì€ ë°©ì‹ìœ¼ë¡œ ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ì¡°ì‘í•˜ëŠ” "
"`RcBox<T>`ë¥¼ ì°¸ì¡°í•©ë‹ˆë‹¤."

#: src/concurrency/send-sync/examples.md:40
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`, `*mut T`: ëŸ¬ìŠ¤íŠ¸ëŠ” í¬ì¸í„°ê°€ ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•Šë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤."

#: src/concurrency/shared_state.md:3
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ëŠ” ì£¼ë¡œ ì•„ë˜ ë‘ ê°€ì§€ íƒ€ì…ì„ ì´ìš©í•´ì„œ ê³µìœ  ë°ì´í„° ë™ê¸°í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤:"

#: src/concurrency/shared_state.md:6
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), `T`ì— ëŒ€í•œ ì•„"
"í† ë¯¹ ì°¸ì¡° ì¹´ìš´íŠ¸: ì´ ì°¸ì¡°ëŠ” ë‹¤ìˆ˜ì˜ ìŠ¤ë ˆë“œ ì‚¬ì´ì—ì„œ ê³µìœ ë  ìˆ˜ ìˆê³ , ì°¸ì¡°í•˜ë˜ "
"ë§ˆì§€ë§‰ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œí•  ê²½ìš° `T`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/concurrency/shared_state.md:8
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): `T`ê°’ì— "
"ëŒ€í•œ ìƒí˜¸ ë°°ì œ ì—‘ì„¸ìŠ¤ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤."

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html)ì˜ `clone` ë©”ì„œ"
"ë“œë¥¼ ì´ìš©í•˜ë©´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ í•œ ë°ì´í„°ë¥¼ ë™ì‹œì— (_ì—­ì£¼_: ê·¸ë¦¬ê³  ì•ˆì „í•˜ê²Œ. ìŠ¤ë ˆ"
"ë“œê°€ í•˜ë‚˜ë¼ë„ ì‚´ì•„ìˆëŠ” ë™ì•ˆì—ëŠ” `T`ê°€ ë°˜í™˜ë˜ì§€ ì•ŠìŒ) ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/concurrency/shared_state/arc.md:16
msgid "\"{thread_id:?}: {v:?}\""
msgstr ""

#: src/concurrency/shared_state/arc.md:21
#: src/concurrency/shared_state/example.md:17
#: src/concurrency/shared_state/example.md:45
msgid "\"v: {v:?}\""
msgstr ""

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"`Arc`ëŠ” \"Atomic Reference Counted\"ë¥¼ ì˜ë¯¸í•˜ë©°, ìŠ¤ë ˆë“œ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ëŠ” "
"`Rc`ë¼ê³  ìƒê°í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/concurrency/shared_state/arc.md:31
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"`T`ê°€ `Clone`ì„ êµ¬í˜„í•˜ë“  ì•ˆí•˜ë“  `Arc<T>`ëŠ” `Clone`ì„ êµ¬í˜„í•©ë‹ˆë‹¤. `Send`ì™€ "
"`Sync`ëŠ” `T`ê°€ ì´ë“¤ì„ êµ¬í˜„í•˜ëŠ” ê²½ìš°ì—ë§Œ êµ¬í˜„ë©ë‹ˆë‹¤."

#: src/concurrency/shared_state/arc.md:33
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()`ëŠ” ì•„í† ë¯¹ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— ê·¸ ë•Œ ì½”ìŠ¤íŠ¸ê°€ ì¢€ ìˆì§€ë§Œ, ì¼"
"ë‹¨ `clone()`ì´ ëë‚œ í›„ `T`ë¥¼ ì‚¬ìš©í•˜ëŠ” ëŒ€ì—ëŠ” ì•„ë¬´ëŸ° ì˜¤ë²„í—¤ë“œê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/concurrency/shared_state/arc.md:35
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ìˆœí™˜ ì°¸ì¡°ë¥¼ ê°ì§€í•˜ëŠ” ê°€"
"ë¹„ì§€ ì»¬ë™í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/concurrency/shared_state/arc.md:37
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr "ìˆœí™˜ ì°¸ì¡°ë¥¼ í”¼í•˜ëŠ”ë° `std::sync::Weak`ê°€ ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:3
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface:"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)ë¥¼ ì´ìš©í•˜"
"ë©´ ë¶ˆë³€ ì°¸ì¡°ë¥¼ í†µí•´ì„œë„ `T`ì˜ ê°’ì„ ìˆ˜ì •í•  ìˆ˜ê°€ ìˆìœ¼ë©°, _ì´ì— ë”í•´ì„œ_ í•œ ë²ˆì— "
"í•œ ìŠ¤ë ˆë“œë§Œ `T`ì˜ ê°’ì„ ì ‘ê·¼(ì½ê±°ë‚˜ ì“°ê±°ë‚˜)í•¨ì„ ë³´ì¥í•´ ì¤ë‹ˆë‹¤:"

#: src/concurrency/shared_state/mutex.md:11
#: src/concurrency/shared_state/mutex.md:18
msgid "\"v: {:?}\""
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"ëª¨ë“  `Mutex<T>`ëŠ” [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-lang."
"org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E)ë¥¼ ìë™ìœ¼ë¡œ êµ¬í˜„í•¨"
"ì„ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ì˜ `Mutex`ëŠ” ì˜¤ì§ í•˜ë‚˜ì˜ ë°ì´í„°ë§Œ ë‹´ì„ ìˆ˜ ìˆëŠ” ì»¬ë ‰ì…˜ì²˜ëŸ¼ ë³¼ ìˆ˜ë„ ìˆìŠµ"
"ë‹ˆë‹¤. ë‹¤ë¥¸ ì»¬ë ‰ì…˜ê³¼ ë‹¤ë¥¸ ì ì€, ê·¸ ë°ì´í„°ê°€ ë™ì‹œì„± ë¬¸ì œë¡œë¶€í„° ììœ ë¡­ë‹¤ëŠ” ì ì…"
"ë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:33
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"`Mutex`ëŠ” ë®¤í…ìŠ¤ë¥¼ íšë“í•˜ì§€ ì•Šìœ¼ë©´ ë³´í˜¸ëœ ë°ì´í„°ì— ì ‘ê·¼í•˜ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥  í•˜ë„"
"ë¡ ë””ìì¸ ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:35
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"`&Mutex<T>`ì— ëŒ€í•´ lockì„ íšë“í•˜ë©´ `&mut T`ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `MutexGuard`"
"ëŠ” `&mut T`ê°€ íšë“í•œ lockë³´ë‹¤ ì˜¤ë˜ ì‚´ì•„ë‚¨ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:37
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr ""
"`Mutex<T>`ëŠ” ì˜¤ì§ `T`ê°€ `Send`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²½ìš°ì—ë§Œ `Send`ì™€ `Sync`ë¥¼ êµ¬í˜„í•©ë‹ˆ"
"ë‹¤."

#: src/concurrency/shared_state/mutex.md:39
#, fuzzy
msgid "A read-write lock counterpart: `RwLock`."
msgstr "ì½ê¸°-ì“°ê¸° lockì€ `RwLock`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/concurrency/shared_state/mutex.md:40
#, fuzzy
msgid "Why does `lock()` return a `Result`?"
msgstr "ì™œ `lock()`ì´ `Result`ë¥¼ ë°˜í™˜í• ê¹Œìš”?"

#: src/concurrency/shared_state/mutex.md:41
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"`Mutex`ë¥¼ íšë“í•œ ìŠ¤ë ˆë“œì—ì„œ íŒ¨ë‹‰ì´ ë°œìƒí•˜ë©´, ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ìƒí™©ì´ "
"ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ `Mutex`ê°€ \"ì¤‘ë…(poisoned)\" ë˜ì—ˆë‹¤ê³  í‘œí˜„í•˜ë©°, ì¤‘ë…ëœ "
"ë®¤í…ìŠ¤ì—ì„œ `lock()`ì„ í˜¸ì¶œí•˜ë©´ ì‹¤íŒ¨í•˜ê³  [`PoisonError`](https://doc.rust-"
"lang.org/std/sync/struct.PoisonError.html)ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì˜¤ë¥˜ë¡œë¶€í„° ë°"
"ì´í„°ë¥¼ ë³µêµ¬í•˜ê¸° ìœ„í•´ `into_inner()`ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/concurrency/shared_state/example.md:3
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "`Arc`ì™€ `Mutex`ì˜ ë™ì‘ì„ ì‚´í´ë´…ì‹œë‹¤:"

#: src/concurrency/shared_state/example.md:6
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid "Possible solution:"
msgstr "ê°€ëŠ¥í•œ í•´ê²°ì±…:"

#: src/concurrency/shared_state/example.md:49
msgid "Notable parts:"
msgstr "ëˆˆì—¬ê²¨ ë³¼ ë¶€ë¶„:"

#: src/concurrency/shared_state/example.md:51
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"`v`ëŠ” `Arc`ì™€ `Mutex` ëª¨ë‘ì— í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” `Arc`ì™€ `Mutex`ê°€ ì„œë¡œ "
"ì™„ì „íˆ ë‹¤ë¥¸ ë¬¸ì œë¥¼ ìœ„í•œ ë„êµ¬ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/concurrency/shared_state/example.md:53
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"`Mutex`ë¥¼ `Arc`ë¡œ ë˜í•‘í•˜ëŠ” ê²ƒì€ ê°€ë³€ ìƒíƒœë¥¼ ìŠ¤ë ˆë“œë“¤ ê°„ì— ê³µìœ í•  ë•Œ í”íˆ ì‚¬ìš©"
"í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤."

#: src/concurrency/shared_state/example.md:55
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>`ë¥¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‚¬ìš©í•˜ë ¤ë©´, ë¨¼ì € `v2`ë¡œ ë³µì‚¬ë¥¼ í•˜ê³  ì´ë¥¼ ê·¸ ìŠ¤"
"ë ˆë“œë¡œ ì´ë™ í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ë˜ì„œ ëŒë‹¤ì˜ ì‹œê·¸ë‹ˆì²˜ì— `move`ê°€ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/concurrency/shared_state/example.md:57
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr "ë¸”ë¡ì€ `LockGuard`ì˜ ë²”ìœ„ë¥¼ ìµœëŒ€í•œ ì¢íˆê¸° ìœ„í•´ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/exercises/concurrency/morning.md:3
msgid "Let us practice our new concurrency skills with"
msgstr "ë™ì‹œì„± ê¸°ë²•ë“¤ì„ ì—°ìŠµí•´ ë´…ì‹œë‹¤"

#: src/exercises/concurrency/morning.md:5
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "ì‹ì‚¬í•˜ëŠ” ì² í•™ì ë¬¸ì œ: ê³ ì ì ì¸ ë™ì‹œì„± ë¬¸ì œì…ë‹ˆë‹¤."

#: src/exercises/concurrency/morning.md:7
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"ë©€í‹° ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°: ë³‘ë ¬ì ìœ¼ë¡œ ì›¹í˜ì´ì§€ì˜ ë§í¬ë“¤ì„ ì²´í¬í•©ë‹ˆë‹¤. ì¹´ê³ ë¥¼ í†µ"
"í•´ ëª‡ ê°€ì§€ ì˜ì¡´ì„±ë“¤ì„ ë‹¤ìš´ë„ë¥´ ë°›ì•„ì•¼ í•˜ëŠ” í° í”„ë¡œì íŠ¸ ì…ë‹ˆë‹¤."

#: src/exercises/concurrency/dining-philosophers.md:3
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "ì‹ì‚¬í•˜ëŠ” ì² í•™ì ë¬¸ì œëŠ” ë™ì‹œì„±ì— ìˆì–´ì„œ ê³ ì „ì ì¸ ë¬¸ì œì…ë‹ˆë‹¤:"

#: src/exercises/concurrency/dining-philosophers.md:5
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"5ëª…ì˜ ì² í•™ìê°€ ì›íƒì—ì„œ ì‹ì‚¬ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤.  ì² í•™ìëŠ” ì›íƒì—ì„œ ìì‹ ì˜ ìë¦¬"
"ì— ì•‰ì•„ìˆìŠµë‹ˆë‹¤. í¬í¬ëŠ” ê° ì ‘ì‹œ ì‚¬ì´ì— ìˆìŠµë‹ˆë‹¤.  ì œê³µë˜ëŠ” ìš”ë¦¬ë¥¼ ë¨¹ê¸° ìœ„í•´ì„œ"
"ëŠ” ë‘ ê°œì˜ í¬í¬ë¥¼ ëª¨ë‘ ì‚¬ìš©í•´ì•¼í•©ë‹ˆë‹¤. ì² í•™ìëŠ” ìƒê°ì„ í•˜ë‹¤ê°€ ë°°ê°€ ê³ í”„ë©´ ì"
"ì‹ ì˜ ì¢Œ,ìš°ì˜ í¬í¬ë¥¼ ë“¤ì–´ ìš”ë¦¬ë¥¼ ë¨¹ìŠµë‹ˆë‹¤. ì² í•™ìëŠ” ìš”ë¦¬ë¥¼ ë¨¹ì€ í›„ì—ëŠ” í¬í¬ë¥¼ "
"ë‹¤ì‹œ ìë¦¬ì— ë‚´ë ¤ë†“ìŠµë‹ˆë‹¤. ì² í•™ìëŠ” ìì‹ ì˜ ì¢Œ,ìš°ì— í¬í¬ê°€ ìˆì„ë•Œë§Œ ìš”ë¦¬ë¥¼ ë¨¹"
"ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë‘ ê°œì˜ í¬í¬ëŠ” ì˜¤ì§ ìì‹ ì˜ ì¢Œ,ìš° ì² í•™ìê°€ ìƒê°ì„ í•  ë•Œ"
"ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"ì´ë²ˆ í›ˆë ¨ì—ì„œëŠ” [ì¹´ê³  ì„¤ì¹˜í•˜ê¸°](../../cargo/running-locally.md)ê°€ í•„ìš”í•©ë‹ˆ"
"ë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ë³µì‚¬í•´ì„œ `src/main.rs`ì— ë¶™ì—¬ë†“ê³  ë¹ˆ ë¶€ë¶„ì„ ì±„ìš°ê³ , `cargo "
"run` ì»¤ë§¨ë“œë¡œ í…ŒìŠ¤íŠ¸ í•´ì„œ êµì°©ìƒíƒœ(ë°ë“œë½)ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/exercises/concurrency/dining-philosophers.md:28
#: src/exercises/concurrency/dining-philosophers-async.md:23
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:36
#: src/exercises/concurrency/solutions-morning.md:24
#: src/exercises/concurrency/dining-philosophers-async.md:31
#: src/exercises/concurrency/solutions-afternoon.md:25
msgid "\"Eureka! {} has a new idea!\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:41
#: src/exercises/concurrency/dining-philosophers-async.md:37
#: src/exercises/concurrency/solutions-afternoon.md:31
msgid "// Pick up forks...\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:42
#: src/exercises/concurrency/solutions-morning.md:33
#: src/exercises/concurrency/dining-philosophers-async.md:38
#: src/exercises/concurrency/solutions-afternoon.md:38
msgid "\"{} is eating...\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
#, fuzzy
msgid "\"Socrates\""
msgstr "HAL í¬ë ˆì´íŠ¸ë“¤"

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Hypatia\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Plato\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Aristotle\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:48
#: src/exercises/concurrency/solutions-morning.md:39
#: src/exercises/concurrency/dining-philosophers-async.md:44
#: src/exercises/concurrency/solutions-afternoon.md:46
msgid "\"Pythagoras\""
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:51
#: src/exercises/concurrency/dining-philosophers-async.md:48
#: src/exercises/concurrency/solutions-afternoon.md:50
msgid "// Create forks\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:53
#: src/exercises/concurrency/dining-philosophers-async.md:50
#: src/exercises/concurrency/solutions-afternoon.md:54
msgid "// Create philosophers\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:55
msgid "// Make each of them think and eat 100 times\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:57
#: src/exercises/concurrency/dining-philosophers-async.md:54
#: src/exercises/concurrency/solutions-afternoon.md:88
msgid "// Output their thoughts\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
msgid "You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:3
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"ìƒˆë¡œ ë°°ìš´ê²ƒë“¤ì„ í™œìš©í•´ì„œ ë©€í‹° ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°ë¥¼ ë§Œë“­ë‹ˆë‹¤. ì´ ê²€ì‚¬ê¸°ëŠ” ì›¹í˜"
"ì´ì§€ ì•ˆì— ìˆëŠ” ë§í¬ë“¤ì´ ìœ íš¨í•œì§€ í™•ì¸í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì¬ê·€ì ìœ¼ë¡œ ë™ì¼ ë„ë©”ì¸ì˜ "
"ë‹¤ë¥¸ ëª¨ë“  í˜ì´ì§€ê°€ ìœ íš¨í•œì§€ í™•ì¸í•©ë‹ˆë‹¤."

#: src/exercises/concurrency/link-checker.md:8
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"ì´ë¥¼ ìœ„í•´ì„œ [`reqwest`](https://docs.rs/reqwest/)ì™€ ê°™ì€ HTTP í´ë¼ì´ì–¸íŠ¸ê°€ í•„"
"ìš”í•©ë‹ˆë‹¤. ìƒˆë¡œìš´ ë¡œì»¬ í”„ë¡œì íŠ¸ë¥¼ ë§Œë“¤ê³  [`reqwest`](https://docs.rs/reqwest/)"
"ë¥¼ ì˜ì¡´ì„±ì— ì¶”ê°€í•˜ì‹­ì‹œìš”:"

#: src/exercises/concurrency/link-checker.md:17
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"ë§Œì¼ `cargo add` ì»¤ë§¨ë“œê°€ `error: no such subcommand` ë¡œ ì‹¤íŒ¨í•œë‹¤ë©´ `Cargo."
"toml` íŒŒì¼ì„ ì§ì ‘ ìˆ˜ì •í•´ë„ ë©ë‹ˆë‹¤. ì•„ë˜ì— ì „ì²´ ì˜ì¡´ì„± ë‚´ìš©ì´ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/concurrency/link-checker.md:20
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr "ë§í¬ë¥¼ ì°¾ê¸° ìœ„í•´ì„œ [`scraper`](https://docs.rs/scraper/)ë„ ì¶”ê°€í•©ë‹ˆë‹¤:"

#: src/exercises/concurrency/link-checker.md:26
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"ë§ˆì§€ë§‰ìœ¼ë¡œ ì˜¤ë¥˜ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ [`thiserror`](https://docs.rs/thiserror/)"
"ë„ ì¶”ê°€í•©ë‹ˆë‹¤:"

#: src/exercises/concurrency/link-checker.md:33
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "ëª¨ë“  `cargo add`ê°€ ëë‚˜ë©´ `Cargo.toml`ì— ì•„ë˜ ë‚´ìš©ì´ ì¶”ê°€ë©ë‹ˆë‹¤:"

#: src/exercises/concurrency/link-checker.md:37
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:50
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr "ì´ì œ `https://www.google.org/` ê°™ì€ ì›¹ í˜ì´ì§€ë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/exercises/concurrency/link-checker.md:53
msgid "Your `src/main.rs` file should look something like this:"
msgstr "`rc/main.rs`íŒŒì¼ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#: src/exercises/concurrency/link-checker.md:65
#: src/exercises/concurrency/solutions-morning.md:97
msgid "\"request error: {0}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:67
#: src/exercises/concurrency/solutions-morning.md:99
msgid "\"bad http response: {0}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:78
#: src/exercises/concurrency/solutions-morning.md:110
msgid "\"Checking {:#}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:96
#: src/exercises/concurrency/solutions-morning.md:128
msgid "\"href\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:103
#: src/exercises/concurrency/solutions-morning.md:135
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:112
#: src/exercises/concurrency/solutions-morning.md:245
msgid "\"https://www.google.org\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:115
msgid "\"Links: {links:#?}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:116
msgid "\"Could not extract links: {err:#}\""
msgstr ""

#: src/exercises/concurrency/link-checker.md:121
msgid "Run the code in `src/main.rs` with"
msgstr "ì•„ë˜ ì»¤ë§¨ë“œë¡œ ì†ŒìŠ¤ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤"

#: src/exercises/concurrency/link-checker.md:129
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë§í¬ë¥¼ ë³‘ë ¬ë¡œ í™•ì¸í•©ë‹ˆë‹¤: URLì„ ì±„ë„ë¡œ ë³´ë‚´ì„œ ëª‡ ê°œì˜ ìŠ¤ë ˆ"
"ë“œê°€ URLì„ ë³‘ë ¬ë¡œ ì²´í¬í•˜ë„ë¡ í•©ë‹ˆë‹¤."

#: src/exercises/concurrency/link-checker.md:131
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"`www.google.org`ë„ë©”ì¸ì˜ ëª¨ë“  í˜ì´ì§€ë¥¼ ì¬ê·€ì ìœ¼ë¡œ í™•ì¸í•˜ê¸° ìœ„í•´ ì½”ë“œë¥¼ í™•ì¥í•´"
"ì„œ ì‘ì„±í•©ë‹ˆë‹¤: ì°¨ë‹¨ë‹¹í•˜ì§€ ì•Šë„ë¡ 100í˜ì´ì§€ ì •ë„ë¡œ ì œí•œì„ ë‘ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "Concurrency Morning Exercise"
msgstr "3ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#: src/exercises/concurrency/solutions-morning.md:5
msgid "([back to exercise](dining-philosophers.md))"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:29
msgid "\"{} is trying to eat\""
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:53
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:77
msgid "\"{thought}\""
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:82
#, fuzzy
msgid "Link Checker"
msgstr "ë©€í‹°ìŠ¤ë ˆë“œ ë§í¬ ê²€ì‚¬ê¸°"

#: src/exercises/concurrency/solutions-morning.md:84
msgid "([back to exercise](link-checker.md))"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:154
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:162
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:188
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:229
msgid "\"Got crawling error: {:#}\""
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:247
msgid "\"Bad URLs: {:#?}\""
msgstr ""

#: src/async.md:1
#, fuzzy
msgid "Async Rust"
msgstr "ë¹„ë™ê¸°"

#: src/async.md:3
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"\"Async\"ëŠ” ë¸”ëŸ­ë (ë” ì´ìƒ ì§„í–‰í•  ìˆ˜ ì—†ì„) ë•Œê¹Œì§€ ê° ì‘ì—…ì„ ì‹¤í–‰í•œ ë‹¤ìŒ ì§„í–‰"
"í•  ì¤€ë¹„ê°€ ëœ ë‹¤ë¥¸ ì‘ì—…ìœ¼ë¡œ ì „í™˜í•˜ì—¬ ì—¬ëŸ¬ ì‘ì—…ì„ ë™ì‹œì— ì‹¤í–‰í•˜ëŠ” ë™ì‹œ ì‹¤í–‰ ëª¨"
"ë¸ì…ë‹ˆë‹¤. ì´ ëª¨ë¸ì„ ì‚¬ìš©í•˜ë©´ ì œí•œëœ ìˆ˜ì˜ ìŠ¤ë ˆë“œì—ì„œ ë” ë§ì€ ì‘ì—…ì„ ì‹¤í–‰í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì´ëŠ”, í•œ ì‘ì—…ì„ ìœ ì§€í•˜ê³  ìˆ˜í–‰í•˜ëŠ”ë° í•„ìš”í•œ ì˜¤ë²„í—¤ë“œê°€ (ìŠ¤ë ˆë“œì— ë¹„"
"í•´) ë§¤ìš° ë‚®ê³  ìš´ì˜ì²´ì œê°€ ì—¬ëŸ¬ I/Oë“¤ì—ì„œ í˜„ì¬ ì§„í–‰ ê°€ëŠ¥í•œ I/Oë“¤ì„ íš¨ê³¼ì ìœ¼ë¡œ "
"ì‹ë³„í•´ ì£¼ëŠ” í”„ë¦¬ë¯¸í‹°ë¸Œë¥¼ ì œê³µí•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/async.md:10
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Rustì˜ ë¹„ë™ê¸° ì‘ì—…ì€ \"futures\"ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©° ì´ëŠ” ë¯¸ë˜ì— ì™„ë£Œë  ìˆ˜ ìˆëŠ” "
"ì‘ì—…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. FuturesëŠ” ì™„ë£Œë˜ì—ˆë‹¤ëŠ” ì‹ í˜¸ë¥¼ ë³´ë‚¼ ë•Œê¹Œì§€ \"í´ë§\"ë©ë‹ˆë‹¤."

#: src/async.md:14
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""
"FuturesëŠ” ë¹„ë™ê¸° ëŸ°íƒ€ì„ì— ì˜í•´ í´ë§ë˜ë©°, ë¹„ë™ê¸° ëŸ°íƒ€ì„ì—ëŠ” ì—¬ëŸ¬ ë‹¤ì–‘í•œ ì¢…ë¥˜"
"ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/async.md:19
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"íŒŒì´ì¬ì—ë„ `asyncio`ë¼ëŠ” ìœ ì‚¬í•œ ëª¨ë¸ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ íŒŒì´ì¬ì˜ `Future` íƒ€"
"ì…ì€ ì½œë°± ê¸°ë°˜ì´ë©° í´ë§ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŒŒì´ì¬ìœ¼ë¡œ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì„ í•  ë•Œì—"
"ëŠ”, Rustì—ì„œ ëŸ°íƒ€ì„ì´ ë‚´ë¶€ì ìœ¼ë¡œ í•´ ì£¼ëŠ” ê²ƒê³¼ ìœ ì‚¬í•œ,  \"ë£¨í”„\"ë¥¼ ëª…ì‹œì ìœ¼ë¡œ "
"ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/async.md:23
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ `Promise`ë„ ë¹„ìŠ·í•˜ì§€ë§Œ ì—­ì‹œ ì½œë°± ê¸°ë°˜ì…ë‹ˆë‹¤. ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ"
"ëŠ” ì´ë²¤íŠ¸ ë£¨í”„ê°€ëŸ°íƒ€ì„ ì—”ì§„ì—ì„œ êµ¬í˜„ë˜ë¯€ë¡œ `Promise`ê°€ ì²˜ë¦¬ë˜ëŠ” ì„¸ë¶€ ê³¼ì •ì´ "
"ìˆ¨ê²¨ì§‘ë‹ˆë‹¤."

#: src/async/async-await.md:3
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""
"ê²‰ì—ì„œ ë³´ì•˜ì„ ë•Œ, ë¹„ë™ê¸° Rust ì½”ë“œëŠ” ì¼ë°˜ì ì¸ ì ˆì°¨ì  ì½”ë“œì™€ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤."

#: src/async/async-await.md:10
msgid "\"Count is: {i}!\""
msgstr ""

#: src/async/async-await.md:27
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"Rust ë¹„ë™ê¸° ë¬¸ë²•ì„ ë³´ì—¬ì£¼ëŠ” ê°„ë‹¨í•œ ì˜ˆì‹œì…ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” ì˜¤ë˜ ì‹¤í–‰ë˜ëŠ” ì‘ì—…ì´"
"ë‚˜, ì‹¤ì œë¡œ ë™ì‹œì— ìˆ˜í–‰ë˜ëŠ” ê²ƒë“¤ì€ ì—†ìŠµë‹ˆë‹¤."

#: src/async/async-await.md:30
msgid "What is the return type of an async call?"
msgstr "`async`í•¨ìˆ˜ì˜ ë¦¬í„´ íƒ€ì…ì€ ë¬´ì—‡ì¸ê°€ìš”?"

#: src/async/async-await.md:31
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""
"`main`ì—ì„œ \\`let future: () = async_main(10);ì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì…ì„ í™•ì¸í•˜ì„¸ìš”."

#: src/async/async-await.md:33
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr ""
"\"async\" í‚¤ì›Œë“œëŠ” ë¬¸ë²• ì„¤íƒ•(syntactic sugar)ì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ë¦¬í„´ íƒ€ì…ì„ "
"futureë¡œ ë°”ê¿‰ë‹ˆë‹¤. "

#: src/async/async-await.md:36
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"`main`ì„ ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ ë§Œë“¤ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤. ë§Œì•½ ê·¸ë ‡ê²Œ í•  ê²½ìš° ì»´íŒŒì¼ëŸ¬ëŠ” ë¦¬"
"í„´ íƒ€ì…ì¸ futureë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í•  ì§€ ëª¨ë¥´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/async/async-await.md:39
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"ë¹„ë™ê¸° ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ ì‹¤í–‰ì(executor)ê°€ í•„ìš”í•©ë‹ˆë‹¤. `block_on` ì‹¤í–‰ìëŠ” "
"ì œê³µëœ futureê°€ ì™„ë£Œë  ë•Œê¹Œì§€ í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡í•©ë‹ˆë‹¤. "

#: src/async/async-await.md:42
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await`ëŠ” ë‹¤ë¥¸ ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ëŒ€ê¸°í•©ë‹ˆë‹¤. `block_on`ê³¼ ë‹¬"
"ë¦¬ `.await`ëŠ” í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/async/async-await.md:45
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr ""
"`.await`ëŠ” `async` í•¨ìˆ˜(ë˜ëŠ” ë‚˜ì¤‘ì— ì†Œê°œë  `async` ë¸”ë¡) ì•ˆì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. "

#: src/async/futures.md:3
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html)ëŠ” íŠ¸ë ˆì‡ì…"
"ë‹ˆë‹¤.ì´ íŠ¸ë ˆì‡ì€ ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì•˜ì„ ìˆ˜ë„ ìˆëŠ” ì‘ì—…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. FutureëŠ” "
"`poll` í•¨ìˆ˜ë¥¼ í†µí•´ í´ë§ë  ìˆ˜ ìˆìœ¼ë©°, ì´ í•¨ìˆ˜ëŠ” [`Poll`](https://doc.rust-"
"lang.org/std/task/enum.Poll.html)ì„ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/async/futures.md:23
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"ë¹„ë™ê¸° í•¨ìˆ˜ëŠ” `impl Future`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ìƒˆë¡œìš´ íƒ€ì…ì„ ë§Œë“¤ê³  ì´ íƒ€ì…ì´ "
"`Future`ë¥¼ êµ¬í˜„í•˜ê²Œ í•  ìˆ˜ë„ ìˆì§€ë§Œ ì¼ë°˜ì ì´ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `tokio::"
"spawn`ê°€ ë¦¬í„´í•˜ëŠ” `JoinHandle`ì€ `Future`ë¥¼ êµ¬í˜„í•˜ë©°, ì´ë¥¼ í†µí•´ ìƒì„±ëœ ìŠ¤ë ˆë“œ"
"ì— joiní•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/futures.md:27
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"Futureì— `.await`ë¥¼ í˜¸ì¶œí•˜ë©´, í•´ë‹¹ Futureê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ í˜„ì¬ ë¹„ë™ê¸° í•¨ìˆ˜ê°€ "
"ì¼ì‹œ ì¤‘ì§€ë©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ Futureê°€ ì¤€ë¹„ê°€ ë˜ë©´, ê·¸ ê°’ì´ `.await` êµ¬ë¬¸ì˜ ê°’"
"ì´ ë©ë‹ˆë‹¤."

#: src/async/futures.md:32
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"`Future` ì™€ `Poll` íƒ€ì…ì˜ ì‹¤ì œ ì •ì˜ëŠ” ìœ„ì— ë³´ì´ëŠ” ê·¸ëŒ€ë¡œ ì…ë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­"
"í•˜ë©´ Rust ë¬¸ì„œì—ì„œ í•œ ë²ˆ ë” í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/futures.md:35
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"ë³¸ ê°•ì˜ì˜ ëª©ì ì€ ë¹„ë™ê¸° ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ”ë° ìˆê¸° ë•Œë¬¸ì—, ìƒˆë¡œìš´ ë¹„ë™ê¸° í”„ë¦¬ë¯¸í‹°"
"ë¸Œë¥¼ ë§Œë“œëŠ”ë° í•„ìš”í•œ  `Pin`ê³¼ `Context`ëŠ” ë‹¤ë£¨ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ë“¤ì— ëŒ€í•´ ê°„ë‹¨"
"íˆ ì„¤ëª…í•˜ìë©´:"

#: src/async/futures.md:38
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""
"`Context`ë¥¼ ì‚¬ìš©í•˜ë©´ Futureê°€ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œ ë‹¤ì‹œ í´ë§ë˜ë„ë¡ ì˜ˆì•½í•  ìˆ˜ ìˆ"
"ìŠµë‹ˆë‹¤."

#: src/async/futures.md:41
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"'Pin'ì„ ì‚¬ìš©í•˜ë©´ ë©”ëª¨ë¦¬ì—ì„œ Futureì˜ ìœ„ì¹˜ê°€ ê³ ì •ë˜ê¸° ë•Œë¬¸ì— í•´ë‹¹ futureì˜ í¬"
"ì¸í„°ê°€ í•­ìƒ ìœ íš¨í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤. ì´ëŠ” `.await` í›„ì— ì°¸ì¡°ë¥¼ ìœ íš¨í•œ ìƒíƒœë¡œ ìœ ì§€"
"í•˜ê¸° ìœ„í•´ í•„ìš”í•©ë‹ˆë‹¤."

#: src/async/runtimes.md:3
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"ë¹„ë™ê¸° _ëŸ°íƒ€ì„_ì€ _ë¦¬ì•¡í„°_ (ë¹„ë™ê¸°ì‹ ì‘ì—… ì‹¤í–‰ì„ ì§€ì›)ì™€ _ì‹¤í–‰ì_ (futuresë¥¼ "
"ì‹¤í–‰)ì˜ ë‘ ê°€ì§€ ì—­í• ì„ í•©ë‹ˆë‹¤. Rust ì–¸ì–´ ìì²´ì—ì„œ ê¸°ë³¸ ì œê³µí•˜ëŠ” ë¹„ë™ê¸° ëŸ°íƒ€ì„"
"ì€ ì—†ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë‹¤ìŒê³¼ ê°™ì€ ë¹„ë™ê¸° ëŸ°íƒ€ì„ í¬ë ˆì‡ë“¤ì´ ìˆìŠµë‹ˆë‹¤."

#: src/async/runtimes.md:7
#, fuzzy
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/) - ì„±ëŠ¥ì´ ìš°ìˆ˜í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  HTTPë¥¼ ì§€ì›í•˜ëŠ” "
"[Hyper](https://hyper.rs/) ì™€ gRPCë¥¼ ì§€ì›í•˜ëŠ” [Tonic](https://github.com/"
"hyperium/tonic)ê³¼ ê°™ì€ ì˜ ë°œë‹¬ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒíƒœê³„ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/async/runtimes.md:10
#, fuzzy
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/) - ë¹„ë™ê¸°ì—ì„œì˜ `std`ë¥¼ ëª©í‘œë¡œ í•˜ê³  ìˆìŠµë‹ˆë‹¤. "
"`async::task`ì— ê¸°ë³¸ ëŸ°íƒ€ì„ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/async/runtimes.md:12
#, fuzzy
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/) - ê°„ë‹¨í•˜ê³  ê°€ë³ìŠµë‹ˆë‹¤."

#: src/async/runtimes.md:14
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"ì—¬ëŸ¬ ëŒ€ê·œëª¨ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ëŠ” ìì²´ ëŸ°íƒ€ì„ì´ ìˆëŠ” ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤. ì˜ˆë“¤ ë“¤ì–´  "
"[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/"
"fuchsia-async/src/lib.rs)ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/async/runtimes.md:20
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œì—ì„œëŠ” ìœ„ì— ë‚˜ì—´ëœ ë¹„ë™ê¸° ëŸ°íƒ€ì„ ì¤‘ì—ì„œ Tokioë§Œ ì‚¬ìš©í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ë˜í•œ Rust í”Œë ˆì´ê·¸ë¼ìš´ë“œëŠ” I/Oë¥¼ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ asyncë¥¼ ê°€ì§€ê³  "
"í•  ìˆ˜ ìˆëŠ” ë§ì€ í¥ë¯¸ë¡œìš´ ì‘ì—…ë“¤ì´ ë¶ˆê°€ëŠ¥ í•©ë‹ˆë‹¤."

#: src/async/runtimes.md:24
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"FuturesëŠ” ì‹¤í–‰ìê°€ í´ë§í•˜ì§€ ì•ŠëŠ” í•œ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì—ì„œ(I/O ì‘ì—…ì¡°"
"ì°¨ ì‹œì‘í•˜ì§€ ì•ŠìŒ) \"ë¹„í™œì„±\" ìƒíƒœì…ë‹ˆë‹¤. ì´ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë„ ì™„ë£Œë  "
"ë•Œ ê¹Œì§€ ì‹¤í–‰ë˜ëŠ”, ìë°” ìŠ¤í¬ë¦½íŠ¸ì˜ promiseì™€ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/async/runtimes/tokio.md:3
#, fuzzy
msgid "Tokio provides:"
msgstr "TokioëŠ” ë‹¤ìŒì„ ì œê³µí•©ë‹ˆë‹¤. "

#: src/async/runtimes/tokio.md:5
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr "ë¹„ë™ê¸° ì½”ë“œ ì‹¤í–‰ì„ ìœ„í•œ ë©€í‹°ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„"

#: src/async/runtimes/tokio.md:6
msgid "An asynchronous version of the standard library."
msgstr "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ë¹„ë™ê¸° ë²„ì „"

#: src/async/runtimes/tokio.md:7
msgid "A large ecosystem of libraries."
msgstr "ëŒ€ê·œëª¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒíƒœê³„"

#: src/async/runtimes/tokio.md:14
msgid "\"Count in task: {i}!\""
msgstr ""

#: src/async/runtimes/tokio.md:24
msgid "\"Main task: {i}\""
msgstr ""

#: src/async/runtimes/tokio.md:32
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr ""
"ì´ì œ `tokio::main` ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ë©´ `main`ì„ ë¹„ë™ê¸°ë¡œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/runtimes/tokio.md:34
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "`spawn` í•¨ìˆ˜ëŠ” ë™ì‹œ ì‹¤í–‰ë˜ëŠ” ìƒˆë¡œìš´ \"ì‘ì—…\"ì„ ë§Œë“­ë‹ˆë‹¤."

#: src/async/runtimes/tokio.md:36
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"ì°¸ê³ : `spawn`ì€ `Future`ë¥¼ ì¸ìë¡œ ë°›ìŠµë‹ˆë‹¤. ë•Œë¬¸ì— `count_to`ì— `.await`ë¥¼ í˜¸"
"ì¶œí•˜ì§€ ì•ŠëŠ” ì ì„ ì£¼ëª©í•˜ì„¸ìš”."

#: src/async/runtimes/tokio.md:38
msgid "**Further exploration:**"
msgstr "**ì‹¬í™” í•™ìŠµ:**"

#: src/async/runtimes/tokio.md:40
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"`count_to`ê°€ 10ì— ë„ë‹¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ë§ì€ë° ê·¸ ì´ìœ ëŠ” ë¬´ì—‡ì¼ê¹Œìš”? ì´ëŠ” ë¹„ë™"
"ê¸°ì ì¸ ì·¨ì†Œë¥¼ ë³´ì—¬ì£¼ëŠ” ì˜ˆì…ë‹ˆë‹¤. `tokio::spawn`ì´ ë¦¬í„´í•˜ëŠ” ê²ƒì€ ì™„ë£Œë  ë•Œê¹Œ"
"ì§€ ê¸°ë‹¤ë¦¬ë„ë¡ ëŒ€ê¸°í•˜ëŠ”ë° ì‚¬ìš©ë˜ëŠ” í•¸ë“¤ì…ë‹ˆë‹¤."

#: src/async/runtimes/tokio.md:44
msgid "Try `count_to(10).await` instead of spawning."
msgstr "`tokio::spawn` ëŒ€ì‹  `count_to(10).await`ë¥¼ ì‚¬ìš©í•´ ë³´ì„¸ìš”."

#: src/async/runtimes/tokio.md:46
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "`tokio::spawn`ì—ì„œ ë°˜í™˜ëœ ì‘ì—…ì„ `await` í•´ ë³´ì„¸ìš”."

#: src/async/tasks.md:3
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rustì˜ íƒœìŠ¤í¬(ì‘ì—…) ì‹œìŠ¤í…œì€ ê²½ëŸ‰ ìŠ¤ë ˆë”©ì˜ í•œ ì¢…ë¥˜ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/tasks.md:5
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"í•˜ë‚˜ì˜ ì‘ì—…ì—ëŠ”, ì‹¤í–‰ìê°€ ì´ ì‘ì—…ì„ ì§„í–‰í•˜ê¸° ìœ„í•´ ê³„ì† í´ë§í•˜ëŠ”, ìµœìƒìœ„ "
"futureê°€ í•œ ê°œ ìˆìŠµë‹ˆë‹¤. ì´ futureì—ëŠ” `poll` ë©”ì„œë“œê°€ í´ë§í•˜ëŠ” ì¤‘ì²©ëœ future"
"ê°€ í•œ ê°œ ì´ìƒ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ì¤‘ì²©ëœ futureëŠ” ì¼ë°˜ì ì¸ í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤"
"íƒí•˜ê³  ë¹„ìŠ·í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. í•œ ì‘ì—… ì•ˆì—ì„œ ì—¬ëŸ¬ ìì‹ futureë“¤ì„ í´ë§í•˜ë©´, íƒ€"
"ì´ë¨¸ë¥¼ ì¼œëŠ” ê²ƒê³¼ ì–´ë–¤ I/Oì‘ì—…ì„ ë™ì‹œì— ìˆ˜í–‰ì‹œí‚¨ í›„ íƒ€ì´ë¨¸ì™€ I/O ì¤‘ ë¨¼ì € ëë‚˜"
"ëŠ” ê²ƒì„ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒê³¼ ê°™ì€ë™ì‹œì„±ë„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/tasks.md:16
msgid "\"127.0.0.1:0\""
msgstr ""

#: src/async/tasks.md:17
msgid "\"listening on port {}\""
msgstr ""

#: src/async/tasks.md:22
msgid "\"connection from {addr:?}\""
msgstr ""

#: src/async/tasks.md:25
msgid "b\"Who are you?\\n\""
msgstr ""

#: src/async/tasks.md:25 src/async/tasks.md:28 src/async/tasks.md:31
msgid "\"socket error\""
msgstr ""

#: src/async/tasks.md:30
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr ""

#: src/async/tasks.md:39 src/async/control-flow/join.md:36
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""
"ì´ ì˜ˆì œë¥¼, ë¡œì»¬ ì»´í“¨í„°ì— ë§Œë“¤ì–´ ë‘” `src/main.rs`ì— ë³µì‚¬í•˜ê³  ê±°ê¸°ì—ì„œ ì‹¤í–‰í•˜ì„¸"
"ìš”."

#: src/async/tasks.md:41
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""

#: src/async/tasks.md:45
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"ìˆ˜ê°•ìƒë“¤ì—ê²Œ ì´ ì„œë²„ì— ëª‡ ê°œì˜ í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ë˜ë©´ ì´ ì„œë²„ì˜ ìƒíƒœê°€ ì–´ë–»ê²Œ "
"ë³€í• ì§€ ê·¸ë¦¼ì„ ê·¸ë ¤ë³´ë„ë¡ í•˜ì„¸ìš”. ì–´ë–¤ íƒœìŠ¤í¬ë“¤ì´ ìˆëŠ”ì§€, ì´ íƒœìŠ¤í¬ë“¤ì˜ Future"
"ëŠ” ì–´ë–¤ ìƒíƒœì— ìˆëŠ”ì§€ ë¬¼ì–´ë´…ë‹ˆë‹¤."

#: src/async/tasks.md:48
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"`async` ë¸”ë¡ì„ ì²˜ìŒ ë³´ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ í´ë¡œì €ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ì¸ìë¥¼ ë°›ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. ë¦¬í„´ íƒ€ì…ì€ `async fn`ê³¼ ë¹„ìŠ·í•œ Futureì…ë‹ˆë‹¤. "

#: src/async/tasks.md:52
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""
"Async ë¸”ë¡ì„ í•¨ìˆ˜ë¡œ ë¦¬íŒ©í„°ë§í•˜ê³  `?`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ê°œì„ í•´ ë´…ì‹œë‹¤."

#: src/async/channels.md:3
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""
"ì—¬ëŸ¬ í¬ë ˆì´íŠ¸ì—ì„œ ë¹„ë™ê¸° ì±„ë„ì„ ì§€ì›í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `tokio`ì—ì„œëŠ” ì•„ë˜ì™€ ê°™"
"ì´í•©ë‹ˆë‹¤."

#: src/async/channels.md:13
msgid "\"Received {count} pings so far.\""
msgstr ""

#: src/async/channels.md:16
msgid "\"ping_handler complete\""
msgstr ""

#: src/async/channels.md:24
msgid "\"Failed to send ping.\""
msgstr ""

#: src/async/channels.md:25
msgid "\"Sent {} pings so far.\""
msgstr ""

#: src/async/channels.md:29
msgid "\"Something went wrong in ping handler task.\""
msgstr ""

#: src/async/channels.md:35
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr "ì±„ë„ í¬ê¸°ë¥¼ `3`ìœ¼ë¡œ ë³€ê²½í•˜ê³  ë™ì‘ì´ ì–´ë–»ê²Œ ë°”ë€ŒëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."

#: src/async/channels.md:37
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"ë¹„ë™ê¸° ì±„ë„ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ëŠ” [ì˜¤ì „ ê³¼ì •](concurrency/channels.md)"
"ì—ì„œ ë°°ìš´ `sync` ì±„ë„ê³¼ ë¹„ìŠ·í•©ë‹ˆë‹¤."

#: src/async/channels.md:40
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr ""
"`std::mem::drop` í˜¸ì¶œí•˜ëŠ” ì¤„ì„ ì‚­ì œí•´ ë³´ì„¸ìš”. ì–´ë–¤ ê²°ê³¼ê°€ ë‚˜íƒ€ë‚˜ë‚˜ìš”? ì´ìœ ê°€ "
"ë¬´ì—‡ì¸ê°€ìš”?"

#: src/async/channels.md:42
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"[Flume](https://docs.rs/flume/latest/flume/) í¬ë ˆì´íŠ¸ì—ëŠ” `sync`ì™€ `async`, "
"`send`ì™€ `recv`ë¥¼ ëª¨ë‘ êµ¬í˜„í•˜ëŠ” ì±„ë„ì´ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ IOì™€ CPU ì²˜ë¦¬ ì‘ì—…ì´ "
"ë§ì€ ë³µì¡í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬í˜„í•  ë•Œ ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤."

#: src/async/channels.md:46
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"`async` ì±„ë„ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì¢‹ì€ ì´ìœ ëŠ” ì´ë¥¼ ë‹¤ë¥¸ `future`ì™€ ê²°í•©í•˜ì—¬ ë³µ"
"ì¡í•œ ì œì–´ íë¦„ì„ ë§Œë“¤ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/async/control-flow.md:1
#, fuzzy
msgid "Futures Control Flow"
msgstr "íë¦„ ì œì–´"

#: src/async/control-flow.md:3
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""
"Futureë“¤ì„ ê²°í•©í•˜ì—¬ ê³„ì‚° ê³¼ì •ì„ ë™ì‹œì„±ì´ ìˆëŠ” í”Œë¡œìš° ê·¸ë˜í”„ í˜•íƒœë¡œ ëª¨ë¸ë§ í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•ì„œ ë°°ìš´,  ê° íƒœìŠ¤í¬ê°€ ë…ë¦½ì ìœ¼ë¡œ ìˆ˜í–‰ë˜ë„ë¡ í•˜ëŠ” ê²ƒë„ Futureë“¤"
"ì„ ê²°í•©í•˜ëŠ” í•œ ë°©ë²•ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/control-flow.md:6
msgid "[Join](control-flow/join.md)"
msgstr "[Join](control-flow/join.md)"

#: src/async/control-flow.md:7
msgid "[Select](control-flow/select.md)"
msgstr "[Select](control-flow/select.md)"

#: src/async/control-flow/join.md:3
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"Join ì—°ì‚°ì€ ëª¨ë“  futureê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„, ê° futureì˜ ê²°ê³¼ê°’ì„ ë‹´ì€ "
"ì»¬ë ‰ì…˜ì„ ë¦¬í„´í•©ë‹ˆë‹¤. ì´ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ `Promise.all`ì´ë‚˜ íŒŒì´ì¬ì˜ `asyncio."
"gather`ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤."

#: src/async/control-flow/join.md:21
msgid "\"https://google.com\""
msgstr ""

#: src/async/control-flow/join.md:22
msgid "\"https://httpbin.org/ip\""
msgstr ""

#: src/async/control-flow/join.md:23
msgid "\"https://play.rust-lang.org/\""
msgstr ""

#: src/async/control-flow/join.md:24
msgid "\"BAD_URL\""
msgstr ""

#: src/async/control-flow/join.md:38
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§€ëŠ” ì—¬ëŸ¬ ì—¬ëŸ¬ futuresë“¤ì„ joiní•˜ê³ ì í•  ê²½ìš° `std::"
"future::join!`ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ futuresê°€ ëª‡ ê°œ"
"ë‚˜ ìˆì„ì§€ ì»´íŒŒì¼ í•  ë•Œ ì•Œì•„ì•¼ í•œë‹¤ëŠ” ì ì„ ì£¼ì˜í•˜ì„¸ìš”. ì´ ë§¤í¬ë¡œëŠ” ì§€ê¸ˆì€ "
"'futures' í¬ë ˆì´íŠ¸ì— ìˆìœ¼ë©° ê³§ ì•ˆì •í™” ë˜ì–´ `std::future`ì— í¬í•¨ë  ì˜ˆì •ì…ë‹ˆë‹¤."

#: src/async/control-flow/join.md:42
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"'join'ì˜ ìœ„í—˜ì„±ì€ futuresë“¤ ì¤‘ í•˜ë‚˜ê°€ ì˜ì˜ ëë‚˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. "
"ê·¸ëŸ¬ë©´ í”„ë¡œê·¸ë¨ì´ ë”ì´ìƒ ì§„í–‰ì„ ëª»í•˜ê³  ë©ˆì¶°ìˆì„(stall) ìˆ˜ ìˆìŠµë‹ˆë‹¤. "

#: src/async/control-flow/join.md:45
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"`join_all`ì„ `join!`ê³¼ ê²°í•©í•˜ì—¬ http ì„œë¹„ìŠ¤ì™€ ë°ì´í„°ë² ì´ìŠ¤ì— ëŒ€í•œ ëª¨ë“  ìš”ì²­ë“¤"
"ì„ í•œêº¼ë²ˆì— ì§„í–‰ì‹œí‚¬ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. `futures::join!`ì„ ì‚¬ìš©í•˜ì—¬ `tokio::"
"time::sleep`ì„ futureì— ì¶”ê°€í•´ ë³´ì„¸ìš”. ì´ê±´ íƒ€ì„ì•„ì›ƒì„ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì•„ë‹˜ì„ "
"ì£¼ì˜í•˜ì„¸ìš”.  ì‹¤ì œë¡œ, íƒ€ì„ì•„ì›ƒì€ ë‹¤ìŒ ì¥ì—ì„œ ì„¤ëª…í•˜ëŠ” `select!`ë¥¼ ì‚¬ìš©í•´ì„œ êµ¬"
"í˜„í•´ì•¼ í•©ë‹ˆë‹¤.  ì—¬ê¸°ì„œëŠ” `tokio::time::sleep`ì„ ì‚¬ìš©í•œ ê²ƒì€ ë‹¨ìˆœíˆ `join!`ì˜ "
"ë™ì‘ì„ ì„¤ëª…í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤."

#: src/async/control-flow/select.md:3
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"Select ì—°ì‚°ì€ ì—¬ëŸ¬ futureë“¤ ëª¨ë‘ì— ëŒ€í•´ì„œ ì¤€ë¹„ë  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¬ë‹¤ê°€, ê·¸ ì¤‘ ì–´"
"ë–¤ í•œ futureê°€ ìµœì´ˆë¡œ ì¤€ë¹„ ìƒíƒœê°€ ë˜ë©´ í•´ë‹¹ futureì˜ ê²°ê³¼ê°’ì„ ë¦¬í„´í•©ë‹ˆë‹¤.  ì´"
"ê²ƒì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œì˜ `Promise.race`ì™€ ë¹„ìŠ·í•©ë‹ˆë‹¤. íŒŒì´ì¬ì—ì„œë¼ë©´ `asyncio."
"wait(task_set, return_when=asyncio.FIRST_COMPLETED)`ê°€ í•˜ëŠ” ë™ì‘ê³¼ ë¹„ìŠ·í•©ë‹ˆ"
"ë‹¤."

#: src/async/control-flow/select.md:8
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When the `future` is "
"ready, the `statement` is executed with the variables in `pattern` bound to "
"the `future`'s result."
msgstr ""
"`select!` ì•ˆì—ëŠ”, `match`ë¬¸ê³¼ ë¹„ìŠ·í•˜ê²Œ, `pattern = future => statement` í˜•íƒœ"
"ì˜ ë¸Œëœì¹˜(arm) ë“¤ì´ ìˆìŠµë‹ˆë‹¤. ì–´ë–¤ 'future'ê°€ ì§„í–‰ ê°€ëŠ¥ ìƒíƒœê°€ ë˜ë©´ 'ê·¸ "
"`future`ì˜ ê²°ê³¼ê°’ì´ `pattern`ìœ¼ë¡œ ë°”ì¸ë”© ë˜ë©°, ê·¸ ìƒíƒœì—ì„œ \\`statement'ê°€ ìˆ˜"
"í–‰ë©ë‹ˆë‹¤."

#: src/async/control-flow/select.md:39
msgid "\"Felix\""
msgstr ""

#: src/async/control-flow/select.md:39
msgid "\"Failed to send cat.\""
msgstr ""

#: src/async/control-flow/select.md:43
msgid "\"Rex\""
msgstr ""

#: src/async/control-flow/select.md:43
msgid "\"Failed to send dog.\""
msgstr ""

#: src/async/control-flow/select.md:48
msgid "\"Failed to receive winner\""
msgstr ""

#: src/async/control-flow/select.md:50
msgid "\"Winner is {winner:?}\""
msgstr ""

#: src/async/control-flow/select.md:56
#, fuzzy
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"ì´ ì˜ˆì œì—ì„œëŠ” ê³ ì–‘ì´ì™€ ê°œë¥¼ ê²½ì£¼ì‹œì¼°ìŠµë‹ˆë‹¤(ë™ì‹œì— ì‹œì‘ì‹œí‚¨ í›„, ë‘˜ ì¤‘ ë¨¼ì € ë"
"ë‚˜ëŠ” ìª½ì´ ì´ê¹€). `first_animal_to_finish_race`í•¨ìˆ˜ëŠ” ë‘ ì±„ë„ ëª¨ë‘ì— ê·€ê¸°ìš¸ì´"
"ê³ (listení•˜ê³ ) ìˆë‹¤ê°€, ë©”ì‹œì§€ê°€ ë¨¼ì € ë„ì°©í•œ ì±„ë„ì„ ì„ íƒí•©ë‹ˆë‹¤. ê°œëŠ” 50msë§Œì— "
"ì‘ì—…ì„ ëë‚´ê³  ê³ ì–‘ì´ëŠ” 500msê°€ ê±¸ë¦¬ê¸° ë•Œë¬¸ì—, ê°œê°€ ì´ê¹ë‹ˆë‹¤."

#: src/async/control-flow/select.md:61
#, fuzzy
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"ì´ ì˜ˆì œì—ì„œëŠ” `oneshot` ì±„ë„ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì¢‹ì€ ë””ìì¸ ì…ë‹ˆë‹¤. ê° ì±„ë„"
"ì´ í•œ ë²ˆì˜ `send`ë§Œ ìˆ˜ì‹ í•´ì•¼ í•˜ëŠ” ê²ƒì´ ë³´ì¥ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/async/control-flow/select.md:64
#, fuzzy
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""
"ì´ ê²½ì£¼ì— íƒ€ì„ì•„ì›ƒì„ ì¶”ê°€í•´ì„œ, ì„œë¡œ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ futuresë“¤ì„ ë™ì‹œì— `select`"
"í•  ìˆ˜ ìˆìŒì„ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/async/control-flow/select.md:67
#, fuzzy
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"`select!`ëŠ” ë§¤ì¹­ë˜ì§€ ì•Šì€ ë‹¤ë¥¸ ëª¨ë“  ë¸Œëœì¹˜ì— ëŒ€í•´ dropì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ë”°ë¼ì„œ "
"ê²½ìŸì—ì„œ ì§„ ëª¨ë“  futureë“¤ì€  ì·¨ì†Œ(cancel) ë©ë‹ˆë‹¤. `select!`ë¥¼ ì‹¤í–‰í•  ë•Œë§ˆë‹¤ "
"ìƒˆë¡œìš´ futuresê°€ ë§Œë“¤ì–´ì§€ëŠ” ê²½ìš°ë¼ë©´, ì´ëŸ¬í•œ ì ì´ ë§¤ìš° í¸í•˜ê²Œ ëŠê»´ì§ˆ ê²ƒì…ë‹ˆ"
"ë‹¤. Futureê°€ ì·¨ì†Œë˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´ futureë¥¼ ì§ì ‘ ì „ë‹¬í•˜ëŠ” ëŒ€ì‹  `&mut "
"future`ë¥¼ ì „ë‹¬í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.  í•˜ì§€ë§Œ ì´ë ‡ê²Œ í•˜ë©´ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤ (ì™œ ê·¸ëŸ°ì§€ëŠ” `Pin`ì„¤ëª…í•  ë•Œ ìì„¸íˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤)."

#: src/async/control-flow/select.md:70
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""

#: src/async/pitfalls.md:1
msgid "Pitfalls of async/await"
msgstr "async/awaitì—ì„œ ì£¼ì˜í•´ì•¼í•  í•¨ì •"

#: src/async/pitfalls.md:3
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"Asyncì™€ awaitëŠ” ë™ì‹œ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•œ í¸ë¦¬í•˜ê³  íš¨ìœ¨ì ì¸ ì¶”ìƒí™”ë¥¼ ì œê³µ"
"í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ Rustì˜ async/await ëª¨ë¸ì—ë„ ë¬¸ì œëŠ” ìˆìŠµë‹ˆë‹¤. ì´ ì¥ì—ì„œ ëª‡ ê°€"
"ì§€ ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/async/pitfalls.md:7
#, fuzzy
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr "[ì‹¤í–‰ì ì°¨ë‹¨](pitfalls/blocking-executor.md)"

#: src/async/pitfalls.md:8
#, fuzzy
msgid "[Pin](pitfalls/pin.md)"
msgstr "[ê³ ì •](pitfalls/pin.md)"

#: src/async/pitfalls.md:9
#, fuzzy
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr "[ë¹„ë™ê¸° íŠ¸ë ˆì‡](pitfall/async-traits.md)"

#: src/async/pitfalls.md:10
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:1
msgid "Blocking the executor"
msgstr "ì‹¤í–‰ì(executor)ë¥¼ ë¸”ë¡ì‹œí‚´"

#: src/async/pitfalls/blocking-executor.md:3
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ë¹„ë™ê¸° ëŸ°íƒ€ì„ì€ IO ì‘ì—…ë§Œ ë™ì‹œì— ì‹¤í–‰ë˜ë„ë¡ í—ˆìš©í•©ë‹ˆë‹¤. ì¦‰, CPUë¥¼ ë¸”"
"ëŸ­í•˜ëŠ” íƒœìŠ¤í¬ê°€ ìˆëŠ” ê²½ìš°, ì´ëŠ” ì‹¤í–‰ì(executor)ë¥¼ ë¸”ëŸ­í•˜ê²Œ ë˜ë©°, ê·¸ ê²°ê³¼ë¡œ "
"ë‹¤ë¥¸ íƒœìŠ¤í¬ê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê°„ë‹¨í•œ ë°©ë²•ì€, í•­ìƒ async"
"ë¥¼ ì§€ì›í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/async/pitfalls/blocking-executor.md:14
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr ""

#: src/async/pitfalls/blocking-executor.md:19
msgid "\"current_thread\""
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""
"ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì—¬ sleepë“¤ì´ ë™ì‹œì— ì§„í–‰ë˜ì§€ ì•Šê³  ìˆœì°¨ì ìœ¼ë¡œìœ¼ë¡œ ì§„í–‰ë˜ëŠ”ì§€ í™•ì¸"
"í•˜ì„¸ìš”."

#: src/async/pitfalls/blocking-executor.md:32
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"`flavor`ë¥¼ `\"current_thread\"` ë¡œ ì„¤ì •í•˜ë©´ ëª¨ë“  íƒœìŠ¤í¬ê°€ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œì—ì„œ "
"ìˆ˜í–‰ë©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë¬¸ì œ ìƒí™©ì´ ë” ë¶„ëª…íˆ ë“œëŸ¬ë‚©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ ë²„ê·¸ëŠ” ë©€"
"í‹°ìŠ¤ë ˆë“œì¸ ê²½ìš°ì—ë„ ì—¬ì „íˆ ì¡´ì¬í•©ë‹ˆë‹¤."

#: src/async/pitfalls/blocking-executor.md:36
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""
"`std::thread::sleep`ì„ `tokio::time::sleep`ìœ¼ë¡œ ë°”ê¾¸ê³  ê·¸ ê²°ê³¼ë¥¼ `await`í•´ ë³´"
"ì„¸ìš”."

#: src/async/pitfalls/blocking-executor.md:38
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"ë˜ ë‹¤ë¥¸ í•´ê²° ë°©ë²•ì€ `tokio::task::spawn_blocking`ì…ë‹ˆë‹¤. ì´ëŠ” ì‹¤ì œ ìŠ¤ë ˆë“œë¥¼ "
"ìƒì„±í•˜ê³ , ê·¸ ìŠ¤ë ˆë“œì— ëŒ€í•œ í•¸ë“¤ì„ futureë¡œ ë³€í™˜í•¨ìœ¼ë¡œì¨ ì‹¤í–‰ìê°€ ë¸”ë¡ë˜ëŠ” ê²ƒ"
"ì„ ë§‰ìŠµë‹ˆë‹¤."

#: src/async/pitfalls/blocking-executor.md:41
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"íƒœìŠ¤í¬ë¥¼ OS ìŠ¤ë ˆë“œë¼ê³  ìƒê°í•˜ë©´ ì•ˆ ë©ë‹ˆë‹¤. íƒœìŠ¤í¬ì™€ OSìŠ¤ë ˆë“œëŠ” ì¼ëŒ€ì¼ ë§¤í•‘ ê´€"
"ê³„ì— ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ì‹¤í–‰ìëŠ” í•˜ë‚˜ì˜ OS ìŠ¤ë ˆë“œì—ì„œ ìµœëŒ€í•œ ë§ì€ íƒœìŠ¤í¬"
"ë¥¼ ìˆ˜í–‰í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ì ì€ FFIë¥¼ í†µí•´ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ìƒí˜¸ì‘ìš©"
"í•  ë•Œ íŠ¹íˆ ë¬¸ì œê°€ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•´ë‹¹ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ìŠ¤ë ˆë“œ ë¡œì»¬ ì €ì¥ì†Œë¥¼ "
"ì´ìš©í•˜ê±°ë‚˜ íŠ¹ì • OS ìŠ¤ë ˆë“œì— ë§¤í•‘ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: CUDA). ì´ëŸ¬í•œ ìƒí™©ì—ì„œëŠ” "
"`tokio::task::spawn_blocking`ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/async/pitfalls/blocking-executor.md:47
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"ë™ê¸°í™” ë®¤í…ìŠ¤ë¥¼ ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì„¸ìš”. `.await` ìœ„ì— ë®¤í…ìŠ¤ë¥¼ ì ìš©í•˜ë©´ ë‹¤ë¥¸ ì‘"
"ì—…ì´ ì°¨ë‹¨ë  ìˆ˜ ìˆìœ¼ë©° í•´ë‹¹ ì‘ì—…ì€ ë™ì¼í•œ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ ì¤‘ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/async/pitfalls/pin.md:3
msgid ""
"When you await a future, all local variables (that would ordinarily be "
"stored on a stack frame) are instead stored in the Future for the current "
"async block. If your future has pointers to data on the stack, those "
"pointers might get invalidated. This is unsafe."
msgstr ""
"Futureì— ëŒ€í•´ `await`ë¥¼ í˜¸ì¶œí•˜ì—¬ ê·¸ futureê°€ ì¤€ë¹„ë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦´ ë•Œ, ëª¨ë“  ë¡œì»¬ "
"ë³€ìˆ˜(ì¼ë°˜ì ìœ¼ë¡œ ìŠ¤íƒ í”„ë ˆì„ì— ì €ì¥ë¨)ëŠ” ê·¸ futureê°ì²´ ì•ˆì— ì €ì¥ë©ë‹ˆë‹¤.  ë§Œì•½ "
"ê·¸ futureì— ìŠ¤íƒì— ìˆëŠ” ì–´ë–¤ ë°ì´í„°ë¡œì˜ í¬ì¸í„°ê°€ ìˆìœ¼ë©´ ì´ëŸ¬í•œ í¬ì¸í„°ëŠ” ì˜¬ë°”"
"ë¥´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/async/pitfalls/pin.md:8
#, fuzzy
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't "
"change. That is why we need to \"pin\" futures. Using the same future "
"repeatedly in a `select!` often leads to issues with pinned values."
msgstr ""
"ë”°ë¼ì„œ futureê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œê°€ ë³€ê²½ë˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤. ì´ê²ƒì´ futureë¥¼ "
"`pin`(ê³ ì •)í•´ì•¼ í•˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤. `select!`ì—ì„œ ë™ì¼í•œ futureë¥¼ ë°˜ë³µì ìœ¼ë¡œ ì‚¬"
"ìš©í•˜ë©´ ê³ ì • ê°’ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤."

#: src/async/pitfalls/pin.md:16
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""

#: src/async/pitfalls/pin.md:24
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr ""

#: src/async/pitfalls/pin.md:31
msgid "// Pretend to work.\n"
msgstr ""

#: src/async/pitfalls/pin.md:34
msgid "\"failed to send response\""
msgstr ""

#: src/async/pitfalls/pin.md:37
msgid "// TODO: report number of iterations every 100ms\n"
msgstr ""

#: src/async/pitfalls/pin.md:41
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr ""

#: src/async/pitfalls/pin.md:48
msgid "\"failed to send on work queue\""
msgstr ""

#: src/async/pitfalls/pin.md:49
msgid "\"failed waiting for response\""
msgstr ""

#: src/async/pitfalls/pin.md:58
msgid "\"work result for iteration {i}: {resp}\""
msgstr ""

#: src/async/pitfalls/pin.md:65
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""
"ìœ„ì—ì„œ ì†Œê°œí•œ ê²ƒì€ ì•¡í„°(actor) íŒ¨í„´ì˜ í•œ ì˜ˆë¼ê³  ë´ë„ ë¬´ë°©í•©ë‹ˆë‹¤. ì•¡í„°ëŠ” ì¼ë°˜"
"ì ìœ¼ë¡œ ë£¨í”„ ì•ˆì—ì„œ `select!`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤."

#: src/async/pitfalls/pin.md:68
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr "ì´ì „ ê°•ì˜ ëª‡ ê°œì˜ ë‚´ìš©ì„ ìš”ì•½í•œ ê²ƒì´ê¸° ë•Œë¬¸ì— ì²œì²œíˆ ì‚´í´ë³´ì„¸ìš”."

#: src/async/pitfalls/pin.md:71
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"`_ = sleep(Duration::from_millis(100)) => { println!(..) }`ì„ `select!`ì— ì¶”"
"ê°€í•´ ë³´ì„¸ìš”. ì´ ì‘ì—…ì€ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì™œ ê·¸ëŸ´ê¹Œìš”?"

#: src/async/pitfalls/pin.md:74
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""
"ëŒ€ì‹ , í•´ë‹¹ futureê°€ í¬í•¨ëœ `timeout_fut`ë¥¼ `loop` ì™¸ë¶€ì— ì¶”ê°€í•´ ë³´ì„¸ìš”."

#: src/async/pitfalls/pin.md:85
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"ì—¬ì „íˆ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ë¥¼ ë”°ë¼ `select!`ì˜ `timeout_fut`ì— "
"`&mut`ë¥¼ ì¶”ê°€í•˜ì—¬ Move ì‹œë©˜í‹± ê´€ë ¨í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê³  `Box::pin`ì„ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/async/pitfalls/pin.md:99
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"ì´ëŠ” ì»´íŒŒì¼ì€ ë˜ì§€ë§Œ íƒ€ì„ ì•„ì›ƒì´ ë˜ë©´ ë§¤ë²ˆ ë°˜ë³µí•  ë•Œ ë§ˆë‹¤ `Poll::Ready`ê°€ ë©"
"ë‹ˆë‹¤(ìœµí•©ëœ futureê°€ ë„ì›€ì´ ë  ìˆ˜ ìˆìŒ). íƒ€ì„ ì•„ì›ƒ ë  ë•Œë§ˆë‹¤ `timeout_fut`ë¥¼ "
"ë¦¬ì…‹í•˜ë„ë¡ ìˆ˜ì •í•˜ì„¸ìš”."

#: src/async/pitfalls/pin.md:103
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"BoxëŠ” í™ì— í• ë‹¹í•©ë‹ˆë‹¤. ê²½ìš°ì— ë”°ë¼ `std::pin::pin!`(ìµœê·¼ì—ì•¼ ì•ˆì •í™”ë˜ì—ˆìœ¼ë©° "
"ì´ì „ ì½”ë“œëŠ” `tokio::pin!`ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ)ë„ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ì´ëŠ” ì¬"
"í• ë‹¹ëœ futureì— ì‚¬ìš©í•˜ê¸°ê°€ ì–´ë µìŠµë‹ˆë‹¤."

#: src/async/pitfalls/pin.md:107
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"ë˜ ë‹¤ë¥¸ ë°©ë²•ì€ `pin`ì„ ì•„ì˜ˆ ì‚¬ìš©í•˜ì§€ ì•Šê³  100msë§ˆë‹¤ `oneshot` ì±„ë„ì— ì „ì†¡í•  "
"ë‹¤ë¥¸ ì‘ì—…ì„ ìƒì„±í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/async/pitfalls/async-traits.md:3
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"íŠ¸ë ˆì‡ì— async ë©”ì†Œë“œë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì€ ì•„ì§ ì•ˆì •í™” ë²„ì „ ì±„ë„ì—ì„œ ì§€ì›ë˜ì§€ ì•ŠìŠµ"
"ë‹ˆë‹¤([ì‹¤í—˜ìš© ê¸°ëŠ¥ì€ nightlyì— ì¡´ì¬í•˜ë©° ì¡°ë§Œê°„ ì•ˆì •í™” ë  ê²ƒì…ë‹ˆë‹¤](https://"
"blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html))."

#: src/async/pitfalls/async-traits.md:6
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"í¬ë ˆì´íŠ¸ [async_trait](https://docs.rs/async-trait/latest/async_trait/)ì€ ë§¤"
"í¬ë¡œë¥¼ í†µí•œ í•´ê²° ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/async/pitfalls/async-traits.md:35
msgid "\"running all sleepers..\""
msgstr ""

#: src/async/pitfalls/async-traits.md:39
msgid "\"slept for {}ms\""
msgstr ""

#: src/async/pitfalls/async-traits.md:56
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait`ì€ ì‚¬ìš©í•˜ê¸° ì‰½ì§€ë§Œ ì´ë¥¼ ìœ„í•´ í™ì— ë©”ëª¨ë¦¬ë¥¼  í• ë‹¹í•œë‹¤ëŠ” ì ì— ìœ ì˜"
"í•˜ì„¸ìš”. ì´ í™ í• ë‹¹ì—ëŠ” ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œê°€ ìˆìŠµë‹ˆë‹¤."

#: src/async/pitfalls/async-traits.md:59
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"`async trait` ë¥¼ ì–¸ì–´ ì°¨ì›ì—ì„œ ì§€ì›í•˜ëŠ” ê²ƒê³¼ ê´€ë ¨ëœ ë¬¸ì œëŠ” ë§¤ìš° ì „ë¬¸ì ì¸ í† í”½"
"ì´ë©° ë”°ë¼ì„œ ì´ ê°•ì˜ì—ì„œ ë‹¤ë£° ë‚´ìš©ì€ ì•„ë‹™ë‹ˆë‹¤. [ì´ ê²Œì‹œë¬¼](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/)ì— ì´ì— ê´€í•œ ë‹ˆì½” ë§ˆì‚¬í‚¤ìŠ¤ì˜ ì¢‹ì€ ì„¤ëª…ì´ ìˆìœ¼ë¯€ë¡œ ê´€ì‹¬ì´ ìˆë‹¤ë©´ ì°¸ê³ í•˜"
"ì„¸ìš”."

#: src/async/pitfalls/async-traits.md:65
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"ì„ì˜ì˜ ì‹œê°„ ë™ì•ˆ sleep í•˜ëŠ” ìƒˆë¡œìš´ sleeper êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ Vecì— ì¶”ê°€í•´ ë³´ì„¸"
"ìš”."

#: src/async/pitfalls/cancellation.md:3
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""

#: src/async/pitfalls/cancellation.md:35
#, fuzzy
msgid "\"not UTF-8\""
msgstr "UTF-8"

#: src/async/pitfalls/cancellation.md:51
msgid "\"hi\\nthere\\n\""
msgstr ""

#: src/async/pitfalls/cancellation.md:57
msgid "\"tick!\""
msgstr ""

#: src/async/pitfalls/cancellation.md:72
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""

#: src/async/pitfalls/cancellation.md:75
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""

#: src/async/pitfalls/cancellation.md:78
msgid "The example loses parts of the string."
msgstr ""

#: src/async/pitfalls/cancellation.md:80
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""

#: src/async/pitfalls/cancellation.md:83
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr ""

#: src/async/pitfalls/cancellation.md:97
msgid "// prefix buf and bytes with self.\n"
msgstr ""

#: src/async/pitfalls/cancellation.md:106
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""

#: src/async/pitfalls/cancellation.md:110
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""

#: src/async/pitfalls/cancellation.md:113
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""

#: src/exercises/concurrency/afternoon.md:3
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""

#: src/exercises/concurrency/afternoon.md:8
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:1
#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "ì‹ì‚¬í•˜ëŠ” ì² í•™ìë“¤"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"ì´ë²ˆ í›ˆë ¨ì—ì„œëŠ” [ì¹´ê³  ì„¤ì¹˜í•˜ê¸°](../../cargo/running-locally.md)ê°€ í•„ìš”í•©ë‹ˆ"
"ë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ë³µì‚¬í•´ì„œ `src/main.rs`ì— ë¶™ì—¬ë†“ê³  ë¹ˆ ë¶€ë¶„ì„ ì±„ìš°ê³ , `cargo "
"run` ì»¤ë§¨ë“œë¡œ í…ŒìŠ¤íŠ¸ í•´ì„œ êµì°©ìƒíƒœ(ë°ë“œë½)ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:"

#: src/exercises/concurrency/dining-philosophers-async.md:52
#: src/exercises/concurrency/solutions-afternoon.md:78
msgid "// Make them think and eat\n"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:58
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:63
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:73
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:78
msgid "Can you make your implementation single-threaded?"
msgstr ""

#: src/exercises/concurrency/chat-app.md:3
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""

#: src/exercises/concurrency/chat-app.md:9
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""

#: src/exercises/concurrency/chat-app.md:12
msgid "Create a new Cargo project and add the following dependencies:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:14
msgid "_Cargo.toml_:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:18
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.0.0\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.5.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:31
msgid "The required APIs"
msgstr ""

#: src/exercises/concurrency/chat-app.md:33
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""

#: src/exercises/concurrency/chat-app.md:37
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""

#: src/exercises/concurrency/chat-app.md:39
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""

#: src/exercises/concurrency/chat-app.md:41
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""

#: src/exercises/concurrency/chat-app.md:43
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""

#: src/exercises/concurrency/chat-app.md:45
#, fuzzy
msgid "Two binaries"
msgstr "ëŸ¬ìŠ¤íŠ¸ ë°”ì´ë„ˆë¦¬"

#: src/exercises/concurrency/chat-app.md:47
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""

#: src/exercises/concurrency/chat-app.md:54
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""

#: src/exercises/concurrency/chat-app.md:58
#: src/exercises/concurrency/solutions-afternoon.md:99
#, fuzzy
msgid "_src/bin/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/exercises/concurrency/chat-app.md:77
#: src/exercises/concurrency/chat-app.md:124
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr ""

#: src/exercises/concurrency/chat-app.md:85
#: src/exercises/concurrency/solutions-afternoon.md:147
msgid "\"127.0.0.1:2000\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:86
#: src/exercises/concurrency/solutions-afternoon.md:148
msgid "\"listening on port 2000\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:90
#: src/exercises/concurrency/solutions-afternoon.md:152
msgid "\"New connection from {addr:?}\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:93
#: src/exercises/concurrency/solutions-afternoon.md:155
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr ""

#: src/exercises/concurrency/chat-app.md:102
#: src/exercises/concurrency/solutions-afternoon.md:164
#, fuzzy
msgid "_src/bin/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/exercises/concurrency/chat-app.md:116
#: src/exercises/concurrency/solutions-afternoon.md:176
msgid "\"ws://127.0.0.1:2000\""
msgstr ""

#: src/exercises/concurrency/chat-app.md:129
#, fuzzy
msgid "Running the binaries"
msgstr "ê°•ì˜ ì§„í–‰ ë°©ì‹"

#: src/exercises/concurrency/chat-app.md:131
#, fuzzy
msgid "Run the server with:"
msgstr "ì•„ë˜ ëª…ë ¹ì–´ë¡œ ì˜ˆì œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì„¸ìš”."

#: src/exercises/concurrency/chat-app.md:137
#, fuzzy
msgid "and the client with:"
msgstr "ì•„ë˜ ëª…ë ¹ì–´ë¡œ ì˜ˆì œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì„¸ìš”."

#: src/exercises/concurrency/chat-app.md:145
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr ""

#: src/exercises/concurrency/chat-app.md:146
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""

#: src/exercises/concurrency/chat-app.md:149
msgid "Complete the main function in `src/bin/client.rs`."
msgstr ""

#: src/exercises/concurrency/chat-app.md:150
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""

#: src/exercises/concurrency/chat-app.md:154
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "Concurrency Afternoon Exercise"
msgstr "1ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#: src/exercises/concurrency/solutions-afternoon.md:5
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:33
msgid ""
"// Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:41
msgid "// The locks are dropped here\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:61
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:75
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:90
msgid "\"Here is a thought: {thought}\""
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:97
msgid "([back to exercise](chat-app.md))"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:116
msgid "\"Welcome to chat! Type a message\""
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:119
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:128
msgid "\"From client {addr:?} {text:?}\""
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:183
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:190
msgid "\"From server: {}\""
msgstr ""

#: src/thanks.md:3
msgid ""
"_Thank you for taking Comprehensive Rust ğŸ¦€!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"Comprehensive Rust ğŸ¦€ë¥¼ ì´ìš©í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤. ì¦ê²ê³  ìœ ìµí•œ ì‹œê°„ì´ì—ˆê¸°ë¥¼ "
"ë°”ëë‹ˆë‹¤."

#: src/thanks.md:6
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"ê°•ì˜ê°€ ì™„ë²½í•˜ì§„ ì•Šìœ¼ë‹ˆ ì‹¤ìˆ˜ë‚˜ ê°œì„ ì ì´ ìˆë‹¤ë©´ ì–¸ì œë“ ì§€ [ê¹ƒí—ˆë¸Œ](https://"
"github.com/google/comprehensive-rust/discussions)ë¡œ ì—°ë½ì£¼ì„¸ìš”."

#: src/glossary.md:3
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""

#: src/glossary.md:30
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""

#: src/glossary.md:32
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""

#: src/glossary.md:34
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""

#: src/glossary.md:37
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""

#: src/glossary.md:39
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""

#: src/glossary.md:41
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""

#: src/glossary.md:43
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""

#: src/glossary.md:45
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""

#: src/glossary.md:48
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""

#: src/glossary.md:50
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""

#: src/glossary.md:52
msgid ""
"Comprehensive Rust ğŸ¦€:  \n"
"The courses here are jointly called Comprehensive Rust ğŸ¦€."
msgstr ""

#: src/glossary.md:54
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""

#: src/glossary.md:56
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr ""

#: src/glossary.md:58
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""

#: src/glossary.md:60
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""

#: src/glossary.md:63
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""

#: src/glossary.md:65
msgid ""
"enumeration:  \n"
"A data type that consists of named constant values."
msgstr ""

#: src/glossary.md:67
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""

#: src/glossary.md:69
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""

#: src/glossary.md:72
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""

#: src/glossary.md:74
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""

#: src/glossary.md:76
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""

#: src/glossary.md:79
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""

#: src/glossary.md:82
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""

#: src/glossary.md:84
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""

#: src/glossary.md:87
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""

#: src/glossary.md:90
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""

#: src/glossary.md:92
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""

#: src/glossary.md:96
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""

#: src/glossary.md:98
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""

#: src/glossary.md:101
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""

#: src/glossary.md:104
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""

#: src/glossary.md:106
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""

#: src/glossary.md:109
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""

#: src/glossary.md:111
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""

#: src/glossary.md:114
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""

#: src/glossary.md:117
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""

#: src/glossary.md:120
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""

#: src/glossary.md:122
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""

#: src/glossary.md:125
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""

#: src/glossary.md:127
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""

#: src/glossary.md:130
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""

#: src/glossary.md:132
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""

#: src/glossary.md:135
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""

#: src/glossary.md:138
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""

#: src/glossary.md:140
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""

#: src/glossary.md:143
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 3 of this course."
msgstr ""

#: src/glossary.md:145
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr ""

#: src/glossary.md:147
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr ""

#: src/glossary.md:149
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""

#: src/glossary.md:152
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""

#: src/glossary.md:154
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""

#: src/glossary.md:156
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""

#: src/glossary.md:159
msgid ""
"string:  \n"
"A data type storing textual data. See [`String` vs `str`](basic-syntax/"
"string-slices.html) for more."
msgstr ""

#: src/glossary.md:162
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""

#: src/glossary.md:165
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""

#: src/glossary.md:168
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""

#: src/glossary.md:170
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""

#: src/glossary.md:173
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""

#: src/glossary.md:176
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""

#: src/glossary.md:179
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""

#: src/glossary.md:182
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""

#: src/glossary.md:185
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""

#: src/glossary.md:188
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""

#: src/glossary.md:190
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""

#: src/glossary.md:193
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe.html)."
msgstr ""

#: src/glossary.md:196
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""

#: src/other-resources.md:1
msgid "Other Rust Resources"
msgstr "ëŸ¬ìŠ¤íŠ¸ ì°¸ê³  ìë£Œ"

#: src/other-resources.md:3
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr "ëŸ¬ìŠ¤íŠ¸ ì»¤ë®¤ë‹ˆí‹°ëŠ” ì˜¨ë¼ì¸ì—ì„œ ê³ í’ˆì§ˆì˜ ë¬´ë£Œ ì†ŒìŠ¤ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤."

#: src/other-resources.md:6
msgid "Official Documentation"
msgstr "ê³µì‹ ë¬¸ì„œë“¤"

#: src/other-resources.md:8
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr ""
"ëŸ¬ìŠ¤íŠ¸ í”„ë¡œì íŠ¸ì—ëŠ” ì°¸ì¡°í•  ë§Œí•œ ìë£Œê°€ ë§ìŠµë‹ˆë‹¤. ì¼ë°˜ì ì¸ ë‚´ìš©ì„ ë‹¤ë£¨ëŠ” ëª‡ê°€"
"ì§€ ì°¸ê³  ë¬¸ì„œë“¤ì…ë‹ˆë‹¤:"

#: src/other-resources.md:10
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): ëŸ¬ìŠ¤íŠ¸ì— ëŒ€"
"í•œ ë¬´ë£Œ í‘œì¤€ ì„œì ì…ë‹ˆë‹¤. ì–¸ì–´ì— ëŒ€í•œ ìì„¸í•œ ì„¤ëª…ê³¼ ì‚¬ëŒë“¤ì´ ë¹Œë“œ í• ìˆ˜ ìˆëŠ” ëª‡"
"ê°€ì§€ í”„ë¡œì íŠ¸ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/other-resources.md:13
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): ì—¬ëŸ¬ ì˜ˆì œë¥¼ í†µ"
"í•´ ëŸ¬ìŠ¤íŠ¸ì˜ ë¬¸ë²•ì„ ë³´ì—¬ì£¼ë©° ë•Œë•Œë¡œ ì½”ë“œë¥¼ í™•ì¥í•˜ëŠ” ì•½ê°„ì˜ ì—°ìŠµë¬¸ì œë“¤ì´ í¬í•¨ë˜"
"ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/other-resources.md:17
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬"
"ë¦¬ ì „ì²´ ë¬¸ì„œì…ë‹ˆë‹¤."

#: src/other-resources.md:19
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): ë©”ëª¨ë¦¬ ëª¨ë¸ë§ê³¼ "
"ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•ì„ ì„¤ëª…í•˜ëŠ” ë¬¸ì„œì…ë‹ˆë‹¤.(ì•„ì§ ë¶ˆì™„ì „í•˜ë‹¤í•¨)"

#: src/other-resources.md:22
msgid "More specialized guides hosted on the official Rust site:"
msgstr "ì¢€ ë” ì „ë¬¸ì ì¸ ê³µì‹ ê°€ì´ë“œì…ë‹ˆë‹¤:"

#: src/other-resources.md:24
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤"
"íŠ¸, FFI, rawí¬ì¸í„° ì‘ì—…ì„ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/other-resources.md:27
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"ëŸ¬ìŠ¤íŠ¸ ë¶ì´ ì‘ì„± ëœ ì´í›„ ë„ì…ëœ ìƒˆë¡œìš´ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/other-resources.md:30
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): ìš´"
"ì˜ì²´ì œê°€ ì—†ëŠ” ì„ë² ë””ë“œ ì¥ì¹˜ì—ì„œì˜ ëŸ¬ìŠ¤íŠ¸ ì‚¬ìš©ë²•ì„ ì†Œê°œí•©ë‹ˆë‹¤."

#: src/other-resources.md:33
msgid "Unofficial Learning Material"
msgstr "ë¹„ê³µì‹ì  í•™ìŠµ ìë£Œ"

#: src/other-resources.md:35
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "ëŸ¬ìŠ¤íŠ¸ì— ëŒ€í•œ ê¸°íƒ€ ì•ˆë‚´ì„œì™€ íŠœí† ë¦¬ì–¼ì˜ ì¼ë¶€ì…ë‹ˆë‹¤:"

#: src/other-resources.md:37
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): Cì–¸ì–´ í”„ë¡œê·¸"
"ë˜ë¨¸ ê´€ì ì—ì„œ ëŸ¬ìŠ¤íŠ¸ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/other-resources.md:39
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): ì„ë² ë””ë“œ Cê°œë°œì(íŒì›¨ì–´ ê°œë°œì)ë¥¼ ìœ„í•œ ëŸ¬ìŠ¤íŠ¸ ê°€ì´ë“œì…ë‹ˆë‹¤."

#: src/other-resources.md:41
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): ë‹¤"
"ë¥¸ ì–¸ì–´(C/C++, Java, Python, Javascript)ì™€ì˜ ë³‘ë ¬ë¹„êµë¥¼ ì‚¬ìš©í•˜ì—¬ ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•"
"ì„ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/other-resources.md:44
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): ëŸ¬ìŠ¤íŠ¸ë¥¼ ë°°ìš°ëŠ”ë° ë„ì›€"
"ì´ ë˜ëŠ” 100ê°œ ì´ìƒì˜ ì—°ìŠµë¬¸ì œ"

#: src/other-resources.md:46
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): ëŸ¬ìŠ¤íŠ¸ ì–¸ì–´ì˜ ê¸°ë³¸ë¶€í„° ê³ ê¸‰ì„ ì „ë¶€ ë‹¤ë£¨ëŠ” ì¼ë ¨ì˜ ì‘ì€ "
"í”„ë ˆì  í…Œì´ì…˜, ì›¹ ì–´ì…ˆë¸”ë¦¬, async/await ê°™ì€ ë¶€ë¶„ë„ í•¨ê»˜ ë‹¤ë£¹ë‹ˆë‹¤."

#: src/other-resources.md:50
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/), [Take your first steps with Rust](https://docs.microsoft."
"com/en-us/learn/paths/rust-first-steps/): ì²«ë²ˆì§¸ëŠ” 35ê°œì˜ ì‹œë¦¬ì¦ˆ ì˜ìƒì´ë©° ë‘"
"ë²ˆì§¸ëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ë¬¸ë²•ê³¼ êµ¬ì¡°ë¥¼ ë‹¤ë£¨ëŠ” 11ê°œì˜ ëª¨ë“ˆ ì„¸íŠ¸ì…ë‹ˆë‹¤."

#: src/other-resources.md:56
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): ëª‡ê°€ì§€ ìœ í˜•ì˜ ë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡°ë¥¼ êµ¬í˜„í•´ë³´ë©´ì„œ ëŸ¬ìŠ¤"
"íŠ¸ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê·œì¹™ë“¤ì„ ê¹Šì´ìˆê²Œ íƒìƒ‰í•©ë‹ˆë‹¤."

#: src/other-resources.md:61
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"[Little Book of Rust Books](https://lborb.github.io/book/)ì—ì„œ ë” ë§ì€ ëŸ¬ìŠ¤"
"íŠ¸ ë¶ì„ í™•ì¸í•´ë³´ì„¸ìš”."

#: src/credits.md:3
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"ì´ ìë£ŒëŠ” ë§ì€ í›Œë¥­í•œ ëŸ¬ìŠ¤íŠ¸ ë¬¸ì„œë“¤ì˜ ë„ì›€ì„ ë°›ì•„ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ìœ ìš©í•œ ìë£Œ"
"ì˜ ì „ì²´ ëª©ë¡ì€ [other resources](other-resources.md)ì—ì„œ ì‚´í´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Comprehensive Rustì˜ ìë£ŒëŠ” Apache 2.0 ë¼ì´ì„ ìŠ¤ë¥¼ ë”°ë¦…ë‹ˆë‹¤. ìì„¸í•œê±´ "
"[`LICENSE`](../LICENSE) í™•ì¸í•´ ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:12
msgid "Rust by Example"
msgstr "Rust by Example"

#: src/credits.md:14
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"ì¼ë¶€ ì˜ˆì œì™€ ì—°ìŠµë¬¸ì œëŠ” [Rust by Example](https://doc.rust-lang.org/rust-by-"
"example/)ì„ ì°¸ì¡°í•˜ì˜€ìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ ì¡°í•­ì„ í¬í•¨í•˜ì—¬ ì €ì¥ì†Œì˜ `third_party/"
"rust-by-example/` í´ë”ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:19
msgid "Rust on Exercism"
msgstr "Rust on Exercism"

#: src/credits.md:21
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"ì¼ë¶€ ì—°ìŠµë¬¸ì œëŠ” [Rust on Exercism](https://exercism.org/tracks/rust)ì„ ì°¸ì¡°í•˜"
"ì˜€ìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ ì¡°í•­ì„ í¬í•¨í•˜ì—¬ ì €ì¥ì†Œì˜ `third_party/rust-on-exercism/`í´"
"ë”ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: src/credits.md:26
msgid "CXX"
msgstr "CXX"

#: src/credits.md:28
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"4ì¼ì°¨ ì˜¤í›„ ê°•ì˜ ì¤‘ [Interoperability with C++](android/interoperability/cpp."
"md)ì—ì„œëŠ” [CXX](https://cxx.rs/)ì˜ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ ì¡°í•­ì„ "
"í¬í•¨í•˜ì—¬ ì €ì¥ì†Œì˜ `third_party/cxx/`í´ë”ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#~ msgid "Small Example"
#~ msgstr "ì‘ì€ ì˜ˆì œ"

#~ msgid "Why Rust?"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ë¥¼ ì¨ì•¼í•˜ëŠ” ì´ìœ "

#~ msgid "Compile Time Guarantees"
#~ msgstr "ì»´íŒŒì¼ ì‹œ ë³´ì¥ë˜ëŠ” ê²ƒë“¤"

#~ msgid "Runtime Guarantees"
#~ msgstr "ëŸ°íƒ€ì„ ì‹œ ë³´ì¥ë˜ëŠ” ê²ƒë“¤"

#~ msgid "Modern Features"
#~ msgstr "í˜„ëŒ€ì ì¸ íŠ¹ì§•"

#~ msgid "Basic Syntax"
#~ msgstr "ê¸°ë³¸ ë¬¸ë²•"

#~ msgid "String vs str"
#~ msgstr "Stringê³¼ str"

#~ msgid "Overloading"
#~ msgstr "ì˜¤ë²„ë¡œë”©"

#~ msgid "Arrays and for Loops"
#~ msgstr "ë°°ì—´ê³¼ for ë°˜ë³µë¬¸"

#~ msgid "Stack vs Heap"
#~ msgstr "ìŠ¤íƒ(Stack)ê³¼ í™(Heap)"

#~ msgid "Stack Memory"
#~ msgstr "ìŠ¤íƒ ë©”ëª¨ë¦¬"

#~ msgid "Manual Memory Management"
#~ msgstr "ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#~ msgid "Scope-Based Memory Management"
#~ msgstr "ë²”ìœ„ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#~ msgid "Garbage Collection"
#~ msgstr "ê°€ë¹„ì§€ ì»¬ë ‰ì…˜"

#~ msgid "Rust Memory Management"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#~ msgid "Comparison"
#~ msgstr "ë¹„êµ"

#~ msgid "Moved Strings in Rust"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œì˜ ë¬¸ìì—´ ì´ë™"

#~ msgid "Moves in Function Calls"
#~ msgstr "í•¨ìˆ˜ í˜¸ì¶œì—ì„œì˜ ì´ë™(Move)"

#~ msgid "Copying and Cloning"
#~ msgstr "ë³µì‚¬ì™€ ë³µì œ"

#~ msgid "Shared and Unique Borrows"
#~ msgstr "ê³µìœ ì™€ ê³ ìœ  ë¹Œë¦¼"

#~ msgid "Storing Books"
#~ msgstr "ì±… ì €ì¥í•˜ê¸°"

#~ msgid "Iterators and Ownership"
#~ msgstr "ë°˜ë³µìì™€ ì†Œìœ ê¶Œ"

#~ msgid "Field Shorthand Syntax"
#~ msgstr "í•„ë“œ í• ë‹¹ ë‹¨ì¶• ë¬¸ë²•"

#~ msgid "Variant Payloads"
#~ msgstr "ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ì—´ê±°í˜•(Variant Payloads)"

#~ msgid "Enum Sizes"
#~ msgstr "ì—´ê±°í˜•ì˜ í¬ê¸°"

#~ msgid "Method Receiver"
#~ msgstr "ë©”ì„œë“œ ë¦¬ì‹œë²„(Receiver)"

#~ msgid "Destructuring Structs"
#~ msgstr "êµ¬ì¡°ì²´ ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#~ msgid "Destructuring Arrays"
#~ msgstr "ë°°ì—´ ë¶„í•´(ì—­êµ¬ì¡°í™”)"

#~ msgid "Match Guards"
#~ msgstr "ë§¤ì¹˜ ê°€ë“œ"

#~ msgid "Points and Polygons"
#~ msgstr "ì ê³¼ ë‹¤ê°í˜•"

#~ msgid "if expressions"
#~ msgstr "if í‘œí˜„ì‹"

#~ msgid "if let expressions"
#~ msgstr "if let í‘œí˜„ì‹"

#~ msgid "while expressions"
#~ msgstr "while í‘œí˜„ì‹"

#~ msgid "for expressions"
#~ msgstr "for í‘œí˜„ì‹"

#~ msgid "loop expressions"
#~ msgstr "loop í‘œí˜„ì‹"

#~ msgid "match expressions"
#~ msgstr "match í‘œí˜„ì‹"

#~ msgid "break & continue"
#~ msgstr "breakì™€ continue"

#~ msgid "Option and Result"
#~ msgstr "Optionê³¼ Result"

#~ msgid "Vec"
#~ msgstr "Vec"

#~ msgid "HashMap"
#~ msgstr "HashMap"

#~ msgid "Box"
#~ msgstr "Box"

#~ msgid "Recursive Data Types"
#~ msgstr "ì¬ê·€ì  ìë£Œêµ¬ì¡°"

#~ msgid "Rc"
#~ msgstr "Rc"

#~ msgid "Cell/RefCell"
#~ msgstr "Cellê³¼ RefCell"

#~ msgid "Strings and Iterators"
#~ msgstr "ë¬¸ìì—´ê³¼ ë°˜ë³µì"

#~ msgid "Generic Methods"
#~ msgstr "ì œë„¤ë¦­ ë©”ì„œë“œ"

#~ msgid "Monomorphization"
#~ msgstr "ë‹¨í˜•í™”"

#~ msgid "Default Methods"
#~ msgstr "ê¸°ë³¸ ë©”ì„œë“œ"

#~ msgid "impl Trait"
#~ msgstr "íŠ¸ë ˆì‡ êµ¬í˜„í•˜ê¸°"

#~ msgid "Important Traits"
#~ msgstr "ì¤‘ìš”í•œ íŠ¸ë ˆì‡"

#~ msgid "From and Into"
#~ msgstr "Fromê³¼ Into"

#~ msgid "Default"
#~ msgstr "Default"

#~ msgid "Operators: Add, Mul, ..."
#~ msgstr "ì—°ì‚°ì: Add, Mul, ..."

#~ msgid "Closures: Fn, FnMut, FnOnce"
#~ msgstr "í´ë¡œì €: Fn, FnMut, FnOnce"

#~ msgid "Catching Stack Unwinding"
#~ msgstr "ìŠ¤íƒ ë˜ê°ê¸°"

#~ msgid "Structured Error Handling"
#~ msgstr "êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ì²˜ë¦¬"

#~ msgid "Propagating Errors with ?"
#~ msgstr "'?'ë¥¼ ì´ìš©í•œ ì˜¤ë¥˜ ì „íŒŒ"

#~ msgid "Converting Error Types"
#~ msgstr "ì˜¤ë¥˜íƒ€ì… ë³€í™˜"

#~ msgid "Deriving Error Enums"
#~ msgstr "ë˜ë‹¤ë¥¸ ì˜¤ë¥˜ ì—´ê±°í˜•"

#~ msgid "Adding Context to Errors"
#~ msgstr "ì˜¤ë¥˜ì— ìƒí™©ì •ë³´ ì¶”ê°€"

#~ msgid "no_std"
#~ msgstr "no_std"

#~ msgid "alloc"
#~ msgstr "alloc"

#~ msgid "embedded-hal"
#~ msgstr "embedded-hal"

#~ msgid "probe-rs, cargo-embed"
#~ msgstr "progo-rs, cargo-embed"

#~ msgid "zerocopy"
#~ msgstr "zerocopy"

#~ msgid "buddy_system_allocator"
#~ msgstr "buddy_system_allocator"

#~ msgid "tinyvec"
#~ msgstr "tinyvec"

#~ msgid "spin"
#~ msgstr "íšŒì „"

#~ msgid "Send and Sync"
#~ msgstr "Sendì™€ Sync"

#~ msgid "Send"
#~ msgstr "Send"

#~ msgid "Sync"
#~ msgstr "Sync"

#~ msgid "Arc"
#~ msgstr "Arc"

#~ msgid "Mutex"
#~ msgstr "Mutex"

#~ msgid "async/await"
#~ msgstr "async/await"

#~ msgid "Pin"
#~ msgstr "Pin"

#~ msgid "Day 1 Morning"
#~ msgstr "1ì¼ì°¨ ì˜¤ì „"

#~ msgid "Day 1 Afternoon"
#~ msgstr "1ì¼ì°¨ ì˜¤í›„"

#~ msgid "Day 2 Morning"
#~ msgstr "2ì¼ì°¨ ì˜¤ì „"

#~ msgid "Day 2 Afternoon"
#~ msgstr "2ì¼ì°¨ ì˜¤í›„"

#~ msgid "Day 3 Morning"
#~ msgstr "3ì¼ì°¨ ì˜¤ì „"

#~ msgid "Day 3 Afternoon"
#~ msgstr "3ì¼ì°¨ ì˜¤í›„"

#~ msgid "Bare Metal Rust Morning"
#~ msgstr "Bare Metal ì˜¤ì „"

#~ msgid "Concurrency Morning"
#~ msgstr "ë™ì‹œì„± ì˜¤ì „"

#~ msgid "Concurrency Afternoon"
#~ msgstr "ë™ì‹œì„± ì˜¤í›„"

#~ msgid ""
#~ "[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
#~ "google/comprehensive-rust/build.yml?style=flat-square)](https://github."
#~ "com/google/comprehensive-rust/actions/workflows/build.yml?"
#~ "query=branch%3Amain)"
#~ msgstr ""
#~ "[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
#~ "google/comprehensive-rust/build.yml?style=flat-square)](https://github."
#~ "com/google/comprehensive-rust/actions/workflows/build.yml?"
#~ "query=branch%3Amain)"

#~ msgid "Build workflow"
#~ msgstr "ë¹Œë“œ ì›Œí¬í”Œë¡œ"

#~ msgid "GitHub contributors"
#~ msgstr "GitHub ì°¸ì—¬ì"

#~ msgid ""
#~ "[![GitHub contributors](https://img.shields.io/github/contributors/google/"
#~ "comprehensive-rust?style=flat-square)](https://github.com/google/"
#~ "comprehensive-rust/graphs/contributors) [![GitHub stars](https://img."
#~ "shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
#~ "(https://github.com/google/comprehensive-rust/stargazers)"
#~ msgstr ""
#~ "[![GitHub contributors](https://img.shields.io/github/contributors/google/"
#~ "comprehensive-rust?style=flat-square)](https://github.com/google/"
#~ "comprehensive-rust/graphs/contributors) [![GitHub stars](https://img."
#~ "shields.io/github/stars/google/comprehensive-rust?style=flat-square)]"
#~ "(https://github.com/google/comprehensive-rust/stargazers)"

#~ msgid "GitHub stars"
#~ msgstr "GitHub stars"

#~ msgid ""
#~ "[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-"
#~ "rust?style=flat-square)](https://github.com/google/comprehensive-rust/"
#~ "stargazers)"
#~ msgstr ""
#~ "[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-"
#~ "rust?style=flat-square)](https://github.com/google/comprehensive-rust/"
#~ "stargazers)"

#~ msgid "The course is fast paced and covers a lot of ground:"
#~ msgstr "ê°•ì˜ëŠ” ë¹ ë¥¸ ì†ë„ë¡œ ì§„í–‰ë˜ë©°, ì•„ë˜ ë‚´ìš©ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤:"

#~ msgid "Day 1: Basic Rust, ownership and the borrow checker."
#~ msgstr "1ì¼ì°¨: ëŸ¬ìŠ¤íŠ¸ ê¸°ë³¸, ì†Œìœ ê¶Œ(ownership)ê³¼ ë¹Œë¦¼(borrow) ì²´í¬."

#~ msgid "Day 2: Compound data types,  pattern matching, the standard library."
#~ msgstr "2ì¼ì°¨: ë³µí•© ë°ì´í„° ìœ í˜•, íŒ¨í„´ ë§¤ì¹­, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬."

#~ msgid "Day 3: Traits and generics, error handling, testing, unsafe Rust."
#~ msgstr ""
#~ "3ì¼ì°¨: íŠ¸ë ˆì‡(trait)ì™€ ì œë„¤ë¦­(generic), ì˜¤ë¥˜ ì²˜ë¦¬, í…ŒìŠ¤íŠ¸, ì•ˆì „í•˜ì§€ ì•Šì€ "
#~ "ëŸ¬ìŠ¤íŠ¸."

#~ msgid "Concurrency"
#~ msgstr "ë™ì‹œì„±"

#~ msgid ""
#~ "```shell\n"
#~ "cargo init concurrency\n"
#~ "cd concurrency\n"
#~ "cargo add tokio --features full\n"
#~ "cargo run\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "cargo init concurrency\n"
#~ "cd concurrency\n"
#~ "cargo add tokio --features full\n"
#~ "cargo run\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "    sudo apt install cargo rust-src rustfmt\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ sudo apt install cargo rust-src rustfmt\n"
#~ "```"

#~ msgid ""
#~ "We suggest using [VS Code](https://code.visualstudio.com/) to edit the "
#~ "code (but any LSP compatible editor works with rust-analyzer[3](https://"
#~ "rust-analyzer.github.io/))."
#~ msgstr ""
#~ "ìš°ë¦¬ëŠ” ì½”ë“œ ì—ë””í„°ë¡œ [VS Code](https://code.visualstudio.com/)ë¥¼ ì¶”ì²œí•©ë‹ˆ"
#~ "ë‹¤. ê·¸ëŸ¬ë‚˜ LSPë¥¼ ì§€ì›í•˜ëŠ” (ê·¸ë˜ì„œ rust-analyzer[3](https://rust-analyzer."
#~ "github.io/)ì™€ ì—°ë™ì´ ê°€ëŠ¥í•œ) ì—ë””í„°ë¼ë©´ ì–´ë–¤ ê²ƒì´ë¼ë„ ê´œì°®ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Some folks also like to use the [JetBrains](https://www.jetbrains.com/"
#~ "clion/) family of IDEs, which do their own analysis but have their own "
#~ "tradeoffs. If you prefer them, you can install the [Rust Plugin](https://"
#~ "www.jetbrains.com/rust/). Please take note that as of January 2023 "
#~ "debugging only works on the CLion version of the JetBrains IDEA suite."
#~ msgstr ""
#~ "ì–´ë–¤ ì‚¬ëŒë“¤ì€ [JetBrains](https://www.jetbrains.com/clion/) ì œí’ˆêµ°ì„ ì„ í˜¸"
#~ "í•˜ê¸°ë„ í•©ë‹ˆë‹¤. ì´ ì œí’ˆë“¤ì€ rust-analyzer ë¥¼ í™œìš©í•˜ì§€ ì•Šê³  IDE ìì²´ì ìœ¼ë¡œ "
#~ "êµ¬ë¬¸ë¶„ì„ì„ í•©ë‹ˆë‹¤. ë§Œì•½ ì´ IDEë¥¼ ì„¤ì¹˜í•˜ì…¨ë‹¤ë©´ [Rust Plugin](https://www."
#~ "jetbrains.com/rust/)ë¥¼ ì„¤ì¹˜í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ë‹¤ë§Œ 2023ë…„ 1ì›” ê¸°ì¤€, ë””ë²„ê¹…"
#~ "ì€ JetBrains IDEA suiteì˜ CLion ë²„ì „ì—ì„œë§Œ ì‘ë™í•œë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì‹œê¸° ë°”ë"
#~ "ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "% rustc --version\n"
#~ "rustc 1.69.0 (84c898d65 2023-04-16)\n"
#~ "% cargo --version\n"
#~ "cargo 1.69.0 (6e9a83356 2023-04-12)\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "% rustc --version\n"
#~ "rustc 1.69.0 (84c898d65 2023-04-16)\n"
#~ "% cargo --version\n"
#~ "cargo 1.69.0 (6e9a83356 2023-04-12)\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ cargo new exercise\n"
#~ "     Created binary (application) `exercise` package\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cargo new exercise\n"
#~ "     Created binary (application) `exercise` package\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ cd exercise\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Hello, world!\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cd exercise\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Hello, world!\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Edit me!\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ cargo run\n"
#~ "   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
#~ "    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
#~ "     Running `target/debug/exercise`\n"
#~ "Edit me!\n"
#~ "```"

#~ msgid ""
#~ "Memory management: stack vs heap, manual memory management, scope-based "
#~ "memory management, and garbage collection."
#~ msgstr ""
#~ "ë©”ëª¨ë¦¬ ê´€ë¦¬: ìŠ¤íƒê³¼ í™, ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬, ìŠ¤ì½”í”„(ë²”ìœ„)ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬, ê°€"
#~ "ë¹„ì§€ ì»¬ë ‰ì…˜(GC)"

#~ msgid ""
#~ "Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
#~ msgstr "ì†Œìœ ê¶Œ: Move ë¬¸ë²•, ë³µì‚¬ì™€ ë³µì œ, ë¹Œë¦¼, ìˆ˜ëª…."

#~ msgid ""
#~ "The idea for the first day is to show _just enough_ of Rust to be able to "
#~ "speak about the famous borrow checker. The way Rust handles memory is a "
#~ "major feature and we should show students this right away."
#~ msgstr ""
#~ "ì²« ë‚  ê°•ì˜ì˜ ëª©í‘œëŠ”, ëŸ¬ìŠ¤íŠ¸ì—ì„œ ê·¸ ìœ ëª…í•œ ë¹Œë¦¼ í™•ì¸ì— ëŒ€í•´ì„œ ì´ì•¼ê¸° í•  ìˆ˜ "
#~ "ìˆì„ ì •ë„ ê¹Œì§€ë§Œ ëŸ¬ìŠ¤íŠ¸ë¥¼ ì†Œê°œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì˜ ê°€ì¥ ë…íŠ¹í•œ íŠ¹ì§•ì´ "
#~ "ë©”ëª¨ë¦¬ë¥¼ ë‹¤ë£¨ëŠ” ë°©ì‹ì´ê¸° ë•Œë¬¸ì—, í•™ìƒë“¤ì—ê²Œ ì´ ë¶€ë¶„ ì„ ìš°ì„ ì ìœ¼ë¡œ ë³´ì—¬ì£¼"
#~ "ë ¤ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "If you're teaching this in a classroom, this is a good place to go over "
#~ "the schedule. We suggest splitting the day into two parts (following the "
#~ "slides):"
#~ msgstr ""
#~ "ë§Œì•½ ë‹¹ì‹ ì´ ê°•ì˜ì‹¤ì—ì„œ ê°€ë¥´ì¹˜ê³  ìˆë‹¤ë©´, ì´ ìŠ¬ë¼ì´ë“œëŠ” ì¼ì •ì„ ê²€í† í•˜ê¸°ì— ì "
#~ "í•©í•œ ê³³ì…ë‹ˆë‹¤. í•˜ë£¨ì¹˜ ê°•ì˜ë¥¼ ì•„ë˜ì²˜ëŸ¼ ì˜¤ì „ ì˜¤í›„ë¡œ ë‚˜ëˆ„ì–´ ì§„í–‰í•˜ëŠ” ê²ƒì„ ì¶”"
#~ "ì²œí•©ë‹ˆë‹¤. (ìŠ¬ë¼ì´ë“œê°€ ê·¸ëŸ°ì‹ìœ¼ë¡œ ë‚˜ë‰˜ì–´ ìˆìŠµë‹ˆë‹¤.)"

#~ msgid "Morning: 9:00 to 12:00,"
#~ msgstr "ì˜¤ì „: 9:00 ~ 12:00,"

#~ msgid "Afternoon: 13:00 to 16:00."
#~ msgstr "ì˜¤í›„: 13:00 ~ 16:00."

#~ msgid ""
#~ "You can of course adjust this as necessary. Please make sure to include "
#~ "breaks, we recommend a break every hour!"
#~ msgstr ""
#~ "ë¬¼ë¡  í•„ìš”ì— ë”°ë¼ ì¡°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°•ì˜ ì¤‘ê°„ì— ì‰¬ëŠ”ì‹œê°„ì„ ë„£ëŠ” ê²ƒì„ ìŠ"
#~ "ì§€ ë§ˆì„¸ìš”. ë§¤ ì‹œê°„ íœ´ì‹ì„ ê°–ëŠ”ê±¸ ì¶”ì²œí•©ë‹ˆë‹¤!"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello ğŸŒ!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello ğŸŒ!\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Here is a small example program in Rust:"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ë¡œ ì‘ì„±ëœ ì‘ì€ ì˜ˆì œì…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {              // Program entry point\n"
#~ "    let mut x: i32 = 6;  // Mutable variable binding\n"
#~ "    print!(\"{x}\");       // Macro for printing, like printf\n"
#~ "    while x != 1 {       // No parenthesis around expression\n"
#~ "        if x % 2 == 0 {  // Math like in other languages\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {              // í”„ë¡œê·¸ë¨ ì§„ì…ì ì…ë‹ˆë‹¤.\n"
#~ "    let mut x: i32 = 6;  // ê°€ë³€ ë³€ìˆ˜ í• ë‹¹(binding)ì…ë‹ˆë‹¤.\n"
#~ "    print!(\"{x}\");       // printfì™€ ê°™ì€ ì¶œë ¥ì„ ìœ„í•œ ë§¤í¬ë¡œ ì…ë‹ˆë‹¤.\n"
#~ "    while x != 1 {       // í‘œí˜„ì‹ì— ê´„í˜¸ëŠ” ì—†ìŠµë‹ˆë‹¤.\n"
#~ "        if x % 2 == 0 {  // ë‹¤ë¥¸ ì–¸ì–´ì™€ ê°™ì€ ìˆ˜í•™ì—°ì‚°ì‹ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The code implements the Collatz conjecture: it is believed that the loop "
#~ "will always end, but this is not yet proved. Edit the code and play with "
#~ "different inputs."
#~ msgstr ""
#~ "ì´ ì½”ë“œëŠ” ì½œë¼ì¸  ì¶”ì¸¡(Collatz conjecture)ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤: ë°˜ë³µë¬¸ì´ ì–¸ì œë‚˜ "
#~ "ì¢…ë£Œë  ê²ƒì´ë¼ê³  ë¯¿ì§€ë§Œ ì¦ëª…ëœ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. ì½”ë“œë¥¼ ìˆ˜ì •í•˜ê³  ì‹¤í–‰í•´ ë³´ì‹œ"
#~ "ê¸° ë°”ëë‹ˆë‹¤."

#~ msgid ""
#~ "Explain that all variables are statically typed. Try removing `i32` to "
#~ "trigger type inference. Try with `i8` instead and trigger a runtime "
#~ "integer overflow."
#~ msgstr ""
#~ "ëª¨ë“  ë³€ìˆ˜ê°€ ì»´íŒŒì¼ ì‹œ ì •í•´ì§„ íƒ€ì…ì„ ê°€ì§ì„ ì„¤ëª…í•©ë‹ˆë‹¤. `i32`ë¥¼ ì‚­ì œí•˜ì—¬ ì»´"
#~ "íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ ì„ í•˜ë„ë¡ í•´ ë´…ë‹ˆë‹¤. `i32`ì„ `i8`ë¡œ ë³€ê²½í•˜ì—¬ ëŸ°íƒ€ì„ ì˜¤ë²„"
#~ "í”Œë¡œë¥¼ ìœ ë°œí•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid "Change `let mut x` to `let x`, discuss the compiler error."
#~ msgstr "`let mut x`ë¥¼ `let x`ë¡œ ìˆ˜ì •í•˜ì—¬ ì»´íŒŒì¼ ì˜¤ë¥˜ì— ëŒ€í•´ í† ë¡ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Show how `print!` gives a compilation error if the arguments don't match "
#~ "the format string."
#~ msgstr ""
#~ "ì¸ìê°€ í¬ë§· ë¬¸ìì—´ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ê²½ìš° `print!`ì—ì„œ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•¨"
#~ "ì„ ì–¸ê¸‰í•˜ëŠ” ê²ƒë„ ì¢‹ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Show how you need to use `{}` as a placeholder if you want to print an "
#~ "expression which is more complex than just a single variable."
#~ msgstr ""
#~ "ë‹¨ì¼ ë³€ìˆ˜ë³´ë‹¤ ë³µì¡í•œ ì‹ì„ ì¶œë ¤í•˜ë ¤ë©´ `{}`ì„ ìë¦¬ í‘œì‹œìë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ "
#~ "ë³´ì—¬ ì¤ë‹ˆë‹¤."

#~ msgid ""
#~ "Show the students the standard library, show them how to search for `std::"
#~ "fmt` which has the rules of the formatting mini-language. It's important "
#~ "that the students become familiar with searching in the standard library."
#~ msgstr ""
#~ "í•™ìƒë“¤ì—ê²Œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì–´ë”” ìˆëŠ”ì§€ ì•Œë ¤ ì£¼ê³ ëŠ”, `print!`ê°€ ì§€ì›í•˜ëŠ” "
#~ "í¬ë§·íŒ… ì–¸ì–´ì˜ ë¬¸ë²•ì„ ì•Œê¸° ìœ„í•´ `std::fmt`ë¥¼ ê²€ìƒ‰í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ê°€ë¥´ì¹˜ì„¸"
#~ "ìš”.í•™ìƒë“¤ì´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê²€ìƒ‰ ê¸°ëŠ¥ì— ìµìˆ™í•´ ì§€ë„ë¡ í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "In a shell `rustup doc std::fmt` will open a browser on the local std::"
#~ "fmt documentation"
#~ msgstr ""
#~ "ì‰˜ì—ì„œ  `rustup doc std::fmt`ë¥¼ ìˆ˜í–‰í•˜ë©´ ë¡œì»¬ ë¸Œë¼ìš°ì €ë¡œ `std:fmt`ì— ëŒ€í•œ "
#~ "ë¬¸ì„œë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤"

#~ msgid "Compile time memory safety."
#~ msgstr "ì»´íŒŒì¼ ì‹œ ë©”ëª¨ë¦¬ ì•ˆì „ì´ ë³´ì¥ë¨."

#~ msgid "Lack of undefined runtime behavior."
#~ msgstr "ì •ì˜ë˜ì§€ ì•Šì€ ëŸ°íƒ€ì„ ë™ì‘ì´ ì—†ìŒ."

#~ msgid "Modern language features."
#~ msgstr "í˜„ëŒ€ì ì¸ ì–¸ì–´ ê¸°ëŠ¥."

#~ msgid "Static memory management at compile time:"
#~ msgstr "ì»´íŒŒì¼ ì‹œ ì •ì  ë©”ëª¨ë¦¬ ê´€ë¦¬:"

#~ msgid "No memory leaks (_mostly_, see notes)."
#~ msgstr "ë©”ëª¨ë¦¬ ëˆ„ì¶œ ì—†ìŒ(_ê±°ì˜_. ê°•ì˜ì°¸ì¡°ë…¸íŠ¸ ì°¸ê³ .)"

#~ msgid ""
#~ "It is possible to produce memory leaks in (safe) Rust. Some examples are:"
#~ msgstr ""
#~ "(ì•ˆì „í•œ) ëŸ¬ìŠ¤íŠ¸ì—ì„œë„ ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª‡ ê°€ì§€ ê²½ìš°ê°€ ìˆìŠµë‹ˆ"
#~ "ë‹¤:"

#~ msgid ""
#~ "You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
#~ "html#method.leak) to leak a pointer. A use of this could be to get "
#~ "runtime-initialized and runtime-sized static variables"
#~ msgstr ""
#~ "[`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method."
#~ "leak)ì„ ì´ìš©í•˜ì—¬ í¬ì¸í„°ë¥¼ ì˜ë„ì ìœ¼ë¡œ ëˆ„ì¶œì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•´ì„œ "
#~ "ëŸ°íƒ€ì„ì´ ìƒì„±í•˜ê³  ëŸ°íƒ€ì„ì´ í¬ê¸°ë¥¼ ì •í•œ ì •ì  ë³€ìˆ˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#~ msgid ""
#~ "You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn."
#~ "forget.html) to make the compiler \"forget\" about a value (meaning the "
#~ "destructor is never run)."
#~ msgstr ""
#~ "[`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget.html)ì„ "
#~ "ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼ëŸ¬ê°€ ê°’ì— ëŒ€í•´ \"ìŠë„ë¡\" ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì†Œë©¸ìê°€ ì‹¤í–‰ë˜"
#~ "ì§€ ì•ŠìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤)."

#~ msgid ""
#~ "You can also accidentally create a [reference cycle](https://doc.rust-"
#~ "lang.org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
#~ msgstr ""
#~ "`Rc` ë˜ëŠ” `Arc`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤ìˆ˜ë¡œ [ìˆœí™˜ì°¸ì¡°](https://doc.rust-lang.org/"
#~ "book/ch15-06-reference-cycles.html)ë¥¼ ìƒì„±í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "In fact, some will consider infinitely populating a collection a memory "
#~ "leak and Rust does not protect from those."
#~ msgstr ""
#~ "ì»¬ë ‰ì…˜ì„ ë¬´í•œì • ì±„ìš°ëŠ” ê²ƒì„ ë©”ëª¨ë¦¬ ëˆ„ì¶œë¡œ ê°„ì£¼í•  ìˆ˜ë„ ìˆì§€ë§Œ, ëŸ¬ìŠ¤íŠ¸ëŠ” ì´"
#~ "ë¥¼ ë³´í˜¸í•˜ì§„ ëª»í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "For the purpose of this course, \"No memory leaks\" should be understood "
#~ "as \"Pretty much no _accidental_ memory leaks\"."
#~ msgstr ""
#~ "ë³¸ ê°•ì˜ì—ì„œëŠ” \"ë©”ëª¨ë¦¬ ëˆ„ì¶œ ì—†ìŒ\"ì„ \"ìš°ë°œì ì¸ ë©”ëª¨ë¦¬ ëˆ„ì¶œ ì—†ìŒ\"ìœ¼ë¡œ ì´"
#~ "í•´í•´ì•¼ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
#~ "lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
#~ "flag. If enabled, the program will panic (a controlled crash of the "
#~ "program), otherwise you get wrap-around semantics. By default, you get "
#~ "panics in debug mode (`cargo build`) and wrap-around in release mode "
#~ "(`cargo build --release`)."
#~ msgstr ""
#~ "ì •ìˆ˜í˜• ì˜¤ë²„í”Œë¡œìš°ëŠ” [`overflow-checks`](https://doc.rust-lang.org/rustc/"
#~ "codegen-options/index.html#overflow-checks) ì»´íŒŒì¼ íƒ€ì„ í”Œë˜ê·¸ë¥¼ í†µí•´ ì •ì˜"
#~ "ë©ë‹ˆë‹¤. ì´ í”Œë˜ê·¸ê°€ ì¼œì§€ë©´, í”„ë¡œê·¸ë¨ì€ ì •ìˆ˜í˜• ì˜¤ë²„í”Œë¡œìš° ë°œìƒì‹œ panic (í”„"
#~ "ë¡œê·¸ë¨ì„ í¬ë˜ì‹œ ì‹œí‚¤ëŠ” ì˜ ì •ì˜ëœ ë°©ë²•) í•©ë‹ˆë‹¤. ì´ í”Œë˜ê·¸ê°€ êº¼ì§€ë©´, ì˜¤ë²„í”Œ"
#~ "ë¡œìš°ëŠ” wrap-around ê°€ ë©ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ë””ë²„ê·¸ ëª¨ë“œ(`cargo build`)ì—ì„œëŠ” "
#~ "íŒ¨ë‹‰ì´, ë¦´ë¦¬ì¦ˆ ëª¨ë“œ(`cargo build --release`)ì—ì„œëŠ” wrap-aroundê°€ ë°œìƒí•©ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "Bounds checking cannot be disabled with a compiler flag. It can also not "
#~ "be disabled directly with the `unsafe` keyword. However, `unsafe` allows "
#~ "you to call functions such as `slice::get_unchecked` which does not do "
#~ "bounds checking."
#~ msgstr ""
#~ "ì»´íŒŒì¼ í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²½ê³„ì²´í¬ë¥¼ ë¬´ë ¥í™” í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `unsafe`ë¥¼ ì‚¬ìš©"
#~ "í•˜ë”ë¼ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ `unsafe`ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ `slice::"
#~ "get_unchecked`ê°™ì€ í•¨ìˆ˜ëŠ” ê²½ê³„ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#~ msgid "Rust is built with all the experience gained in the last decades."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ëŠ” ì§€ë‚œ ìˆ˜ì‹­ë…„ê°„ì˜ ëª¨ë“  (í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë“¤ì˜) ê²½í—˜ìœ¼ë¡œ ë§Œë“¤ì–´ì¡ŒìŠµë‹ˆ"
#~ "ë‹¤."

#~ msgid "Language Features"
#~ msgstr "ì–¸ì–´ì  íŠ¹ì§•"

#~ msgid "Tooling"
#~ msgstr "ë„êµ¬ë“¤"

#~ msgid ""
#~ "Zero-cost abstractions, similar to C++, means that you don't have to "
#~ "'pay' for higher-level programming constructs with memory or CPU. For "
#~ "example, writing a loop using `for` should result in roughly the same low "
#~ "level instructions as using the `.iter().fold()` construct."
#~ msgstr ""
#~ "C++ ì™€ ìœ ì‚¬í•˜ê²Œ ì œë¡œ ì½”ìŠ¤íŠ¸ ì¶”ìƒí™”ëŠ” CPUë‚˜ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒìœ„ë ˆë²¨ í”„ë¡œ"
#~ "ê·¸ë˜ë° êµ¬ì¡°ë¥¼ ë§Œë“œëŠ”ë° 'ë¹„ìš©'ì„ ì§€ë¶ˆí•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `for` ë£¨"
#~ "í”„ì™€ì™€ `iter().fold()` êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ê±°ì˜ ë™ì¼í•œ ë‚®ì€ ìˆ˜ì¤€ì˜ ëª…ë ¹ì–´"
#~ "ê°€ ìƒì„±ë  ê²ƒ ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
#~ "also known as 'sum types', which allow the type system to express things "
#~ "like `Option<T>` and `Result<T, E>`."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì˜ ì—´ê±°í˜•(enum)ì€ í•©ê³„ íƒ€ì…(sum type)ìœ¼ë¡œ ì•Œë ¤ì§„ ëŒ€ìˆ˜í•™ì  ë°ì´í„°í˜•"
#~ "(Algebraic Data Type)ìœ¼ë¡œ, íƒ€ì… ì‹œìŠ¤í…œì´ `Option<T>`ì™€ `Result<T, E>`ë“±ì„ "
#~ "í‘œí˜„í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤."

#~ msgid ""
#~ "Remind people to read the errors --- many developers have gotten used to "
#~ "ignore lengthy compiler output. The Rust compiler is significantly more "
#~ "talkative than other compilers. It will often provide you with "
#~ "_actionable_ feedback, ready to copy-paste into your code."
#~ msgstr ""
#~ "ì˜¤ë¥˜ë¥¼ ì½ì–´ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤ --- ì˜¤ëœê¸°ê°„ ë§ì€ ê°œë°œìë“¤ì´ ì»´íŒŒì¼ëŸ¬ ì¶œë ¥ì„ ë¬´"
#~ "ì‹œí•˜ëŠ”ë° ìµìˆ™í•´ì ¸ ìˆìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ë¥¸ ì»´íŒŒì¼ëŸ¬ë³´ë‹¤ ë” ìˆ˜ë‹¤ìŠ¤"
#~ "ëŸ½ê³ , ë³µì‚¬-ë¶™ì—¬ë„£ê¸° í•  ìˆ˜ ìˆëŠ” ì •ë„ì˜ ì½”ë“œ í”¼ë“œë°±ì„ ì œê³µí•˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "The Rust standard library is small compared to languages like Java, "
#~ "Python, and Go. Rust does not come with several things you might consider "
#~ "standard and essential:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” Java, Pythonì´ë‚˜ Goì™€ ê°™ì€ ì–¸ì–´ì— ë¹„í•´ì„œ ê·œëª¨ê°€ "
#~ "ì‘ìŠµë‹ˆë‹¤. ë‹¹ì—°íˆ í¬í•¨ë˜ì–´ì•¼ í•œë‹¤ê³  ìƒê°í•  ìˆ˜ë„ ìˆëŠ” ì•„ë˜ì™€ ê°™ì€ ê²ƒë“¤ì´ ëŸ¬"
#~ "ìŠ¤íŠ¸ì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì—†ìŠµë‹ˆë‹¤:"

#~ msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
#~ msgstr ""
#~ "ë‚œìˆ˜ ìƒì„±ê¸°, í•˜ì§€ë§Œ [rand](https://docs.rs/rand/)ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆ"
#~ "ë‹¤."

#~ msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
#~ msgstr ""
#~ "SSL ë˜ëŠ” TLSì§€ì›, í•˜ì§€ë§Œ [rusttls](https://docs.rs/rustls/)ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì‹œ"
#~ "ê¸° ë°”ëë‹ˆë‹¤."

#~ msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
#~ msgstr ""
#~ "JSON ì§€ì›, í•˜ì§€ë§Œ [serde_json](https://docs.rs/serde_json/) ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜"
#~ "ì‹œê¸° ë°”ëë‹ˆë‹¤."

#~ msgid ""
#~ "The reasoning behind this is that functionality in the standard library "
#~ "cannot go away, so it has to be very stable. For the examples above, the "
#~ "Rust community is still working on finding the best solution --- and "
#~ "perhaps there isn't a single \"best solution\" for some of these things."
#~ msgstr ""
#~ "ê·¸ ì´ìœ ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ í•œ ë²ˆ ì–´ë–¤ ê¸°ëŠ¥ì„ ì œê³µí•˜ë©´ ëº„ ìˆ˜ ì—†ìœ¼ë©°, ë§¤"
#~ "ìš° ì•ˆì •ì ì´ì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ìœ„ì— ì–¸ê¸‰í•œ ê¸°ëŠ¥ë“¤ì€ ì•„ì§ ëŸ¬ìŠ¤íŠ¸ ì»¤ë®¤ë‹ˆí‹°"
#~ "ê°€ ìµœê³ ì˜ ì†”ë£¨ì…˜ì„ ì°¾ì§€ ëª»í–ˆê¸° ë•Œë¬¸ì— í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— í¬í•¨ë˜ì§€ ì•Šì•˜ìŠµë‹ˆ"
#~ "ë‹¤. ì–´ì©Œë©´ ì´ë“¤ ì¤‘ ëª‡ ê°œëŠ” 'ìµœê³ ì˜ ì†”ë£¨ì…˜'ì´ ì•„ì˜ˆ ì¡´ì¬í•  ìˆ˜ ì—†ì„ ì§€ë„ ëª¨ë¦…"
#~ "ë‹ˆë‹¤."

#~ msgid ""
#~ "Rust comes with a built-in package manager in the form of Cargo and this "
#~ "makes it trivial to download and compile third-party crates. A "
#~ "consequence of this is that the standard library can be smaller."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ëŠ” ì¹´ê³ ë¼ëŠ” íŒ¨í‚¤ì§€ ê´€ë¦¬ìê°€ ë‚´ì¥ë˜ì–´ ìˆê³ , ì„œë“œíŒŒí‹° í¬ë ˆì´íŠ¸ë¥¼ ë‹¤ìš´"
#~ "ë¡œë“œ, ì»´íŒŒì¼ í•˜ê¸° ë§¤ìš° ì‰½ìŠµë‹ˆë‹¤. ì´ ë˜í•œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì‘ì€ ì´ìœ ì…ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "Discovering good third-party crates can be a problem. Sites like <https://"
#~ "lib.rs/> help with this by letting you compare health metrics for crates "
#~ "to find a good and trusted one."
#~ msgstr ""
#~ "ì¢‹ì€ ì„œë“œíŒŒí‹° í¬ë ˆì´íŠ¸ë¥¼ ì°¾ëŠ” ê²ƒì€ ì–´ë µìŠµë‹ˆë‹¤. <https://lib.rs> ì™€ ê°™ì€ ì‚¬"
#~ "ì´íŠ¸ê°€ ì‹ ë¢°í• ìˆ˜ ìˆëŠ” ì¢‹ì€ í¬ë ˆì´íŠ¸ë¥¼ ë¹„êµí•˜ì—¬ ì°¾ëŠ”ë° ì¢‹ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
#~ "implementation used in major IDEs and text editors."
#~ msgstr ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/)ëŠ” ì£¼ìš” IDEë‚˜ í…ìŠ¤íŠ¸ ì—ë””"
#~ "í„°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ëŸ¬ìŠ¤íŠ¸ìš© LSPì„œë²„ ì…ë‹ˆë‹¤."

#~ msgid "`\"foo\"`, `\"two\\nlines\"`"
#~ msgstr "`\"foo\"`, `\"two\\nlines\"`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
#~ "    println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
#~ "    println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", b\"abc\");\n"
#~ "    println!(\"{:?}\", &[97, 98, 99]);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", b\"abc\");\n"
#~ "    println!(\"{:?}\", &[97, 98, 99]);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut a: [i8; 10] = [42; 10];\n"
#~ "    a[5] = 0;\n"
#~ "    println!(\"a: {:?}\", a);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut a: [i8; 10] = [42; 10];\n"
#~ "    a[5] = 0;\n"
#~ "    println!(\"a: {:?}\", a);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let t: (i8, bool) = (7, true);\n"
#~ "    println!(\"1st index: {}\", t.0);\n"
#~ "    println!(\"2nd index: {}\", t.1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let t: (i8, bool) = (7, true);\n"
#~ "    println!(\"1st index: {}\", t.0);\n"
#~ "    println!(\"2nd index: {}\", t.1);\n"
#~ "}\n"
#~ "```"

#~ msgid "Like C++, Rust has references:"
#~ msgstr "C++ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ëŸ¬ìŠ¤íŠ¸ë„ ì°¸ì¡°í˜•ì„ ê°–ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x: i32 = 10;\n"
#~ "    let ref_x: &mut i32 = &mut x;\n"
#~ "    *ref_x = 20;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x: i32 = 10;\n"
#~ "    let ref_x: &mut i32 = &mut x;\n"
#~ "    *ref_x = 20;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We must dereference `ref_x` when assigning to it, similar to C and C++ "
#~ "pointers."
#~ msgstr ""
#~ "`ref_x`ì— ê°’ì„ í• ë‹¹í•  ë•Œ, C/C++ì˜ í¬ì¸í„°ì™€ ìœ ì‚¬í•˜ê²Œ `*`ë¥¼ ì´ìš©í•´ì„œ ì°¸ì¡°ë¥¼ "
#~ "ë”°ë¼ê°€ì•¼(ì—­ì°¸ì¡°) í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "References that are declared as `mut` can be bound to different values "
#~ "over their lifetime."
#~ msgstr ""
#~ "`mut`ë¡œ ì„ ì–¸ëœ ì°¸ì¡°ëŠ” ê·¸ ë³€ìˆ˜ê°€ ì‚´ì•„ìˆëŠ” ë™ì•ˆ ë‹¤ë¥¸ ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let ref_x: &i32;\n"
#~ "    {\n"
#~ "        let x: i32 = 10;\n"
#~ "        ref_x = &x;\n"
#~ "    }\n"
#~ "    println!(\"ref_x: {ref_x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let ref_x: &i32;\n"
#~ "    {\n"
#~ "        let x: i32 = 10;\n"
#~ "        ref_x = &x;\n"
#~ "    }\n"
#~ "    println!(\"ref_x: {ref_x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "A reference is said to \"borrow\" the value it refers to."
#~ msgstr "ì°¸ì¡°ëŠ” ì–´ë–¤ ê°’ì„ \"ë¹Œë¦¬ëŠ”\" ê²ƒì…ë‹ˆë‹¤."

#~ msgid ""
#~ "Rust is tracking the lifetimes of all references to ensure they live long "
#~ "enough."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ëŠ” ì°¸ì¡° ëŒ€ìƒì˜ ê°’ì´, ê·¸ ê°’ì— ëŒ€í•œ ëª¨ë“  ì°¸ì¡°ë“¤ë³´ë‹¤ ë” ì˜¤ë˜ ì‚´ì•„ìˆìŒ"
#~ "ì„ ì¶”ì í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
#~ "    println!(\"a: {a:?}\");\n"
#~ "\n"
#~ "    let s: &[i32] = &a[2..4];\n"
#~ "\n"
#~ "    println!(\"s: {s:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
#~ "    println!(\"a: {a:?}\");\n"
#~ "\n"
#~ "    let s: &[i32] = &a[2..4];\n"
#~ "    println!(\"s: {s:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "`String` vs `str`"
#~ msgstr "`String`ê³¼ `str`"

#~ msgid "We can now understand the two string types in Rust:"
#~ msgstr "ì´ì œ ëŸ¬ìŠ¤íŠ¸ì˜ ë‘ ê°€ì§€ ë¬¸ìì—´ íƒ€ì…ì— ëŒ€í•´ì„œ ì´í•´í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: &str = \"World\";\n"
#~ "    println!(\"s1: {s1}\");\n"
#~ "\n"
#~ "    let mut s2: String = String::from(\"Hello \");\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    s2.push_str(s1);\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    \n"
#~ "    let s3: &str = &s2[6..];\n"
#~ "    println!(\"s3: {s3}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: &str = \"World\";\n"
#~ "    println!(\"s1: {s1}\");\n"
#~ "\n"
#~ "    let mut s2: String = String::from(\"Hello \");\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    s2.push_str(s1);\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    \n"
#~ "    let s3: &str = &s2[6..];\n"
#~ "    println!(\"s3: {s3}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "You can borrow `&str` slices from `String` via `&` and optionally range "
#~ "selection."
#~ msgstr ""
#~ "`&`ì™€ ë²”ìœ„ ì—°ì‚°ìë¥¼ ì´ìš©í•˜ì—¬ `String`ì—ì„œ `&str`ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë¹Œë ¤ì˜¬ ìˆ˜ ìˆìŠµ"
#~ "ë‹ˆë‹¤."

#~ msgid ""
#~ "A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
#~ "Fizz_buzz) interview question:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ ë²„ì „ì˜ [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) í•¨ìˆ˜ì…ë‹ˆ"
#~ "ë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    print_fizzbuzz_to(20);\n"
#~ "}\n"
#~ "\n"
#~ "fn is_divisible(n: u32, divisor: u32) -> bool {\n"
#~ "    if divisor == 0 {\n"
#~ "        return false;\n"
#~ "    }\n"
#~ "    n % divisor == 0\n"
#~ "}\n"
#~ "\n"
#~ "fn fizzbuzz(n: u32) -> String {\n"
#~ "    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
#~ "    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
#~ "    if fizz.is_empty() && buzz.is_empty() {\n"
#~ "        return format!(\"{n}\");\n"
#~ "    }\n"
#~ "    format!(\"{fizz}{buzz}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn print_fizzbuzz_to(n: u32) {\n"
#~ "    for i in 1..=n {\n"
#~ "        println!(\"{}\", fizzbuzz(i));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    print_fizzbuzz_to(20);\n"
#~ "}\n"
#~ "\n"
#~ "fn is_divisible(n: u32, divisor: u32) -> bool {\n"
#~ "    if divisor == 0 {\n"
#~ "        return false;\n"
#~ "    }\n"
#~ "    n % divisor == 0\n"
#~ "}\n"
#~ "\n"
#~ "fn fizzbuzz(n: u32) -> String {\n"
#~ "    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
#~ "    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
#~ "    if fizz.is_empty() && buzz.is_empty() {\n"
#~ "        return format!(\"{n}\");\n"
#~ "    }\n"
#~ "    format!(\"{fizz}{buzz}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn print_fizzbuzz_to(n: u32) {\n"
#~ "    for i in 1..=n {\n"
#~ "        println!(\"{}\", fizzbuzz(i));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We refer in `main` to a function written below. Neither forward "
#~ "declarations nor headers are necessary. "
#~ msgstr ""
#~ "`main` í•¨ìˆ˜ì—ì„œ ê·¸ ë‹¤ìŒì— ì˜¤ëŠ” í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¯¸ë¦¬ ì„ ì–¸í•˜ê¸°"
#~ "(forward declaration)ë‚˜ í—¤ë” ê°™ì€ê±´ í•„ìš” ì—†ìŠµë‹ˆë‹¤. "

#~ msgid ""
#~ "The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
#~ "`=n`, which causes it to include the upper bound."
#~ msgstr ""
#~ "`fizzbuzz_to()`í•¨ìˆ˜ ë‚´ `for` ë°˜ëª©ë¬¸ì˜ ë²”ìœ„ í‘œí˜„ì‹ ì¤‘ `=n`ì€ nê¹Œì§€ í¬í•¨í•œë‹¤"
#~ "ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "All language items in Rust can be documented using special `///` syntax."
#~ msgstr "Rustì˜ ì•„ì´í…œ(item)ì€ `///` ë¬¸ë²•ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì„œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "/// Determine whether the first argument is divisible by the second "
#~ "argument.\n"
#~ "///\n"
#~ "/// If the second argument is zero, the result is false.\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // Corner case, early return\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // The last expression in a block is the return "
#~ "value\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "/// ì²« ë²ˆì§¸ ì¸ìˆ˜ê°€ ë‘ ë²ˆì§¸ ì¸ìˆ˜ë¡œ ë‚˜ëˆ ì§ˆ ìˆ˜ ìˆëŠ”ì§€ ê²°ì •í•©ë‹ˆë‹¤.\n"
#~ "///\n"
#~ "/// ë‘ ë²ˆì§¸ ì¸ìˆ˜ê°€ 0ì´ë©´ ê²°ê³¼ëŠ” falseì…ë‹ˆë‹¤.\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // Corner case, early return\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // ë¸”ë¡ ì•ˆì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì€ ë°˜í™˜ê°’ì…ë‹ˆë‹¤\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "This course does not include rustdoc on slides, just to save space, but "
#~ "in real code they should be present."
#~ msgstr ""
#~ "ì´ ìŠ¬ë¼ì´ë“œì˜ ì˜ˆì œ ì½”ë“œëŠ” ë¬¸ì„œí™” ì£¼ì„ì´ ìƒëµë˜ì–´ ìˆì§€ë§Œ, ì‹¤ì œ ì½”ë“œë¼ë©´ ë¬¸"
#~ "ì„œí™” ì£¼ì„ì„ ë°˜ë“œì‹œ ì¨ì•¼ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Inner doc comments are discussed later (in the page on modules) and need "
#~ "not be addressed here."
#~ msgstr ""
#~ "ë¬¸ì„œ ë‚´ë¶€ ì£¼ì„ ëª¨ë“ˆ í˜ì´ì§€ ë’·ë¶€ë¶„ì—ì„œ ë‹¤ë£¨ë©° ì—¬ê¸°ì„œ ë‹¤ë£¨ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "Rustdoc comments can contain code snippets that we can run and test using "
#~ "`cargo test`. We will discuss these tests in the [Testing section](../"
#~ "testing/doc-tests.html)."
#~ msgstr ""
#~ "ë¬¸ì„œí™” ì£¼ì„ì€ ì½”ë“œë¥¼ í¬í•¨í•  ìˆ˜ë„ ìˆìœ¼ë©°, ì´ ì½”ë“œëŠ” `cargo test`ë¥¼ í†µí•´ í…Œ"
#~ "ìŠ¤íŠ¸ë¡œ ë™ì‘í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. [í…ŒìŠ¤íŠ¸](../testing/doc-tests.html)ì—ì„œ ë” ì"
#~ "ì„¸íˆ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Methods are functions associated with a type. The `self` argument of a "
#~ "method is an instance of the type it is associated with:"
#~ msgstr ""
#~ "ë©”ì„œë“œëŠ” íŠ¹ì • íƒ€ì…ê³¼ ì—°ê²°ëœ í•¨ìˆ˜ì…ë‹ˆë‹¤. ë©”ì„œë“œì˜ `self` ì¸ìê°€ ê·¸ ë©”ì„œë“œ"
#~ "ê°€ ì—°ê²°ëœ ì¸ìŠ¤í„´ìŠ¤ì˜ íƒ€ì…ì…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Rectangle {\n"
#~ "    width: u32,\n"
#~ "    height: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Rectangle {\n"
#~ "    fn area(&self) -> u32 {\n"
#~ "        self.width * self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inc_width(&mut self, delta: u32) {\n"
#~ "        self.width += delta;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut rect = Rectangle { width: 10, height: 5 };\n"
#~ "    println!(\"old area: {}\", rect.area());\n"
#~ "    rect.inc_width(5);\n"
#~ "    println!(\"new area: {}\", rect.area());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Rectangle {\n"
#~ "    width: u32,\n"
#~ "    height: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Rectangle {\n"
#~ "    fn area(&self) -> u32 {\n"
#~ "        self.width * self.height\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inc_width(&mut self, delta: u32) {\n"
#~ "        self.width += delta;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut rect = Rectangle { width: 10, height: 5 };\n"
#~ "    println!(\"old area: {}\", rect.area());\n"
#~ "    rect.inc_width(5);\n"
#~ "    println!(\"new area: {}\", rect.area());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We will look much more at methods in today's exercise and in tomorrow's "
#~ "class."
#~ msgstr "ì˜¤ëŠ˜ê³¼ ë‚´ì¼ ê°•ì˜ì—ì„œ ë” ë§ì€ ë©”ì„œë“œ ì‚¬ìš©ë²•ì„ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#~ msgid ""
#~ "Add a static method called `Rectangle::new` and call this from `main`:"
#~ msgstr "`Rectangle::new` ìƒì„±ìë¥¼ ì¶”ê°€í•˜ê³  ì´ë¥¼ `main`ì—ì„œ í˜¸ì¶œí•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn new(width: u32, height: u32) -> Rectangle {\n"
#~ "    Rectangle { width, height }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn new(width: u32, height: u32) -> Rectangle {\n"
#~ "    Rectangle { width, height }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "While _technically_, Rust does not have custom constructors, static "
#~ "methods are commonly used to initialize structs (but don't have to). The "
#~ "actual constructor, `Rectangle { width, height }`, could be called "
#~ "directly. See the [Rustnomicon](https://doc.rust-lang.org/nomicon/"
#~ "constructors.html)."
#~ msgstr ""
#~ "\\_ê¸°ìˆ ì _ìœ¼ë¡œ ì´ì•¼ê¸° í•˜ìë©´, ëŸ¬ìŠ¤íŠ¸ëŠ” ì»¤ìŠ¤í…€ ìƒì„±ìë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. "
#~ "ì •ì  ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ êµ¬ì¡°ì²´ë¥¼ ì´ˆê¸°í™” í•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì…ë‹ˆë‹¤ (ë¬¼"
#~ "ë¡  ì´ê²ƒì´ ê°•ì œë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤). ì§„ì§œ ìƒì„±ìì¸ `Rectangle { width, height }"
#~ "`ë¥¼ ì§ì ‘ í˜¸ì¶œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [Rustnomicon](https://doc."
#~ "rust-lang.org/nomicon/constructors.html)ì„ ì°¸ì¡°í•˜ì„¸ìš”."

#~ msgid ""
#~ "Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
#~ "static methods can take arbitrary parameters."
#~ msgstr ""
#~ "`Rectangle::square(width: u32)` ìƒì„±ìë¥¼ ì¶”ê°€í•˜ì—¬ ìƒì„±ìê°€ ì„ì˜ì˜ ë§¤ê°œë³€ìˆ˜"
#~ "ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì„ ë³´ì…ì‹œë‹¤."

#~ msgid "Function Overloading"
#~ msgstr "(í•¨ìˆ˜) ì˜¤ë²„ë¡œë”©"

#~ msgid "Overloading is not supported:"
#~ msgstr "ì˜¤ë²„ë¡œë”©ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#~ msgid "Always takes a fixed number of parameters."
#~ msgstr "í•­ìƒ ê³ ì •ëœ ìˆ˜ì˜ íŒŒë¼ë§¤í„°ë§Œ ê°–ìŠµë‹ˆë‹¤."

#~ msgid "Default values are not supported:"
#~ msgstr "íŒŒë¼ë§¤í„°ì˜ ê¸°ë³¸ ê°’ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#~ msgid "All call sites have the same number of arguments."
#~ msgstr "ëª¨ë“  í˜¸ì¶œë¶€ì—ì„œëŠ” ë™ì¼í•œ ìˆ˜ì˜ ì¸ìë¥¼ ì„¤ì •í•´ì•¼í•©ë‹ˆë‹¤."

#~ msgid "Macros are sometimes used as an alternative."
#~ msgstr "ì´ëŸ° ì‚¬í•­ë“¤ì´ ì œì•½ì´ ë  ê²½ìš°, ëŒ€ì•ˆìœ¼ë¡œ ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ê¸°ë„ í•©ë‹ˆë‹¤."

#~ msgid "However, function parameters can be generic:"
#~ msgstr "í•˜ì§€ë§Œ, í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ëŠ” ì œë„¤ë¦­ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
#~ "    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
#~ "    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "When using generics, the standard library's `Into<T>` can provide a kind "
#~ "of limited polymorphism on argument types. We will see more details in a "
#~ "later section."
#~ msgstr ""
#~ "ì œë„¤ë¦­ì„ ì‚¬ìš©í•  ë•Œ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `Into<T>`ì€ íƒ€ì…ì— ëŒ€í•œ ë‹¤í˜•ì„±ì„ ì œê³µ"
#~ "í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚˜ì¤‘ì— ìì„¸íˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤."

#~ msgid "Day 1: Morning Exercises"
#~ msgstr "1ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#~ msgid "In these exercises, we will explore two parts of Rust:"
#~ msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ë‘ ë¶€ë¶„ì„ ì•Œì•„ë³¼ ê²ƒì…ë‹ˆë‹¤:"

#~ msgid "Implicit conversions between types."
#~ msgstr "íƒ€ì…ì˜ ë¬µì‹œì  ë³€í™˜."

#~ msgid "Arrays and `for` loops."
#~ msgstr "ë°°ì—´ê³¼ `for` ë°˜ë³µë¬¸."

#~ msgid "A few things to consider while solving the exercises:"
#~ msgstr "ì—°ìŠµë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ë° ê³ ë ¤í•´ì•¼ í•  ì‚¬í•­ë“¤:"

#~ msgid ""
#~ "Use a local Rust installation, if possible. This way you can get auto-"
#~ "completion in your editor. See the page about [Using Cargo](../../cargo."
#~ "md) for details on installing Rust."
#~ msgstr ""
#~ "ê°€ëŠ¥í•˜ë‹¤ë©´ ëŸ¬ìŠ¤íŠ¸ê°€ ì„¤ì¹˜ëœ ë¡œì»¬ í™˜ê²½ì—ì„œ ì§„í–‰í•˜ì„¸ìš”. ê·¸ëŸ¬ëŠ” í¸ì´ í…ìŠ¤íŠ¸ ì—"
#~ "ë””í„°ì˜ ìë™ì™„ì„± ê¸°ëŠ¥ì˜ ë„ì›€ì„ ë°›ì„ ìˆ˜ ìˆì–´ì„œ ì¢‹ìŠµë‹ˆë‹¤. [ì¹´ê³  ì‚¬ìš©í•˜ê¸°]"
#~ "(../../cargo.md) ì„ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#~ msgid "Alternatively, use the Rust Playground."
#~ msgstr "í˜¹ì€ ëŸ¬ìŠ¤íŠ¸ í”Œë ˆì´ê·¸ë¼ìš´ë“œë¥¼ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "The code snippets are not editable on purpose: the inline code snippets "
#~ "lose their state if you navigate away from the page."
#~ msgstr ""
#~ "í˜ì´ì§€ ë°–ìœ¼ë¡œ ì´ë™í•  ê²½ìš° ì‘ì„±í•œ ë‚´ìš©ì´ ì†Œì‹¤ë˜ê¸° ë•Œë¬¸ì— ì œê³µë˜ëŠ” ì½”ë“œ ìŠ¤ë‹ˆ"
#~ "í«ì€ ì˜ë„ì ìœ¼ë¡œ í¸ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "After looking at the exercises, you can look at the \\[solutions\\] "
#~ "provided."
#~ msgstr ""
#~ "ì—°ìŠµë¬¸ì œë¥¼ ì‚´í´ ë³¸ í›„, ì œê³µëœ \\[í•´ë‹µ\\]\\[solutions\\]ì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "Rust will not automatically apply _implicit conversions_ between types "
#~ "([unlike C++](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion)). You can see this in a program like this:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ëŠ” [C++ ì™€ ë‹¤ë¥´ê²Œ](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion) íƒ€ì… ê°„ _ë¬µì‹œì  ë³€í™˜_ì„ ìë™ìœ¼ë¡œ ì ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. "
#~ "ì•„ë˜ ì˜ˆì‹œë¥¼ í™•ì¸í•´ ë³´ì„¸ìš”:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn multiply(x: i16, y: i16) -> i16 {\n"
#~ "    x * y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x: i8 = 15;\n"
#~ "    let y: i16 = 1000;\n"
#~ "\n"
#~ "    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn multiply(x: i16, y: i16) -> i16 {\n"
#~ "    x * y\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x: i8 = 15;\n"
#~ "    let y: i16 = 1000;\n"
#~ "\n"
#~ "    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The Rust integer types all implement the [`From<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.Into.html) traits to let us convert between "
#~ "them. The `From<T>` trait has a single `from()` method and similarly, the "
#~ "`Into<T>` trait has a single `into()` method. Implementing these traits "
#~ "is how a type expresses that it can be converted into another type."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì˜ ì •ìˆ˜í˜• íƒ€ì…ì€ ëª¨ë‘ [`From<T>`](https://doc.rust-lang.org/std/"
#~ "convert/trait.From.html) ì™€ [`Into<T>`](https://doc.rust-lang.org/std/"
#~ "convert/trait.Into.html) íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ê³  ìˆìœ¼ë©°, ì´ë¥¼ í†µí•´ íƒ€ì… ë³€í™˜ì´ "
#~ "ì´ë£¨ì–´ ì§‘ë‹ˆë‹¤. `From<T>` íŠ¸ë ˆì‡ì€ `from()` ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆê³ , `Into<T>`"
#~ "íŠ¸ë ˆì‡ì€ `into()` ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” `From`ê³¼ `Into` "
#~ "íŠ¸ë ˆì‡ì„ êµ¬í˜„í•¨ìœ¼ë¡œì¨, íƒ€ì… ê°„ ë³€í™˜ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ í‘œí˜„í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "The standard library has an implementation of `From<i8> for i16`, which "
#~ "means that we can convert a variable `x` of type `i8` to an `i16` by "
#~ "calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> "
#~ "for i16` implementation automatically create an implementation of "
#~ "`Into<i16> for i8`."
#~ msgstr ""
#~ "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” `From<i8> for i16`ê°€ êµ¬í˜„ë˜ì–´ ìˆëŠ”ë° ì´ê²ƒì€ `i8` íƒ€ì…"
#~ "ì˜ ë³€ìˆ˜ `x`ë¥¼ `i16::from(x)`ë¥¼ í˜¸ì¶œí•˜ì—¬ `i16`íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜"
#~ "ë¯¸ì…ë‹ˆë‹¤. í˜¹ì€ ë” ê°„ë‹¨í•˜ê²Œ `x.into()`ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì´ ê°€ëŠ¥"
#~ "í•œ ì´ìœ ëŠ” `From<i8> for i16` êµ¬í˜„ì„ ê°€ì§€ê³  ìˆìœ¼ë©´ `Into<i16> for i8` êµ¬í˜„"
#~ "ì´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "The same applies for your own `From` implementations for your own types, "
#~ "so it is sufficient to only implement `From` to get a respective `Into` "
#~ "implementation automatically."
#~ msgstr ""
#~ "ì´ëŠ” ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì—ë„ ë™ì¼í•˜ê²Œ ì ìš©ë˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤. ë”°ë¼ì„œ `From`ë§Œì„ "
#~ "êµ¬í˜„í•´ë„ `Into`ê¹Œì§€ ìë™ìœ¼ë¡œ êµ¬í˜„ì´ ë©ë‹ˆë‹¤."

#~ msgid "Execute the above program and look at the compiler error."
#~ msgstr "ìœ„ ì˜ˆì œì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  ì–´ë–¤ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”."

#~ msgid "Update the code above to use `into()` to do the conversion."
#~ msgstr "`into()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì„¸ìš”."

#~ msgid ""
#~ "Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
#~ "`i128`) to see which types you can convert to which other types. Try "
#~ "converting small types to big types and the other way around. Check the "
#~ "[standard library documentation](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html) to see if `From<T>` is implemented for the pairs you "
#~ "check."
#~ msgstr ""
#~ "`x`ì™€ `y`ë¥¼ `f32`ì´ë‚˜ `bool`, `i128` ë“±ìœ¼ë¡œ ë°”ê¿”ì„œ í•´ë‹¹ íƒ€ì…ë“¤ë¡œ ë³€í™˜ì´ ë˜"
#~ "ëŠ”ì§€ í™•ì¸í•´ë³´ì„¸ìš”. ì‘ì€ ì‚¬ì´ì¦ˆ íƒ€ì…ì—ì„œ í° ì‚¬ì´ì¦ˆë¡œ ë³€ê²½í•´ë³´ì‹œê³  ê·¸ ë°˜ëŒ€ë¡œ"
#~ "ë„ í•´ë³´ì„¸ìš”. [í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html)ì—ì„œ ì‹œë„í•´ ë³¸ ì¼€ì´ìŠ¤ê°€ êµ¬í˜„ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”."

#~ msgid "Arrays and `for` Loops"
#~ msgstr "ë°°ì—´ê³¼ `for`ë°˜ë³µë¬¸"

#~ msgid "We saw that an array can be declared like this:"
#~ msgstr "ë°°ì—´ì„ ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸ í•  ìˆ˜ ìˆìŒì„ ë°°ì› ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust\n"
#~ "let array = [10, 20, 30];\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let array = [10, 20, 30];\n"
#~ "```"

#~ msgid ""
#~ "You can print such an array by asking for its debug representation with "
#~ "`{:?}`:"
#~ msgstr "ë°°ì—´ì„ ì¶œë ¥í•˜ë ¤ë©´ `{:?}`ë¥¼ ì”ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    println!(\"array: {array:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    println!(\"array: {array:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Rust lets you iterate over things like arrays and ranges using the `for` "
#~ "keyword:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” `for` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ ë°°ì—´ì´ë‚˜ ë²”ìœ„ë¥¼ ë°˜ë³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    print!(\"Iterating over array:\");\n"
#~ "    for n in array {\n"
#~ "        print!(\" {n}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "\n"
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    print!(\"Iterating over array:\");\n"
#~ "    for n in array {\n"
#~ "        print!(\" {n}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "\n"
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ "           â›â¡1 2 3â¤â      â¡1 4 7â¤\n"
#~ "\"transpose\"âœâ¢4 5 6â¥âŸ  \"==\"â¢2 5 8â¥\n"
#~ "           ââ£7 8 9â¦â       â£3 6 9â¦\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ "           â›â¡1 2 3â¤â      â¡1 4 7â¤\n"
#~ "\"transpose\"âœâ¢4 5 6â¥âŸ  \"==\"â¢2 5 8â¥\n"
#~ "           ââ£7 8 9â¦â       â£3 6 9â¦\n"
#~ "```"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "\n"
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);\n"
#~ "\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: êµ¬í˜„ì´ ì™„ë£Œë˜ë©´ ì•„ë˜ ì¤„ì€ ì‚­ì œí•©ë‹ˆë‹¤.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "\n"
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);\n"
#~ "\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"

#~ msgid "Bonus Question"
#~ msgstr "ë³´ë„ˆìŠ¤ ë¬¸ì œ"

#~ msgid ""
#~ "Could you use `&[i32]` slices instead of hard-coded 3 Ã— 3 matrices for "
#~ "your argument and return types? Something like `&[&[i32]]` for a two-"
#~ "dimensional slice-of-slices. Why or why not?"
#~ msgstr ""
#~ "`&[i32]`ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì˜ ì´ìš©í•˜ë©´ í–‰ë ¬ í¬ê¸°ë¥¼ 3 x 3ìœ¼ë¡œ í•˜ë“œì½”ë”© í•˜ì§€ ì•Šì„ "
#~ "ìˆ˜ ìˆì„ê¹Œìš”? ì˜ˆì»¨ë° `&[&[i32]]`ëŠ” 2ì°¨ì› ìŠ¬ë¼ì´ìŠ¤ì˜ ìŠ¬ë¼ì´ìŠ¤ ì…ë‹ˆë‹¤. ê°€ëŠ¥í•˜"
#~ "ë‹¤ë©´/í•˜ì§€ ì•Šë‹¤ë©´ ì™œ ê·¸ëŸ°ê°€ìš”?"

#~ msgid ""
#~ "See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
#~ "quality implementation."
#~ msgstr ""
#~ "ìƒìš© í’ˆì§ˆì˜ êµ¬í˜„ì— ëŒ€í•´ì„œëŠ” [`ndarray` í¬ë ˆì´íŠ¸](https://docs.rs/ndarray/)"
#~ "ë¥¼ ì°¸ì¡°í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."

#~ msgid ""
#~ "The solution and the answer to the bonus section are available in the  "
#~ "[Solution](solutions-morning.md#arrays-and-for-loops) section."
#~ msgstr ""
#~ "ë³´ë„ˆìŠ¤ ë¬¸ì œì— ëŒ€í•œ ë‹µë³€ ì—­ì‹œ [í•´ë‹µ](solutions-morning.md#arrays-and-for-"
#~ "loops)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x: i32 = 10;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    // x = 20;\n"
#~ "    // println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x: i32 = 10;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    // x = 20;\n"
#~ "    // println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Due to type inference the `i32` is optional. We will gradually show the "
#~ "types less and less as the course progresses."
#~ msgstr ""
#~ "íƒ€ì… ì¶”ë¡ ì— ë•ë¶„ì— `i32`ëŠ” ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê°•ì˜ê°€ ì§„í–‰ë  ìˆ˜ë¡ ìƒëµ ê°€ëŠ¥"
#~ "í•œ ë¶€ë¶„ì€ ì ì  ìƒëµí•  ê²ƒì…ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn takes_u32(x: u32) {\n"
#~ "    println!(\"u32: {x}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn takes_i8(y: i8) {\n"
#~ "    println!(\"i8: {y}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = 10;\n"
#~ "    let y = 20;\n"
#~ "\n"
#~ "    takes_u32(x);\n"
#~ "    takes_i8(y);\n"
#~ "    // takes_u32(y);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn takes_u32(x: u32) {\n"
#~ "    println!(\"u32: {x}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn takes_i8(y: i8) {\n"
#~ "    println!(\"i8: {y}\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = 10;\n"
#~ "    let y = 20;\n"
#~ "\n"
#~ "    takes_u32(x);\n"
#~ "    takes_i8(y);\n"
#~ "    // takes_u32(y);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The following code tells the compiler to copy into a certain generic "
#~ "container without the code ever explicitly specifying the contained type, "
#~ "using `_` as a placeholder:"
#~ msgstr ""
#~ "ì•„ë˜ ì½”ë“œëŠ”, ì œë„¤ë¦­ ì»¨í…Œì´ë„ˆë¥¼ ì“¸ ë•Œ ì»¨í…Œì´í„° ì•ˆì— í¬í•¨ëœ ë°ì´í„°ì˜ íƒ€ì…ì„ "
#~ "ëª…ì‹œì ìœ¼ë¡œ ì“°ì§€ ì•Šê³  `_`ë¡œ ëŒ€ì²´í•˜ì—¬ë„ ëœë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push((10, false));\n"
#~ "    v.push((20, true));\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "\n"
#~ "    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
#~ "    println!(\"vv: {vv:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push((10, false));\n"
#~ "    v.push((20, true));\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "\n"
#~ "    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
#~ "    println!(\"vv: {vv:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
#~ "std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-"
#~ "lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
#~ "HashSet%3CT,+S%3E) implements."
#~ msgstr ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect)ëŠ” [`HashSet`](https://doc.rust-lang.org/std/"
#~ "collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-HashSet%3CT,"
#~ "+S%3E)ì„ êµ¬í˜„í•œ [`FromIterator`](https://doc.rust-lang.org/std/iter/trait."
#~ "FromIterator.html)ì— ì˜ì¡´í•©ë‹ˆë‹¤."

#~ msgid "Static and Constant Variables"
#~ msgstr "ì •ì ë³€ìˆ˜(static)ê³¼ ìƒìˆ˜(const)"

#~ msgid ""
#~ "```rust,editable\n"
#~ "const DIGEST_SIZE: usize = 3;\n"
#~ "const ZERO: Option<u8> = Some(42);\n"
#~ "\n"
#~ "fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
#~ "    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
#~ "    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
#~ "        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
#~ "wrapping_add(b);\n"
#~ "    }\n"
#~ "    digest\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let digest = compute_digest(\"Hello\");\n"
#~ "    println!(\"Digest: {digest:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "const DIGEST_SIZE: usize = 3;\n"
#~ "const ZERO: Option<u8> = Some(42);\n"
#~ "\n"
#~ "fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
#~ "    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
#~ "    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
#~ "        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
#~ "wrapping_add(b);\n"
#~ "    }\n"
#~ "    digest\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let digest = compute_digest(\"Hello\");\n"
#~ "    println!(\"Digest: {digest:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"{BANNER}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"{BANNER}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");\n"
#~ "\n"
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");\n"
#~ "\n"
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");\n"
#~ "\n"
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");\n"
#~ "\n"
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The following code demonstrates why the compiler can't simply reuse "
#~ "memory locations when shadowing an immutable variable in a scope, even if "
#~ "the type does not change."
#~ msgstr ""
#~ "ì•„ë˜ ì½”ë“œëŠ” ë¶ˆë³€ ë³€ìˆ˜ë¥¼ ì‰ë„ì‰í•  ë•Œ íƒ€ì…ì´ ë™ì¼í•˜ë”ë¼ë„ ìƒˆ ë³€ìˆ˜ê°€ ì›ë˜ ë³€"
#~ "ìˆ˜ì˜ ë©”ëª¨ë¦¬ ìœ„ì¹˜ë¥¼ ì¬ì‚¬ìš© í•  ìˆ˜ ì—†ëŠ”ì§€ ê·¸ ì´ìœ ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 1;\n"
#~ "    let b = &a;\n"
#~ "    let a = a + 1;\n"
#~ "    println!(\"{a} {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 1;\n"
#~ "    let b = &a;\n"
#~ "    let a = a + 1;\n"
#~ "    println!(\"{a} {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "First, let's refresh how memory management works."
#~ msgstr "ìš°ì„  ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ì´ë¤„ì§€ëŠ” ë°©ì‹ì„ ë‹¤ì‹œ ì‚´í´ ë³´ê² ìŠµë‹ˆë‹¤."

#~ msgid "The Stack vs The Heap"
#~ msgstr "ìŠ¤íƒ(Stack)ê³¼ í™(Heap)"

#~ msgid "Stack and Heap Example"
#~ msgstr "ìŠ¤íƒê³¼ í™ì— ê´€í•œ ì˜ˆì œ"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1 = String::from(\"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1 = String::from(\"Hello\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::from(\"Hello\");\n"
#~ "    s1.push(' ');\n"
#~ "    s1.push_str(\"world\");\n"
#~ "    // DON'T DO THIS AT HOME! For educational purposes only.\n"
#~ "    // String provides no guarantees about its layout, so this could lead "
#~ "to\n"
#~ "    // undefined behavior.\n"
#~ "    unsafe {\n"
#~ "        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
#~ "transmute(s1);\n"
#~ "        println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
#~ "{capacity}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::from(\"Hello\");\n"
#~ "    s1.push(' ');\n"
#~ "    s1.push_str(\"world\");\n"
#~ "    // DON'T DO THIS AT HOME! For educational purposes only.\n"
#~ "    // String provides no guarantees about its layout, so this could lead "
#~ "to\n"
#~ "    // undefined behavior.\n"
#~ "    unsafe {\n"
#~ "        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
#~ "transmute(s1);\n"
#~ "        println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
#~ "{capacity}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "You allocate and deallocate heap memory yourself."
#~ msgstr "ì‚¬ìš©ìê°€ ì§ì ‘ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹, í•´ì œ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "If not done with care, this can lead to crashes, bugs, security "
#~ "vulnerabilities, and memory leaks."
#~ msgstr ""
#~ "ì¡°ì‹¬í•˜ì§€ ì•Šìœ¼ë©´, ì¶©ëŒ(crash), ë²„ê·¸, ë³´ì•ˆì·¨ì•½ì„± ë° ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ë°œìƒí•  ìˆ˜ "
#~ "ìˆìŠµë‹ˆë‹¤."

#~ msgid "C Example"
#~ msgstr "C ì–¸ì–´ ì˜ˆì œ"

#~ msgid "You must call `free` on every pointer you allocate with `malloc`:"
#~ msgstr "`malloc`ìœ¼ë¡œ í• ë‹¹í•˜ëŠ” í¬ì¸í„°ë§ˆë‹¤ `free`ë¥¼ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```c\n"
#~ "void foo(size_t n) {\n"
#~ "    int* int_array = malloc(n * sizeof(int));\n"
#~ "    //\n"
#~ "    // ... lots of code\n"
#~ "    //\n"
#~ "    free(int_array);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c\n"
#~ "void foo(size_t n) {\n"
#~ "    int* int_array = malloc(n * sizeof(int));\n"
#~ "    //\n"
#~ "    // ... lots of code\n"
#~ "    //\n"
#~ "    free(int_array);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Memory is leaked if the function returns early between `malloc` and "
#~ "`free`: the pointer is lost and we cannot deallocate the memory. Worse, "
#~ "freeing the pointer twice, or accessing a freed pointer can lead to "
#~ "exploitable security vulnerabilities."
#~ msgstr ""
#~ "ë§Œì•½ `malloc` ê³¼ `free` ì‚¬ì´ì—ì„œ í•¨ìˆ˜ê°€ ì¼ì° ë°˜í™˜ë˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ì¼ì–´ë‚©"
#~ "ë‹ˆë‹¤: í¬ì¸í„°ë¥¼ ìƒì–´ë²„ë¦¬ê²Œ ë˜ì–´ ë©”ëª¨ë¦¬ë¥¼ ë°˜í™˜í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤. ê°™ì€ í¬ì¸í„°"
#~ "ë¥¼ ë‘ ë²ˆ ë°˜í™˜í•˜ê±°ë‚˜, ì´ë¯¸ ë°˜í™˜ëœ í¬ì¸í„°ë¥¼ ì ‘ê·¼í•˜ëŠ” ê²ƒì€ ì‹¬ê°í•œ ë³´ì•ˆ ë¬¸ì œ"
#~ "ë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Constructors and destructors let you hook into the lifetime of an object."
#~ msgstr ""
#~ "ìƒì„±ìì™€ ì†Œë©¸ìë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ì˜ ìƒëª…ì£¼ê¸°ì— ë”°ë¼ ë©”ëª¨ë¦¬ í• ë‹¹/í•´ì œê°€ ì¼ì–´"
#~ "ë‚˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "By wrapping a pointer in an object, you can free memory when the object "
#~ "is destroyed. The compiler guarantees that this happens, even if an "
#~ "exception is raised."
#~ msgstr ""
#~ "í¬ì¸í„°ë¥¼ ê°ì²´ë¡œ ê°ì‹¸ë„ë¡ í•˜ë©´, ê·¸ ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ê·¸ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”"
#~ "ëª¨ë¦¬ê°€ í•´ì œë˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ë°˜ë“œì‹œ ì†Œë©¸"
#~ "ìê°€ í˜¸ì¶œë˜ëŠ” ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤. ì‹¬ì§€ì–´ëŠ” ì˜ˆì™¸(exception)ê°€ ë°œìƒ(_ì—­ì£¼_: í•¨"
#~ "ìˆ˜ì˜ ë¦¬í„´ì´ë‚˜ ìŠ¤ì½”í”„ì˜ ì¢…ë£Œ ë¿ë§Œì´ ì•„ë‹ˆë¼) í•˜ë”ë¼ë„ìš”."

#~ msgid ""
#~ "This is often called _resource acquisition is initialization_ (RAII) and "
#~ "gives you smart pointers."
#~ msgstr ""
#~ "ì´ë¥¼ ì¢…ì¢… RAII (Resource Acquisition Is Initialization)ë¼ê³  í•˜ë©°, ì´ëŸ° ê°"
#~ "ì²´ëŠ” ì¼ì¢…ì˜ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì—­í• ì„ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "```c++\n"
#~ "void say_hello(std::unique_ptr<Person> person) {\n"
#~ "  std::cout << \"Hello \" << person->name << std::endl;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "void say_hello(std::unique_ptr<Person> person) {\n"
#~ "  std::cout << \"Hello \" << person->name << std::endl;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The `std::unique_ptr` object is allocated on the stack, and points to "
#~ "memory allocated on the heap."
#~ msgstr ""
#~ "`std::unique_ptr`ê°ì²´ëŠ” ìŠ¤íƒì— í• ë‹¹ë˜ë©°, í™ì— í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤."

#~ msgid ""
#~ "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
#~ msgstr "`say_hello`í•¨ìˆ˜ê°€ ëë‚˜ë©´ `std::unique_ptr`ì˜ ì†Œë©¸ìê°€ ì‹¤í–‰ë©ë‹ˆë‹¤."

#~ msgid "The destructor frees the `Person` object it points to."
#~ msgstr "ì†Œë©¸ìëŠ” `Person` ê°ì²´ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Special move constructors are used when passing ownership to a function:"
#~ msgstr "ì´ë™ ìƒì„±ìëŠ” í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ì†Œìœ ê¶Œì„ ì „ë‹¬í• ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```c++\n"
#~ "std::unique_ptr<Person> person = find_person(\"Carla\");\n"
#~ "say_hello(std::move(person));\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "std::unique_ptr<Person> person = find_person(\"Carla\");\n"
#~ "say_hello(std::move(person));\n"
#~ "```"

#~ msgid ""
#~ "An alternative to manual and scope-based memory management is automatic "
#~ "memory management:"
#~ msgstr ""
#~ "ìˆ˜ë™, ìŠ¤ì½”í”„ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ì˜ ëŒ€ì•ˆìœ¼ë¡œ ìë™ ë©”ëª¨ë¦¬ ê´€ë¦¬ ë°©ì‹ì´ ìˆìŠµë‹ˆë‹¤:"

#~ msgid "The programmer never allocates or deallocates memory explicitly."
#~ msgstr "ê°œë°œìëŠ” ë©”ëª¨ë¦¬ë¥¼ ëª…ì‹œì ìœ¼ë¡œ í• ë‹¹/í•´ì œ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "A garbage collector finds unused memory and deallocates it for the "
#~ "programmer."
#~ msgstr "ê°€ë¹„ì§€ ì»¬ë ‰í„°(GC)ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ë¥¼ ì°¾ì•„ í•´ì œí•©ë‹ˆë‹¤."

#~ msgid "Java Example"
#~ msgstr "Java ì˜ˆì œ"

#~ msgid "The `person` object is not deallocated after `sayHello` returns:"
#~ msgstr ""
#~ "`person`ê°ì²´ëŠ” `sayHello`í•¨ìˆ˜ ë°˜í™˜ í›„ì—ë„ í•´ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (_ì—­ì£¼_: GC"
#~ "ê°€ ë‚˜ì¤‘ì— ì•Œì•„ì„œ í•´ì œí•©ë‹ˆë‹¤.)"

#~ msgid ""
#~ "```java\n"
#~ "void sayHello(Person person) {\n"
#~ "  System.out.println(\"Hello \" + person.getName());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "void sayHello(Person person) {\n"
#~ "  System.out.println(\"Hello \" + person.getName());\n"
#~ "}\n"
#~ "```"

#~ msgid "Memory Management in Rust"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬"

#~ msgid "Memory management in Rust is a mix:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ëŠ” ì§€ê¸ˆê¹Œì§€ ì„¤ëª…í•œ ë°©ì‹ë“¤ì„ í˜¼í•©í•´ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#~ msgid "Safe and correct like Java, but without a garbage collector."
#~ msgstr "ìë°”ì²˜ëŸ¼ ì•ˆì „í•˜ê³  ì •í™•í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ GCëŠ” ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Depending on which abstraction (or combination of abstractions) you "
#~ "choose, can be a single unique pointer, reference counted, or atomically "
#~ "reference counted."
#~ msgstr ""
#~ "ë‹¤ì–‘í•œ ì¶”ìƒí™”ë¥¼ ì œê³µí•©ë‹ˆë‹¤: ë‹¨ì¼ í¬ì¸í„°, ì°¸ì¡° ì¹´ìš´íŠ¸, ì•„í† ë¯¹(atomic) ì°¸ì¡° "
#~ "ì¹´ìš´íŠ¸."

#~ msgid "Scope-based like C++, but the compiler enforces full adherence."
#~ msgstr ""
#~ "C++ ì²˜ëŸ¼ ë²”ìœ„(ìŠ¤ì½”í”„) ê¸°ë°˜ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì»´íŒŒì¼ëŸ¬ê°€ í›¨ì”¬ ë” ì—„ê²©í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "A Rust user can choose the right abstraction for the situation, some even "
#~ "have no cost at runtime like C."
#~ msgstr ""
#~ "ì‚¬ìš©ìëŠ” ìƒí™©ì— ë”°ë¼ ì í•©í•œ ì¶”ìƒí™”ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ ì¤‘ì—ëŠ” C ì–¸ì–´ "
#~ "ì²˜ëŸ¼ ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ì—†ëŠ” ê²ƒë„ ìˆìŠµë‹ˆë‹¤."

#~ msgid "Rust achieves this by modeling _ownership_ explicitly."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ëŠ” \\_ì†Œìœ ê¶Œ_ì„ ì–¸ì–´ ì°¨ì›ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ëª¨ë¸ë§ í•¨ìœ¼ë¡œì¨ ì´ë¥¼ ì´ë£¹ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "If asked how at this point, you can mention that in Rust this is usually "
#~ "handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
#~ "boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct."
#~ "Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
#~ "(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
#~ "ownership and memory allocation via various means, and prevent the "
#~ "potential errors in C."
#~ msgstr ""
#~ "ì´ ì‹œì ì—ì„œ ê·¸ê²Œ ì–´ë–»ê²Œ ê°€ëŠ¥í•˜ëƒëŠ” ì§ˆë¬¸ì´ ìˆìœ¼ë©´, ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì´ ì‘ì—…ì€ ì¼"
#~ "ë°˜ì ìœ¼ë¡œ [Box](https://doc.rust-lang.org/std/boxed/struct.Box.html), [Vec]"
#~ "(https://doc.rust-lang.org/std/vec/struct.Vec.html), [Rc](https://doc."
#~ "rust-lang.org/std/rc/struct.Rc.html) ë˜ëŠ” [Arc](https://doc.rust-lang.org/"
#~ "std/sync/struct.Arc.html)ì™€ ê°™ì€ RAII íƒ€ì…ì— ì˜í•´ ì²˜ë¦¬ëœë‹¤ê³  ë‹µë³€í•  ìˆ˜ ìˆ"
#~ "ìŠµë‹ˆë‹¤. ì´ë“¤ì€ ë‹¤ì–‘í•œ ë°©ë²•ì„ í†µí•´ ì†Œìœ ê¶Œê³¼ ë©”ëª¨ë¦¬ í• ë‹¹ì— ëŒ€í•œ êµ¬ì²´ì ì¸ ë‚´"
#~ "ìš©ì„ì„ ìº¡ìŠí™”í•˜ì—¬, C ì–¸ì–´ì˜€ë‹¤ë©´ ë°œìƒí•  ìˆ˜ ìˆì—ˆì„ ë‹¤ì–‘í•œ ì—ëŸ¬ë¥¼ ë§‰ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "You may be asked about destructors here, the [Drop](https://doc.rust-lang."
#~ "org/std/ops/trait.Drop.html) trait is the Rust equivalent."
#~ msgstr ""
#~ "ì†Œë©¸ìì— ëŒ€í•œ ì§ˆë¬¸ë„ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. [Drop](https://doc.rust-lang.org/"
#~ "std/ops/trait.Drop.html) íŠ¸ë ˆì‡ì´ ë‹µì…ë‹ˆë‹¤."

#~ msgid "Here is a rough comparison of the memory management techniques."
#~ msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ìˆ ì˜ ëŒ€ëµì ì¸ ë¹„êµì…ë‹ˆë‹¤."

#~ msgid "Pros of Different Memory Management Techniques"
#~ msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬ ë°©ë²• ë³„ ì¥ì "

#~ msgid "Manual like C:"
#~ msgstr "Cì™€ ê°™ì€ ìˆ˜ë™ ê´€ë¦¬:"

#~ msgid "No runtime overhead."
#~ msgstr "ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œê°€ ì—†ìŒ."

#~ msgid "Automatic like Java:"
#~ msgstr "JAVAì™€ ê°™ì€ ìë™í™” ê´€ë¦¬:"

#~ msgid "Fully automatic."
#~ msgstr "ì™„ì „í•œ ìë™í™”."

#~ msgid "Safe and correct."
#~ msgstr "ì•ˆì „í•˜ê³  ì •í™•í•¨."

#~ msgid "Scope-based like C++:"
#~ msgstr "C++ ì™€ ê°™ì€ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬:"

#~ msgid "Partially automatic."
#~ msgstr "ë¶€ë¶„ ìë™í™”."

#~ msgid "Compiler-enforced scope-based like Rust:"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ì™€ ê°™ì€ ì»´íŒŒì¼ëŸ¬ ìˆ˜í–‰ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬:"

#~ msgid "Enforced by compiler."
#~ msgstr "ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìˆ˜í–‰ë©ë‹ˆë‹¤."

#~ msgid "Cons of Different Memory Management Techniques"
#~ msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬ ë°©ë²• ë³„ ë‹¨ì "

#~ msgid "Use-after-free."
#~ msgstr "ì‚¬ìš© í›„ í•´ì œ ë¬¸ì œ."

#~ msgid "Double-frees."
#~ msgstr "ì´ì¤‘ í•´ì œ ë¬¸ì œ."

#~ msgid "Memory leaks."
#~ msgstr "ë©”ëª¨ë¦¬ ëˆ„ì¶œ ë¬¸ì œ."

#~ msgid "Garbage collection pauses."
#~ msgstr "GCë™ì‘ìœ¼ë¡œ ì¸í•œ ë©ˆì¶¤."

#~ msgid "Destructor delays."
#~ msgstr ""
#~ "ì†Œë©¸ì ì§€ì—° (_ì—­ì£¼_: íŠ¹ì • ë©”ëª¨ë¦¬ë¥¼ ë”ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šë”ë¼ë„ ê³§ë°”ë¡œ í•´ì œ ë˜"
#~ "ì§€ ì•Šê³  GCê°€ ë™ì‘í•  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•œë‹¤ëŠ” ì )"

#~ msgid "Complex, opt-in by programmer (on C++)."
#~ msgstr "ë³µì¡í•˜ë©°, ê°œë°œìì˜ ì„ íƒì‚¬í•­ì„."

#~ msgid "Circular references can lead to memory leaks"
#~ msgstr "ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•¨"

#~ msgid "Potential runtime overhead"
#~ msgstr "ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ ìˆì„ ìˆ˜ ìˆìŒ"

#~ msgid "Compiler-enforced and scope-based like Rust:"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ì™€ ê°™ì€ ì»´íŒŒì¼ëŸ¬ê°€ ê°•ì œí•˜ëŠ” ìˆ˜í–‰ ë²”ìœ„ ê¸°ë°˜ ê´€ë¦¬:"

#~ msgid "Some upfront complexity."
#~ msgstr "ì²˜ìŒì— ë°°ìš¸ ë•Œ ì–´ë ¤ì›€."

#~ msgid "Can reject valid programs."
#~ msgstr "ì˜¬ë°”ë¥¸ í”„ë¡œê·¸ë¨ì´ë”ë¼ë„ ì»´íŒŒì¼ëŸ¬ê°€ ê±°ë¶€í•  ìˆ˜ ìˆìŒ."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    {\n"
#~ "        let p = Point(3, 4);\n"
#~ "        println!(\"x: {}\", p.0);\n"
#~ "    }\n"
#~ "    println!(\"y: {}\", p.1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    {\n"
#~ "        let p = Point(3, 4);\n"
#~ "        println!(\"x: {}\", p.0);\n"
#~ "    }\n"
#~ "    println!(\"y: {}\", p.1);\n"
#~ "}\n"
#~ "```"

#~ msgid "A destructor can run here to free up resources."
#~ msgstr ""
#~ "ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë  ë•Œ ë‹¤ë¥¸ ë¦¬ì†ŒìŠ¤ë¥¼ í•´ì œí•˜ê¸° ìœ„í•´ ì†Œë©¸ìê°€ í˜¸ì¶œë˜ë„ë¡ í•  ìˆ˜ "
#~ "ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Hello!\");\n"
#~ "    let s2: String = s1;\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    // println!(\"s1: {s1}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Hello!\");\n"
#~ "    let s2: String = s1;\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    // println!(\"s1: {s1}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "There is always _exactly_ one variable binding which owns a value."
#~ msgstr "ê°’(ë°ì´í„°)ì˜ ì†Œìœ ê¶Œì„ ê°–ëŠ” ë³€ìˆ˜ëŠ” í•­ìƒ _ë‹¨_ í•˜ë‚˜ ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Rust\");\n"
#~ "    let s2: String = s1;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Rust\");\n"
#~ "    let s2: String = s1;\n"
#~ "}\n"
#~ "```"

#~ msgid "The heap data from `s1` is reused for `s2`."
#~ msgstr "`s1`ì˜ í™ ë°ì´í„°ëŠ” `s2`ì—ì„œ ì¬ì‚¬ìš© ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "When `s1` goes out of scope, nothing happens (it has been moved from)."
#~ msgstr ""
#~ "`s1`ì˜ ìŠ¤ì½”í”„ê°€ ì¢…ë£Œë˜ë©´ ì•„ë¬´ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.(ì´ë¯¸ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.)"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
#~ ":                           :     :                           :\n"
#~ ":    s1                     :     :                           :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
#~ ":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
#~ ":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
#~ ":   | capacity  |     4 |   :     :                           :\n"
#~ ":   +-----------+-------+   :     :                           :\n"
#~ ":                           :     `- - - - - - - - - - - - - -'\n"
#~ ":                           :\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
#~ ":                           :     :                           :\n"
#~ ":    s1                     :     :                           :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
#~ ":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
#~ ":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
#~ ":   | capacity  |     4 |   :     :                           :\n"
#~ ":   +-----------+-------+   :     :                           :\n"
#~ ":                           :     `- - - - - - - - - - - - - -'\n"
#~ ":                           :\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid "Extra Work in Modern C++"
#~ msgstr "Modern C++ì—ì„œ ì´ì¤‘í•´ì œ ë¬¸ì œ"

#~ msgid ""
#~ "```c++\n"
#~ "std::string s1 = \"Cpp\";\n"
#~ "std::string s2 = s1;  // Duplicate the data in s1.\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "std::string s1 = \"Cpp\";\n"
#~ "std::string s2 = s1;  // s1ì˜ ë°ì´í„°ë¥¼ ë³µì œí•©ë‹ˆë‹¤.\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     :                       :\n"
#~ ":    s2                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ " Stack                             Heap\n"
#~ ".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
#~ ":                           :     :                       :\n"
#~ ":    s1                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     :                       :\n"
#~ ":    s2                     :     :                       :\n"
#~ ":   +-----------+-------+   :     :   +----+----+----+    :\n"
#~ ":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
#~ ":   | len       |     3 |   :     :   +----+----+----+    :\n"
#~ ":   | capacity  |     3 |   :     :                       :\n"
#~ ":   +-----------+-------+   :     :                       :\n"
#~ ":                           :     `- - - - - - - - - - - -'\n"
#~ "`- - - - - - - - - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = String::from(\"Alice\");\n"
#~ "    say_hello(name);\n"
#~ "    // say_hello(name);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = String::from(\"Alice\");\n"
#~ "    say_hello(name);\n"
#~ "    // say_hello(name);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = 42;\n"
#~ "    let y = x;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    println!(\"y: {y}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = 42;\n"
#~ "    let y = x;\n"
#~ "    println!(\"x: {x}\");\n"
#~ "    println!(\"y: {y}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Copy, Clone, Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = p1;\n"
#~ "    println!(\"p1: {p1:?}\");\n"
#~ "    println!(\"p2: {p2:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Copy, Clone, Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = p1;\n"
#~ "    println!(\"p1: {p1:?}\");\n"
#~ "    println!(\"p2: {p2:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "If students ask about `derive`, it is sufficient to say that this is a "
#~ "way to generate code in Rust at compile time. In this case the default "
#~ "implementations of `Copy` and `Clone` traits are generated."
#~ msgstr ""
#~ "ë§Œì•½ í•™ìƒë“¤ì´ `derive`ì— ëŒ€í•´ ë¬»ëŠ”ë‹¤ë©´, ì»´íŒŒì¼ ì‹œ ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì½”ë“œë¥¼ ìƒì„±í•˜"
#~ "ëŠ”ë°©ë²•ì´ë¼ê³  ë§í•˜ëŠ” ê²ƒìœ¼ë¡œ ì¶©ë¶„í•©ë‹ˆë‹¤. ìœ„ ê²½ìš° `Copy`ì™€ `Clone` íŠ¸ë ˆì‡ì— "
#~ "ëŒ€í•œ ê¸°ë³¸ êµ¬í˜„ì´ ìƒì„±ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
#~ "    println!(\"&p.0: {:p}\", &p.0);\n"
#~ "    p\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"&p3.0: {:p}\", &p3.0);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn add(p1: &Point, p2: &Point) -> Point {\n"
#~ "    let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
#~ "    println!(\"&p.0: {:p}\", &p.0);\n"
#~ "    p\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    let p1 = Point(3, 4);\n"
#~ "    let p2 = Point(10, 20);\n"
#~ "    let p3 = add(&p1, &p2);\n"
#~ "    println!(\"&p3.0: {:p}\", &p3.0);\n"
#~ "    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let mut a: i32 = 10;\n"
#~ "    let b: &i32 = &a;\n"
#~ "\n"
#~ "    {\n"
#~ "        let c: &mut i32 = &mut a;\n"
#~ "        *c = 20;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let mut a: i32 = 10;\n"
#~ "    let b: &i32 = &a;\n"
#~ "\n"
#~ "    {\n"
#~ "        let c: &mut i32 = &mut a;\n"
#~ "        *c = 20;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "A borrowed value has a _lifetime_:"
#~ msgstr "ë¹Œë ¤ì˜¨ ê°’ì€ _ìˆ˜ëª…_ì„ ê°–ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`."
#~ msgstr "ìˆ˜ëª…ì€ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤: `add(p1: &Point, p2: &Point) -> Point`."

#~ msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
#~ msgstr "ë¬¼ë¡  ëª…ì‹œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤: `&'a Point`, `&'document str`."

#~ msgid ""
#~ "Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
#~ "lifetime `a`\"."
#~ msgstr ""
#~ "`&'a Point` ëŠ” `Point`ì˜ ìˆ˜ëª…ì´ ìµœì†Œí•œ `'a`ë¼ëŠ” ìˆ˜ëª…ë³´ë‹¤ëŠ” ê°™ê±°ë‚˜ ë” ê¸¸ë‹¤"
#~ "ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Lifetimes are always inferred by the compiler: you cannot assign a "
#~ "lifetime yourself."
#~ msgstr ""
#~ "ìˆ˜ëª…ì€ í•­ìƒ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ì¶”ë¡ í•©ë‹ˆë‹¤. ì§ì ‘ ìˆ˜ëª…ì„ ì§€ì •í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "In addition to borrowing its arguments, a function can return a borrowed "
#~ "value:"
#~ msgstr "í•¨ìˆ˜ëŠ” ì¸ìˆ˜ë¥¼ ë¹Œë¦¬ëŠ” ê²ƒ ì™¸ì—ë„ ë¹Œë¦° ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p2: Point = Point(20, 20);\n"
#~ "    let p3: &Point = left_most(&p1, &p2);\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p2: Point = Point(20, 20);\n"
#~ "    let p3: &Point = left_most(&p1, &p2);\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"

#~ msgid "`'a` is a generic parameter, it is inferred by the compiler."
#~ msgstr "`'a`ëŠ” ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ë¡œ ì»´íŒŒì¼ëŸ¬ë¡œì— ì˜í•´ ì¶”ë¡ ë©ë‹ˆë‹¤."

#~ msgid "Lifetimes start with `'` and `'a` is a typical default name."
#~ msgstr "ìˆ˜ëª…ì˜ ì´ë¦„ì€ `'` ë¡œ ì‹œì‘í•˜ë©° ë³´í†µ `'a`ë¥¼ ë§ì´ ì”ë‹ˆë‹¤."

#~ msgid ""
#~ "The _at least_ part is important when parameters are in different scopes."
#~ msgstr ""
#~ "ë§¤ê°œë³€ìˆ˜ë“¤ì´ ì„œë¡œ ë‹¤ë¥¸ ìŠ¤ì½”í”„ì— ìˆì„ ê²½ìš° \"ìµœì†Œí•œ\"ì´ë¼ëŠ” ì¡°ê±´ì´ ì¤‘ìš”í•©ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
#~ "resulting in the following code:"
#~ msgstr ""
#~ "`p2`ì™€ `p3`ë¥¼ ìƒˆë¡œìš´ ë²”ìœ„(`{...}`)ë¡œ ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ì´ë™í•´ ë´…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p3: &Point;\n"
#~ "    {\n"
#~ "        let p2: Point = Point(20, 20);\n"
#~ "        p3 = left_most(&p1, &p2);\n"
#~ "    }\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
#~ "    if p1.0 < p2.0 { p1 } else { p2 }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1: Point = Point(10, 10);\n"
#~ "    let p3: &Point;\n"
#~ "    {\n"
#~ "        let p2: Point = Point(20, 20);\n"
#~ "        p3 = left_most(&p1, &p2);\n"
#~ "    }\n"
#~ "    println!(\"left-most point: {:?}\", p3);\n"
#~ "}\n"
#~ "```"

#~ msgid "Note how this does not compile since `p3` outlives `p2`."
#~ msgstr ""
#~ "`p3`ì˜ ìˆ˜ëª…ì´ `p2` ë³´ë‹¤ ê¸¸ê¸° ë•Œë¬¸ì— ì´ ì˜ˆì œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠìŒì„ í™•ì¸í•˜ì‹œ"
#~ "ê¸° ë°”ëë‹ˆë‹¤."

#~ msgid ""
#~ "Reset the workspace and change the function signature to `fn "
#~ "left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will "
#~ "not compile because the relationship between the lifetimes `'a` and `'b` "
#~ "is unclear."
#~ msgstr ""
#~ "ì‘ì—…ê³µê°„ì„ ì´ˆê¸°í™” í•œ í›„ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ `fn left_most<'a, 'b>(p1: &'a "
#~ "Point, p2: &'a Point) -> &'b Point`ë¡œ ë³€ê²½í•´ ë´…ë‹ˆë‹¤. ì´ ê²½ìš° `'a`ì™€ `'b`ì‚¬"
#~ "ì´ì˜ ê´€ê³„ê°€ ë¶ˆë¶„ëª…í•˜ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#~ msgid "Another way to explain it:"
#~ msgstr "ì´ ì—ëŸ¬ë¥¼ ì„¤ëª…í•˜ëŠ” ë˜ ë‹¤ë¥¸ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "Two references to two values are borrowed by a function and the function "
#~ "returns another reference."
#~ msgstr "ì´ í•¨ìˆ˜ëŠ” ë‘ ê°’ì„ ë¹Œë ¤ì„œ, ìƒˆë¡œìš´ ì°¸ì¡°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "It must have come from one of those two inputs (or from a global "
#~ "variable)."
#~ msgstr ""
#~ "ì´ ë°˜í™˜ëœ ì°¸ì¡°ëŠ” ë‘ ì…ë ¥ ì¤‘ í•˜ë‚˜ë¡œ ë¶€í„° ì™€ì•¼ í•©ë‹ˆë‹¤. (ì•„ë‹ˆë©´ ì „ì—­ ë³€ìˆ˜ë¡œ "
#~ "ë¶€í„°)"

#~ msgid ""
#~ "Which one is it? The compiler needs to know, so at the call site the "
#~ "returned reference is not used for longer than a variable from where the "
#~ "reference came from."
#~ msgstr ""
#~ "ë‘ ì…ë ¥ ì¤‘ ì–´ë–¤ ê²ƒì¼ê¹Œìš”? ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤. ê·¸ë˜ì•¼ë§Œ í•¨ìˆ˜ í˜¸"
#~ "ì¶œë¶€ì—ì„œ ë´¤ì„ ë•Œ, ë°˜í™˜ëœ ì°¸ì¡°ì˜ ìˆ˜ëª…ì´ ì›ë˜ ê°’ì„ ìˆ˜ëª…ë³´ë‹¤ ê¸¸ì§€ ì•ŠìŒì„ í™•ì¸"
#~ "í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);\n"
#~ "\n"
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let text = String::from(\"The quick brown fox jumps over the lazy dog."
#~ "\");\n"
#~ "    let fox = Highlight(&text[4..19]);\n"
#~ "    let dog = Highlight(&text[35..43]);\n"
#~ "    // erase(text);\n"
#~ "    println!(\"{fox:?}\");\n"
#~ "    println!(\"{dog:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);\n"
#~ "\n"
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let text = String::from(\"The quick brown fox jumps over the lazy dog."
#~ "\");\n"
#~ "    let fox = Highlight(&text[4..19]);\n"
#~ "    let dog = Highlight(&text[35..43]);\n"
#~ "    // erase(text);\n"
#~ "    println!(\"{fox:?}\");\n"
#~ "    println!(\"{dog:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Day 1: Afternoon Exercises"
#~ msgstr "1ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#~ msgid "We will look at two things:"
#~ msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œëŠ” ì•„ë˜ ë‘ê°€ì§€ì…ë‹ˆë‹¤:"

#~ msgid "A small book library,"
#~ msgstr "ì‘ì€ ë„ì„œê´€,"

#~ msgid "Iterators and ownership (hard)."
#~ msgstr "ë°˜ë³µìì™€ ì†Œìœ ê¶Œ (ì–´ë ¤ì›€)"

#~ msgid ""
#~ "We will learn much more about structs and the `Vec<T>` type tomorrow. For "
#~ "now, you just need to know part of its API:"
#~ msgstr ""
#~ "ìš°ë¦¬ëŠ” ë‚´ì¼ êµ¬ì¡°ì²´ì™€ `Vec<T>`ì— ëŒ€í•´ ë” ë§ì€ ê²ƒì„ ë°°ìš¸ ê²ƒì…ë‹ˆë‹¤. ì¼ë‹¨ ì˜¤ëŠ˜"
#~ "ì€ APIì˜ ì¼ë¶€ë§Œ ì•Œë©´ ë©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut vec = vec![10, 20];\n"
#~ "    vec.push(30);\n"
#~ "    let midpoint = vec.len() / 2;\n"
#~ "    println!(\"middle value: {}\", vec[midpoint]);\n"
#~ "    for item in &vec {\n"
#~ "        println!(\"item: {item}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut vec = vec![10, 20];\n"
#~ "    vec.push(30);\n"
#~ "    let midpoint = vec.len() / 2;\n"
#~ "    println!(\"middle value: {}\", vec[midpoint]);\n"
#~ "    for item in &vec {\n"
#~ "        println!(\"item: {item}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Use this to model a library's book collection. Copy the code below to "
#~ "<https://play.rust-lang.org/> and update the types to make it compile:"
#~ msgstr ""
#~ "ì•„ë˜ ì½”ë“œëŠ” ë„ì„œê´€ì— ìˆëŠ” ë„ì„œ ì»¬ë™ì…˜ì„ ëª¨ë¸ë§ í•©ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ "
#~ "<https://play.rust-lang.org/>ì— ë³µì‚¬í•œ í›„, ì»´íŒŒì¼ ë˜ë„ë¡ ìˆ˜ì •í•´ ë´…ì‹œë‹¤:"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "struct Library {\n"
#~ "    books: Vec<Book>,\n"
#~ "}\n"
#~ "\n"
#~ "struct Book {\n"
#~ "    title: String,\n"
#~ "    year: u16,\n"
#~ "}\n"
#~ "\n"
#~ "impl Book {\n"
#~ "    // This is a constructor, used below.\n"
#~ "    fn new(title: &str, year: u16) -> Book {\n"
#~ "        Book {\n"
#~ "            title: String::from(title),\n"
#~ "            year,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Implement the methods below. Update the `self` parameter to\n"
#~ "// indicate the method's required level of ownership over the object:\n"
#~ "//\n"
#~ "// - `&self` for shared read-only access,\n"
#~ "// - `&mut self` for unique and mutable access,\n"
#~ "// - `self` for unique access by value.\n"
#~ "impl Library {\n"
#~ "    fn new() -> Library {\n"
#~ "        todo!(\"Initialize and return a `Library` value\")\n"
#~ "    }\n"
#~ "\n"
#~ "    //fn len(self) -> usize {\n"
#~ "    //    todo!(\"Return the length of `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    //    todo!(\"Return `true` if `self.books` is empty\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    //    todo!(\"Add a new book to `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn print_books(self) {\n"
#~ "    //    todo!(\"Iterate over `self.books` and each book's title and "
#~ "year\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
#~ "    //}\n"
#~ "}\n"
#~ "\n"
#~ "// This shows the desired behavior. Uncomment the code below and\n"
#~ "// implement the missing methods. You will need to update the\n"
#~ "// method signatures, including the \"self\" parameter! You may\n"
#~ "// also need to update the variable bindings within main.\n"
#~ "fn main() {\n"
#~ "    let library = Library::new();\n"
#~ "\n"
#~ "    //println!(\"The library is empty: library.is_empty() -> {}\", "
#~ "library.is_empty());\n"
#~ "    //\n"
#~ "    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
#~ "1865));\n"
#~ "    //\n"
#~ "    //println!(\"The library is no longer empty: library.is_empty() -> "
#~ "{}\", library.is_empty());\n"
#~ "    //\n"
#~ "    //\n"
#~ "    //library.print_books();\n"
#~ "    //\n"
#~ "    //match library.oldest_book() {\n"
#~ "    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
#~ "    //    None => println!(\"The library is empty!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"The library has {} books\", library.len());\n"
#~ "    //library.print_books();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "struct Library {\n"
#~ "    books: Vec<Book>,\n"
#~ "}\n"
#~ "\n"
#~ "struct Book {\n"
#~ "    title: String,\n"
#~ "    year: u16,\n"
#~ "}\n"
#~ "\n"
#~ "impl Book {\n"
#~ "    // This is a constructor, used below.\n"
#~ "    fn new(title: &str, year: u16) -> Book {\n"
#~ "        Book {\n"
#~ "            title: String::from(title),\n"
#~ "            year,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Implement the methods below. Update the `self` parameter to\n"
#~ "// indicate the method's required level of ownership over the object:\n"
#~ "//\n"
#~ "// - `&self` for shared read-only access,\n"
#~ "// - `&mut self` for unique and mutable access,\n"
#~ "// - `self` for unique access by value.\n"
#~ "impl Library {\n"
#~ "    fn new() -> Library {\n"
#~ "        todo!(\"Initialize and return a `Library` value\")\n"
#~ "    }\n"
#~ "\n"
#~ "    //fn len(self) -> usize {\n"
#~ "    //    todo!(\"Return the length of `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn is_empty(self) -> bool {\n"
#~ "    //    todo!(\"Return `true` if `self.books` is empty\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn add_book(self, book: Book) {\n"
#~ "    //    todo!(\"Add a new book to `self.books`\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn print_books(self) {\n"
#~ "    //    todo!(\"Iterate over `self.books` and each book's title and "
#~ "year\")\n"
#~ "    //}\n"
#~ "\n"
#~ "    //fn oldest_book(self) -> Option<&Book> {\n"
#~ "    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
#~ "    //}\n"
#~ "}\n"
#~ "\n"
#~ "// This shows the desired behavior. Uncomment the code below and\n"
#~ "// implement the missing methods. You will need to update the\n"
#~ "// method signatures, including the \"self\" parameter! You may\n"
#~ "// also need to update the variable bindings within main.\n"
#~ "fn main() {\n"
#~ "    let library = Library::new();\n"
#~ "\n"
#~ "    //println!(\"The library is empty: library.is_empty() -> {}\", "
#~ "library.is_empty());\n"
#~ "    //\n"
#~ "    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
#~ "    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
#~ "1865));\n"
#~ "    //\n"
#~ "    //println!(\"The library is no longer empty: library.is_empty() -> "
#~ "{}\", library.is_empty());\n"
#~ "    //\n"
#~ "    //\n"
#~ "    //library.print_books();\n"
#~ "    //\n"
#~ "    //match library.oldest_book() {\n"
#~ "    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
#~ "    //    None => println!(\"The library is empty!\"),\n"
#~ "    //}\n"
#~ "    //\n"
#~ "    //println!(\"The library has {} books\", library.len());\n"
#~ "    //library.print_books();\n"
#~ "}\n"
#~ "```"

#~ msgid "[Solution](solutions-afternoon.md#designing-a-library)"
#~ msgstr "[í•´ë‹µ](solutions-afternoon.md#designing-a-library)"

#~ msgid ""
#~ "The ownership model of Rust affects many APIs. An example of this is the "
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) traits."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì˜ ì†Œìœ ê¶Œ ëª¨ë¸ì€ ë§ì€ APIì— ë°˜ì˜ì´ ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ë“¤ì–´ "
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) ì™€ "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) ê°™ì€ íŠ¸ë ˆì‡ì´ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Traits are like interfaces: they describe behavior (methods) for a type. "
#~ "The `Iterator` trait simply says that you can call `next` until you get "
#~ "`None` back:"
#~ msgstr ""
#~ "íŠ¸ë ˆì‡ì€ íƒ€ì…ì— ëŒ€í•œ í–‰ë™(ë©”ì„œë“œ)ë¥¼ ì„¤ëª…í•œë‹¤ëŠ” ì ì—ì„œ ì¸í„°í˜ì´ìŠ¤ì™€ ìœ ì‚¬í•©"
#~ "ë‹ˆë‹¤. `Iterator`ëŠ” ë‹¨ìˆœíˆ `None`ì´ ë‚˜ì˜¬ë•Œê¹Œì§€ `next`ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ê°€ëŠ¥"
#~ "í•˜ë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust\n"
#~ "pub trait Iterator {\n"
#~ "    type Item;\n"
#~ "    fn next(&mut self) -> Option<Self::Item>;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub trait Iterator {\n"
#~ "    type Item;\n"
#~ "    fn next(&mut self) -> Option<Self::Item>;\n"
#~ "}\n"
#~ "```"

#~ msgid "You use this trait like this:"
#~ msgstr "`Iterator` íŠ¸ë ˆì‡ì€ ì´ë ‡ê²Œ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    println!(\"v[0]: {:?}\", iter.next());\n"
#~ "    println!(\"v[1]: {:?}\", iter.next());\n"
#~ "    println!(\"v[2]: {:?}\", iter.next());\n"
#~ "    println!(\"No more items: {:?}\", iter.next());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    println!(\"v[0]: {:?}\", iter.next());\n"
#~ "    println!(\"v[1]: {:?}\", iter.next());\n"
#~ "    println!(\"v[2]: {:?}\", iter.next());\n"
#~ "    println!(\"No more items: {:?}\", iter.next());\n"
#~ "}\n"
#~ "```"

#~ msgid "What is the type returned by the iterator? Test your answer here:"
#~ msgstr ""
#~ "ë°˜ë³µìê°€ ë°˜í™˜í•˜ëŠ” ê°’ë“¤ì€ íƒ€ì…ì´ ë­˜ê¹Œìš”? ì—¬ê¸°ì„œ ë‹µì„ í…ŒìŠ¤íŠ¸ í•´ ë³´ì„¸ìš”:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<i8> = vec![10, 20, 30];\n"
#~ "    let mut iter = v.iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Why is this type used?"
#~ msgstr "ì™œ ì´ëŸ° íƒ€ì…ì´ ì‚¬ìš©ë˜ëŠ” ê²ƒì¼ê¹Œìš”?"

#~ msgid ""
#~ "```rust\n"
#~ "pub trait IntoIterator {\n"
#~ "    type Item;\n"
#~ "    type IntoIter: Iterator<Item = Self::Item>;\n"
#~ "\n"
#~ "    fn into_iter(self) -> Self::IntoIter;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub trait IntoIterator {\n"
#~ "    type Item;\n"
#~ "    type IntoIter: Iterator<Item = Self::Item>;\n"
#~ "\n"
#~ "    fn into_iter(self) -> Self::IntoIter;\n"
#~ "}\n"
#~ "```"

#~ msgid "Like before, what  is the type returned by the iterator?"
#~ msgstr "ì´ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ, ë°˜ë³µìê°€ ë°˜í™˜í•˜ëŠ” íƒ€ì…ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    let v0: Option<..> = iter.next();\n"
#~ "    println!(\"v0: {v0:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
#~ "loops. They call `into_iter()` on an expression and iterates over the "
#~ "resulting iterator:"
#~ msgstr ""
#~ "ì, ì´ì œ ìš°ë¦¬ëŠ” `Iterator`ì™€ `IntoIterator`ë¥¼ ì•Œì•˜ìœ¼ë¯€ë¡œ `for` ë£¨í”„ë¥¼ ë§Œ"
#~ "ë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `for` ë£¨í”„ëŠ” `into_iter()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ë°˜ë³µìë¥¼ ë§Œë“  ë‹¤ìŒ "
#~ "ê·¸ ë°˜ë³µìë¥¼ ì´ìš©í•˜ì—¬ ìš”ì†Œë“¤ì„ ë°˜ë³µí•´ì„œ ì ‘ê·¼í•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "\n"
#~ "    for word in &v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    for word in v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v: Vec<String> = vec![String::from(\"foo\"), String::"
#~ "from(\"bar\")];\n"
#~ "\n"
#~ "    for word in &v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    for word in v {\n"
#~ "        println!(\"word: {word}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Experiment with the code above and then consult the documentation for "
#~ "[`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/"
#~ "struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) and [`impl "
#~ "IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
#~ "html#impl-IntoIterator-for-Vec%3CT,+A%3E) to check your answers."
#~ msgstr ""
#~ "ìœ„ ì½”ë“œì—ì„œ ì‹¤í—˜ í•´ ë³¸ í›„, ë‹¤ìŒ ë¬¸ì„œë¥¼ ì°¸ì¡°í•´ì„œ ë‹µë³€ì„ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆ"
#~ "ë‹¤:[`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/"
#~ "struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E), [`impl "
#~ "IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
#~ "html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E)"

#~ msgid "Structs, enums, methods."
#~ msgstr "êµ¬ì¡°ì²´, ì—´ê±°í˜•, ë©”ì„œë“œ."

#~ msgid ""
#~ "Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
#~ "and `continue`."
#~ msgstr ""
#~ "íë¦„ ì œì–´: `if`, `if let`, `while`, `while let`, `break`, ê·¸ë¦¬ê³  "
#~ "`continue`."

#~ msgid ""
#~ "The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
#~ "`Rc` and `Arc`."
#~ msgstr ""
#~ "í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬: `String`, `Option` ê³¼ `Result`, `Vec`, `HashMap`, `Rc` ê·¸"
#~ "ë¦¬ê³  `Arc`."

#~ msgid "Modules: visibility, paths, and filesystem hierarchy."
#~ msgstr "ëª¨ë“ˆ: ê°€ì‹œì„±, ê²½ë¡œ ë° íŒŒì¼ ì‹œìŠ¤í…œ ê³„ì¸µ."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    peter.age = 28;\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    let jackie = Person {\n"
#~ "        name: String::from(\"Jackie\"),\n"
#~ "        ..peter\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    peter.age = 28;\n"
#~ "    println!(\"{} is {} years old\", peter.name, peter.age);\n"
#~ "    \n"
#~ "    let jackie = Person {\n"
#~ "        name: String::from(\"Jackie\"),\n"
#~ "        ..peter\n"
#~ "    };\n"
#~ "    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Methods are defined in an `impl` block, which we will see in following "
#~ "slides."
#~ msgstr ""
#~ "ë©”ì„œë“œëŠ” `impl`ë¸”ë¡ì— ì •ì˜ í•©ë‹ˆë‹¤. ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(17, 23);\n"
#~ "    println!(\"({}, {})\", p.0, p.1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Point(i32, i32);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(17, 23);\n"
#~ "    println!(\"({}, {})\", p.0, p.1);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "struct PoundsOfForce(f64);\n"
#~ "struct Newtons(f64);\n"
#~ "\n"
#~ "fn compute_thruster_force() -> PoundsOfForce {\n"
#~ "    todo!(\"Ask a rocket scientist at NASA\")\n"
#~ "}\n"
#~ "\n"
#~ "fn set_thruster_force(force: Newtons) {\n"
#~ "    // ...\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let force = compute_thruster_force();\n"
#~ "    set_thruster_force(force);\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "struct PoundsOfForce(f64);\n"
#~ "struct Newtons(f64);\n"
#~ "\n"
#~ "fn compute_thruster_force() -> PoundsOfForce {\n"
#~ "    todo!(\"Ask a rocket scientist at NASA\")\n"
#~ "}\n"
#~ "\n"
#~ "fn set_thruster_force(force: Newtons) {\n"
#~ "    // ...\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let force = compute_thruster_force();\n"
#~ "    set_thruster_force(force);\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Person {\n"
#~ "        Person { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person::new(String::from(\"Peter\"), 27);\n"
#~ "    println!(\"{peter:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Person {\n"
#~ "        Person { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person::new(String::from(\"Peter\"), 27);\n"
#~ "    println!(\"{peter:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The `new` function could be written using `Self` as a type, as it is "
#~ "interchangeable with the struct type name"
#~ msgstr ""
#~ "`new`í•¨ìˆ˜ë¥¼ ë‹¤ìŒì²˜ëŸ¼ êµ¬ì¡°ì²´ ì´ë¦„ ëŒ€ì‹  `Self`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‘ì„±í•´ë„ ë©ë‹ˆë‹¤"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Self {\n"
#~ "        Self { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Person {\n"
#~ "    fn new(name: String, age: u8) -> Self {\n"
#~ "        Self { name, age }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Implement the `Default` trait for the struct. Define some fields and use "
#~ "the default values for the other fields."
#~ msgstr ""
#~ "`Default` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ë³´ì„¸ìš”. í•„ë“œ ëª‡ê°œëŠ” ì´ˆê¸°í™”í•˜ê³  ë‚˜ë¨¸ì§€ í•„ë“œëŠ” ë””í´"
#~ "íŠ¸ ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Default for Person {\n"
#~ "    fn default() -> Person {\n"
#~ "        Person {\n"
#~ "            name: \"Bot\".to_string(),\n"
#~ "            age: 0,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "fn create_default() {\n"
#~ "    let tmp = Person {\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "    let tmp = Person {\n"
#~ "        name: \"Sam\".to_string(),\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "impl Default for Person {\n"
#~ "    fn default() -> Person {\n"
#~ "        Person {\n"
#~ "            name: \"Bot\".to_string(),\n"
#~ "            age: 0,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "fn create_default() {\n"
#~ "    let tmp = Person {\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "    let tmp = Person {\n"
#~ "        name: \"Sam\".to_string(),\n"
#~ "        ..Person::default()\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid "Methods are defined in the `impl` block."
#~ msgstr "ë©”ì„œë“œëŠ” `impl` ë¸”ë¡ì— ì •ì˜ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "Use struct update syntax to define a new structure using `peter`. Note "
#~ "that the variable `peter` will no longer be accessible afterwards."
#~ msgstr ""
#~ "`peter`ì™€ êµ¬ì¡°ì²´ ì—…ë°ì´íŠ¸ ë¬¸ë²•ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ êµ¬ì¡°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ì–´"
#~ "ë³´ì„¸ìš”. ì´ë•Œ, `peter`ëŠ” ë”ì´ìƒ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "Use `{:#?}` when printing structs to request the `Debug` representation."
#~ msgstr "êµ¬ì¡°ì²´ë¥¼ `Debug` í˜•íƒœë¡œ ì¶œë ¥í•˜ë ¤ë©´ `{:#?}`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn generate_random_number() -> i32 {\n"
#~ "    // Implementation based on https://xkcd.com/221/\n"
#~ "    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum CoinFlip {\n"
#~ "    Heads,\n"
#~ "    Tails,\n"
#~ "}\n"
#~ "\n"
#~ "fn flip_coin() -> CoinFlip {\n"
#~ "    let random_number = generate_random_number();\n"
#~ "    if random_number % 2 == 0 {\n"
#~ "        return CoinFlip::Heads;\n"
#~ "    } else {\n"
#~ "        return CoinFlip::Tails;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"You got: {:?}\", flip_coin());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn generate_random_number() -> i32 {\n"
#~ "    // Implementation based on https://xkcd.com/221/\n"
#~ "    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum CoinFlip {\n"
#~ "    Heads,\n"
#~ "    Tails,\n"
#~ "}\n"
#~ "\n"
#~ "fn flip_coin() -> CoinFlip {\n"
#~ "    let random_number = generate_random_number();\n"
#~ "    if random_number % 2 == 0 {\n"
#~ "        return CoinFlip::Heads;\n"
#~ "    } else {\n"
#~ "        return CoinFlip::Tails;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"You got: {:?}\", flip_coin());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "This page offers an enum type `CoinFlip` with two variants `Heads` and "
#~ "`Tails`. You might note the namespace when using variants."
#~ msgstr ""
#~ "ìœ„ì˜ `CoinFlip` ì—´ê±°í˜• íƒ€ì…ì€ `Heads`ì™€ `Tail` ë‘ ê°€ì§€ variantë¥¼ ê°€ì§‘ë‹ˆ"
#~ "ë‹¤. ì—´ê±°í˜• íƒ€ì…ì˜ variantëŠ” ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ë¶™ì—¬ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#~ msgid "In both, associated functions are defined within an `impl` block."
#~ msgstr "ë‘˜ ë‹¤ ì—°ê´€í•¨ìˆ˜ë¥¼ `impl`ë¸”ë¡ìœ¼ë¡œ ì •ì˜ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "You can define richer enums where the variants carry data. You can then "
#~ "use the `match` statement to extract the data from each variant:"
#~ msgstr ""
#~ "ì¢€ë” ë³µì¡í•œ ì—´ê±°í˜•ì˜ ê²½ìš° variantì— ë°ì´í„°(payload)ë¥¼ í¬í•¨ì‹œí‚¤ë„ í•©ë‹ˆë‹¤. "
#~ "ê° variantì— ë‹´ê¸´ ë°ì´í„°ëŠ” `match`ë¬¸ì„ ì´ìš©í•´ ì¶”ì¶œí•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // Variant without payload\n"
#~ "    KeyPress(char),           // Tuple struct variant\n"
#~ "    Click { x: i64, y: i64 }, // Full struct variant\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, "
#~ "y={y}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };\n"
#~ "\n"
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // í˜ì´ë¡œë“œê°€ ì—†ëŠ” ìœ í˜•\n"
#~ "    KeyPress(char),           // íŠœí”Œ êµ¬ì¡°ì²´ ìœ í˜•\n"
#~ "    Click { x: i64, y: i64 }, // ì™„ì „í•œ êµ¬ì¡°ì²´ ìœ í˜•\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, "
#~ "y={y}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };\n"
#~ "\n"
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The expression is matched against the patterns from top to bottom. There "
#~ "is no fall-through like in C or C++."
#~ msgstr ""
#~ "ë§¤ì¹˜ íŒ¨í„´ë“¤ì€ ìœ„ì—ì„œ ì•„ë˜ë¡œ ìˆœì„œì— ë”°ë¼ ê²€ì‚¬í•©ë‹ˆë‹¤. Cë‚˜ C++ì—ì„œì™€ ê°™ì€ "
#~ "fall-throughëŠ” ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "The match expression has a value. The value is the last expression in the "
#~ "match arm which was executed."
#~ msgstr ""
#~ "ë§¤ì¹˜ í‘œí˜„ì‹ ìì²´ëŠ” ê°’ì„ ê°€ì§‘ë‹ˆë‹¤. ê·¸ ê°’ì€ ë§¤ì¹­ì´ ëœ íŒ¨í„´ì—ì„œ ê°€ì¥ ë§ˆì§€ë§‰"
#~ "ì— ìˆ˜í–‰ëœ í‘œí˜„ì‹ì´ ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "Starting from the top we look for what pattern matches the value then run "
#~ "the code following the arrow. Once we find a match, we stop. "
#~ msgstr ""
#~ "ê°€ì¥ ìœ„ì—ì„œ ë¶€í„° ì–´ë–¤ íŒ¨í„´ì´ ì£¼ì–´ì§„ ê°’ê³¼ ë§¤ì¹­í•˜ëŠ”ì§€ ê²€ì‚¬í•œ ë‹¤ìŒ, ë§¤ì¹­ëœ ê²ƒ"
#~ "ì´ ë°œê²¬ë˜ë©´ í™”ì‚´í‘œë¥¼ ë”°ë¼ ì½”ë“œë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. í•œ ë²ˆ ë§¤ì¹­ì´ ë˜ê³  ì½”ë“œê°€ ìˆ˜í–‰"
#~ "ì´ ë˜ë©´, ë”ì´ìƒì˜ ë§¤ì¹­ì€ ì—†ìŠµë‹ˆë‹¤. "

#~ msgid "`match` inspects a hidden discriminant field in the `enum`."
#~ msgstr ""
#~ "`match`ëŠ” ì£¼ì–´ì§„ ì—´ê±°í˜• ê°’ì´ ì‹¤ì œë¡œ ì–´ë–¤ variantì¸ì§€ íŒë‹¨í•˜ê¸° ìœ„í•´, ê·¸ "
#~ "variantì˜ ì¢…ë¥˜ê°€ ê¸°ë¡ëœ, ìˆ¨ê²¨ì§„ í•„ë“œ(ì‹ë³„ì)ì˜ ê°’ì„ ê²€ì‚¬í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "It is possible to retrieve the discriminant by calling `std::mem::"
#~ "discriminant()`"
#~ msgstr "`std::mem::discriminant()`ë¥¼ ì´ìš©í•˜ì—¬ ì‹ë³„ìë¥¼ ì–»ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤"

#~ msgid ""
#~ "This is useful, for example, if implementing `PartialEq` for structs "
#~ "where comparing field values doesn't affect equality."
#~ msgstr ""
#~ "ì´ëŠ” ê° í•„ë“œ ê°’ì„ êµ³ì´ ë¹„êµí•  í•„ìš” ì—†ëŠ” êµ¬ì¡°ì²´ì— ëŒ€í•´ `PartialEq` íŠ¸ë ˆì‡"
#~ "ì„ êµ¬í˜„í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
#~ "Click(Click)` with a top level `struct Click { ... }`. The inlined "
#~ "version cannot implement traits, for example."
#~ msgstr ""
#~ "`WebEvent::Click { ... }`ì€ ìµœìƒìœ„ ë ˆë²¨ êµ¬ì¡°ì²´ `struct Click {...}`ë¥¼ ë”°"
#~ "ë¡œ ì •ì˜í•˜ê³  `WebEvent::Click(Click)`ì²˜ëŸ¼ íŠœí”Œ í˜•íƒœë¡œ ì •ì˜í•œ ê²ƒê³¼ ì •í™•íˆ ê°™"
#~ "ì§„ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `WebEvent::Click { ... }` ë¡œ ì •ì˜í•œ ê²½ìš°, êµ¬ì¡°ì²´ í˜•"
#~ "íƒœì™€ ìœ ì‚¬í•˜ì§€ë§Œ íŠ¸ë ˆì‡ì„ êµ¬í˜„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Rust enums are packed tightly, taking constraints due to alignment into "
#~ "account:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì˜ ì—´ê±°í˜•ì€ ì •ë ¬(alignment)ë¡œ ì¸í•œ ì œì•½ì„ ê³ ë ¤í•˜ì—¬ í¬ê¸°ë¥¼ ë¹½ë¹½í•˜ê²Œ "
#~ "ì¡ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::any::type_name;\n"
#~ "use std::mem::{align_of, size_of};\n"
#~ "\n"
#~ "fn dbg_size<T>() {\n"
#~ "    println!(\"{}: size {} bytes, align: {} bytes\",\n"
#~ "        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
#~ "}\n"
#~ "\n"
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    dbg_size::<Foo>();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::any::type_name;\n"
#~ "use std::mem::{align_of, size_of};\n"
#~ "\n"
#~ "fn dbg_size<T>() {\n"
#~ "    println!(\"{}: size {} bytes, align: {} bytes\",\n"
#~ "        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
#~ "}\n"
#~ "\n"
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    dbg_size::<Foo>();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Internally Rust is using a field (discriminant) to keep track of the enum "
#~ "variant."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ëŠ” ì—´ê±°í˜• variantë¥¼ êµ¬ë¶„í•˜ê¸° ìœ„í•´ ë‚´ë¶€ì ìœ¼ë¡œ ì‹ë³„ì(discriminant) í•„"
#~ "ë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[repr(u32)]\n"
#~ "enum Bar {\n"
#~ "    A,  // 0\n"
#~ "    B = 10000,\n"
#~ "    C,  // 10001\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"A: {}\", Bar::A as u32);\n"
#~ "    println!(\"B: {}\", Bar::B as u32);\n"
#~ "    println!(\"C: {}\", Bar::C as u32);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[repr(u32)]\n"
#~ "enum Bar {\n"
#~ "    A,  // 0\n"
#~ "    B = 10000,\n"
#~ "    C,  // 10001\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"A: {}\", Bar::A as u32);\n"
#~ "    println!(\"B: {}\", Bar::B as u32);\n"
#~ "    println!(\"C: {}\", Bar::C as u32);\n"
#~ "}\n"
#~ "```"

#~ msgid "Try out other types such as"
#~ msgstr "ë‹¤ë¥¸ íƒ€ì…ë“¤ë„ í™•ì¸í•´ë³´ì„¸ìš”"

#~ msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
#~ msgstr "`dbg_size!(bool)`: í¬ê¸° 1 ë°”ì´íŠ¸, ì •ë ¬: 1 ë°”ì´íŠ¸,"

#~ msgid ""
#~ "`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche "
#~ "optimization, see below),"
#~ msgstr ""
#~ "`dbg_size!(Option<bool>)`: í¬ê¸° 1 ë°”ì´íŠ¸, ì •ë ¬: 1 ë°”ì´íŠ¸ (ë‹ˆì¹˜ ìµœì í™”, ì•„"
#~ "ë˜ ì„¤ëª… ì°¸ì¡°)"

#~ msgid ""
#~ "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
#~ msgstr ""
#~ "`dbg_size!(&i32)`: í¬ê¸° 8 ë°”ì´íŠ¸, ì •ë ¬: 8 ë°”ì´íŠ¸ (64ë¹„íŠ¸ ë¨¸ì‹ ì¸ ê²½ìš°)"

#~ msgid ""
#~ "`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
#~ "optimization, see below)."
#~ msgstr ""
#~ "`dbg_size!(Option<&i32>)`: í¬ê¸° 8 ë°”ì´íŠ¸, ì •ë ¬: 8 ë°”ì´íŠ¸ (ë„í¬ì¸í„° ìµœì "
#~ "í™”, ì•„ë˜ ì„¤ëª… ì°¸ì¡°)"

#~ msgid ""
#~ "Niche optimization: Rust will merge unused bit patterns for the enum "
#~ "discriminant."
#~ msgstr ""
#~ "ë‹ˆì¹˜ ìµœì í™”: ëŸ¬ìŠ¤íŠ¸ëŠ” ì—´ê±°í˜• ì‹ë³„ìë¥¼ ì‚¬ìš©ë˜ì§€ ì•Šì€ ë¹„íŠ¸ íŒ¨í„´ê³¼ ë³‘í•©í•©ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        println!(\"Bitwise representation of bool\");\n"
#~ "        dbg_bits!(false, u8);\n"
#~ "        dbg_bits!(true, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<bool>\");\n"
#~ "        dbg_bits!(None::<bool>, u8);\n"
#~ "        dbg_bits!(Some(false), u8);\n"
#~ "        dbg_bits!(Some(true), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
#~ "        dbg_bits!(Some(Some(false)), u8);\n"
#~ "        dbg_bits!(Some(Some(true)), u8);\n"
#~ "        dbg_bits!(Some(None::<bool>), u8);\n"
#~ "        dbg_bits!(None::<Option<bool>>, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<&i32>\");\n"
#~ "        dbg_bits!(None::<&i32>, usize);\n"
#~ "        dbg_bits!(Some(&0i32), usize);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        println!(\"Bitwise representation of bool\");\n"
#~ "        dbg_bits!(false, u8);\n"
#~ "        dbg_bits!(true, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<bool>\");\n"
#~ "        dbg_bits!(None::<bool>, u8);\n"
#~ "        dbg_bits!(Some(false), u8);\n"
#~ "        dbg_bits!(Some(true), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
#~ "        dbg_bits!(Some(Some(false)), u8);\n"
#~ "        dbg_bits!(Some(Some(true)), u8);\n"
#~ "        dbg_bits!(Some(None::<bool>), u8);\n"
#~ "        dbg_bits!(None::<Option<bool>>, u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of Option<&i32>\");\n"
#~ "        dbg_bits!(None::<&i32>, usize);\n"
#~ "        dbg_bits!(Some(&0i32), usize);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "More complex example if you want to discuss what happens when we chain "
#~ "more than 256 `Option`s together."
#~ msgstr ""
#~ "ì•„ë˜ëŠ” ì¢€ ë” ë³µì¡í•œ ì˜ˆì œì…ë‹ˆë‹¤.  256ê°œ ì´ìƒì˜ `Option`ì´ ì¤‘ì²©ë˜ì–´ ì—°ê²°ë˜"
#~ "ì–´ ìˆì„ ê²½ìš° ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ë³´ì—¬ì¤ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#![recursion_limit = \"1000\"]\n"
#~ "\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
#~ "signs.\n"
#~ "// Increasing the recursion limit is required to evaluate this macro.\n"
#~ "macro_rules! many_options {\n"
#~ "    ($value:expr) => { Some($value) };\n"
#~ "    ($value:expr, @) => {\n"
#~ "        Some(Some($value))\n"
#~ "    };\n"
#~ "    ($value:expr, @ $($more:tt)+) => {\n"
#~ "        many_options!(many_options!($value, $($more)+), $($more)+)\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        assert_eq!(many_options!(false), Some(false));\n"
#~ "        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
#~ "        assert_eq!(many_options!(false, @@), "
#~ "Some(Some(Some(Some(false)))));\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 128 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 256 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 257 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#![recursion_limit = \"1000\"]\n"
#~ "\n"
#~ "use std::mem::transmute;\n"
#~ "\n"
#~ "macro_rules! dbg_bits {\n"
#~ "    ($e:expr, $bit_type:ty) => {\n"
#~ "        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
#~ "$bit_type>($e));\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
#~ "signs.\n"
#~ "// Increasing the recursion limit is required to evaluate this macro.\n"
#~ "macro_rules! many_options {\n"
#~ "    ($value:expr) => { Some($value) };\n"
#~ "    ($value:expr, @) => {\n"
#~ "        Some(Some($value))\n"
#~ "    };\n"
#~ "    ($value:expr, @ $($more:tt)+) => {\n"
#~ "        many_options!(many_options!($value, $($more)+), $($more)+)\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
#~ "    // representation of types.\n"
#~ "    unsafe {\n"
#~ "        assert_eq!(many_options!(false), Some(false));\n"
#~ "        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
#~ "        assert_eq!(many_options!(false, @@), "
#~ "Some(Some(Some(Some(false)))));\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 128 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 256 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
#~ "\n"
#~ "        println!(\"Bitwise representation of a chain of 257 Option's."
#~ "\");\n"
#~ "        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
#~ "        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Hello, my name is {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    peter.say_hello();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Person {\n"
#~ "    name: String,\n"
#~ "    age: u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Person {\n"
#~ "    fn say_hello(&self) {\n"
#~ "        println!(\"Hello, my name is {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let peter = Person {\n"
#~ "        name: String::from(\"Peter\"),\n"
#~ "        age: 27,\n"
#~ "    };\n"
#~ "    peter.say_hello();\n"
#~ "}\n"
#~ "```"

#~ msgid "We describe the distinction between method receivers next."
#~ msgstr "ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œ receiverì˜ êµ¬ë¶„ì„ ì„¤ëª…í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
#~ "These constraints always come together in Rust due to borrow checker "
#~ "rules, and `self` is no exception. It isn't possible to reference a "
#~ "struct from multiple locations and call a mutating (`&mut self`) method "
#~ "on it."
#~ msgstr ""
#~ "\"ê³µìœ ê°€ëŠ¥í•œ ë¶ˆë³€\"ê³¼ \"ìœ ì¼í•œ ê°€ë³€\" ë¶€ë¶„ì€ ê°•ì¡°í•  ë§Œí•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì œì•½"
#~ "ì€ ëŸ¬ìŠ¤íŠ¸ì˜ ë¹Œë¦¼ ê²€ì‚¬ê¸°(borrow checker) ê·œì¹™ìœ¼ë¡œ ëŠ˜ ë¶™ì–´ë‹¤ë‹™ë‹ˆë‹¤. `self`"
#~ "ë„ ì˜ˆì™¸ëŠ” ì•„ë‹™ë‹ˆë‹¤. ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ êµ¬ì¡°ì²´ë¥¼ ì°¸ì¡°í•˜ë©´ì„œ ê°ì²´ë¥¼ ìˆ˜ì •í•˜ëŠ”"
#~ "(`&mut self`ë¥¼ ë¦¬ì‹œë²„ë¡œ í•˜ëŠ”) ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Race {\n"
#~ "    name: String,\n"
#~ "    laps: Vec<i32>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Race {\n"
#~ "    fn new(name: &str) -> Race {  // No receiver, a static method\n"
#~ "        Race { name: String::from(name), laps: Vec::new() }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
#~ "access to self\n"
#~ "        self.laps.push(lap);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn print_laps(&self) {  // Shared and read-only borrowed access to "
#~ "self\n"
#~ "        println!(\"Recorded {} laps for {}:\", self.laps.len(), self."
#~ "name);\n"
#~ "        for (idx, lap) in self.laps.iter().enumerate() {\n"
#~ "            println!(\"Lap {idx}: {lap} sec\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn finish(self) {  // Exclusive ownership of self\n"
#~ "        let total = self.laps.iter().sum::<i32>();\n"
#~ "        println!(\"Race {} is finished, total lap time: {}\", self.name, "
#~ "total);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut race = Race::new(\"Monaco Grand Prix\");\n"
#~ "    race.add_lap(70);\n"
#~ "    race.add_lap(68);\n"
#~ "    race.print_laps();\n"
#~ "    race.add_lap(71);\n"
#~ "    race.print_laps();\n"
#~ "    race.finish();\n"
#~ "    // race.add_lap(42);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Race {\n"
#~ "    name: String,\n"
#~ "    laps: Vec<i32>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Race {\n"
#~ "    fn new(name: &str) -> Race {  // No receiver, a static method\n"
#~ "        Race { name: String::from(name), laps: Vec::new() }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
#~ "access to self\n"
#~ "        self.laps.push(lap);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn print_laps(&self) {  // Shared and read-only borrowed access to "
#~ "self\n"
#~ "        println!(\"Recorded {} laps for {}:\", self.laps.len(), self."
#~ "name);\n"
#~ "        for (idx, lap) in self.laps.iter().enumerate() {\n"
#~ "            println!(\"Lap {idx}: {lap} sec\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn finish(self) {  // Exclusive ownership of self\n"
#~ "        let total = self.laps.iter().sum::<i32>();\n"
#~ "        println!(\"Race {} is finished, total lap time: {}\", self.name, "
#~ "total);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut race = Race::new(\"Monaco Grand Prix\");\n"
#~ "    race.add_lap(70);\n"
#~ "    race.add_lap(68);\n"
#~ "    race.print_laps();\n"
#~ "    race.add_lap(71);\n"
#~ "    race.print_laps();\n"
#~ "    race.finish();\n"
#~ "    // race.add_lap(42);\n"
#~ "}\n"
#~ "```"

#~ msgid "All four methods here use a different method receiver."
#~ msgstr "ì´ ë„¤ ê°œì˜ ë©”ì„œë“œëŠ” ì„œë¡œ ë‹¤ë¥¸ ìœ í˜•ì˜ ë¦¬ì‹œë²„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "You can point out how that changes what the function can do with the "
#~ "variable values and if/how it can be used again in `main`."
#~ msgstr ""
#~ "ë¦¬ì‹œë²„ì˜ ìœ í˜•ì— ë”°ë¼ í•¨ìˆ˜ê°€ í•  ìˆ˜ ìˆëŠ” ì¼ì´ ë‹¬ë¼ì§€ê³ , ë˜ ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•œ "
#~ "ë’¤ `main`ì—ì„œ í•´ë‹¹ ê°ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ë„ ë‹¬ë¼ì§„ë‹¤ëŠ” ì ì„ ê°•ì¡°í•˜ì„¸"
#~ "ìš”."

#~ msgid ""
#~ "You can showcase the error that appears when trying to call `finish` "
#~ "twice."
#~ msgstr "`finish`ë¥¼ ë‘ë²ˆ í˜¸ì¶œí•˜ì—¬ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Note that although the method receivers are different, the non-static "
#~ "functions are called the same way in the main body. Rust enables "
#~ "automatic referencing and dereferencing when calling methods. Rust "
#~ "automatically adds in the `&`, `*`, `muts` so that that object matches "
#~ "the method signature."
#~ msgstr ""
#~ "ë¹„ë¡ ë©”ì„œë“œ receiverëŠ” ë‹¤ë¥´ì§€ë§Œ main í•¨ìˆ˜ì—ì„œ ë¹„ ì •ì  í•¨ìˆ˜ë¥¼ ë¶€ë¥´ëŠ” ë°©ë²•"
#~ "ì€ ê°™ìŠµë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ë•Œ ìë™ìœ¼ë¡œ ì°¸ì¡°/ì—­ì°¸ì¡°(ë”°ë¼ê°€ê¸°)ë¥¼ "
#~ "ìˆ˜í–‰í•©ë‹ˆë‹¤. ëŸ¬ìŠ¤íŠ¸ëŠ” ê°ì²´ì™€ ë§¤ì„œë“œ ì‹œê·¸ë‹ˆì²˜ê°€ ì„œë¡œ ë§¤ì¹˜ë˜ë„ë¡ ê°ì²´ì— `&`, "
#~ "`*`, `muts`ë¥¼ ìë™ìœ¼ë¡œ ë¶™ì—¬ì¤ë‹ˆë‹¤."

#~ msgid ""
#~ "You might point out that `print_laps` is using a vector that is iterated "
#~ "over. We describe vectors in more detail in the afternoon. "
#~ msgstr ""
#~ "`print_laps`í•¨ìˆ˜ì—ì„œ ë²¡í„°ë¥¼ ì–´ë–¤ ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ìˆëŠ”ì§€ ì–¸ê¸‰í•˜ëŠ” ê²ƒë„ ì¢‹ìŠµ"
#~ "ë‹ˆë‹¤. ë²¡í„°ëŠ” ì˜¤í›„ ê°•ì˜ì—ì„œ ë” ìì„¸íˆ ì„¤ëª…í•  ê²ƒì…ë‹ˆë‹¤. "

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let input = 'x';\n"
#~ "\n"
#~ "    match input {\n"
#~ "        'q'                   => println!(\"Quitting\"),\n"
#~ "        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
#~ "        '0'..='9'             => println!(\"Number input\"),\n"
#~ "        _                     => println!(\"Something else\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let input = 'x';\n"
#~ "\n"
#~ "    match input {\n"
#~ "        'q'                   => println!(\"Quitting\"),\n"
#~ "        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
#~ "        '0'..='9'             => println!(\"Number input\"),\n"
#~ "        _                     => println!(\"Something else\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "The `_` pattern is a wildcard pattern which matches any value."
#~ msgstr "`_`íŒ¨í„´ì€ ì–´ë–¤ ê°’ê³¼ë„ ë§¤ì¹­ë˜ëŠ” ì™€ì¼ë“œì¹´ë“œì…ë‹ˆë‹¤."

#~ msgid ""
#~ "It can be useful to show how binding works, by for instance replacing a "
#~ "wildcard character with a variable, or removing the quotes around `q`."
#~ msgstr ""
#~ "ì™€ì¼ë“œì¹´ë“œ ë¬¸ìë¥¼ ë³€ìˆ˜ë¡œ ë°”ê¾¸ê±°ë‚˜ `q`ì˜ ë”°ì˜´í‘œë¥¼ ì œê±°í•˜ëŠ” ì‹ìœ¼ë¡œ ìˆ˜ì •í•˜ë©´"
#~ "ì„œ ë°”ì¸ë”©ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ë³´ì—¬ì£¼ëŠ” ê²ƒë„ ìœ ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid "You can demonstrate matching on a reference."
#~ msgstr "ì°¸ì¡°ë¥¼ ë§¤ì¹­í•˜ëŠ” ê²ƒë„ ì‹œì—°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "This might be a good time to bring up the concept of irrefutable "
#~ "patterns, as the term can show up in error messages."
#~ msgstr ""
#~ "ì—ëŸ¬ ë©”ì‹œì§€ì— \"ë°˜ë°• ë¶ˆê°€ëŠ¥ íŒ¨í„´(irrefutable pattern)\"ì´ë€ ìš©ì–´ê°€ ë“±ì¥í•˜"
#~ "ê¸°ë„ í•©ë‹ˆë‹¤. ì§€ê¸ˆ ê·¸ ì˜ë¯¸ë¥¼ ì†Œê°œí•˜ëŠ” ê²ƒë„ ì¢‹ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum Result {\n"
#~ "    Ok(i32),\n"
#~ "    Err(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn divide_in_two(n: i32) -> Result {\n"
#~ "    if n % 2 == 0 {\n"
#~ "        Result::Ok(n / 2)\n"
#~ "    } else {\n"
#~ "        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let n = 100;\n"
#~ "    match divide_in_two(n) {\n"
#~ "        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
#~ "        Result::Err(msg) => println!(\"sorry, an error happened: "
#~ "{msg}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum Result {\n"
#~ "    Ok(i32),\n"
#~ "    Err(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn divide_in_two(n: i32) -> Result {\n"
#~ "    if n % 2 == 0 {\n"
#~ "        Result::Ok(n / 2)\n"
#~ "    } else {\n"
#~ "        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let n = 100;\n"
#~ "    match divide_in_two(n) {\n"
#~ "        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
#~ "        Result::Err(msg) => println!(\"sorry, an error happened: "
#~ "{msg}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "You can also destructure `structs`:"
#~ msgstr "`struct` êµ¬ì¡°ì²´ ì—­ì‹œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Foo {\n"
#~ "    x: (u32, u32),\n"
#~ "    y: u32,\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let foo = Foo { x: (1, 2), y: 3 };\n"
#~ "    match foo {\n"
#~ "        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
#~ "        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
#~ "        Foo { y, .. }        => println!(\"y = {y}, other fields were "
#~ "ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Foo {\n"
#~ "    x: (u32, u32),\n"
#~ "    y: u32,\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let foo = Foo { x: (1, 2), y: 3 };\n"
#~ "    match foo {\n"
#~ "        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
#~ "        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
#~ "        Foo { y, .. }        => println!(\"y = {y}, other fields were "
#~ "ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let triple = [0, -2, 3];\n"
#~ "    println!(\"Tell me about {triple:?}\");\n"
#~ "    match triple {\n"
#~ "        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
#~ "        _         => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let triple = [0, -2, 3];\n"
#~ "    println!(\"Tell me about {triple:?}\");\n"
#~ "    match triple {\n"
#~ "        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
#~ "        _         => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Destructuring of slices of unknown length also works with patterns of "
#~ "fixed length."
#~ msgstr ""
#~ "ê¸¸ì´ë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•´ì„œë„ ê³ ì • ê¸¸ì´ íŒ¨í„´ìœ¼ë¡œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    inspect(&[0, -2, 3]);\n"
#~ "    inspect(&[0, -2, 3, 4]);\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(slice: &[i32]) {\n"
#~ "    println!(\"Tell me about {slice:?}\");\n"
#~ "    match slice {\n"
#~ "        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        &[1, ..]   => println!(\"First is 1 and the rest were "
#~ "ignored\"),\n"
#~ "        _          => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    inspect(&[0, -2, 3]);\n"
#~ "    inspect(&[0, -2, 3, 4]);\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(slice: &[i32]) {\n"
#~ "    println!(\"Tell me about {slice:?}\");\n"
#~ "    match slice {\n"
#~ "        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        &[1, ..]   => println!(\"First is 1 and the rest were "
#~ "ignored\"),\n"
#~ "        _          => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "When matching, you can add a _guard_ to a pattern. This is an arbitrary "
#~ "Boolean expression which will be executed if the pattern matches:"
#~ msgstr ""
#~ "íŒ¨í„´ ë’¤ì— ê°€ë“œ(guard, ì¡°ê±´ì‹)ë¥¼ ë§ë¶™ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ë“œëŠ” íŒ¨í„´ì´ ë§¤ì¹˜ë˜"
#~ "ë©´ ì¶”ê°€ë¡œ ë”°ì ¸ë³´ëŠ” ë¶ˆë¦¬ì–¸ í‘œí˜„ì‹ì…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let pair = (2, -2);\n"
#~ "    println!(\"Tell me about {pair:?}\");\n"
#~ "    match pair {\n"
#~ "        (x, y) if x == y     => println!(\"These are twins\"),\n"
#~ "        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
#~ "        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
#~ "        _                    => println!(\"No correlation...\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[rustfmt::skip]\n"
#~ "fn main() {\n"
#~ "    let pair = (2, -2);\n"
#~ "    println!(\"Tell me about {pair:?}\");\n"
#~ "    match pair {\n"
#~ "        (x, y) if x == y     => println!(\"These are twins\"),\n"
#~ "        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
#~ "        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
#~ "        _                    => println!(\"No correlation...\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "You can use the variables defined in the pattern in your if expression."
#~ msgstr "íŒ¨í„´ì— ì •ì˜ëœ ë³€ìˆ˜ë¥¼ ê°€ë“œì˜ í‘œí˜„ì‹ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid "Day 2: Morning Exercises"
#~ msgstr "2ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#~ msgid "We will look at implementing methods in two contexts:"
#~ msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œë“¤ì€ ë‘ê°€ì§€ ë§¥ë½ì—ì„œ ë©”ì„œë“œ êµ¬í˜„ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤:"

#~ msgid "Simple struct which tracks health statistics."
#~ msgstr "ê±´ê°• ìƒíƒœ í†µê³„ë¥¼ ì¶”ì í•˜ëŠ” í”„ë¡œê·¸ë¨ì˜ ê°„ë‹¨í•œ êµ¬ì¡°ì²´."

#~ msgid "Multiple structs and enums for a drawing library."
#~ msgstr "ë“œë¡œì‰ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìœ„í•œ êµ¬ì¡°ì²´ ë° ì—´ê±°í—."

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct User {\n"
#~ "    name: String,\n"
#~ "    age: u32,\n"
#~ "    height: f32,\n"
#~ "    visit_count: usize,\n"
#~ "    last_blood_pressure: Option<(u32, u32)>,\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Measurements {\n"
#~ "    height: f32,\n"
#~ "    blood_pressure: (u32, u32),\n"
#~ "}\n"
#~ "\n"
#~ "pub struct HealthReport<'a> {\n"
#~ "    patient_name: &'a str,\n"
#~ "    visit_count: u32,\n"
#~ "    height_change: f32,\n"
#~ "    blood_pressure_change: Option<(i32, i32)>,\n"
#~ "}\n"
#~ "\n"
#~ "impl User {\n"
#~ "    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn name(&self) -> &str {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn age(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn height(&self) -> f32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn doctor_visits(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_age(&mut self, new_age: u32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_height(&mut self, new_height: f32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
#~ "HealthReport {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_height() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.height(), 155.2);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_set_age() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.age(), 32);\n"
#~ "    bob.set_age(33);\n"
#~ "    assert_eq!(bob.age(), 33);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_visit() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.doctor_visits(), 0);\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (120, 80),\n"
#~ "    });\n"
#~ "    assert_eq!(report.patient_name, \"Bob\");\n"
#~ "    assert_eq!(report.visit_count, 1);\n"
#~ "    assert_eq!(report.blood_pressure_change, None);\n"
#~ "\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (115, 76),\n"
#~ "    });\n"
#~ "\n"
#~ "    assert_eq!(report.visit_count, 2);\n"
#~ "    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct User {\n"
#~ "    name: String,\n"
#~ "    age: u32,\n"
#~ "    height: f32,\n"
#~ "    visit_count: usize,\n"
#~ "    last_blood_pressure: Option<(u32, u32)>,\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Measurements {\n"
#~ "    height: f32,\n"
#~ "    blood_pressure: (u32, u32),\n"
#~ "}\n"
#~ "\n"
#~ "pub struct HealthReport<'a> {\n"
#~ "    patient_name: &'a str,\n"
#~ "    visit_count: u32,\n"
#~ "    height_change: f32,\n"
#~ "    blood_pressure_change: Option<(i32, i32)>,\n"
#~ "}\n"
#~ "\n"
#~ "impl User {\n"
#~ "    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn name(&self) -> &str {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn age(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn height(&self) -> f32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn doctor_visits(&self) -> u32 {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_age(&mut self, new_age: u32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn set_height(&mut self, new_height: f32) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
#~ "HealthReport {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_height() {\n"
#~ "    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.height(), 155.2);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_set_age() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.age(), 32);\n"
#~ "    bob.set_age(33);\n"
#~ "    assert_eq!(bob.age(), 33);\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_visit() {\n"
#~ "    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
#~ "    assert_eq!(bob.doctor_visits(), 0);\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (120, 80),\n"
#~ "    });\n"
#~ "    assert_eq!(report.patient_name, \"Bob\");\n"
#~ "    assert_eq!(report.visit_count, 1);\n"
#~ "    assert_eq!(report.blood_pressure_change, None);\n"
#~ "\n"
#~ "    let report = bob.visit_doctor(Measurements {\n"
#~ "        height: 156.1,\n"
#~ "        blood_pressure: (115, 76),\n"
#~ "    });\n"
#~ "\n"
#~ "    assert_eq!(report.visit_count, 2);\n"
#~ "    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
#~ "}\n"
#~ "```"

#~ msgid "Polygon Struct"
#~ msgstr "Polygon êµ¬ì¡°ì²´"

#~ msgid ""
#~ "We will create a `Polygon` struct which contain some points. Copy the "
#~ "code below to <https://play.rust-lang.org/> and fill in the missing "
#~ "methods to make the tests pass:"
#~ msgstr ""
#~ "ìš°ë¦¬ëŠ” ëª‡ê°œì˜ ê¼­ì§€ì ì„ ê°€ì§„ ë‹¤ê°í˜•ì„ í‘œí˜„í•˜ëŠ” `Polygon` êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ ê²ƒì…"
#~ "ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í•˜"
#~ "ë„ë¡ ë¹ ì§„ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct Point {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Point {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Polygon {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Polygon {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Circle {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Circle {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Shape {\n"
#~ "    Polygon(Polygon),\n"
#~ "    Circle(Circle),\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    fn round_two_digits(x: f64) -> f64 {\n"
#~ "        (x * 100.0).round() / 100.0\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_magnitude() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_dist() {\n"
#~ "        let p1 = Point::new(10, 10);\n"
#~ "        let p2 = Point::new(14, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_add() {\n"
#~ "        let p1 = Point::new(16, 16);\n"
#~ "        let p2 = p1 + Point::new(-4, 3);\n"
#~ "        assert_eq!(p2, Point::new(12, 19));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_left_most_point() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "        assert_eq!(poly.left_most_point(), Some(p1));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_iter() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "\n"
#~ "        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
#~ "        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, "
#~ "16)]);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_shape_perimeters() {\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(Point::new(12, 13));\n"
#~ "        poly.add_point(Point::new(17, 11));\n"
#~ "        poly.add_point(Point::new(16, 16));\n"
#~ "        let shapes = vec![\n"
#~ "            Shape::from(poly),\n"
#~ "            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimeters = shapes\n"
#~ "            .iter()\n"
#~ "            .map(Shape::perimeter)\n"
#~ "            .map(round_two_digits)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub struct Point {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Point {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Polygon {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Polygon {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Circle {\n"
#~ "    // add fields\n"
#~ "}\n"
#~ "\n"
#~ "impl Circle {\n"
#~ "    // add methods\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Shape {\n"
#~ "    Polygon(Polygon),\n"
#~ "    Circle(Circle),\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    fn round_two_digits(x: f64) -> f64 {\n"
#~ "        (x * 100.0).round() / 100.0\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_magnitude() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_dist() {\n"
#~ "        let p1 = Point::new(10, 10);\n"
#~ "        let p2 = Point::new(14, 13);\n"
#~ "        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_point_add() {\n"
#~ "        let p1 = Point::new(16, 16);\n"
#~ "        let p2 = p1 + Point::new(-4, 3);\n"
#~ "        assert_eq!(p2, Point::new(12, 19));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_left_most_point() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "        assert_eq!(poly.left_most_point(), Some(p1));\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_polygon_iter() {\n"
#~ "        let p1 = Point::new(12, 13);\n"
#~ "        let p2 = Point::new(16, 16);\n"
#~ "\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(p1);\n"
#~ "        poly.add_point(p2);\n"
#~ "\n"
#~ "        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
#~ "        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, "
#~ "16)]);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_shape_perimeters() {\n"
#~ "        let mut poly = Polygon::new();\n"
#~ "        poly.add_point(Point::new(12, 13));\n"
#~ "        poly.add_point(Point::new(17, 11));\n"
#~ "        poly.add_point(Point::new(16, 16));\n"
#~ "        let shapes = vec![\n"
#~ "            Shape::from(poly),\n"
#~ "            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
#~ "        ];\n"
#~ "        let perimeters = shapes\n"
#~ "            .iter()\n"
#~ "            .map(Shape::perimeter)\n"
#~ "            .map(round_two_digits)\n"
#~ "            .collect::<Vec<_>>();\n"
#~ "        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "Since the method signatures are missing from the problem statements, the "
#~ "key part of the exercise is to specify those correctly. You don't have to "
#~ "modify the tests."
#~ msgstr ""
#~ "ëˆ„ë½ëœ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì •ì˜í•˜ëŠ” ê²ƒì´ ë¬¸ì œì˜ í•µì‹¬ ë¶€ë¶„ì…ë‹ˆë‹¤. í…Œ"
#~ "ìŠ¤íŠ¸ëŠ” ìˆ˜ì •í•˜ë©´ ì•ˆë©ë‹ˆë‹¤."

#~ msgid "Other interesting parts of the exercise:"
#~ msgstr "ì—°ìŠµë¬¸ì œì˜ ë‹¤ë¥¸ í¥ë¯¸ë¡œìš´ ë¶€ë¶„:"

#~ msgid ""
#~ "Derive a `Copy` trait for some structs, as in tests the methods sometimes "
#~ "don't borrow their arguments."
#~ msgstr ""
#~ "í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ë³´ë©´ ì–´ë–¤ ë©”ì„œë“œë“¤ì€ ì¸ìë¥¼ borrowí•˜ëŠ” ëŒ€ì‹  `Copy` íŠ¸ë ˆì‡ì„ "
#~ "ì‚¬ìš©í•˜ê¸°ë„ í•©ë‹ˆë‹¤. êµ¬ì¡°ì²´ê°€ `Copy` íŠ¸ë ˆì‡ì„ ìƒì†(derive)í•˜ë„ë¡ í•˜ë©´ ë©ë‹ˆ"
#~ "ë‹¤."

#~ msgid ""
#~ "Discover that `Add` trait must be implemented for two objects to be "
#~ "addable via \"+\". Note that we do not discuss generics until Day 3."
#~ msgstr ""
#~ "\"+\"ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‘ ê°ì²´ë¥¼ ì„œë¡œ ë”í•˜ë ¤ë©´ `Add` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. "
#~ "ì´ëŠ” 3ì¼ì°¨ì— ë‹¤ë£° ë‚´ìš©ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "As we have seen, `if` is an expression in Rust. It is used to "
#~ "conditionally evaluate one of two blocks, but the blocks can have a value "
#~ "which then becomes the value of the `if` expression. Other control flow "
#~ "expressions work similarly in Rust."
#~ msgstr ""
#~ "ì•ì—ì„œ ì‚´í´ë³¸ ë°”ì™€ ê°™ì´ ëŸ¬ìŠ¤íŠ¸ì—ì„œ `if`ëŠ” í‘œí˜„ì‹ì…ë‹ˆë‹¤. ì¡°ê±´ì— ë”°ë¼ ë‘ ë¸”"
#~ "ë¡ ì¤‘ í•˜ë‚˜ë¥¼ í‰ê°€í•˜ë©°, ê·¸ ê²°ê³¼ê°’ì´ `if` í‘œí˜„ì‹ì˜ ê°’ì´ ë©ë‹ˆë‹¤. ë‹¤ë¥¸ íë¦„ì œ"
#~ "ì–´ í‘œí˜„ì‹ë„ ìœ ì‚¬í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = {\n"
#~ "        let y = 10;\n"
#~ "        println!(\"y: {y}\");\n"
#~ "        let z = {\n"
#~ "            let w = {\n"
#~ "                3 + 4\n"
#~ "            };\n"
#~ "            println!(\"w: {w}\");\n"
#~ "            y * w\n"
#~ "        };\n"
#~ "        println!(\"z: {z}\");\n"
#~ "        z - y\n"
#~ "    };\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let x = {\n"
#~ "        let y = 10;\n"
#~ "        println!(\"y: {y}\");\n"
#~ "        let z = {\n"
#~ "            let w = {\n"
#~ "                3 + 4\n"
#~ "            };\n"
#~ "            println!(\"w: {w}\");\n"
#~ "            y * w\n"
#~ "        };\n"
#~ "        println!(\"z: {z}\");\n"
#~ "        z - y\n"
#~ "    };\n"
#~ "    println!(\"x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The same rule is used for functions: the value of the function body is "
#~ "the return value:"
#~ msgstr ""
#~ "í•¨ìˆ˜ì—ë„ ë™ì¼í•œ ê·œì¹™ì´ ì ìš©ë©ë‹ˆë‹¤. í•¨ìˆ˜ ë°”ë””ë¥¼ ì´ë£¨ëŠ” ë¸”ë¡ì˜ ê°’ì´ ë°˜í™˜ê°’"
#~ "ì´ ë©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn double(x: i32) -> i32 {\n"
#~ "    x + x\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"doubled: {}\", double(7));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn double(x: i32) -> i32 {\n"
#~ "    x + x\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"doubled: {}\", double(7));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The point of this slide is to show that blocks have a type and value in "
#~ "Rust. "
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì—ì„œëŠ” ë¸”ë¡ì´ íƒ€ì…ê³¼ ê°’ì„ ê°€ì§„ë‹¤ëŠ” ì ì´ ì´ ìŠ¬ë¼ì´ë“œì˜ í•µì‹¬ì…ë‹ˆë‹¤. "

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    if x % 2 == 0 {\n"
#~ "        x = x / 2;\n"
#~ "    } else {\n"
#~ "        x = 3 * x + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    if x % 2 == 0 {\n"
#~ "        x = x / 2;\n"
#~ "    } else {\n"
#~ "        x = 3 * x + 1;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    x = if x % 2 == 0 {\n"
#~ "        x / 2\n"
#~ "    } else {\n"
#~ "        3 * x + 1\n"
#~ "    };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    x = if x % 2 == 0 {\n"
#~ "        x / 2\n"
#~ "    } else {\n"
#~ "        3 * x + 1\n"
#~ "    };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let arg = std::env::args().next();\n"
#~ "    if let Some(value) = arg {\n"
#~ "        println!(\"Program name: {value}\");\n"
#~ "    } else {\n"
#~ "        println!(\"Missing name?\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let arg = std::env::args().next();\n"
#~ "    if let Some(value) = arg {\n"
#~ "        println!(\"Program name: {value}\");\n"
#~ "    } else {\n"
#~ "        println!(\"Missing name?\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "See [pattern matching](../pattern-matching.md) for more details on "
#~ "patterns in Rust."
#~ msgstr ""
#~ "íŒ¨í„´ì— ê´€í•œ ì„¤ëª…ì€ [íŒ¨í„´ ë§¤ì¹­](../pattern-matching.md)ì„ ì°¸ì¡°í•˜ì„¸ìš”."

#~ msgid ""
#~ "Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-"
#~ "example/flow_control/let_else.html) construct allows to do a "
#~ "destructuring assignment, or if it fails, execute a block which is "
#~ "required to abort normal control flow (with `panic`/`return`/`break`/"
#~ "`continue`):"
#~ msgstr ""
#~ "1.65ë¶€í„° ìœ ì‚¬í•œ [let-else](https://doc.rust-lang.org/rust-by-example/"
#~ "flow_control/let_else.html) êµ¬ì„±ì€ ë””ìŠ¤íŠ¸ëŸ­ì²˜ë§ í• ë‹¹ì„ ì‹¤í–‰í•˜ê±°ë‚˜ ì‹¤íŒ¨í•  "
#~ "ê²½ìš° ë°˜í™˜ë˜ì§€ ì•ŠëŠ” ë¸”ë¡ ë¸Œëœì¹˜(panic/return/break/continue)ë¥¼ ë³´ìœ í•˜ë„ë¡ "
#~ "í—ˆìš©í•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
#~ "}\n"
#~ " \n"
#~ "fn second_word_to_upper(s: &str) -> Option<String> {\n"
#~ "    let mut it = s.split(' ');\n"
#~ "    let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
#~ "        return None;\n"
#~ "    };\n"
#~ "    Some(item.to_uppercase())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
#~ "}\n"
#~ " \n"
#~ "fn second_word_to_upper(s: &str) -> Option<String> {\n"
#~ "    let mut it = s.split(' ');\n"
#~ "    let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
#~ "        return None;\n"
#~ "    };\n"
#~ "    Some(item.to_uppercase())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    while x != 1 {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    while x != 1 {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "`for` loops"
#~ msgstr "`for` ë°˜ë³µë¬¸"

#~ msgid ""
#~ "The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is "
#~ "closely related to the [`while let` loop](while-let-expressions.md). It "
#~ "will automatically call `into_iter()` on the expression and then iterate "
#~ "over it:"
#~ msgstr ""
#~ "`for` ë°˜ë³µë¬¸ì€ `while let` ë°˜ë³µë¬¸ê³¼ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆë‹¤. `for` ë°˜ë³µë¬¸ì€ ìë™ìœ¼"
#~ "ë¡œ `into_iter()`ë¥¼ í˜¸ì¶œí•œ ë‹¤ìŒ ì´ë¥¼ ë°˜ë³µí•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "\n"
#~ "    for x in v {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "    \n"
#~ "    for i in (0..10).step_by(2) {\n"
#~ "        println!(\"i: {i}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "\n"
#~ "    for x in v {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "    \n"
#~ "    for i in (0..10).step_by(2) {\n"
#~ "        println!(\"i: {i}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "You can use `break` and `continue` here as usual."
#~ msgstr "ë‹¤ë¥¸ ì–¸ì–´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `break` ì™€ `continue`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid "Index iteration is not a special syntax in Rust for just that case."
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ëŠ” ì¸ë±ìŠ¤ ê¸°ë°˜ì˜ ë°˜ë³µì„ ìœ„í•œ ë³„ë„ì˜ ë¬¸ë²•ì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#~ msgid "`(0..10)` is a range that implements an `Iterator` trait. "
#~ msgstr "`(0..10)`ì€ `Iterator` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ë²”ìœ„(range) ê°’ì…ë‹ˆë‹¤. "

#~ msgid ""
#~ "`step_by` is a method that returns another `Iterator` that skips every "
#~ "other element. "
#~ msgstr ""
#~ "`step_by`ëŠ” ë°˜ë³µìì˜ ìš”ì†Œë“¤ì„ ê±´ë„ˆë›°ëŠ” ë˜ë‹¤ë¥¸ `Iterator`ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ"
#~ "ì…ë‹ˆë‹¤. "

#~ msgid ""
#~ "Modify the elements in the vector and explain the compiler errors. Change "
#~ "vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
#~ msgstr ""
#~ "ë²¡í„° ìš”ì†Œë“¤ì„ ìˆ˜ì •í•˜ë ¤ê³  í•˜ë©´ ë‚˜ì˜¤ëŠ” ì»´íŒŒì¼ëŸ¬ ì—ëŸ¬ë¥¼ ê°™ì´ ì‚´í´ë³´ì„¸ìš”. `v` "
#~ "ë²¡í„°ë¥¼ ê°€ë³€ ë³€ìˆ˜ë¡œ ë³€ê²½í•˜ê³  ë£¨í”„ëŠ” `for x in v.iter_mut()`ë¡œ ìˆ˜ì •í•˜ì„¸ìš”."

#~ msgid "`loop` expressions"
#~ msgstr "`loop` í‘œí˜„ì‹"

#~ msgid ""
#~ "Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
#~ "expressions/loop-expr.html#infinite-loops) which creates an endless loop."
#~ msgstr ""
#~ "ë§ˆì§€ë§‰ìœ¼ë¡œ, ë¬´í•œ ë£¨í”„ë¥¼ ë§Œë“œëŠ” [`loop` í‚¤ì›Œë“œ](https://doc.rust-lang.org/"
#~ "reference/expressions/loop-expr.html#infinite-loops)ê°€ ìˆìŠµë‹ˆë‹¤."

#~ msgid "Here you must either `break` or `return` to stop the loop:"
#~ msgstr ""
#~ "ë”°ë¼ì„œ ë°˜ë“œì‹œ `break` ë˜ëŠ” `return`ì„ ì‚¬ìš©í•´ì„œ ë£¨í”„ë¥¼ ì •ì§€í•´ì•¼ í•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    loop {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "        if x == 1 {\n"
#~ "            break;\n"
#~ "        }\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut x = 10;\n"
#~ "    loop {\n"
#~ "        x = if x % 2 == 0 {\n"
#~ "            x / 2\n"
#~ "        } else {\n"
#~ "            3 * x + 1\n"
#~ "        };\n"
#~ "        if x == 1 {\n"
#~ "            break;\n"
#~ "        }\n"
#~ "    }\n"
#~ "    println!(\"Final x: {x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
#~ msgstr "`loop`ë¥¼ ê°’(ì˜ˆ: `break 8`)ìœ¼ë¡œ ë‚˜ëˆ„ê³  ì¶œë ¥í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "The [`match` keyword](https://doc.rust-lang.org/reference/expressions/"
#~ "match-expr.html) is used to match a value against one or more patterns. "
#~ "In that sense, it works like a series of `if let` expressions:"
#~ msgstr ""
#~ "`match`í‚¤ì›Œë“œëŠ” ì–´ë–¤ ê°’ì„ í•˜ë‚˜ ì´ìƒì˜ íŒ¨í„´ì— ëŒ€í•´ ë§¤ì¹˜í•˜ëŠ”ë° ì‚¬ìš©í•©ë‹ˆë‹¤. "
#~ "ê·¸ëŸ° ë©´ì—ì„œ `if let` í‘œí˜„ì‹ì„ ì—¬ëŸ¬ê°œ ì´ì–´ ë†“ì€ ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    match std::env::args().next().as_deref() {\n"
#~ "        Some(\"cat\") => println!(\"Will do cat things\"),\n"
#~ "        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
#~ "        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
#~ "        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
#~ "        None        => println!(\"Hmm, no program name?\"),\n"
#~ "        _           => println!(\"Unknown program name!\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    match std::env::args().next().as_deref() {\n"
#~ "        Some(\"cat\") => println!(\"Will do cat things\"),\n"
#~ "        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
#~ "        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
#~ "        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
#~ "        None        => println!(\"Hmm, no program name?\"),\n"
#~ "        _           => println!(\"Unknown program name!\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Save the match expression to a variable and print it out."
#~ msgstr "`match` í‘œí˜„ì‹ì„ ë³€ìˆ˜ì— í• ë‹¹í•˜ê³  ê·¸ ê°’ì„ ì¶œë ¥í•´ë³´ì„¸ìš”."

#~ msgid "Remove `.as_deref()` and explain the error."
#~ msgstr "`.as_deref()`ë¥¼ ì§€ì›Œë³´ê³ , ì´ ë•Œ ë‚˜ì˜¤ëŠ” ì—ëŸ¬ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”."

#~ msgid ""
#~ "`std::env::args().next()` returns an `Option<String>`, but we cannot "
#~ "match against `String`."
#~ msgstr ""
#~ "`std::env::args().next()`ëŠ” `Option<String>` ê°’ì„ ë°˜í™˜í•˜ëŠ”ë°, `String`ì€ "
#~ "ì§ì ‘ ë§¤ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our "
#~ "case, this turns `Option<String>` into `Option<&str>`."
#~ msgstr ""
#~ "`as_deref()`ëŠ” `Option<T>`ë¥¼ `Option<&T::Target>`ìœ¼ë¡œ ë°”ê¿”ì¤ë‹ˆë‹¤. ì´ ê²½ìš°"
#~ "ëŠ” `Option<String>`ì—ì„œ `Option<&str>`ë¡œ ë°”ë€ë‹ˆë‹¤."

#~ msgid ""
#~ "We can now use pattern matching to match against the `&str` inside "
#~ "`Option`."
#~ msgstr "ì´ì œëŠ” íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ `Option` ì•ˆì˜ `&str`ì„ ë§¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "    'outer: while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "        let mut i = 0;\n"
#~ "        while i < x {\n"
#~ "            println!(\"x: {x}, i: {i}\");\n"
#~ "            i += 1;\n"
#~ "            if i == 3 {\n"
#~ "                break 'outer;\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "    'outer: while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "        let mut i = 0;\n"
#~ "        while i < x {\n"
#~ "            println!(\"x: {x}, i: {i}\");\n"
#~ "            i += 1;\n"
#~ "            if i == 3 {\n"
#~ "                break 'outer;\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "The common vocabulary types include:"
#~ msgstr "ì¼ë°˜ì ì¸ íƒ€ì…ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "[`Option` and `Result`](std/option-result.md) types: used for optional "
#~ "values and [error handling](error-handling.md)."
#~ msgstr ""
#~ "[`Option`ê³¼ `Result`](std/option-result.md) : ì–´ë–¤ ê°’ì´ ìˆê±°ë‚˜ ì—†ê±°ë‚˜ í•˜"
#~ "ëŠ” ê²½ìš°, ê·¸ë¦¬ê³  [ì˜¤ë¥˜ ì²˜ë¦¬](error-handling.md)ì— ì‚¬ìš©í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "[`String`](std/string.md): the default string type used for owned data."
#~ msgstr ""
#~ "[`String`](std/string.md): ê¸°ë³¸ì ì¸ ë¬¸ìì—´ íƒ€ì…ìœ¼ë¡œ, ë¬¸ìì—´ ë°ì´í„°ë¥¼ ì†Œìœ "
#~ "í•˜ëŠ” ê²½ìš°ì— ì‚¬ìš©í•©ë‹ˆë‹¤."

#~ msgid "[`Vec`](std/vec.md): a standard extensible vector."
#~ msgstr "[`Vec`](std/vec.md): ê°€ë³€ í¬ê¸°ì˜ í‘œì¤€ ë²¡í„° íƒ€ì…ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
#~ "algorithm."
#~ msgstr ""
#~ "[`HashMap`](std/hashmap.md): í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ì„ ë”°ë¡œ ì§€ì •í•  ìˆ˜ë„ ìˆëŠ” í•´ì‹œë§µ "
#~ "íƒ€ì…ì…ë‹ˆë‹¤."

#~ msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
#~ msgstr "[`Box`](std/box.md): í™ ë°ì´í„°ì— ëŒ€í•œ ì†Œìœ  í¬ì¸í„°ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
#~ "data."
#~ msgstr ""
#~ "[`Rc`](std/rc.md): í™ì— í• ë‹¹ëœ ë°ì´í„°ì— ëŒ€í•œ ì°¸ì¡° ì¹´ìš´íŒ… ê³µìœ  í¬ì¸í„°ì…ë‹ˆ"
#~ "ë‹¤."

#~ msgid "`Option` and `Result`"
#~ msgstr "`Option`ê³¼ `Result`"

#~ msgid "The types represent optional data:"
#~ msgstr "ì´ íƒ€ì…ì€ ì„ íƒì  ë°ì´í„°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let numbers = vec![10, 20, 30];\n"
#~ "    let first: Option<&i8> = numbers.first();\n"
#~ "    println!(\"first: {first:?}\");\n"
#~ "\n"
#~ "    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
#~ "    println!(\"idx: {idx:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let numbers = vec![10, 20, 30];\n"
#~ "    let first: Option<&i8> = numbers.first();\n"
#~ "    println!(\"first: {first:?}\");\n"
#~ "\n"
#~ "    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
#~ "    println!(\"idx: {idx:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "`Option<&T>` has zero space overhead compared to `&T`."
#~ msgstr "`Option<&T>` ëŠ” `&T`ì— ë¹„í•´ ê³µê°„ ì˜¤ë²„í—¤ë“œê°€ ì—†ìŠµë‹ˆë‹¤."

#~ msgid "`binary_search` returns `Result<usize, usize>`."
#~ msgstr "`binary_search`ëŠ” `Result<usize, usize>`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#~ msgid "If found, `Result::Ok` holds the index where the element is found."
#~ msgstr ""
#~ "ìš”ì†Œê°€ ë°œê²¬ëœë‹¤ë©´, `Result::Ok`ëŠ” ë°œê²¬ëœ ìš”ì†Œì˜ ì¸ë±ìŠ¤ë¥¼ ë³´ìœ í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Otherwise, `Result::Err` contains the index where such an element should "
#~ "be inserted."
#~ msgstr ""
#~ "ì•„ë‹ˆë©´, `Result::Err`ì—ëŠ” ìš”ì†Œê°€ ì‚½ì…ë˜ì•¼ í•˜ëŠ” ì¸ë±ìŠ¤ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::new();\n"
#~ "    s1.push_str(\"Hello\");\n"
#~ "    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
#~ "\n"
#~ "    let mut s2 = String::with_capacity(s1.len() + 1);\n"
#~ "    s2.push_str(&s1);\n"
#~ "    s2.push('!');\n"
#~ "    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
#~ "\n"
#~ "    let s3 = String::from(\"ğŸ‡¨ğŸ‡­\");\n"
#~ "    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
#~ "             s3.chars().count());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::new();\n"
#~ "    s1.push_str(\"Hello\");\n"
#~ "    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
#~ "\n"
#~ "    let mut s2 = String::with_capacity(s1.len() + 1);\n"
#~ "    s2.push_str(&s1);\n"
#~ "    s2.push('!');\n"
#~ "    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
#~ "\n"
#~ "    let s3 = String::from(\"ğŸ‡¨ğŸ‡­\");\n"
#~ "    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
#~ "             s3.chars().count());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v1 = Vec::new();\n"
#~ "    v1.push(42);\n"
#~ "    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
#~ "\n"
#~ "    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
#~ "    v2.extend(v1.iter());\n"
#~ "    v2.push(9999);\n"
#~ "    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
#~ "\n"
#~ "    // Canonical macro to initialize a vector with elements.\n"
#~ "    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
#~ "\n"
#~ "    // Retain only the even elements.\n"
#~ "    v3.retain(|x| x % 2 == 0);\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "\n"
#~ "    // Remove consecutive duplicates.\n"
#~ "    v3.dedup();\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut v1 = Vec::new();\n"
#~ "    v1.push(42);\n"
#~ "    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
#~ "\n"
#~ "    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
#~ "    v2.extend(v1.iter());\n"
#~ "    v2.push(9999);\n"
#~ "    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
#~ "\n"
#~ "    // ìš”ì†Œë¡œ ë²¡í„°ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” í‘œì¤€ ë§¤í¬ë¡œì…ë‹ˆë‹¤.\n"
#~ "    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
#~ "\n"
#~ "    // ì§ìˆ˜ ìš”ì†Œë§Œ ìœ ì§€í•©ë‹ˆë‹¤.\n"
#~ "    v3.retain(|x| x % 2 == 0);\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "\n"
#~ "    // ì—°ì† ì¤‘ë³µì„ ì‚­ì œí•©ë‹ˆë‹¤.\n"
#~ "    v3.dedup();\n"
#~ "    println!(\"{v3:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Show iterating over a vector and mutating the value: `for e in &mut v "
#~ "{ *e += 50; }`"
#~ msgstr ""
#~ "ë²¡í„°ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ê°’ì„ ë³€ê²½í•  ìˆ˜ë„ ìˆìŒì„ ë³´ì—¬ì£¼ì„¸ìš”: `for e in &mut v "
#~ "{ *e += 50; }`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut page_counts = HashMap::new();\n"
#~ "    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
#~ "207);\n"
#~ "    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
#~ "    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
#~ "\n"
#~ "    if !page_counts.contains_key(\"Les MisÃ©rables\") {\n"
#~ "        println!(\"We know about {} books, but not Les MisÃ©rables.\",\n"
#~ "                 page_counts.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        match page_counts.get(book) {\n"
#~ "            Some(count) => println!(\"{book}: {count} pages\"),\n"
#~ "            None => println!(\"{book} is unknown.\")\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // Use the .entry() method to insert a value if nothing is found.\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        let page_count: &mut i32 = page_counts.entry(book.to_string())."
#~ "or_insert(0);\n"
#~ "        *page_count += 1;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"{page_counts:#?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut page_counts = HashMap::new();\n"
#~ "    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
#~ "207);\n"
#~ "    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
#~ "    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
#~ "\n"
#~ "    if !page_counts.contains_key(\"Les MisÃ©rables\") {\n"
#~ "        println!(\"We know about {} books, but not Les MisÃ©rables.\",\n"
#~ "                 page_counts.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        match page_counts.get(book) {\n"
#~ "            Some(count) => println!(\"{book}: {count} pages\"),\n"
#~ "            None => println!(\"{book} is unknown.\")\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // ì•„ë¬´ê²ƒë„ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° .entry() ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê°’ì„ ì‚½ì…í•©ë‹ˆ"
#~ "ë‹¤.\n"
#~ "    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
#~ "Wonderland\"] {\n"
#~ "        let page_count: &mut i32 = page_counts.entry(book.to_string())."
#~ "or_insert(0);\n"
#~ "        *page_count += 1;\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"{page_counts:#?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "  let pc1 = page_counts\n"
#~ "      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
#~ "      .unwrap_or(&336);\n"
#~ "  let pc2 = page_counts\n"
#~ "      .entry(\"The Hunger Games\".to_string())\n"
#~ "      .or_insert(374);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "  let pc1 = page_counts\n"
#~ "      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
#~ "      .unwrap_or(&336);\n"
#~ "  let pc2 = page_counts\n"
#~ "      .entry(\"The Hunger Games\".to_string())\n"
#~ "      .or_insert(374);\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "  let page_counts = HashMap::from([\n"
#~ "    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
#~ "    (\"The Hunger Games\".to_string(), 374),\n"
#~ "  ]);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "  let page_counts = HashMap::from([\n"
#~ "    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
#~ "    (\"The Hunger Games\".to_string(), 374),\n"
#~ "  ]);\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let five = Box::new(5);\n"
#~ "    println!(\"five: {}\", *five);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let five = Box::new(5);\n"
#~ "    println!(\"five: {}\", *five);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bob\n"
#~ " Stack                     Heap\n"
#~ ".- - - - - - -.     .- - - - - - -.\n"
#~ ":             :     :             :\n"
#~ ":    five     :     :             :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":   | o---|---+-----+-->|  5  |   :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":             :     :             :\n"
#~ ":             :     :             :\n"
#~ "`- - - - - - -'     `- - - - - - -'\n"
#~ "```"
#~ msgstr ""
#~ "```bob\n"
#~ "  ìŠ¤íƒ                í™\n"
#~ ".- - - - - - -.     .- - - - - - -.\n"
#~ ":             :     :             :\n"
#~ ":    five     :     :             :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":   | o---|---+-----+-->|  5  |   :\n"
#~ ":   +-----+   :     :   +-----+   :\n"
#~ ":             :     :             :\n"
#~ ":             :     :             :\n"
#~ "`- - - - - - -'     `- - - - - - -'\n"
#~ "```"

#~ msgid ""
#~ "In the above example, you can even leave out the `*` in the `println!` "
#~ "statement thanks to `Deref`. "
#~ msgstr ""
#~ "`Deref` ë•ë¶„ì— ìœ„ ì˜ˆì œì˜ `println!`ë¬¸ì— ì‚¬ìš©ëœ `*`ë¥¼ ë¹¼ë„ ë¬¸ì œê°€ ì—†ìŠµë‹ˆ"
#~ "ë‹¤. "

#~ msgid "Box with Recursive Data Structures"
#~ msgstr "ì¬ê·€ìë£Œ êµ¬ì¡°ì—ì„œì˜ `Box`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "enum List<T> {\n"
#~ "    Cons(T, Box<List<T>>),\n"
#~ "    Nil,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
#~ "new(List::Nil))));\n"
#~ "    println!(\"{list:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "enum List<T> {\n"
#~ "    Cons(T, Box<List<T>>),\n"
#~ "    Nil,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
#~ "new(List::Nil))));\n"
#~ "    println!(\"{list:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = Rc::new(10);\n"
#~ "    let mut b = Rc::clone(&a);\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = Rc::new(10);\n"
#~ "    let mut b = Rc::clone(&a);\n"
#~ "\n"
#~ "    println!(\"a: {a}\");\n"
#~ "    println!(\"b: {b}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::cell::RefCell;\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Node {\n"
#~ "    value: i64,\n"
#~ "    children: Vec<Rc<RefCell<Node>>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Node {\n"
#~ "    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
#~ "        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
#~ "    }\n"
#~ "\n"
#~ "    fn sum(&self) -> i64 {\n"
#~ "        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
#~ "<i64>()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let root = Node::new(1);\n"
#~ "    root.borrow_mut().children.push(Node::new(5));\n"
#~ "    let subtree = Node::new(10);\n"
#~ "    subtree.borrow_mut().children.push(Node::new(11));\n"
#~ "    subtree.borrow_mut().children.push(Node::new(12));\n"
#~ "    root.borrow_mut().children.push(subtree);\n"
#~ "\n"
#~ "    println!(\"graph: {root:#?}\");\n"
#~ "    println!(\"graph sum: {}\", root.borrow().sum());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::cell::RefCell;\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Node {\n"
#~ "    value: i64,\n"
#~ "    children: Vec<Rc<RefCell<Node>>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Node {\n"
#~ "    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
#~ "        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
#~ "    }\n"
#~ "\n"
#~ "    fn sum(&self) -> i64 {\n"
#~ "        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
#~ "<i64>()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let root = Node::new(1);\n"
#~ "    root.borrow_mut().children.push(Node::new(5));\n"
#~ "    let subtree = Node::new(10);\n"
#~ "    subtree.borrow_mut().children.push(Node::new(11));\n"
#~ "    subtree.borrow_mut().children.push(Node::new(12));\n"
#~ "    root.borrow_mut().children.push(subtree);\n"
#~ "\n"
#~ "    println!(\"graph: {root:#?}\");\n"
#~ "    println!(\"graph sum: {}\", root.borrow().sum());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "mod foo {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the foo module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "mod bar {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the bar module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo::do_something();\n"
#~ "    bar::do_something();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "mod foo {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the foo module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "mod bar {\n"
#~ "    pub fn do_something() {\n"
#~ "        println!(\"In the bar module\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo::do_something();\n"
#~ "    bar::do_something();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "mod outer {\n"
#~ "    fn private() {\n"
#~ "        println!(\"outer::private\");\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn public() {\n"
#~ "        println!(\"outer::public\");\n"
#~ "    }\n"
#~ "\n"
#~ "    mod inner {\n"
#~ "        fn private() {\n"
#~ "            println!(\"outer::inner::private\");\n"
#~ "        }\n"
#~ "\n"
#~ "        pub fn public() {\n"
#~ "            println!(\"outer::inner::public\");\n"
#~ "            super::private();\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    outer::public();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "mod outer {\n"
#~ "    fn private() {\n"
#~ "        println!(\"outer::private\");\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn public() {\n"
#~ "        println!(\"outer::public\");\n"
#~ "    }\n"
#~ "\n"
#~ "    mod inner {\n"
#~ "        fn private() {\n"
#~ "            println!(\"outer::inner::private\");\n"
#~ "        }\n"
#~ "\n"
#~ "        pub fn public() {\n"
#~ "            println!(\"outer::inner::public\");\n"
#~ "            super::private();\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    outer::public();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::collections::HashSet;\n"
#~ "use std::mem::transmute;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::collections::HashSet;\n"
#~ "use std::mem::transmute;\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "mod garden;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "mod garden;\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "//! This module implements the garden, including a highly performant "
#~ "germination\n"
#~ "//! implementation.\n"
#~ "\n"
#~ "// Re-export types from this module.\n"
#~ "pub use seeds::SeedPacket;\n"
#~ "pub use garden::Garden;\n"
#~ "\n"
#~ "/// Sow the given seed packets.\n"
#~ "pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
#~ "\n"
#~ "/// Harvest the produce in the garden that is ready.\n"
#~ "pub fn harvest(garden: &mut Garden) { todo!() }\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "//! ì´ ëª¨ë“ˆì€ ë†’ì€ ì„±ëŠ¥ì˜ ë°œì•„ êµ¬í˜„ì„ ë¹„ë¡¯í•˜ì—¬ ì •ì›ì„\n"
#~ "//! êµ¬í˜„í•©ë‹ˆë‹¤.\n"
#~ "\n"
#~ "// ì´ ëª¨ë“ˆì— ì •ì˜ëœ íƒ€ì…ì„ ë°–ìœ¼ë¡œ ê³µê°œí•©ë‹ˆë‹¤.\n"
#~ "pub use seeds::SeedPacket;\n"
#~ "pub use garden::Garden;\n"
#~ "\n"
#~ "/// ì§€ì •ëœ ì”¨ì•— íŒ¨í‚·ì„ ë¿Œë¦½ë‹ˆë‹¤.\n"
#~ "pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
#~ "\n"
#~ "/// ì •ì›ì—ì„œ ì¤€ë¹„ëœ ë†ì‚°ë¬¼ì„ ìˆ˜í™•í•©ë‹ˆë‹¤.\n"
#~ "pub fn harvest(garden: &mut Garden) { todo!() }\n"
#~ "```"

#~ msgid ""
#~ "```ignore\n"
#~ "src/\n"
#~ "â”œâ”€â”€ main.rs\n"
#~ "â”œâ”€â”€ top_module.rs\n"
#~ "â””â”€â”€ top_module/\n"
#~ "    â””â”€â”€ sub_module.rs\n"
#~ "```"
#~ msgstr ""
#~ "```ignore\n"
#~ "src/\n"
#~ "â”œâ”€â”€ main.rs\n"
#~ "â”œâ”€â”€ top_module.rs\n"
#~ "â””â”€â”€ top_module/\n"
#~ "    â””â”€â”€ sub_module.rs\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[path = \"some/path.rs\"]\n"
#~ "mod some_module;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[path = \"some/path.rs\"]\n"
#~ "mod some_module;\n"
#~ "```"

#~ msgid "Day 2: Afternoon Exercises"
#~ msgstr "2ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#~ msgid ""
#~ "The exercises for this afternoon will focus on strings and iterators."
#~ msgstr "ì´ë²ˆ ì—°ìŠµë¬¸ì œëŠ” ë¬¸ìì—´ê³¼ ë°˜ë³µìì— ì´ˆì ì„ ë§ì¶œ ê²ƒì…ë‹ˆë‹¤."

#~ msgid ""
#~ "Copy the code below to <https://play.rust-lang.org/> and implement the "
#~ "function."
#~ msgstr ""
#~ "ì•„ë˜ ì½”ë“œë¥¼ <https://play.rust-lang.org/>ì— ë³µì‚¬í•´ì„œ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "Try to solve the problem the \"simple\" way first, using `for` loops and "
#~ "integers. Then, revisit the solution and try to implement it with "
#~ "iterators."
#~ msgstr ""
#~ "`for`ë°˜ë³µë¬¸ê³¼ ì¸ë±ìŠ¤ë¥¼ ì´ìš©í•˜ëŠ” \"ì‰¬ìš´\"ë°©ë²•ìœ¼ë¡œ ë¨¼ì € í’€ì–´ ë³´ì„¸ìš”. ê·¸ëŸ° ë‹¤"
#~ "ìŒ ë°˜ë³µìë¥¼ ì´ìš©í•´ì„œ ë‹¤ì‹œ í’€ì–´ ë³´ì„¸ìš”."

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn luhn(cc_number: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_non_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty_cc_number() {\n"
#~ "    assert!(!luhn(\"\"));\n"
#~ "    assert!(!luhn(\" \"));\n"
#~ "    assert!(!luhn(\"  \"));\n"
#~ "    assert!(!luhn(\"    \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"0\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_two_digit_cc_number() {\n"
#~ "    assert!(luhn(\" 0 0 \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_valid_cc_number() {\n"
#~ "    assert!(luhn(\"4263 9826 4026 9299\"));\n"
#~ "    assert!(luhn(\"4539 3195 0343 6467\"));\n"
#~ "    assert!(luhn(\"7992 7398 713\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_invalid_cc_number() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn luhn(cc_number: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_non_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"foo\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty_cc_number() {\n"
#~ "    assert!(!luhn(\"\"));\n"
#~ "    assert!(!luhn(\" \"));\n"
#~ "    assert!(!luhn(\"  \"));\n"
#~ "    assert!(!luhn(\"    \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_digit_cc_number() {\n"
#~ "    assert!(!luhn(\"0\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_two_digit_cc_number() {\n"
#~ "    assert!(luhn(\" 0 0 \"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_valid_cc_number() {\n"
#~ "    assert!(luhn(\"4263 9826 4026 9299\"));\n"
#~ "    assert!(luhn(\"4539 3195 0343 6467\"));\n"
#~ "    assert!(luhn(\"7992 7398 713\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_invalid_cc_number() {\n"
#~ "    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
#~ "    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
#~ "    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[allow(dead_code)]\n"
#~ "fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "In this exercise, you are implementing a routing component of a web "
#~ "server. The server is configured with a number of _path prefixes_ which "
#~ "are matched against _request paths_. The path prefixes can contain a "
#~ "wildcard character which matches a full segment. See the unit tests below."
#~ msgstr ""
#~ "ì´ë²ˆ í›ˆë ¨ì€ ì›¹ ì„œë²„ì˜ ë¼ìš°íŒ… ì»´í¬ë„ŒíŠ¸ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì„œë²„ëŠ” _ìš”ì²­ ê²½ë¡œ"
#~ "(request path)_ ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì—¬ëŸ¬ ê°œì˜ _ê²½ë¡œ ì ‘ë‘ì‚¬(path prefix)_ ë¡œ "
#~ "êµ¬ì„±ë©ë‹ˆë‹¤. ê²½ë¡œ ì ‘ë‘ì‚¬ëŠ” ì™€ì¼ë“œì¹´ë“œë¬¸ìë¥¼ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  ì•„ë˜ ë‹¨ìœ„ "
#~ "í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#~ msgid ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
#~ "abc-123\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
#~ "books\"));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/"
#~ "publishersBooks\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
#~ "publishers\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_with_wildcard() {\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/bar/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books/book1\"\n"
#~ "    ));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
#~ "publishers\"));\n"
#~ "    assert!(!prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_without_wildcard() {\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
#~ "abc-123\"));\n"
#~ "    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
#~ "books\"));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/"
#~ "publishersBooks\"));\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
#~ "publishers\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_matches_with_wildcard() {\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/bar/books\"\n"
#~ "    ));\n"
#~ "    assert!(prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/books/book1\"\n"
#~ "    ));\n"
#~ "\n"
#~ "    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
#~ "publishers\"));\n"
#~ "    assert!(!prefix_matches(\n"
#~ "        \"/v1/publishers/*/books\",\n"
#~ "        \"/v1/publishers/foo/booksByAuthor\"\n"
#~ "    ));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Traits: deriving traits, default methods, and important standard library "
#~ "traits."
#~ msgstr ""
#~ "íŠ¸ë ˆì‡: íŠ¸ë ˆì‡ ìƒì†(derive), ë””í´íŠ¸ ë©”ì„œë“œ, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ì— ìˆëŠ” ì¤‘ìš”í•œ íŠ¸"
#~ "ë ˆì‡ë“¤."

#~ msgid ""
#~ "Generics: generic data types, generic methods, monomorphization, and "
#~ "trait objects."
#~ msgstr ""
#~ "ì œë„¤ë¦­: ì œë„¤ë¦­ ë°ì´í„° íƒ€ì…, ì œë„¤ë¦­ ë©”ì„œë“œ, ë‹¨í˜•í™”(monomorphization), íŠ¸ë ˆ"
#~ "ì‡ ê°ì²´."

#~ msgid "Testing: unit tests, documentation tests, and integration tests."
#~ msgstr "í…ŒìŠ¤íŠ¸: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, ë¬¸ì„œ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸."

#~ msgid ""
#~ "Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
#~ "functions."
#~ msgstr ""
#~ "ì•ˆì „í•˜ì§€ ì•Šì€ ëŸ¬ìŠ¤íŠ¸: ì›ì‹œ(raw) í¬ì¸í„°, ì •ì  ë³€ìˆ˜, ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜, ì™¸"
#~ "ë¶€ í•¨ìˆ˜."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T> {\n"
#~ "    x: T,\n"
#~ "    y: T,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Point { x: 5, y: 10 };\n"
#~ "    let float = Point { x: 1.0, y: 4.0 };\n"
#~ "    println!(\"{integer:?} and {float:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T> {\n"
#~ "    x: T,\n"
#~ "    y: T,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Point { x: 5, y: 10 };\n"
#~ "    let float = Point { x: 1.0, y: 4.0 };\n"
#~ "    println!(\"{integer:?} and {float:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
#~ msgstr "ìƒˆ ë³€ìˆ˜ `let p = Point { x: 5, y: 10.0 };`ë¥¼ ì„ ì–¸í•´ ë³´ì„¸ìš”."

#~ msgid "Fix the code to allow points that have elements of different types."
#~ msgstr ""
#~ "`Point`ê°€ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì˜ ê°’ë“¤ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ë„ ì»´íŒŒì¼ ë˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •"
#~ "í•´ ë³´ì„¸ìš”."

#~ msgid "You can declare a generic type on your `impl` block:"
#~ msgstr "`impl` ë¸”ë¡ì—ì„œë„ ì œë„¤ë¦­ íƒ€ì…ì„ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T>(T, T);\n"
#~ "\n"
#~ "impl<T> Point<T> {\n"
#~ "    fn x(&self) -> &T {\n"
#~ "        &self.0  // + 10\n"
#~ "    }\n"
#~ "\n"
#~ "    // fn set_x(&mut self, x: T)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(5, 10);\n"
#~ "    println!(\"p.x = {}\", p.x());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Point<T>(T, T);\n"
#~ "\n"
#~ "impl<T> Point<T> {\n"
#~ "    fn x(&self) -> &T {\n"
#~ "        &self.0  // + 10\n"
#~ "    }\n"
#~ "\n"
#~ "    // fn set_x(&mut self, x: T)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p = Point(5, 10);\n"
#~ "    println!(\"p.x = {}\", p.x());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Generic code is turned into non-generic code based on the call sites:"
#~ msgstr "ì œë„¤ë¦­ ì½”ë“œëŠ” í˜¸ì¶œë¶€ì—ì„œ ë¹„ ì œë„¤ë¦­ ì½”ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let integer = Some(5);\n"
#~ "    let float = Some(5.0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let integer = Some(5);\n"
#~ "    let float = Some(5.0);\n"
#~ "}\n"
#~ "```"

#~ msgid "behaves as if you wrote"
#~ msgstr "ìœ„ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ì´ ë™ì‘í•©ë‹ˆë‹¤"

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum Option_i32 {\n"
#~ "    Some(i32),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "enum Option_f64 {\n"
#~ "    Some(f64),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Option_i32::Some(5);\n"
#~ "    let float = Option_f64::Some(5.0);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum Option_i32 {\n"
#~ "    Some(i32),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "enum Option_f64 {\n"
#~ "    Some(f64),\n"
#~ "    None,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let integer = Option_i32::Some(5);\n"
#~ "    let float = Option_f64::Some(5.0);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn greet<P: Pet>(pet: &P) {\n"
#~ "    println!(\"Who's a cutie? {} is!\", pet.name());\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fido = Dog { name: \"Fido\".into() };\n"
#~ "    greet(&fido);\n"
#~ "\n"
#~ "    let captain_floof = Cat;\n"
#~ "    greet(&captain_floof);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn greet<P: Pet>(pet: &P) {\n"
#~ "    println!(\"Who's a cutie? {} is!\", pet.name());\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fido = Dog { name: \"Fido\".into() };\n"
#~ "    greet(&fido);\n"
#~ "\n"
#~ "    let captain_floof = Cat;\n"
#~ "    greet(&captain_floof);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let pets: Vec<Box<dyn Pet>> = vec![\n"
#~ "        Box::new(Cat),\n"
#~ "        Box::new(Dog { name: String::from(\"Fido\") }),\n"
#~ "    ];\n"
#~ "    for pet in pets {\n"
#~ "        println!(\"Hello {}!\", pet.name());\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Pet {\n"
#~ "    fn name(&self) -> String;\n"
#~ "}\n"
#~ "\n"
#~ "struct Dog {\n"
#~ "    name: String,\n"
#~ "}\n"
#~ "\n"
#~ "struct Cat;\n"
#~ "\n"
#~ "impl Pet for Dog {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        self.name.clone()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Pet for Cat {\n"
#~ "    fn name(&self) -> String {\n"
#~ "        String::from(\"The cat\") // No name, cats won't respond to it "
#~ "anyway.\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let pets: Vec<Box<dyn Pet>> = vec![\n"
#~ "        Box::new(Cat),\n"
#~ "        Box::new(Dog { name: String::from(\"Fido\") }),\n"
#~ "    ];\n"
#~ "    for pet in pets {\n"
#~ "        println!(\"Hello {}!\", pet.name());\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
#~ "<Cat>());\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
#~ "<&Cat>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
#~ "<Cat>());\n"
#~ "    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
#~ "<&Cat>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
#~ "    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
#~ "```"

#~ msgid ""
#~ "Rust derive macros work by automatically generating code that implements "
#~ "the specified traits for a data structure."
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ì˜ derive ë§¤í¬ë¡œëŠ” ë°ì´í„° êµ¬ì¡°ì²´ê°€ íŠ¹ì • íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ì½”ë“œë¥¼ ì"
#~ "ë™ìœ¼ë¡œ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤."

#~ msgid "You can let the compiler derive a number of traits as follows:"
#~ msgstr ""
#~ "ì»´íŒŒì¼ëŸ¬ê°€ ì—¬ëŸ¬ê°€ì§€ íŠ¸ë ˆì‡ì„ ìƒì†(derive)í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš° ì»´"
#~ "íŒŒì¼ëŸ¬ê°€ íŠ¸ë ˆì‡ì„ ìë™ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
#~ "struct Player {\n"
#~ "    name: String,\n"
#~ "    strength: u8,\n"
#~ "    hit_points: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Player::default();\n"
#~ "    let p2 = p1.clone();\n"
#~ "    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
#~ "             if p1 == p2 { \"yes\" } else { \"no\" });\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
#~ "struct Player {\n"
#~ "    name: String,\n"
#~ "    strength: u8,\n"
#~ "    hit_points: u8,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Player::default();\n"
#~ "    let p2 = p1.clone();\n"
#~ "    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
#~ "             if p1 == p2 { \"yes\" } else { \"no\" });\n"
#~ "}\n"
#~ "```"

#~ msgid "Traits can implement behavior in terms of other trait methods:"
#~ msgstr ""
#~ "íŠ¸ë ˆì‡ì˜ ë””í´íŠ¸ ë©”ì„œë“œì—ì„œ ë‹¤ë¥¸(êµ¬í˜„ë˜ì§€ ì•Šì€) ë©”ì†Œë“œë¥¼ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆ"
#~ "ë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "trait Equals {\n"
#~ "    fn equals(&self, other: &Self) -> bool;\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Centimeter(i16);\n"
#~ "\n"
#~ "impl Equals for Centimeter {\n"
#~ "    fn equals(&self, other: &Centimeter) -> bool {\n"
#~ "        self.0 == other.0\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Centimeter(10);\n"
#~ "    let b = Centimeter(20);\n"
#~ "    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
#~ "    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "trait Equals {\n"
#~ "    fn equals(&self, other: &Self) -> bool;\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Centimeter(i16);\n"
#~ "\n"
#~ "impl Equals for Centimeter {\n"
#~ "    fn equals(&self, other: &Centimeter) -> bool {\n"
#~ "        self.0 == other.0\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Centimeter(10);\n"
#~ "    let b = Centimeter(20);\n"
#~ "    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
#~ "    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
#~ "}\n"
#~ "```"

#~ msgid "Move method `not_equals` to a new trait `NotEquals`."
#~ msgstr "`not_equal` ë©”ì„œë“œë¥¼ ìƒˆë¡œìš´ íŠ¸ë ˆì‡ì¸ `NotEqual`ë¡œ ì´ë™í•©ë‹ˆë‹¤."

#~ msgid "Make `Equals` a super trait for `NotEquals`."
#~ msgstr "`NotEqual`ì„ `Equal`ì˜ ìŠˆí¼ íŠ¸ë ˆì‡ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
#~ msgstr "`Equal`ì— `NotEqual`ì˜ í¬ê´„ì  êµ¬í˜„ì„ ì œê³µí•©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl<T> NotEquals for T where T: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "trait NotEquals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl<T> NotEquals for T where T: Equals {\n"
#~ "    fn not_equals(&self, other: &Self) -> bool {\n"
#~ "        !self.equals(other)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "With the blanket implementation, you no longer need `Equals` as a super "
#~ "trait for `NotEqual`."
#~ msgstr ""
#~ "í¬ê´„ì  êµ¬í˜„ì„ ì‚¬ìš©í•˜ë©´ ë” ì´ìƒ `NotEqual`ì´ `Equal`ì˜ ìŠˆí¼ íŠ¸ë ˆì‡ìœ¼ë¡œ í•„ìš”"
#~ "í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "\n"
#~ "// Syntactic sugar for:\n"
#~ "//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
#~ "fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
#~ "    x.into() + 42_000_000\n"
#~ "}\n"
#~ "\n"
#~ "// struct NotClonable;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let foo = String::from(\"foo\");\n"
#~ "    let pair = duplicate(foo);\n"
#~ "    println!(\"{pair:?}\");\n"
#~ "\n"
#~ "    let many = add_42_millions(42_i8);\n"
#~ "    println!(\"{many}\");\n"
#~ "    let many_more = add_42_millions(10_000_000);\n"
#~ "    println!(\"{many_more}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "\n"
#~ "// ë‹¤ìŒì— ëŒ€í•œ ë¬¸ë²• ìŠˆê°€:\n"
#~ "//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
#~ "fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
#~ "    x.into() + 42_000_000\n"
#~ "}\n"
#~ "\n"
#~ "// struct NotClonable;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let foo = String::from(\"foo\");\n"
#~ "    let pair = duplicate(foo);\n"
#~ "    println!(\"{pair:?}\");\n"
#~ "\n"
#~ "    let many = add_42_millions(42_i8);\n"
#~ "    println!(\"{many}\");\n"
#~ "    let many_more = add_42_millions(10_000_000);\n"
#~ "    println!(\"{many_more}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn duplicate<T>(a: T) -> (T, T)\n"
#~ "where\n"
#~ "    T: Clone,\n"
#~ "{\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn duplicate<T>(a: T) -> (T, T)\n"
#~ "where\n"
#~ "    T: Clone,\n"
#~ "{\n"
#~ "    (a.clone(), a.clone())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::fmt::Display;\n"
#~ "\n"
#~ "fn get_x(name: impl Display) -> impl Display {\n"
#~ "    format!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = get_x(\"foo\");\n"
#~ "    println!(\"{x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::fmt::Display;\n"
#~ "\n"
#~ "fn get_x(name: impl Display) -> impl Display {\n"
#~ "    format!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = get_x(\"foo\");\n"
#~ "    println!(\"{x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "`impl Trait` allows you to work with types which you cannot name."
#~ msgstr "`impl Trait`ë¥¼ ì´ìš©í•˜ë©´ ì´ë¦„ì´ ì—†ëŠ” íƒ€ì…ì„ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "This example is great, because it uses `impl Display` twice. It helps to "
#~ "explain that nothing here enforces that it is _the same_ `impl Display` "
#~ "type. If we used a single  `T: Display`, it would enforce the constraint "
#~ "that input `T` and return `T` type are the same type. It would not work "
#~ "for this particular function, as the type we expect as input is likely "
#~ "not what `format!` returns. If we wanted to do the same via `: Display` "
#~ "syntax, we'd need two independent generic parameters."
#~ msgstr ""
#~ "ì´ ì˜ˆì‹œëŠ” `impl Display`ê°€ ë‘ë²ˆ ì‚¬ìš© ë˜ì—ˆë‹¤ëŠ” ì ì—ì„œ í›Œë¥­í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì¤‘"
#~ "ìš”í•œ ê²ƒì€ ì´ ë‘ `impl Display`ê°€ ì‹¤ì œë¡œ ê°™ì€ íƒ€ì…ì¼ í•„ìš”ê°€ ì—†ë‹¤ëŠ” ê²ƒì…ë‹ˆ"
#~ "ë‹¤. ë§Œì•½ `T: Display`ë¡œ íŠ¸ë ˆì‡ ê²½ê³„ë¥¼ ì •í•˜ê³  ì…ë ¥ íŒŒë¼ë©”í„°ì™€ ë¦¬í„´ ê°’ì˜ íƒ€"
#~ "ì…ì„ ëª¨ë‘ `T`ë¡œ í–ˆë‹¤ë©´, ì´ëŠ” ì…ë ¥ê³¼ ë¦¬í„´ê°’ì´ ê°™ì€ íƒ€ì…ì„ì„ ê°•ì œí•©ë‹ˆë‹¤. ì´"
#~ "ë ‡ê²Œ í–ˆë‹¤ë©´ ìœ„ì˜ ì˜ˆì œëŠ” ë™ì‘í•˜ì§€ ì•Šì•˜ì„ ê²ƒì…ë‹ˆë‹¤. ì™œëƒí•˜ë©´, ì…ë ¥ ê°’ì˜ íƒ€ì…"
#~ "ì´ `format!`ì´ ë¦¬í„´í•˜ëŠ” íƒ€ì…ê³¼ ê°™ì§€ ì•Šì„ ê°€ëŠ¥ì„±ì´ ë†’ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë§Œì•½ "
#~ "`: Display` ë¬¸ë²•ì„ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ ë…ë¦½ì ì¸ ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ê°€ ë‘ ê°œê°€ í•„ìš”"
#~ "í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "We will now look at some of the most common traits of the Rust standard "
#~ "library:"
#~ msgstr ""
#~ "ëŸ¬ìŠ¤íŠ¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë²”ìš© íŠ¸ë ˆì‡ë“¤ì´ ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) used in `for` loops,"
#~ msgstr ""
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html)ì™€ "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) íŠ¸ë ˆì‡ì€ `for` ë°˜ë³µë¬¸ì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤,"

#~ msgid ""
#~ "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and "
#~ "[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) used to "
#~ "convert values,"
#~ msgstr ""
#~ "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html)ê³¼ [`Into`]"
#~ "(https://doc.rust-lang.org/std/convert/trait.Into.html) íŠ¸ë ˆì‡ì€ ê°’ì„ ë³€í™˜"
#~ "í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤,"

#~ msgid ""
#~ "[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
#~ "(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
#~ msgstr ""
#~ "[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html)ì™€ [`Write`]"
#~ "(https://doc.rust-lang.org/std/io/trait.Write.html) íŠ¸ë ˆì‡ì€ I/Oì— ì‚¬ìš©ë©"
#~ "ë‹ˆë‹¤,"

#~ msgid ""
#~ "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`]"
#~ "(https://doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
#~ "overloading, and"
#~ msgstr ""
#~ "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`]"
#~ "(https://doc.rust-lang.org/std/ops/trait.Mul.html) ë“±ì˜ íŠ¸ë ˆì‡ë“¤ì€ ì—°ì‚°ì "
#~ "ì˜¤ë²„ë¡œë”©(overloading)ì— ì‚¬ìš©ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
#~ "used to construct a default instance of a type."
#~ msgstr ""
#~ "[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) íŠ¸ë ˆ"
#~ "ì‡ì€ ì–´ë–¤ íƒ€ì…ì˜ ê¸°ë³¸ê°’ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Fibonacci {\n"
#~ "    curr: u32,\n"
#~ "    next: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for Fibonacci {\n"
#~ "    type Item = u32;\n"
#~ "\n"
#~ "    fn next(&mut self) -> Option<Self::Item> {\n"
#~ "        let new_next = self.curr + self.next;\n"
#~ "        self.curr = self.next;\n"
#~ "        self.next = new_next;\n"
#~ "        Some(self.curr)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fib = Fibonacci { curr: 0, next: 1 };\n"
#~ "    for (i, n) in fib.enumerate().take(5) {\n"
#~ "        println!(\"fib({i}): {n}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Fibonacci {\n"
#~ "    curr: u32,\n"
#~ "    next: u32,\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for Fibonacci {\n"
#~ "    type Item = u32;\n"
#~ "\n"
#~ "    fn next(&mut self) -> Option<Self::Item> {\n"
#~ "        let new_next = self.curr + self.next;\n"
#~ "        self.curr = self.next;\n"
#~ "        self.next = new_next;\n"
#~ "        Some(self.curr)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let fib = Fibonacci { curr: 0, next: 1 };\n"
#~ "    for (i, n) in fib.enumerate().take(5) {\n"
#~ "        println!(\"fib({i}): {n}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let primes = vec![2, 3, 5, 7];\n"
#~ "    let prime_squares = primes\n"
#~ "        .into_iter()\n"
#~ "        .map(|prime| prime * prime)\n"
#~ "        .collect::<Vec<_>>();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let primes = vec![2, 3, 5, 7];\n"
#~ "    let prime_squares = primes\n"
#~ "        .into_iter()\n"
#~ "        .map(|prime| prime * prime)\n"
#~ "        .collect::<Vec<_>>();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "`Iterator` implements `fn collect<B>(self) -> B where B: "
#~ "FromIterator<Self::Item>, Self: Sized`"
#~ msgstr ""
#~ "`Iterator`ì—ëŠ” ë‹¤ìŒ í•¨ìˆ˜ê°€ ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤: `fn collect<B>(self) -> B "
#~ "where B: FromIterator<Self::Item>, Self: Sized`"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"hello\");\n"
#~ "    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
#~ "    let one = i16::from(true);\n"
#~ "    let bigger = i32::from(123i16);\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"hello\");\n"
#~ "    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
#~ "    let one = i16::from(true);\n"
#~ "    let bigger = i32::from(123i16);\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s: String = \"hello\".into();\n"
#~ "    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
#~ "    let one: i16 = true.into();\n"
#~ "    let bigger: i32 = 123i16.into();\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s: String = \"hello\".into();\n"
#~ "    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
#~ "    let one: i16 = true.into();\n"
#~ "    let bigger: i32 = 123i16.into();\n"
#~ "    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::io::{BufRead, BufReader, Read, Result};\n"
#~ "\n"
#~ "fn count_lines<R: Read>(reader: R) -> usize {\n"
#~ "    let buf_reader = BufReader::new(reader);\n"
#~ "    buf_reader.lines().count()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
#~ "    println!(\"lines in slice: {}\", count_lines(slice));\n"
#~ "\n"
#~ "    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
#~ "    println!(\"lines in file: {}\", count_lines(file));\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::io::{BufRead, BufReader, Read, Result};\n"
#~ "\n"
#~ "fn count_lines<R: Read>(reader: R) -> usize {\n"
#~ "    let buf_reader = BufReader::new(reader);\n"
#~ "    buf_reader.lines().count()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
#~ "    println!(\"lines in slice: {}\", count_lines(slice));\n"
#~ "\n"
#~ "    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
#~ "    println!(\"lines in file: {}\", count_lines(file));\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::io::{Result, Write};\n"
#~ "\n"
#~ "fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
#~ "    writer.write_all(msg.as_bytes())?;\n"
#~ "    writer.write_all(\"\\n\".as_bytes())\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let mut buffer = Vec::new();\n"
#~ "    log(&mut buffer, \"Hello\")?;\n"
#~ "    log(&mut buffer, \"World\")?;\n"
#~ "    println!(\"Logged: {:?}\", buffer);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::io::{Result, Write};\n"
#~ "\n"
#~ "fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
#~ "    writer.write_all(msg.as_bytes())?;\n"
#~ "    writer.write_all(\"\\n\".as_bytes())\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<()> {\n"
#~ "    let mut buffer = Vec::new();\n"
#~ "    log(&mut buffer, \"Hello\")?;\n"
#~ "    log(&mut buffer, \"World\")?;\n"
#~ "    println!(\"Logged: {:?}\", buffer);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "struct Droppable {\n"
#~ "    name: &'static str,\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for Droppable {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        println!(\"Dropping {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Droppable { name: \"a\" };\n"
#~ "    {\n"
#~ "        let b = Droppable { name: \"b\" };\n"
#~ "        {\n"
#~ "            let c = Droppable { name: \"c\" };\n"
#~ "            let d = Droppable { name: \"d\" };\n"
#~ "            println!(\"Exiting block B\");\n"
#~ "        }\n"
#~ "        println!(\"Exiting block A\");\n"
#~ "    }\n"
#~ "    drop(a);\n"
#~ "    println!(\"Exiting main\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "struct Droppable {\n"
#~ "    name: &'static str,\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for Droppable {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        println!(\"Dropping {}\", self.name);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let a = Droppable { name: \"a\" };\n"
#~ "    {\n"
#~ "        let b = Droppable { name: \"b\" };\n"
#~ "        {\n"
#~ "            let c = Droppable { name: \"c\" };\n"
#~ "            let d = Droppable { name: \"d\" };\n"
#~ "            println!(\"Exiting block B\");\n"
#~ "        }\n"
#~ "        println!(\"Exiting block A\");\n"
#~ "    }\n"
#~ "    drop(a);\n"
#~ "    println!(\"Exiting main\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Derived {\n"
#~ "    x: u32,\n"
#~ "    y: String,\n"
#~ "    z: Implemented,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Implemented(String);\n"
#~ "\n"
#~ "impl Default for Implemented {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self(\"John Smith\".into())\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let default_struct = Derived::default();\n"
#~ "    println!(\"{default_struct:#?}\");\n"
#~ "\n"
#~ "    let almost_default_struct = Derived {\n"
#~ "        y: \"Y is set!\".into(),\n"
#~ "        ..Derived::default()\n"
#~ "    };\n"
#~ "    println!(\"{almost_default_struct:#?}\");\n"
#~ "\n"
#~ "    let nothing: Option<Derived> = None;\n"
#~ "    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Default)]\n"
#~ "struct Derived {\n"
#~ "    x: u32,\n"
#~ "    y: String,\n"
#~ "    z: Implemented,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct Implemented(String);\n"
#~ "\n"
#~ "impl Default for Implemented {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self(\"John Smith\".into())\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let default_struct = Derived::default();\n"
#~ "    println!(\"{default_struct:#?}\");\n"
#~ "\n"
#~ "    let almost_default_struct = Derived {\n"
#~ "        y: \"Y is set!\".into(),\n"
#~ "        ..Derived::default()\n"
#~ "    };\n"
#~ "    println!(\"{almost_default_struct:#?}\");\n"
#~ "\n"
#~ "    let nothing: Option<Derived> = None;\n"
#~ "    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "`Add`, `Mul`, ..."
#~ msgstr "`Add`, `Mul`, ..."

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Copy, Clone)]\n"
#~ "struct Point { x: i32, y: i32 }\n"
#~ "\n"
#~ "impl std::ops::Add for Point {\n"
#~ "    type Output = Self;\n"
#~ "\n"
#~ "    fn add(self, other: Self) -> Self {\n"
#~ "        Self {x: self.x + other.x, y: self.y + other.y}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 10, y: 20 };\n"
#~ "    let p2 = Point { x: 100, y: 200 };\n"
#~ "    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug, Copy, Clone)]\n"
#~ "struct Point { x: i32, y: i32 }\n"
#~ "\n"
#~ "impl std::ops::Add for Point {\n"
#~ "    type Output = Self;\n"
#~ "\n"
#~ "    fn add(self, other: Self) -> Self {\n"
#~ "        Self {x: self.x + other.x, y: self.y + other.y}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let p1 = Point { x: 10, y: 20 };\n"
#~ "    let p2 = Point { x: 100, y: 200 };\n"
#~ "    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
#~ "    println!(\"Calling function on {input}\");\n"
#~ "    func(input)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let add_3 = |x| x + 3;\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
#~ "\n"
#~ "    let mut v = Vec::new();\n"
#~ "    let mut accumulate = |x: i32| {\n"
#~ "        v.push(x);\n"
#~ "        v.iter().sum::<i32>()\n"
#~ "    };\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
#~ "\n"
#~ "    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
#~ "    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
#~ "    println!(\"Calling function on {input}\");\n"
#~ "    func(input)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let add_3 = |x| x + 3;\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
#~ "    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
#~ "\n"
#~ "    let mut v = Vec::new();\n"
#~ "    let mut accumulate = |x: i32| {\n"
#~ "        v.push(x);\n"
#~ "        v.iter().sum::<i32>()\n"
#~ "    };\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
#~ "    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
#~ "\n"
#~ "    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
#~ "    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
#~ "    return move |name| println!(\"{} {}\", prefix, name)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let hi = make_greeter(\"Hi\".to_string());\n"
#~ "    hi(\"there\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
#~ "    return move |name| println!(\"{} {}\", prefix, name)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let hi = make_greeter(\"Hi\".to_string());\n"
#~ "    hi(\"there\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Day 3: Morning Exercises"
#~ msgstr "3ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#~ msgid "We will design a classical GUI library traits and trait objects."
#~ msgstr ""
#~ "ì´ë²ˆ ì—°ìŠµë¬¸ì œì—ì„œëŠ” íŠ¸ë ˆì‡ì™€ íŠ¸ë ˆì‡ ê°ì²´ë¥¼ í†µí•´ ê³ ì „ì ì¸ GUI ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ "
#~ "ì„¤ê³„í•  ê²ƒì…ë‹ˆë‹¤."

#~ msgid ""
#~ "`Button`: has a `label` and a callback function which is invoked when the "
#~ "button is pressed."
#~ msgstr ""
#~ "`Button`: `label` ì†ì„±ì„ ê°€ì§€ê³  ìˆìœ¼ë©°, ë²„íŠ¼ì´ ëˆŒë ¸ì„ë•Œ ì‹¤í–‰ë˜ëŠ” ì½œë°± í•¨ìˆ˜"
#~ "ê°€ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;\n"
#~ "\n"
#~ "    /// Draw the widget into a buffer.\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
#~ "\n"
#~ "    /// Draw the widget on standard output.\n"
#~ "    fn draw(&self) {\n"
#~ "        let mut buffer = String::new();\n"
#~ "        self.draw_into(&mut buffer);\n"
#~ "        println!(\"{buffer}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Label {\n"
#~ "    label: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl Label {\n"
#~ "    fn new(label: &str) -> Label {\n"
#~ "        Label {\n"
#~ "            label: label.to_owned(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Button {\n"
#~ "    label: Label,\n"
#~ "    callback: Box<dyn FnMut()>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Button {\n"
#~ "    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
#~ "        Button {\n"
#~ "            label: Label::new(label),\n"
#~ "            callback,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Window {\n"
#~ "    title: String,\n"
#~ "    widgets: Vec<Box<dyn Widget>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Window {\n"
#~ "    fn new(title: &str) -> Window {\n"
#~ "        Window {\n"
#~ "            title: title.to_owned(),\n"
#~ "            widgets: Vec::new(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
#~ "        self.widgets.push(widget);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inner_width(&self) -> usize {\n"
#~ "        std::cmp::max(\n"
#~ "            self.title.chars().count(),\n"
#~ "            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
#~ "        )\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
#~ "\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Click me!\",\n"
#~ "        Box::new(|| println!(\"You clicked the button!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "pub trait Widget {\n"
#~ "    /// Natural width of `self`.\n"
#~ "    fn width(&self) -> usize;\n"
#~ "\n"
#~ "    /// Draw the widget into a buffer.\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
#~ "\n"
#~ "    /// Draw the widget on standard output.\n"
#~ "    fn draw(&self) {\n"
#~ "        let mut buffer = String::new();\n"
#~ "        self.draw_into(&mut buffer);\n"
#~ "        println!(\"{buffer}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Label {\n"
#~ "    label: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl Label {\n"
#~ "    fn new(label: &str) -> Label {\n"
#~ "        Label {\n"
#~ "            label: label.to_owned(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Button {\n"
#~ "    label: Label,\n"
#~ "    callback: Box<dyn FnMut()>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Button {\n"
#~ "    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
#~ "        Button {\n"
#~ "            label: Label::new(label),\n"
#~ "            callback,\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct Window {\n"
#~ "    title: String,\n"
#~ "    widgets: Vec<Box<dyn Widget>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Window {\n"
#~ "    fn new(title: &str) -> Window {\n"
#~ "        Window {\n"
#~ "            title: title.to_owned(),\n"
#~ "            widgets: Vec::new(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
#~ "        self.widgets.push(widget);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn inner_width(&self) -> usize {\n"
#~ "        std::cmp::max(\n"
#~ "            self.title.chars().count(),\n"
#~ "            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
#~ "        )\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "\n"
#~ "impl Widget for Label {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Button {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Widget for Window {\n"
#~ "    fn width(&self) -> usize {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
#~ "    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
#~ "\")));\n"
#~ "    window.add_widget(Box::new(Button::new(\n"
#~ "        \"Click me!\",\n"
#~ "        Box::new(|| println!(\"You clicked the button!\")),\n"
#~ "    )));\n"
#~ "    window.draw();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "========\n"
#~ "Rust GUI Demo 1.23\n"
#~ "========\n"
#~ "\n"
#~ "This is a small text GUI demo.\n"
#~ "\n"
#~ "| Click me! |\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "========\n"
#~ "Rust GUI Demo 1.23\n"
#~ "========\n"
#~ "\n"
#~ "This is a small text GUI demo.\n"
#~ "\n"
#~ "| Click me! |\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let width = 10;\n"
#~ "    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
#~ "    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
#~ "    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let width = 10;\n"
#~ "    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
#~ "    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
#~ "    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "+--------------------------------+\n"
#~ "|       Rust GUI Demo 1.23       |\n"
#~ "+================================+\n"
#~ "| This is a small text GUI demo. |\n"
#~ "| +-----------+                  |\n"
#~ "| | Click me! |                  |\n"
#~ "| +-----------+                  |\n"
#~ "+--------------------------------+\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "+--------------------------------+\n"
#~ "|       Rust GUI Demo 1.23       |\n"
#~ "+================================+\n"
#~ "| This is a small text GUI demo. |\n"
#~ "| +-----------+                  |\n"
#~ "| | Click me! |                  |\n"
#~ "| +-----------+                  |\n"
#~ "+--------------------------------+\n"
#~ "```"

#~ msgid "Error handling in Rust is done using explicit control flow:"
#~ msgstr "ëŸ¬ìŠ¤íŠ¸ì—ì„œ ì˜¤ë¥˜ëŠ” ëª…ì‹œì ì¸ íë¦„ì„ ë”°ë¼ ì²˜ë¦¬ê°€ ë©ë‹ˆë‹¤:"

#~ msgid "Functions that can have errors list this in their return type,"
#~ msgstr "ì˜¤ë¥˜ë¥¼ ë°œìƒí•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ëŠ” ë°˜í™˜ íƒ€ì…ì— ì´ë¥¼ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤,"

#~ msgid "There are no exceptions."
#~ msgstr "ì˜ˆì™¸(exception) ê¸°ëŠ¥ì€ ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable,should_panic\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    println!(\"v[100]: {}\", v[100]);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,should_panic\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    println!(\"v[100]: {}\", v[100]);\n"
#~ "}\n"
#~ "```"

#~ msgid "Catching the Stack Unwinding"
#~ msgstr "ìŠ¤íƒ ë˜ê°ê¸°"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::panic;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        println!(\"hello!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_ok());\n"
#~ "    \n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        panic!(\"oh no!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_err());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::panic;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        println!(\"hello!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_ok());\n"
#~ "    \n"
#~ "    let result = panic::catch_unwind(|| {\n"
#~ "        panic!(\"oh no!\");\n"
#~ "    });\n"
#~ "    assert!(result.is_err());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "We have already seen the `Result` enum. This is used pervasively when "
#~ "errors are expected as part of normal operation:"
#~ msgstr ""
#~ "ì—¬ëŸ¬ë¶„ì€ ì´ë¯¸ `Result` ì—´ê±°í˜•ì„ ëª‡ ë²ˆ ë´¤ìŠµë‹ˆë‹¤. ì´ íƒ€ì…ì€ í”„ë¡œê·¸ë¨ì˜ ì •ìƒ"
#~ "ì ì¸ ìˆ˜í–‰ ì¤‘ì— ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜¤ë¥˜ê°’ë“¤ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let file = fs::File::open(\"diary.txt\");\n"
#~ "    match file {\n"
#~ "        Ok(mut file) => {\n"
#~ "            let mut contents = String::new();\n"
#~ "            file.read_to_string(&mut contents);\n"
#~ "            println!(\"Dear diary: {contents}\");\n"
#~ "        },\n"
#~ "        Err(err) => {\n"
#~ "            println!(\"The diary could not be opened: {err}\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let file = fs::File::open(\"diary.txt\");\n"
#~ "    match file {\n"
#~ "        Ok(mut file) => {\n"
#~ "            let mut contents = String::new();\n"
#~ "            file.read_to_string(&mut contents);\n"
#~ "            println!(\"Dear diary: {contents}\");\n"
#~ "        },\n"
#~ "        Err(err) => {\n"
#~ "            println!(\"The diary could not be opened: {err}\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Propagating Errors with `?`"
#~ msgstr "`?`ë¥¼ ì´ìš©í•œ ì˜¤ë¥˜ ì „íŒŒ"

#~ msgid ""
#~ "The try-operator `?` is used to return errors to the caller. It lets you "
#~ "turn the common"
#~ msgstr ""
#~ "ì—°ì‚°ì `?`ëŠ” í˜¸ì¶œìì—ê²Œ ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ ì´ëŸ° ì½”"
#~ "ë“œë¥¼"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "match some_expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err) => return Err(err),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "match some_expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err) => return Err(err),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "some_expression?\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "some_expression?\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, io::Error> {\n"
#~ "    let username_file_result = fs::File::open(path);\n"
#~ "    let mut username_file = match username_file_result {\n"
#~ "        Ok(file) => file,\n"
#~ "        Err(err) => return Err(err),\n"
#~ "    };\n"
#~ "\n"
#~ "    let mut username = String::new();\n"
#~ "    match username_file.read_to_string(&mut username) {\n"
#~ "        Ok(_) => Ok(username),\n"
#~ "        Err(err) => Err(err),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, io::Error> {\n"
#~ "    let username_file_result = fs::File::open(path);\n"
#~ "    let mut username_file = match username_file_result {\n"
#~ "        Ok(file) => file,\n"
#~ "        Err(err) => return Err(err),\n"
#~ "    };\n"
#~ "\n"
#~ "    let mut username = String::new();\n"
#~ "    match username_file.read_to_string(&mut username) {\n"
#~ "        Ok(_) => Ok(username),\n"
#~ "        Err(err) => Err(err),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The return type of the function has to be compatible with the nested "
#~ "functions it calls. For instance, a function returning a `Result<T, Err>` "
#~ "can only apply the `?` operator on a function returning a  `Result<AnyT, "
#~ "Err>`. It cannot apply the `?` operator on a function returning an "
#~ "`Option<AnyT>` or `Result<T, OtherErr>` unless `OtherErr` implements "
#~ "`From<Err>`. Reciprocally, a function returning an `Option<T>` can only "
#~ "apply the `?` operator  on a function returning an `Option<AnyT>`."
#~ msgstr ""
#~ "í•¨ìˆ˜ì˜ ë¦¬í„´ íƒ€ì…ì€ ë„¤ìŠ¤íŒ… ë˜ì–´ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ì˜ ë¦¬í„´ íƒ€ì…ê³¼ í˜¸í™˜ë˜ì–´ì•¼ í•©ë‹ˆ"
#~ "ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `Result<T, Err>`ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜ëŠ” `Result<AnyT, Err>`ë¥¼ ë¦¬"
#~ "í„´í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œì—ë§Œ`?`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `Option<AnyT>`ë‚˜ "
#~ "`Result<T, OtherErr>` (`OtherError`ê°€ `From<Err>`ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠëŠ” ë‹¤ê³  ê°€"
#~ "ì •í•  ë•Œ)ì™€ ê°™ì€ íƒ€ì…ì„ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œì—ëŠ” `?`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµ"
#~ "ë‹ˆë‹¤. ë™ì¼í•œ ì´ìœ ë¡œ, `Option<T>`ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜ëŠ” `Option<AnyT>`ë¥¼ ë¦¬í„´í•˜"
#~ "ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œì—ë§Œ `?`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "You can convert incompatible types into one another with the different "
#~ "`Option` and `Result` methods  such as `Option::ok_or`, `Result::ok`, "
#~ "`Result::err`."
#~ msgstr ""
#~ "`Option`ê³¼ `Result`ê°„ì˜ ë³€í™˜ì„ ìœ„í•´ `Option::ok_or`, `Result::ok`, "
#~ "`Result::err`ì™€ ê°™ì€ í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,ignore\n"
#~ "expression?\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "expression?\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "match expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err)  => return Err(From::from(err)),\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "match expression {\n"
#~ "    Ok(value) => value,\n"
#~ "    Err(err)  => return Err(From::from(err)),\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::error::Error;\n"
#~ "use std::fmt::{self, Display, Formatter};\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::{self, Read};\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    IoError(io::Error),\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "impl Error for ReadUsernameError {}\n"
#~ "\n"
#~ "impl Display for ReadUsernameError {\n"
#~ "    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
#~ "        match self {\n"
#~ "            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
#~ "            Self::EmptyUsername(filename) => write!(f, \"Found no "
#~ "username in {filename}\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl From<io::Error> for ReadUsernameError {\n"
#~ "    fn from(err: io::Error) -> ReadUsernameError {\n"
#~ "        ReadUsernameError::IoError(err)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::error::Error;\n"
#~ "use std::fmt::{self, Display, Formatter};\n"
#~ "use std::fs::{self, File};\n"
#~ "use std::io::{self, Read};\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    IoError(io::Error),\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "impl Error for ReadUsernameError {}\n"
#~ "\n"
#~ "impl Display for ReadUsernameError {\n"
#~ "    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
#~ "        match self {\n"
#~ "            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
#~ "            Self::EmptyUsername(filename) => write!(f, \"Found no "
#~ "username in {filename}\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl From<io::Error> for ReadUsernameError {\n"
#~ "    fn from(err: io::Error) -> ReadUsernameError {\n"
#~ "        ReadUsernameError::IoError(err)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    let username = read_username(\"config.dat\");\n"
#~ "    println!(\"username or error: {username:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "It is good practice for all error types that don't need to be `no_std` to "
#~ "implement `std::error::Error`, which requires `Debug` and `Display`. The "
#~ "`Error` crate for `core` is only available in [nightly](https://github."
#~ "com/rust-lang/rust/issues/103765), so not fully `no_std` compatible yet."
#~ msgstr ""
#~ "ëª¨ë“  ì—ëŸ¬ íƒ€ì… (`no_std`ì´ì–´ì•¼ í•˜ëŠ” ì—ëŸ¬ íƒ€ì…ì„ ì œì™¸í•˜ê³ )ì— ëŒ€í•´ `std::"
#~ "error::Error`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì€ ì¢‹ì€ ìŠµê´€ì…ë‹ˆë‹¤. `std::error::Error`ë¥¼ êµ¬í˜„"
#~ "í•œë‹¤ëŠ” ê²ƒì€ `Debug`ì™€ `Display`ë„ êµ¬í˜„í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. `core`ë¥¼ ìœ„í•œ "
#~ "`Error`í¬ë ˆì´í¬ëŠ” [ë‚˜ì´í‹€ë¦¬](https://github.com/rust-lang/rust/"
#~ "issues/103765)ì—ë§Œ ì œê³µì´ ë©ë‹ˆë‹¤. ê·¸ë˜ì„œ ì•„ì§ `no_std`í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ìˆ˜"
#~ "ëŠ” ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "It's generally helpful for them to implement `Clone` and `Eq` too where "
#~ "possible, to make life easier for tests and consumers of your library. In "
#~ "this case we can't easily do so, because `io::Error` doesn't implement "
#~ "them."
#~ msgstr ""
#~ "ê°€ëŠ¥í•˜ë‹¤ë©´ `Clone`ê³¼ `Eq` íŠ¸ë ˆì‡ë„ êµ¬í˜„í•˜ë„ë¡ í•˜ì„¸ìš”. ì—¬ëŸ¬ë¶„ì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬"
#~ "ê°€ í…ŒìŠ¤íŠ¸ í•˜ê¸° ì‰¬ì›Œì§€ê³ , ì‚¬ìš©í•˜ê¸° ì¢‹ì•„ì§ˆ ê²ë‹ˆë‹¤. ë‹¤ë§Œ, ì´ ì˜ˆì œì—ì„œëŠ” ê·¸ë ‡"
#~ "ê²Œ í•˜ê¸° í˜ë“­ë‹ˆë‹¤. ì™œëƒí•˜ë©´ `io::Error`ëŠ” ì´ íŠ¸ë ˆì‡ë“¤ì„ êµ¬í˜„í•˜ê³  ìˆì§€ ì•Šê¸° "
#~ "ë•Œë¬¸ì…ë‹ˆë‹¤."

#~ msgid ""
#~ "The [thiserror](https://docs.rs/thiserror/) crate is a popular way to "
#~ "create an error enum like we did on the previous page:"
#~ msgstr ""
#~ "[thiserror](https://docs.rs/thiserror/)ëŠ”, ì´ì „ í˜ì´ì§€ì—ì„œ ë³´ì•˜ë˜ ê²ƒê³¼ ê°™"
#~ "ì€ ì—ëŸ¬ ì—´ê±°í˜•ì„ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆê²Œ í•´ ì£¼ëŠ” ìœ ëª…í•œ í¬ë ˆì´íŠ¸ ì…ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "\n"
#~ "#[derive(Debug, Error)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    #[error(\"Could not read: {0}\")]\n"
#~ "    IoError(#[from] io::Error),\n"
#~ "    #[error(\"Found no username in {0}\")]\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "\n"
#~ "#[derive(Debug, Error)]\n"
#~ "enum ReadUsernameError {\n"
#~ "    #[error(\"Could not read: {0}\")]\n"
#~ "    IoError(#[from] io::Error),\n"
#~ "    #[error(\"Found no username in {0}\")]\n"
#~ "    EmptyUsername(String),\n"
#~ "}\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(ReadUsernameError::EmptyUsername(String::"
#~ "from(path)));\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "`thiserror`'s derive macro automatically implements `std::error::Error`, "
#~ "and optionally `Display` (if the `#[error(...)]` attributes are provided) "
#~ "and `From` (if the `#[from]` attribute is added). It also works for "
#~ "structs."
#~ msgstr ""
#~ "`thiserror`ì˜ derive ë§¤í¬ë¡œë¥¼ ì´ìš©í•˜ë©´ `std::error::Error`ê³¼ `Display`(ë§Œ"
#~ "ì•½ `#[error(...)]` ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì¶”ê°€í–ˆì„ ê²½ìš°), `From`(ë§Œì•½ `#[from]` ì–´íŠ¸"
#~ "ë¦¬ë·°íŠ¸ë¥¼ ì¶”ê°€í–ˆì„ ê²½ìš°) íŠ¸ë ˆì‡ë“¤ì´ ìë™ìœ¼ë¡œ êµ¬í˜„ì´ ë©ë‹ˆë‹¤. êµ¬ì¡°ì²´ì— ëŒ€í•´ì„œ"
#~ "ë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "It doesn't affect your public API, which makes it good for libraries."
#~ msgstr ""
#~ "ì´ ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•´ë„ ë°–ìœ¼ë¡œ ë…¸ì¶œë˜ëŠ” APIê°€ ë³€ê²½ë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬"
#~ "ë¥¼ ë§Œë“¤ ê²½ìš°ì—ëŠ” ì´ê²Œ ì¤‘ìš”í•˜ì£ ."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "use std::error::Error;\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
#~ "#[error(\"Found no username in {0}\")]\n"
#~ "struct EmptyUsernameError(String);\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(EmptyUsernameError(String::from(path)).into());\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::fs;\n"
#~ "use std::io::Read;\n"
#~ "use thiserror::Error;\n"
#~ "use std::error::Error;\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
#~ "#[error(\"Found no username in {0}\")]\n"
#~ "struct EmptyUsernameError(String);\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
#~ "    let mut username = String::new();\n"
#~ "    fs::File::open(path)?.read_to_string(&mut username)?;\n"
#~ "    if username.is_empty() {\n"
#~ "        return Err(EmptyUsernameError(String::from(path)).into());\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
#~ "contextual information to your errors and allows you to have fewer custom "
#~ "error types:"
#~ msgstr ""
#~ "[anyhow](https://docs.rs/anyhow/) í¬ë ˆì´íŠ¸ëŠ” ì—ëŸ¬ì— ì—ëŸ¬ê°€ ë°œìƒí•œ ë¬¸ë§¥ì— "
#~ "ëŒ€í•œ ì •ë³´ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´ ë„ë¦¬ ì‚¬ìš©ë˜ë©°, ì´ë¥¼ ì´ìš©í•˜ë©´ ì„œë¡œ ë‹¤ë¥¸ ë¬¸ë§¥ì„ ë‚˜"
#~ "íƒ€ë‚´ê¸° ì‚¬ìš©ì ì •ì˜ ì˜¤ë¥˜ íƒ€ì…ì„ ë§ì´ ë§Œë“¤ì–´ì•¼ í•˜ëŠ” ë¶ˆí¸í•¨ì„ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆ"
#~ "ë‹¤:"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use anyhow::{Context, Result, bail};\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    fs::File::open(path)\n"
#~ "        .with_context(|| format!(\"Failed to open {path}\"))?\n"
#~ "        .read_to_string(&mut username)\n"
#~ "        .context(\"Failed to read\")?;\n"
#~ "    if username.is_empty() {\n"
#~ "        bail!(\"Found no username in {path}\");\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err:?}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::{fs, io};\n"
#~ "use std::io::Read;\n"
#~ "use anyhow::{Context, Result, bail};\n"
#~ "\n"
#~ "fn read_username(path: &str) -> Result<String> {\n"
#~ "    let mut username = String::with_capacity(100);\n"
#~ "    fs::File::open(path)\n"
#~ "        .with_context(|| format!(\"Failed to open {path}\"))?\n"
#~ "        .read_to_string(&mut username)\n"
#~ "        .context(\"Failed to read\")?;\n"
#~ "    if username.is_empty() {\n"
#~ "        bail!(\"Found no username in {path}\");\n"
#~ "    }\n"
#~ "    Ok(username)\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    //fs::write(\"config.dat\", \"\").unwrap();\n"
#~ "    match read_username(\"config.dat\") {\n"
#~ "        Ok(username) => println!(\"Username: {username}\"),\n"
#~ "        Err(err)     => println!(\"Error: {err:?}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Mark unit tests with `#[test]`:"
#~ msgstr "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” `#[test]` ë¡œ í‘œì‹œí•©ë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable,ignore\n"
#~ "fn first_word(text: &str) -> &str {\n"
#~ "    match text.find(' ') {\n"
#~ "        Some(idx) => &text[..idx],\n"
#~ "        None => &text,\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty() {\n"
#~ "    assert_eq!(first_word(\"\"), \"\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_word() {\n"
#~ "    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_multiple_words() {\n"
#~ "    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,ignore\n"
#~ "fn first_word(text: &str) -> &str {\n"
#~ "    match text.find(' ') {\n"
#~ "        Some(idx) => &text[..idx],\n"
#~ "        None => &text,\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_empty() {\n"
#~ "    assert_eq!(first_word(\"\"), \"\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_single_word() {\n"
#~ "    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_multiple_words() {\n"
#~ "    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Use `cargo test` to find and run the unit tests."
#~ msgstr "`cargo test` ì»¤ë§¨ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì°¾ì•„ì„œ ì‹¤í–‰í•©ë‹ˆë‹¤."

#~ msgid ""
#~ "Unit tests are often put in a nested module (run tests on the [Playground]"
#~ "(https://play.rust-lang.org/)):"
#~ msgstr ""
#~ "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì›ë˜ ëª¨ë“ˆ ë°‘ì— ì„œë¸Œ ëª¨ë“ˆë¡œ ë§Œë“œëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤. ([í”Œë ˆì´"
#~ "ê·¸ë¼ìš´ë“œ](https://play.rust-lang.org/)ì—ì„œ ë‹¤ìŒ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•´ ë³´ì„¸ìš”):"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn helper(a: &str, b: &str) -> String {\n"
#~ "    format!(\"{a} {b}\")\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_helper() {\n"
#~ "        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn helper(a: &str, b: &str) -> String {\n"
#~ "    format!(\"{a} {b}\")\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
#~ "}\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use super::*;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_helper() {\n"
#~ "        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use my_library::init;\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_init() {\n"
#~ "    assert!(init().is_ok());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "use my_library::init;\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn test_init() {\n"
#~ "    assert!(init().is_ok());\n"
#~ "}\n"
#~ "```"

#~ msgid "Useful crates for writing tests"
#~ msgstr "í…ŒìŠ¤íŠ¸ ì‘ì„±ì— ìœ ìš©í•œ í¬ë ˆì´íŠ¸"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static HELLO_WORLD: &str = \"Hello, world!\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static HELLO_WORLD: &str = \"Hello, world!\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static mut COUNTER: u32 = 0;\n"
#~ "\n"
#~ "fn add_to_counter(inc: u32) {\n"
#~ "    unsafe { COUNTER += inc; }  // Potential data race!\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    add_to_counter(42);\n"
#~ "\n"
#~ "    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data "
#~ "race!\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static mut COUNTER: u32 = 0;\n"
#~ "\n"
#~ "fn add_to_counter(inc: u32) {\n"
#~ "    unsafe { COUNTER += inc; }  // ì ì¬ì  ë°ì´í„° ê²½í•©!\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    add_to_counter(42);\n"
#~ "\n"
#~ "    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // ì ì¬ì  ë°ì´í„° ê²½í•©!\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[repr(C)]\n"
#~ "union MyUnion {\n"
#~ "    i: u8,\n"
#~ "    b: bool,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let u = MyUnion { i: 42 };\n"
#~ "    println!(\"int: {}\", unsafe { u.i });\n"
#~ "    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[repr(C)]\n"
#~ "union MyUnion {\n"
#~ "    i: u8,\n"
#~ "    b: bool,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let u = MyUnion { i: 42 };\n"
#~ "    println!(\"int: {}\", unsafe { u.i });\n"
#~ "    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let emojis = \"ğŸ—»âˆˆğŸŒ\";\n"
#~ "\n"
#~ "    // Safe because the indices are in the correct order, within the "
#~ "bounds of\n"
#~ "    // the string slice, and lie on UTF-8 sequence boundaries.\n"
#~ "    unsafe {\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..7) }));\n"
#~ "\n"
#~ "    // Not upholding the UTF-8 encoding requirement breaks memory "
#~ "safety!\n"
#~ "    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
#~ "    // println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..3) }));\n"
#~ "}\n"
#~ "\n"
#~ "fn count_chars(s: &str) -> usize {\n"
#~ "    s.chars().map(|_| 1).sum()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let emojis = \"ğŸ—»âˆˆğŸŒ\";\n"
#~ "\n"
#~ "    // Safe because the indices are in the correct order, within the "
#~ "bounds of\n"
#~ "    // the string slice, and lie on UTF-8 sequence boundaries.\n"
#~ "    unsafe {\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
#~ "        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..7) }));\n"
#~ "\n"
#~ "    // Not upholding the UTF-8 encoding requirement breaks memory "
#~ "safety!\n"
#~ "    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
#~ "    // println!(\"char count: {}\", count_chars(unsafe { emojis."
#~ "get_unchecked(0..3) }));\n"
#~ "}\n"
#~ "\n"
#~ "fn count_chars(s: &str) -> usize {\n"
#~ "    s.chars().map(|_| 1).sum()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "/// Swaps the values pointed to by the given pointers.\n"
#~ "///\n"
#~ "/// # Safety\n"
#~ "///\n"
#~ "/// The pointers must be valid and properly aligned.\n"
#~ "unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
#~ "    let temp = *a;\n"
#~ "    *a = *b;\n"
#~ "    *b = temp;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = 42;\n"
#~ "    let mut b = 66;\n"
#~ "\n"
#~ "    // Safe because ...\n"
#~ "    unsafe {\n"
#~ "        swap(&mut a, &mut b);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a = {}, b = {}\", a, b);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "/// Swaps the values pointed to by the given pointers.\n"
#~ "///\n"
#~ "/// # Safety\n"
#~ "///\n"
#~ "/// The pointers must be valid and properly aligned.\n"
#~ "unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
#~ "    let temp = *a;\n"
#~ "    *a = *b;\n"
#~ "    *b = temp;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut a = 42;\n"
#~ "    let mut b = 66;\n"
#~ "\n"
#~ "    // Safe because ...\n"
#~ "    unsafe {\n"
#~ "        swap(&mut a, &mut b);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"a = {}, b = {}\", a, b);\n"
#~ "}\n"
#~ "```"

#~ msgid "Calling External Code"
#~ msgstr "ì™¸ë¶€ ì½”ë“œ í˜¸ì¶œ"

#~ msgid ""
#~ "Functions from other languages might violate the guarantees of Rust. "
#~ "Calling them is thus unsafe:"
#~ msgstr ""
#~ "ë‹¤ë¥¸ ì–¸ì–´ì˜ í•¨ìˆ˜ëŠ” ëŸ¬ìŠ¤íŠ¸ì˜ ë³´ì¦ì„ ìœ„ë°˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì´ë¥¼ í˜¸ì¶œí•˜"
#~ "ëŠ” ê²ƒì€ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#~ msgid ""
#~ "```rust,editable\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(input: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    unsafe {\n"
#~ "        // Undefined behavior if abs misbehaves.\n"
#~ "        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(input: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    unsafe {\n"
#~ "        // Undefined behavior if abs misbehaves.\n"
#~ "        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::mem::size_of_val;\n"
#~ "use std::slice;\n"
#~ "\n"
#~ "/// ...\n"
#~ "/// # Safety\n"
#~ "/// The type must have a defined representation and no padding.\n"
#~ "pub unsafe trait AsBytes {\n"
#~ "    fn as_bytes(&self) -> &[u8] {\n"
#~ "        unsafe {\n"
#~ "            slice::from_raw_parts(self as *const Self as *const u8, "
#~ "size_of_val(self))\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Safe because u32 has a defined representation and no padding.\n"
#~ "unsafe impl AsBytes for u32 {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::mem::size_of_val;\n"
#~ "use std::slice;\n"
#~ "\n"
#~ "/// ...\n"
#~ "/// # Safety\n"
#~ "/// The type must have a defined representation and no padding.\n"
#~ "pub unsafe trait AsBytes {\n"
#~ "    fn as_bytes(&self) -> &[u8] {\n"
#~ "        unsafe {\n"
#~ "            slice::from_raw_parts(self as *const Self as *const u8, "
#~ "size_of_val(self))\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Safe because u32 has a defined representation and no padding.\n"
#~ "unsafe impl AsBytes for u32 {}\n"
#~ "```"

#~ msgid "Day 3: Afternoon Exercises"
#~ msgstr "3ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#~ msgid "Let us build a safe wrapper for reading directory content!"
#~ msgstr "ë””ë ‰í„°ë¦¬ì˜ ë‚´ìš©ì„ ì½ëŠ” ì•ˆì „í•œ ë˜í¼ ì½”ë“œë¥¼ ì‘ì„±í•´ ë´…ì‹œë‹¤!"

#~ msgid ""
#~ "For this exercise, we suggest using a local dev environment instead of "
#~ "the Playground. This will allow you to run your binary on your own "
#~ "machine."
#~ msgstr ""
#~ "ì´ë²ˆ ì—°ìŠµì—ì„œëŠ”, í”Œë ˆì´ê·¸ë¼ìš´ë“œ ëŒ€ì‹  ë¡œì»¬ ê°œë°œ í™˜ê²½ì„ ì‚¬ìš©í•´ì„œ, ì—¬ëŸ¬ë¶„ì˜ "
#~ "ì»´í“¨í„°ì—ì„œ ë°”ì´ë„ˆë¦¬ë¥¼ ì§ì ‘ ìˆ˜í–‰í•´ ë³´ì„¸ìš”."

#~ msgid ""
#~ "To get started, follow the [running locally](../../cargo/running-locally."
#~ "md) instructions."
#~ msgstr ""
#~ "ì‹œì‘í•˜ê¸° ìœ„í•´, [ë¡œì»¬ í™˜ê²½ì—ì„œ ìˆ˜í–‰í•˜ê¸°](../../cargo/running-locally.md)ë¥¼ "
#~ "ë”°ë¥´ì„¸ìš”."

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int};\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
#~ "\n"
#~ "    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct DIR {\n"
#~ "        _data: [u8; 0],\n"
#~ "        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
#~ "PhantomPinned)>,\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the Linux man page for readdir(3), where ino_t "
#~ "and\n"
#~ "    // off_t are resolved according to the definitions in\n"
#~ "    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_ino: c_ulong,\n"
#~ "        pub d_off: c_long,\n"
#~ "        pub d_reclen: c_ushort,\n"
#~ "        pub d_type: c_uchar,\n"
#~ "        pub d_name: [c_char; 256],\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the macOS man page for dir(5).\n"
#~ "    #[cfg(all(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_fileno: u64,\n"
#~ "        pub d_seekoff: u64,\n"
#~ "        pub d_reclen: u16,\n"
#~ "        pub d_namlen: u16,\n"
#~ "        pub d_type: u8,\n"
#~ "        pub d_name: [c_char; 1024],\n"
#~ "    }\n"
#~ "\n"
#~ "    extern \"C\" {\n"
#~ "        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
#~ "\n"
#~ "        #[cfg(not(all(target_os = \"macos\", target_arch = "
#~ "\"x86_64\")))]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        // See https://github.com/rust-lang/libc/issues/414 and the "
#~ "section on\n"
#~ "        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for "
#~ "stat(2).\n"
#~ "        //\n"
#~ "        // \"Platforms that existed before these updates were available\" "
#~ "refers\n"
#~ "        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
#~ "PowerPC.\n"
#~ "        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
#~ "        #[link_name = \"readdir$INODE64\"]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        pub fn closedir(s: *mut DIR) -> c_int;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use std::ffi::{CStr, CString, OsStr, OsString};\n"
#~ "use std::os::unix::ffi::OsStrExt;\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}\n"
#~ "\n"
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for DirectoryIterator {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Call closedir as needed.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_imports, unused_variables, dead_code)]\n"
#~ "\n"
#~ "mod ffi {\n"
#~ "    use std::os::raw::{c_char, c_int};\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
#~ "\n"
#~ "    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct DIR {\n"
#~ "        _data: [u8; 0],\n"
#~ "        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
#~ "PhantomPinned)>,\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the Linux man page for readdir(3), where ino_t "
#~ "and\n"
#~ "    // off_t are resolved according to the definitions in\n"
#~ "    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
#~ "    #[cfg(not(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_ino: c_ulong,\n"
#~ "        pub d_off: c_long,\n"
#~ "        pub d_reclen: c_ushort,\n"
#~ "        pub d_type: c_uchar,\n"
#~ "        pub d_name: [c_char; 256],\n"
#~ "    }\n"
#~ "\n"
#~ "    // Layout according to the macOS man page for dir(5).\n"
#~ "    #[cfg(all(target_os = \"macos\"))]\n"
#~ "    #[repr(C)]\n"
#~ "    pub struct dirent {\n"
#~ "        pub d_fileno: u64,\n"
#~ "        pub d_seekoff: u64,\n"
#~ "        pub d_reclen: u16,\n"
#~ "        pub d_namlen: u16,\n"
#~ "        pub d_type: u8,\n"
#~ "        pub d_name: [c_char; 1024],\n"
#~ "    }\n"
#~ "\n"
#~ "    extern \"C\" {\n"
#~ "        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
#~ "\n"
#~ "        #[cfg(not(all(target_os = \"macos\", target_arch = "
#~ "\"x86_64\")))]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        // See https://github.com/rust-lang/libc/issues/414 and the "
#~ "section on\n"
#~ "        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for "
#~ "stat(2).\n"
#~ "        //\n"
#~ "        // \"Platforms that existed before these updates were available\" "
#~ "refers\n"
#~ "        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
#~ "PowerPC.\n"
#~ "        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
#~ "        #[link_name = \"readdir$INODE64\"]\n"
#~ "        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
#~ "\n"
#~ "        pub fn closedir(s: *mut DIR) -> c_int;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use std::ffi::{CStr, CString, OsStr, OsString};\n"
#~ "use std::os::unix::ffi::OsStrExt;\n"
#~ "\n"
#~ "#[derive(Debug)]\n"
#~ "struct DirectoryIterator {\n"
#~ "    path: CString,\n"
#~ "    dir: *mut ffi::DIR,\n"
#~ "}\n"
#~ "\n"
#~ "impl DirectoryIterator {\n"
#~ "    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
#~ "        // Call opendir and return a Ok value if that worked,\n"
#~ "        // otherwise return Err with a message.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Iterator for DirectoryIterator {\n"
#~ "    type Item = OsString;\n"
#~ "    fn next(&mut self) -> Option<OsString> {\n"
#~ "        // Keep calling readdir until we get a NULL pointer back.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Drop for DirectoryIterator {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Call closedir as needed.\n"
#~ "        unimplemented!()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() -> Result<(), String> {\n"
#~ "    let iter = DirectoryIterator::new(\".\")?;\n"
#~ "    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "source build/envsetup.sh\n"
#~ "lunch aosp_cf_x86_64_phone-userdebug\n"
#~ "acloud create\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ source build/envsetup.sh\n"
#~ "$ lunch aosp_cf_x86_64_phone-userdebug\n"
#~ "$ acloud create\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust\",\n"
#~ "    crate_name: \"hello_rust\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust\",\n"
#~ "    crate_name: \"hello_rust\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello from Rust!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//! Rust ë°ëª¨ì…ë‹ˆë‹¤.\n"
#~ "\n"
#~ "/// ì¸ì‚¬ë§ì„ í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ì¸ì‡„í•©ë‹ˆë‹¤.\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello from Rust!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_with_dep\",\n"
#~ "    crate_name: \"hello_rust_with_dep\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libgreetings\",\n"
#~ "        \"libtextwrap\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "\n"
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_with_dep\",\n"
#~ "    crate_name: \"hello_rust_with_dep\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libgreetings\",\n"
#~ "        \"libtextwrap\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "\n"
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Rust ë°ëª¨ì…ë‹ˆë‹¤.\n"
#~ "\n"
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;\n"
#~ "\n"
#~ "/// ì¸ì‚¬ë§ì„ í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ì¸ì‡„í•©ë‹ˆë‹¤.\n"
#~ "fn main() {\n"
#~ "    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Greeting library.\n"
#~ "\n"
#~ "/// Greet `name`.\n"
#~ "pub fn greeting(name: &str) -> String {\n"
#~ "    format!(\"Hello {name}, it is very nice to meet you!\")\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! ì¸ì‚¬ë§ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤.\n"
#~ "\n"
#~ "/// `ì´ë¦„`ì—ê²Œ ì¸ì‚¬í•©ë‹ˆë‹¤.\n"
#~ "pub fn greeting(name: &str) -> String {\n"
#~ "    format!(\"Hello {name}, it is very nice to meet you!\")\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** Birthday service interface. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** ìƒì¼ ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "aidl_interface {\n"
#~ "    name: \"com.example.birthdayservice\",\n"
#~ "    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
#~ "    unstable: true,\n"
#~ "    backend: {\n"
#~ "        rust: { // Rust is not enabled by default\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "aidl_interface {\n"
#~ "    name: \"com.example.birthdayservice\",\n"
#~ "    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
#~ "    unstable: true,\n"
#~ "    backend: {\n"
#~ "        rust: { // Rust is not enabled by default\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Implementation of the `IBirthdayService` AIDL interface.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "/// The `IBirthdayService` implementation.\n"
#~ "pub struct BirthdayService;\n"
#~ "\n"
#~ "impl binder::Interface for BirthdayService {}\n"
#~ "\n"
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
#~ "Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} "
#~ "years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! `IBirthdayService` AIDL ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì…ë‹ˆë‹¤.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "/// `IBirthdayService` êµ¬í˜„ì…ë‹ˆë‹¤.\n"
#~ "pub struct BirthdayService;\n"
#~ "\n"
#~ "impl binder::Interface for BirthdayService {}\n"
#~ "\n"
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
#~ "Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} "
#~ "years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_library {\n"
#~ "    name: \"libbirthdayservice\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    crate_name: \"birthdayservice\",\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_library {\n"
#~ "    name: \"libbirthdayservice\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    crate_name: \"birthdayservice\",\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// Entry point for birthday service.\n"
#~ "fn main() {\n"
#~ "    let birthday_service = BirthdayService;\n"
#~ "    let birthday_service_binder = BnBirthdayService::new_binder(\n"
#~ "        birthday_service,\n"
#~ "        binder::BinderFeatures::default(),\n"
#~ "    );\n"
#~ "    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
#~ "as_binder())\n"
#~ "        .expect(\"Failed to register service\");\n"
#~ "    binder::ProcessState::join_thread_pool()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! ìƒì¼ ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// ìƒì¼ ì„œë¹„ìŠ¤ì˜ ì§„ì…ì ì…ë‹ˆë‹¤.\n"
#~ "fn main() {\n"
#~ "    let birthday_service = BirthdayService;\n"
#~ "    let birthday_service_binder = BnBirthdayService::new_binder(\n"
#~ "        birthday_service,\n"
#~ "        binder::BinderFeatures::default(),\n"
#~ "    );\n"
#~ "    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
#~ "as_binder())\n"
#~ "        .expect(\"Failed to register service\");\n"
#~ "    binder::ProcessState::join_thread_pool()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_server\",\n"
#~ "    crate_name: \"birthday_server\",\n"
#~ "    srcs: [\"src/server.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "        \"libbirthdayservice\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_server\",\n"
#~ "    crate_name: \"birthday_server\",\n"
#~ "    srcs: [\"src/server.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "        \"libbirthdayservice\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "adb shell service check birthdayservice\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb shell service check birthdayservice\n"
#~ "Service birthdayservice: found\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "Service birthdayservice: found\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb shell service check birthdayservice\n"
#~ "Service birthdayservice: found\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "adb shell service call birthdayservice 1 s16 Bob i32 24\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb shell service check birthdayservice\n"
#~ "Service birthdayservice: found\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "Result: Parcel(\n"
#~ "  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
#~ "  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
#~ "  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
#~ "  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
#~ "  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
#~ "  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
#~ "  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
#~ "  0x00000070: 00210073 00000000                   's.!.....        ')\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ $ adb shell service call birthdayservice 1 s16 Bob i32 24\n"
#~ "Result: Parcel(\n"
#~ "  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
#~ "  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
#~ "  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
#~ "  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
#~ "  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
#~ "  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
#~ "  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
#~ "  0x00000070: 00210073 00000000                   's.!.....        ')\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// Connect to the BirthdayService.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
#~ "StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}\n"
#~ "\n"
#~ "/// Call the birthday service.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);\n"
#~ "\n"
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to "
#~ "BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! ìƒì¼ ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// BirthdayServiceì— ì—°ê²°í•©ë‹ˆë‹¤.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
#~ "StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}\n"
#~ "\n"
#~ "/// ìƒì¼ ì„œë¹„ìŠ¤ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);\n"
#~ "\n"
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to "
#~ "BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_client\",\n"
#~ "    crate_name: \"birthday_client\",\n"
#~ "    srcs: [\"src/client.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_client\",\n"
#~ "    crate_name: \"birthday_client\",\n"
#~ "    srcs: [\"src/client.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** Birthday service interface. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years, in String[] text);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "package com.example.birthdayservice;\n"
#~ "\n"
#~ "/** ìƒì¼ ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤. */\n"
#~ "interface IBirthdayService {\n"
#~ "    /** Generate a Happy Birthday message. */\n"
#~ "    String wishHappyBirthday(String name, int years, in String[] text);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_logs\",\n"
#~ "    crate_name: \"hello_rust_logs\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"liblog_rust\",\n"
#~ "        \"liblogger\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "    host_supported: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_logs\",\n"
#~ "    crate_name: \"hello_rust_logs\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"liblog_rust\",\n"
#~ "        \"liblogger\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "    host_supported: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust logging demo.\n"
#~ "\n"
#~ "use log::{debug, error, info};\n"
#~ "\n"
#~ "/// Logs a greeting.\n"
#~ "fn main() {\n"
#~ "    logger::init(\n"
#~ "        logger::Config::default()\n"
#~ "            .with_tag_on_device(\"rust\")\n"
#~ "            .with_min_level(log::Level::Trace),\n"
#~ "    );\n"
#~ "    debug!(\"Starting program.\");\n"
#~ "    info!(\"Things are going fine.\");\n"
#~ "    error!(\"Something went wrong!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Rust ë¡œê¹… ë°ëª¨ì…ë‹ˆë‹¤.\n"
#~ "\n"
#~ "use log::{debug, error, info};\n"
#~ "\n"
#~ "/// ì¸ì‚¬ë§ì„ ê¸°ë¡í•©ë‹ˆë‹¤.\n"
#~ "fn main() {\n"
#~ "    logger::init(\n"
#~ "        logger::Config::default()\n"
#~ "            .with_tag_on_device(\"rust\")\n"
#~ "            .with_min_level(log::Level::Trace),\n"
#~ "    );\n"
#~ "    debug!(\"Starting program.\");\n"
#~ "    info!(\"Things are going fine.\");\n"
#~ "    error!(\"Something went wrong!\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "adb logcat -s rust\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ sudo apt install cargo rust-src rustfmt\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting "
#~ "program.\n"
#~ "09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
#~ "fine.\n"
#~ "09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
#~ "wrong!\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ adb logcat -s rust\n"
#~ "09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting "
#~ "program.\n"
#~ "09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
#~ "fine.\n"
#~ "09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
#~ "wrong!\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -42;\n"
#~ "    let abs_x = unsafe { abs(x) };\n"
#~ "    println!(\"{x}, {abs_x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -42;\n"
#~ "    let abs_x = unsafe { abs(x) };\n"
#~ "    println!(\"{x}, {abs_x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI demo.\n"
#~ "\n"
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;\n"
#~ "\n"
#~ "/// HelloWorld::hello method implementation.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"system\" fn Java_HelloWorld_hello(\n"
#~ "    env: JNIEnv,\n"
#~ "    _class: JClass,\n"
#~ "    name: JString,\n"
#~ ") -> jstring {\n"
#~ "    let input: String = env.get_string(name).unwrap().into();\n"
#~ "    let greeting = format!(\"Hello, {input}!\");\n"
#~ "    let output = env.new_string(greeting).unwrap();\n"
#~ "    output.into_inner()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI ë°ëª¨ì…ë‹ˆë‹¤.\n"
#~ "\n"
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;\n"
#~ "\n"
#~ "/// HelloWorld::hello ë©”ì„œë“œ êµ¬í˜„ì…ë‹ˆë‹¤.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"system\" fn Java_HelloWorld_hello(\n"
#~ "    env: JNIEnv,\n"
#~ "    _class: JClass,\n"
#~ "    name: JString,\n"
#~ ") -> jstring {\n"
#~ "    let input: String = env.get_string(name).unwrap().into();\n"
#~ "    let greeting = format!(\"Hello, {input}!\");\n"
#~ "    let output = env.new_string(greeting).unwrap();\n"
#~ "    output.into_inner()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_ffi_shared {\n"
#~ "    name: \"libhello_jni\",\n"
#~ "    crate_name: \"hello_jni\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    rustlibs: [\"libjni\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_ffi_shared {\n"
#~ "    name: \"libhello_jni\",\n"
#~ "    crate_name: \"hello_jni\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    rustlibs: [\"libjni\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);\n"
#~ "\n"
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        String output = HelloWorld.hello(\"Alice\");\n"
#~ "        System.out.println(output);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);\n"
#~ "\n"
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        String output = HelloWorld.hello(\"Alice\");\n"
#~ "        System.out.println(output);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "java_binary {\n"
#~ "    name: \"helloworld_jni\",\n"
#~ "    srcs: [\"HelloWorld.java\"],\n"
#~ "    main_class: \"HelloWorld\",\n"
#~ "    required: [\"libhello_jni\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "java_binary {\n"
#~ "    name: \"helloworld_jni\",\n"
#~ "    srcs: [\"HelloWorld.java\"],\n"
#~ "    main_class: \"HelloWorld\",\n"
#~ "    required: [\"libhello_jni\"],\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "m helloworld_jni\n"
#~ "adb sync  # requires adb root && adb remount\n"
#~ "adb shell /system/bin/helloworld_jni\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ m helloworld_jni\n"
#~ "$ adb sync  # requires adb root && adb remount\n"
#~ "$ adb shell /system/bin/helloworld_jni\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom "
#~ "pkg-config qemu-system-arm\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom "
#~ "pkg-config qemu-system-arm\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
#~ "GROUP=\"plugdev\"' |\\\n"
#~ "  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
#~ "sudo udevadm control --reload-rules\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
#~ "GROUP=\"plugdev\"' |\\\n"
#~ "  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
#~ "sudo udevadm control --reload-rules\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "xcode-select --install\n"
#~ "brew install gdb picocom qemu\n"
#~ "brew install --cask gcc-aarch64-embedded\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "xcode-select --install\n"
#~ "brew install gdb picocom qemu\n"
#~ "brew install --cask gcc-aarch64-embedded\n"
#~ "rustup update\n"
#~ "rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
#~ "rustup component add llvm-tools-preview\n"
#~ "cargo install cargo-binutils cargo-embed\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "#[panic_handler]\n"
#~ "fn panic(_panic: &PanicInfo) -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "#[panic_handler]\n"
#~ "fn panic(_panic: &PanicInfo) -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate alloc;\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use alloc::string::ToString;\n"
#~ "use alloc::vec::Vec;\n"
#~ "use buddy_system_allocator::LockedHeap;\n"
#~ "\n"
#~ "#[global_allocator]\n"
#~ "static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
#~ "\n"
#~ "static mut HEAP: [u8; 65536] = [0; 65536];\n"
#~ "\n"
#~ "pub fn entry() {\n"
#~ "    // Safe because `HEAP` is only used here and `entry` is only called "
#~ "once.\n"
#~ "    unsafe {\n"
#~ "        // Give the allocator some memory to allocate.\n"
#~ "        HEAP_ALLOCATOR\n"
#~ "            .lock()\n"
#~ "            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    // Now we can do things that require heap allocation.\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push(\"A string\".to_string());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate alloc;\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use alloc::string::ToString;\n"
#~ "use alloc::vec::Vec;\n"
#~ "use buddy_system_allocator::LockedHeap;\n"
#~ "\n"
#~ "#[global_allocator]\n"
#~ "static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
#~ "\n"
#~ "static mut HEAP: [u8; 65536] = [0; 65536];\n"
#~ "\n"
#~ "pub fn entry() {\n"
#~ "    // Safe because `HEAP` is only used here and `entry` is only called "
#~ "once.\n"
#~ "    unsafe {\n"
#~ "        // Give the allocator some memory to allocate.\n"
#~ "        HEAP_ALLOCATOR\n"
#~ "            .lock()\n"
#~ "            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
#~ "    }\n"
#~ "\n"
#~ "    // ì´ì œ í™ í• ë‹¹ì´ í•„ìš”í•œ ì‘ì—…ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
#~ "    let mut v = Vec::new();\n"
#~ "    v.push(\"A string\".to_string());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use core::mem::size_of;\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "/// GPIO port 0 peripheral address\n"
#~ "const GPIO_P0: usize = 0x5000_0000;\n"
#~ "\n"
#~ "// GPIO peripheral offsets\n"
#~ "const PIN_CNF: usize = 0x700;\n"
#~ "const OUTSET: usize = 0x508;\n"
#~ "const OUTCLR: usize = 0x50c;\n"
#~ "\n"
#~ "// PIN_CNF fields\n"
#~ "const DIR_OUTPUT: u32 = 0x1;\n"
#~ "const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
#~ "const PULL_DISABLED: u32 = 0x0 << 2;\n"
#~ "const DRIVE_S0S1: u32 = 0x0 << 8;\n"
#~ "const SENSE_DISABLED: u32 = 0x0 << 16;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    // Safe because the pointers are to valid peripheral control "
#~ "registers, and\n"
#~ "    // no aliases exist.\n"
#~ "    unsafe {\n"
#~ "        pin_cnf_21.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "        pin_cnf_28.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
#~ "    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
#~ "    // Safe because the pointers are to valid peripheral control "
#~ "registers, and\n"
#~ "    // no aliases exist.\n"
#~ "    unsafe {\n"
#~ "        gpio0_outclr.write_volatile(1 << 28);\n"
#~ "        gpio0_outset.write_volatile(1 << 21);\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "mod interrupts;\n"
#~ "\n"
#~ "use core::mem::size_of;\n"
#~ "use cortex_m_rt::entry;\n"
#~ "\n"
#~ "/// GPIO í¬íŠ¸ 0 ì£¼ë³€ê¸°ê¸° ì£¼ì†Œì…ë‹ˆë‹¤.\n"
#~ "const GPIO_P0: usize = 0x5000_0000;\n"
#~ "\n"
#~ "// GPIO ì£¼ë³€ê¸°ê¸° ì˜¤í”„ì…‹ì…ë‹ˆë‹¤.\n"
#~ "const PIN_CNF: usize = 0x700;\n"
#~ "const OUTSET: usize = 0x508;\n"
#~ "const OUTCLR: usize = 0x50c;\n"
#~ "\n"
#~ "// PIN_CNF í•„ë“œì…ë‹ˆë‹¤.\n"
#~ "const DIR_OUTPUT: u32 = 0x1;\n"
#~ "const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
#~ "const PULL_DISABLED: u32 = 0x0 << 2;\n"
#~ "const DRIVE_S0S1: u32 = 0x0 << 8;\n"
#~ "const SENSE_DISABLED: u32 = 0x0 << 16;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
#~ "u32;\n"
#~ "    // Safe because the pointers are to valid peripheral control "
#~ "registers, and\n"
#~ "    // no aliases exist.\n"
#~ "    unsafe {\n"
#~ "        pin_cnf_21.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "        pin_cnf_28.write_volatile(\n"
#~ "            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
#~ "SENSE_DISABLED,\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    // í•€ 28ì„ lowë¡œ, í•€ 21ì„ highë¡œ ì„¤ì •í•˜ì—¬ LEDì„ ì¼­ë‹ˆë‹¤.\n"
#~ "    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
#~ "    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
#~ "    // í¬ì¸í„°ê°€ ìœ íš¨í•œ ì£¼ë³€ê¸°ê¸° ì»¨íŠ¸ë¡¤ ë ˆì§€ìŠ¤í„°ì— ê´€í•œ ê²ƒì´ë¯€ë¡œ ì•ˆì „í•˜ê³ \n"
#~ "    // ë³„ì¹­ì´ ì—†ìŠµë‹ˆë‹¤.\n"
#~ "    unsafe {\n"
#~ "        gpio0_outclr.write_volatile(1 << 28);\n"
#~ "        gpio0_outset.write_volatile(1 << 21);\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin mmio\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin mmio\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_pac::Peripherals;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p.P0;\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    gpio0.pin_cnf[21].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "    gpio0.pin_cnf[28].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    gpio0.outclr.write(|w| w.pin28().clear());\n"
#~ "    gpio0.outset.write(|w| w.pin21().set());\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_pac::Peripherals;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p.P0;\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    gpio0.pin_cnf[21].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "    gpio0.pin_cnf[28].write(|w| {\n"
#~ "        w.dir().output();\n"
#~ "        w.input().disconnect();\n"
#~ "        w.pull().disabled();\n"
#~ "        w.drive().s0s1();\n"
#~ "        w.sense().disabled();\n"
#~ "        w\n"
#~ "    });\n"
#~ "\n"
#~ "    // í•€ 28ì„ lowë¡œ, í•€ 21ì„ highë¡œ ì„¤ì •í•˜ì—¬ LEDë¥¼ ì¼­ë‹ˆë‹¤.\n"
#~ "    gpio0.outclr.write(|w| w.pin28().clear());\n"
#~ "    gpio0.outset.write(|w| w.pin21().set());\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_hal::gpio::{p0, Level};\n"
#~ "use nrf52833_hal::pac::Peripherals;\n"
#~ "use nrf52833_hal::prelude::*;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "\n"
#~ "    // Create HAL wrapper for GPIO port 0.\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
#~ "    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    col1.set_low().unwrap();\n"
#~ "    row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use nrf52833_hal::gpio::{p0, Level};\n"
#~ "use nrf52833_hal::pac::Peripherals;\n"
#~ "use nrf52833_hal::prelude::*;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "\n"
#~ "    // Create HAL wrapper for GPIO port 0.\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
#~ "    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
#~ "    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    // Set pin 28 low and pin 21 high to turn the LED on.\n"
#~ "    col1.set_low().unwrap();\n"
#~ "    row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin hal\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin hal\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use microbit::hal::prelude::*;\n"
#~ "use microbit::Board;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let mut board = Board::take().unwrap();\n"
#~ "\n"
#~ "    board.display_pins.col1.set_low().unwrap();\n"
#~ "    board.display_pins.row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "extern crate panic_halt as _;\n"
#~ "\n"
#~ "use cortex_m_rt::entry;\n"
#~ "use microbit::hal::prelude::*;\n"
#~ "use microbit::Board;\n"
#~ "\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let mut board = Board::take().unwrap();\n"
#~ "\n"
#~ "    board.display_pins.col1.set_low().unwrap();\n"
#~ "    board.display_pins.row1.set_high().unwrap();\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin board_support\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin board_support\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
#~ "\n"
#~ "    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
#~ "    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
#~ "    if pin_input.is_high().unwrap() {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    pin_output.set_high().unwrap();\n"
#~ "    // pin_input.is_high(); // Error, moved.\n"
#~ "\n"
#~ "    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
#~ "        .p0_02\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
#~ "into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#[entry]\n"
#~ "fn main() -> ! {\n"
#~ "    let p = Peripherals::take().unwrap();\n"
#~ "    let gpio0 = p0::Parts::new(p.P0);\n"
#~ "\n"
#~ "    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
#~ "\n"
#~ "    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
#~ "    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
#~ "    if pin_input.is_high().unwrap() {\n"
#~ "        // ...\n"
#~ "    }\n"
#~ "    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    pin_output.set_high().unwrap();\n"
#~ "    // pin_input.is_high(); // ì˜¤ë¥˜, ì´ë™í–ˆìŠµë‹ˆë‹¤.\n"
#~ "\n"
#~ "    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
#~ "        .p0_02\n"
#~ "        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
#~ "Level::Low);\n"
#~ "    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
#~ "into_push_pull_output(Level::Low);\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid "SWD"
#~ msgstr "SWD"

#~ msgid "GDB stub and Microsoft "
#~ msgstr "GDB ìŠ¤í… ë° Microsoft "

#~ msgid "DAP"
#~ msgstr "DAP"

#~ msgid " server"
#~ msgstr " ì„œë²„"

#~ msgid ""
#~ "`cargo-embed` is a cargo subcommand to build and flash binaries, log "
#~ msgstr ""
#~ "`cargo-embed`ëŠ” cargoì˜ ì„œë¸Œ ì»¤ë§¨íŠ¸ë¡œì¨, ë°”ì´ë„ˆë¦¬ë¥¼ ë¹Œë“œí•˜ê³  í”Œë˜ì‹œí•˜ë©°, "

#~ msgid "RTT"
#~ msgstr "RTT"

#~ msgid ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo embed --bin board_support debug\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin board_support debug\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
#~ "command=\"target remote :1337\"\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
#~ "command=\"target remote :1337\"\n"
#~ "```"

#~ msgid ""
#~ "```gdb\n"
#~ "b src/bin/board_support.rs:29\n"
#~ "b src/bin/board_support.rs:30\n"
#~ "b src/bin/board_support.rs:32\n"
#~ "c\n"
#~ "c\n"
#~ "c\n"
#~ "```"
#~ msgstr ""
#~ "```gdb\n"
#~ "b src/bin/board_support.rs:29\n"
#~ "b src/bin/board_support.rs:30\n"
#~ "b src/bin/board_support.rs:32\n"
#~ "c\n"
#~ "c\n"
#~ "c\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "\n"
#~ "[debug.reset]\n"
#~ "halt_afterwards = true\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[default.general]\n"
#~ "chip = \"nrf52833_xxAA\"\n"
#~ "\n"
#~ "[debug.gdb]\n"
#~ "enabled = true\n"
#~ "```"

#~ msgid "HVC"
#~ msgstr "HVC"

#~ msgid " to tell the firmware to power off the system:"
#~ msgstr "ë¥¼ í˜¸ì¶œí•˜ëŠ”  ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::arch::asm;\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "mod exceptions;\n"
#~ "\n"
#~ "const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
#~ "\n"
#~ "#[no_mangle]\n"
#~ "extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
#~ "    // Safe because this only uses the declared registers and doesn't do\n"
#~ "    // anything with memory.\n"
#~ "    unsafe {\n"
#~ "        asm!(\"hvc #0\",\n"
#~ "            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
#~ "            inout(\"w1\") 0 => _,\n"
#~ "            inout(\"w2\") 0 => _,\n"
#~ "            inout(\"w3\") 0 => _,\n"
#~ "            inout(\"w4\") 0 => _,\n"
#~ "            inout(\"w5\") 0 => _,\n"
#~ "            inout(\"w6\") 0 => _,\n"
#~ "            inout(\"w7\") 0 => _,\n"
#~ "            options(nomem, nostack)\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use core::arch::asm;\n"
#~ "use core::panic::PanicInfo;\n"
#~ "\n"
#~ "mod exceptions;\n"
#~ "\n"
#~ "const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
#~ "\n"
#~ "#[no_mangle]\n"
#~ "extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
#~ "    // Safe because this only uses the declared registers and doesn't do\n"
#~ "    // anything with memory.\n"
#~ "    unsafe {\n"
#~ "        asm!(\"hvc #0\",\n"
#~ "            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
#~ "            inout(\"w1\") 0 => _,\n"
#~ "            inout(\"w2\") 0 => _,\n"
#~ "            inout(\"w3\") 0 => _,\n"
#~ "            inout(\"w4\") 0 => _,\n"
#~ "            inout(\"w5\") 0 => _,\n"
#~ "            inout(\"w6\") 0 => _,\n"
#~ "            inout(\"w7\") 0 => _,\n"
#~ "            options(nomem, nostack)\n"
#~ "        );\n"
#~ "    }\n"
#~ "\n"
#~ "    loop {}\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
#~ "const FR_BUSY: u8 = 1 << 3;\n"
#~ "const FR_TXFF: u8 = 1 << 5;\n"
#~ "\n"
#~ "/// Minimal driver for a PL011 UART.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    base_address: *mut u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
#~ "        Self { base_address }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Writes a single byte to the UART.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register() & FR_TXFF != 0 {}\n"
#~ "\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            self.base_address.write_volatile(byte);\n"
#~ "        }\n"
#~ "\n"
#~ "        // Wait until the UART is no longer busy.\n"
#~ "        while self.read_flag_register() & FR_BUSY != 0 {}\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> u8 {\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
#~ "read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
#~ "const FR_BUSY: u8 = 1 << 3;\n"
#~ "const FR_TXFF: u8 = 1 << 5;\n"
#~ "\n"
#~ "/// PL011 UARTìš© ìµœì†Œ ë“œë¼ì´ë²„ì…ë‹ˆë‹¤.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    base_address: *mut u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
#~ "        Self { base_address }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// UARTì— í•œ ë°”ì´íŠ¸ë¥¼ ì”ë‹ˆë‹¤.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register() & FR_TXFF != 0 {}\n"
#~ "\n"
#~ "        //  `base_address`ê°€ PL011ì˜ ì»¨íŠ¸ë¡¤ ë ˆì§€ìŠ¤í„°ê°€ ë§¤í•‘ëœ ì£¼ì†Œë¥¼ ê°€ë¦¬"
#~ "í‚¤ê³ \n"
#~ "        // ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            self.base_address.write_volatile(byte);\n"
#~ "        }\n"
#~ "\n"
#~ "        // UARTê°€ ë” ì´ìƒ ì‚¬ìš© ì¤‘ì´ ì•„ë‹ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.\n"
#~ "        while self.read_flag_register() & FR_BUSY != 0 {}\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> u8 {\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
#~ "read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "/// Driver for a PL011 UART.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    registers: *mut Registers,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
#~ "        Self {\n"
#~ "            registers: base_address as *mut Registers,\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Writes a single byte to the UART.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register().contains(Flags::TXFF) {}\n"
#~ "\n"
#~ "        // Safe because we know that self.registers points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            addr_of_mut!((*self.registers).dr).write_volatile(byte."
#~ "into());\n"
#~ "        }\n"
#~ "\n"
#~ "        // Wait until the UART is no longer busy.\n"
#~ "        while self.read_flag_register().contains(Flags::BUSY) {}\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Reads and returns a pending byte, or `None` if nothing has been "
#~ "received.\n"
#~ "    pub fn read_byte(&self) -> Option<u8> {\n"
#~ "        if self.read_flag_register().contains(Flags::RXFE) {\n"
#~ "            None\n"
#~ "        } else {\n"
#~ "            let data = unsafe { addr_of!((*self.registers).dr)."
#~ "read_volatile() };\n"
#~ "            // TODO: Check for error conditions in bits 8-11.\n"
#~ "            Some(data as u8)\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> Flags {\n"
#~ "        // Safe because we know that self.registers points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
#~ "const FR_BUSY: u8 = 1 << 3;\n"
#~ "const FR_TXFF: u8 = 1 << 5;\n"
#~ "\n"
#~ "/// PL011 UARTìš© ìµœì†Œ ë“œë¼ì´ë²„ì…ë‹ˆë‹¤.\n"
#~ "#[derive(Debug)]\n"
#~ "pub struct Uart {\n"
#~ "    base_address: *mut u8,\n"
#~ "}\n"
#~ "\n"
#~ "impl Uart {\n"
#~ "    /// Constructs a new instance of the UART driver for a PL011 device "
#~ "at the\n"
#~ "    /// given base address.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// The given base address must point to the 8 MMIO control registers "
#~ "of a\n"
#~ "    /// PL011 device, which must be mapped into the address space of the "
#~ "process\n"
#~ "    /// as device memory and not have any other aliases.\n"
#~ "    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
#~ "        Self { base_address }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// UARTì— í•œ ë°”ì´íŠ¸ë¥¼ ì”ë‹ˆë‹¤.\n"
#~ "    pub fn write_byte(&self, byte: u8) {\n"
#~ "        // Wait until there is room in the TX buffer.\n"
#~ "        while self.read_flag_register() & FR_TXFF != 0 {}\n"
#~ "\n"
#~ "        //  `base_address`ê°€ PL011ì˜ ì»¨íŠ¸ë¡¤ ë ˆì§€ìŠ¤í„°ê°€ ë§¤í•‘ëœ ì£¼ì†Œë¥¼ ê°€ë¦¬"
#~ "í‚¤ê³ \n"
#~ "        // ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.\n"
#~ "        unsafe {\n"
#~ "            // Write to the TX buffer.\n"
#~ "            self.base_address.write_volatile(byte);\n"
#~ "        }\n"
#~ "\n"
#~ "        // UARTê°€ ë” ì´ìƒ ì‚¬ìš© ì¤‘ì´ ì•„ë‹ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.\n"
#~ "        while self.read_flag_register() & FR_BUSY != 0 {}\n"
#~ "    }\n"
#~ "\n"
#~ "    fn read_flag_register(&self) -> u8 {\n"
#~ "        // Safe because we know that the base address points to the "
#~ "control\n"
#~ "        // registers of a PL011 device which is appropriately mapped.\n"
#~ "        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
#~ "read_volatile() }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// Initialises UART logger.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// UART ë¡œê±°ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use zerocopy::AsBytes;\n"
#~ "\n"
#~ "#[repr(u32)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "enum RequestType {\n"
#~ "    #[default]\n"
#~ "    In = 0,\n"
#~ "    Out = 1,\n"
#~ "    Flush = 4,\n"
#~ "}\n"
#~ "\n"
#~ "#[repr(C)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "struct VirtioBlockRequest {\n"
#~ "    request_type: RequestType,\n"
#~ "    reserved: u32,\n"
#~ "    sector: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let request = VirtioBlockRequest {\n"
#~ "        request_type: RequestType::Flush,\n"
#~ "        sector: 42,\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "\n"
#~ "    assert_eq!(\n"
#~ "        request.as_bytes(),\n"
#~ "        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
#~ "    );\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use zerocopy::AsBytes;\n"
#~ "\n"
#~ "#[repr(u32)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "enum RequestType {\n"
#~ "    #[default]\n"
#~ "    In = 0,\n"
#~ "    Out = 1,\n"
#~ "    Flush = 4,\n"
#~ "}\n"
#~ "\n"
#~ "#[repr(C)]\n"
#~ "#[derive(AsBytes, Debug, Default)]\n"
#~ "struct VirtioBlockRequest {\n"
#~ "    request_type: RequestType,\n"
#~ "    reserved: u32,\n"
#~ "    sector: u64,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let request = VirtioBlockRequest {\n"
#~ "        request_type: RequestType::Flush,\n"
#~ "        sector: 42,\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "\n"
#~ "    assert_eq!(\n"
#~ "        request.as_bytes(),\n"
#~ "        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
#~ "    );\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use aarch64_paging::{\n"
#~ "    idmap::IdMap,\n"
#~ "    paging::{Attributes, MemoryRegion},\n"
#~ "};\n"
#~ "\n"
#~ "const ASID: usize = 1;\n"
#~ "const ROOT_LEVEL: usize = 1;\n"
#~ "\n"
#~ "// Create a new page table with identity mapping.\n"
#~ "let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
#~ "// Map a 2 MiB region of memory as read-only.\n"
#~ "idmap.map_range(\n"
#~ "    &MemoryRegion::new(0x80200000, 0x80400000),\n"
#~ "    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
#~ ").unwrap();\n"
#~ "// Set `TTBR0_EL1` to activate the page table.\n"
#~ "idmap.activate();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use aarch64_paging::{\n"
#~ "    idmap::IdMap,\n"
#~ "    paging::{Attributes, MemoryRegion},\n"
#~ "};\n"
#~ "\n"
#~ "const ASID: usize = 1;\n"
#~ "const ROOT_LEVEL: usize = 1;\n"
#~ "\n"
#~ "// ìƒë™(identity) ë§¤í•‘ìœ¼ë¡œ ìƒˆë¡œìš´ í˜ì´ì§€ í…Œì´ë¸”ì„ ë§Œë“­ë‹ˆë‹¤.\n"
#~ "let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
#~ "// 2MiB ë©”ëª¨ë¦¬ ì˜ì—­ì„ ì½ê¸° ì „ìš©ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.\n"
#~ "idmap.map_range(\n"
#~ "    &MemoryRegion::new(0x80200000, 0x80400000),\n"
#~ "    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
#~ ").unwrap();\n"
#~ "// í˜ì´ì§€ í…Œì´ë¸”ì„ í™œì„±í™”í•˜ë„ë¡ `TTBR0_EL1`ì„ ì„¤ì •í•©ë‹ˆë‹¤.\n"
#~ "idmap.activate();\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use buddy_system_allocator::FrameAllocator;\n"
#~ "use core::alloc::Layout;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut allocator = FrameAllocator::<32>::new();\n"
#~ "    allocator.add_frame(0x200_0000, 0x400_0000);\n"
#~ "\n"
#~ "    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
#~ "    let bar = allocator\n"
#~ "        .alloc_aligned(layout)\n"
#~ "        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
#~ "    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use buddy_system_allocator::FrameAllocator;\n"
#~ "use core::alloc::Layout;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut allocator = FrameAllocator::<32>::new();\n"
#~ "    allocator.add_frame(0x200_0000, 0x400_0000);\n"
#~ "\n"
#~ "    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
#~ "    let bar = allocator\n"
#~ "        .alloc_aligned(layout)\n"
#~ "        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
#~ "    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tinyvec::{array_vec, ArrayVec};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.push(7);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.remove(1);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tinyvec::{array_vec, ArrayVec};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.push(7);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "    numbers.remove(1);\n"
#~ "    println!(\"{numbers:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "    *counter.lock() += 2;\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "    *counter.lock() += 2;\n"
#~ "    println!(\"count: {}\", counter.lock());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```soong\n"
#~ "rust_ffi_static {\n"
#~ "    name: \"libvmbase_example\",\n"
#~ "    defaults: [\"vmbase_ffi_defaults\"],\n"
#~ "    crate_name: \"vmbase_example\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libvmbase\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "cc_binary {\n"
#~ "    name: \"vmbase_example\",\n"
#~ "    defaults: [\"vmbase_elf_defaults\"],\n"
#~ "    srcs: [\n"
#~ "        \"idmap.S\",\n"
#~ "    ],\n"
#~ "    static_libs: [\n"
#~ "        \"libvmbase_example\",\n"
#~ "    ],\n"
#~ "    linker_scripts: [\n"
#~ "        \"image.ld\",\n"
#~ "        \":vmbase_sections\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "raw_binary {\n"
#~ "    name: \"vmbase_example_bin\",\n"
#~ "    stem: \"vmbase_example.bin\",\n"
#~ "    src: \":vmbase_example\",\n"
#~ "    enabled: false,\n"
#~ "    target: {\n"
#~ "        android_arm64: {\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```soong\n"
#~ "rust_ffi_static {\n"
#~ "    name: \"libvmbase_example\",\n"
#~ "    defaults: [\"vmbase_ffi_defaults\"],\n"
#~ "    crate_name: \"vmbase_example\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libvmbase\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "cc_binary {\n"
#~ "    name: \"vmbase_example\",\n"
#~ "    defaults: [\"vmbase_elf_defaults\"],\n"
#~ "    srcs: [\n"
#~ "        \"idmap.S\",\n"
#~ "    ],\n"
#~ "    static_libs: [\n"
#~ "        \"libvmbase_example\",\n"
#~ "    ],\n"
#~ "    linker_scripts: [\n"
#~ "        \"image.ld\",\n"
#~ "        \":vmbase_sections\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "\n"
#~ "raw_binary {\n"
#~ "    name: \"vmbase_example_bin\",\n"
#~ "    stem: \"vmbase_example.bin\",\n"
#~ "    src: \":vmbase_example\",\n"
#~ "    enabled: false,\n"
#~ "    target: {\n"
#~ "        android_arm64: {\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use vmbase::{main, println};\n"
#~ "\n"
#~ "main!(main);\n"
#~ "\n"
#~ "pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
#~ "    println!(\"Hello world\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "#![no_main]\n"
#~ "#![no_std]\n"
#~ "\n"
#~ "use vmbase::{main, println};\n"
#~ "\n"
#~ "main!(main);\n"
#~ "\n"
#~ "pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
#~ "    println!(\"Hello world\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "// Copyright 2023 Google LLC\n"
#~ "//\n"
#~ "// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
#~ "// you may not use this file except in compliance with the License.\n"
#~ "// You may obtain a copy of the License at\n"
#~ "//\n"
#~ "//      http://www.apache.org/licenses/LICENSE-2.0\n"
#~ "//\n"
#~ "// Unless required by applicable law or agreed to in writing, software\n"
#~ "// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
#~ "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or "
#~ "implied.\n"
#~ "// See the License for the specific language governing permissions and\n"
#~ "// limitations under the License.\n"
#~ "\n"
#~ "// ANCHOR: main\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// Initialises UART logger.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use crate::pl011::Uart;\n"
#~ "use core::fmt::Write;\n"
#~ "use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
#~ "use spin::mutex::SpinMutex;\n"
#~ "\n"
#~ "static LOGGER: Logger = Logger {\n"
#~ "    uart: SpinMutex::new(None),\n"
#~ "};\n"
#~ "\n"
#~ "struct Logger {\n"
#~ "    uart: SpinMutex<Option<Uart>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Log for Logger {\n"
#~ "    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
#~ "        true\n"
#~ "    }\n"
#~ "\n"
#~ "    fn log(&self, record: &Record) {\n"
#~ "        writeln!(\n"
#~ "            self.uart.lock().as_mut().unwrap(),\n"
#~ "            \"[{}] {}\",\n"
#~ "            record.level(),\n"
#~ "            record.args()\n"
#~ "        )\n"
#~ "        .unwrap();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn flush(&self) {}\n"
#~ "}\n"
#~ "\n"
#~ "/// UART ë¡œê±°ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.\n"
#~ "pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
#~ "SetLoggerError> {\n"
#~ "    LOGGER.uart.lock().replace(uart);\n"
#~ "\n"
#~ "    log::set_logger(&LOGGER)?;\n"
#~ "    log::set_max_level(max_level);\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    thread::spawn(|| {\n"
#~ "        for i in 1..10 {\n"
#~ "            println!(\"Count in thread: {i}!\");\n"
#~ "            thread::sleep(Duration::from_millis(5));\n"
#~ "        }\n"
#~ "    });\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    thread::spawn(|| {\n"
#~ "        for i in 1..10 {\n"
#~ "            println!(\"Count in thread: {i}!\");\n"
#~ "            thread::sleep(Duration::from_millis(5));\n"
#~ "        }\n"
#~ "    });\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn foo() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::scope(|scope| {\n"
#~ "        scope.spawn(|| {\n"
#~ "            println!(\"Length: {}\", s.len());\n"
#~ "        });\n"
#~ "    });\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::scope(|scope| {\n"
#~ "        scope.spawn(|| {\n"
#~ "            println!(\"Length: {}\", s.len());\n"
#~ "        });\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    tx.send(10).unwrap();\n"
#~ "    tx.send(20).unwrap();\n"
#~ "\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "\n"
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    tx.send(10).unwrap();\n"
#~ "    tx.send(20).unwrap();\n"
#~ "\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "\n"
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(vec![10, 20, 30]);\n"
#~ "    let mut handles = Vec::new();\n"
#~ "    for _ in 1..5 {\n"
#~ "        let v = Arc::clone(&v);\n"
#~ "        handles.push(thread::spawn(move || {\n"
#~ "            let thread_id = thread::current().id();\n"
#~ "            println!(\"{thread_id:?}: {v:?}\");\n"
#~ "        }));\n"
#~ "    }\n"
#~ "\n"
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(vec![10, 20, 30]);\n"
#~ "    let mut handles = Vec::new();\n"
#~ "    for _ in 1..5 {\n"
#~ "        let v = Arc::clone(&v);\n"
#~ "        handles.push(thread::spawn(move || {\n"
#~ "            let thread_id = thread::current().id();\n"
#~ "            println!(\"{thread_id:?}: {v:?}\");\n"
#~ "        }));\n"
#~ "    }\n"
#~ "\n"
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "// use std::sync::{Arc, Mutex};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let handle = thread::spawn(|| {\n"
#~ "        v.push(10);\n"
#~ "    });\n"
#~ "    v.push(1000);\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo new link-checker\n"
#~ "cd link-checker\n"
#~ "cargo add --features blocking,rustls-tls reqwest\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "cargo init concurrency\n"
#~ "cd concurrency\n"
#~ "cargo add tokio --features full\n"
#~ "cargo run\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo add scraper\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo add thiserror\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin mmio\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo run\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::executor::block_on;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count is: {i}!\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn async_main(count: i32) {\n"
#~ "    count_to(count).await;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    block_on(async_main(10));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::executor::block_on;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count is: {i}!\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn async_main(count: i32) {\n"
#~ "    count_to(count).await;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    block_on(async_main(10));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::pin::Pin;\n"
#~ "use std::task::Context;\n"
#~ "\n"
#~ "pub trait Future {\n"
#~ "    type Output;\n"
#~ "    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
#~ "Output>;\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Poll<T> {\n"
#~ "    Ready(T),\n"
#~ "    Pending,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::pin::Pin;\n"
#~ "use std::task::Context;\n"
#~ "\n"
#~ "pub trait Future {\n"
#~ "    type Output;\n"
#~ "    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
#~ "Output>;\n"
#~ "}\n"
#~ "\n"
#~ "pub enum Poll<T> {\n"
#~ "    Ready(T),\n"
#~ "    Pending,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::time;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count in task: {i}!\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    tokio::spawn(count_to(10));\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main task: {i}\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::time;\n"
#~ "\n"
#~ "async fn count_to(count: i32) {\n"
#~ "    for i in 1..=count {\n"
#~ "        println!(\"Count in task: {i}!\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    tokio::spawn(count_to(10));\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main task: {i}\");\n"
#~ "        time::sleep(time::Duration::from_millis(5)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
#~ "use tokio::net::TcpListener;\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() -> io::Result<()> {\n"
#~ "    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
#~ "\tprintln!(\"listening on port 6142\");\n"
#~ "\n"
#~ "    loop {\n"
#~ "        let (mut socket, addr) = listener.accept().await?;\n"
#~ "\n"
#~ "        println!(\"connection from {addr:?}\");\n"
#~ "\n"
#~ "        tokio::spawn(async move {\n"
#~ "            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await "
#~ "{\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "                return;\n"
#~ "            }\n"
#~ "\n"
#~ "            let mut buf = vec![0; 1024];\n"
#~ "            let reply = match socket.read(&mut buf).await {\n"
#~ "                Ok(n) => {\n"
#~ "                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
#~ "trim();\n"
#~ "                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
#~ "                }\n"
#~ "                Err(e) => {\n"
#~ "                    println!(\"socket error: {e:?}\");\n"
#~ "                    return;\n"
#~ "                }\n"
#~ "            };\n"
#~ "\n"
#~ "            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "            }\n"
#~ "        });\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
#~ "use tokio::net::TcpListener;\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() -> io::Result<()> {\n"
#~ "    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
#~ "\tprintln!(\"listening on port 6142\");\n"
#~ "\n"
#~ "    loop {\n"
#~ "        let (mut socket, addr) = listener.accept().await?;\n"
#~ "\n"
#~ "        println!(\"connection from {addr:?}\");\n"
#~ "\n"
#~ "        tokio::spawn(async move {\n"
#~ "            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await "
#~ "{\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "                return;\n"
#~ "            }\n"
#~ "\n"
#~ "            let mut buf = vec![0; 1024];\n"
#~ "            let reply = match socket.read(&mut buf).await {\n"
#~ "                Ok(n) => {\n"
#~ "                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
#~ "trim();\n"
#~ "                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
#~ "                }\n"
#~ "                Err(e) => {\n"
#~ "                    println!(\"socket error: {e:?}\");\n"
#~ "                    return;\n"
#~ "                }\n"
#~ "            };\n"
#~ "\n"
#~ "            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
#~ "                println!(\"socket error: {e:?}\");\n"
#~ "            }\n"
#~ "        });\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "\n"
#~ "async fn ping_handler(mut input: Receiver<()>) {\n"
#~ "    let mut count: usize = 0;\n"
#~ "\n"
#~ "    while let Some(_) = input.recv().await {\n"
#~ "        count += 1;\n"
#~ "        println!(\"Received {count} pings so far.\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"ping_handler complete\");\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (sender, receiver) = mpsc::channel(32);\n"
#~ "    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
#~ "    for i in 0..10 {\n"
#~ "        sender.send(()).await.expect(\"Failed to send ping.\");\n"
#~ "        println!(\"Sent {} pings so far.\", i + 1);\n"
#~ "    }\n"
#~ "\n"
#~ "    drop(sender);\n"
#~ "    ping_handler_task.await.expect(\"Something went wrong in ping handler "
#~ "task.\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "\n"
#~ "async fn ping_handler(mut input: Receiver<()>) {\n"
#~ "    let mut count: usize = 0;\n"
#~ "\n"
#~ "    while let Some(_) = input.recv().await {\n"
#~ "        count += 1;\n"
#~ "        println!(\"Received {count} pings so far.\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"ping_handler complete\");\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (sender, receiver) = mpsc::channel(32);\n"
#~ "    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
#~ "    for i in 0..10 {\n"
#~ "        sender.send(()).await.expect(\"Failed to send ping.\");\n"
#~ "        println!(\"Sent {} pings so far.\", i + 1);\n"
#~ "    }\n"
#~ "\n"
#~ "    std::mem::drop(sender);\n"
#~ "    ping_handler_task.await.expect(\"Something went wrong in ping handler "
#~ "task.\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use anyhow::Result;\n"
#~ "use futures::future;\n"
#~ "use reqwest;\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "async fn size_of_page(url: &str) -> Result<usize> {\n"
#~ "    let resp = reqwest::get(url).await?;\n"
#~ "    Ok(resp.text().await?.len())\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let urls: [&str; 4] = [\n"
#~ "        \"https://google.com\",\n"
#~ "        \"https://httpbin.org/ip\",\n"
#~ "        \"https://play.rust-lang.org/\",\n"
#~ "        \"BAD_URL\",\n"
#~ "    ];\n"
#~ "    let futures_iter = urls.into_iter().map(size_of_page);\n"
#~ "    let results = future::join_all(futures_iter).await;\n"
#~ "    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
#~ "        urls.into_iter().zip(results.into_iter()).collect();\n"
#~ "    println!(\"{:?}\", page_sizes_dict);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use anyhow::Result;\n"
#~ "use futures::future;\n"
#~ "use reqwest;\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "async fn size_of_page(url: &str) -> Result<usize> {\n"
#~ "    let resp = reqwest::get(url).await?;\n"
#~ "    Ok(resp.text().await?.len())\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let urls: [&str; 4] = [\n"
#~ "        \"https://google.com\",\n"
#~ "        \"https://httpbin.org/ip\",\n"
#~ "        \"https://play.rust-lang.org/\",\n"
#~ "        \"BAD_URL\",\n"
#~ "    ];\n"
#~ "    let futures_iter = urls.into_iter().map(size_of_page);\n"
#~ "    let results = future::join_all(futures_iter).await;\n"
#~ "    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
#~ "        urls.into_iter().zip(results.into_iter()).collect();\n"
#~ "    println!(\"{:?}\", page_sizes_dict);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[derive(Debug, PartialEq)]\n"
#~ "enum Animal {\n"
#~ "    Cat { name: String },\n"
#~ "    Dog { name: String },\n"
#~ "}\n"
#~ "\n"
#~ "async fn first_animal_to_finish_race(\n"
#~ "    mut cat_rcv: Receiver<String>,\n"
#~ "    mut dog_rcv: Receiver<String>,\n"
#~ ") -> Option<Animal> {\n"
#~ "    tokio::select! {\n"
#~ "        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: "
#~ "cat_name? }),\n"
#~ "        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: "
#~ "dog_name? })\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
#~ "    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(500)).await;\n"
#~ "        cat_sender\n"
#~ "            .send(String::from(\"Felix\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send cat.\");\n"
#~ "    });\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(50)).await;\n"
#~ "        dog_sender\n"
#~ "            .send(String::from(\"Rex\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send dog.\");\n"
#~ "    });\n"
#~ "\n"
#~ "    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
#~ "        .await\n"
#~ "        .expect(\"Failed to receive winner\");\n"
#~ "\n"
#~ "    println!(\"Winner is {winner:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::mpsc::{self, Receiver};\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[derive(Debug, PartialEq)]\n"
#~ "enum Animal {\n"
#~ "    Cat { name: String },\n"
#~ "    Dog { name: String },\n"
#~ "}\n"
#~ "\n"
#~ "async fn first_animal_to_finish_race(\n"
#~ "    mut cat_rcv: Receiver<String>,\n"
#~ "    mut dog_rcv: Receiver<String>,\n"
#~ ") -> Option<Animal> {\n"
#~ "    tokio::select! {\n"
#~ "        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: "
#~ "cat_name? }),\n"
#~ "        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: "
#~ "dog_name? })\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
#~ "    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(500)).await;\n"
#~ "        cat_sender\n"
#~ "            .send(String::from(\"Felix\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send cat.\");\n"
#~ "    });\n"
#~ "    tokio::spawn(async move {\n"
#~ "        sleep(Duration::from_millis(50)).await;\n"
#~ "        dog_sender\n"
#~ "            .send(String::from(\"Rex\"))\n"
#~ "            .await\n"
#~ "            .expect(\"Failed to send dog.\");\n"
#~ "    });\n"
#~ "\n"
#~ "    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
#~ "        .await\n"
#~ "        .expect(\"Failed to receive winner\");\n"
#~ "\n"
#~ "    println!(\"Winner is {winner:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::future::join_all;\n"
#~ "use std::time::Instant;\n"
#~ "\n"
#~ "async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
#~ "    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
#~ "    println!(\n"
#~ "        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
#~ "        start.elapsed().as_millis()\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main(flavor = \"current_thread\")]\n"
#~ "async fn main() {\n"
#~ "    let start = Instant::now();\n"
#~ "    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
#~ "    join_all(sleep_futures).await;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use futures::future::join_all;\n"
#~ "use std::time::Instant;\n"
#~ "\n"
#~ "async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
#~ "    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
#~ "    println!(\n"
#~ "        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
#~ "        start.elapsed().as_millis()\n"
#~ "    );\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main(flavor = \"current_thread\")]\n"
#~ "async fn main() {\n"
#~ "    let start = Instant::now();\n"
#~ "    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
#~ "    join_all(sleep_futures).await;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::{mpsc, oneshot};\n"
#~ "use tokio::task::spawn;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "// A work item. In this case, just sleep for the given time and respond\n"
#~ "// with a message on the `respond_on` channel.\n"
#~ "#[derive(Debug)]\n"
#~ "struct Work {\n"
#~ "    input: u32,\n"
#~ "    respond_on: oneshot::Sender<u32>,\n"
#~ "}\n"
#~ "\n"
#~ "// A worker which listens for work on a queue and performs it.\n"
#~ "async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
#~ "    let mut iterations = 0;\n"
#~ "    loop {\n"
#~ "        tokio::select! {\n"
#~ "            Some(work) = work_queue.recv() => {\n"
#~ "                sleep(Duration::from_millis(10)).await; // Pretend to "
#~ "work.\n"
#~ "                work.respond_on\n"
#~ "                    .send(work.input * 1000)\n"
#~ "                    .expect(\"failed to send response\");\n"
#~ "                iterations += 1;\n"
#~ "            }\n"
#~ "            // TODO: report number of iterations every 100ms\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// A requester which requests work and waits for it to complete.\n"
#~ "async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
#~ "    let (tx, rx) = oneshot::channel();\n"
#~ "    work_queue\n"
#~ "        .send(Work {\n"
#~ "            input,\n"
#~ "            respond_on: tx,\n"
#~ "        })\n"
#~ "        .await\n"
#~ "        .expect(\"failed to send on work queue\");\n"
#~ "    rx.await.expect(\"failed waiting for response\")\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel(10);\n"
#~ "    spawn(worker(rx));\n"
#~ "    for i in 0..100 {\n"
#~ "        let resp = do_work(&tx, i).await;\n"
#~ "        println!(\"work result for iteration {i}: {resp}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use tokio::sync::{mpsc, oneshot};\n"
#~ "use tokio::task::spawn;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "// ì‘ì—… í•­ëª©. ì´ ê²½ìš° ì§€ì •ëœ ì‹œê°„ ë™ì•ˆ ì ˆì „ ëª¨ë“œë¡œ ìˆë‹¤ê°€\n"
#~ "// `respond_on` ì±„ë„ì˜ ë©”ì‹œì§€ë¡œ ì‘ë‹µí•©ë‹ˆë‹¤.\n"
#~ "#[derive(Debug)]\n"
#~ "struct Work {\n"
#~ "    input: u32,\n"
#~ "    respond_on: oneshot::Sender<u32>,\n"
#~ "}\n"
#~ "\n"
#~ "// ëŒ€ê¸°ì—´ì—ì„œ ì‘ì—…ì„ ë¦¬ìŠ¨í•˜ê³  ì‹¤í–‰í•˜ëŠ” workerì…ë‹ˆë‹¤.\n"
#~ "async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
#~ "    let mut iterations = 0;\n"
#~ "    loop {\n"
#~ "        tokio::select! {\n"
#~ "            Some(work) = work_queue.recv() => {\n"
#~ "                sleep(Duration::from_millis(10)).await; // Pretend to "
#~ "work.\n"
#~ "                work.respond_on\n"
#~ "                    .send(work.input * 1000)\n"
#~ "                    .expect(\"failed to send response\");\n"
#~ "                iterations += 1;\n"
#~ "            }\n"
#~ "            // TODO: 100msë§ˆë‹¤ ë°˜ë³µ íšŸìˆ˜ë¥¼ ë³´ê³ í•©ë‹ˆë‹¤.\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// ì‘ì—…ì„ ìš”ì²­í•˜ê³  ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ìš”ì²­ìì…ë‹ˆë‹¤.\n"
#~ "async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
#~ "    let (tx, rx) = oneshot::channel();\n"
#~ "    work_queue\n"
#~ "        .send(Work {\n"
#~ "            input,\n"
#~ "            respond_on: tx,\n"
#~ "        })\n"
#~ "        .await\n"
#~ "        .expect(\"failed to send on work queue\");\n"
#~ "    rx.await.expect(\"failed waiting for response\")\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel(10);\n"
#~ "    spawn(worker(rx));\n"
#~ "    for i in 0..100 {\n"
#~ "        let resp = do_work(&tx, i).await;\n"
#~ "        println!(\"work result for iteration {i}: {resp}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = sleep(Duration::from_millis(100));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = sleep(Duration::from_millis(100));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = &mut timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
#~ "loop {\n"
#~ "    select! {\n"
#~ "        ..,\n"
#~ "        _ = &mut timeout_fut => { println!(..); },\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use async_trait::async_trait;\n"
#~ "use std::time::Instant;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "trait Sleeper {\n"
#~ "    async fn sleep(&self);\n"
#~ "}\n"
#~ "\n"
#~ "struct FixedSleeper {\n"
#~ "    sleep_ms: u64,\n"
#~ "}\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "impl Sleeper for FixedSleeper {\n"
#~ "    async fn sleep(&self) {\n"
#~ "        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
#~ "n_times: usize) {\n"
#~ "    for _ in 0..n_times {\n"
#~ "        println!(\"running all sleepers..\");\n"
#~ "        for sleeper in &sleepers {\n"
#~ "            let start = Instant::now();\n"
#~ "            sleeper.sleep().await;\n"
#~ "            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
#~ "    ];\n"
#~ "    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use async_trait::async_trait;\n"
#~ "use std::time::Instant;\n"
#~ "use tokio::time::{sleep, Duration};\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "trait Sleeper {\n"
#~ "    async fn sleep(&self);\n"
#~ "}\n"
#~ "\n"
#~ "struct FixedSleeper {\n"
#~ "    sleep_ms: u64,\n"
#~ "}\n"
#~ "\n"
#~ "#[async_trait]\n"
#~ "impl Sleeper for FixedSleeper {\n"
#~ "    async fn sleep(&self) {\n"
#~ "        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
#~ "n_times: usize) {\n"
#~ "    for _ in 0..n_times {\n"
#~ "        println!(\"running all sleepers..\");\n"
#~ "        for sleeper in &sleepers {\n"
#~ "            let start = Instant::now();\n"
#~ "            sleeper.sleep().await;\n"
#~ "            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[tokio::main]\n"
#~ "async fn main() {\n"
#~ "    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
#~ "        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
#~ "    ];\n"
#~ "    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo run --bin server\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```shell\n"
#~ "cargo run --bin client\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo embed --bin pac\n"
#~ "```"

#~ msgid "You will find solutions to the exercises on the following pages."
#~ msgstr "ì—°ìŠµë¬¸ì œì˜ í•´ë‹µì€ ë‹¤ìŒ í˜ì´ì§€ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Feel free to ask questions about the solutions [on GitHub](https://github."
#~ "com/google/comprehensive-rust/discussions). Let us know if you have a "
#~ "different or better solution than what is presented here."
#~ msgstr ""
#~ "[ê¹ƒí—ˆë¸Œ](https://github.com/google/comprehensive-rust/discussions)ì—ì„œ ì´"
#~ "ì— ëŒ€í•´ ììœ ë¡­ê²Œ ì§ˆë¬¸í•˜ì‹œê³  ë” ë‚˜ì€ ì†”ë£¨ì…˜ì´ ìˆë‹¤ë©´ ì•Œë ¤ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤."

#~ msgid ""
#~ "**Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label` "
#~ "comments you see in the solutions. They are there to make it possible to "
#~ "re-use parts of the solutions as the exercises."
#~ msgstr ""
#~ "**ì°¸ê³ :** `// ANCHOR: label`ê³¼ `// ANCHOR_END: label` ì£¼ì„ì€ ë¬¸ì œë¥¼ êµ¬ì„±í•˜"
#~ "ê¸° ìœ„í•œ ë©”íƒ€ ì£¼ì„ìœ¼ë¡œ ë¬´ì‹œí•˜ì‹œë©´ ë©ë‹ˆë‹¤."

#~ msgid "Day 1 Morning Exercises"
#~ msgstr "1ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#~ msgid "Bonus question"
#~ msgstr "ë³´ë„ˆìŠ¤ ë¬¸ì œ"

#~ msgid ""
#~ "It requires more advanced concepts. It might seem that we could use a "
#~ "slice-of-slices (`&[&[i32]]`) as the input type to transpose and thus "
#~ "make our function handle any size of matrix. However, this quickly breaks "
#~ "down: the return type cannot be `&[&[i32]]` since it needs to own the "
#~ "data you return."
#~ msgstr ""
#~ "ì‚¬ì‹¤ ì´ ë¬¸ì œëŠ” ê³ ê¸‰ ê°œë…ì´ í•„ìš”í•©ë‹ˆë‹¤. ìŠ¬ë¼ì´ìŠ¤ì˜ ìŠ¬ë¼ì´ìŠ¤(slice-of-"
#~ "slices, `&[&[i32]]`)ë¥¼ ì…ë ¥ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ëª¨ë“  í¬ê¸°ì˜ í–‰ë ¬ì„ ì²˜ë¦¬í•  "
#~ "ìˆ˜ ìˆì„ê²ƒ ê°™ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì œë¡œ í•´ë³´ë©´ ê¸ˆë°© ì•ˆëœë‹¤ëŠ” ê±¸ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
#~ "ë°˜í™˜ê°’ì„ ì†Œìœ í•´ì•¼ í•˜ê¸°ë•Œë¬¸ì— `&[&[i32]]` ë°˜í™˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't "
#~ "work out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
#~ "`&[&[i32]]` so now you cannot easily use `pretty_print` either."
#~ msgstr ""
#~ "`Vec<Vec<i32>>`ì™€ ê°™ì€ íƒ€ì…ì„ ì‚¬ìš©í•˜ë ¤ê³  ì‹œë„í•  ìˆ˜ë„ ìˆì§€ë§Œ ì—­ì‹œ ì‰½ê²Œ ë˜"
#~ "ì§„ ì•ŠìŠµë‹ˆë‹¤. `Vec<Vec<i32>>` íƒ€ì…ì„ `&[&[i32]]`ë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì´ ì–´ë µê¸° ë•Œ"
#~ "ë¬¸ì— `pretty_print`ì„ ì‚¬ìš©í•˜ëŠ”ë° ì–´ë ¤ì›€ì´ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "Once we get to traits and generics, we'll be able to use the [`std::"
#~ "convert::AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) "
#~ "trait to abstract over anything that can be referenced as a slice."
#~ msgstr ""
#~ "íŠ¸ë ˆì‡ë‚˜ ì œë„¤ë¦­ì„ ë‹¤ë£¨ê³  ë‚˜ë©´ [`std::convert::AsRef`](https://doc.rust-"
#~ "lang.org/std/convert/trait.AsRef.html) íŠ¸ë ˆì‡ì„ ì‚¬ìš©í•˜ì—¬ ìŠ¬ë¼ì´ìŠ¤ì²˜ëŸ¼ ì‚¬ìš©"
#~ "ë  ìˆ˜ ìˆëŠ” íƒ€ì…ì„ ì¶”ìƒí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid ""
#~ "In addition, the type itself would not enforce that the child slices are "
#~ "of the same length, so such variable could contain an invalid matrix."
#~ msgstr ""
#~ "ë˜í•œ, ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…ì€ ê¸¸ì´ë¥¼ í¬í•¨í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— í•œ ë‹¨ê³„ ì•„ë˜ì˜ ìŠ¬ë¼ì´ìŠ¤"
#~ "ë“¤ì´ ê°™ì€ ê¸¸ì´ì„ì„ ë³´ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë•Œë¬¸ì— ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…ì˜ ë³€ìˆ˜ì—ëŠ” ì˜"
#~ "ëª»ëœ í–‰ë ¬ì´ ì „ë‹¬ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#~ msgid "Day 1 Afternoon Exercises"
#~ msgstr "1ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#~ msgid "Designing a Library"
#~ msgstr "ë„ì„œê´€ ì„¤ê³„"

#~ msgid "Day 2 Morning Exercises"
#~ msgstr "2ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#~ msgid "Day 2 Afternoon Exercises"
#~ msgstr "2ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"

#~ msgid "Day 3 Morning Exercise"
#~ msgstr "3ì¼ì°¨ ì˜¤ì „ ì—°ìŠµë¬¸ì œ"

#~ msgid "Day 3 Afternoon Exercises"
#~ msgstr "3ì¼ì°¨ ì˜¤í›„ ì—°ìŠµë¬¸ì œ"
