msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust ğŸ¦€\n"
"POT-Creation-Date: 2023-08-26\n"
"PO-Revision-Date: 2023-08-25 13:24-0700\n"
"Last-Translator: root <andrikopoulos@google.com>\n"
"Language-Team: Greek <team@lists.gnome.gr>\n"
"Language: el\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:4 src/index.md:1
msgid "Welcome to Comprehensive Rust ğŸ¦€"
msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Comprehensive Rust ğŸ¦€"

#: src/SUMMARY.md:5 src/running-the-course.md:1
msgid "Running the Course"
msgstr "Î”Î¹ÎµÎ¾Î±Î³Ï‰Î³Î® Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚"

#: src/SUMMARY.md:6 src/running-the-course/course-structure.md:1
msgid "Course Structure"
msgstr "Î”Î¿Î¼Î® ÎœÎ±Î¸Î®Î¼Î±Ï„Î¿Ï‚"

#: src/SUMMARY.md:7 src/running-the-course/keyboard-shortcuts.md:1
msgid "Keyboard Shortcuts"
msgstr "Î£Ï…Î½Ï„Î¿Î¼ÎµÏÏƒÎµÎ¹Ï‚ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»Î¿Î³Î¯Î¿Ï…"

#: src/SUMMARY.md:8 src/running-the-course/translations.md:1
msgid "Translations"
msgstr "ÎœÎµÏ„Î±Ï†ÏÎ¬ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:9 src/cargo.md:1
msgid "Using Cargo"
msgstr "Î§ÏÎ®ÏƒÎ· Cargo"

#: src/SUMMARY.md:10
msgid "Rust Ecosystem"
msgstr "Rust ÎŸÎ¹ÎºÎ¿ÏƒÏÏƒÏ„Î·Î¼Î±"

#: src/SUMMARY.md:11
msgid "Code Samples"
msgstr "Î”ÎµÎ¯Î³Î¼Î±Ï„Î± ÎºÏÎ´Î¹ÎºÎ±"

#: src/SUMMARY.md:12
msgid "Running Cargo Locally"
msgstr "Î•ÎºÏ„Î­Î»ÎµÏƒÎ· Cargo Ï„Î¿Ï€Î¹ÎºÎ¬"

#: src/SUMMARY.md:15
msgid "Day 1: Morning"
msgstr "1Î· Î¼Î­ÏÎ±: Î ÏÏ‰Î¯"

#: src/SUMMARY.md:19 src/SUMMARY.md:79 src/SUMMARY.md:137 src/SUMMARY.md:195
#: src/SUMMARY.md:221 src/SUMMARY.md:271
msgid "Welcome"
msgstr "ÎšÎ±Î»Ï‰Ï‚ Î‰ÏÎ¸Î±Ï„Îµ"

#: src/SUMMARY.md:20 src/welcome-day-1/what-is-rust.md:1
msgid "What is Rust?"
msgstr "Î¤Î¹ ÎµÎ¯Î½Î±Î¹ Î· Rust;"

#: src/SUMMARY.md:21 src/hello-world.md:1
msgid "Hello World!"
msgstr "Î“ÎµÎ¹Î¬ ÏƒÎ¿Ï… ÎšÏŒÏƒÎ¼Îµ!"

#: src/SUMMARY.md:22 src/hello-world/small-example.md:1
msgid "Small Example"
msgstr "ÎœÎ¹ÎºÏÏŒ Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±"

#: src/SUMMARY.md:23 src/why-rust.md:1
msgid "Why Rust?"
msgstr "Î“Î¹Î±Ï„Î¯ Rust;"

#: src/SUMMARY.md:24 src/why-rust/compile-time.md:1
msgid "Compile Time Guarantees"
msgstr "Î•Î³Î³Ï…Î®ÏƒÎµÎ¹Ï‚ Î§ÏÏŒÎ½Î¿Ï… ÎœÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚"

#: src/SUMMARY.md:25 src/why-rust/runtime.md:1
msgid "Runtime Guarantees"
msgstr "Î•Î³Î³Ï…Î®ÏƒÎµÎ¹Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚"

#: src/SUMMARY.md:26 src/why-rust/modern.md:1
msgid "Modern Features"
msgstr "Î£ÏÎ³Ï‡ÏÎ¿Î½Î± Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/SUMMARY.md:27 src/basic-syntax.md:1
msgid "Basic Syntax"
msgstr "Î’Î±ÏƒÎ¹ÎºÎ® Î£ÏÎ½Ï„Î±Î¾Î·"

#: src/SUMMARY.md:28 src/basic-syntax/scalar-types.md:1
msgid "Scalar Types"
msgstr "Î’Î±Î¸Î¼Ï‰Ï„Î¿Î¯ Î¤ÏÏ€Î¿Î¹"

#: src/SUMMARY.md:29 src/basic-syntax/compound-types.md:1
msgid "Compound Types"
msgstr "Î£ÏÎ½Î¸ÎµÏ„Î¿Î¹ Ï„ÏÏ€Î¿Î¹"

#: src/SUMMARY.md:30 src/basic-syntax/references.md:1
msgid "References"
msgstr "Î‘Î½Î±Ï†Î¿ÏÎ­Ï‚"

#: src/SUMMARY.md:31 src/basic-syntax/references-dangling.md:1
msgid "Dangling References"
msgstr "ÎšÏÎµÎ¼Î±ÏƒÎ¼Î­Î½ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚"

#: src/SUMMARY.md:32 src/basic-syntax/slices.md:1
msgid "Slices"
msgstr "Î¦Î­Ï„ÎµÏ‚"

#: src/SUMMARY.md:33
msgid "String vs str"
msgstr "String vs str"

#: src/SUMMARY.md:34 src/basic-syntax/functions.md:1
msgid "Functions"
msgstr "Î£Ï…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:35 src/basic-syntax/rustdoc.md:1
#, fuzzy
msgid "Rustdoc"
msgstr "Î“Î¹Î±Ï„Î¯ Rust;"

#: src/SUMMARY.md:36 src/SUMMARY.md:107 src/basic-syntax/methods.md:1
#: src/methods.md:1
msgid "Methods"
msgstr "ÎœÎ­Î¸Î¿Î´Î¿Î¹"

#: src/SUMMARY.md:37
msgid "Overloading"
msgstr "Î¥Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ·"

#: src/SUMMARY.md:38 src/SUMMARY.md:71 src/SUMMARY.md:100 src/SUMMARY.md:110
#: src/SUMMARY.md:129 src/SUMMARY.md:157 src/SUMMARY.md:187 src/SUMMARY.md:214
#: src/SUMMARY.md:235 src/SUMMARY.md:263 src/SUMMARY.md:285 src/SUMMARY.md:306
#: src/exercises/android/morning.md:1 src/exercises/bare-metal/morning.md:1
#: src/exercises/bare-metal/afternoon.md:1
#: src/exercises/concurrency/morning.md:1
#: src/exercises/concurrency/afternoon.md:1
msgid "Exercises"
msgstr "Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:39 src/exercises/day-1/implicit-conversions.md:1
msgid "Implicit Conversions"
msgstr "ÎˆÎ¼Î¼ÎµÏƒÎµÏ‚ Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î­Ï‚"

#: src/SUMMARY.md:40
msgid "Arrays and for Loops"
msgstr "Î Î¯Î½Î±ÎºÎµÏ‚ ÎºÎ±Î¹ Î²ÏÏŒÏ‡Î¿Î¹ for"

#: src/SUMMARY.md:42
msgid "Day 1: Afternoon"
msgstr "1Î· Î¼Î­ÏÎ±: Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:44 src/SUMMARY.md:298 src/control-flow.md:1
msgid "Control Flow"
msgstr "Î¡Î¿Î® ÎµÎ»Î­Î³Ï‡Î¿Ï…"

#: src/SUMMARY.md:45 src/control-flow/blocks.md:1
msgid "Blocks"
msgstr "ÎœÏ€Î»Î¿Îº"

#: src/SUMMARY.md:46
msgid "if expressions"
msgstr "EÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ if"

#: src/SUMMARY.md:47
msgid "for expressions"
msgstr "Î•ÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ for"

#: src/SUMMARY.md:48
msgid "while expressions"
msgstr "Î•ÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ while"

#: src/SUMMARY.md:49
msgid "break & continue"
msgstr "break & continue"

#: src/SUMMARY.md:50
msgid "loop expressions"
msgstr "Î•ÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ loop"

#: src/SUMMARY.md:52 src/basic-syntax/variables.md:1
msgid "Variables"
msgstr "ÎœÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚"

#: src/SUMMARY.md:53 src/basic-syntax/type-inference.md:1
msgid "Type Inference"
msgstr "Î£Ï…Î¼Ï€ÎµÏÎ±ÏƒÎ¼ÏŒÏ‚ Î¤ÏÏ€Ï‰Î½"

#: src/SUMMARY.md:54
msgid "static & const"
msgstr "static & const"

#: src/SUMMARY.md:55 src/basic-syntax/scopes-shadowing.md:1
msgid "Scopes and Shadowing"
msgstr "Î•Î¼Î²Î­Î»Î¹Î± ÎºÎ±Î¹ ÏƒÎºÎ¯Î±ÏƒÎ·"

#: src/SUMMARY.md:56 src/enums.md:1
msgid "Enums"
msgstr "Î‘Ï€Î±ÏÎ¹Î¸Î¼Î®ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:57 src/enums/variant-payloads.md:1
msgid "Variant Payloads"
msgstr "Î ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ Î Î±ÏÎ±Î»Î»Î±Î³ÏÎ½"

#: src/SUMMARY.md:58 src/enums/sizes.md:1
msgid "Enum Sizes"
msgstr "ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ Î‘Ï€Î±ÏÎ¹Î¸Î¼Î®ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:60 src/control-flow/novel.md:1
#, fuzzy
msgid "Novel Control Flow"
msgstr "Î¡Î¿Î® ÎµÎ»Î­Î³Ï‡Î¿Ï…"

#: src/SUMMARY.md:61
msgid "if let expressions"
msgstr "Î•ÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ if let"

#: src/SUMMARY.md:62
msgid "while let expressions"
msgstr "Î•ÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ while let"

#: src/SUMMARY.md:63
msgid "match expressions"
msgstr "Î•ÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ match"

#: src/SUMMARY.md:65 src/pattern-matching.md:1
msgid "Pattern Matching"
msgstr "Î‘Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Ï€ÏÎ¿Ï„ÏÏ€Ï‰Î½"

#: src/SUMMARY.md:66 src/pattern-matching/destructuring-enums.md:1
msgid "Destructuring Enums"
msgstr "Î‘Ï€Î¿Î´ÏŒÎ¼Î·ÏƒÎ· Î‘Ï€Î±ÏÎ¹Î¸Î¼Î®ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:67 src/pattern-matching/destructuring-structs.md:1
msgid "Destructuring Structs"
msgstr "Î‘Ï€Î¿Î´ÏŒÎ¼Î·ÏƒÎ· Î”Î¿Î¼ÏÎ½"

#: src/SUMMARY.md:68 src/pattern-matching/destructuring-arrays.md:1
msgid "Destructuring Arrays"
msgstr "Î‘Ï€Î¿Î´ÏŒÎ¼Î·ÏƒÎ· Î Î¹Î½Î¬ÎºÏ‰Î½"

#: src/SUMMARY.md:69 src/pattern-matching/match-guards.md:1
msgid "Match Guards"
msgstr "Î¦ÏÎ»Î±ÎºÎµÏ‚ Î‘Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:72 src/exercises/day-1/luhn.md:1
#: src/exercises/day-1/solutions-afternoon.md:3
msgid "Luhn Algorithm"
msgstr "Î‘Î»Î³ÏŒÏÎ¹Î¸Î¼Î¿Ï‚ Luhn"

#: src/SUMMARY.md:73
#, fuzzy
msgid "Pattern Matching (TBD)"
msgstr "Î‘Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Ï€ÏÎ¿Ï„ÏÏ€Ï‰Î½"

#: src/SUMMARY.md:75
msgid "Day 2: Morning"
msgstr "2Î· Î¼Î­ÏÎ±: Î ÏÏ‰Î¯"

#: src/SUMMARY.md:81 src/memory-management.md:1
msgid "Memory Management"
msgstr "Î”Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚"

#: src/SUMMARY.md:82
msgid "Stack vs Heap"
msgstr "Î£Ï„Î¿Î¯Î²Î± ÎºÎ±Î¹ Î£Ï‰ÏÏŒÏ‚"

#: src/SUMMARY.md:83
msgid "Stack Memory"
msgstr "ÎœÎ½Î®Î¼Î· ÏƒÏ„Î¿Î¯Î²Î±Ï‚"

#: src/SUMMARY.md:84 src/memory-management/manual.md:1
msgid "Manual Memory Management"
msgstr "Î§ÎµÎ¹ÏÎ¿ÎºÎ¯Î½Î·Ï„Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚"

#: src/SUMMARY.md:85 src/memory-management/scope-based.md:1
msgid "Scope-Based Memory Management"
msgstr "Î”Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚ Î²Î¬ÏƒÎµÎ¹ ÎµÎ¼Î²Î­Î»Î¹Î±Ï‚"

#: src/SUMMARY.md:86
msgid "Garbage Collection"
msgstr "Î£Ï…Î»Î»Î¿Î³Î® ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¹ÏÎ½"

#: src/SUMMARY.md:87
msgid "Rust Memory Management"
msgstr "Î”Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚ ÏƒÏ„Î· Rust"

#: src/SUMMARY.md:88 src/memory-management/comparison.md:1
msgid "Comparison"
msgstr "Î£ÏÎ³ÎºÏÎ¹ÏƒÎ·"

#: src/SUMMARY.md:89 src/ownership.md:1
msgid "Ownership"
msgstr "Î™Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±"

#: src/SUMMARY.md:90 src/ownership/move-semantics.md:1
msgid "Move Semantics"
msgstr "Î£Î·Î¼Î±ÏƒÎ¹Î¿Î»Î¿Î³Î¯Î± Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚"

#: src/SUMMARY.md:91 src/ownership/moved-strings-rust.md:1
msgid "Moved Strings in Rust"
msgstr "ÎœÎµÏ„Î±ÎºÎ¹Î½Î·Î¼Î­Î½ÎµÏ‚ ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚ ÏƒÏ„Î· Rust"

#: src/SUMMARY.md:92
msgid "Double Frees in Modern C++"
msgstr "Î”Î¹Ï€Î»Î­Ï‚ Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏÏƒÎµÎ¹Ï‚ Î¼Î½Î®Î¼Î·Ï‚ ÏƒÏ„Î· ÏƒÏÎ³Ï‡ÏÎ¿Î½Î· C++"

#: src/SUMMARY.md:93 src/ownership/moves-function-calls.md:1
msgid "Moves in Function Calls"
msgstr "ÎœÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÎµÎ¹Ï‚ ÏƒÎµ ÎºÎ»Î®ÏƒÎµÎ¹Ï‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:94 src/ownership/copy-clone.md:1
msgid "Copying and Cloning"
msgstr "Î‘Î½Ï„Î¹Î³ÏÎ±Ï†Î® ÎºÎ±Î¹ ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¯Î·ÏƒÎ·"

#: src/SUMMARY.md:95 src/ownership/borrowing.md:1
msgid "Borrowing"
msgstr "Î”Î±Î½ÎµÎ¹ÏƒÎ¼ÏŒÏ‚"

#: src/SUMMARY.md:96 src/ownership/shared-unique-borrows.md:1
msgid "Shared and Unique Borrows"
msgstr "ÎšÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î± ÎºÎ±Î¹ Î¼Î¿Î½Î±Î´Î¹ÎºÎ¬ Î´Î¬Î½ÎµÎ¹Î±"

#: src/SUMMARY.md:97 src/ownership/lifetimes.md:1
msgid "Lifetimes"
msgstr "Î”Î¹Î¬ÏÎºÎµÎ¹ÎµÏ‚"

#: src/SUMMARY.md:98 src/ownership/lifetimes-function-calls.md:1
msgid "Lifetimes in Function Calls"
msgstr "Î”Î¹Î¬ÏÎºÎµÎ¹ÎµÏ‚ ÏƒÎµ ÎºÎ»Î®ÏƒÎµÎ¹Ï‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:99 src/ownership/lifetimes-data-structures.md:1
msgid "Lifetimes in Data Structures"
msgstr "Î”Î¹Î¬ÏÎºÎµÎ¹ÎµÏ‚ Î¶Ï‰Î®Ï‚ ÏƒÎµ Î´Î¿Î¼Î­Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½"

#: src/SUMMARY.md:101 src/exercises/day-2/book-library.md:1
#, fuzzy
msgid "Storing Books"
msgstr "Î£Ï…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚"

#: src/SUMMARY.md:102 src/exercises/day-2/iterators-and-ownership.md:1
msgid "Iterators and Ownership"
msgstr "Iterators ÎºÎ±Î¹ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±"

#: src/SUMMARY.md:104 src/structs.md:1
msgid "Structs"
msgstr "Î”Î¿Î¼Î­Ï‚"

#: src/SUMMARY.md:105 src/structs/tuple-structs.md:1
msgid "Tuple Structs"
msgstr "Î”Î¿Î¼Î­Ï‚ Î¤Î¿ÏÏ€Î»Î±Ï‚"

#: src/SUMMARY.md:106 src/structs/field-shorthand.md:1
msgid "Field Shorthand Syntax"
msgstr "Î£Ï…Î½Ï„Î¿Î¼ÎµÏ…Î¼Î­Î½Î¿ ÏƒÏ…Î½Ï„Î±ÎºÏ„Î¹ÎºÏŒ Ï€ÎµÎ´Î¯Ï‰Î½"

#: src/SUMMARY.md:108 src/methods/receiver.md:1
msgid "Method Receiver"
msgstr "Î”Î­ÎºÏ„Î·Ï‚ ÎœÎµÎ¸ÏŒÎ´Ï‰Î½"

#: src/SUMMARY.md:109 src/SUMMARY.md:169 src/SUMMARY.md:284
#: src/methods/example.md:1 src/concurrency/shared_state/example.md:1
msgid "Example"
msgstr "Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±"

#: src/SUMMARY.md:111 src/exercises/day-2/health-statistics.md:1
msgid "Health Statistics"
msgstr "Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬ Î¥Î³ÎµÎ¯Î±Ï‚"

#: src/SUMMARY.md:113
msgid "Day 2: Afternoon"
msgstr "2Î· Î¼Î­ÏÎ±: Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:115 src/std.md:1
msgid "Standard Library"
msgstr "Î£Ï„Î¬Î½Ï„Î±Ï Î’Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·"

#: src/SUMMARY.md:116
msgid "Option and Result"
msgstr "Option ÎºÎ±Î¹ Result"

#: src/SUMMARY.md:117 src/std/string.md:1
msgid "String"
msgstr "Î£Ï…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚"

#: src/SUMMARY.md:118
msgid "Vec"
msgstr "Vec"

#: src/SUMMARY.md:119
msgid "HashMap"
msgstr "HashMap"

#: src/SUMMARY.md:120
msgid "Box"
msgstr "Box"

#: src/SUMMARY.md:121
msgid "Recursive Data Types"
msgstr "Î‘Î½Î±Î´ÏÎ¿Î¼Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½"

#: src/SUMMARY.md:122 src/std/box-niche.md:1
msgid "Niche Optimization"
msgstr "Î•Î¾ÎµÎ¹Î´Î¹ÎºÎµÏ…Î¼Î­Î½Î· Î’ÎµÎ»Ï„Î¹ÏƒÏ„Î¿Ï€Î¿Î¯Î·ÏƒÎ·"

#: src/SUMMARY.md:123
msgid "Rc"
msgstr "Rc"

#: src/SUMMARY.md:124
msgid "Cell/RefCell"
msgstr ""

#: src/SUMMARY.md:125 src/modules.md:1
msgid "Modules"
msgstr "Î”Î¿Î¼Î¹ÎºÎ­Ï‚ ÎœÎ¿Î½Î¬Î´ÎµÏ‚"

#: src/SUMMARY.md:126 src/modules/visibility.md:1
msgid "Visibility"
msgstr "ÎŸÏÎ±Ï„ÏŒÏ„Î·Ï„Î±"

#: src/SUMMARY.md:127 src/modules/paths.md:1
msgid "Paths"
msgstr "ÎœÎ¿Î½Î¿Ï€Î¬Ï„Î¹Î±"

#: src/SUMMARY.md:128 src/modules/filesystem.md:1
msgid "Filesystem Hierarchy"
msgstr "Î™ÎµÏÎ±ÏÏ‡Î¯Î± ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ Î±ÏÏ‡ÎµÎ¯Ï‰Î½"

#: src/SUMMARY.md:130 src/exercises/day-2/strings-iterators.md:1
#: src/exercises/day-2/solutions-afternoon.md:3
msgid "Strings and Iterators"
msgstr "Î£Ï…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚ ÎºÎ±Î¹ Î•Ï€Î±Î½Î±Î»Î®Ï€Ï„ÎµÏ‚"

#: src/SUMMARY.md:133
msgid "Day 3: Morning"
msgstr "3Î· Î¼Î­ÏÎ±: Î ÏÏ‰Î¯"

#: src/SUMMARY.md:138 src/generics.md:1
msgid "Generics"
msgstr "Î“ÎµÎ½Î¹ÎºÎµÏ…ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:139 src/generics/data-types.md:1
msgid "Generic Data Types"
msgstr "Î“ÎµÎ½Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½"

#: src/SUMMARY.md:140 src/generics/methods.md:1
msgid "Generic Methods"
msgstr "Î“ÎµÎ½Î¹ÎºÎ­Ï‚ ÎœÎ­Î¸Î¿Î´Î¿Î¹"

#: src/SUMMARY.md:141 src/generics/monomorphization.md:1
msgid "Monomorphization"
msgstr "ÎœÎ¿Î½Î¿Î¼Î¿ÏÏ†Î¿Ï€Î¿Î¯Î·ÏƒÎ·"

#: src/SUMMARY.md:142 src/traits.md:1
msgid "Traits"
msgstr "Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/SUMMARY.md:143 src/traits/trait-objects.md:1
msgid "Trait Objects"
msgstr "Î‘Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½"

#: src/SUMMARY.md:144 src/traits/deriving-traits.md:1
msgid "Deriving Traits"
msgstr "Î•Î¾Î¬Î³Ï‰Î½Ï„Î±Ï‚ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/SUMMARY.md:145 src/traits/default-methods.md:1
msgid "Default Methods"
msgstr "Î ÏÎ¿-Ï…Î»Î¿Ï€Î¿Î¹Î·Î¼Î­Î½ÎµÏ‚ Î¼Î­Î¸Î¿Î´Î¿Î¹"

#: src/SUMMARY.md:146 src/traits/trait-bounds.md:1
msgid "Trait Bounds"
msgstr "Î ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿Î¯ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½"

#: src/SUMMARY.md:147
msgid "impl Trait"
msgstr "impl Trait"

#: src/SUMMARY.md:148 src/traits/important-traits.md:1
msgid "Important Traits"
msgstr "Î£Î·Î¼Î±Î½Ï„Î¹ÎºÎ¬ Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/SUMMARY.md:149
msgid "Iterator"
msgstr "Iterator"

#: src/SUMMARY.md:150 src/traits/from-iterator.md:1
msgid "FromIterator"
msgstr "FromIterator"

#: src/SUMMARY.md:151
msgid "From and Into"
msgstr "From ÎºÎ±Î¹ Into"

#: src/SUMMARY.md:152
msgid "Read and Write"
msgstr "Read ÎºÎ±Î¹ Write"

#: src/SUMMARY.md:153
msgid "Drop"
msgstr "Drop"

#: src/SUMMARY.md:154
msgid "Default"
msgstr ""

#: src/SUMMARY.md:155
#, fuzzy
msgid "Operators: Add, Mul, ..."
msgstr "Add, Mul, ..."

#: src/SUMMARY.md:156
msgid "Closures: Fn, FnMut, FnOnce"
msgstr ""

#: src/SUMMARY.md:158 src/exercises/day-3/simple-gui.md:1
#: src/exercises/day-3/solutions-morning.md:3
msgid "A Simple GUI Library"
msgstr "ÎœÎ¹Î± Î±Ï€Î»Î® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· GUI"

#: src/SUMMARY.md:159 src/exercises/day-3/solutions-morning.md:175
msgid "Points and Polygons"
msgstr "Î£Î·Î¼ÎµÎ¯Î± ÎºÎ±Î¹ Î Î¿Î»ÏÎ³Ï‰Î½Î±"

#: src/SUMMARY.md:161
msgid "Day 3: Afternoon"
msgstr "3Î· Î¼Î­ÏÎ±: Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:163 src/error-handling.md:1
msgid "Error Handling"
msgstr "Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½"

#: src/SUMMARY.md:164 src/error-handling/panics.md:1
msgid "Panics"
msgstr "Î Î±Î½Î¹ÎºÎ¿Î¯"

#: src/SUMMARY.md:165
msgid "Catching Stack Unwinding"
msgstr "Î Î¹Î¬Î½Î¿Î½Ï„Î±Ï‚ Î¾ÎµÏ„Ï…Î»Î¯Î³Î¼Î±Ï„Î± ÏƒÏ„Î¿Î¯Î²Î±Ï‚"

#: src/SUMMARY.md:166
msgid "Structured Error Handling"
msgstr "Î”Î¿Î¼Î·Î¼Î­Î½Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½"

#: src/SUMMARY.md:167
msgid "Propagating Errors with ?"
msgstr "Î”Î¹Î¬Î´Î¿ÏƒÎ· ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ Î¼Îµ ?"

#: src/SUMMARY.md:168 src/error-handling/converting-error-types.md:1
#: src/error-handling/converting-error-types-example.md:1
msgid "Converting Error Types"
msgstr "ÎœÎµÏ„Î±Ï„ÏÎ¿Ï€Î® Ï„ÏÏ€Ï‰Î½ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½"

#: src/SUMMARY.md:170 src/error-handling/deriving-error-enums.md:1
msgid "Deriving Error Enums"
msgstr "Î•Î¾Î±Î³Ï‰Î³Î® Î±Ï€Î±ÏÎ¹Î¸Î¼Î®ÏƒÎµÏ‰Î½ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½"

#: src/SUMMARY.md:171 src/error-handling/dynamic-errors.md:1
msgid "Dynamic Error Types"
msgstr "Î”Ï…Î½Î±Î¼Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½"

#: src/SUMMARY.md:172 src/error-handling/error-contexts.md:1
msgid "Adding Context to Errors"
msgstr "Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· Ï€ÎµÏÎ¹ÎµÏ‡Î¿Î¼Î­Î½Î¿Ï… ÏƒÏ„Î± ÏƒÏ†Î¬Î»Î¼Î±Ï„Î±"

#: src/SUMMARY.md:173 src/testing.md:1
msgid "Testing"
msgstr "Î¤ÎµÏƒÏ„"

#: src/SUMMARY.md:174 src/testing/unit-tests.md:1
msgid "Unit Tests"
msgstr "Î¤ÎµÏƒÏ„ Î¼Î¿Î½Î¬Î´Ï‰Î½"

#: src/SUMMARY.md:175 src/testing/test-modules.md:1
msgid "Test Modules"
msgstr "Î”Î¿Î¼Î¹ÎºÎ­Ï‚ Î¼Î¿Î½Î¬Î´ÎµÏ‚ Ï„ÎµÏƒÏ„"

#: src/SUMMARY.md:176 src/testing/doc-tests.md:1
msgid "Documentation Tests"
msgstr "Î¤ÎµÏƒÏ„ Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ·Ï‚"

#: src/SUMMARY.md:177 src/testing/integration-tests.md:1
msgid "Integration Tests"
msgstr "Î¤ÎµÏƒÏ„ ÎµÎ½ÏƒÏ‰Î¼Î¬Ï„Ï‰ÏƒÎ·Ï‚"

#: src/SUMMARY.md:178 src/bare-metal/useful-crates.md:1
msgid "Useful crates"
msgstr ""

#: src/SUMMARY.md:179 src/unsafe.md:1
msgid "Unsafe Rust"
msgstr "ÎœÎ· Î±ÏƒÏ†Î±Î»Î®Ï‚ Rust"

#: src/SUMMARY.md:180 src/unsafe/raw-pointers.md:1
msgid "Dereferencing Raw Pointers"
msgstr "Î‘Ï€Î¿Î±Î½Î±Ï†Î¿ÏÎ¬ Î´ÎµÎ¹ÎºÏ„ÏÎ½"

#: src/SUMMARY.md:181 src/unsafe/mutable-static-variables.md:1
msgid "Mutable Static Variables"
msgstr "ÎœÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚"

#: src/SUMMARY.md:182 src/unsafe/unions.md:1
msgid "Unions"
msgstr "Î£Ï‰Î¼Î±Ï„ÎµÎ¯Î±"

#: src/SUMMARY.md:183 src/unsafe/calling-unsafe-functions.md:1
msgid "Calling Unsafe Functions"
msgstr "ÎšÎ»Î®ÏƒÎ· Î¼Î· Î±ÏƒÏ†Î±Î»ÏÎ½ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:184 src/unsafe/writing-unsafe-functions.md:1
msgid "Writing Unsafe Functions"
msgstr "Î¥Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î¼Î· Î±ÏƒÏ†Î±Î»ÏÎ½ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½"

#: src/SUMMARY.md:185
msgid "Extern Functions"
msgstr "Î•Î¾Ï‰Ï„ÎµÏÎ¹ÎºÎ­Ï‚ Î£Ï…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:186 src/unsafe/unsafe-traits.md:1
msgid "Implementing Unsafe Traits"
msgstr "Î¥Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î¼Î· Î±ÏƒÏ†Î±Î»ÏÎ½ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½"

#: src/SUMMARY.md:188 src/exercises/day-3/safe-ffi-wrapper.md:1
#: src/exercises/day-3/solutions-afternoon.md:3
msgid "Safe FFI Wrapper"
msgstr "Î‘ÏƒÏ†Î±Î»Î­Ï‚ Ï€ÎµÏÎ¹Ï„ÏÎ»Î¹Î³Î¼Î± FFI"

#: src/SUMMARY.md:191 src/SUMMARY.md:261 src/bare-metal/android.md:1
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md:196 src/android/setup.md:1
msgid "Setup"
msgstr "Î ÏÎ¿ÎµÏ„Î¿Î¹Î¼Î±ÏƒÎ¯Î±"

#: src/SUMMARY.md:197 src/android/build-rules.md:1
msgid "Build Rules"
msgstr "ÎšÎ±Î½ÏŒÎ½ÎµÏ‚ ÎšÎ±Ï„Î±ÏƒÎºÎµÏ…Î®Ï‚"

#: src/SUMMARY.md:198
msgid "Binary"
msgstr "Î•ÎºÏ„ÎµÎ»Î­ÏƒÎ¹Î¼Î±"

#: src/SUMMARY.md:199
msgid "Library"
msgstr "Î’Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚"

#: src/SUMMARY.md:200 src/android/aidl.md:1
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md:201
msgid "Interface"
msgstr "Î”Î¹ÎµÏ€Î±Ï†Î­Ï‚"

#: src/SUMMARY.md:202
msgid "Implementation"
msgstr "Î¥Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ·"

#: src/SUMMARY.md:203
msgid "Server"
msgstr "Î•Î¾Ï…Ï€Î·ÏÎµÏ„Î·Ï„Î®Ï‚"

#: src/SUMMARY.md:204 src/android/aidl/deploy.md:1
msgid "Deploy"
msgstr "Deploy"

#: src/SUMMARY.md:205
msgid "Client"
msgstr "Î ÎµÎ»Î¬Ï„Î·Ï‚"

#: src/SUMMARY.md:206 src/android/aidl/changing.md:1
msgid "Changing API"
msgstr "Î‘Î»Î»Î±Î³Î® API"

#: src/SUMMARY.md:207 src/SUMMARY.md:251 src/android/logging.md:1
#: src/bare-metal/aps/logging.md:1
msgid "Logging"
msgstr "ÎšÎ±Ï„Î±Î³ÏÎ±Ï†Î®"

#: src/SUMMARY.md:208 src/android/interoperability.md:1
msgid "Interoperability"
msgstr "Î”Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î±"

#: src/SUMMARY.md:209
msgid "With C"
msgstr "ÎœÎµ C"

#: src/SUMMARY.md:210
msgid "Calling C with Bindgen"
msgstr "ÎšÎ±Î»ÏÎ½Ï„Î±Ï‚ C Î¼Îµ Bindgen"

#: src/SUMMARY.md:211
msgid "Calling Rust from C"
msgstr "ÎšÎ±Î»ÏÎ½Ï„Î±Ï‚ Rust Î±Ï€ÏŒ C"

#: src/SUMMARY.md:212 src/android/interoperability/cpp.md:1
msgid "With C++"
msgstr "ÎœÎµ C++"

#: src/SUMMARY.md:213
msgid "With Java"
msgstr "ÎœÎµ Java"

#: src/SUMMARY.md:217
#, fuzzy
msgid "Bare Metal: Morning"
msgstr "Rust Ï‡Ï‰ÏÎ¯Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î±: Î ÏÏ‰Î¯;"

#: src/SUMMARY.md:222
msgid "no_std"
msgstr ""

#: src/SUMMARY.md:223
msgid "A Minimal Example"
msgstr "ÎœÎ¹ÎºÏÏŒ Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±"

#: src/SUMMARY.md:224
msgid "alloc"
msgstr ""

#: src/SUMMARY.md:225 src/bare-metal/microcontrollers.md:1
msgid "Microcontrollers"
msgstr "ÎœÎ¹ÎºÏÎ¿ÎµÏ€ÎµÎ¾ÎµÏÎ³Î±ÏƒÏ„Î­Ï‚"

#: src/SUMMARY.md:226 src/bare-metal/microcontrollers/mmio.md:1
msgid "Raw MMIO"
msgstr ""

#: src/SUMMARY.md:227
msgid "PACs"
msgstr ""

#: src/SUMMARY.md:228
msgid "HAL Crates"
msgstr ""

#: src/SUMMARY.md:229
msgid "Board Support Crates"
msgstr "Crates Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î·Ï‚ Ï€Î»Î±ÎºÎµÏ„ÏÎ½"

#: src/SUMMARY.md:230
msgid "The Type State Pattern"
msgstr "Î¤Î¿ Î¼Î¿Ï„Î¯Î²Î¿ Î¤ÏÏ€Î¿Ï… ÎšÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚"

#: src/SUMMARY.md:231
msgid "embedded-hal"
msgstr ""

#: src/SUMMARY.md:232
msgid "probe-rs, cargo-embed"
msgstr ""

#: src/SUMMARY.md:233 src/bare-metal/microcontrollers/debugging.md:1
msgid "Debugging"
msgstr "Î‘Ï€Î¿ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰ÏƒÎ·"

#: src/SUMMARY.md:234 src/SUMMARY.md:254
msgid "Other Projects"
msgstr "Î•Ï€Î¹Ï€Î»Î­Î¿Î½ Projects"

#: src/SUMMARY.md:236 src/exercises/bare-metal/compass.md:1
#: src/exercises/bare-metal/solutions-morning.md:3
msgid "Compass"
msgstr "Î Ï…Î¾Î¯Î´Î±"

#: src/SUMMARY.md:238
#, fuzzy
msgid "Bare Metal: Afternoon"
msgstr "Rust Ï‡Ï‰ÏÎ¯Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î±: Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:240
msgid "Application Processors"
msgstr ""

#: src/SUMMARY.md:241 src/bare-metal/aps/entry-point.md:1
msgid "Getting Ready to Rust"
msgstr ""

#: src/SUMMARY.md:242
msgid "Inline Assembly"
msgstr ""

#: src/SUMMARY.md:243
msgid "MMIO"
msgstr ""

#: src/SUMMARY.md:244
msgid "Let's Write a UART Driver"
msgstr "Î‘Ï‚ Î³ÏÎ¬ÏˆÎ¿Ï…Î¼Îµ Î­Î½Î±Î½ Î¿Î´Î·Î³ÏŒ UART"

#: src/SUMMARY.md:245
msgid "More Traits"
msgstr "Î•Ï€Î¹Ï€Î»Î­Î¿Î½ Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/SUMMARY.md:246
msgid "A Better UART Driver"
msgstr "ÎˆÎ½Î±Ï‚ ÎºÎ±Î»ÏÏ„ÎµÏÎ¿Ï‚ Î¿Î´Î·Î³ÏŒÏ‚ UART"

#: src/SUMMARY.md:247 src/bare-metal/aps/better-uart/bitflags.md:1
msgid "Bitflags"
msgstr ""

#: src/SUMMARY.md:248
msgid "Multiple Registers"
msgstr "Î Î¿Î»Î»Î±Ï€Î»Î¿Î¯ ÎºÎ±Ï„Î±Ï‡Ï‰ÏÎ·Ï„Î­Ï‚"

#: src/SUMMARY.md:249 src/bare-metal/aps/better-uart/driver.md:1
msgid "Driver"
msgstr "ÎŸÎ´Î·Î³ÏŒÏ‚"

#: src/SUMMARY.md:250 src/SUMMARY.md:252
#, fuzzy
msgid "Using It"
msgstr "Î§ÏÎ®ÏƒÎ·"

#: src/SUMMARY.md:253 src/bare-metal/aps/exceptions.md:1
#, fuzzy
msgid "Exceptions"
msgstr "Î£Ï…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:255
msgid "Useful Crates"
msgstr "Î§ÏÎ®ÏƒÎ¹Î¼Î± Crates"

#: src/SUMMARY.md:256
msgid "zerocopy"
msgstr ""

#: src/SUMMARY.md:257
msgid "aarch64-paging"
msgstr ""

#: src/SUMMARY.md:258
msgid "buddy_system_allocator"
msgstr ""

#: src/SUMMARY.md:259
msgid "tinyvec"
msgstr ""

#: src/SUMMARY.md:260
msgid "spin"
msgstr ""

#: src/SUMMARY.md:262 src/bare-metal/android/vmbase.md:1
msgid "vmbase"
msgstr ""

#: src/SUMMARY.md:264
msgid "RTC Driver"
msgstr "ÎŸÎ´Î·Î³ÏŒÏ‚ RTC"

#: src/SUMMARY.md:267
#, fuzzy
msgid "Concurrency: Morning"
msgstr "Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚"

#: src/SUMMARY.md:272 src/concurrency/threads.md:1
msgid "Threads"
msgstr "ÎÎ®Î¼Î±Ï„Î±"

#: src/SUMMARY.md:273 src/concurrency/scoped-threads.md:1
msgid "Scoped Threads"
msgstr "ÎÎ®Î¼Î±Ï„Î± Î¼Îµ ÎµÎ¼Î²Î­Î»ÎµÎ¹Î±"

#: src/SUMMARY.md:274 src/concurrency/channels.md:1
msgid "Channels"
msgstr "ÎšÎ±Î½Î¬Î»Î¹Î±"

#: src/SUMMARY.md:275 src/concurrency/channels/unbounded.md:1
msgid "Unbounded Channels"
msgstr "ÎšÎ±Î½Î¬Î»Î¹Î± Ï‡Ï‰ÏÎ¯Ï‚ ÎŒÏÎ¹Î±"

#: src/SUMMARY.md:276 src/concurrency/channels/bounded.md:1
msgid "Bounded Channels"
msgstr "ÎšÎ±Î½Î¬Î»Î¹Î± Î¼Îµ ÎŒÏÎ¹Î±"

#: src/SUMMARY.md:277
msgid "Send and Sync"
msgstr "Send ÎºÎ±Î¹ Sync"

#: src/SUMMARY.md:277
msgid "Send"
msgstr "Send"

#: src/SUMMARY.md:277
msgid "Sync"
msgstr "Sync"

#: src/SUMMARY.md:280 src/concurrency/send-sync/examples.md:1
msgid "Examples"
msgstr "Î Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î±"

#: src/SUMMARY.md:281 src/concurrency/shared_state.md:1
msgid "Shared State"
msgstr "ÎšÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î± Î”ÎµÎ´Î¿Î¼Î­Î½Î±"

#: src/SUMMARY.md:282
msgid "Arc"
msgstr "Arc"

#: src/SUMMARY.md:283
msgid "Mutex"
msgstr "Mutex"

#: src/SUMMARY.md:286 src/SUMMARY.md:307
#: src/exercises/concurrency/dining-philosophers.md:1
#: src/exercises/concurrency/solutions-morning.md:3
msgid "Dining Philosophers"
msgstr "Î”ÎµÎ¯Ï€Î½Î¿ Î¼Îµ Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Ï…Ï‚"

#: src/SUMMARY.md:287 src/exercises/concurrency/link-checker.md:1
msgid "Multi-threaded Link Checker"
msgstr "ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Ï‰Î½ Ï€Î¿Î»Î»Î±Ï€Î»ÏÎ½ Î½Î·Î¼Î¬Ï„Ï‰Î½"

#: src/SUMMARY.md:289
#, fuzzy
msgid "Concurrency: Afternoon"
msgstr "Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚"

#: src/SUMMARY.md:291
msgid "Async Basics"
msgstr ""

#: src/SUMMARY.md:292
msgid "async/await"
msgstr ""

#: src/SUMMARY.md:293 src/async/futures.md:1
msgid "Futures"
msgstr ""

#: src/SUMMARY.md:294 src/async/runtimes.md:1
#, fuzzy
msgid "Runtimes"
msgstr "Î•Î³Î³Ï…Î®ÏƒÎµÎ¹Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚"

#: src/SUMMARY.md:295 src/async/runtimes/tokio.md:1
msgid "Tokio"
msgstr ""

#: src/SUMMARY.md:296 src/exercises/concurrency/link-checker.md:126
#: src/async/tasks.md:1 src/exercises/concurrency/chat-app.md:140
#, fuzzy
msgid "Tasks"
msgstr "ÎšÎ±Î¸Î®ÎºÎ¿Î½Ï„Î±"

#: src/SUMMARY.md:297 src/async/channels.md:1
#, fuzzy
msgid "Async Channels"
msgstr "ÎšÎ±Î½Î¬Î»Î¹Î±"

#: src/SUMMARY.md:299 src/async/control-flow/join.md:1
msgid "Join"
msgstr ""

#: src/SUMMARY.md:300 src/async/control-flow/select.md:1
msgid "Select"
msgstr ""

#: src/SUMMARY.md:301
msgid "Pitfalls"
msgstr ""

#: src/SUMMARY.md:302
msgid "Blocking the Executor"
msgstr ""

#: src/SUMMARY.md:303 src/async/pitfalls/pin.md:1
msgid "Pin"
msgstr ""

#: src/SUMMARY.md:304 src/async/pitfalls/async-traits.md:1
#, fuzzy
msgid "Async Traits"
msgstr "Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/SUMMARY.md:305 src/async/pitfalls/cancellation.md:1
#, fuzzy
msgid "Cancellation"
msgstr "Î•Î³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·"

#: src/SUMMARY.md:308 src/exercises/concurrency/chat-app.md:1
#: src/exercises/concurrency/solutions-afternoon.md:119
msgid "Broadcast Chat Application"
msgstr ""

#: src/SUMMARY.md:311
msgid "Final Words"
msgstr "ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿"

#: src/SUMMARY.md:315 src/thanks.md:1
msgid "Thanks!"
msgstr "Î•Ï…Ï‡Î±ÏÎ¹ÏƒÏ„Î®ÏÎ¹Î±"

#: src/SUMMARY.md:316
msgid "Other Resources"
msgstr "Î•Ï€Î¹Ï€Î»Î­Î¿Î½ Î¥Î»Î¹ÎºÏŒ"

#: src/SUMMARY.md:317 src/credits.md:1
#, fuzzy
msgid "Credits"
msgstr "Î Î¹ÏƒÏ„ÏÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:320 src/exercises/solutions.md:1
msgid "Solutions"
msgstr "Î›ÏÏƒÎµÎ¹Ï‚"

#: src/SUMMARY.md:325
msgid "Day 1 Morning"
msgstr "1Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¯"

#: src/SUMMARY.md:326
msgid "Day 1 Afternoon"
msgstr "1Î· Î¼Î­ÏÎ± Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:327
msgid "Day 2 Morning"
msgstr "2Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¯"

#: src/SUMMARY.md:328
msgid "Day 2 Afternoon"
msgstr "2Î· Î¼Î­ÏÎ± Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:329
msgid "Day 3 Morning"
msgstr "3Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¯"

#: src/SUMMARY.md:330
msgid "Day 3 Afternoon"
msgstr "3Î· Î¼Î­ÏÎ± Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:331
msgid "Bare Metal Rust Morning"
msgstr "Rust Ï‡Ï‰ÏÎ¯Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î±: Î ÏÏ‰Î¯"

#: src/SUMMARY.md:332 src/exercises/bare-metal/solutions-afternoon.md:1
msgid "Bare Metal Rust Afternoon"
msgstr "Rust Ï‡Ï‰ÏÎ¯Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î± Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±"

#: src/SUMMARY.md:333
#, fuzzy
msgid "Concurrency Morning"
msgstr "Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚"

#: src/SUMMARY.md:334
#, fuzzy
msgid "Concurrency Afternoon"
msgstr "Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚"

#: src/index.md:3
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""

#: src/index.md:7
#, fuzzy
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Ï„ÎµÏ„ÏÎ±Î®Î¼ÎµÏÎ¿ Î¼Î¬Î¸Î·Î¼Î± Rust Ï€Î¿Ï… Î±Î½Î±Ï€Ï„ÏÏ‡Î¸Î·ÎºÎµ Î±Ï€ÏŒ Ï„Î·Î½ Î¿Î¼Î¬Î´Î± Android. "
"Î¤Î¿ Î¼Î¬Î¸Î·Î¼Î± ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î¿ Ï€Î»Î®ÏÎµÏ‚ Ï†Î¬ÏƒÎ¼Î± Ï„Î·Ï‚ Rust, Î±Ï€ÏŒ Ï„Î· Î²Î±ÏƒÎ¹ÎºÎ® ÏƒÏÎ½Ï„Î±Î¾Î· Î­Ï‰Ï‚ Ï„Î± "
"Ï€ÏÎ¿Î·Î³Î¼Î­Î½Î± Î¸Î­Î¼Î±Ï„Î± ÏŒÏ€Ï‰Ï‚ Î¿Î¹ Î³ÎµÎ½Î¹ÎºÎµÏ…Î¼Î­Î½Î¿Î¹ Ï„ÏÏ€Î¿Î¹ ÎºÎ±Î¹ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½. "
"Î ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Ï€ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ ÎµÎ¹Î´Î¹ÎºÎ¬ Î³Î¹Î± Android Ï„Î·Î½ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± Î·Î¼Î­ÏÎ±."

#: src/index.md:11
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr ""
"ÎŸ ÏƒÏ„ÏŒÏ‡Î¿Ï‚ Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î½Î± ÏƒÎ±Ï‚ Î´Î¹Î´Î¬Î¾ÎµÎ¹ Ï„Î· Î³Î»ÏÏƒÏƒÎ± Rust. Î¥Ï€Î¿Î¸Î­Ï„Î¿Ï…Î¼Îµ ÏŒÏ„Î¹ "
"Î´ÎµÎ½ Î¾Î­ÏÎµÏ„Îµ Ï„Î¯Ï€Î¿Ï„Î± ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î· Rust ÎºÎ±Î¹ ÎµÎ»Ï€Î¯Î¶Î¿Ï…Î¼Îµ Î½Î±:"

#: src/index.md:14
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr ""
"Î£Î±Ï‚ Î´ÏÏƒÎ¿Ï…Î¼Îµ Î¼Î¹Î± Î¿Î»Î¿ÎºÎ»Î·ÏÏ‰Î¼Î­Î½Î· ÎºÎ±Ï„Î±Î½ÏŒÎ·ÏƒÎ· Ï„Î·Ï‚ ÏƒÏÎ½Ï„Î±Î¾Î·Ï‚ ÎºÎ±Î¹ Ï„Î·Ï‚ Î³Î»ÏÏƒÏƒÎ±Ï‚ Rust."

#: src/index.md:15
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr ""
"Î£Î±Ï‚ ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎ¿Ï…Î¼Îµ Î¹ÎºÎ±Î½Î¿ÏÏ‚ Î½Î± Ï„ÏÎ¿Ï€Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Ï…Ï€Î¬ÏÏ‡Î¿Î½Ï„Î± Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î± ÎºÎ±Î¹ Î½Î± "
"Î³ÏÎ¬Ï†ÎµÏ„Îµ Î½Î­Î± Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î± Î¼Îµ Ï„Î· Rust."

#: src/index.md:16
msgid "Show you common Rust idioms."
msgstr "Î£Î±Ï‚ Î´ÎµÎ¯Î¾Î¿Ï…Î¼Îµ Ï„Î¿Ï…Ï‚ ÏƒÏ…Î½Î®Î¸ÎµÎ¹Ï‚ Î¹Î´Î¹Ï‰Î¼Î±Ï„Î¹ÏƒÎ¼Î¿ÏÏ‚ Ï„Î·Ï‚ Rust."

#: src/index.md:18
msgid "We call the first three course days Rust Fundamentals."
msgstr ""

#: src/index.md:20
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr ""

#: src/index.md:22
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""

#: src/index.md:24
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""

#: src/index.md:27
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""

#: src/index.md:33
msgid "Non-Goals"
msgstr "ÎœÎ·-Î£Ï„ÏŒÏ‡Î¿Î¹"

#: src/index.md:35
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Î— Rust ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î¼ÎµÎ³Î¬Î»Î· Î³Î»ÏÏƒÏƒÎ± ÎºÎ±Î¹ Î´ÎµÎ½ Î¸Î± Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Ï„Î·Î½ ÎºÎ±Î»ÏÏˆÎ¿Ï…Î¼Îµ ÏŒÎ»Î· ÏƒÎµ "
"Î»Î¯Î³ÎµÏ‚ Î¼Î­ÏÎµÏ‚. ÎœÎµÏÎ¹ÎºÎ¿Î¯ Î¼Î·-ÏƒÏ„ÏŒÏ‡Î¿Î¹ Î±Ï…Ï„Î¿Ï Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚ ÎµÎ¯Î½Î±Î¹:"

#: src/index.md:38
#, fuzzy
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"Î‘Î½Î¬Ï€Ï„Ï…Î¾Î· Î¼Î±ÎºÏÎ¿ÎµÎ½Ï„Î¿Î»ÏÎ½, Î±Î½Î±Ï„ÏÎ­Î¾Ï„Îµ ÏƒÏ„Î¿ [ÎšÎµÏ†Î¬Î»Î±Î¹Î¿ 19.5 ÏƒÏ„Î¿ Rust Book](https://"
"doc.rust-lang.org/book/ch19-06-macros.html) ÎºÎ±Î¹ [Rust by Example](https://"
"doc.rust-lang.org/rust-by-example/macros.html) Î±Î½Ï„' Î±Ï…Ï„Î¿Ï."

#: src/index.md:42
msgid "Assumptions"
msgstr "Î¥Ï€Î¿Î¸Î­ÏƒÎµÎ¹Ï‚"

#: src/index.md:44
#, fuzzy
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"Î¤Î¿ Î¼Î¬Î¸Î·Î¼Î± Ï€ÏÎ¿Ï‹Ï€Î¿Î¸Î­Ï„ÎµÎ¹ ÏŒÏ„Î¹ Î³Î½Ï‰ÏÎ¯Î¶ÎµÏ„Îµ Î®Î´Î· Ï€ÏÏ‚ Î½Î± Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¯Î¶ÎµÏ„Îµ. Î— Rust ÎµÎ¯Î½Î±Î¹ "
"Î³Î»ÏÏƒÏƒÎ± Î¼Îµ ÏƒÏ„Î±Ï„Î¹ÎºÏŒ ÏƒÏÏ„Î·Î¼Î± Ï„ÏÏ€Ï‰Î½ ÎºÎ±Î¹ Î¼ÎµÏÎ¹ÎºÎ­Ï‚ Ï†Î¿ÏÎ­Ï‚ Î¸Î± ÎºÎ¬Î½Î¿Ï…Î¼Îµ ÏƒÏ…Î³ÎºÏÎ¯ÏƒÎµÎ¹Ï‚ Î¼Îµ C "
"ÎºÎ±Î¹ C++ Î³Î¹Î± ÎºÎ±Î»ÏÏ„ÎµÏÎ· ÎºÎ±Ï„Î±Î½ÏŒÎ·ÏƒÎ· Ï„Î·Ï‚ Ï€ÏÎ¿ÏƒÎ­Î³Î³Î¹ÏƒÎ·Ï‚ Ï„Î·Ï‚ Rust."

#: src/index.md:48
#, fuzzy
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"Î•Î¬Î½ Î³Î½Ï‰ÏÎ¯Î¶ÎµÏ„Îµ Ï€ÏÏ‚ Î½Î± Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¯Î¶ÎµÏ„Îµ ÏƒÎµ Î¼Î¹Î± Î³Î»ÏÏƒÏƒÎ± Î¼Îµ Î´Ï…Î½Î±Î¼Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î± Ï„ÏÏ€Ï‰Î½ "
"ÏŒÏ€Ï‰Ï‚ Python Î® JavaScript, Ï„ÏŒÏ„Îµ Î¸Î± Î¼Ï€Î¿ÏÎ­ÏƒÎµÏ„Îµ Î½Î± Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÎµÏ„Îµ Î¬Î½ÎµÏƒÎ·."

#: src/index.md:53
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± _ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÏ‰Î½ Î¿Î¼Î¹Î»Î·Ï„Î®_. Î˜Î± Ï„Î¹Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Î³Î¹Î± "
"Î½Î± Ï€ÏÎ¿ÏƒÎ¸Î­Ï„Î¿Ï…Î¼Îµ ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ ÏƒÏ„Î¹Ï‚ Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹ÎµÏ‚. Î‘Ï…Ï„Î­Ï‚ Î¸Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Î½ Î½Î± "
"ÎµÎ¯Î½Î±Î¹ Î²Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î± Ï€Î¿Ï… Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ±Î»ÏÏˆÎµÎ¹ Î¿ ÎµÎºÏ€Î±Î¹Î´ÎµÏ…Ï„Î®Ï‚  ÎºÎ±Î¸ÏÏ‚ ÎºÎ±Î¹ "
"Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚ ÏƒÎµ ÏƒÏ…Ï‡Î½Î­Ï‚ ÎµÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… Ï€ÏÎ¿ÎºÏÏ€Ï„Î¿Ï…Î½ ÏƒÏ„Î·Î½ Ï„Î¬Î¾Î·."

#: src/running-the-course.md:3 src/running-the-course/course-structure.md:3
msgid "This page is for the course instructor."
msgstr "Î‘Ï…Ï„Î® Î· ÏƒÎµÎ»Î¯Î´Î± ÎµÎ¯Î½Î±Î¹ Î³Î¹Î± Ï„Î¿Î½ ÎµÎºÏ€Î±Î¹Î´ÎµÏ…Ï„Î® Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚."

#: src/running-the-course.md:5
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr ""
"Î‘ÎºÎ¿Î»Î¿Ï…Î¸Î¿ÏÎ½ Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î²Î±ÏƒÎ¹ÎºÎ­Ï‚ Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î¿Î½ Ï„ÏÏŒÏ€Î¿ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±Ï‚ "
"Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚ ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÎ¬ ÏƒÏ„Î·Î½ Google."

#: src/running-the-course.md:8
msgid "Before you run the course, you will want to:"
msgstr "Î“Î¹Î± Î½Î± Î´Î¹ÎµÎ¾Î¬Î¾ÎµÏ„Îµ Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î±, Ï€ÏÎ­Ï€ÎµÎ¹:"

#: src/running-the-course.md:10
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"Î•Î¾Î¿Î¹ÎºÎµÎ¹Ï‰Î¸ÎµÎ¯Ï„Îµ Î¼Îµ Ï„Î¿ Ï…Î»Î¹ÎºÏŒ Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚. ÎˆÏ‡Î¿Ï…Î¼Îµ ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î¬Î²ÎµÎ¹ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ "
"Î¿Î¼Î¹Î»Î·Ï„ÏÎ½ Î³Î¹Î± Î½Î± Ï„Î¿Î½Î¯ÏƒÎ¿Ï…Î¼Îµ Ï„Î± Î²Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î± (Ï€Î±ÏÎ±ÎºÎ±Î»Î¿ÏÎ¼Îµ Î²Î¿Î·Î¸Î®ÏƒÏ„Îµ Î¼Î±Ï‚ "
"ÏƒÏ…Î½ÎµÎ¹ÏƒÏ†Î­ÏÎ¿Î½Ï„Î±Ï‚ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ Î¿Î¼Î¹Î»Î·Ï„Î®!). ÎšÎ±Ï„Î¬ Ï„Î·Î½ Ï€Î±ÏÎ¿Ï…ÏƒÎ¯Î±ÏƒÎ·, Î¸Î± "
"Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î²ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Î±Î½Î¿Î¯Î³ÎµÏ„Îµ Ï„Î¹Ï‚ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ Ï„Î¿Ï… Î¿Î¼Î¹Î»Î·Ï„Î® ÏƒÎµ Î­Î½Î± "
"Î±Î½Î±Î´Ï…ÏŒÎ¼ÎµÎ½Î¿ Ï€Î±ÏÎ¬Î¸Ï…ÏÎ¿ (ÎºÎ¬Î½Ï„Îµ ÎºÎ»Î¹Îº ÏƒÏ„Î¿ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿ Î¼Îµ Î­Î½Î± Î¼Î¹ÎºÏÏŒ Î²Î­Î»Î¿Ï‚ Î´Î¯Ï€Î»Î± ÏƒÏ„Î¿ "
"\"Speaker Notes\"). ÎœÎµ Î±Ï…Ï„ÏŒÎ½ Ï„Î¿Î½ Ï„ÏÏŒÏ€Î¿ Î­Ï‡ÎµÏ„Îµ Î¼Î¹Î± ÎºÎ±Î¸Î±ÏÎ® Î¿Î¸ÏŒÎ½Î· Î³Î¹Î± Î½Î± "
"Ï€Î±ÏÎ¿Ï…ÏƒÎ¹Î¬ÏƒÎµÏ„Îµ ÏƒÏ„Î·Î½ Ï„Î¬Î¾Î·."

#: src/running-the-course.md:16
#, fuzzy
msgid ""
"Decide on the dates. Since the course takes at least three full days, we "
"recommend that you schedule the days over two weeks. Course participants "
"have said that they find it helpful to have a gap in the course since it "
"helps them process all the information we give them."
msgstr ""
"Î‘Ï€Î¿Ï†Î±ÏƒÎ¯ÏƒÏ„Îµ Î³Î¹Î± Ï„Î¹Ï‚ Î·Î¼ÎµÏÎ¿Î¼Î·Î½Î¯ÎµÏ‚. Î•Ï€ÎµÎ¹Î´Î® Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î± ÎµÎ¯Î½Î±Î¹ Î¼ÎµÎ³Î¬Î»Î¿, ÏƒÎ±Ï‚ "
"ÏƒÏ…Î½Î¹ÏƒÏ„Î¿ÏÎ¼Îµ Î½Î± Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¯ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ Ï„Î­ÏƒÏƒÎµÏÎ¹Ï‚ Î·Î¼Î­ÏÎµÏ‚ ÏƒÎµ Î´ÏÎ¿ ÎµÎ²Î´Î¿Î¼Î¬Î´ÎµÏ‚. ÎŸÎ¹ "
"Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿Î¹ ÏƒÏ…Î¼Î¼ÎµÏ„Î­Ï‡Î¿Î½Ï„ÎµÏ‚ ÏƒÏ„Î¿ Î¼Î¬Î¸Î·Î¼Î± Î¸ÎµÏ‰ÏÎ¿ÏÎ½ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ Î½Î± Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î­Î½Î± ÎºÎµÎ½ÏŒ "
"ÏƒÏ„Î¿ Î¼Î¬Î¸Î·Î¼Î±, ÎºÎ±Î¸ÏÏ‚ Ï„Î¿Ï…Ï‚ Î²Î¿Î·Î¸Î¬ Î½Î± ÎµÏ€ÎµÎ¾ÎµÏÎ³Î¬Î¶Î¿Î½Ï„Î±Î¹ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ Ï€Î¿Ï… Ï„Î¿Ï…Ï‚ "
"Î´Î¯Î½Î¿Ï…Î¼Îµ."

#: src/running-the-course.md:21
#, fuzzy
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"Î’ÏÎµÎ¯Ï„Îµ Î­Î½Î± Î´Ï‰Î¼Î¬Ï„Î¹Î¿ Î±ÏÎºÎµÏ„Î¬ Î¼ÎµÎ³Î¬Î»Î¿ Î³Î¹Î± ÏŒÎ»Î¿Ï…Ï‚ Ï„Î¿Ï…Ï‚ ÏƒÏ…Î¼Î¼ÎµÏ„Î­Ï‡Î¿Î½Ï„ÎµÏ‚. Î ÏÎ¿Ï„ÎµÎ¯Î½Î¿Ï…Î¼Îµ "
"Î¼Î­Î³ÎµÎ¸Î¿Ï‚ Ï„Î¬Î¾Î·Ï‚ 15-20 Î±Ï„ÏŒÎ¼Ï‰Î½. Î•Î¯Î½Î±Î¹ Î±ÏÎºÎµÏ„Î¬ Î¼Î¹ÎºÏÏŒ ÏÏƒÏ„Îµ Î¿Î¹ Î¬Î½Î¸ÏÏ‰Ï€Î¿Î¹ Î½Î± "
"Î±Î¹ÏƒÎ¸Î¬Î½Î¿Î½Ï„Î±Î¹ Î¬Î½ÎµÏ„Î± Î½Î± ÎºÎ¬Î½Î¿Ï…Î½ ÎµÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ - ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î±ÏÎºÎµÏ„Î¬ Î¼Î¹ÎºÏÏŒ ÏÏƒÏ„Îµ Î­Î½Î±Ï‚ "
"ÎµÎºÏ€Î±Î¹Î´ÎµÏ…Ï„Î®Ï‚ Î½Î± Î­Ï‡ÎµÎ¹ Ï‡ÏÏŒÎ½Î¿ Î½Î± Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹. Î’ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Ï„Î¿ Î´Ï‰Î¼Î¬Ï„Î¹Î¿ Î­Ï‡ÎµÎ¹ "
"Î¸ÏÎ±Î½Î¯Î± Î³Î¹Î± ÎµÏƒÎ¬Ï‚ ÎºÎ±Î¹ Ï„Î¿Ï…Ï‚ Î¼Î±Î¸Î·Ï„Î­Ï‚: ÏŒÎ»Î¿Î¹ Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎºÎ±Î¸Î¯ÏƒÎµÏ„Îµ ÎºÎ±Î¹ "
"Î½Î± ÎµÏÎ³Î¬Î¶ÎµÏƒÏ„Îµ Î¼Îµ Ï„Î¿Ï…Ï‚ Ï†Î¿ÏÎ·Ï„Î¿ÏÏ‚ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÏ„Î­Ï‚ ÏƒÎ±Ï‚. Î£Ï…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î±, Î¸Î± Î³ÏÎ¬ÏˆÎµÏ„Îµ Ï€Î¿Î»Ï "
"ÎºÏÎ´Î¹ÎºÎ± Î¶Ï‰Î½Ï„Î±Î½Î¬ Ï‰Ï‚ ÎµÎºÏ€Î±Î¹Î´ÎµÏ…Ï„Î®Ï‚, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Î­Î½Î± Î±Î½Î±Î»ÏŒÎ³Î¹Î¿ Î´ÎµÎ½ Î¸Î± ÏƒÎ±Ï‚ Î²Î¿Î·Î¸Î®ÏƒÎµÎ¹ "
"Ï€Î¿Î»Ï."

#: src/running-the-course.md:29
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"Î¤Î·Î½ Î·Î¼Î­ÏÎ± Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚, ÎµÎ¼Ï†Î±Î½Î¹ÏƒÏ„ÎµÎ¯Ï„Îµ ÏƒÏ„Î·Î½ Î±Î¯Î¸Î¿Ï…ÏƒÎ± Î½Ï‰ÏÎ¯Ï‚ Î³Î¹Î± Î½Î± ÏÏ…Î¸Î¼Î¯ÏƒÎµÏ„Îµ Ï„Î± "
"Ï€ÏÎ¬Î³Î¼Î±Ï„Î±. Î£Ï…Î½Î¹ÏƒÏ„Î¿ÏÎ¼Îµ Ï„Î·Î½ Î±Ï€ÎµÏ…Î¸ÎµÎ¯Î±Ï‚ Ï€Î±ÏÎ¿Ï…ÏƒÎ¯Î±ÏƒÎ· Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î·Î½ Ï…Ï€Î·ÏÎµÏƒÎ¯Î± "
"mdbook Ï€Î¿Ï… ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Î±Î¹ ÏƒÏ„Î¿Î½ Ï†Î¿ÏÎ·Ï„ÏŒ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÏ„Î® ÏƒÎ±Ï‚ (Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ Î¿Î´Î·Î³Î¯ÎµÏ‚ "
"ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚). Î‘Ï…Ï„ÏŒ ÎµÎ¾Î±ÏƒÏ†Î±Î»Î¯Î¶ÎµÎ¹ Î²Î­Î»Ï„Î¹ÏƒÏ„Î· Î±Ï€ÏŒÎ´Î¿ÏƒÎ· Ï‡Ï‰ÏÎ¯Ï‚ ÎºÎ±Î¸Ï…ÏƒÏ„Î­ÏÎ·ÏƒÎ· ÎºÎ±Î¸ÏÏ‚ "
"Î±Î»Î»Î¬Î¶ÎµÏ„Îµ ÏƒÎµÎ»Î¯Î´ÎµÏ‚. Î— Ï‡ÏÎ®ÏƒÎ· Ï„Î¿Ï… Ï†Î¿ÏÎ·Ï„Î¿Ï Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÏ„Î® ÏƒÎ±Ï‚ Î¸Î± ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ "
"Î½Î± Î´Î¹Î¿ÏÎ¸ÏÏƒÎµÏ„Îµ Ï„Ï…Ï€Î¿Î³ÏÎ±Ï†Î¹ÎºÎ¬ Î»Î¬Î¸Î· ÎºÎ±Î¸ÏÏ‚ Ï„Î± ÎµÎ½Ï„Î¿Ï€Î¯Î¶ÎµÏ„Îµ ÎµÏƒÎµÎ¯Ï‚ Î® Î¿Î¹ ÏƒÏ…Î¼Î¼ÎµÏ„Î­Ï‡Î¿Î½Ï„ÎµÏ‚ "
"ÏƒÏ„Î¿ Î¼Î¬Î¸Î·Î¼Î±."

#: src/running-the-course.md:35
#, fuzzy
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"Î‘Ï†Î®ÏƒÏ„Îµ Ï„Î¿Ï…Ï‚ Î¼Î±Î¸Î·Ï„Î­Ï‚ Î½Î± Î»ÏÏƒÎ¿Ï…Î½ Ï„Î¹Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ Î¼ÏŒÎ½Î¿Î¹ Ï„Î¿Ï…Ï‚ Î® ÏƒÎµ Î¼Î¹ÎºÏÎ­Ï‚ Î¿Î¼Î¬Î´ÎµÏ‚. "
"Î’ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Ï„Î¿Ï…Ï‚ ÏÏ‰Ï„Î¬Ï„Îµ ÎµÎ¬Î½ Î­Ï‡Î¿Ï…Î½ ÎºÎ¿Î»Î»Î®ÏƒÎµÎ¹ Î® ÎµÎ¬Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ ÎºÎ¬Ï„Î¹ Î¼Îµ Ï„Î¿ "
"Î¿Ï€Î¿Î¯Î¿ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î²Î¿Î·Î¸Î®ÏƒÎµÏ„Îµ. ÎŒÏ„Î±Î½ Î´ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Ï€Î¿Î»Î»Î¬ Î¬Ï„Î¿Î¼Î± Î­Ï‡Î¿Ï…Î½ Ï„Î¿ Î¯Î´Î¹Î¿ "
"Ï€ÏÏŒÎ²Î»Î·Î¼Î±, Î±Î½Î±Ï†Î­ÏÎµÏ„Î­ Ï„Î¿ ÏƒÏ„Î·Î½ Ï„Î¬Î¾Î· ÎºÎ±Î¹ Ï€ÏÎ¿ÏƒÏ†Î­ÏÎµÏ„Îµ Î¼Î¹Î± Î»ÏÏƒÎ·, Ï€.Ï‡., Î´ÎµÎ¯Ï‡Î½Î¿Î½Ï„Î±Ï‚ "
"ÏƒÏ„Î¿Ï…Ï‚ Î¼Î±Î¸Î·Ï„Î­Ï‚ Ï€Î¿Ï Î½Î± Î²ÏÎ¿Ï…Î½ Ï„Î¹Ï‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ­Ï‚ Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ ÏƒÏ„Î·Î½ Ï„Ï…Ï€Î¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·."

#: src/running-the-course.md:43
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr ""
"Î‘Ï…Ï„ÏŒ Î®Ï„Î±Î½! ÎšÎ±Î»Î® ÎµÏ€Î¹Ï„Ï…Ï‡Î¯Î± ÏƒÏ„Î· Î´Î¹ÎµÎ¾Î±Î³Ï‰Î³Î® Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚! Î•Î»Ï€Î¯Î¶Î¿Ï…Î¼Îµ ÏŒÏ„Î¹ Î¸Î± ÎµÎ¯Î½Î±Î¹ "
"Ï„ÏŒÏƒÎ¿ Î´Î¹Î±ÏƒÎºÎµÎ´Î±ÏƒÏ„Î¹ÎºÏŒ Î³Î¹Î± ÎµÏƒÎ¬Ï‚ ÏŒÏ€Ï‰Ï‚ Î®Ï„Î±Î½ ÎºÎ±Î¹ Î³Î¹Î± ÎµÎ¼Î¬Ï‚!"

#: src/running-the-course.md:46
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"Î Î±ÏÎ±ÎºÎ±Î»Î¿ÏÎ¼Îµ [Ï€Î±ÏÎ­Ï‡ÎµÏ„Îµ ÏƒÏ‡ÏŒÎ»Î¹Î±](https://github.com/google/comprehensive-rust/"
"discussions/86) Î¼ÎµÏ„Î¬ Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î±, ÏÏƒÏ„Îµ Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎ¿Ï…Î¼Îµ Î½Î± Î²ÎµÎ»Ï„Î¹ÏÎ½Î¿Ï…Î¼Îµ Ï„Î¿ Ï…Î»Î¹ÎºÏŒ. "
"Î˜Î± Î¸Î­Î»Î±Î¼Îµ Î½Î± Î±ÎºÎ¿ÏÏƒÎ¿Ï…Î¼Îµ Ï„Î¹ Ï€Î®Î³Îµ ÎºÎ±Î»Î¬ Î³Î¹Î± ÎµÏƒÎ¬Ï‚ ÎºÎ±Î¹ Ï„Î¹ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î³Î¯Î½ÎµÎ¹ "
"ÎºÎ±Î»ÏÏ„ÎµÏÎ±. ÎŸÎ¹ Î¼Î±Î¸Î·Ï„Î­Ï‚ ÏƒÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Ï€Î¿Î»Ï ÎµÏ…Ï€ÏÏŒÏƒÎ´ÎµÎºÏ„Î¿Î¹ Î½Î± [Î¼Î±Ï‚ ÏƒÏ„ÎµÎ¯Î»Î¿Ï…Î½ "
"ÏƒÏ‡ÏŒÎ»Î¹Î±](https://github.com/google/comprehensive-rust/discussions/100)!"

#: src/running-the-course/course-structure.md:5
msgid "The course is fast paced and covers a lot of ground:"
msgstr "Î¤Î¿ Î¼Î¬Î¸Î·Î¼Î± Î­Ï‡ÎµÎ¹ Î³ÏÎ®Î³Î¿ÏÎ¿ ÏÏ…Î¸Î¼ÏŒ ÎºÎ±Î¹ ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹:"

#: src/running-the-course/course-structure.md:7
msgid "Day 1: Basic Rust, syntax, control flow, creating and consuming values."
msgstr ""

#: src/running-the-course/course-structure.md:8
#, fuzzy
msgid ""
"Day 2: Memory management, ownership, compound data types, and the standard "
"library."
msgstr ""
"Î—Î¼Î­ÏÎ± 2: Î£ÏÎ½Î¸ÎµÏ„Î¿Î¹ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½, Ï„Î±Î¯ÏÎ¹Î±ÏƒÎ¼Î± Ï€ÏÎ¿Ï„ÏÏ€Ï‰Î½, Ï„Ï…Ï€Î¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·."

#: src/running-the-course/course-structure.md:9
#, fuzzy
msgid "Day 3: Generics, traits, error handling, testing, and unsafe Rust."
msgstr ""
"Î—Î¼Î­ÏÎ± 3: Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ ÎºÎ±Î¹ Î³ÎµÎ½Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹, Ï‡ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½, Ï„ÎµÏƒÏ„, Î¼Î· "
"Î±ÏƒÏ†Î±Î»Î®Ï‚ Rust."

#: src/running-the-course/course-structure.md:11
msgid "Deep Dives"
msgstr ""

#: src/running-the-course/course-structure.md:13
msgid ""
"In addition to the 3-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr ""

#: src/running-the-course/course-structure.md:16
#, fuzzy
msgid "Rust in Android"
msgstr "Rust Binaries"

#: src/running-the-course/course-structure.md:18
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""

#: src/running-the-course/course-structure.md:22
#, fuzzy
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"Î•Î¬Î½ Î´ÎµÎ½ ÎµÏ€Î¹Î»Î­Î¾ÎµÏ„Îµ Ï„o ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Ï„Î¿Ï… Android Ï„Î·Î½ 4Î· Î—Î¼Î­ÏÎ±, Î¸Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Î­Î½Î± "
"\\[AOSP checkout\\]\\[1\\]. Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î­Î½Î± checkout Î±Ï€ÏŒ Ï„Î¿ \\[Î±Ï€Î¿Î¸ÎµÏ„Î®ÏÎ¹Î¿ "
"Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚\\]\\[2\\] ÏƒÏ„Î¿Î½ Î¯Î´Î¹Î¿ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÏ„Î® ÎºÎ±Î¹ Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÏ„Îµ Ï„Î¿Î½ ÎºÎ±Ï„Î¬Î»Î¿Î³Î¿ "
"`src/android/` ÏƒÏ„Î· ÏÎ¯Î¶Î± Ï„Î¿Ï… AOSP checkout ÏƒÎ±Ï‚. Î‘Ï…Ï„ÏŒ Î¸Î± Î´Î¹Î±ÏƒÏ†Î±Î»Î¯ÏƒÎµÎ¹ ÏŒÏ„Î¹ Ï„Î¿ "
"build system Ï„Î¿Ï… Android Î²Î»Î­Ï€ÎµÎ¹ Ï„Î± Î‘ÏÏ‡ÎµÎ¯Î± `Android.bp` ÎºÎ¬Ï„Ï‰ Î±Ï€ÏŒ Ï„Î¿Î½ Ï†Î¬ÎºÎµÎ»Î¿ "
"`src/android/`."

#: src/running-the-course/course-structure.md:27
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"Î’ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Ï„Î¿ \"adb sync\" Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Î¼Îµ Ï„Î¿Î½ ÎµÎ¾Î¿Î¼Î¿Î¹Ï‰Ï„Î® Î® Ï„Î·Î½ ÏƒÏ…ÏƒÎºÎµÏ…Î® "
"ÏƒÎ±Ï‚ ÎºÎ±Î¹ Ï‡Ï„Î¯ÏƒÏ„Îµ ÏŒÎ»Î± Ï„Î± Ï€Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î± Ï„Î¿Ï… Android Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿ `src/"
"android/build_all.sh`. Î”Î¹Î±Î²Î¬ÏƒÏ„Îµ Ï„Î¿ script Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ ÎµÎ½Ï„Î¿Î»Î­Ï‚ Ï€Î¿Ï… "
"ÎµÎºÏ„ÎµÎ»ÎµÎ¯ ÎºÎ±Î¹ Î²ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÎ½ ÏŒÏ„Î±Î½ Ï„Î¹Ï‚ ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Îµ Î¼Îµ Ï„Î¿ Ï‡Î­ÏÎ¹."

#: src/running-the-course/course-structure.md:34
#, fuzzy
msgid "Bare-Metal Rust"
msgstr "Rust Ï‡Ï‰ÏÎ¯Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î±: Î ÏÏ‰Î¯"

#: src/running-the-course/course-structure.md:36
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""

#: src/running-the-course/course-structure.md:40
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""

#: src/running-the-course/course-structure.md:45
#, fuzzy
msgid "Concurrency in Rust"
msgstr "Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚"

#: src/running-the-course/course-structure.md:47
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""

#: src/running-the-course/course-structure.md:50
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""

#: src/running-the-course/course-structure.md:54
msgid ""
"```shell\n"
"cargo init concurrency\n"
"cd concurrency\n"
"cargo add tokio --features full\n"
"cargo run\n"
"```"
msgstr ""

#: src/running-the-course/course-structure.md:61
msgid "Format"
msgstr "ÎœÎ¿ÏÏ†Î®"

#: src/running-the-course/course-structure.md:63
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr ""
"Î¤Î¿ Î¼Î¬Î¸Î·Î¼Î± ÏƒÏ‡ÎµÎ´Î¹Î¬ÏƒÏ„Î·ÎºÎµ Î½Î± ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î´ÏÎ±ÏƒÏ„Î¹ÎºÏŒ ÎºÎ±Î¹ ÏƒÏ…Î½Î¹ÏƒÏ„Î¿ÏÎ¼Îµ Î½Î± Î±Ï†Î®ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ "
"ÎµÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ Î½Î± Î¿Î´Î·Î³Î®ÏƒÎ¿Ï…Î½ Ï„Î·Î½ ÎºÎ¿Ï…Î²Î­Î½Ï„Î± Î³ÏÏÏ‰ Î±Ï€ÏŒ Ï„Î· Rust!"

#: src/running-the-course/keyboard-shortcuts.md:3
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "Î¥Ï€Î¬ÏÏ‡Î¿Ï…Î½ Ï€Î¿Î»Î»Î­Ï‚ Ï‡ÏÎ®ÏƒÎ¹Î¼ÎµÏ‚ ÏƒÏ…Î½Ï„Î¿Î¼ÎµÏÏƒÎµÎ¹Ï‚ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»Î¿Î³Î¯Î¿Ï… ÏƒÏ„Î¿ mdBook:"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid "Arrow-Left"
msgstr "Î’Î­Î»Î¿Ï‚-Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ¬"

#: src/running-the-course/keyboard-shortcuts.md:5
msgid ": Navigate to the previous page."
msgstr ": ÎœÎµÏ„Î±Î²ÎµÎ¯Ï„Îµ ÏƒÏ„Î·Î½ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î· ÏƒÎµÎ»Î¯Î´Î±."

#: src/running-the-course/keyboard-shortcuts.md:6
msgid "Arrow-Right"
msgstr "Î’Î­Î»Î¿Ï‚-Î”ÎµÎ¾Î¹Î¬"

#: src/running-the-course/keyboard-shortcuts.md:6
msgid ": Navigate to the next page."
msgstr ": ÎœÎµÏ„Î±Î²ÎµÎ¯Ï„Îµ ÏƒÏ„Î·Î½ ÎµÏ€ÏŒÎ¼ÎµÎ½Î· ÏƒÎµÎ»Î¯Î´Î±."

#: src/running-the-course/keyboard-shortcuts.md:7 src/cargo/code-samples.md:19
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md:7
msgid ": Execute the code sample that has focus."
msgstr ": Î•ÎºÏ„ÎµÎ»Î­ÏƒÏ„Îµ Ï„Î¿ Î´ÎµÎ¯Î³Î¼Î± ÎºÏÎ´Î¹ÎºÎ± Ï…Ï€ÏŒ ÎµÏƒÏ„Î¯Î±ÏƒÎ·."

#: src/running-the-course/keyboard-shortcuts.md:8
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md:8
msgid ": Activate the search bar."
msgstr ": Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î· Î³ÏÎ±Î¼Î¼Î® Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚."

#: src/running-the-course/translations.md:3
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr ""
"Î¤Î¿ Î¼Î¬Î¸Î·Î¼Î± Î­Ï‡Î¿Ï…Î¼Îµ Î¼ÎµÏ„Î±Ï†ÏÎ±ÏƒÏ„ÎµÎ¯ ÏƒÎµ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚ Î±Ï€ÏŒ Î­Î½Î± ÏƒÏÎ½Î¿Î»Î¿ ÎµÎºÏ€Î»Î·ÎºÏ„Î¹ÎºÏÎ½ "
"ÎµÎ¸ÎµÎ»Î¿Î½Ï„ÏÎ½:"

#: src/running-the-course/translations.md:6
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes) and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""

#: src/running-the-course/translations.md:7
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp) and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""

#: src/running-the-course/translations.md:9
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î·Î½ ÎµÏ€Î¹Î»Î¿Î³Î® Î³Î»ÏÏƒÏƒÎ±Ï‚ ÏƒÏ„Î·Î½ Ï€Î¬Î½Ï‰-Î´ÎµÎ¾Î¹Î¬ Î³Ï‰Î½Î¯Î± Î³Î¹Î± Î½Î± Î±Î»Î»Î¬Î¾ÎµÏ„Îµ "
"Î³Î»ÏÏƒÏƒÎ±."

#: src/running-the-course/translations.md:11
#, fuzzy
msgid "Incomplete Translations"
msgstr "ÎœÎµÏ„Î±Ï†ÏÎ¬ÏƒÎµÎ¹Ï‚"

#: src/running-the-course/translations.md:13
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr ""

#: src/running-the-course/translations.md:16
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""

#: src/running-the-course/translations.md:17
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""

#: src/running-the-course/translations.md:18
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""

#: src/running-the-course/translations.md:19
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""

#: src/running-the-course/translations.md:21
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î²Î¿Î·Î¸Î®ÏƒÎµÏ„Îµ ÏƒÏ„Î· Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ· Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ Î¿Î´Î·Î³Î¯ÎµÏ‚ Î¼Î±Ï‚ Î³Î¹Î± Ï„Î¿ Ï€ÏÏ‚Î½Î± "
"Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ. ÎŸÎ¹ Î¼ÎµÏ„Î±Ï†ÏÎ¬ÏƒÎµÎ¹Ï‚ Î¿ÏÎ³Î±Î½ÏÎ½Î¿Î½Ï„Î±Î¹ ÏƒÏ„Î¿Î½ [issue tracker](https://github."
"com/google/comprehensive-rust/issues/282)."

#: src/cargo.md:3
#, fuzzy
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"ÎŒÏ„Î±Î½ Î±ÏÏ‡Î¯ÏƒÎµÏ„Îµ Î½Î± Î´Î¹Î±Î²Î¬Î¶ÎµÏ„Îµ Î³Î¹Î± Ï„Î¿ Rust, ÏƒÏÎ½Ï„Î¿Î¼Î± Î¸Î± ÏƒÏ…Î½Î±Î½Ï„Î®ÏƒÎµÏ„Îµ Ï„Î¿ [Cargo]"
"(https://doc.rust-lang.org/cargo/), Ï„Î¿ Ï„Ï…Ï€Î¹ÎºÏŒ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ ÏƒÏ„Î¿ "
"Î¿Î¹ÎºÎ¿ÏƒÏÏƒÏ„Î·Î¼Î± Rust Î³Î¹Î± Ï„Î· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎºÎ±Î¹ ÎµÎºÏ„Î­Î»ÎµÏƒÎ· ÎµÏ†Î±ÏÎ¼Î¿Î³ÏÎ½ Rust. Î•Î´Ï Î¸Î­Î»Î¿Ï…Î¼Îµ "
"Î´ÏÏƒÏ„Îµ Î¼Î¹Î± ÏƒÏÎ½Ï„Î¿Î¼Î· ÎµÏ€Î¹ÏƒÎºÏŒÏ€Î·ÏƒÎ· Ï„Î¿Ï… Ï„Î¹ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Cargo ÎºÎ±Î¹ Ï€ÏÏ‚ Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ ÏƒÏ„Î¿ "
"ÎµÏ…ÏÏÏ„ÎµÏÎ¿ Î¿Î¹ÎºÎ¿ÏƒÏÏƒÏ„Î·Î¼Î± ÎºÎ±Î¹ Ï€ÏÏ‚ Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ ÏƒÎµ Î±Ï…Ï„Î® Ï„Î·Î½ ÎµÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ·."

#: src/cargo.md:8
#, fuzzy
msgid "Installation"
msgstr "Î•Î³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·"

#: src/cargo.md:10
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr ""

#: src/cargo.md:12
#, fuzzy
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install/switch toolchains, setup cross compilation, etc."
msgstr ""
"ÎœÎ±Î¶Î¯ Î¼Îµ Ï„Î¿ cargo ÎºÎ±Î¹ Ï„Î¿ rustc, Ï„Î¿ Rustup Î¸Î± ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î±Î¸ÎµÎ¯ Ï‰Ï‚ Î²Î¿Î·Î¸Î·Ï„Î¹ÎºÏŒ "
"Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Î³ÏÎ±Î¼Î¼Î®Ï‚ ÎµÎ½Ï„Î¿Î»ÏÎ½ Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î³Î¹Î± Î½Î± "
"ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎµÏ„Îµ/ÎµÎ½Î±Î»Î»Î¬Î¾ÎµÏ„Îµ Î±Î»Ï…ÏƒÎ¯Î´ÎµÏ‚ ÎµÏÎ³Î±Î»ÎµÎ¯Ï‰Î½, Î½Î± ÏÏ…Î¸Î¼Î¯ÏƒÎµÏ„Îµ Ï„Î· Î´Î¹Î±ÏƒÏ„Î±Ï…ÏÎ¿ÏÎ¼ÎµÎ½Î· "
"Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ· Îº.Î»Ï€."

#: src/cargo.md:16
#, fuzzy
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"Î£Ï„Î¿ Debian/Ubuntu, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎµÏ„Îµ Ï„Î¿ Cargo ÎºÎ±Î¹ Ï„Î·Î½ Ï€Î·Î³Î® Rust Î¼Îµ"

#: src/cargo.md:18
msgid ""
"```shell\n"
"sudo apt install cargo rust-src rustfmt\n"
"```"
msgstr ""

#: src/cargo.md:22
#, fuzzy
msgid ""
"We suggest using [VS Code](https://code.visualstudio.com/) to edit the code "
"(but any LSP compatible editor works with rust-analyzer[3](https://rust-"
"analyzer.github.io/))."
msgstr ""
"Î‘Ï…Ï„ÏŒ Î¸Î± ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎµÎ¹ ÏƒÏ„Î¿Î½ \\[rust-analyzer\\]\\[1\\] Î½Î± Î¼ÎµÏ„Î±Î²ÎµÎ¯ ÏƒÏ„Î¿Ï…Ï‚ Î¿ÏÎ¹ÏƒÎ¼Î¿ÏÏ‚. "
"Î ÏÎ¿Ï„ÎµÎ¯Î½Î¿Ï…Î¼Îµ Ï„Î· Ï‡ÏÎ®ÏƒÎ· [VS Code](https://code.visualstudio.com/) Î³Î¹Î± Î½Î± "
"ÎµÏ€ÎµÎ¾ÎµÏÎ³Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± (Î±Î»Î»Î¬ ÎºÎ¬Î¸Îµ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± ÎµÏ€ÎµÎ¾ÎµÏÎ³Î±ÏƒÎ¯Î±Ï‚ ÏƒÏ…Î¼Î²Î±Ï„ÏŒ Î¼Îµ LSP "
"Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯)."

#: src/cargo.md:24
#, fuzzy
msgid ""
"Some folks also like to use the [JetBrains](https://www.jetbrains.com/"
"clion/) family of IDEs, which do their own analysis but have their own "
"tradeoffs. If you prefer them, you can install the [Rust Plugin](https://www."
"jetbrains.com/rust/). Please take note that as of January 2023 debugging "
"only works on the CLion version of the JetBrains IDEA suite."
msgstr ""
"Î£Îµ Î¼ÎµÏÎ¹ÎºÎ¿ÏÏ‚ Î±Î½Î¸ÏÏÏ€Î¿Ï…Ï‚ Î±ÏÎ­ÏƒÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î·Î½ Î¿Î¹ÎºÎ¿Î³Î­Î½ÎµÎ¹Î± IDE "
"[JetBrains](https://www.jetbrains.com/clion/), Ï€Î¿Ï… ÎºÎ¬Î½Î¿Ï…Î½ Ï„Î· Î´Î¹ÎºÎ® Ï„Î¿Ï…Ï‚ "
"Î±Î½Î¬Î»Ï…ÏƒÎ· Î±Î»Î»Î¬ Î­Ï‡Î¿Ï…Î½ Ï„Î¹Ï‚ Î´Î¹ÎºÎ­Ï‚ Ï„Î¿Ï…Ï‚ Î±Î½Ï„Î±Î»Î»Î±Î³Î­Ï‚. Î•Î¬Î½ Ï„Î± Ï€ÏÎ¿Ï„Î¹Î¼Î¬Ï„Îµ, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎµÏ„Îµ Ï„Î¿ [Rust Plugin](https://www.jetbrains.com/rust/). Î›Î¬Î²ÎµÏ„Îµ "
"Ï…Ï€ÏŒÏˆÎ· ÏŒÏ„Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ Î™Î±Î½Î¿Ï…Î¬ÏÎ¹Î¿ Ï„Î¿Ï… 2023 Î¿ ÎµÎ½Ï„Î¿Ï€Î¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Î¼ÏŒÎ½Î¿ "
"ÏƒÏ„Î·Î½ Î­ÎºÎ´Î¿ÏƒÎ· CLion Ï„Î·Ï‚ ÏƒÎ¿Ï…Î¯Ï„Î±Ï‚ JetBrains IDEA."

#: src/cargo/rust-ecosystem.md:1
#, fuzzy
msgid "The Rust Ecosystem"
msgstr "Î¤Î¿ Î¿Î¹ÎºÎ¿ÏƒÏÏƒÏ„Î·Î¼Î± Ï„Î·Ï‚ ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚"

#: src/cargo/rust-ecosystem.md:3
#, fuzzy
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr ""
"Î¤Î¿ Î¿Î¹ÎºÎ¿ÏƒÏÏƒÏ„Î·Î¼Î± Rust Î±Ï€Î¿Ï„ÎµÎ»ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Î¼Î¹Î± ÏƒÎµÎ¹ÏÎ¬ Î±Ï€ÏŒ ÎµÏÎ³Î±Î»ÎµÎ¯Î±, Î±Ï€ÏŒ Ï„Î± Î¿Ï€Î¿Î¯Î± Ï„Î± "
"ÎºÏ…ÏÎ¹ÏŒÏ„ÎµÏÎ± ÎµÎ¯Î½Î±Î¹:"

#: src/cargo/rust-ecosystem.md:5
#, fuzzy
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr ""
"Â«rustupÂ»: Ï„Î¿ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚ ÎºÎ±Î¹ ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·Ï‚ Ï„Î·Ï‚ Î±Î»Ï…ÏƒÎ¯Î´Î±Ï‚ ÎµÏÎ³Î±Î»ÎµÎ¯Ï‰Î½ "
"Rust. Î‘Ï…Ï„ÏŒ Ï„Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Î½Î± ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÏ„Îµ ÎºÎ±Î¹ ÎµÎ½Î·Î¼ÎµÏÏÏƒÏ„Îµ Ï„Î± "
"Â«rustcÂ» ÎºÎ±Î¹ Â«cargoÂ» ÏŒÏ„Î±Î½ ÎºÏ…ÎºÎ»Î¿Ï†Î¿ÏÎ®ÏƒÎ¿Ï…Î½ Î½Î­ÎµÏ‚ ÎµÎºÎ´ÏŒÏƒÎµÎ¹Ï‚ Ï„Î¿Ï… Rust. Î•Ï€Î¹Ï€Î»Î­Î¿Î½, Ï„Î¿ "
"\"rustup\" Î¼Ï€Î¿ÏÎµÎ¯ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± ÎºÎ±Ï„ÎµÎ²Î¬ÏƒÎµÎ¹ Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ· Î³Î¹Î± Ï„Î¿ Ï€ÏÏŒÏ„Ï…Ï€Î¿ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·. "
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎµÏ„Îµ Ï€Î¿Î»Î»Î­Ï‚ ÎµÎºÎ´ÏŒÏƒÎµÎ¹Ï‚ Ï„Î¿Ï… Rust Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î± ÎºÎ±Î¹ Ï„Î¿ "
"\"rustup\". Î¸Î± ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎµÎ¹ Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ ÎµÎ½Î±Î»Î»Î±Î³Î® Î¼ÎµÏ„Î±Î¾Ï Ï„Î¿Ï…Ï‚ Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î¹Ï‚ "
"Î±Î½Î¬Î³ÎºÎµÏ‚."

#: src/cargo/rust-ecosystem.md:8
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""

#: src/cargo/rust-ecosystem.md:13
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust is "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""

#: src/cargo/rust-ecosystem.md:21 src/hello-world.md:25
#: src/hello-world/small-example.md:27 src/why-rust/runtime.md:10
#: src/why-rust/modern.md:21 src/basic-syntax/compound-types.md:30
#: src/basic-syntax/references.md:23
#: src/pattern-matching/destructuring-enums.md:35
#: src/error-handling/try-operator.md:48
#: src/error-handling/converting-error-types-example.md:50
#: src/concurrency/threads.md:30 src/async/async-await.md:25
#, fuzzy
msgid "Key points:"
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/cargo/rust-ecosystem.md:23
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""

#: src/cargo/rust-ecosystem.md:27
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr ""

#: src/cargo/rust-ecosystem.md:29
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr ""

#: src/cargo/rust-ecosystem.md:32
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""

#: src/cargo/rust-ecosystem.md:34
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""

#: src/cargo/rust-ecosystem.md:37
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr ""

#: src/cargo/rust-ecosystem.md:40
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""

#: src/cargo/rust-ecosystem.md:43
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr ""

#: src/cargo/rust-ecosystem.md:46
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""

#: src/cargo/rust-ecosystem.md:48
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool.  It is capable of many advanced features including but "
"not limited to: "
msgstr ""

#: src/cargo/rust-ecosystem.md:49
msgid "Project/package structure"
msgstr ""

#: src/cargo/rust-ecosystem.md:50
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr ""

#: src/cargo/rust-ecosystem.md:51
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr ""

#: src/cargo/rust-ecosystem.md:52
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr ""

#: src/cargo/rust-ecosystem.md:53
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr ""

#: src/cargo/rust-ecosystem.md:54
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""

#: src/cargo/rust-ecosystem.md:55
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr ""

#: src/cargo/code-samples.md:1
#, fuzzy
msgid "Code Samples in This Training"
msgstr "Î”ÎµÎ¯Î³Î¼Î±Ï„Î± ÎºÏÎ´Î¹ÎºÎ± ÏƒÎµ Î±Ï…Ï„Î®Î½ Ï„Î·Î½ ÎµÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ·"

#: src/cargo/code-samples.md:3
#, fuzzy
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"Î“Î¹Î± Î±Ï…Ï„Î®Î½ Ï„Î·Î½ ÎµÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ·, Î¸Î± ÎµÎ¾ÎµÏÎµÏ…Î½Î®ÏƒÎ¿Ï…Î¼Îµ ÎºÏ…ÏÎ¯Ï‰Ï‚ Ï„Î· Î³Î»ÏÏƒÏƒÎ± Rust Î¼Î­ÏƒÏ‰ "
"Ï€Î±ÏÎ±Î´ÎµÎ¹Î³Î¼Î¬Ï„Ï‰Î½ Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„ÎµÎ¯ Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚ Ï€ÎµÏÎ¹Î®Î³Î·ÏƒÎ®Ï‚ ÏƒÎ±Ï‚. "
"Î‘Ï…Ï„ÏŒ ÎºÎ¬Î½ÎµÎ¹ Ï„Î· ÏÏÎ¸Î¼Î¹ÏƒÎ· Ï€Î¿Î»Ï Ï€Î¹Î¿ ÎµÏÎºÎ¿Î»Î· ÎºÎ±Î¹ ÎµÎ¾Î±ÏƒÏ†Î±Î»Î¯Î¶ÎµÎ¹ Î¼Î¹Î± ÏƒÏ…Î½ÎµÏ€Î® ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î± "
"Î³Î¹Î± ÏŒÎ»Î¿Ï…Ï‚."

#: src/cargo/code-samples.md:7
#, fuzzy
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"Î— ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Cargo ÎµÎ¾Î±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Î½Î± ÎµÎ½Î¸Î±ÏÏÏÎ½ÎµÏ„Î±Î¹: Î¸Î± ÏƒÎ±Ï‚ Î´Î¹ÎµÏ…ÎºÎ¿Î»ÏÎ½ÎµÎ¹ Î½Î± Ï„Î¿ "
"ÎºÎ¬Î½ÎµÏ„Îµ Î³Ï…Î¼Î½Î¬ÏƒÎ¹Î±. Î¤Î·Î½ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± Î¼Î­ÏÎ±, Î¸Î± ÎºÎ¬Î½Î¿Ï…Î¼Îµ Î¼Î¹Î± Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ· Î¬ÏƒÎºÎ·ÏƒÎ· Ï€Î¿Ï… "
"ÏƒÎ±Ï‚ Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€ÏÏ‚ Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ ÎµÏÎ³Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Î¼Îµ ÎµÎ¾Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ ÎºÎ±Î¹ Î³Î¹Î± Î±Ï…Ï„ÏŒ "
"Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏƒÏ„Îµ Cargo."

#: src/cargo/code-samples.md:11
#, fuzzy
msgid "The code blocks in this course are fully interactive:"
msgstr "Î¤Î± Î¼Ï€Î»Î¿Îº ÎºÏÎ´Î¹ÎºÎ± ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î± ÎµÎ¯Î½Î±Î¹ Ï€Î»Î®ÏÏ‰Ï‚ Î´Î¹Î±Î´ÏÎ±ÏƒÏ„Î¹ÎºÎ¬:"

#: src/cargo/code-samples.md:13
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""

#: src/cargo/code-samples.md:19
#, fuzzy
msgid "You can use "
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ "

#: src/cargo/code-samples.md:19
#, fuzzy
msgid " to execute the code when focus is in the text box."
msgstr ""
" Î³Î¹Î± Î½Î± ÎµÎºÏ„ÎµÎ»Î­ÏƒÎµÏ„Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± ÏŒÏ„Î±Î½ Î· ÎµÏƒÏ„Î¯Î±ÏƒÎ· Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Ï€Î»Î±Î¯ÏƒÎ¹Î¿ ÎºÎµÎ¹Î¼Î­Î½Î¿Ï…."

#: src/cargo/code-samples.md:24
#, fuzzy
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"Î¤Î± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± Î´ÎµÎ¯Î³Î¼Î±Ï„Î± ÎºÏÎ´Î¹ÎºÎ± ÎµÎ¯Î½Î±Î¹ ÎµÏ€ÎµÎ¾ÎµÏÎ³Î¬ÏƒÎ¹Î¼Î± ÏŒÏ€Ï‰Ï‚ Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰. "
"ÎœÎµÏÎ¹ÎºÎ¬ Î´ÎµÎ¯Î³Î¼Î±Ï„Î± ÎºÏÎ´Î¹ÎºÎ± Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎµÏ€ÎµÎ¾ÎµÏÎ³Î¬ÏƒÎ¹Î¼Î± Î³Î¹Î± Î´Î¹Î¬Ï†Î¿ÏÎ¿Ï…Ï‚ Î»ÏŒÎ³Î¿Ï…Ï‚:"

#: src/cargo/code-samples.md:27
#, fuzzy
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"ÎŸÎ¹ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½ÎµÏ‚ Ï€Î±Î¹Î´Î¹ÎºÎ­Ï‚ Ï‡Î±ÏÎ­Ï‚ Ï‡Î¬Î½Î¿Ï…Î½ Ï„Î·Î½ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ® Ï„Î¿Ï…Ï‚ Ï„Î· ÏƒÏ„Î¹Î³Î¼Î® Ï€Î¿Ï… "
"Ï€Î»Î¿Î·Î³ÎµÎ¯ÏƒÏ„Îµ Î¼Î±ÎºÏÎ¹Î¬ Î±Ï€ÏŒ Ï„Î· ÏƒÎµÎ»Î¯Î´Î±! Î‘Ï…Ï„ÏŒÏ‚ ÎµÎ¯Î½Î±Î¹ Î¿ Î»ÏŒÎ³Î¿Ï‚ Ï€Î¿Ï… Ï€ÏÎ­Ï€ÎµÎ¹ Î¿Î¹ Î¼Î±Î¸Î·Ï„Î­Ï‚ "
"Î»ÏÏƒÏ„Îµ Ï„Î¹Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿Ï€Î¹ÎºÎ® ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Rust Î® Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… "
"Î Î±Î¹Î´Î¹ÎºÎ® Ï‡Î±ÏÎ¬."

#: src/cargo/code-samples.md:30
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""

#: src/cargo/running-locally.md:1
#, fuzzy
msgid "Running Code Locally with Cargo"
msgstr "ÎšÏ‰Î´Î¹ÎºÏŒÏ‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±Ï‚ Ï„Î¿Ï€Î¹ÎºÎ¬ Î¼Îµ Ï†Î¿ÏÏ„Î¯Î¿"

#: src/cargo/running-locally.md:3
#, fuzzy
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Ï€ÎµÎ¹ÏÎ±Î¼Î±Ï„Î¹ÏƒÏ„ÎµÎ¯Ï„Îµ Î¼Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ Î´Î¹ÎºÏŒ ÏƒÎ±Ï‚ ÏƒÏÏƒÏ„Î·Î¼Î±, Ï„ÏŒÏ„Îµ Î¸Î± "
"Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Î³Î¹Î± Î½Î± ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎµÏ„Îµ Ï€ÏÏÏ„Î± Ï„Î¿ Rust. ÎšÎ¬Î½Ï„Îµ Î±Ï…Ï„ÏŒ Î±ÎºÎ¿Î»Î¿Ï…Î¸ÏÎ½Ï„Î±Ï‚ Ï„Î¹Ï‚ "
"[Î¿Î´Î·Î³Î¯ÎµÏ‚ ÏƒÏ„Î¿ Rust Î’Î¹Î²Î»Î¯Î¿](https://doc.rust-lang.org/book/ch01-01-"
"installation.html). Î‘Ï…Ï„ÏŒ Î¸Î± ÏƒÎ±Ï‚ Î´ÏÏƒÎµÎ¹ Î­Î½Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ Â«rustcÂ» ÎºÎ±Î¹ Â«cargoÂ». "
"Î¤Î·Î½ ÎµÏ€Î¿Ï‡Î® Ï„Î¿Ï… Î³ÏÎ¬Ï†Î¿Î½Ï„Î±Ï‚, Î· Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± ÏƒÏ„Î±Î¸ÎµÏÎ® Î­ÎºÎ´Î¿ÏƒÎ· Rust Î­Ï‡ÎµÎ¹ Î±Ï…Ï„Î¿ÏÏ‚ Ï„Î¿Ï…Ï‚ "
"Î±ÏÎ¹Î¸Î¼Î¿ÏÏ‚ Î­ÎºÎ´Î¿ÏƒÎ·Ï‚:"

#: src/cargo/running-locally.md:8
msgid ""
"```shell\n"
"% rustc --version\n"
"rustc 1.69.0 (84c898d65 2023-04-16)\n"
"% cargo --version\n"
"cargo 1.69.0 (6e9a83356 2023-04-12)\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:15
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr ""

#: src/cargo/running-locally.md:17
#, fuzzy
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"Î•Ï†ÏŒÏƒÎ¿Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î±Ï…Ï„ÏŒ, Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÏ„Îµ Î±Ï…Ï„Î¬ Ï„Î± Î²Î®Î¼Î±Ï„Î± Î³Î¹Î± Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î­Î½Î± "
"Î´Ï…Î±Î´Î¹ÎºÏŒ Î±ÏÏ‡ÎµÎ¯Î¿ Rust Î±Ï€ÏŒ Î­Î½Î± Î±Ï€ÏŒ Ï„Î± Ï€Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î± Î±Ï…Ï„Î®Ï‚ Ï„Î·Ï‚ ÎµÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ·Ï‚:"

#: src/cargo/running-locally.md:20
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr ""

#: src/cargo/running-locally.md:22
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr ""

#: src/cargo/running-locally.md:24
msgid ""
"```shell\n"
"$ cargo new exercise\n"
"     Created binary (application) `exercise` package\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:29
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr ""

#: src/cargo/running-locally.md:31
msgid ""
"```shell\n"
"$ cd exercise\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.75s\n"
"     Running `target/debug/exercise`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:40
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""

#: src/cargo/running-locally.md:43
msgid ""
"```rust\n"
"fn main() {\n"
"    println!(\"Edit me!\");\n"
"}\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:49
msgid "Use `cargo run` to build and run your updated binary:"
msgstr ""

#: src/cargo/running-locally.md:51
msgid ""
"```shell\n"
"$ cargo run\n"
"   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n"
"     Running `target/debug/exercise`\n"
"Edit me!\n"
"```"
msgstr ""

#: src/cargo/running-locally.md:59
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""

#: src/cargo/running-locally.md:64
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""

#: src/cargo/running-locally.md:72
#, fuzzy
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"Î ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÏ„Îµ Î½Î± ÎµÎ½Î¸Î±ÏÏÏÎ½ÎµÏ„Îµ Ï„Î¿Ï…Ï‚ ÏƒÏ…Î¼Î¼ÎµÏ„Î­Ï‡Î¿Î½Ï„ÎµÏ‚ ÏƒÏ„Î·Î½ Ï„Î¬Î¾Î· Î½Î± ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎ¿Ï…Î½ Ï„Î¿ "
"Cargo ÎºÎ±Î¹ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î¿ Î± Ï„Î¿Ï€Î¹ÎºÏŒÏ‚ ÏƒÏ…Î½Ï„Î¬ÎºÏ„Î·Ï‚. Î˜Î± Ï„Î¿Ï…Ï‚ ÎºÎ¬Î½ÎµÎ¹ Ï„Î· Î¶Ï‰Î® Ï€Î¹Î¿ "
"ÎµÏÎºÎ¿Î»Î· Î±Ï†Î¿Ï Î¸Î± Î­Ï‡Î¿Ï…Î½ Î± ÎºÎ±Î½Î¿Î½Î¹ÎºÏŒ Ï€ÎµÏÎ¹Î²Î¬Î»Î»Î¿Î½ Î±Î½Î¬Ï€Ï„Ï…Î¾Î·Ï‚."

#: src/welcome-day-1.md:1
#, fuzzy
msgid "Welcome to Day 1"
msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Î—Î¼Î­ÏÎ± 1"

#: src/welcome-day-1.md:3
#, fuzzy
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr ""
"Î‘Ï…Ï„Î® ÎµÎ¯Î½Î±Î¹ Î· Ï€ÏÏÏ„Î· Î¼Î­ÏÎ± Ï„Î¿Ï… Comprehensive Rust. Î˜Î± ÎºÎ±Î»ÏÏˆÎ¿Ï…Î¼Îµ Ï€Î¿Î»Ï Î­Î´Î±Ï†Î¿Ï‚ "
"ÏƒÎ®Î¼ÎµÏÎ±:"

#: src/welcome-day-1.md:6
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""

#: src/welcome-day-1.md:9
msgid ""
"Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, and "
"`continue`."
msgstr ""

#: src/welcome-day-1.md:12
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr ""

#: src/welcome-day-1.md:16
#, fuzzy
msgid "Please remind the students that:"
msgstr "Î¥Ï€ÎµÎ½Î¸Ï…Î¼Î¯ÏƒÏ„Îµ ÏƒÏ„Î¿Ï…Ï‚ Î¼Î±Î¸Î·Ï„Î­Ï‚ ÏŒÏ„Î¹:"

#: src/welcome-day-1.md:18
#, fuzzy
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr ""
"Î˜Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ¬Î½Î¿Ï…Î½ ÎµÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ ÏŒÏ„Î±Î½ Ï„Î¹Ï‚ Ï€Î¬ÏÎ¿Ï…Î½, Î¼Î·Î½ Ï„Î¹Ï‚ Î±Ï€Î¿Î¸Î·ÎºÎµÏÏƒÎµÏ„Îµ Î¼Î­Ï‡ÏÎ¹ Ï„Î¿ "
"Ï„Î­Î»Î¿Ï‚."

#: src/welcome-day-1.md:19
#, fuzzy
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr ""
"Î— Ï„Î¬Î¾Î· Ï€ÏÎ¿Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î½Î± ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î´ÏÎ±ÏƒÏ„Î¹ÎºÎ® ÎºÎ±Î¹ Î¿Î¹ ÏƒÏ…Î¶Î·Ï„Î®ÏƒÎµÎ¹Ï‚ ÎµÎ½Î¸Î±ÏÏÏÎ½Î¿Î½Ï„Î±Î¹ Ï€Î¿Î»Ï!"

#: src/welcome-day-1.md:20
#, fuzzy
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other "
"language.  It can be hard to find the right balance, but err on the side of "
"allowing  discussions since they engage people much more than one-way "
"communication."
msgstr ""
"Î©Ï‚ ÎµÎºÏ€Î±Î¹Î´ÎµÏ…Ï„Î®Ï‚, Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÎµÏ„Îµ Î½Î± Î´Î¹Î±Ï„Î·ÏÎ®ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ ÏƒÏ…Î¶Î·Ï„Î®ÏƒÎµÎ¹Ï‚ "
"ÏƒÏ‡ÎµÏ„Î¹ÎºÎ­Ï‚, Ï€.Ï‡. ÎºÏÎ±Ï„Î®ÏƒÏ„Îµ Ï„Î· ÏƒÏ‡ÎµÏ„Î¹ÎºÎ® Î¼Îµ Ï„Î¿ Ï€ÏÏ‚ ÎºÎ¬Î½ÎµÎ¹ Ï„Î± Ï€ÏÎ¬Î³Î¼Î±Ï„Î± Î¿ Rust ÏƒÎµ "
"ÏƒÏ‡Î­ÏƒÎ· Î¼Îµ ÎºÎ¬Ï€Î¿Î¹Î± Î¬Î»Î»Î· Î³Î»ÏÏƒÏƒÎ±. ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î´ÏÏƒÎºÎ¿Î»Î¿ Î½Î± Î²ÏÎµÎ¹Ï‚ Ï„Î· ÏƒÏ‰ÏƒÏ„Î® "
"Î¹ÏƒÎ¿ÏÏÎ¿Ï€Î¯Î±, Î±Î»Î»Î¬ ÏƒÏ†Î¬Î»Î»Î·ÏƒÎµ Î½Î± ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎµÎ¹Ï‚ ÏƒÏ…Î¶Î·Ï„Î®ÏƒÎµÎ¹Ï‚ Î±Ï†Î¿Ï ÎµÎ¼Ï€Î»Î­ÎºÎ¿Ï…Î½ Ï„Î¿Ï…Ï‚ "
"Î±Î½Î¸ÏÏÏ€Î¿Ï…Ï‚ Ï€Î¿Î»Ï Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ Î±Ï€ÏŒ Ï„Î· Î¼Î¿Î½ÏŒÎ´ÏÎ¿Î¼Î· ÎµÏ€Î¹ÎºÎ¿Î¹Î½Ï‰Î½Î¯Î±."

#: src/welcome-day-1.md:24
#, fuzzy
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr ""
"ÎŸÎ¹ ÎµÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¹Î¸Î±Î½ÏŒÏ„Î±Ï„Î± Î¸Î± ÏƒÎ·Î¼Î±Î¯Î½Î¿Ï…Î½ ÏŒÏ„Î¹ ÎµÎ¯Î¼Î±ÏƒÏ„Îµ Î³Î¹Î± Ï„Î± Ï€ÏÎ¬Î³Î¼Î±Ï„Î± Ï€ÏÎ¹Î½ Î±Ï€ÏŒ "
"Ï„Î¹Ï‚ Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹ÎµÏ‚."

#: src/welcome-day-1.md:25
#, fuzzy
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î¿Î»ÏÏ„Ï‰Ï‚ ÎµÎ½Ï„Î¬Î¾ÎµÎ¹! Î— ÎµÏ€Î±Î½Î¬Î»Î·ÏˆÎ· ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ Î¼Î­ÏÎ¿Ï‚ Ï„Î·Ï‚ "
"ÎºÎ»Î¯ÏƒÎ·Ï‚. Î˜Ï…Î¼Î¬Î¼Î±Î¹ ÏŒÏ„Î¹ Î¿Î¹ Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹ÎµÏ‚ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»ÏÏ‚ Î¼Î¹Î± Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· ÎºÎ±Î¹ ÎµÎ¯ÏƒÏ„Îµ "
"ÎµÎ»ÎµÏÎ¸ÎµÏÎ¿Î¹ Î½Î± Ï„Î¹Ï‚ Ï€Î±ÏÎ±Î»ÎµÎ¯ÏˆÎµÏ„Îµ ÏŒÏ€Ï‰Ï‚ ÎµÏƒÎµÎ¯Ï‚ Î±ÏÎ­ÏƒÎµÎ¹."

#: src/welcome-day-1.md:29
#, fuzzy
msgid ""
"The idea for the first day is to show _just enough_ of Rust to be able to "
"speak about the famous borrow checker. The way Rust handles memory is a "
"major feature and we should show students this right away."
msgstr ""
"Î— Î¹Î´Î­Î± Î³Î¹Î± Ï„Î·Î½ Ï€ÏÏÏ„Î· Î¼Î­ÏÎ± ÎµÎ¯Î½Î±Î¹ Î½Î± Î´ÎµÎ¯Î¾Î¿Ï…Î¼Îµ _Î±ÏÎºÎµÏ„Î¬_ Rust Î³Î¹Î± Î½Î± Î¼Ï€Î¿ÏÎ­ÏƒÎµÎ¹ Î½Î± "
"Î¼Î¹Î»Î®ÏƒÎµÎ¹ Î³Î¹Î± Ï„Î¿ Ï€ÎµÏÎ¯Ï†Î·Î¼Î¿ Î´Î¬Î½ÎµÎ¹Î¿ Ï€Î¿ÏÎ»Î¹. ÎŸ Ï„ÏÏŒÏ€Î¿Ï‚ Î¼Îµ Ï„Î¿Î½ Î¿Ï€Î¿Î¯Î¿ Î· Rust "
"Ï‡ÎµÎ¹ÏÎ¯Î¶ÎµÏ„Î±Î¹ Ï„Î· Î¼Î½Î®Î¼Î· ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ ÎºÎ±Î¹ Î±Ï…Ï„ÏŒ Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"Ï„Î¿ Î´ÎµÎ¯Î¾Î¿Ï…Î¼Îµ Î±Î¼Î­ÏƒÏ‰Ï‚ ÏƒÏ„Î¿Ï…Ï‚ Î¼Î±Î¸Î·Ï„Î­Ï‚."

#: src/welcome-day-1.md:33
#, fuzzy
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. We suggest splitting the day into two parts (following the slides):"
msgstr ""
"Î•Î¬Î½ Ï„Î¿ Î´Î¹Î´Î¬ÏƒÎºÎµÏ„Îµ ÏƒÎµ Î¼Î¹Î± Ï„Î¬Î¾Î·, Î±Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÎºÎ±Î»ÏŒ Î¼Î­ÏÎ¿Ï‚ Î³Î¹Î± Î½Î± Ï„Î¿ Î´ÎµÎ¯Ï„Îµ "
"Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î±. Î ÏÎ¿Ï„ÎµÎ¯Î½Î¿Ï…Î¼Îµ Î½Î± Ï‡Ï‰ÏÎ¯ÏƒÎµÏ„Îµ Ï„Î·Î½ Î·Î¼Î­ÏÎ± ÏƒÎµ Î´ÏÎ¿ Î¼Î­ÏÎ· (Î±ÎºÎ¿Î»Î¿Ï…Î¸ÏÎ½Ï„Î±Ï‚ Ï„Î¹Ï‚ "
"Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹ÎµÏ‚):"

#: src/welcome-day-1.md:36
#, fuzzy
msgid "Morning: 9:00 to 12:00,"
msgstr "Î ÏÏ‰Î¯: 9:00 Î­Ï‰Ï‚ 12:00,"

#: src/welcome-day-1.md:37
#, fuzzy
msgid "Afternoon: 13:00 to 16:00."
msgstr "Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î±: 13:00 Î­Ï‰Ï‚ 16:00."

#: src/welcome-day-1.md:39
#, fuzzy
msgid ""
"You can of course adjust this as necessary. Please make sure to include "
"breaks, we recommend a break every hour!"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Ï†Ï…ÏƒÎ¹ÎºÎ¬ Î½Î± Ï„Î¿ Ï€ÏÎ¿ÏƒÎ±ÏÎ¼ÏŒÏƒÎµÏ„Îµ ÏŒÏ€Ï‰Ï‚ Î±Ï€Î±Î¹Ï„ÎµÎ¯Ï„Î±Î¹. Î¦ÏÎ¿Î½Ï„Î¯ÏƒÏ„Îµ Î½Î± "
"ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î¬Î²ÎµÏ„Îµ Î´Î¹Î±Î»ÎµÎ¯Î¼Î¼Î±Ï„Î±, Ï€ÏÎ¿Ï„ÎµÎ¯Î½Î¿Ï…Î¼Îµ Î­Î½Î± Î´Î¹Î¬Î»ÎµÎ¹Î¼Î¼Î± ÎºÎ¬Î¸Îµ ÏÏÎ±!"

#: src/welcome-day-1/what-is-rust.md:3
#, fuzzy
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Î— Rust ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î½Î­Î± Î³Î»ÏÏƒÏƒÎ± Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î¿Ï Ï€Î¿Ï… ÎºÏ…ÎºÎ»Î¿Ï†ÏŒÏÎ·ÏƒÎµ Ï„Î¿ 1.0 Ï„Î¿ 2015:"

#: src/welcome-day-1/what-is-rust.md:5
#, fuzzy
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr ""
"Î— Rust ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÏƒÏ„Î±Ï„Î¹ÎºÎ¬ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÎ¼Î­Î½Î· Î³Î»ÏÏƒÏƒÎ± Î¼Îµ Ï€Î±ÏÏŒÎ¼Î¿Î¹Î¿ ÏÏŒÎ»Î¿ Î¼Îµ Ï„Î· C++"

#: src/welcome-day-1/what-is-rust.md:6
#, fuzzy
msgid "`rustc` uses LLVM as its backend."
msgstr "Î¤Î¿ \"rustc\" Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ LLVM Ï‰Ï‚ backend Ï„Î¿Ï…."

#: src/welcome-day-1/what-is-rust.md:7
#, fuzzy
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Î¤Î¿ Rust Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÎ¹ Ï€Î¿Î»Î»Î­Ï‚ [Ï€Î»Î±Ï„Ï†ÏŒÏÎ¼ÎµÏ‚ ÎºÎ±Î¹ Î±ÏÏ‡Î¹Ï„ÎµÎºÏ„Î¿Î½Î¹ÎºÎ­Ï‚](https://doc.rust-"
"lang.org/nightly/rustc/platform-support.html):"

#: src/welcome-day-1/what-is-rust.md:9
#, fuzzy
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86, ARM, WebAssembly, ..."

#: src/welcome-day-1/what-is-rust.md:10
#, fuzzy
msgid "Linux, Mac, Windows, ..."
msgstr "Linux, Mac, Windows, ..."

#: src/welcome-day-1/what-is-rust.md:11
#, fuzzy
msgid "Rust is used for a wide range of devices:"
msgstr "Î¤Î¿ Rust Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Î­Î½Î± ÎµÏ…ÏÏ Ï†Î¬ÏƒÎ¼Î± ÏƒÏ…ÏƒÎºÎµÏ…ÏÎ½:"

#: src/welcome-day-1/what-is-rust.md:12
#, fuzzy
msgid "firmware and boot loaders,"
msgstr "Ï…Î»Î¹ÎºÎ¿Î»Î¿Î³Î¹ÏƒÎ¼Î¹ÎºÏŒ ÎºÎ±Î¹ Ï†Î¿ÏÏ„Ï‰Ï„Î­Ï‚ ÎµÎºÎºÎ¯Î½Î·ÏƒÎ·Ï‚,"

#: src/welcome-day-1/what-is-rust.md:13
#, fuzzy
msgid "smart displays,"
msgstr "Î­Î¾Ï…Ï€Î½ÎµÏ‚ Î¿Î¸ÏŒÎ½ÎµÏ‚,"

#: src/welcome-day-1/what-is-rust.md:14
#, fuzzy
msgid "mobile phones,"
msgstr "ÎºÎ¹Î½Î·Ï„Î¬ Ï„Î·Î»Î­Ï†Ï‰Î½Î±,"

#: src/welcome-day-1/what-is-rust.md:15
#, fuzzy
msgid "desktops,"
msgstr "ÎµÏ€Î¹Ï„ÏÎ±Ï€Î­Î¶Î¹Î¿Î¹ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÏ„Î­Ï‚,"

#: src/welcome-day-1/what-is-rust.md:16
#, fuzzy
msgid "servers."
msgstr "Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚."

#: src/welcome-day-1/what-is-rust.md:21
#, fuzzy
msgid "Rust fits in the same area as C++:"
msgstr "Î— ÏƒÎºÎ¿Ï…ÏÎ¹Î¬ Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± Ï€ÎµÏÎ¹Î¿Ï‡Î® Î¼Îµ Ï„Î¿ C++:"

#: src/welcome-day-1/what-is-rust.md:23
#, fuzzy
msgid "High flexibility."
msgstr "Î¥ÏˆÎ·Î»Î® ÎµÏ…ÎµÎ»Î¹Î¾Î¯Î±."

#: src/welcome-day-1/what-is-rust.md:24
#, fuzzy
msgid "High level of control."
msgstr "Î¥ÏˆÎ·Î»ÏŒ ÎµÏ€Î¯Ï€ÎµÎ´Î¿ ÎµÎ»Î­Î³Ï‡Î¿Ï…."

#: src/welcome-day-1/what-is-rust.md:25
#, fuzzy
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr "ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± Î¼ÎµÎ¹Ï‰Î¸ÎµÎ¯ ÏƒÎµ Ï€Î¿Î»Ï Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ ÏƒÏ…ÏƒÎºÎµÏ…Î­Ï‚ ÏŒÏ€Ï‰Ï‚ ÎºÎ¹Î½Î·Ï„Î¬ Ï„Î·Î»Î­Ï†Ï‰Î½Î±."

#: src/welcome-day-1/what-is-rust.md:26
#, fuzzy
msgid "Has no runtime or garbage collection."
msgstr "Î”ÎµÎ½ Î­Ï‡ÎµÎ¹ Ï‡ÏÏŒÎ½Î¿ ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚ Î® ÏƒÏ…Î»Î»Î¿Î³Î® ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¹ÏÎ½."

#: src/welcome-day-1/what-is-rust.md:27
#, fuzzy
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr ""
"Î•ÏƒÏ„Î¹Î¬Î¶ÎµÎ¹ ÏƒÏ„Î·Î½ Î±Î¾Î¹Î¿Ï€Î¹ÏƒÏ„Î¯Î± ÎºÎ±Î¹ Ï„Î·Î½ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Î¸Ï…ÏƒÎ¹Î¬Î¶ÎµÎ¹ Ï„Î·Î½ Î±Ï€ÏŒÎ´Î¿ÏƒÎ·."

#: src/hello-world.md:3
#, fuzzy
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr ""
"Î‘Ï‚ Î¼ÎµÏ„Î±Î²Î¿ÏÎ¼Îµ ÏƒÏ„Î¿ Î±Ï€Î»Î¿ÏÏƒÏ„ÎµÏÎ¿ Î´Ï…Î½Î±Ï„ÏŒ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Rust, Î­Î½Î± ÎºÎ»Î±ÏƒÎ¹ÎºÏŒ Hello World "
"Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î±:"

#: src/hello-world.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"Hello ğŸŒ!\");\n"
"}\n"
"```"
msgstr ""

#: src/hello-world.md:12
#, fuzzy
msgid "What you see:"
msgstr "Î¤Î¹ Î²Î»Î­Ï€ÎµÎ¹Ï‚:"

#: src/hello-world.md:14
#, fuzzy
msgid "Functions are introduced with `fn`."
msgstr "ÎŸÎ¹ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ ÎµÎ¹ÏƒÎ¬Î³Î¿Î½Ï„Î±Î¹ Î¼Îµ Ï„Î¿ Â«fnÂ»."

#: src/hello-world.md:15
#, fuzzy
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "Î¤Î± Î¼Ï€Î»Î¿Îº Î¿ÏÎ¹Î¿Î¸ÎµÏ„Î¿ÏÎ½Ï„Î±Î¹ Î¼Îµ ÏƒÎ³Î¿Ï…ÏÎ¬ Ï„Î¹ÏÎ¬Î½Ï„ÎµÏ‚ ÏŒÏ€Ï‰Ï‚ ÏƒÏ„Î¿ C ÎºÎ±Î¹ Ï„Î¿ C++."

#: src/hello-world.md:16
#, fuzzy
msgid "The `main` function is the entry point of the program."
msgstr "Î— Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Â«ÎºÏÏÎ¹Î±Â» ÎµÎ¯Î½Î±Î¹ Ï„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ ÎµÎ¹ÏƒÏŒÎ´Î¿Ï… Ï„Î¿Ï… Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚."

#: src/hello-world.md:17
#, fuzzy
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr ""
"Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ Ï…Î³Î¹ÎµÎ¹Î½Î­Ï‚ Î¼Î±ÎºÏÎ¿ÎµÎ½Ï„Î¿Î»Î­Ï‚, Ï„Î¿ Â«println!Â» ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Î±Ï…Ï„Î¿Ï."

#: src/hello-world.md:18
#, fuzzy
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr ""
"ÎŸÎ¹ ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚ Rust Î­Ï‡Î¿Ï…Î½ ÎºÏ‰Î´Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· UTF-8 ÎºÎ±Î¹ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Ï€ÎµÏÎ¹Î­Ï‡Î¿Ï…Î½ "
"Î¿Ï€Î¿Î¹Î¿Î½Î´Î®Ï€Î¿Ï„Îµ Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎ± Unicode."

#: src/hello-world.md:22
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next three days so we start small with something "
"familiar."
msgstr ""
"Î‘Ï…Ï„Î® Î· Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸ÎµÎ¯ Î½Î± ÎºÎ¬Î½ÎµÎ¹ Ï„Î¿Ï…Ï‚ Î¼Î±Î¸Î·Ï„Î­Ï‚ Î¬Î½ÎµÏ„Î± Î¼Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± Rust. "
"Î˜Î± Î´Î¿Ï…Î½ Î­Î½Î±Ï‚ Ï„ÏŒÎ½Î¿Ï‚ Î±Ï€ÏŒ Î±Ï…Ï„ÏŒ Ï„Î¹Ï‚ ÎµÏ€ÏŒÎ¼ÎµÎ½ÎµÏ‚ Ï„Î­ÏƒÏƒÎµÏÎ¹Ï‚ Î·Î¼Î­ÏÎµÏ‚, Î¿Ï€ÏŒÏ„Îµ Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ "
"Î¼Î¹ÎºÏÎ¬ Î¼Îµ ÎºÎ¬Ï„Î¹ Î¿Î¹ÎºÎµÎ¯Î¿."

#: src/hello-world.md:27
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""

#: src/hello-world.md:31
msgid "Rust is modern with full support for things like Unicode."
msgstr ""

#: src/hello-world.md:33
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](basic-syntax/functions-interlude.md))."
msgstr ""

#: src/hello-world.md:36
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""

#: src/hello-world.md:40
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""

#: src/hello-world/small-example.md:3
#, fuzzy
msgid "Here is a small example program in Rust:"
msgstr "Î‘ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Î­Î½Î± Î¼Î¹ÎºÏÏŒ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚ ÏƒÏ„Î¿ Rust:"

#: src/hello-world/small-example.md:5
msgid ""
"```rust,editable\n"
"fn main() {              // Program entry point\n"
"    let mut x: i32 = 6;  // Mutable variable binding\n"
"    print!(\"{x}\");       // Macro for printing, like printf\n"
"    while x != 1 {       // No parenthesis around expression\n"
"        if x % 2 == 0 {  // Math like in other languages\n"
"            x = x / 2;\n"
"        } else {\n"
"            x = 3 * x + 1;\n"
"        }\n"
"        print!(\" -> {x}\");\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/hello-world/small-example.md:23
#, fuzzy
msgid ""
"The code implements the Collatz conjecture: it is believed that the loop "
"will always end, but this is not yet proved. Edit the code and play with "
"different inputs."
msgstr ""
"ÎŸ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î·Î½ ÎµÎ¹ÎºÎ±ÏƒÎ¯Î± Collatz: Ï€Î¹ÏƒÏ„ÎµÏÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î¿ Î²ÏÏŒÏ‡Î¿Ï‚ Î¸Î± Ï€Î¬Î½Ï„Î± "
"Ï„ÎµÎ»ÎµÎ¹ÏÎ½ÎµÎ¹, Î±Î»Î»Î¬ Î±Ï…Ï„ÏŒ Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ Î±ÎºÏŒÎ¼Î· Î±Ï€Î¿Î´ÎµÎ¹Ï‡Î¸ÎµÎ¯. Î•Ï€ÎµÎ¾ÎµÏÎ³Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± "
"ÎºÎ±Î¹ Ï€Î±Î¯Î¾Ï„Îµ Î¼Îµ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬ ÎµÎ¹ÏƒÏÎ¿Î­Ï‚."

#: src/hello-world/small-example.md:29
msgid ""
"Explain that all variables are statically typed. Try removing `i32` to "
"trigger type inference. Try with `i8` instead and trigger a runtime integer "
"overflow."
msgstr ""

#: src/hello-world/small-example.md:32
msgid "Change `let mut x` to `let x`, discuss the compiler error."
msgstr ""

#: src/hello-world/small-example.md:34
msgid ""
"Show how `print!` gives a compilation error if the arguments don't match the "
"format string."
msgstr ""

#: src/hello-world/small-example.md:37
msgid ""
"Show how you need to use `{}` as a placeholder if you want to print an "
"expression which is more complex than just a single variable."
msgstr ""

#: src/hello-world/small-example.md:40
msgid ""
"Show the students the standard library, show them how to search for `std::"
"fmt` which has the rules of the formatting mini-language. It's important "
"that the students become familiar with searching in the standard library."
msgstr ""

#: src/hello-world/small-example.md:44
msgid ""
"In a shell `rustup doc std::fmt` will open a browser on the local std::fmt "
"documentation"
msgstr ""

#: src/why-rust.md:3
#, fuzzy
msgid "Some unique selling points of Rust:"
msgstr "ÎœÎµÏÎ¹ÎºÎ¬ Î¼Î¿Î½Î±Î´Î¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î± Ï€ÏÎ»Î·ÏƒÎ·Ï‚ Ï„Î¿Ï… Rust:"

#: src/why-rust.md:5
#, fuzzy
msgid "Compile time memory safety."
msgstr "Î£Ï…Î³ÎºÎµÎ½Ï„ÏÏÏƒÏ„Îµ Ï„Î·Î½ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Ï„Î·Ï‚ Î¼Î½Î®Î¼Î·Ï‚ Ï‡ÏÏŒÎ½Î¿Ï…."

#: src/why-rust.md:6
#, fuzzy
msgid "Lack of undefined runtime behavior."
msgstr "ÎˆÎ»Î»ÎµÎ¹ÏˆÎ· Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î·Ï‚ ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚."

#: src/why-rust.md:7
#, fuzzy
msgid "Modern language features."
msgstr "Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ ÏƒÏÎ³Ï‡ÏÎ¿Î½Î·Ï‚ Î³Î»ÏÏƒÏƒÎ±Ï‚."

#: src/why-rust.md:11
#, fuzzy
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr ""
"Î¦ÏÎ¿Î½Ï„Î¯ÏƒÏ„Îµ Î½Î± ÏÏ‰Ï„Î®ÏƒÎµÏ„Îµ Ï„Î·Î½ Ï„Î¬Î¾Î· Î¼Îµ Ï€Î¿Î¹ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚ Î­Ï‡Î¿Ï…Î½ ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î±. Î£Îµ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· "
"ÏƒÏ„Î·Î½ Î±Ï€Î¬Î½Ï„Î·ÏƒÎ· Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Ï„Î¿Ï… Rust:"

#: src/why-rust.md:14
#, fuzzy
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"Î•Î¼Ï€ÎµÎ¹ÏÎ¯Î± Î¼Îµ Java, Go, Python, JavaScript...: ÎˆÏ‡ÎµÏ„Îµ Ï„Î·Î½ Î¯Î´Î¹Î± Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Î¼Î½Î®Î¼Î·Ï‚ "
"ÏŒÏ€Ï‰Ï‚ ÏƒÎµ Î±Ï…Ï„Î­Ï‚ Ï„Î¹Ï‚ Î³Î»ÏÏƒÏƒÎµÏ‚, ÏƒÏ…Î½ Î­Î½Î± Ï€Î±ÏÏŒÎ¼Î¿Î¹Î¿ Î³Î»Ï‰ÏƒÏƒÎ¹ÎºÏŒ ÏƒÏ…Î½Î±Î¯ÏƒÎ¸Î·Î¼Î± Ï…ÏˆÎ·Î»Î¿Ï "
"ÎµÏ€Î¹Ï€Î­Î´Î¿Ï…. Î•Ï€Î¹Ï€Î»Î­Î¿Î½ Î­Ï‡ÎµÏ„Îµ Î³ÏÎ®Î³Î¿ÏÎ· ÎºÎ±Î¹ Ï€ÏÎ¿Î²Î»Î­ÏˆÎ¹Î¼Î· Î±Ï€ÏŒÎ´Î¿ÏƒÎ· ÏŒÏ€Ï‰Ï‚ C ÎºÎ±Î¹ C++ "
"(Ï‡Ï‰ÏÎ¯Ï‚ ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¿ÏƒÏ…Î»Î»Î­ÎºÏ„Î·) ÎºÎ±Î¸ÏÏ‚ ÎºÎ±Î¹ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÎµ Ï…Î»Î¹ÎºÏŒ Ï‡Î±Î¼Î·Î»Î¿Ï ÎµÏ€Î¹Ï€Î­Î´Î¿Ï… (ÏƒÎµ "
"Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· Ï€Î¿Ï… Ï„Î¿ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏƒÏ„Îµ)"

#: src/why-rust.md:19
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""

#: src/why-rust/compile-time.md:3
#, fuzzy
msgid "Static memory management at compile time:"
msgstr "Î”Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· ÏƒÏ„Î±Ï„Î¹ÎºÎ®Ï‚ Î¼Î½Î®Î¼Î·Ï‚ ÎºÎ±Ï„Î¬ Ï„Î¿ Ï‡ÏÏŒÎ½Î¿ Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚:"

#: src/why-rust/compile-time.md:5
#, fuzzy
msgid "No uninitialized variables."
msgstr "Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î¼Î· Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¹Î·Î¼Î­Î½ÎµÏ‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚."

#: src/why-rust/compile-time.md:6
#, fuzzy
msgid "No memory leaks (_mostly_, see notes)."
msgstr "Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´Î¹Î±ÏÏÎ¿Î­Ï‚ Î¼Î½Î®Î¼Î·Ï‚ (_ÎºÏ…ÏÎ¯Ï‰Ï‚_, Î²Î»Î­Ï€Îµ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚)."

#: src/why-rust/compile-time.md:7
#, fuzzy
msgid "No double-frees."
msgstr "Î§Ï‰ÏÎ¯Ï‚ Î´Î¹Ï€Î»ÏŒ Î´Ï‰ÏÎµÎ¬Î½."

#: src/why-rust/compile-time.md:8
#, fuzzy
msgid "No use-after-free."
msgstr "ÎšÎ±Î¼Î¯Î± Ï‡ÏÎ®ÏƒÎ·-Î¼ÎµÏ„Î¬-Î´Ï‰ÏÎµÎ¬Î½."

#: src/why-rust/compile-time.md:9
#, fuzzy
msgid "No `NULL` pointers."
msgstr "Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ Â«NULLÂ»."

#: src/why-rust/compile-time.md:10
#, fuzzy
msgid "No forgotten locked mutexes."
msgstr "ÎŒÏ‡Î¹ Î¾ÎµÏ‡Î±ÏƒÎ¼Î­Î½Î± ÎºÎ»ÎµÎ¹Î´Ï‰Î¼Î­Î½Î± mutexes."

#: src/why-rust/compile-time.md:11
#, fuzzy
msgid "No data races between threads."
msgstr "Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Î±Î³ÏÎ½ÎµÏ‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î¼ÎµÏ„Î±Î¾Ï Ï„Ï‰Î½ Î½Î·Î¼Î¬Ï„Ï‰Î½."

#: src/why-rust/compile-time.md:12
#, fuzzy
msgid "No iterator invalidation."
msgstr "Î§Ï‰ÏÎ¯Ï‚ Î±ÎºÏÏÏ‰ÏƒÎ· ÎµÏ€Î±Î½Î±Î»Î·Ï€Ï„Î¹ÎºÎ¿Ï."

#: src/why-rust/compile-time.md:16
#, fuzzy
msgid ""
"It is possible to produce memory leaks in (safe) Rust. Some examples are:"
msgstr ""
"Î•Î¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒ Î½Î± Ï€ÏÎ¿ÎºÎ»Î·Î¸Î¿ÏÎ½ Î´Î¹Î±ÏÏÎ¿Î­Ï‚ Î¼Î½Î®Î¼Î·Ï‚ ÏƒÏ„Î¿ (Î±ÏƒÏ†Î±Î»Î­Ï‚) Rust. ÎœÎµÏÎ¹ÎºÎ¬ "
"Ï€Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î± ÎµÎ¯Î½Î±Î¹:"

#: src/why-rust/compile-time.md:19
#, fuzzy
msgid ""
"You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
"html#method.leak) to leak a pointer. A use of this could be to get runtime-"
"initialized and runtime-sized static variables"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ [`Box::leak`](https://doc.rust-lang.org/std/"
"boxed/struct.Box.html#method.leak) Î³Î¹Î± Î½Î± Î´Î¹Î±ÏÏÎµÏÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î´ÎµÎ¯ÎºÏ„Î·. ÎœÎ¹Î± Ï‡ÏÎ®ÏƒÎ· "
"Î±Ï…Ï„Î¿Ï Î¸Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎµ Î½Î± Î»Î¬Î²ÎµÏ„Îµ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Î¼Îµ Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· Ï‡ÏÏŒÎ½Î¿Ï… "
"ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚ ÎºÎ±Î¹ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚"

#: src/why-rust/compile-time.md:21
#, fuzzy
msgid ""
"You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
"html) to make the compiler \"forget\" about a value (meaning the destructor "
"is never run)."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ [`std::mem::forget`](https://doc.rust-lang."
"org/std/mem/fn.forget.html) Î³Î¹Î± Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ Ï„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Î½Î± \"Î¾ÎµÏ‡Î¬ÏƒÎµÎ¹\" "
"Î¼Î¹Î± Ï„Î¹Î¼Î® (Ï€Î¿Ï… ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†Î­Î±Ï‚ Î´ÎµÎ½ ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Î±Î¹ Ï€Î¿Ï„Î­)."

#: src/why-rust/compile-time.md:23
#, fuzzy
msgid ""
"You can also accidentally create a [reference cycle](https://doc.rust-lang."
"org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ ÎºÎ±Ï„Î¬ Î»Î¬Î¸Î¿Ï‚ Î­Î½Î±Î½ \\[ÎºÏÎºÎ»Î¿ Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚\\] Î¼Îµ "
"\"Rc\" Î® Â«Î¤ÏŒÎ¾Î¿Â»."

#: src/why-rust/compile-time.md:25
#, fuzzy
msgid ""
"In fact, some will consider infinitely populating a collection a memory leak "
"and Rust does not protect from those."
msgstr ""
"Î£Ï„Î·Î½ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒÏ„Î·Ï„Î±, Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿Î¹ Î¸Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎ¿Ï…Î½ Ï„Î¿ ÎµÎ½Î´ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ Î½Î± ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÎ¿Ï…Î½ "
"Î¬Ï€ÎµÎ¹ÏÎ± Î¼Î¹Î± ÏƒÏ…Î»Î»Î¿Î³Î® Ï‰Ï‚ Î±Î½Î¬Î¼Î½Î·ÏƒÎ· Î´Î¹Î±ÏÏÎ¿Î® ÎºÎ±Î¹ Î· Rust Î´ÎµÎ½ Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏÎµÎ¹ Î±Ï€ÏŒ Î±Ï…Ï„Î¬."

#: src/why-rust/compile-time.md:28
#, fuzzy
msgid ""
"For the purpose of this course, \"No memory leaks\" should be understood as "
"\"Pretty much no _accidental_ memory leaks\"."
msgstr ""
"Î“Î¹Î± Ï„Î¿Ï…Ï‚ ÏƒÎºÎ¿Ï€Î¿ÏÏ‚ Î±Ï…Ï„Î¿Ï Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚, Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î³Î¯Î½ÎµÎ¹ ÎºÎ±Ï„Î±Î½Î¿Î·Ï„ÏŒ Ï„Î¿ \"No "
"memory leaks\". Ï‰Ï‚ \"Î£Ï‡ÎµÎ´ÏŒÎ½ ÎºÎ±Î¼Î¯Î± _Ï„Ï…Ï‡Î±Î¯Î±_ Î´Î¹Î±ÏÏÎ¿Î® Î¼Î½Î®Î¼Î·Ï‚\"."

#: src/why-rust/runtime.md:3
#, fuzzy
msgid "No undefined behavior at runtime:"
msgstr "Î§Ï‰ÏÎ¯Ï‚ Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ ÎºÎ±Ï„Î¬ Ï„Î¿ Ï‡ÏÏŒÎ½Î¿ ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚:"

#: src/why-rust/runtime.md:5
#, fuzzy
msgid "Array access is bounds checked."
msgstr "Î— Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÎµ Ï€Î¯Î½Î±ÎºÎ± Î­Ï‡ÎµÎ¹ ÎµÏ€Î¹Î»ÎµÎ³ÎµÎ¯ Ï„Î± ÏŒÏÎ¹Î±."

#: src/why-rust/runtime.md:6
#, fuzzy
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "ÎŸÏÎ¯Î¶ÎµÏ„Î±Î¹ Ï…Ï€ÎµÏÏ‡ÎµÎ¯Î»Î¹ÏƒÎ· Î±ÎºÎ­ÏÎ±Î¹Î¿Ï… Î±ÏÎ¹Î¸Î¼Î¿Ï."

#: src/why-rust/runtime.md:12
#, fuzzy
msgid ""
"Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
"lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
"flag. If enabled, the program will panic (a controlled crash of the "
"program), otherwise you get wrap-around semantics. By default, you get "
"panics in debug mode (`cargo build`) and wrap-around in release mode (`cargo "
"build --release`)."
msgstr ""
"Î— Ï…Ï€ÎµÏÏ‡ÎµÎ¯Î»Î¹ÏƒÎ· Î±ÎºÎ­ÏÎ±Î¹Î¿Ï… Î±ÏÎ¹Î¸Î¼Î¿Ï Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î¼Î­ÏƒÏ‰ Î¼Î¹Î±Ï‚ ÎµÏ€Î¹ÏƒÎ®Î¼Î±Î½ÏƒÎ·Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… "
"Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚. ÎŸÎ¹ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚ ÎµÎ¯Î½Î±Î¹ ÎµÎ¯Ï„Îµ Î­Î½Î±Ï‚ Ï€Î±Î½Î¹ÎºÏŒÏ‚ (Î­Î½Î± ÎµÎ»ÎµÎ³Ï‡ÏŒÎ¼ÎµÎ½Î¿ crash Ï„Î¿Ï… "
"Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚) ÎµÎ¯Ï„Îµ Î½Î± Î±Î½Î±Î´Î¹Ï€Î»Ï‰Î¸ÎµÎ¯ ÏƒÎ·Î¼Î±ÏƒÎ¹Î¿Î»Î¿Î³Î¯Î±. Î‘Ï€ÏŒ Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®, Î»Î±Î¼Î²Î¬Î½ÎµÏ„Îµ "
"Ï€Î±Î½Î¹ÎºÏŒ ÏƒÏ„Î· Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± ÎµÎ½Ï„Î¿Ï€Î¹ÏƒÎ¼Î¿Ï ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ (\"ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î® Ï†Î¿ÏÏ„Î¯Î¿Ï…\") ÎºÎ±Î¹ "
"Ï€ÎµÏÎ¹Ï„ÏÎ»Î¹Î¾Î· ÏƒÎµ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Î±Ï€ÎµÎ»ÎµÏ…Î¸Î­ÏÏ‰ÏƒÎ·Ï‚ (Â«ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î® Ï†Î¿ÏÏ„Î¯Î¿Ï… --Î±Ï€ÎµÎ»ÎµÏ…Î¸Î­ÏÏ‰ÏƒÎ·Â»)."

#: src/why-rust/runtime.md:18
msgid ""
"Bounds checking cannot be disabled with a compiler flag. It can also not be "
"disabled directly with the `unsafe` keyword. However, `unsafe` allows you to "
"call functions such as `slice::get_unchecked` which does not do bounds "
"checking."
msgstr ""

#: src/why-rust/modern.md:3
#, fuzzy
msgid "Rust is built with all the experience gained in the last decades."
msgstr ""
"Î¤Î¿ Rust ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î¬Î¶ÎµÏ„Î±Î¹ Î¼Îµ ÏŒÎ»Î· Ï„Î·Î½ ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î± Ï€Î¿Ï… Î±Ï€Î¿ÎºÏ„Î®Î¸Î·ÎºÎµ Ï„Î± Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± 40 "
"Ï‡ÏÏŒÎ½Î¹Î±."

#: src/why-rust/modern.md:5
#, fuzzy
msgid "Language Features"
msgstr "Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Î³Î»ÏÏƒÏƒÎ±Ï‚"

#: src/why-rust/modern.md:7
#, fuzzy
msgid "Enums and pattern matching."
msgstr "Î‘ÏÎ¹Î¸Î¼Î¿Î¯ ÎºÎ±Î¹ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î¼Î¿Ï„Î¯Î²Ï‰Î½."

#: src/why-rust/modern.md:8
#, fuzzy
msgid "Generics."
msgstr "Î“ÎµÎ½ÏŒÏƒÎ·Î¼Î±."

#: src/why-rust/modern.md:9
#, fuzzy
msgid "No overhead FFI."
msgstr "ÎŒÏ‡Î¹ Î³ÎµÎ½Î¹ÎºÎ¬ FFI."

#: src/why-rust/modern.md:10
#, fuzzy
msgid "Zero-cost abstractions."
msgstr "Î‘Ï†Î±Î¹ÏÎ­ÏƒÎµÎ¹Ï‚ Î¼Î·Î´ÎµÎ½Î¹ÎºÎ¿Ï ÎºÏŒÏƒÏ„Î¿Ï…Ï‚."

#: src/why-rust/modern.md:12
#, fuzzy
msgid "Tooling"
msgstr "Î•ÏÎ³Î±Î»ÎµÎ¯Î±"

#: src/why-rust/modern.md:14
#, fuzzy
msgid "Great compiler errors."
msgstr "ÎœÎµÎ³Î¬Î»Î± Î»Î¬Î¸Î· Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®."

#: src/why-rust/modern.md:15
#, fuzzy
msgid "Built-in dependency manager."
msgstr "Î•Î½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î¿Ï‚ Î´Î¹Î±Ï‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î®Ï‚ ÎµÎ¾Î±ÏÏ„Î®ÏƒÎµÏ‰Î½."

#: src/why-rust/modern.md:16
#, fuzzy
msgid "Built-in support for testing."
msgstr "Î•Î½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î· Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Î´Î¿ÎºÎ¹Î¼Î­Ï‚."

#: src/why-rust/modern.md:17
#, fuzzy
msgid "Excellent Language Server Protocol support."
msgstr "Î•Î¾Î±Î¹ÏÎµÏ„Î¹ÎºÎ® Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Ï€ÏÏ‰Ï„Î¿ÎºÏŒÎ»Î»Î¿Ï… Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î® Î³Î»ÏÏƒÏƒÎ±Ï‚."

#: src/why-rust/modern.md:23
msgid ""
"Zero-cost abstractions, similar to C++, means that you don't have to 'pay' "
"for higher-level programming constructs with memory or CPU. For example, "
"writing a loop using `for` should result in roughly the same low level "
"instructions as using the `.iter().fold()` construct."
msgstr ""

#: src/why-rust/modern.md:28
msgid ""
"It may be worth mentioning that Rust enums are 'Algebraic Data Types', also "
"known as 'sum types', which allow the type system to express things like "
"`Option<T>` and `Result<T, E>`."
msgstr ""

#: src/why-rust/modern.md:32
msgid ""
"Remind people to read the errors --- many developers have gotten used to "
"ignore lengthy compiler output. The Rust compiler is significantly more "
"talkative than other compilers. It will often provide you with _actionable_ "
"feedback, ready to copy-paste into your code."
msgstr ""

#: src/why-rust/modern.md:37
msgid ""
"The Rust standard library is small compared to languages like Java, Python, "
"and Go. Rust does not come with several things you might consider standard "
"and essential:"
msgstr ""

#: src/why-rust/modern.md:41
msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
msgstr ""

#: src/why-rust/modern.md:42
msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
msgstr ""

#: src/why-rust/modern.md:43
msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
msgstr ""

#: src/why-rust/modern.md:45
msgid ""
"The reasoning behind this is that functionality in the standard library "
"cannot go away, so it has to be very stable. For the examples above, the "
"Rust community is still working on finding the best solution --- and perhaps "
"there isn't a single \"best solution\" for some of these things."
msgstr ""

#: src/why-rust/modern.md:50
msgid ""
"Rust comes with a built-in package manager in the form of Cargo and this "
"makes it trivial to download and compile third-party crates. A consequence "
"of this is that the standard library can be smaller."
msgstr ""

#: src/why-rust/modern.md:54
msgid ""
"Discovering good third-party crates can be a problem. Sites like <https://"
"lib.rs/> help with this by letting you compare health metrics for crates to "
"find a good and trusted one."
msgstr ""

#: src/why-rust/modern.md:58
msgid ""
"[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
"implementation used in major IDEs and text editors."
msgstr ""

#: src/basic-syntax.md:3
#, fuzzy
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "ÎœÎµÎ³Î¬Î»Î¿ Î¼Î­ÏÎ¿Ï‚ Ï„Î·Ï‚ ÏƒÏÎ½Ï„Î±Î¾Î·Ï‚ Rust Î¸Î± ÏƒÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿Î¹ÎºÎµÎ¯Î¿ Î±Ï€ÏŒ Ï„Î· C Î® Ï„Î· C++:"

#: src/basic-syntax.md:5
#, fuzzy
msgid "Blocks and scopes are delimited by curly braces."
msgstr "Î¤Î± Î¼Ï€Î»Î¿Îº ÎºÎ±Î¹ Ï„Î± Ï€ÎµÎ´Î¯Î± Î¿ÏÎ¹Î¿Î¸ÎµÏ„Î¿ÏÎ½Ï„Î±Î¹ Î¼Îµ ÏƒÎ³Î¿Ï…ÏÎ¬ Ï„Î¹ÏÎ¬Î½Ï„ÎµÏ‚."

#: src/basic-syntax.md:6
#, fuzzy
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr ""
"Î¤Î± ÏƒÏ‡ÏŒÎ»Î¹Î± Î³ÏÎ±Î¼Î¼Î®Ï‚ Î¾ÎµÎºÎ¹Î½Î¿ÏÎ½ Î¼Îµ `//`, Ï„Î± ÏƒÏ‡ÏŒÎ»Î¹Î± Î±Ï€Î¿ÎºÎ»ÎµÎ¹ÏƒÎ¼Î¿Ï Î¿ÏÎ¹Î¿Î¸ÎµÏ„Î¿ÏÎ½Ï„Î±Î¹ Î±Ï€ÏŒ "
"`/* ... */`."

#: src/basic-syntax.md:8
#, fuzzy
msgid "Keywords like `if` and `while` work the same."
msgstr "Î›Î­Î¾ÎµÎ¹Ï‚-ÎºÎ»ÎµÎ¹Î´Î¹Î¬ ÏŒÏ€Ï‰Ï‚ Â«Î±Î½Â» ÎºÎ±Î¹ Â«ÎµÎ½ÏÂ» Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÎ½ Ï„Î¿ Î¯Î´Î¹Î¿."

#: src/basic-syntax.md:9
#, fuzzy
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr "Î— Î±Î½Î¬Î¸ÎµÏƒÎ· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î®Ï‚ Î³Î¯Î½ÎµÏ„Î±Î¹ Î¼Îµ `=`, Î· ÏƒÏÎ³ÎºÏÎ¹ÏƒÎ· Î³Î¯Î½ÎµÏ„Î±Î¹ Î¼Îµ `==`."

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
#: src/exercises/day-3/safe-ffi-wrapper.md:16
#, fuzzy
msgid "Types"
msgstr ""
"\\| | Î¤ÏÏ€Î¿Î¹ | ÎšÏ…ÏÎ¹Î¿Î»ÎµÎºÏ„Î¹ÎºÎ¬ | "
"\\|------------------------------------------------- "
"-------------------------------------------------- --| \\| Î¥Ï€Î¿Î³ÎµÎ³ÏÎ±Î¼Î¼Î­Î½Î¿Î¹ "
"Î±ÎºÎ­ÏÎ±Î¹Î¿Î¹ Î±ÏÎ¹Î¸Î¼Î¿Î¯ | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, "
"`1_000`, `123i64` | \\| Î‘Î½Ï…Ï€ÏŒÎ³ÏÎ±Ï†Î¿Î¹ Î±ÎºÎ­ÏÎ±Î¹Î¿Î¹ Î±ÏÎ¹Î¸Î¼Î¿Î¯ | Â«u8Â», Â«u16Â», Â«u32Â», "
"Â«u64Â», Â«u128Â», Â«Ï‡ÏÎ®ÏƒÎ·Â» | `0`, `123`, `10u16` | \\| Î‘ÏÎ¹Î¸Î¼Î¿Î¯ ÎºÎ¹Î½Î·Ï„Î®Ï‚ "
"Ï…Ï€Î¿Î´Î¹Î±ÏƒÏ„Î¿Î»Î®Ï‚ | `f32`, `f64` | `3,14`, `-10,0e20`, `2f32` | \\| Î§Î¿ÏÎ´Î­Ï‚ | "
"`&str` | `\"foo\"`, `r#\"\\\\\"#` | \\| Î’Î±Î¸Î¼Ï‰Ï„Î­Ï‚ Ï„Î¹Î¼Î­Ï‚ Unicode | `Ï‡Î±Ï` | "
"`'a', `'Î±'`, `'âˆ'`| | Î£Ï…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚ byte |`&\\[u8\\]`|`b\"abc\"`, `br#\" \" "
"\"#\" | \\| Booleans | Â«Î¼Ï€Î¿Ï…Î»Â» | \"Î±Î»Î·Î¸Î­Ï‚\", \"ÏˆÎµÏ…Î´Î­Ï‚\" |"

#: src/basic-syntax/scalar-types.md:3 src/basic-syntax/compound-types.md:3
msgid "Literals"
msgstr ""

#: src/basic-syntax/scalar-types.md:5
msgid "Signed integers"
msgstr ""

#: src/basic-syntax/scalar-types.md:5
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr ""

#: src/basic-syntax/scalar-types.md:5
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr ""

#: src/basic-syntax/scalar-types.md:6
msgid "Unsigned integers"
msgstr ""

#: src/basic-syntax/scalar-types.md:6
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr ""

#: src/basic-syntax/scalar-types.md:6
msgid "`0`, `123`, `10_u16`"
msgstr ""

#: src/basic-syntax/scalar-types.md:7
msgid "Floating point numbers"
msgstr ""

#: src/basic-syntax/scalar-types.md:7
msgid "`f32`, `f64`"
msgstr ""

#: src/basic-syntax/scalar-types.md:7
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr ""

#: src/basic-syntax/scalar-types.md:8
msgid "Strings"
msgstr ""

#: src/basic-syntax/scalar-types.md:8
msgid "`&str`"
msgstr ""

#: src/basic-syntax/scalar-types.md:8
msgid "`\"foo\"`, `\"two\\nlines\"`"
msgstr ""

#: src/basic-syntax/scalar-types.md:9
msgid "Unicode scalar values"
msgstr ""

#: src/basic-syntax/scalar-types.md:9
msgid "`char`"
msgstr ""

#: src/basic-syntax/scalar-types.md:9
msgid "`'a'`, `'Î±'`, `'âˆ'`"
msgstr ""

#: src/basic-syntax/scalar-types.md:10
msgid "Booleans"
msgstr ""

#: src/basic-syntax/scalar-types.md:10
msgid "`bool`"
msgstr ""

#: src/basic-syntax/scalar-types.md:10
msgid "`true`, `false`"
msgstr ""

#: src/basic-syntax/scalar-types.md:12
#, fuzzy
msgid "The types have widths as follows:"
msgstr "ÎŸÎ¹ Ï„ÏÏ€Î¿Î¹ Î­Ï‡Î¿Ï…Î½ Ï€Î»Î¬Ï„Î· Ï‰Ï‚ ÎµÎ¾Î®Ï‚:"

#: src/basic-syntax/scalar-types.md:14
#, fuzzy
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "Î¤Î± \"iN\", \"uN\" ÎºÎ±Î¹ \"fN\" Î­Ï‡Î¿Ï…Î½ Ï€Î»Î¬Ï„Î¿Ï‚ _N_ bit,"

#: src/basic-syntax/scalar-types.md:15
#, fuzzy
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "Î¤Î¿ \"isize\" ÎºÎ±Î¹ Ï„Î¿ \"usize\" ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Ï€Î»Î¬Ï„Î¿Ï‚ ÎµÎ½ÏŒÏ‚ Î´ÎµÎ¯ÎºÏ„Î·,"

#: src/basic-syntax/scalar-types.md:16
#, fuzzy
msgid "`char` is 32 bits wide,"
msgstr "Î¤Î¿ \"char\" Î­Ï‡ÎµÎ¹ Ï€Î»Î¬Ï„Î¿Ï‚ 32 bit,"

#: src/basic-syntax/scalar-types.md:17
#, fuzzy
msgid "`bool` is 8 bits wide."
msgstr "Î¤Î¿ Â«boolÂ» Î­Ï‡ÎµÎ¹ Ï€Î»Î¬Ï„Î¿Ï‚ 8 bit."

#: src/basic-syntax/scalar-types.md:21
msgid "There are a few syntaxes which are not shown above:"
msgstr ""

#: src/basic-syntax/scalar-types.md:23
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""

#: src/basic-syntax/scalar-types.md:27
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(r#\"<a href=\"link.html\">link</a>\"#);\n"
"    println!(\"<a href=\\\"link.html\\\">link</a>\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scalar-types.md:34
#, fuzzy
msgid "Byte strings allow you to create a `&[u8]` value directly:"
msgstr ""
"ÎŸÎ¹ Î±Ï€Î±ÏÎ¹Î¸Î¼Î®ÏƒÎµÎ¹Ï‚ ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î½ Î½Î± ÏƒÏ…Î»Î»Î­Î³ÎµÏ„Îµ Î­Î½Î± ÏƒÏÎ½Î¿Î»Î¿ Ï„Î¹Î¼ÏÎ½ ÎºÎ¬Ï„Ï‰ Î±Ï€ÏŒ Î­Î½Î±Î½ "
"Ï„ÏÏ€Î¿"

#: src/basic-syntax/scalar-types.md:36
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"{:?}\", b\"abc\");\n"
"    println!(\"{:?}\", &[97, 98, 99]);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scalar-types.md:43
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""

#: src/basic-syntax/compound-types.md:5
msgid "Arrays"
msgstr ""

#: src/basic-syntax/compound-types.md:5
msgid "`[T; N]`"
msgstr ""

#: src/basic-syntax/compound-types.md:5
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr ""

#: src/basic-syntax/compound-types.md:6
msgid "Tuples"
msgstr ""

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr ""

#: src/basic-syntax/compound-types.md:6
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr ""

#: src/basic-syntax/compound-types.md:8
#, fuzzy
msgid "Array assignment and access:"
msgstr "Î•ÎºÏ‡ÏÏÎ·ÏƒÎ· Ï€Î¯Î½Î±ÎºÎ± ÎºÎ±Î¹ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ·:"

#: src/basic-syntax/compound-types.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i8; 10] = [42; 10];\n"
"    a[5] = 0;\n"
"    println!(\"a: {:?}\", a);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:18
#, fuzzy
msgid "Tuple assignment and access:"
msgstr "Î”Î¹Ï€Î»Î® Î±Î½Î¬Î¸ÎµÏƒÎ· ÎºÎ±Î¹ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ·:"

#: src/basic-syntax/compound-types.md:20
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let t: (i8, bool) = (7, true);\n"
"    println!(\"1st index: {}\", t.0);\n"
"    println!(\"2nd index: {}\", t.1);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/compound-types.md:32
#, fuzzy
msgid "Arrays:"
msgstr "Î Î¯Î½Î±ÎºÎµÏ‚:"

#: src/basic-syntax/compound-types.md:34
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types."
msgstr ""

#: src/basic-syntax/compound-types.md:38
msgid "We can use literals to assign values to arrays."
msgstr ""

#: src/basic-syntax/compound-types.md:40
msgid ""
"In the main function, the print statement asks for the debug implementation "
"with the `?` format parameter: `{}` gives the default output, `{:?}` gives "
"the debug output. We could also have used `{a}` and `{a:?}` without "
"specifying the value after the format string."
msgstr ""

#: src/basic-syntax/compound-types.md:45
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""

#: src/basic-syntax/compound-types.md:47
#, fuzzy
msgid "Tuples:"
msgstr "Î Î»ÎµÎ¹Î¬Î´ÎµÏ‚:"

#: src/basic-syntax/compound-types.md:49
#, fuzzy
msgid "Like arrays, tuples have a fixed length."
msgstr ""
"Î— Î¬Î´ÎµÎ¹Î± Ï€Î»ÎµÎ¹Î¬Î´Î± `()` ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î³Î½Ï‰ÏƒÏ„Î® Ï‰Ï‚ \"Ï„ÏÏ€Î¿Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚\". Î•Î¯Î½Î±Î¹ ÎºÎ±Î¹ "
"Ï„ÏÏ€Î¿Ï‚, ÎºÎ±Î¹ Î· Î¼ÏŒÎ½Î· Î­Î³ÎºÏ…ÏÎ· Ï„Î¹Î¼Î® Î±Ï…Ï„Î¿Ï Ï„Î¿Ï… Ï„ÏÏ€Î¿Ï… - Î´Î·Î»Î±Î´Î® ÎºÎ±Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ ÎºÎ±Î¹ Î· "
"Ï„Î¹Î¼Î® Ï„Î¿Ï… ÎµÎºÏ†ÏÎ¬Î¶Î¿Î½Ï„Î±Î¹ Ï‰Ï‚ Â«()Â». Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Î½Î± Ï…Ï€Î¿Î´ÎµÎ¯Î¾ÎµÎ¹, Î³Î¹Î± "
"Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, ÏŒÏ„Î¹ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î® Î— Î­ÎºÏ†ÏÎ±ÏƒÎ· Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ Ï„Î¹Î¼Î® ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚, ÏŒÏ€Ï‰Ï‚ Î¸Î± "
"Î´Î¿ÏÎ¼Îµ ÏƒÎµ Î¼Î¹Î± Î¼ÎµÎ»Î»Î¿Î½Ï„Î¹ÎºÎ® Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹Î±."

#: src/basic-syntax/compound-types.md:51
#, fuzzy
msgid "Tuples group together values of different types into a compound type."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÏƒÎºÎµÏ†Ï„ÎµÎ¯Ï„Îµ Ï‰Ï‚ Â«ÎºÎµÎ½ÏŒÂ» Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÏƒÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿Î¹ÎºÎµÎ¯Î¿ Î±Ï€ÏŒ Î¬Î»Î»Î¿Ï…Ï‚ "
"Î³Î»ÏÏƒÏƒÎµÏ‚ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î¿Ï."

#: src/basic-syntax/compound-types.md:53
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr ""

#: src/basic-syntax/compound-types.md:55
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type - that is to say both the type and its "
"value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide. "
msgstr ""

#: src/basic-syntax/compound-types.md:59
msgid ""
"You can think of it as `void` that can be familiar to you from other  "
"programming languages."
msgstr ""

#: src/basic-syntax/references.md:3
#, fuzzy
msgid "Like C++, Rust has references:"
msgstr "ÎŒÏ€Ï‰Ï‚ Î· C++, Ï„Î¿ Rust Î­Ï‡ÎµÎ¹ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚:"

#: src/basic-syntax/references.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x: i32 = 10;\n"
"    let ref_x: &mut i32 = &mut x;\n"
"    *ref_x = 20;\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references.md:14
#, fuzzy
msgid "Some notes:"
msgstr "ÎœÎµÏÎ¹ÎºÎ­Ï‚ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚:"

#: src/basic-syntax/references.md:16
#, fuzzy
msgid ""
"We must dereference `ref_x` when assigning to it, similar to C and C++ "
"pointers."
msgstr ""
"Î ÏÎ­Ï€ÎµÎ¹ Î½Î± Î¼Î·Î½ Î±Î½Î±Ï†Î­ÏÎ¿Ï…Î¼Îµ Ï„Î¿ Â«ref_xÂ» ÎºÎ±Ï„Î¬ Ï„Î·Î½ Î±Î½Î¬Î¸ÎµÏƒÎ· ÏƒÎµ Î±Ï…Ï„ÏŒ, Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ "
"Ï„Î¿Ï…Ï‚ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ C ÎºÎ±Î¹ C++."

#: src/basic-syntax/references.md:17
#, fuzzy
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `ref_x.count_ones()`)."
msgstr ""
"Î¤Î¿ Rust Î¸Î± ÎµÏ€Î±Î½Î±Ï†Î­ÏÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± ÏƒÎµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚, Î¹Î´Î¹Î±Î¯Ï„ÎµÏÎ± ÎºÎ±Ï„Î¬ Ï„Î·Î½ "
"ÎµÏ€Î¯ÎºÎ»Î·ÏƒÎ· Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ (Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Ï„Î¿ `ref_x.count_ones()`)."

#: src/basic-syntax/references.md:19
#, fuzzy
msgid ""
"References that are declared as `mut` can be bound to different values over "
"their lifetime."
msgstr ""
"ÎŸÎ¹ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚ Ï€Î¿Ï… Î´Î·Î»ÏÎ½Î¿Î½Ï„Î±Î¹ Ï‰Ï‚ Â«mutÂ» Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î´ÎµÏƒÎ¼ÎµÏ…Ï„Î¿ÏÎ½ ÏƒÎµ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ "
"Ï„Î¹Î¼Î­Ï‚ ÎºÎ±Ï„Î¬ Ï„Î· Î´Î¹Î¬ÏÎºÎµÎ¹Î± Ï„Î·Ï‚ Î¶Ï‰Î®Ï‚ Ï„Î¿Ï…Ï‚."

#: src/basic-syntax/references.md:25
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut ref_x: &i32` and `let ref_x: "
"&mut i32`. The first one represents a mutable reference which can be bound "
"to different values, while the second represents a reference to a mutable "
"value."
msgstr ""
"Î¦ÏÎ¿Î½Ï„Î¯ÏƒÏ„Îµ Î½Î± ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÏ„Îµ Ï„Î· Î´Î¹Î±Ï†Î¿ÏÎ¬ Î¼ÎµÏ„Î±Î¾Ï Ï„Î¿Ï… \"let mut ref_x: &i32\" ÎºÎ±Î¹ "
"Ï„Î¿Ï… \"let ref_x: &mut i32\\`. Î— Ï€ÏÏÏ„Î· Î±Î½Ï„Î¹Ï€ÏÎ¿ÏƒÏ‰Ï€ÎµÏÎµÎ¹ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î±Î½Î±Ï†Î¿ÏÎ¬ "
"ÏƒÏ„Î·Î½ Î¿Ï€Î¿Î¯Î± Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÏƒÏ…Î½Î´ÎµÎ¸ÎµÎ¯ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ Ï„Î¹Î¼Î­Ï‚, ÎµÎ½Ï Î· Î´ÎµÏÏ„ÎµÏÎ· "
"Î±Î½Ï„Î¹Ï€ÏÎ¿ÏƒÏ‰Ï€ÎµÏÎµÎ¹ Î¼Î¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎµ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Ï„Î¹Î¼Î®."

#: src/basic-syntax/references-dangling.md:3
#, fuzzy
msgid "Rust will statically forbid dangling references:"
msgstr "Î— ÏƒÎºÎ¿Ï…ÏÎ¹Î¬ Î¸Î± Î±Ï€Î±Î³Î¿ÏÎµÏÏƒÎµÎ¹ ÏƒÏ„Î±Ï„Î¹ÎºÎ¬ Ï„Î¹Ï‚ ÎºÏÎ­Î¼Î¿Î½Ï„Î±Î¹ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚:"

#: src/basic-syntax/references-dangling.md:5
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let ref_x: &i32;\n"
"    {\n"
"        let x: i32 = 10;\n"
"        ref_x = &x;\n"
"    }\n"
"    println!(\"ref_x: {ref_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/references-dangling.md:16
#, fuzzy
msgid "A reference is said to \"borrow\" the value it refers to."
msgstr "ÎœÎ¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ Î»Î­Î³ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ \"Î´Î±Î½ÎµÎ¯Î¶ÎµÏ„Î±Î¹\" Ï„Î·Î½ Ï„Î¹Î¼Î® ÏƒÏ„Î·Î½ Î¿Ï€Î¿Î¯Î± Î±Î½Î±Ï†Î­ÏÎµÏ„Î±Î¹."

#: src/basic-syntax/references-dangling.md:17
#, fuzzy
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough."
msgstr ""
"Î¤Î¿ Rust Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Ï„Î· Î´Î¹Î¬ÏÎºÎµÎ¹Î± Î¶Ï‰Î®Ï‚ ÏŒÎ»Ï‰Î½ Ï„Ï‰Î½ Î±Î½Î±Ï†Î¿ÏÏÎ½ Î³Î¹Î± Î½Î± Î´Î¹Î±ÏƒÏ†Î±Î»Î¯ÏƒÎµÎ¹ "
"ÏŒÏ„Î¹ Î¶Î¿Ï…Î½ Ï€Î¿Î»Ï Î±ÏÎºÎµÏ„Î¬."

#: src/basic-syntax/references-dangling.md:19
#, fuzzy
msgid "We will talk more about borrowing when we get to ownership."
msgstr "Î˜Î± Î¼Î¹Î»Î®ÏƒÎ¿Ï…Î¼Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ Î³Î¹Î± Î´Î±Î½ÎµÎ¹ÏƒÎ¼ÏŒ ÏŒÏ„Î±Î½ Ï†Ï„Î¬ÏƒÎ¿Ï…Î¼Îµ ÏƒÏ„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±."

#: src/basic-syntax/slices.md:3
#, fuzzy
msgid "A slice gives you a view into a larger collection:"
msgstr "ÎœÎ¹Î± Ï†Î­Ï„Î± ÏƒÎ¬Ï‚ Î´Î¯Î½ÎµÎ¹ Î¼Î¹Î± Ï€ÏÎ¿Î²Î¿Î»Î® ÏƒÎµ Î¼Î¹Î± Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ· ÏƒÏ…Î»Î»Î¿Î³Î®:"

#: src/basic-syntax/slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];\n"
"    println!(\"a: {a:?}\");\n"
"\n"
"    let s: &[i32] = &a[2..4];\n"
"\n"
"    println!(\"s: {s:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/slices.md:16
#, fuzzy
msgid "Slices borrow data from the sliced type."
msgstr "ÎŸÎ¹ Ï†Î­Ï„ÎµÏ‚ Î´Î±Î½ÎµÎ¯Î¶Î¿Î½Ï„Î±Î¹ Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î±Ï€ÏŒ Ï„Î¿Î½ Ï„ÏÏ€Î¿ ÏƒÎµ Ï†Î­Ï„ÎµÏ‚."

#: src/basic-syntax/slices.md:17
#, fuzzy
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr "Î•ÏÏÏ„Î·ÏƒÎ·: Î¤Î¹ Î¸Î± ÏƒÏ…Î¼Î²ÎµÎ¯ Î±Î½ Ï„ÏÎ¿Ï€Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Â«a\\[3\\]Â»;"

#: src/basic-syntax/slices.md:21
#, fuzzy
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr ""
"Î¤Î¿ `s` ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎµ Î­Î½Î± ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Ï„Î¿Ï… `i32`. Î Î±ÏÎ±Ï„Î·ÏÎ®ÏƒÏ„Îµ ÏŒÏ„Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ "
"`s` (`&[i32]`) Î´ÎµÎ½ Î±Î½Î±Ï†Î­ÏÎµÎ¹ Ï€Î»Î­Î¿Î½ Ï„Î¿ Î¼Î®ÎºÎ¿Ï‚ Ï„Î¿Ï… Ï€Î¯Î½Î±ÎºÎ±. Î‘Ï…Ï„ÏŒ Î¼Î±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"ÎºÎ¬Î½Î¿Ï…Î¼Îµ Ï…Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿ÏÏ‚ ÏƒÎµ Ï†Î­Ï„ÎµÏ‚ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏÎ½ Î¼ÎµÎ³ÎµÎ¸ÏÎ½."

#: src/basic-syntax/slices.md:23
#, fuzzy
msgid ""
"If the slice starts at index 0, Rustâ€™s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"ÎŸÎ¹ Ï†Î­Ï„ÎµÏ‚ Î´Î±Î½ÎµÎ¯Î¶Î¿Î½Ï„Î±Î¹ Ï€Î¬Î½Ï„Î± Î±Ï€ÏŒ Î¬Î»Î»Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿. Î£Îµ Î±Ï…Ï„ÏŒ Ï„Î¿ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Ï„Î¿ "
"Â«aÂ» Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€Î±ÏÎ±Î¼ÎµÎ¯Î½ÎµÎ¹ Â«Î¶Ï‰Î½Ï„Î±Î½ÏŒÂ» (ÏƒÏ„Î¿ Ï€ÎµÎ´Î¯Î¿ ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚) Î³Î¹Î± Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ ÏŒÏƒÎ¿ "
"Ï„Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Î¼Î±Ï‚."

#: src/basic-syntax/slices.md:25
#, fuzzy
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"Î— ÎµÏÏÏ„Î·ÏƒÎ· ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î·Î½ Ï„ÏÎ¿Ï€Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… Â«a\\[3\\]Â» Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÏÎ¿ÎºÎ±Î»Î­ÏƒÎµÎ¹ Î¼Î¹Î± "
"ÎµÎ½Î´Î¹Î±Ï†Î­ÏÎ¿Ï…ÏƒÎ± ÏƒÏ…Î¶Î®Ï„Î·ÏƒÎ·, Î±Î»Î»Î¬ Î· Î±Ï€Î¬Î½Ï„Î·ÏƒÎ· ÎµÎ¯Î½Î±Î¹ ÏŒÏ„Î¹ Î³Î¹Î± Î»ÏŒÎ³Î¿Ï…Ï‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ Ï„Î·Ï‚ "
"Î¼Î½Î®Î¼Î·Ï‚ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… \"a\" Î±Ï†Î¿Ï Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î­Î½Î± "
"slice, Î±Î»Î»Î¬ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î¹Î±Î²Î¬ÏƒÎµÏ„Îµ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î±Ï€ÏŒ Ï„Î¿ \"a\" ÎºÎ±Î¹ Ï„Î¿ \"s\" Î¼Îµ "
"Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î±. Î ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ Î¸Î± ÎµÏ€ÎµÎ¾Î·Î³Î·Î¸Î¿ÏÎ½ ÏƒÏ„Î·Î½ ÎµÎ½ÏŒÏ„Î·Ï„Î± ÎµÎ»Î­Î³Ï‡Î¿Ï… "
"Î´Î±Î½ÎµÎ¹ÏƒÎ¼Î¿Ï."

#: src/basic-syntax/slices.md:27
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr ""

#: src/basic-syntax/slices.md:29
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""

#: src/basic-syntax/slices.md:31
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice. "
msgstr ""

#: src/basic-syntax/slices.md:33
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used. More details will be explained "
"in the borrow checker section."
msgstr ""

#: src/basic-syntax/string-slices.md:1
#, fuzzy
msgid "`String` vs `str`"
msgstr "`String` vs `str`"

#: src/basic-syntax/string-slices.md:3
#, fuzzy
msgid "We can now understand the two string types in Rust:"
msgstr "ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Ï„ÏÏÎ± Î½Î± ÎºÎ±Ï„Î±Î½Î¿Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Ï…Ï‚ Î´ÏÎ¿ Ï„ÏÏ€Î¿Ï…Ï‚ Ï‡Î¿ÏÎ´ÏÎ½ ÏƒÏ„Î¿ Rust:"

#: src/basic-syntax/string-slices.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: &str = \"World\";\n"
"    println!(\"s1: {s1}\");\n"
"\n"
"    let mut s2: String = String::from(\"Hello \");\n"
"    println!(\"s2: {s2}\");\n"
"    s2.push_str(s1);\n"
"    println!(\"s2: {s2}\");\n"
"    \n"
"    let s3: &str = &s2[6..];\n"
"    println!(\"s3: {s3}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/string-slices.md:20
#, fuzzy
msgid "Rust terminology:"
msgstr "ÎŸÏÎ¿Î»Î¿Î³Î¯Î± ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚:"

#: src/basic-syntax/string-slices.md:22
#, fuzzy
msgid "`&str` an immutable reference to a string slice."
msgstr "Â«&strÂ» Î¼Î¹Î± Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î· Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎµ Î­Î½Î± ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬Ï‚."

#: src/basic-syntax/string-slices.md:23
#, fuzzy
msgid "`String` a mutable string buffer."
msgstr "\"String\" Î­Î½Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏŒ buffer ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÏÎ½."

#: src/basic-syntax/string-slices.md:27
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data  stored in a block of memory. String literals "
"(`â€Helloâ€`), are stored in the programâ€™s binary."
msgstr ""
"Î— Î¼Î±ÎºÏÎ¿ÎµÎ½Ï„Î¿Î»Î® Â«format!()Â» ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Î²Î¿Î»Î¹ÎºÏŒÏ‚ Ï„ÏÏŒÏ€Î¿Ï‚ Î³Î¹Î± Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î¼Î¹Î± "
"Î¹Î´Î¹ÏŒÎºÏ„Î·Ï„Î· ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬ Î±Ï€ÏŒ Î´Ï…Î½Î±Î¼Î¹ÎºÎ­Ï‚ Ï„Î¹Î¼Î­Ï‚. Î¤Î¿ Î´Î­Ï‡ÎµÏ„Î±Î¹ Ï„Î·Î½ Î¯Î´Î¹Î± Ï€ÏÎ¿Î´Î¹Î±Î³ÏÎ±Ï†Î® "
"Î¼Î¿ÏÏ†Î®Ï‚ Î¼Îµ Ï„Î¿ \"println!()\"."

#: src/basic-syntax/string-slices.md:30
#, fuzzy
msgid ""
"Rustâ€™s `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î±Î½ÎµÎ¹ÏƒÏ„ÎµÎ¯Ï„Îµ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹Î± Â«&strÂ» Î±Ï€ÏŒ Ï„Î¿ Â«StringÂ» Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… Â«&Â» ÎºÎ±Î¹ "
"Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ ÎµÏ€Î¹Î»Î¿Î³Î®Ï‚ ÎµÏÏÎ¿Ï…Ï‚."

#: src/basic-syntax/string-slices.md:32
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()`  creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"Î“Î¹Î± Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚ C++: ÏƒÎºÎµÏ†Ï„ÎµÎ¯Ï„Îµ Ï„Î¿ Â«&strÂ» Ï‰Ï‚ Â«const char\\*Â» Î±Ï€ÏŒ Ï„Î· C++, "
"Î±Î»Î»Î¬ Î±Ï…Ï„ÏŒ Ï€Î¿Ï… Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€Î¬Î½Ï„Î± ÏƒÎµ Î¼Î¹Î± Î­Î³ÎºÏ…ÏÎ· ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬ ÏƒÏ„Î· Î¼Î½Î®Î¼Î·. Î¤Î¿ Rust "
"Â«StringÂ» ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÎºÎ±Ï„Î¬ Ï€ÏÎ¿ÏƒÎ­Î³Î³Î¹ÏƒÎ· Î¹ÏƒÎ¿Î´ÏÎ½Î±Î¼Î¿ Ï„Î¿Ï… Â«std::stringÂ» Î±Ï€ÏŒ Ï„Î· C++ "
"(ÎºÏÏÎ¹Î± Î´Î¹Î±Ï†Î¿ÏÎ¬: Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î¼ÏŒÎ½Î¿ byte Î¼Îµ ÎºÏ‰Î´Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· UTF-8 ÎºÎ±Î¹ Î´ÎµÎ½ "
"Î¸Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹ Ï€Î¿Ï„Î­ Î²ÎµÎ»Ï„Î¹ÏƒÏ„Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î¼Î¹ÎºÏÎ®Ï‚ ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬Ï‚)."

#: src/basic-syntax/string-slices.md:35
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It  accepts the same format specification as `println!()`."
msgstr ""

#: src/basic-syntax/string-slices.md:38
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection."
msgstr ""

#: src/basic-syntax/string-slices.md:40
msgid ""
"For C++ programmers: think of `&str` as `const char*` from C++, but the one "
"that always points  to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++  (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""

#: src/basic-syntax/functions.md:3
#, fuzzy
msgid ""
"A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
"Fizz_buzz) interview question:"
msgstr ""
"ÎœÎ¹Î± Î­ÎºÎ´Î¿ÏƒÎ· Rust Ï„Î·Ï‚ Ï€ÎµÏÎ¯Ï†Î·Î¼Î·Ï‚ ÎµÏÏÏ„Î·ÏƒÎ·Ï‚ ÏƒÏ…Î½Î­Î½Ï„ÎµÏ…Î¾Î·Ï‚ [FizzBuzz](https://en."
"wikipedia.org/wiki/Fizz_buzz):"

#: src/basic-syntax/functions.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    print_fizzbuzz_to(20);\n"
"}\n"
"\n"
"fn is_divisible(n: u32, divisor: u32) -> bool {\n"
"    if divisor == 0 {\n"
"        return false;\n"
"    }\n"
"    n % divisor == 0\n"
"}\n"
"\n"
"fn fizzbuzz(n: u32) -> String {\n"
"    let fizz = if is_divisible(n, 3) { \"fizz\" } else { \"\" };\n"
"    let buzz = if is_divisible(n, 5) { \"buzz\" } else { \"\" };\n"
"    if fizz.is_empty() && buzz.is_empty() {\n"
"        return format!(\"{n}\");\n"
"    }\n"
"    format!(\"{fizz}{buzz}\")\n"
"}\n"
"\n"
"fn print_fizzbuzz_to(n: u32) {\n"
"    for i in 1..=n {\n"
"        println!(\"{}\", fizzbuzz(i));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions.md:35
msgid ""
"We refer in `main` to a function written below. Neither forward declarations "
"nor headers are necessary. "
msgstr ""

#: src/basic-syntax/functions.md:36
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr ""

#: src/basic-syntax/functions.md:37
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression."
msgstr ""

#: src/basic-syntax/functions.md:38
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""

#: src/basic-syntax/functions.md:39
msgid ""
"The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
"`=n`, which causes it to include the upper bound."
msgstr ""

#: src/basic-syntax/rustdoc.md:3
msgid ""
"All language items in Rust can be documented using special `///` syntax."
msgstr ""

#: src/basic-syntax/rustdoc.md:5
msgid ""
"```rust,editable\n"
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
"fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
"    if rhs == 0 {\n"
"        return false;  // Corner case, early return\n"
"    }\n"
"    lhs % rhs == 0     // The last expression in a block is the return "
"value\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/rustdoc.md:17
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""

#: src/basic-syntax/rustdoc.md:24
msgid ""
"Show students the generated docs for the `rand` crate at [`docs.rs/rand`]"
"(https://docs.rs/rand)."
msgstr ""

#: src/basic-syntax/rustdoc.md:27
msgid ""
"This course does not include rustdoc on slides, just to save space, but in "
"real code they should be present."
msgstr ""

#: src/basic-syntax/rustdoc.md:30
msgid ""
"Inner doc comments are discussed later (in the page on modules) and need not "
"be addressed here."
msgstr ""

#: src/basic-syntax/rustdoc.md:33
msgid ""
"Rustdoc comments can contain code snippets that we can run and test using "
"`cargo test`. We will discuss these tests in the [Testing section](../"
"testing/doc-tests.html)."
msgstr ""

#: src/basic-syntax/methods.md:3
#, fuzzy
msgid ""
"Methods are functions associated with a type. The `self` argument of a "
"method is an instance of the type it is associated with:"
msgstr ""
"Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚, ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»ÏÏ‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Ï€Î¿Ï… ÏƒÏ‡ÎµÏ„Î¯Î¶Î¿Î½Ï„Î±Î¹ Î¼Îµ Î­Î½Î±Î½ "
"ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿ Ï„ÏÏ€Î¿. Î¿ Î¤Î¿ Ï€ÏÏÏ„Î¿ ÏŒÏÎ¹ÏƒÎ¼Î± Î¼Î¹Î±Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï… ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Ï„Î¿Ï… "
"Ï„ÏÏ€Î¿Ï… Î¼Îµ Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ ÏƒÏ‡ÎµÏ„Î¯Î¶ÎµÏ„Î±Î¹:"

#: src/basic-syntax/methods.md:6
msgid ""
"```rust,editable\n"
"struct Rectangle {\n"
"    width: u32,\n"
"    height: u32,\n"
"}\n"
"\n"
"impl Rectangle {\n"
"    fn area(&self) -> u32 {\n"
"        self.width * self.height\n"
"    }\n"
"\n"
"    fn inc_width(&mut self, delta: u32) {\n"
"        self.width += delta;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut rect = Rectangle { width: 10, height: 5 };\n"
"    println!(\"old area: {}\", rect.area());\n"
"    rect.inc_width(5);\n"
"    println!(\"new area: {}\", rect.area());\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:30
#, fuzzy
msgid ""
"We will look much more at methods in today's exercise and in tomorrow's "
"class."
msgstr ""
"Î˜Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎ¿Ï…Î¼Îµ Ï€Î¿Î»Ï Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ Ï„Î¹Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ ÏƒÏ„Î· ÏƒÎ·Î¼ÎµÏÎ¹Î½Î® Î¬ÏƒÎºÎ·ÏƒÎ· ÎºÎ±Î¹ ÏƒÏ„Î·Î½ "
"Î±Ï…ÏÎ¹Î±Î½Î® Ï„Î¬Î¾Î·."

#: src/basic-syntax/methods.md:34
msgid "Add a static method called `Rectangle::new` and call this from `main`:"
msgstr ""

#: src/basic-syntax/methods.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn new(width: u32, height: u32) -> Rectangle {\n"
"    Rectangle { width, height }\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/methods.md:42
msgid ""
"While _technically_, Rust does not have custom constructors, static methods "
"are commonly used to initialize structs (but don't have to). The actual "
"constructor, `Rectangle { width, height }`, could be called directly. See "
"the [Rustnomicon](https://doc.rust-lang.org/nomicon/constructors.html)."
msgstr ""

#: src/basic-syntax/methods.md:45
msgid ""
"Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
"static methods can take arbitrary parameters."
msgstr ""

#: src/basic-syntax/functions-interlude.md:1
#, fuzzy
msgid "Function Overloading"
msgstr "Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Î¥Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ·"

#: src/basic-syntax/functions-interlude.md:3
#, fuzzy
msgid "Overloading is not supported:"
msgstr "Î— Ï…Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ· Î´ÎµÎ½ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÏ„Î±Î¹:"

#: src/basic-syntax/functions-interlude.md:5
#, fuzzy
msgid "Each function has a single implementation:"
msgstr "ÎšÎ¬Î¸Îµ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î­Ï‡ÎµÎ¹ Î¼Î¹Î± ÎµÎ½Î¹Î±Î¯Î± Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ·:"

#: src/basic-syntax/functions-interlude.md:6
#, fuzzy
msgid "Always takes a fixed number of parameters."
msgstr "Î›Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï€Î¬Î½Ï„Î± Î­Î½Î±Î½ ÏƒÏ„Î±Î¸ÎµÏÏŒ Î±ÏÎ¹Î¸Î¼ÏŒ Ï€Î±ÏÎ±Î¼Î­Ï„ÏÏ‰Î½."

#: src/basic-syntax/functions-interlude.md:7
#, fuzzy
msgid "Always takes a single set of parameter types."
msgstr "Î›Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï€Î¬Î½Ï„Î± Î­Î½Î± ÎµÎ½Î¹Î±Î¯Î¿ ÏƒÏÎ½Î¿Î»Î¿ Ï„ÏÏ€Ï‰Î½ Ï€Î±ÏÎ±Î¼Î­Ï„ÏÏ‰Î½."

#: src/basic-syntax/functions-interlude.md:8
#, fuzzy
msgid "Default values are not supported:"
msgstr "ÎŸÎ¹ Ï€ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚ Î´ÎµÎ½ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶Î¿Î½Ï„Î±Î¹:"

#: src/basic-syntax/functions-interlude.md:9
#, fuzzy
msgid "All call sites have the same number of arguments."
msgstr "ÎŒÎ»Î¿Î¹ Î¿Î¹ Î¹ÏƒÏ„ÏŒÏ„Î¿Ï€Î¿Î¹ ÎºÎ»Î®ÏƒÎµÏ‰Î½ Î­Ï‡Î¿Ï…Î½ Ï„Î¿Î½ Î¯Î´Î¹Î¿ Î±ÏÎ¹Î¸Î¼ÏŒ Î¿ÏÎ¹ÏƒÎ¼Î¬Ï„Ï‰Î½."

#: src/basic-syntax/functions-interlude.md:10
#, fuzzy
msgid "Macros are sometimes used as an alternative."
msgstr "ÎŸÎ¹ Î¼Î±ÎºÏÎ¿ÎµÎ½Ï„Î¿Î»Î­Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î¼ÎµÏÎ¹ÎºÎ­Ï‚ Ï†Î¿ÏÎ­Ï‚ Ï‰Ï‚ ÎµÎ½Î±Î»Î»Î±ÎºÏ„Î¹ÎºÎ® Î»ÏÏƒÎ·."

#: src/basic-syntax/functions-interlude.md:12
#, fuzzy
msgid "However, function parameters can be generic:"
msgstr "Î©ÏƒÏ„ÏŒÏƒÎ¿, Î¿Î¹ Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Î¹ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î³ÎµÎ½Î¹ÎºÎ­Ï‚:"

#: src/basic-syntax/functions-interlude.md:14
msgid ""
"```rust,editable\n"
"fn pick_one<T>(a: T, b: T) -> T {\n"
"    if std::process::id() % 2 == 0 { a } else { b }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
"    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/functions-interlude.md:27
#, fuzzy
msgid ""
"When using generics, the standard library's `Into<T>` can provide a kind of "
"limited polymorphism on argument types. We will see more details in a later "
"section."
msgstr ""
"ÎŒÏ„Î±Î½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Î³ÎµÎ½Î¹ÎºÎ¬, Ï„Î¿ 'Into\n"
"\n"
"' Ï„Î·Ï‚ Ï„Ï…Ï€Î¹ÎºÎ®Ï‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€Î±ÏÎ­Ï‡ÎµÎ¹ Î­Î½Î± ÎµÎ¯Î´Î¿Ï‚ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿Ï… "
"Ï€Î¿Î»Ï…Î¼Î¿ÏÏ†Î¹ÏƒÎ¼ÏŒÏ‚ ÏƒÎµ Ï„ÏÏ€Î¿Ï…Ï‚ ÎµÏ€Î¹Ï‡ÎµÎ¹ÏÎ·Î¼Î¬Ï„Ï‰Î½. Î˜Î± Î´Î¿ÏÎ¼Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ ÏƒÎµ "
"ÎµÏ€ÏŒÎ¼ÎµÎ½Î· ÎµÎ½ÏŒÏ„Î·Ï„Î±."

#: src/exercises/day-1/morning.md:1
#, fuzzy
msgid "Day 1: Morning Exercises"
msgstr "Î—Î¼Î­ÏÎ± 1: Î ÏÏ‰Î¹Î½Î­Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-1/morning.md:3
#, fuzzy
msgid "In these exercises, we will explore two parts of Rust:"
msgstr "Î£Îµ Î±Ï…Ï„Î­Ï‚ Ï„Î¹Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚, Î¸Î± ÎµÎ¾ÎµÏÎµÏ…Î½Î®ÏƒÎ¿Ï…Î¼Îµ Î´ÏÎ¿ Î¼Î­ÏÎ· Ï„Î¿Ï… Rust:"

#: src/exercises/day-1/morning.md:5
#, fuzzy
msgid "Implicit conversions between types."
msgstr "Î£Î¹Ï‰Ï€Î·ÏÎ­Ï‚ Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î­Ï‚ Î¼ÎµÏ„Î±Î¾Ï Ï„ÏÏ€Ï‰Î½."

#: src/exercises/day-1/morning.md:7
msgid "Arrays and `for` loops."
msgstr ""

#: src/exercises/day-1/morning.md:11
#, fuzzy
msgid "A few things to consider while solving the exercises:"
msgstr ""
"ÎœÎµÏÎ¹ÎºÎ¬ Ï€ÏÎ¬Î³Î¼Î±Ï„Î± Ï€Î¿Ï… Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î»Î¬Î²ÎµÏ„Îµ Ï…Ï€ÏŒÏˆÎ· ÎºÎ±Ï„Î¬ Ï„Î·Î½ ÎµÏ€Î¯Î»Ï…ÏƒÎ· Ï„Ï‰Î½ Î±ÏƒÎºÎ®ÏƒÎµÏ‰Î½:"

#: src/exercises/day-1/morning.md:13
#, fuzzy
msgid ""
"Use a local Rust installation, if possible. This way you can get auto-"
"completion in your editor. See the page about [Using Cargo](../../cargo.md) "
"for details on installing Rust."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Î¼Î¹Î± Ï„Î¿Ï€Î¹ÎºÎ® ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Rust, ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒÎ½. ÎœÎµ Î±Ï…Ï„ÏŒÎ½ Ï„Î¿Î½ "
"Ï„ÏÏŒÏ€Î¿ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î±Ï€Î¿ÎºÏ„Î®ÏƒÎµÏ„Îµ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î· ÏƒÏ…Î¼Ï€Î»Î®ÏÏ‰ÏƒÎ· ÏƒÏ„Î¿Î½ ÎµÏ€ÎµÎ¾ÎµÏÎ³Î±ÏƒÏ„Î® ÏƒÎ±Ï‚. Î”ÎµÎ¯Ï„Îµ "
"Ï„Î· ÏƒÎµÎ»Î¯Î´Î± ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î¿ [Using Cargo](../../cargo.md) Î³Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ ÎºÎ±Ï„Î¬ "
"Ï„Î·Î½ ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Ï„Î¿Ï… Rust."

#: src/exercises/day-1/morning.md:17
msgid "Alternatively, use the Rust Playground."
msgstr ""

#: src/exercises/day-1/morning.md:19
#, fuzzy
msgid ""
"The code snippets are not editable on purpose: the inline code snippets lose "
"their state if you navigate away from the page."
msgstr ""
"Î¤Î± Î±Ï€Î¿ÏƒÏ€Î¬ÏƒÎ¼Î±Ï„Î± ÎºÏÎ´Î¹ÎºÎ± Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎµÏ€ÎµÎ¾ÎµÏÎ³Î¬ÏƒÎ¹Î¼Î± ÎµÏ€Î¯Ï„Î·Î´ÎµÏ‚: Ï„Î± ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î± "
"Î±Ï€Î¿ÏƒÏ€Î¬ÏƒÎ¼Î±Ï„Î± ÎºÏÎ´Î¹ÎºÎ± Ï‡Î¬Î½Î¿Î½Ï„Î±Î¹ Ï„Î·Î½ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ® Ï„Î¿Ï…Ï‚ ÎµÎ¬Î½ Î±Ï€Î¿Î¼Î±ÎºÏÏ…Î½Î¸ÎµÎ¯Ï„Îµ Î±Ï€ÏŒ Ï„Î· "
"ÏƒÎµÎ»Î¯Î´Î±."

#: src/exercises/day-1/morning.md:22 src/exercises/day-2/morning.md:11
#: src/exercises/day-3/morning.md:9 src/exercises/bare-metal/morning.md:7
#: src/exercises/concurrency/morning.md:12
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr "Î‘Ï†Î¿Ï Î´ÎµÎ¯Ï„Îµ Ï„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î· \\[Î»ÏÏƒÎ·\\] Ï€Î¿Ï… Ï€Î±ÏÎ­Ï‡ÎµÏ„Î±Î¹."

#: src/exercises/day-1/implicit-conversions.md:3
#, fuzzy
msgid ""
"Rust will not automatically apply _implicit conversions_ between types "
"([unlike C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). You can see this in a program like this:"
msgstr ""
"Î¤Î¿ Rust Î´ÎµÎ½ Î¸Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± _implicit conversions_ Î¼ÎµÏ„Î±Î¾Ï Ï„Ï‰Î½ Ï„ÏÏ€Ï‰Î½ "
"([ÏƒÎµ Î±Î½Ï„Î¯Î¸ÎµÏƒÎ· Î¼Îµ C++](https://en.cppreference.com/w/cpp/language/"
"implicit_conversion)). ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ Î´ÎµÎ¯Ï„Îµ ÏƒÎµ Î­Î½Î± Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± ÏŒÏ€Ï‰Ï‚ Î±Ï…Ï„ÏŒ:"

#: src/exercises/day-1/implicit-conversions.md:6
msgid ""
"```rust,editable,compile_fail\n"
"fn multiply(x: i16, y: i16) -> i16 {\n"
"    x * y\n"
"}\n"
"\n"
"fn main() {\n"
"    let x: i8 = 15;\n"
"    let y: i16 = 1000;\n"
"\n"
"    println!(\"{x} * {y} = {}\", multiply(x, y));\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/implicit-conversions.md:19
#, fuzzy
msgid ""
"The Rust integer types all implement the [`From<T>`](https://doc.rust-lang."
"org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-lang.org/"
"std/convert/trait.Into.html) traits to let us convert between them. The "
"`From<T>` trait has a single `from()` method and similarly, the `Into<T>` "
"trait has a single `into()` method. Implementing these traits is how a type "
"expresses that it can be converted into another type."
msgstr ""
"ÎŒÎ»Î¿Î¹ Î¿Î¹ Ï„ÏÏ€Î¿Î¹ Î±ÎºÎ­ÏÎ±Î¹Î¿Ï… Î±ÏÎ¹Î¸Î¼Î¿Ï Rust ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Ï„Î± [`From<T>`](https://doc."
"rust-lang.org/std/convert/trait.From.html) ÎºÎ±Î¹ [`Into<T>`](https://doc.rust-"
"lang.org/std/convert/trait.Into.html) Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Î³Î¹Î± Î½Î± Î¼Î±Ï‚ Î±Ï†Î®ÏƒÎ¿Ï…Î½ Î½Î± "
"Î¼ÎµÏ„Î±Ï„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ Î¼ÎµÏ„Î±Î¾Ï Ï„Î¿Ï…Ï‚. Î¤Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ \"From\n"
"\n"
"\" Î­Ï‡ÎµÎ¹ Î­Î½Î± Î¼ÏŒÎ½Î¿ \"from()\". Î¼Î­Î¸Î¿Î´Î¿ ÎºÎ±Î¹ Ï€Î±ÏÎ¿Î¼Î¿Î¯Ï‰Ï‚, Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«Into\n"
"\n"
"Â» Î­Ï‡ÎµÎ¹ Î¼Î¯Î± Î¼ÏŒÎ½Î¿ Î¼Î­Î¸Î¿Î´Î¿ Â«into()Â». Î— ÎµÏ†Î±ÏÎ¼Î¿Î³Î® Î±Ï…Ï„ÏÎ½ Ï„Ï‰Î½ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½ ÎµÎ¯Î½Î±Î¹ "
"Î¿ Ï„ÏÏŒÏ€Î¿Ï‚ Î¼Îµ Ï„Î¿Î½ Î¿Ï€Î¿Î¯Î¿ Î­Î½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ ÎµÎºÏ†ÏÎ¬Î¶ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î¼ÎµÏ„Î±Ï„ÏÎ±Ï€ÎµÎ¯ ÏƒÎµ Î¬Î»Î»Î¿Ï… "
"Ï„ÏÏ€Î¿Ï…."

#: src/exercises/day-1/implicit-conversions.md:25
#, fuzzy
msgid ""
"The standard library has an implementation of `From<i8> for i16`, which "
"means that we can convert a variable `x` of type `i8` to an `i16` by "
"calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> for "
"i16` implementation automatically create an implementation of `Into<i16> for "
"i8`."
msgstr ""
"Î— Ï„Ï…Ï€Î¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Î­Ï‡ÎµÎ¹ Î¼Î¹Î± Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… Â«From\n"
"\n"
" Î³Î¹Î± i16Â», Ï€Î¿Ï… ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Î¼ÎµÏ„Î±Ï„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Â«xÂ» Ï„ÏÏ€Î¿Ï… "
"Â«i8Â» ÏƒÎµ Â«i16Â» ÎºÎ±Î»ÏÎ½Ï„Î±Ï‚ `i16::from(x)`. Î‰, Î±Ï€Î»Î¿ÏÏƒÏ„ÎµÏÎ±, Î¼Îµ `x.into()`, ÎµÏ€ÎµÎ¹Î´Î® "
"`From<i8> Î³Î¹Î± i16` Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Î¼Î¹Î± Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… Â«Into\n"
"\n"
" Î³Î¹Î± i8Â»."

#: src/exercises/day-1/implicit-conversions.md:30
#, fuzzy
msgid ""
"The same applies for your own `From` implementations for your own types, so "
"it is sufficient to only implement `From` to get a respective `Into` "
"implementation automatically."
msgstr ""
"Î¤Î¿ Î¯Î´Î¹Î¿ Î¹ÏƒÏ‡ÏÎµÎ¹ ÎºÎ±Î¹ Î³Î¹Î± Ï„Î¹Ï‚ Î´Î¹ÎºÎ­Ï‚ ÏƒÎ±Ï‚ Ï…Î»Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹Ï‚ Â«Î‘Ï€ÏŒÂ» Î³Î¹Î± Ï„Î¿Ï…Ï‚ Î´Î¹ÎºÎ¿ÏÏ‚ ÏƒÎ±Ï‚ "
"Ï„ÏÏ€Î¿Ï…Ï‚, Î­Ï„ÏƒÎ¹ ÎµÎ¯Î½Î±Î¹ Î±ÏÎºÎµÎ¯ Î³Î¹Î± Î½Î± ÎµÏ†Î±ÏÎ¼Î¿ÏƒÏ„ÎµÎ¯ Î¼ÏŒÎ½Î¿ Ï„Î¿ \"From\" Î³Î¹Î± Î½Î± Î»Î·Ï†Î¸ÎµÎ¯ "
"Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Î¼Î¹Î± Î±Î½Ï„Î¯ÏƒÏ„Î¿Î¹Ï‡Î· Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· \"Into\"."

#: src/exercises/day-1/implicit-conversions.md:33
#, fuzzy
msgid "Execute the above program and look at the compiler error."
msgstr ""
"Î‘Î»Î»Î¬Î¾Ï„Îµ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ \"x\" ÎºÎ±Î¹ \"y\" ÏƒÎµ Î¬Î»Î»Î± Ï€ÏÎ¬Î³Î¼Î±Ï„Î± (ÏŒÏ€Ï‰Ï‚ \"f32\", "
"\"bool\", `i128`) Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ Ï€Î¿Î¹Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î¼ÎµÏ„Î±Ï„ÏÎ­ÏˆÎµÏ„Îµ ÏƒÎµ "
"Ï€Î¿Î¹Î¿Ï…Ï‚ Î¬Î»Î»Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚. Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î® Î¼Î¹ÎºÏÏÎ½ Ï„ÏÏ€Ï‰Î½ ÏƒÎµ Î¼ÎµÎ³Î¬Î»Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ "
"ÎºÎ±Î¹ Ï„Î¿ Î±Î½Ï„Î¯ÏƒÏ„ÏÎ¿Ï†Î¿. Î•Î»ÎµÎ³Î¾Îµ Ï„Î¿ [Ï„Ï…Ï€Î¹ÎºÎ® Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ· Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚](https://doc."
"rust-lang.org/std/convert/trait.From.html) Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ ÎµÎ¬Î½ Ï„Î¿ \"From"

#: src/exercises/day-1/implicit-conversions.md:35
#, fuzzy
msgid "Update the code above to use `into()` to do the conversion."
msgstr "\" Î­Ï‡ÎµÎ¹ ÎµÏ†Î±ÏÎ¼Î¿ÏƒÏ„ÎµÎ¯ Î³Î¹Î± Ï„Î± Î¶ÎµÏ…Î³Î¬ÏÎ¹Î± Ï€Î¿Ï… ÎµÎ»Î­Î³Ï‡ÎµÏ„Îµ."

#: src/exercises/day-1/implicit-conversions.md:37
msgid ""
"Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
"`i128`) to see which types you can convert to which other types. Try "
"converting small types to big types and the other way around. Check the "
"[standard library documentation](https://doc.rust-lang.org/std/convert/trait."
"From.html) to see if `From<T>` is implemented for the pairs you check."
msgstr ""

#: src/exercises/day-1/for-loops.md:1
#: src/exercises/day-1/solutions-morning.md:3
#, fuzzy
msgid "Arrays and `for` Loops"
msgstr "Î Î¯Î½Î±ÎºÎµÏ‚ ÎºÎ±Î¹ Î²ÏÏŒÏ‡Î¿Î¹ Â«Î³Î¹Î±Â»."

#: src/exercises/day-1/for-loops.md:3
#, fuzzy
msgid "We saw that an array can be declared like this:"
msgstr "Î•Î¯Î´Î±Î¼Îµ ÏŒÏ„Î¹ Î­Î½Î±Ï‚ Ï€Î¯Î½Î±ÎºÎ±Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î´Î·Î»Ï‰Î¸ÎµÎ¯ Ï‰Ï‚ ÎµÎ¾Î®Ï‚:"

#: src/exercises/day-1/for-loops.md:5
msgid ""
"```rust\n"
"let array = [10, 20, 30];\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:9
#, fuzzy
msgid ""
"You can print such an array by asking for its debug representation with `{:?}"
"`:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎºÏ„Ï…Ï€ÏÏƒÎµÏ„Îµ Î­Î½Î±Î½ Ï„Î­Ï„Î¿Î¹Î¿ Ï€Î¯Î½Î±ÎºÎ± Î¶Î·Ï„ÏÎ½Ï„Î±Ï‚ Ï„Î·Î½ Î±Î½Î±Ï€Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ® Ï„Î¿Ï… Î³Î¹Î± "
"Ï„Î¿Î½ ÎµÎ½Ï„Î¿Ï€Î¹ÏƒÎ¼ÏŒ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ Î¼Îµ \"{:?}\":"

#: src/exercises/day-1/for-loops.md:11
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    println!(\"array: {array:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:18
#, fuzzy
msgid ""
"Rust lets you iterate over things like arrays and ranges using the `for` "
"keyword:"
msgstr ""
"Î¤Î¿ Rust ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÏ€Î±Î½Î±Î»Î±Î¼Î²Î¬Î½ÎµÏ„Îµ Ï€ÏÎ¬Î³Î¼Î±Ï„Î± ÏŒÏ€Ï‰Ï‚ Ï€Î¯Î½Î±ÎºÎµÏ‚ ÎºÎ±Î¹ ÎµÏÏÎ· "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿ \"Î³Î¹Î±\". Î»Î­Î¾Î·-ÎºÎ»ÎµÎ¹Î´Î¯:"

#: src/exercises/day-1/for-loops.md:21
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let array = [10, 20, 30];\n"
"    print!(\"Iterating over array:\");\n"
"    for n in &array {\n"
"        print!(\" {n}\");\n"
"    }\n"
"    println!();\n"
"\n"
"    print!(\"Iterating over range:\");\n"
"    for i in 0..3 {\n"
"        print!(\" {}\", array[i]);\n"
"    }\n"
"    println!();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:38
#, fuzzy
msgid ""
"Use the above to write a function `pretty_print` which pretty-print a matrix "
"and a function `transpose` which will transpose a matrix (turn rows into "
"columns):"
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î± Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Î³Î¹Î± Î½Î± Î³ÏÎ¬ÏˆÎµÏ„Îµ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Â«pretty_printÂ» Ï€Î¿Ï… "
"ÎµÎºÏ„Ï…Ï€ÏÎ½ÎµÎ¹ ÏŒÎ¼Î¿ÏÏ†Î± Î­Î½Î±Î½ Ï€Î¯Î½Î±ÎºÎ± ÎºÎ±Î¹ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· \"transpose\" Ï€Î¿Ï… Î¸Î± "
"Î¼ÎµÏ„Î±Ï†Î­ÏÎµÎ¹ Î­Î½Î±Î½ Ï€Î¯Î½Î±ÎºÎ± (Î¼ÎµÏ„Î±Ï„ÏÎ­Ï€ÎµÎ¹ Ï„Î¹Ï‚ Î³ÏÎ±Î¼Î¼Î­Ï‚ ÏƒÎµ ÏƒÏ„Î®Î»ÎµÏ‚):"

#: src/exercises/day-1/for-loops.md:41
msgid ""
"```bob\n"
"           â›â¡1 2 3â¤â      â¡1 4 7â¤\n"
"\"transpose\"âœâ¢4 5 6â¥âŸ  \"==\"â¢2 5 8â¥\n"
"           ââ£7 8 9â¦â       â£3 6 9â¦\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:47
#, fuzzy
msgid "Hard-code both functions to operate on 3 Ã— 3 matrices."
msgstr ""
"Î£ÎºÎ»Î·ÏÏŒÏ‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ ÎºÎ±Î¹ Ï„Ï‰Î½ Î´ÏÎ¿ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½ Î³Î¹Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± ÏƒÎµ Ï€Î¯Î½Î±ÎºÎµÏ‚ 3 Ã— 3."

#: src/exercises/day-1/for-loops.md:49
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr ""
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ "
"ÎµÏ†Î±ÏÎ¼ÏŒÏƒÏ„Îµ Ï„Î¿ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚:"

#: src/exercises/day-1/for-loops.md:52
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/for-loops.md:80
#, fuzzy
msgid "Bonus Question"
msgstr "Î•ÏÏÏ„Î·ÏƒÎ· Î¼Ï€ÏŒÎ½Î¿Ï…Ï‚"

#: src/exercises/day-1/for-loops.md:82
#, fuzzy
msgid ""
"Could you use `&[i32]` slices instead of hard-coded 3 Ã— 3 matrices for your "
"argument and return types? Something like `&[&[i32]]` for a two-dimensional "
"slice-of-slices. Why or why not?"
msgstr ""
"Î˜Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï†Î­Ï„ÎµÏ‚ \"&\\[i32\\]\" Î±Î½Ï„Î¯ Î³Î¹Î± ÏƒÎºÎ»Î·ÏÎ¿ÏÏ‚ "
"ÎºÏ‰Î´Î¹ÎºÎ¿Ï€Î¿Î¹Î·Î¼Î­Î½Î¿Ï…Ï‚ Ï€Î¯Î½Î±ÎºÎµÏ‚ 3 Ã— 3 Î³Î¹Î± ÏŒÏÎ¹ÏƒÎ¼Î± ÎºÎ±Î¹ Ï„ÏÏ€Î¿Î¹ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚; ÎšÎ¬Ï„Î¹ ÏƒÎ±Î½ "
"\"&\\[&\\[i32\\]\\]\" Î³Î¹Î± Î­Î½Î± Î´Î¹ÏƒÎ´Î¹Î¬ÏƒÏ„Î±Ï„Î¿ Ï†Î­Ï„Î± Ï†Î­Ï„ÎµÏ‚. Î“Î¹Î±Ï„Î¯ Î® Î³Î¹Î±Ï„Î¯ ÏŒÏ‡Î¹?"

#: src/exercises/day-1/for-loops.md:87
#, fuzzy
msgid ""
"See the [`ndarray` crate](https://docs.rs/ndarray/) for a production quality "
"implementation."
msgstr ""
"Î”ÎµÎ¯Ï„Îµ Ï„Î¿ [`ndarray` crate](https://docs.rs/ndarray/) Î³Î¹Î± Ï€Î¿Î¹ÏŒÏ„Î·Ï„Î± Ï€Î±ÏÎ±Î³Ï‰Î³Î®Ï‚ "
"ÎµÎºÏ„Î­Î»ÎµÏƒÎ·."

#: src/exercises/day-1/for-loops.md:92
#, fuzzy
msgid ""
"The solution and the answer to the bonus section are available in the  "
"[Solution](solutions-morning.md#arrays-and-for-loops) section."
msgstr ""
"Î— Î»ÏÏƒÎ· ÎºÎ±Î¹ Î· Î±Ï€Î¬Î½Ï„Î·ÏƒÎ· ÏƒÏ„Î·Î½ ÎµÎ½ÏŒÏ„Î·Ï„Î± Î¼Ï€ÏŒÎ½Î¿Ï…Ï‚ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼ÎµÏ‚ ÏƒÏ„Î¿ Î•Î½ÏŒÏ„Î·Ï„Î± "
"[Î›ÏÏƒÎ·](solutions-morning.md#arrays-and-for-loops)."

#: src/exercises/day-1/for-loops.md:95
msgid ""
"The use of the reference `&array` within `for n in &array` is a subtle "
"preview of issues of ownership that will come later in the afternoon."
msgstr ""

#: src/exercises/day-1/for-loops.md:98
msgid "Without the `&`..."
msgstr ""

#: src/exercises/day-1/for-loops.md:99
msgid ""
"The loop would have been one that consumes the array.  This is a change "
"[introduced in the 2021 Edition](https://doc.rust-lang.org/edition-guide/"
"rust-2021/IntoIterator-for-arrays.html)."
msgstr ""

#: src/exercises/day-1/for-loops.md:102
msgid ""
"An implicit array copy would have occured.  Since `i32` is a copy type, then "
"`[i32; 3]` is also a copy type."
msgstr ""

#: src/control-flow.md:3
#, fuzzy
msgid ""
"As we have seen, `if` is an expression in Rust. It is used to conditionally "
"evaluate one of two blocks, but the blocks can have a value which then "
"becomes the value of the `if` expression. Other control flow expressions "
"work similarly in Rust."
msgstr ""
"ÎŒÏ€Ï‰Ï‚ ÎµÎ¯Î´Î±Î¼Îµ, Ï„Î¿ Â«Î±Î½Â» ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î­ÎºÏ†ÏÎ±ÏƒÎ· ÏƒÏ„Î¿ Rust. Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Ï…Ï€ÏŒ ÏŒÏÎ¿Ï…Ï‚ "
"Î±Î¾Î¹Î¿Î»Î¿Î³Î®ÏƒÏ„Îµ Î­Î½Î± Î±Ï€ÏŒ Ï„Î± Î´ÏÎ¿ Î¼Ï€Î»Î¿Îº, Î±Î»Î»Î¬ Ï„Î± Î¼Ï€Î»Î¿Îº Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡Î¿Ï…Î½ Î¼Î¹Î± Ï„Î¹Î¼Î® Ï€Î¿Ï… "
"ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î± Î³Î¯Î½ÎµÏ„Î±Î¹ Ï„Î·Î½ Ï„Î¹Î¼Î® Ï„Î·Ï‚ Î­ÎºÏ†ÏÎ±ÏƒÎ·Ï‚ Â«Î±Î½Â». Î†Î»Î»ÎµÏ‚ ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ ÏÎ¿Î®Ï‚ "
"ÎµÎ»Î­Î³Ï‡Î¿Ï… Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÎ½ Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± ÏƒÏ„Î¿ Rust."

#: src/control-flow/blocks.md:3
#, fuzzy
msgid ""
"A block in Rust contains a sequence of expressions. Each block has a value "
"and a type, which are those of the last expression of the block:"
msgstr ""
"ÎˆÎ½Î± Î¼Ï€Î»Î¿Îº ÏƒÏ„Î¿ Rust Î­Ï‡ÎµÎ¹ Î¼Î¹Î± Ï„Î¹Î¼Î® ÎºÎ±Î¹ Î­Î½Î±Î½ Ï„ÏÏ€Î¿: Î· Ï„Î¹Î¼Î® ÎµÎ¯Î½Î±Î¹ Î· Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± "
"Î­ÎºÏ†ÏÎ±ÏƒÎ· Ï„Î¿Ï… ÎŸÎ™ÎšÎŸÎ”ÎŸÎœÎ™ÎšÎŸ Î¤Î•Î¤Î¡Î‘Î“Î©ÎÎŸ:"

#: src/control-flow/blocks.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = {\n"
"        let y = 10;\n"
"        println!(\"y: {y}\");\n"
"        let z = {\n"
"            let w = {\n"
"                3 + 4\n"
"            };\n"
"            println!(\"w: {w}\");\n"
"            y * w\n"
"        };\n"
"        println!(\"z: {z}\");\n"
"        z - y\n"
"    };\n"
"    println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:26
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr ""

#: src/control-flow/blocks.md:28
#, fuzzy
msgid ""
"The same rule is used for functions: the value of the function body is the "
"return value:"
msgstr ""
"ÎŸ Î¯Î´Î¹Î¿Ï‚ ÎºÎ±Î½ÏŒÎ½Î±Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Ï„Î¹Ï‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚: Î· Ï„Î¹Î¼Î® Ï„Î¿Ï… ÏƒÏÎ¼Î±Ï„Î¿Ï‚ "
"ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ ÎµÏ€Î¹ÏƒÏ„ÏÎµÏ†ÏŒÎ¼ÎµÎ½Î· Ï„Î¹Î¼Î®:"

#: src/control-flow/blocks.md:31
msgid ""
"```rust,editable\n"
"fn double(x: i32) -> i32 {\n"
"    x + x\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"doubled: {}\", double(7));\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/blocks.md:43 src/enums.md:34 src/enums/sizes.md:28
#: src/pattern-matching.md:25 src/pattern-matching/match-guards.md:22
#: src/structs.md:31 src/methods.md:30 src/methods/example.md:46
#, fuzzy
msgid "Key Points:"
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/control-flow/blocks.md:44
#, fuzzy
msgid ""
"The point of this slide is to show that blocks have a type and value in "
"Rust. "
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/control-flow/blocks.md:45
#, fuzzy
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"ÎŸ ÏƒÎºÎ¿Ï€ÏŒÏ‚ Î±Ï…Ï„Î®Ï‚ Ï„Î·Ï‚ Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹Î±Ï‚ ÎµÎ¯Î½Î±Î¹ Î½Î± Î´ÎµÎ¯Î¾ÎµÎ¹ ÏŒÏ„Î¹ Ï„Î± Î¼Ï€Î»Î¿Îº Î­Ï‡Î¿Ï…Î½ Ï„ÏÏ€Î¿ ÎºÎ±Î¹ "
"Ï„Î¹Î¼Î® ÏƒÏ„Î¿ Rust.\n"
"\n"
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï€ÏÏ‚ Î±Î»Î»Î¬Î¶ÎµÎ¹ Î· Ï„Î¹Î¼Î® Ï„Î¿Ï… Î¼Ï€Î»Î¿Îº Î±Î»Î»Î¬Î¶Î¿Î½Ï„Î±Ï‚ Ï„Î·Î½ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± "
"Î³ÏÎ±Î¼Î¼Î® ÏƒÏ„Î¿ Î¼Ï€Î»Î¿Îº. Î“Î¹Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Ï€ÏÎ¿ÏƒÎ¸Î­Ï„Î¿Î½Ï„Î±Ï‚/Î±Ï†Î±Î¹ÏÏÎ½Ï„Î±Ï‚ Î­Î½Î± ÎµÏÏ‰Ï„Î·Î¼Î±Ï„Î¹ÎºÏŒ Î® "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Î­Î½Î± Â«returnÂ»."

#: src/control-flow/if-expressions.md:1
#, fuzzy
msgid "`if` expressions"
msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ \"Î±Î½\"."

#: src/control-flow/if-expressions.md:3
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""

#: src/control-flow/if-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    if x % 2 == 0 {\n"
"        x = x / 2;\n"
"    } else {\n"
"        x = 3 * x + 1;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:18
#, fuzzy
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"Î•Ï€Î¹Ï€Î»Î­Î¿Î½, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï‰Ï‚ Î­ÎºÏ†ÏÎ±ÏƒÎ·. Î‘Ï…Ï„ÏŒ ÎºÎ¬Î½ÎµÎ¹ Ï„Î¿ Î¯Î´Î¹Î¿ ÏŒÏ€Ï‰Ï‚ "
"Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰:"

#: src/control-flow/if-expressions.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    x = if x % 2 == 0 {\n"
"        x / 2\n"
"    } else {\n"
"        3 * x + 1\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-expressions.md:35
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Consider showing what happens if you "
"add `;` after `x / 2` in the second example."
msgstr ""

#: src/control-flow/for-expressions.md:1
#, fuzzy
msgid "`for` loops"
msgstr "Î’ÏÏŒÏ‡Î¿Î¹ Â«Î³Î¹Î±Â»."

#: src/control-flow/for-expressions.md:3
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is closely "
"related to the [`while let` loop](while-let-expressions.md). It will "
"automatically call `into_iter()` on the expression and then iterate over it:"
msgstr ""
"Î— Î­ÎºÏ†ÏÎ±ÏƒÎ· \"for\" ÏƒÏ‡ÎµÏ„Î¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„ÎµÎ½Î¬ Î¼Îµ Ï„Î·Î½ Î­ÎºÏ†ÏÎ±ÏƒÎ· \"while let\". Î˜Î± ÎºÎ±Î»ÎµÎ¯ "
"Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï„Î¿ Â«into_iter()Â» ÏƒÏ„Î·Î½ Î­ÎºÏ†ÏÎ±ÏƒÎ· ÎºÎ±Î¹, ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, ÎµÏ€Î±Î½Î±Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï€Î¬Î½Ï‰ "
"Î±Ï€ÏŒ Î±Ï…Ï„Î®Î½:"

#: src/control-flow/for-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"\n"
"    for x in v {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"    \n"
"    for i in (0..10).step_by(2) {\n"
"        println!(\"i: {i}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/for-expressions.md:21
#, fuzzy
msgid "You can use `break` and `continue` here as usual."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Â«Î´Î¹Î¬Î»ÎµÎ¹Î¼Î¼Î±Â» ÎºÎ±Î¹ Ï„Î¿ Â«ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±Â» ÎµÎ´Ï Ï‰Ï‚ ÏƒÏ…Î½Î®Î¸Ï‰Ï‚."

#: src/control-flow/for-expressions.md:25
#, fuzzy
msgid "Index iteration is not a special syntax in Rust for just that case."
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/control-flow/for-expressions.md:26
#, fuzzy
msgid "`(0..10)` is a range that implements an `Iterator` trait. "
msgstr ""
"Î— ÎµÏ€Î±Î½Î¬Î»Î·ÏˆÎ· ÎµÏ…ÏÎµÏ„Î·ÏÎ¯Î¿Ï… Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎµÎ¹Î´Î¹ÎºÎ® ÏƒÏÎ½Ï„Î±Î¾Î· ÏƒÏ„Î¿ Rust Î³Î¹Î± Î±Ï…Ï„Î®Î½ Ï„Î·Î½ "
"Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ·."

#: src/control-flow/for-expressions.md:27
#, fuzzy
msgid ""
"`step_by` is a method that returns another `Iterator` that skips every other "
"element. "
msgstr ""
"Î¤Î¿ \"(0..10)\" ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Ï€ÎµÏÎ¹Î¿Ï‡Î® Ï€Î¿Ï… Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Î­Î½Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ "
"\"Iterator\"."

#: src/control-flow/for-expressions.md:28
#, fuzzy
msgid ""
"Modify the elements in the vector and explain the compiler errors. Change "
"vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
msgstr ""
"Î¤Î¿ \"step_by\" ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î¼Î­Î¸Î¿Î´Î¿Ï‚ Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î­Î½Î±Î½ Î¬Î»Î»Î¿ \"Iterator\" Ï€Î¿Ï… "
"Ï€Î±ÏÎ±Î»ÎµÎ¯Ï€ÎµÎ¹ ÎºÎ¬Î¸Îµ Î¬Î»Î»Î¿ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î¿."

#: src/control-flow/while-expressions.md:1
#, fuzzy
msgid "`while` loops"
msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Â«ÎµÎ½ÏÂ»."

#: src/control-flow/while-expressions.md:3
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works very similar to other languages:"
msgstr ""

#: src/control-flow/while-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    while x != 1 {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:1
#, fuzzy
msgid "`break` and `continue`"
msgstr "Â«Î´Î¹Î¬Î»ÎµÎ¹Î¼Î¼Î±Â» ÎºÎ±Î¹ Â«ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±Â»."

#: src/control-flow/break-continue.md:3
msgid ""
"If you want to exit a loop early, use [`break`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#break-expressions),"
msgstr ""

#: src/control-flow/break-continue.md:4
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""

#: src/control-flow/break-continue.md:7
#, fuzzy
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr ""
"Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î²Î³ÎµÎ¯Ï„Îµ Î½Ï‰ÏÎ¯Ï‚ Î±Ï€ÏŒ Î­Î½Î±Î½ Î²ÏÏŒÏ‡Î¿, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î¿ Â«Î´Î¹Î¬Î»ÎµÎ¹Î¼Î¼Î±Â», "
"ÎµÎ¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ Î±Î¼Î­ÏƒÏ‰Ï‚ Ï„Î·Î½ ÎµÏ€ÏŒÎ¼ÎµÎ½Î· ÎµÏ€Î±Î½Î¬Î»Î·ÏˆÎ· Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ "
"Â«continueÂ». Î¤ÏŒÏƒÎ¿ Ï„Î¿ \"continue\" ÎºÎ±Î¹ Ï„Î¿ \"break\" Î¼Ï€Î¿ÏÎ¿ÏÎ½ Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ Ï€Î¬ÏÏ„Îµ "
"Î­Î½Î± ÏŒÏÎ¹ÏƒÎ¼Î± ÎµÏ„Î¹ÎºÎ­Ï„Î±Ï‚ Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Î½Î± Î¾ÎµÏ†ÏÎ³ÎµÎ¹ Î±Ï€ÏŒ Î­Î½Î¸ÎµÏ„Î¿Ï…Ï‚ Î²ÏÏŒÏ‡Î¿Ï…Ï‚:"

#: src/control-flow/break-continue.md:10
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"    'outer: while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"        let mut i = 0;\n"
"        while i < x {\n"
"            println!(\"x: {x}, i: {i}\");\n"
"            i += 1;\n"
"            if i == 3 {\n"
"                break 'outer;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/break-continue.md:28
#, fuzzy
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr ""
"Î£Îµ Î±Ï…Ï„Î® Ï„Î·Î½ Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· ÏƒÏ€Î¬Î¼Îµ Ï„Î¿Î½ ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÏŒ Î²ÏÏŒÏ‡Î¿ Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ 3 ÎµÏ€Î±Î½Î±Î»Î®ÏˆÎµÎ¹Ï‚ Ï„Î¿Ï… "
"ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÎ¿Ï Î²ÏÏŒÏ‡Î¿Ï…."

#: src/control-flow/loop-expressions.md:1
#, fuzzy
msgid "`loop` expressions"
msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Â«Î²ÏÏŒÏ‡Î¿Ï…Â»."

#: src/control-flow/loop-expressions.md:3
msgid ""
"Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#infinite-loops) which creates an endless loop."
msgstr ""

#: src/control-flow/loop-expressions.md:6
#, fuzzy
msgid "Here you must either `break` or `return` to stop the loop:"
msgstr ""
"Î¤Î­Î»Î¿Ï‚, Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¼Î¹Î± Î»Î­Î¾Î·-ÎºÎ»ÎµÎ¹Î´Î¯ Â«Î²ÏÏŒÏ‡Î¿Ï‚Â» Ï€Î¿Ï… Î´Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯ Î­Î½Î±Î½ Î±Ï„ÎµÎ»ÎµÎ¯Ï‰Ï„Î¿ Î²ÏÏŒÏ‡Î¿. "
"Î•Î´Ï Ï€ÏÎ­Ï€ÎµÎ¹ ÎµÎ¯Ï„Îµ \"break\" ÎµÎ¯Ï„Îµ \"return\" Î³Î¹Î± Î½Î± ÏƒÏ„Î±Î¼Î±Ï„Î®ÏƒÎµÎ¹ Î¿ Î²ÏÏŒÏ‡Î¿Ï‚:"

#: src/control-flow/loop-expressions.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut x = 10;\n"
"    loop {\n"
"        x = if x % 2 == 0 {\n"
"            x / 2\n"
"        } else {\n"
"            3 * x + 1\n"
"        };\n"
"        if x == 1 {\n"
"            break;\n"
"        }\n"
"    }\n"
"    println!(\"Final x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/loop-expressions.md:27
msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
msgstr ""

#: src/control-flow/loop-expressions.md:28
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""

#: src/basic-syntax/variables.md:3
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are immutable "
"by default:"
msgstr ""
"Î¤Î¿ Rust Ï€Î±ÏÎ­Ï‡ÎµÎ¹ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Ï„ÏÏ€Î¿Ï… Î¼Î­ÏƒÏ‰ ÏƒÏ„Î±Ï„Î¹ÎºÎ®Ï‚ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»ÏŒÎ³Î·ÏƒÎ·Ï‚. ÎŸÎ¹ Î´ÎµÏƒÎ¼ÎµÏÏƒÎµÎ¹Ï‚ "
"Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ ÎµÎ¯Î½Î±Î¹ Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„ÎµÏ‚ ÎºÎ±Ï„Î¬ Î ÏÎ¿ÎºÎ±Î¸Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿:"

#: src/basic-syntax/variables.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x: i32 = 10;\n"
"    println!(\"x: {x}\");\n"
"    // x = 20;\n"
"    // println!(\"x: {x}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/variables.md:17
#, fuzzy
msgid ""
"Due to type inference the `i32` is optional. We will gradually show the "
"types less and less as the course progresses."
msgstr ""
"Î›ÏŒÎ³Ï‰ ÏƒÏ…Î¼Ï€ÎµÏÎ±ÏƒÎ¼Î¬Ï„Ï‰Î½ Ï„ÏÏ€Î¿Ï…, Ï„Î¿ Â«i32Â» ÎµÎ¯Î½Î±Î¹ Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÏŒ. Î£Ï„Î±Î´Î¹Î±ÎºÎ¬ Î¸Î± Î´ÎµÎ¯Ï‡Î½Î¿Ï…Î¼Îµ "
"Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ ÏŒÎ»Î¿ ÎºÎ±Î¹ Î»Î¹Î³ÏŒÏ„ÎµÏÎ¿ ÏŒÏƒÎ¿ Ï€ÏÎ¿Ï‡Ï‰ÏÎ¬ Î¿ Ï„ÏÏ€Î¿Ï‚."

#: src/basic-syntax/type-inference.md:3
#, fuzzy
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr ""
"Î¤Î¿ Rust Î¸Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎµÎ¹ Ï€ÏÏ‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î³Î¹Î± Î½Î± Ï€ÏÎ¿ÏƒÎ´Î¹Î¿ÏÎ¯ÏƒÎµÎ¹ Ï„Î¿Î½ "
"Ï„ÏÏ€Î¿:"

#: src/basic-syntax/type-inference.md:5
msgid ""
"```rust,editable\n"
"fn takes_u32(x: u32) {\n"
"    println!(\"u32: {x}\");\n"
"}\n"
"\n"
"fn takes_i8(y: i8) {\n"
"    println!(\"i8: {y}\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = 10;\n"
"    let y = 20;\n"
"\n"
"    takes_u32(x);\n"
"    takes_i8(y);\n"
"    // takes_u32(y);\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:26
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr ""

#: src/basic-syntax/type-inference.md:28
#, fuzzy
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"Î‘Ï…Ï„Î® Î· Î´Î¹Î±Ï†Î¬Î½ÎµÎ¹Î± Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€ÏÏ‚ Î¿ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ Rust ÏƒÏ…Î¼Ï€ÎµÏÎ±Î¯Î½ÎµÎ¹ Ï„ÏÏ€Î¿Ï…Ï‚ Î¼Îµ "
"Î²Î¬ÏƒÎ· Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿ÏÏ‚ Ï€Î¿Ï… Î´Î¯Î½Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Î´Î·Î»ÏÏƒÎµÎ¹Ï‚ ÎºÎ±Î¹ Ï‡ÏÎ®ÏƒÎµÎ¹Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½.\n"
"\n"
"Î•Î¯Î½Î±Î¹ Ï€Î¿Î»Ï ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ Î½Î± Ï„Î¿Î½Î¯ÏƒÎ¿Ï…Î¼Îµ ÏŒÏ„Î¹ Î¿Î¹ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Ï€Î¿Ï… Î´Î·Î»ÏÎ½Î¿Î½Ï„Î±Î¹ ÏŒÏ€Ï‰Ï‚ Î±Ï…Ï„Î® "
"Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎºÎ¬Ï€Î¿Î¹Î¿Ï… ÎµÎ¯Î´Î¿Ï…Ï‚ Î´Ï…Î½Î±Î¼Î¹ÎºÎ¿Ï \"Î¿Ï€Î¿Î¹Î¿Ï…Î´Î®Ï€Î¿Ï„Îµ Ï„ÏÏ€Î¿Ï…\" Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ "
"ÎºÏÎ±Ï„Î®ÏƒÏ„Îµ Ï„Ï…Ï‡ÏŒÎ½ Î´ÎµÎ´Î¿Î¼Î­Î½Î±. ÎŸ ÎºÏ‰Î´Î¹ÎºÏŒÏ‚ Î¼Î·Ï‡Î±Î½Î®Ï‚ Ï€Î¿Ï… Î´Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Î¼Î¹Î± Ï„Î­Ï„Î¿Î¹Î± "
"Î´Î®Î»Ï‰ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Ï€Î±Î½Î¿Î¼Î¿Î¹ÏŒÏ„Ï…Ï€Î¿Ï‚ Î¼Îµ Ï„Î· ÏÎ·Ï„Î® Î´Î®Î»Ï‰ÏƒÎ· ÎµÎ½ÏŒÏ‚ Ï„ÏÏ€Î¿Ï…. ÎŸ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ "
"ÎºÎ¬Î½ÎµÎ¹ Ï„Î· Î´Î¿Ï…Î»ÎµÎ¹Î¬ Î³Î¹Î± ÎµÎ¼Î¬Ï‚ ÎºÎ±Î¹ Î¼Î±Ï‚ Î²Î¿Î·Î¸Î¬ Î½Î± Î³ÏÎ¬ÏˆÎ¿Ï…Î¼Îµ Î­Î½Î±Î½ Ï€Î¹Î¿ ÏƒÏ…Î½Î¿Ï€Ï„Î¹ÎºÏŒ "
"ÎºÏÎ´Î¹ÎºÎ±."

#: src/basic-syntax/type-inference.md:32
#, fuzzy
msgid ""
"The following code tells the compiler to copy into a certain generic "
"container without the code ever explicitly specifying the contained type, "
"using `_` as a placeholder:"
msgstr ""
"ÎŸ Î±ÎºÏŒÎ»Î¿Ï…Î¸Î¿Ï‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Î»Î­ÎµÎ¹ ÏƒÏ„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Î½Î± Î±Î½Ï„Î¹Î³ÏÎ¬ÏˆÎµÎ¹ ÏƒÎµ Î­Î½Î± "
"ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿ Î³ÎµÎ½Î¹ÎºÏŒ ÎºÎ¿Î½Ï„Î­Î¹Î½ÎµÏ Ï‡Ï‰ÏÎ¯Ï‚ Ï€Î¿Ï„Î­ Î¿ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Î½Î± Ï€ÏÎ¿ÏƒÎ´Î¹Î¿ÏÎ¯Î¶ÎµÎ¹ ÏÎ·Ï„Î¬ Ï„Î¿Î½ "
"Ï„ÏÏ€Î¿ Ï€Î¿Ï… Ï€ÎµÏÎ¹Î­Ï‡ÎµÏ„Î±Î¹, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿ Â«\\_Â» Ï‰Ï‚ ÏƒÏÎ¼Î²Î¿Î»Î¿ ÎºÏÎ¬Ï„Î·ÏƒÎ·Ï‚ Î¸Î­ÏƒÎ·Ï‚:"

#: src/basic-syntax/type-inference.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v = Vec::new();\n"
"    v.push((10, false));\n"
"    v.push((20, true));\n"
"    println!(\"v: {v:?}\");\n"
"\n"
"    let vv = v.iter().collect::<std::collections::HashSet<_>>();\n"
"    println!(\"vv: {vv:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/type-inference.md:46
#, fuzzy
msgid ""
"[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
"std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-lang."
"org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
"HashSet%3CT,+S%3E) implements."
msgstr ""
"Î¤Î¿ [`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
"html#method.collect) Î²Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ `FromIterator`, Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ \\[`HashSet`\\]"
"(https:/ /doc.rust-lang.org/std/iter/trait.FromIterator.html) Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯."

#: src/basic-syntax/static-and-const.md:1
#, fuzzy
msgid "Static and Constant Variables"
msgstr "Î£Ï„Î±Ï„Î¹ÎºÎ­Ï‚ ÎºÎ±Î¹ ÏƒÏ„Î±Î¸ÎµÏÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚"

#: src/basic-syntax/static-and-const.md:3
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program. "
msgstr ""

#: src/basic-syntax/static-and-const.md:6
#, fuzzy
msgid "`const`"
msgstr "Â«constÂ»."

#: src/basic-syntax/static-and-const.md:8
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr ""

#: src/basic-syntax/static-and-const.md:11
msgid ""
"```rust,editable\n"
"const DIGEST_SIZE: usize = 3;\n"
"const ZERO: Option<u8> = Some(42);\n"
"\n"
"fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {\n"
"    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];\n"
"    for (idx, &b) in text.as_bytes().iter().enumerate() {\n"
"        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE]."
"wrapping_add(b);\n"
"    }\n"
"    digest\n"
"}\n"
"\n"
"fn main() {\n"
"    let digest = compute_digest(\"Hello\");\n"
"    println!(\"Digest: {digest:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:29
#, fuzzy
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"Î£ÏÎ¼Ï†Ï‰Î½Î± Î¼Îµ Ï„Î¿ [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-"
"static.html), Î±Ï…Ï„Î¬ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„ÏÎ½Î¿Î½Ï„Î±Î¹ ÎºÎ±Ï„Î¬ Ï„Î· Ï‡ÏÎ®ÏƒÎ·."

#: src/basic-syntax/static-and-const.md:31
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""

#: src/basic-syntax/static-and-const.md:33
#, fuzzy
msgid "`static`"
msgstr "Â«ÏƒÏ„Î±Ï„Î¹ÎºÏŒÂ»."

#: src/basic-syntax/static-and-const.md:35
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr ""

#: src/basic-syntax/static-and-const.md:37
msgid ""
"```rust,editable\n"
"static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
"\n"
"fn main() {\n"
"    println!(\"{BANNER}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/static-and-const.md:45
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location.  This is useful for unsafe and  embedded code, "
"and the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"ÎŒÏ€Ï‰Ï‚ ÏƒÎ·Î¼ÎµÎ¹ÏÎ½ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-"
"const-vs-static.html), Î±Ï…Ï„Î¬ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î± ÎºÎ±Ï„Î¬ Ï„Î· Ï‡ÏÎ®ÏƒÎ· ÎºÎ±Î¹ Î­Ï‡Î¿Ï…Î½ "
"Î¼Î¹Î± Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÎ® ÏƒÏ…ÏƒÏ‡ÎµÏ„Î¹ÏƒÎ¼Î­Î½Î· Î¸Î­ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚. Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ Î³Î¹Î± Î¼Î· Î±ÏƒÏ†Î±Î»Î® "
"ÎºÎ±Î¹ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î¿ ÎºÏÎ´Î¹ÎºÎ± ÎºÎ±Î¹ Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î¶ÎµÎ¹ ÏƒÎµ ÏŒÎ»Î· Ï„Î·Î½ ÎµÎºÏ„Î­Î»ÎµÏƒÎ· Ï„Î¿Ï… "
"Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚."

#: src/basic-syntax/static-and-const.md:49
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar. It is also possible "
"to have mutable statics, but they require manual synchronisation so any "
"access to them requires `unsafe` code. We will look at [mutable statics](../"
"unsafe/mutable-static-variables.md) in the chapter on Unsafe Rust."
msgstr ""

#: src/basic-syntax/static-and-const.md:57
#, fuzzy
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr ""
"Î‘Î½Î±Ï†Î­ÏÎµÏ„Îµ ÏŒÏ„Î¹ Ï„Î¿ Â«constÂ» ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î­ÏÎµÏ„Î±Î¹ ÏƒÎ·Î¼Î±ÏƒÎ¹Î¿Î»Î¿Î³Î¹ÎºÎ¬ Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Ï„Î¿ "
"Â«constexprÂ» Ï„Î·Ï‚ C++."

#: src/basic-syntax/static-and-const.md:58
#, fuzzy
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr ""
"Î¤Î¿ Â«staticÂ», Î±Ï€ÏŒ Ï„Î·Î½ Î¬Î»Î»Î· Ï€Î»ÎµÏ…ÏÎ¬, Î¼Î¿Î¹Î¬Î¶ÎµÎ¹ Ï€Î¿Î»Ï Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ Î¼Îµ Î¼Î¹Î± Â«constÂ» Î® "
"Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® ÎºÎ±Î¸Î¿Î»Î¹ÎºÎ® Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® ÏƒÏ„Î· C++."

#: src/basic-syntax/static-and-const.md:59
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""

#: src/basic-syntax/static-and-const.md:60
#, fuzzy
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï€Î¿Î»Ï ÏƒÏ…Î½Î·Î¸Î¹ÏƒÎ¼Î­Î½Î¿ Î½Î± Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ Î¼Î¹Î± ÏƒÏ„Î±Î¸ÎµÏÎ¬ Î±Î¾Î¹Î¿Î»ÏŒÎ³Î·ÏƒÎ·Ï‚ "
"Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚, Î±Î»Î»Î¬ ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ ÎºÎ±Î¹ Î±ÏƒÏ†Î±Î»Î­ÏƒÏ„ÎµÏÎ¿ Î±Ï€ÏŒ Ï„Î· Ï‡ÏÎ®ÏƒÎ· ÏƒÏ„Î±Ï„Î¹ÎºÎ¿Ï."

#: src/basic-syntax/static-and-const.md:61
msgid "`thread_local` data can be created with the macro `std::thread_local`."
msgstr ""

#: src/basic-syntax/static-and-const.md:63
msgid "Properties table:"
msgstr ""

#: src/basic-syntax/static-and-const.md:65
msgid "Property"
msgstr ""

#: src/basic-syntax/static-and-const.md:65
#, fuzzy
msgid "Static"
msgstr "Â«ÏƒÏ„Î±Ï„Î¹ÎºÏŒÂ»."

#: src/basic-syntax/static-and-const.md:65
msgid "Constant"
msgstr ""

#: src/basic-syntax/static-and-const.md:67
msgid "Has an address in memory"
msgstr ""

#: src/basic-syntax/static-and-const.md:67
#: src/basic-syntax/static-and-const.md:68
#: src/basic-syntax/static-and-const.md:70
#: src/basic-syntax/static-and-const.md:71
msgid "Yes"
msgstr ""

#: src/basic-syntax/static-and-const.md:67
msgid "No (inlined)"
msgstr ""

#: src/basic-syntax/static-and-const.md:68
#, fuzzy
msgid "Lives for the entire duration of the program"
msgstr "Î— Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Â«ÎºÏÏÎ¹Î±Â» ÎµÎ¯Î½Î±Î¹ Ï„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ ÎµÎ¹ÏƒÏŒÎ´Î¿Ï… Ï„Î¿Ï… Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚."

#: src/basic-syntax/static-and-const.md:68
#: src/basic-syntax/static-and-const.md:69
#: src/basic-syntax/static-and-const.md:71
msgid "No"
msgstr ""

#: src/basic-syntax/static-and-const.md:69
msgid "Can be mutable"
msgstr ""

#: src/basic-syntax/static-and-const.md:69
msgid "Yes (unsafe)"
msgstr ""

#: src/basic-syntax/static-and-const.md:70
#, fuzzy
msgid "Evaluated at compile time"
msgstr "ÎŸÎ¹ Ï„Î¹Î¼Î­Ï‚ Î­Ï‡Î¿Ï…Î½ ÏƒÏ„Î±Î¸ÎµÏÎ¬ Î¼ÎµÎ³Î­Î¸Î· Î³Î½Ï‰ÏƒÏ„Î¬ ÎºÎ±Ï„Î¬ Ï„Î¿ Ï‡ÏÏŒÎ½Î¿ Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚."

#: src/basic-syntax/static-and-const.md:70
msgid "Yes (initialised at compile time)"
msgstr ""

#: src/basic-syntax/static-and-const.md:71
msgid "Inlined wherever it is used"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:3
#, fuzzy
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÏƒÎºÎ¹Î¬Î¶ÎµÏ„Îµ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚, Ï„ÏŒÏƒÎ¿ Î±Ï…Ï„Î­Ï‚ Î±Ï€ÏŒ ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÎ¬ Ï€ÎµÎ´Î¯Î± ÏŒÏƒÎ¿ ÎºÎ±Î¹ "
"Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Î±Ï€ÏŒ Ï„Î¿ Î¯Î´Î¹Î¿ ÎµÏÏÎ¿Ï‚:"

#: src/basic-syntax/scopes-shadowing.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 10;\n"
"    println!(\"before: {a}\");\n"
"\n"
"    {\n"
"        let a = \"hello\";\n"
"        println!(\"inner scope: {a}\");\n"
"\n"
"        let a = true;\n"
"        println!(\"shadowed in inner scope: {a}\");\n"
"    }\n"
"\n"
"    println!(\"after: {a}\");\n"
"}\n"
"```"
msgstr ""

#: src/basic-syntax/scopes-shadowing.md:25
#, fuzzy
msgid ""
"Definition: Shadowing is different from mutation, because after shadowing "
"both variable's memory locations exist at the same time. Both are available "
"under the same name, depending where you use it in the code. "
msgstr ""
"ÎŸÏÎ¹ÏƒÎ¼ÏŒÏ‚: Î— ÏƒÎºÎ¯Î±ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ® Î±Ï€ÏŒ Ï„Î· Î¼ÎµÏ„Î¬Î»Î»Î±Î¾Î·, Î³Î¹Î±Ï„Î¯ Î¼ÎµÏ„Î¬ Ï„Î· ÏƒÎºÎ¯Î±ÏƒÎ· "
"Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÎºÎ±Î¹ Î¿Î¹ Î´ÏÎ¿ Î¸Î­ÏƒÎµÎ¹Ï‚ Î¼Î½Î®Î¼Î·Ï‚ Ï„Î·Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î®Ï‚ Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î±. ÎšÎ±Î¹ Ï„Î± Î´ÏÎ¿ "
"ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î± Î¼Îµ Ï„Î¿ Î¯Î´Î¹Î¿ ÏŒÎ½Î¿Î¼Î±, Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î¿ Ï€Î¿Ï Ï„Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿Î½ "
"ÎºÏ‰Î´Î¹ÎºÏŒ."

#: src/basic-syntax/scopes-shadowing.md:26
#, fuzzy
msgid "A shadowing variable can have a different type. "
msgstr "ÎœÎ¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® ÏƒÎºÎ¯Î±ÏƒÎ·Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡ÎµÎ¹ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏŒ Ï„ÏÏ€Î¿."

#: src/basic-syntax/scopes-shadowing.md:27
#, fuzzy
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr ""
"Î— ÏƒÎºÎ¯Î±ÏƒÎ· Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ Î±ÏƒÎ±Ï†Î®Ï‚ ÏƒÏ„Î·Î½ Î±ÏÏ‡Î®, Î±Î»Î»Î¬ ÎµÎ¯Î½Î±Î¹ Î²Î¿Î»Î¹ÎºÎ® Î³Î¹Î± Î½Î± ÎºÏÎ±Ï„Î¬Ï„Îµ Ï„Î¹Ï‚ "
"Ï„Î¹Î¼Î­Ï‚ Î¼ÎµÏ„Î¬ Ï„Î¿ Â«.unwrap()Â»."

#: src/basic-syntax/scopes-shadowing.md:28
#, fuzzy
msgid ""
"The following code demonstrates why the compiler can't simply reuse memory "
"locations when shadowing an immutable variable in a scope, even if the type "
"does not change."
msgstr ""
"ÎŸ Î±ÎºÏŒÎ»Î¿Ï…Î¸Î¿Ï‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Î³Î¹Î±Ï„Î¯ Î¿ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î±Ï€Î»ÏÏ‚ Î½Î± "
"ÎµÏ€Î±Î½Î±Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹ Î¸Î­ÏƒÎµÎ¹Ï‚ Î¼Î½Î®Î¼Î·Ï‚ ÏŒÏ„Î±Î½ ÏƒÎºÎ¹Î¬Î¶ÎµÎ¹ Î¼Î¹Î± Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® ÏƒÎµ "
"Î­Î½Î± ÎµÏÏÎ¿Ï‚, Î±ÎºÏŒÎ¼Î± ÎºÎ¹ Î±Î½ Î¿ Ï„ÏÏ€Î¿Ï‚ Î´ÎµÎ½ Î±Î»Î»Î¬Î¾ÎµÎ¹."

#: src/basic-syntax/scopes-shadowing.md:30
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let a = 1;\n"
"    let b = &a;\n"
"    let a = a + 1;\n"
"    println!(\"{a} {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:3
#, fuzzy
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr ""
"Î— Î»Î­Î¾Î·-ÎºÎ»ÎµÎ¹Î´Î¯ Â«enumÂ» ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Ï„Î· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎµÎ½ÏŒÏ‚ Ï„ÏÏ€Î¿Ï… Ï€Î¿Ï… Î­Ï‡ÎµÎ¹ Î»Î¯Î³Î¿Ï…Ï‚ "
"Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚:"

#: src/enums.md:6
msgid ""
"```rust,editable\n"
"fn generate_random_number() -> i32 {\n"
"    // Implementation based on https://xkcd.com/221/\n"
"    4  // Chosen by fair dice roll. Guaranteed to be random.\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"enum CoinFlip {\n"
"    Heads,\n"
"    Tails,\n"
"}\n"
"\n"
"fn flip_coin() -> CoinFlip {\n"
"    let random_number = generate_random_number();\n"
"    if random_number % 2 == 0 {\n"
"        return CoinFlip::Heads;\n"
"    } else {\n"
"        return CoinFlip::Tails;\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"You got: {:?}\", flip_coin());\n"
"}\n"
"```"
msgstr ""

#: src/enums.md:36
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type"
msgstr ""
"ÎŸÎ¹ Î±Ï€Î±ÏÎ¹Î¸Î¼Î®ÏƒÎµÎ¹Ï‚ ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î½ Î½Î± ÏƒÏ…Î»Î»Î­Î³ÎµÏ„Îµ Î­Î½Î± ÏƒÏÎ½Î¿Î»Î¿ Ï„Î¹Î¼ÏÎ½ ÎºÎ¬Ï„Ï‰ Î±Ï€ÏŒ Î­Î½Î±Î½ "
"Ï„ÏÏ€Î¿"

#: src/enums.md:37
#, fuzzy
msgid ""
"This page offers an enum type `CoinFlip` with two variants `Heads` and "
"`Tails`. You might note the namespace when using variants."
msgstr ""
"Î‘Ï…Ï„Î® Î· ÏƒÎµÎ»Î¯Î´Î± Ï€ÏÎ¿ÏƒÏ†Î­ÏÎµÎ¹ Î­Î½Î±Î½ Ï„ÏÏ€Î¿ \"CoinFlip\" Î¼Îµ Î´ÏÎ¿ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚ \"Heads\" "
"ÎºÎ±Î¹ \"Tail\". ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÏ„Îµ Ï„Î¿Î½ Ï‡ÏÏÎ¿ Î¿Î½Î¿Î¼Î¬Ï„Ï‰Î½ ÏŒÏ„Î±Î½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ "
"Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚."

#: src/enums.md:38
#, fuzzy
msgid "This might be a good time to compare Structs and Enums:"
msgstr ""
"Î‘Ï…Ï„Î® Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÎºÎ±Î»Î® ÏƒÏ„Î¹Î³Î¼Î® Î³Î¹Î± Î½Î± ÏƒÏ…Î³ÎºÏÎ¯Î½ÎµÏ„Îµ Structs ÎºÎ±Î¹ Enums:"

#: src/enums.md:39
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads). "
msgstr ""
"ÎšÎ±Î¹ ÏƒÏ„Î± Î´ÏÎ¿, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î­Ï‡ÎµÏ„Îµ Î¼Î¹Î± Î±Ï€Î»Î® Î­ÎºÎ´Î¿ÏƒÎ· Ï‡Ï‰ÏÎ¯Ï‚ Ï€ÎµÎ´Î¯Î± (Î¼Î¿Î½Î¬Î´Î± Î´Î¿Î¼Î®Ï‚) Î® "
"Î¼Î¹Î± Î¼Îµ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¿ÏÏ‚ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€ÎµÎ´Î¯Ï‰Î½ (Ï‰Ï†Î­Î»Î¹Î¼Î± Ï†Î¿ÏÏ„Î¯Î± Ï€Î±ÏÎ±Î»Î»Î±Î³Î®Ï‚)."

#: src/enums.md:40
#, fuzzy
msgid "In both, associated functions are defined within an `impl` block."
msgstr ""
"ÎšÎ±Î¹ ÏƒÏ„Î¹Ï‚ Î´ÏÎ¿, Î¿Î¹ ÏƒÏ…ÏƒÏ‡ÎµÏ„Î¹ÏƒÎ¼Î­Î½ÎµÏ‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Î¿ÏÎ¯Î¶Î¿Î½Ï„Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÎµ Î­Î½Î± Î¼Ï€Î»Î¿Îº "
"Â«implÂ»."

#: src/enums.md:41
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldnâ€™t be the same type as they would if they were "
"all defined in an enum. "
msgstr ""
"Î˜Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Ï„Îµ Î±ÎºÏŒÎ¼Î· ÎºÎ±Î¹ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ Ï„Î¹Ï‚ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚ ÎµÎ½ÏŒÏ‚ enum "
"Î¼Îµ Î¾ÎµÏ‡Ï‰ÏÎ¹ÏƒÏ„Î­Ï‚ Î´Î¿Î¼Î­Ï‚, Î±Î»Î»Î¬ Ï„ÏŒÏ„Îµ Î´ÎµÎ½ Î¸Î± Î®Ï„Î±Î½ Ï„Î¿Ï… Î¯Î´Î¹Î¿Ï… Ï„ÏÏ€Î¿Ï… ÏŒÏ€Ï‰Ï‚ Î¸Î± Î®Ï„Î±Î½ Î±Î½ "
"ÎµÎ¯Ï‡Î±Î½ Î¿ÏÎ¹ÏƒÏ„ÎµÎ¯ ÏŒÎ»ÎµÏ‚ ÏƒÎµ Î­Î½Î± enum."

#: src/enums/variant-payloads.md:3
#, fuzzy
msgid ""
"You can define richer enums where the variants carry data. You can then use "
"the `match` statement to extract the data from each variant:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î¿ÏÎ¯ÏƒÎµÏ„Îµ Ï€Î»Î¿Ï…ÏƒÎ¹ÏŒÏ„ÎµÏÎ¿Ï…Ï‚ Î±ÏÎ¹Î¸Î¼Î¿ÏÏ‚ ÏŒÏ€Î¿Ï… Î¿Î¹ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚ Î¼ÎµÏ„Î±Ï†Î­ÏÎ¿Ï…Î½ "
"Î´ÎµÎ´Î¿Î¼Î­Î½Î±. Î£Ï„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Î”Î®Î»Ï‰ÏƒÎ· Â«Ï„Î±Î¹ÏÎ¹Î¬ÏƒÎ¼Î±Ï„Î¿Ï‚Â» "
"Î³Î¹Î± ÎµÎ¾Î±Î³Ï‰Î³Î® Ï„Ï‰Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î±Ï€ÏŒ ÎºÎ¬Î¸Îµ Ï€Î±ÏÎ±Î»Î»Î±Î³Î®:"

#: src/enums/variant-payloads.md:6
msgid ""
"```rust,editable\n"
"enum WebEvent {\n"
"    PageLoad,                 // Variant without payload\n"
"    KeyPress(char),           // Tuple struct variant\n"
"    Click { x: i64, y: i64 }, // Full struct variant\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(event: WebEvent) {\n"
"    match event {\n"
"        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
"        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
"        WebEvent::Click { x, y } => println!(\"clicked at x={x}, y={y}\"),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let load = WebEvent::PageLoad;\n"
"    let press = WebEvent::KeyPress('x');\n"
"    let click = WebEvent::Click { x: 20, y: 80 };\n"
"\n"
"    inspect(load);\n"
"    inspect(press);\n"
"    inspect(click);\n"
"}\n"
"```"
msgstr ""

#: src/enums/variant-payloads.md:35
#, fuzzy
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched. The pattern binds references to the fields in the \"match arm\" "
"after the `=>`."
msgstr ""
"Î£Ï„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î· Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î¿ \"char\" ÏƒÏ„Î¿ \"KeyPress\" Î® ÏƒÏ„Î¿ "
"\"x\" ÎºÎ±Î¹ \"y\" ÏƒÏ„Î¿ \"Click\" Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Î¼ÏŒÎ½Î¿ Î¼Î­ÏƒÎ± ÏƒÎµ Î¼Î¹Î± Î´Î®Î»Ï‰ÏƒÎ· "
"\"Ï„Î±Î¹ÏÎ¹Î¬Î¶Î¿Ï…Î½\"."

#: src/enums/variant-payloads.md:36
#, fuzzy
msgid ""
"The expression is matched against the patterns from top to bottom. There is "
"no fall-through like in C or C++."
msgstr "Î¤Î¿ \"match\" ÎµÏ€Î¹Î¸ÎµÏ‰ÏÎµÎ¯ Î­Î½Î± ÎºÏÏ…Ï†ÏŒ Ï€ÎµÎ´Î¯Î¿ Î´Î¹Î¬ÎºÏÎ¹ÏƒÎ·Ï‚ ÏƒÏ„Î¿ \"enum\"."

#: src/enums/variant-payloads.md:37
#, fuzzy
msgid ""
"The match expression has a value. The value is the last expression in the "
"match arm which was executed."
msgstr ""
"Î¤Î¿ \"WebEvent::Click { ... }\" Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î±ÎºÏÎ¹Î²ÏÏ‚ Ï„Î¿ Î¯Î´Î¹Î¿ Î¼Îµ Ï„Î¿ \"WebEvent::"
"Click(Click)\" Î¼Îµ Î­Î½Î± Î±Î½ÏÏ„ÎµÏÎ¿ ÎµÏ€Î¯Ï€ÎµÎ´Î¿ \"struct Click { ... }\". Î— "
"ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î· Î­ÎºÎ´Î¿ÏƒÎ· Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÎ¹ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬, Î³Î¹Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±."

#: src/enums/variant-payloads.md:38
msgid ""
"Starting from the top we look for what pattern matches the value then run "
"the code following the arrow. Once we find a match, we stop. "
msgstr ""

#: src/enums/variant-payloads.md:39
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled. "
msgstr ""

#: src/enums/variant-payloads.md:40
msgid "`match` inspects a hidden discriminant field in the `enum`."
msgstr ""

#: src/enums/variant-payloads.md:41
msgid ""
"It is possible to retrieve the discriminant by calling `std::mem::"
"discriminant()`"
msgstr ""

#: src/enums/variant-payloads.md:42
msgid ""
"This is useful, for example, if implementing `PartialEq` for structs where "
"comparing field values doesn't affect equality."
msgstr ""

#: src/enums/variant-payloads.md:43
msgid ""
"`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
"Click(Click)` with a top level `struct Click { ... }`. The inlined version "
"cannot implement traits, for example."
msgstr ""

#: src/enums/sizes.md:3
#, fuzzy
msgid ""
"Rust enums are packed tightly, taking constraints due to alignment into "
"account:"
msgstr ""
"ÎŸÎ¹ ÏƒÎºÎ¿Ï…ÏÎ¹Î­Ï‚ ÏƒÏ…ÏƒÎºÎµÏ…Î¬Î¶Î¿Î½Ï„Î±Î¹ ÏƒÏ†Î¹Ï‡Ï„Î¬, Î»Î±Î¼Î²Î¬Î½Î¿Î½Ï„Î±Ï‚ Ï…Ï€ÏŒÏˆÎ· Ï„Î¿Ï…Ï‚ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿ÏÏ‚ Î»ÏŒÎ³Ï‰ "
"ÎµÏ…Î¸Ï…Î³ÏÎ¬Î¼Î¼Î¹ÏƒÎ·Ï‚:"

#: src/enums/sizes.md:5
msgid ""
"```rust,editable\n"
"use std::any::type_name;\n"
"use std::mem::{align_of, size_of};\n"
"\n"
"fn dbg_size<T>() {\n"
"    println!(\"{}: size {} bytes, align: {} bytes\",\n"
"        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
"}\n"
"\n"
"enum Foo {\n"
"    A,\n"
"    B,\n"
"}\n"
"\n"
"fn main() {\n"
"    dbg_size::<Foo>();\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:24
#, fuzzy
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."
msgstr ""
"Î”ÎµÎ¯Ï„Îµ Ï„Î¿ [Rust Reference](https://doc.rust-lang.org/reference/type-layout."
"html)."

#: src/enums/sizes.md:30
msgid ""
"Internally Rust is using a field (discriminant) to keep track of the enum "
"variant."
msgstr ""

#: src/enums/sizes.md:32
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr ""

#: src/enums/sizes.md:34
msgid ""
"```rust,editable\n"
"#[repr(u32)]\n"
"enum Bar {\n"
"    A,  // 0\n"
"    B = 10000,\n"
"    C,  // 10001\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"A: {}\", Bar::A as u32);\n"
"    println!(\"B: {}\", Bar::B as u32);\n"
"    println!(\"C: {}\", Bar::C as u32);\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:49
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""

#: src/enums/sizes.md:53
msgid "Try out other types such as"
msgstr ""

#: src/enums/sizes.md:55
msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
msgstr ""

#: src/enums/sizes.md:56
msgid ""
"`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche optimization, "
"see below),"
msgstr ""

#: src/enums/sizes.md:57
msgid "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
msgstr ""

#: src/enums/sizes.md:58
msgid ""
"`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
"optimization, see below)."
msgstr ""

#: src/enums/sizes.md:60
msgid ""
"Niche optimization: Rust will merge unused bit patterns for the enum "
"discriminant."
msgstr ""

#: src/enums/sizes.md:63
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""

#: src/enums/sizes.md:67
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""

#: src/enums/sizes.md:70
msgid ""
"```rust,editable\n"
"use std::mem::transmute;\n"
"\n"
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        println!(\"Bitwise representation of bool\");\n"
"        dbg_bits!(false, u8);\n"
"        dbg_bits!(true, u8);\n"
"\n"
"        println!(\"Bitwise representation of Option<bool>\");\n"
"        dbg_bits!(None::<bool>, u8);\n"
"        dbg_bits!(Some(false), u8);\n"
"        dbg_bits!(Some(true), u8);\n"
"\n"
"        println!(\"Bitwise representation of Option<Option<bool>>\");\n"
"        dbg_bits!(Some(Some(false)), u8);\n"
"        dbg_bits!(Some(Some(true)), u8);\n"
"        dbg_bits!(Some(None::<bool>), u8);\n"
"        dbg_bits!(None::<Option<bool>>, u8);\n"
"\n"
"        println!(\"Bitwise representation of Option<&i32>\");\n"
"        dbg_bits!(None::<&i32>, usize);\n"
"        dbg_bits!(Some(&0i32), usize);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/enums/sizes.md:105
msgid ""
"More complex example if you want to discuss what happens when we chain more "
"than 256 `Option`s together."
msgstr ""

#: src/enums/sizes.md:107
msgid ""
"```rust,editable\n"
"#![recursion_limit = \"1000\"]\n"
"\n"
"use std::mem::transmute;\n"
"\n"
"macro_rules! dbg_bits {\n"
"    ($e:expr, $bit_type:ty) => {\n"
"        println!(\"- {}: {:#x}\", stringify!($e), transmute::<_, "
"$bit_type>($e));\n"
"    };\n"
"}\n"
"\n"
"// Macro to wrap a value in 2^n Some() where n is the number of \"@\" "
"signs.\n"
"// Increasing the recursion limit is required to evaluate this macro.\n"
"macro_rules! many_options {\n"
"    ($value:expr) => { Some($value) };\n"
"    ($value:expr, @) => {\n"
"        Some(Some($value))\n"
"    };\n"
"    ($value:expr, @ $($more:tt)+) => {\n"
"        many_options!(many_options!($value, $($more)+), $($more)+)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise\n"
"    // representation of types.\n"
"    unsafe {\n"
"        assert_eq!(many_options!(false), Some(false));\n"
"        assert_eq!(many_options!(false, @), Some(Some(false)));\n"
"        assert_eq!(many_options!(false, @@), "
"Some(Some(Some(Some(false)))));\n"
"\n"
"        println!(\"Bitwise representation of a chain of 128 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@), u8);\n"
"        dbg_bits!(many_options!(true, @@@@@@@), u8);\n"
"\n"
"        println!(\"Bitwise representation of a chain of 256 Option's.\");\n"
"        dbg_bits!(many_options!(false, @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(true, @@@@@@@@), u16);\n"
"\n"
"        println!(\"Bitwise representation of a chain of 257 Option's.\");\n"
"        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);\n"
"        dbg_bits!(many_options!(None::<bool>, @@@@@@@@), u16);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/novel.md:3
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr ""

#: src/control-flow/novel.md:6 src/control-flow/if-let-expressions.md:1
#, fuzzy
msgid "`if let` expressions"
msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ \"Î±Î½ Î±Ï‚\"."

#: src/control-flow/novel.md:7
#, fuzzy
msgid "`while let` expressions"
msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Â«ÎµÎ½Ï Î±Ï‚Â»."

#: src/control-flow/novel.md:8 src/control-flow/match-expressions.md:1
#, fuzzy
msgid "`match` expressions"
msgstr "Â«Ï„Î±Î¹ÏÎ¹Î¬Î¶Î¿Ï…Î½Â» ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚"

#: src/control-flow/if-let-expressions.md:3
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""

#: src/control-flow/if-let-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let arg = std::env::args().next();\n"
"    if let Some(value) = arg {\n"
"        println!(\"Program name: {value}\");\n"
"    } else {\n"
"        println!(\"Missing name?\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/if-let-expressions.md:18
#: src/control-flow/while-let-expressions.md:21
#: src/control-flow/match-expressions.md:23
#, fuzzy
msgid ""
"See [pattern matching](../pattern-matching.md) for more details on patterns "
"in Rust."
msgstr ""
"Î”ÎµÎ¯Ï„Îµ Ï„Î¿ [pattern matching](../pattern-matching.md) Î³Î¹Î± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ "
"Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î± Î¼Î¿Ï„Î¯Î²Î± ÏƒÏ„Î¿ Î£ÎºÎ¿Ï…ÏÎ¹Î¬."

#: src/control-flow/if-let-expressions.md:23
#, fuzzy
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr ""
"Î£Îµ Î±Î½Ï„Î¯Î¸ÎµÏƒÎ· Î¼Îµ Ï„Î¿ \"match\", Ï„Î¿ \"if let\" Î´ÎµÎ½ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÎ¹ Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏ…Ï„Î¹ÎºÎ­Ï‚ "
"ÏÎ®Ï„ÏÎµÏ‚ Î³Î¹Î± Ï„Î·Î½ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î¼Î¿Ï„Î¯Î²Ï‰Î½."

#: src/control-flow/if-let-expressions.md:24
#, fuzzy
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr ""
"ÎœÎ¹Î± ÎºÎ¿Î¹Î½Î® Ï‡ÏÎ®ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Î¿ Ï‡ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï„Ï‰Î½ Ï„Î¹Î¼ÏÎ½ \"ÎœÎµÏÎ¹ÎºÏÎ½\" ÏŒÏ„Î±Î½ ÎµÏÎ³Î¬Î¶ÎµÏƒÏ„Îµ Î¼Îµ Ï„Î¿ "
"\"Option\"."

#: src/control-flow/if-let-expressions.md:25
#, fuzzy
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr ""
"Î£Îµ Î±Î½Ï„Î¯Î¸ÎµÏƒÎ· Î¼Îµ Ï„Î¿ \"match\", Ï„Î¿ \"if let\" Î´ÎµÎ½ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÎ¹ Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏ…Ï„Î¹ÎºÎ­Ï‚ "
"ÏÎ®Ï„ÏÎµÏ‚ Î³Î¹Î± Ï„Î·Î½ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î¼Î¿Ï„Î¯Î²Ï‰Î½."

#: src/control-flow/if-let-expressions.md:26
msgid ""
"Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-example/"
"flow_control/let_else.html) construct allows to do a destructuring "
"assignment, or if it fails, execute a block which is required to abort "
"normal control flow (with `panic`/`return`/`break`/`continue`):"
msgstr ""

#: src/control-flow/if-let-expressions.md:28
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    println!(\"{:?}\", second_word_to_upper(\"foo bar\"));\n"
"}\n"
" \n"
"fn second_word_to_upper(s: &str) -> Option<String> {\n"
"    let mut it = s.split(' ');\n"
"    let (Some(_), Some(item)) = (it.next(), it.next()) else {\n"
"        return None;\n"
"    };\n"
"    Some(item.to_uppercase())\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:1
#, fuzzy
msgid "`while let` loops"
msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Â«ÎµÎ½Ï Î±Ï‚Â»."

#: src/control-flow/while-let-expressions.md:3
#, fuzzy
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"ÎŒÏ€Ï‰Ï‚ ÎºÎ±Î¹ Î¼Îµ Ï„Î¿ \"if\", Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¼Î¹Î± Ï€Î±ÏÎ±Î»Î»Î±Î³Î® \"while let\" Ï€Î¿Ï… ÎµÎ»Î­Î³Ï‡ÎµÎ¹ "
"ÎµÏ€Î±Î½ÎµÎ¹Î»Î·Î¼Î¼Î­Î½Î± Î¼Î¹Î± Ï„Î¹Î¼Î® ÏƒÎµ ÏƒÏ‡Î­ÏƒÎ· Î¼Îµ Î­Î½Î± Î¼Î¿Ï„Î¯Î²Î¿:"

#: src/control-flow/while-let-expressions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    while let Some(x) = iter.next() {\n"
"        println!(\"x: {x}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/while-let-expressions.md:17
#, fuzzy
msgid ""
"Here the iterator returned by `v.into_iter()` will return a `Option<i32>` on "
"every call to `next()`. It returns `Some(x)` until it is done, after which "
"it will return `None`. The `while let` lets us keep iterating through all "
"items."
msgstr ""
"Î•Î´Ï Î¿ ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·Ï‚ Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿ `v.iter()` Î¸Î± ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎµÎ¹ Î­Î½Î± "
"`Option<i32>` ÏƒÎµ ÎºÎ¬Î¸Îµ ÎºÎ»Î®ÏƒÎ· ÏƒÏ„Î¿ `ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿()`. Î•Ï€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ \"Some(x)\" Î¼Î­Ï‡ÏÎ¹ Î½Î± "
"Î¿Î»Î¿ÎºÎ»Î·ÏÏ‰Î¸ÎµÎ¯, Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ Î±Ï…Ï„ÏŒ Î¸Î± Î³Î¯Î½ÎµÎ¹ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Â«ÎšÎ±Î½Î­Î½Î±Â». Î¤Î¿ \"while let\" Î¼Î±Ï‚ "
"ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎ¿Ï…Î¼Îµ Î½Î± ÎµÏ€Î±Î½Î±Î»Î±Î¼Î²Î¬Î½Î¿Ï…Î¼Îµ ÏŒÎ»Î± Ï„Î± ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±."

#: src/control-flow/while-let-expressions.md:26
#, fuzzy
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr ""
"Î•Ï€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ ÏŒÏ„Î¹ Î¿ Î²ÏÏŒÏ‡Î¿Ï‚ \"while let\" Î¸Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎµÎ¹ Î½Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÏŒÏƒÎ¿ Î· Ï„Î¹Î¼Î® "
"Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ Î¼Îµ Ï„Î¿ Î¼Î¿Ï„Î¯Î²Î¿."

#: src/control-flow/while-let-expressions.md:27
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `iter.next()`. "
"The `while let` provides syntactic sugar for the above scenario."
msgstr ""
"Î˜Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Ï„Îµ Î½Î± Î¾Î±Î½Î±Î³ÏÎ¬ÏˆÎµÏ„Îµ Ï„Î¿Î½ Î²ÏÏŒÏ‡Î¿ Â«while letÂ» Ï‰Ï‚ Î¬Ï€ÎµÎ¹ÏÎ¿ Î²ÏÏŒÏ‡Î¿ Î¼Îµ Î¼Î¹Î± "
"Ï€ÏÏŒÏ„Î±ÏƒÎ· if Ï€Î¿Ï… Î´Î¹Î±ÎºÏŒÏ€Ï„ÎµÏ„Î±Î¹ ÏŒÏ„Î±Î½ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï„Î¹Î¼Î® Î³Î¹Î± Î¾ÎµÏ„ÏÎ»Î¹Î³Î¼Î± Î³Î¹Î± Ï„Î¿ Â«iter."
"next()Â». Î¤Î¿ \"while let\" Ï€Î±ÏÎ­Ï‡ÎµÎ¹ ÏƒÏ…Î½Ï„Î±ÎºÏ„Î¹ÎºÎ® Î¶Î¬Ï‡Î±ÏÎ· Î³Î¹Î± Ï„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ ÏƒÎµÎ½Î¬ÏÎ¹Î¿."

#: src/control-flow/match-expressions.md:3
#, fuzzy
msgid ""
"The [`match` keyword](https://doc.rust-lang.org/reference/expressions/match-"
"expr.html) is used to match a value against one or more patterns. In that "
"sense, it works like a series of `if let` expressions:"
msgstr ""
"Î— Î»Î­Î¾Î·-ÎºÎ»ÎµÎ¹Î´Î¯ \"Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯Î±\" Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Ï„Î·Î½ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î¼Î¹Î±Ï‚ "
"Ï„Î¹Î¼Î®Ï‚ Î¼Îµ Î­Î½Î± Î® Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± Î¼Î¿Ï„Î¯Î²Î±. Î£Îµ ÎœÎµ Î±Ï…Ï„Î® Ï„Î·Î½ Î­Î½Î½Î¿Î¹Î±, Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÏƒÎ±Î½ Î¼Î¹Î± "
"ÏƒÎµÎ¹ÏÎ¬ Î±Ï€ÏŒ ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Â«Î±Î½ Î±Ï‚Â»:"

#: src/control-flow/match-expressions.md:7
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    match std::env::args().next().as_deref() {\n"
"        Some(\"cat\") => println!(\"Will do cat things\"),\n"
"        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
"        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
"        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
"        None        => println!(\"Hmm, no program name?\"),\n"
"        _           => println!(\"Unknown program name!\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/control-flow/match-expressions.md:20
#, fuzzy
msgid ""
"Like `if let`, each match arm must have the same type. The type is the last "
"expression of the block, if any. In the example above, the type is `()`."
msgstr ""
"ÎŒÏ€Ï‰Ï‚ Ï„Î¿ \"Î±Î½ Î±Ï‚\", ÎºÎ¬Î¸Îµ Î²ÏÎ±Ï‡Î¯Î¿Î½Î±Ï‚ Î±Î³ÏÎ½Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î­Ï‡ÎµÎ¹ Ï„Î¿Î½ Î¯Î´Î¹Î¿ Ï„ÏÏ€Î¿. ÎŸ "
"Ï„ÏÏ€Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î¿Ï‚ Î­ÎºÏ†ÏÎ±ÏƒÎ· Ï„Î¿Ï… Î¼Ï€Î»Î¿Îº, ÎµÎ¬Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹. Î£Ï„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ "
"Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î¿ Ï„ÏÏ€Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ `()`."

#: src/control-flow/match-expressions.md:28
msgid "Save the match expression to a variable and print it out."
msgstr ""

#: src/control-flow/match-expressions.md:29
msgid "Remove `.as_deref()` and explain the error."
msgstr ""

#: src/control-flow/match-expressions.md:30
msgid ""
"`std::env::args().next()` returns an `Option<String>`, but we cannot match "
"against `String`."
msgstr ""

#: src/control-flow/match-expressions.md:31
msgid ""
"`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our case, "
"this turns `Option<String>` into `Option<&str>`."
msgstr ""

#: src/control-flow/match-expressions.md:32
msgid ""
"We can now use pattern matching to match against the `&str` inside `Option`."
msgstr ""

#: src/pattern-matching.md:3
#, fuzzy
msgid ""
"The `match` keyword let you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"Î— Î»Î­Î¾Î·-ÎºÎ»ÎµÎ¹Î´Î¯ \"Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯Î±\" ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯ÏƒÎµÏ„Îµ Î¼Î¹Î± Ï„Î¹Î¼Î® Î¼Îµ "
"Î­Î½Î± Î® Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± _patterns_. Î¿ ÎŸÎ¹ ÏƒÏ…Î³ÎºÏÎ¯ÏƒÎµÎ¹Ï‚ Î³Î¯Î½Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Ï€Î¬Î½Ï‰ Ï€ÏÎ¿Ï‚ Ï„Î± ÎºÎ¬Ï„Ï‰ "
"ÎºÎ±Î¹ Î¿ Ï€ÏÏÏ„Î¿Ï‚ Î±Î³ÏÎ½Î±Ï‚ ÎºÎµÏÎ´Î¯Î¶ÎµÎ¹."

#: src/pattern-matching.md:6
#, fuzzy
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr ""
"Î¤Î± Î¼Î¿Ï„Î¯Î²Î± Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»Î­Ï‚ Ï„Î¹Î¼Î­Ï‚, Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Ï„Î¿ Â«switchÂ» ÏƒÎµ C ÎºÎ±Î¹ C++:"

#: src/pattern-matching.md:8
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let input = 'x';\n"
"\n"
"    match input {\n"
"        'q'                   => println!(\"Quitting\"),\n"
"        'a' | 's' | 'w' | 'd' => println!(\"Moving around\"),\n"
"        '0'..='9'             => println!(\"Number input\"),\n"
"        _                     => println!(\"Something else\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching.md:21
#, fuzzy
msgid "The `_` pattern is a wildcard pattern which matches any value."
msgstr ""
"Î¤Î¿ Î¼Î¿Ï„Î¯Î²Î¿ `_` ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Î¼Î¿Ï„Î¯Î²Î¿ Î¼Ï€Î±Î»Î±Î½Ï„Î­Ï Ï€Î¿Ï… Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ Î¼Îµ Î¿Ï€Î¿Î¹Î±Î´Î®Ï€Î¿Ï„Îµ Ï„Î¹Î¼Î®."

#: src/pattern-matching.md:26
#, fuzzy
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/pattern-matching.md:27
#, fuzzy
msgid "`|` as an `or`"
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/pattern-matching.md:28
#, fuzzy
msgid "`..` can expand as much as it needs to be"
msgstr ""
"Î˜Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Ï„Îµ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Ï€ÏÏ‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿Î¹ ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿Î¹ "
"Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎµÏ‚ ÏŒÏ„Î±Î½ Î²ÏÎ¯ÏƒÎºÎ¿Î½Ï„Î±Î¹ ÏƒÎµ Î­Î½Î± Î´Î¯Ï€Î»Ï‰Î¼Î± ÎµÏ…ÏÎµÏƒÎ¹Ï„ÎµÏ‡Î½Î¯Î±Ï‚"

#: src/pattern-matching.md:29
#, fuzzy
msgid "`1..=5` represents an inclusive range"
msgstr "Â«|Â» Ï‰Ï‚ Â«Î®Â»."

#: src/pattern-matching.md:30
#, fuzzy
msgid "`_` is a wild card"
msgstr "Î¤Î¿ Â«..Â» Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÏ€ÎµÎºÏ„Î±Î¸ÎµÎ¯ ÏŒÏƒÎ¿ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹"

#: src/pattern-matching.md:31
#, fuzzy
msgid ""
"It can be useful to show how binding works, by for instance replacing a "
"wildcard character with a variable, or removing the quotes around `q`."
msgstr "Î¤Î¿ \"1..=5\" Î±Î½Ï„Î¹Ï€ÏÎ¿ÏƒÏ‰Ï€ÎµÏÎµÎ¹ Î­Î½Î± ÎµÏÏÎ¿Ï‚ Ï€Î¿Ï… Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹"

#: src/pattern-matching.md:32
#, fuzzy
msgid "You can demonstrate matching on a reference."
msgstr "Î¤Î¿ `_` ÎµÎ¯Î½Î±Î¹ Î¼Ï€Î±Î»Î±Î½Ï„Î­Ï"

#: src/pattern-matching.md:33
#, fuzzy
msgid ""
"This might be a good time to bring up the concept of irrefutable patterns, "
"as the term can show up in error messages."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ Î½Î± Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï€ÏÏ‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Ï„Î¿ Î´ÎµÏƒÎ¼ÎµÏ…Ï„Î¹ÎºÏŒ, Î³Î¹Î± "
"Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Î±Î½Ï„Î¹ÎºÎ±Î¸Î¹ÏƒÏ„ÏÎ½Ï„Î±Ï‚ Î­Î½Î±Î½ Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎ± Î¼Ï€Î±Î»Î±Î½Ï„Î­Ï Î¼Îµ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î® "
"Î±Ï†Î±Î¹ÏÏÎ½Ï„Î±Ï‚ Ï„Î± ÎµÎ¹ÏƒÎ±Î³Ï‰Î³Î¹ÎºÎ¬ Î³ÏÏÏ‰ Î±Ï€ÏŒ Ï„Î¿ `q`.\n"
"\n"
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï„Î·Î½ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· ÏƒÎµ Î¼Î¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬.\n"
"\n"
"Î‘Ï…Ï„Î® Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÎºÎ±Î»Î® ÏƒÏ„Î¹Î³Î¼Î® Î³Î¹Î± Î½Î± Î±Î½Î±Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï„Î·Î½ Î­Î½Î½Î¿Î¹Î± Ï„Ï‰Î½ "
"Î±Î´Î¹Î±Î¼Ï†Î¹ÏƒÎ²Î®Ï„Î·Ï„Ï‰Î½ Ï€ÏÎ¿Ï„ÏÏ€Ï‰Î½, ÎºÎ±Î¸ÏÏ‚ Î¿ ÏŒÏÎ¿Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹ ÏƒÎµ Î¼Î·Î½ÏÎ¼Î±Ï„Î± "
"Î»Î¬Î¸Î¿Ï…Ï‚."

#: src/pattern-matching/destructuring-enums.md:3
#, fuzzy
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"Î¤Î± Î¼Î¿Ï„Î¯Î²Î± Î¼Ï€Î¿ÏÎ¿ÏÎ½ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸Î¿ÏÎ½ Î³Î¹Î± Ï„Î· ÏƒÏÎ½Î´ÎµÏƒÎ· Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ ÏƒÎµ "
"Î¼Î­ÏÎ· Ï„Ï‰Î½ Ï„Î¹Î¼ÏÎ½ ÏƒÎ±Ï‚. Î•Ï„ÏƒÎ¹ ÎµÏ€Î¹Î¸ÎµÏ‰ÏÎµÎ¯Ï„Îµ Ï„Î· Î´Î¿Î¼Î® Ï„Ï‰Î½ Ï„ÏÏ€Ï‰Î½ ÏƒÎ±Ï‚. Î‘Ï‚ Î¾ÎµÎºÎ¹Î½Î®ÏƒÎ¿Ï…Î¼Îµ "
"Î¼Îµ Î­Î½Î±Î½ Î±Ï€Î»ÏŒ Ï„ÏÏ€Î¿ Â«enumÂ»:"

#: src/pattern-matching/destructuring-enums.md:6
msgid ""
"```rust,editable\n"
"enum Result {\n"
"    Ok(i32),\n"
"    Err(String),\n"
"}\n"
"\n"
"fn divide_in_two(n: i32) -> Result {\n"
"    if n % 2 == 0 {\n"
"        Result::Ok(n / 2)\n"
"    } else {\n"
"        Result::Err(format!(\"cannot divide {n} into two equal parts\"))\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let n = 100;\n"
"    match divide_in_two(n) {\n"
"        Result::Ok(half) => println!(\"{n} divided in two is {half}\"),\n"
"        Result::Err(msg) => println!(\"sorry, an error happened: {msg}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-enums.md:29
#, fuzzy
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"Î•Î´Ï Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ±Î¼Îµ Ï„Î¿Ï…Ï‚ Î²ÏÎ±Ï‡Î¯Î¿Î½ÎµÏ‚ Î³Î¹Î± Î½Î± _ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ_ Ï„Î·Î½ Ï„Î¹Î¼Î® "
"\"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\". ÎšÎ±Ï„Î¬ Ï„Î·Î½ Ï€ÏÏÏ„Î· Î²ÏÎ±Ï‡Î¯Î¿Î½Î±, Ï„Î¿ \"Î¼Î¹ÏƒÏŒ\" ÎµÎ¯Î½Î±Î¹ Î´ÎµÏƒÎ¼ÎµÏ…Î¼Î­Î½Î¿ ÏƒÏ„Î·Î½ "
"Ï„Î¹Î¼Î® Î¼Î­ÏƒÎ± ÏƒÏ„Î·Î½ Ï€Î±ÏÎ±Î»Î»Î±Î³Î® \"Ok\". Î£Ï„Î¿ Î´ÎµÏÏ„ÎµÏÎ¿ Ï‡Î­ÏÎ¹, Î¤Î¿ \"msg\" ÏƒÏ…Î½Î´Î­ÎµÏ„Î±Î¹ Î¼Îµ "
"Ï„Î¿ Î¼Î®Î½Ï…Î¼Î± ÏƒÏ†Î¬Î»Î¼Î±Ï„Î¿Ï‚."

#: src/pattern-matching/destructuring-enums.md:36
#, fuzzy
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/pattern-matching/destructuring-enums.md:37
#, fuzzy
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"Î— Î­ÎºÏ†ÏÎ±ÏƒÎ· `if`/`else` ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î­Î½Î±Î½ Î±ÏÎ¹Î¸Î¼ÏŒ Ï€Î¿Ï… Î±ÏÎ³ÏŒÏ„ÎµÏÎ± Î±Ï€Î¿ÏƒÏ…ÏƒÎºÎµÏ…Î¬Î¶ÎµÏ„Î±Î¹ Î¼Îµ "
"Î­Î½Î± \"match\".\n"
"\n"
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÎµÏ„Îµ Î½Î± Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÎµÏ„Îµ Î¼Î¹Î± Ï„ÏÎ¯Ï„Î· Ï€Î±ÏÎ±Î»Î»Î±Î³Î® ÏƒÏ„Î¿Î½ Î¿ÏÎ¹ÏƒÎ¼ÏŒ enum "
"ÎºÎ±Î¹ Î½Î± ÎµÎ¼Ï†Î±Î½Î¯ÏƒÎµÏ„Îµ Ï„Î± ÏƒÏ†Î¬Î»Î¼Î±Ï„Î± ÎºÎ±Ï„Î¬ Ï„Î·Î½ ÎµÎºÏ„Î­Î»ÎµÏƒÎ· Ï„Î¿Ï… ÎºÏÎ´Î¹ÎºÎ±. Î•Ï€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Ï„Î± "
"ÏƒÎ·Î¼ÎµÎ¯Î± ÏŒÏ€Î¿Ï… Î¿ ÎºÏÎ´Î¹ÎºÎ±Ï‚ ÏƒÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ Ï€Î»Î­Î¿Î½ Î±Î½ÎµÎ¾Î¬Î½Ï„Î»Î·Ï„Î¿Ï‚ ÎºÎ±Î¹ Ï€ÏÏ‚ Î¿ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ "
"Ï€ÏÎ¿ÏƒÏ€Î±Î¸ÎµÎ¯ Î½Î± ÏƒÎ±Ï‚ Î´ÏÏƒÎµÎ¹ ÏƒÏ…Î¼Î²Î¿Ï…Î»Î­Ï‚."

#: src/pattern-matching/destructuring-structs.md:3
#, fuzzy
msgid "You can also destructure `structs`:"
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ­ÏˆÎµÏ„Îµ Â«structsÂ»:"

#: src/pattern-matching/destructuring-structs.md:5
msgid ""
"```rust,editable\n"
"struct Foo {\n"
"    x: (u32, u32),\n"
"    y: u32,\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let foo = Foo { x: (1, 2), y: 3 };\n"
"    match foo {\n"
"        Foo { x: (1, b), y } => println!(\"x.0 = 1, b = {b}, y = {y}\"),\n"
"        Foo { y: 2, x: i }   => println!(\"y = 2, x = {i:?}\"),\n"
"        Foo { y, .. }        => println!(\"y = {y}, other fields were "
"ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-structs.md:23
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr ""

#: src/pattern-matching/destructuring-structs.md:24
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr ""

#: src/pattern-matching/destructuring-structs.md:25
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:3
#, fuzzy
msgid ""
"You can destructure arrays, tuples, and slices by matching on their elements:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ­ÏˆÎµÏ„Îµ Ï€Î¯Î½Î±ÎºÎµÏ‚, Ï€Î»ÎµÎ¹Î¬Î´ÎµÏ‚ ÎºÎ±Î¹ Ï†Î­Ï„ÎµÏ‚ Ï„Î±Î¹ÏÎ¹Î¬Î¶Î¿Î½Ï„Î±Ï‚ ÏƒÏ„Î± "
"ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± Ï„Î¿Ï…Ï‚:"

#: src/pattern-matching/destructuring-arrays.md:5
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let triple = [0, -2, 3];\n"
"    println!(\"Tell me about {triple:?}\");\n"
"    match triple {\n"
"        [0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        [1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _         => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:21
msgid ""
"Destructuring of slices of unknown length also works with patterns of fixed "
"length."
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:24
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    inspect(&[0, -2, 3]);\n"
"    inspect(&[0, -2, 3, 4]);\n"
"}\n"
"\n"
"#[rustfmt::skip]\n"
"fn inspect(slice: &[i32]) {\n"
"    println!(\"Tell me about {slice:?}\");\n"
"    match slice {\n"
"        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
"        &[1, ..]   => println!(\"First is 1 and the rest were ignored\"),\n"
"        _          => println!(\"All elements were ignored\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:41
msgid "Create a new pattern using `_` to represent an element. "
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:42
msgid "Add more values to the array."
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:43
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr ""

#: src/pattern-matching/destructuring-arrays.md:44
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr ""

#: src/pattern-matching/match-guards.md:3
#, fuzzy
msgid ""
"When matching, you can add a _guard_ to a pattern. This is an arbitrary "
"Boolean expression which will be executed if the pattern matches:"
msgstr ""
"ÎšÎ±Ï„Î¬ Ï„Î·Î½ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ·, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÎµÏ„Îµ Î­Î½Î± _guard_ ÏƒÎµ Î­Î½Î± Î¼Î¿Ï„Î¯Î²Î¿. "
"Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Î±Ï…Î¸Î±Î¯ÏÎµÏ„Î¿ Boolean Î­ÎºÏ†ÏÎ±ÏƒÎ· Ï€Î¿Ï… Î¸Î± ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„ÎµÎ¯ ÎµÎ¬Î½ Ï„Î¿ Î¼Î¿Ï„Î¯Î²Î¿ "
"Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹:"

#: src/pattern-matching/match-guards.md:6
msgid ""
"```rust,editable\n"
"#[rustfmt::skip]\n"
"fn main() {\n"
"    let pair = (2, -2);\n"
"    println!(\"Tell me about {pair:?}\");\n"
"    match pair {\n"
"        (x, y) if x == y     => println!(\"These are twins\"),\n"
"        (x, y) if x + y == 0 => println!(\"Antimatter, kaboom!\"),\n"
"        (x, _) if x % 2 == 1 => println!(\"The first one is odd\"),\n"
"        _                    => println!(\"No correlation...\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/pattern-matching/match-guards.md:23
#, fuzzy
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/pattern-matching/match-guards.md:24
#, fuzzy
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"ÎŸÎ¹ Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏ…Ï„Î¹ÎºÎ¿Î¯ Î±Î³ÏÎ½ÎµÏ‚ Ï‰Ï‚ Î¾ÎµÏ‡Ï‰ÏÎ¹ÏƒÏ„ÏŒ ÏƒÏ…Î½Ï„Î±ÎºÏ„Î¹ÎºÏŒ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ ÎµÎ¯Î½Î±Î¹ "
"ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÎ¿Î¯ ÎºÎ±Î¹ Î±Ï€Î±ÏÎ±Î¯Ï„Î·Ï„Î¿Î¹."

#: src/pattern-matching/match-guards.md:26
#, fuzzy
msgid "You can use the variables defined in the pattern in your if expression."
msgstr ""
"Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î¯Î´Î¹Î± Î¼Îµ Ï„Î·Î½ Î¾ÎµÏ‡Ï‰ÏÎ¹ÏƒÏ„Î® Î­ÎºÏ†ÏÎ±ÏƒÎ· Â«Î±Î½Â» Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Î²ÏÎ±Ï‡Î¯Î¿Î½Î± Ï„Î¿Ï… Î±Î³ÏÎ½Î±. "
"ÎœÎ¹Î± Î­ÎºÏ†ÏÎ±ÏƒÎ· `if` Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Î¼Ï€Î»Î¿Îº Î´Î¹Î±ÎºÎ»Î¬Î´Ï‰ÏƒÎ·Ï‚ (Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ `=>`) ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹ Î¼ÎµÏ„Î¬ "
"Ï„Î·Î½ ÎµÏ€Î¹Î»Î¿Î³Î® Ï„Î¿Ï… Î²ÏÎ±Ï‡Î¯Î¿Î½Î± Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ·Ï‚. Î— Î±Ï€Î¿Ï„Ï…Ï‡Î¯Î± Ï„Î·Ï‚ ÏƒÏ…Î½Î¸Î®ÎºÎ·Ï‚ \"Î±Î½\" Î¼Î­ÏƒÎ± "
"ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ Î¼Ï€Î»Î¿Îº Î´ÎµÎ½ Î¸Î± Î¿Î´Î·Î³Î®ÏƒÎµÎ¹ ÏƒÎµ Î¬Î»Î»Î¿Ï…Ï‚ Î²ÏÎ±Ï‡Î¯Î¿Î½ÎµÏ‚ Ï„Î·Ï‚ Î±ÏÏ‡Î¹ÎºÎ®Ï‚ Î­ÎºÏ†ÏÎ±ÏƒÎ·Ï‚ "
"Â«Ï„Î±Î¹ÏÎ¹Î¬ÏƒÎ¼Î±Ï„Î¿Ï‚Â» Ï€Î¿Ï… ÎµÎ¾ÎµÏ„Î¬Î¶ÎµÏ„Î±Î¹."

#: src/pattern-matching/match-guards.md:27
#, fuzzy
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Ï€Î¿Ï… Î¿ÏÎ¯Î¶Î¿Î½Ï„Î±Î¹ ÏƒÏ„Î¿ Î¼Î¿Ï„Î¯Î²Î¿ ÏƒÏ„Î·Î½ "
"Î­ÎºÏ†ÏÎ±ÏƒÎ· if ÏƒÎ±Ï‚.\n"
"\n"
"Î— ÏƒÏ…Î½Î¸Î®ÎºÎ· Ï€Î¿Ï… Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏ…Ï„Î¹ÎºÏŒ Î¹ÏƒÏ‡ÏÎµÎ¹ Î³Î¹Î± ÎºÎ¬Î¸Îµ Î­ÎºÏ†ÏÎ±ÏƒÎ· ÏƒÎµ Î¼Î¿Ï„Î¯Î²Î¿ "
"Î¼Îµ Î­Î½Î± `|`."

#: src/exercises/day-1/afternoon.md:1
#, fuzzy
msgid "Day 1: Afternoon Exercises"
msgstr "Î—Î¼Î­ÏÎ± 1: Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-1/afternoon.md:3
#, fuzzy
msgid "We will look at two things:"
msgstr "Î˜Î± Î´Î¿ÏÎ¼Îµ Î´ÏÎ¿ Ï€ÏÎ¬Î³Î¼Î±Ï„Î±:"

#: src/exercises/day-1/afternoon.md:5
#, fuzzy
msgid "The Luhn algorithm,"
msgstr "Î‘Î»Î³ÏŒÏÎ¹Î¸Î¼Î¿Ï‚ Luhn"

#: src/exercises/day-1/afternoon.md:7
#, fuzzy
msgid "An exercise on pattern matching."
msgstr "Î‘ÏÎ¹Î¸Î¼Î¿Î¯ ÎºÎ±Î¹ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Î¼Î¿Ï„Î¯Î²Ï‰Î½."

#: src/exercises/day-1/afternoon.md:11 src/exercises/day-2/afternoon.md:7
#: src/exercises/bare-metal/afternoon.md:7
#: src/exercises/concurrency/afternoon.md:13
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr "Î‘Ï†Î¿Ï Î´ÎµÎ¯Ï„Îµ Ï„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î· \\[Î»ÏÏƒÎ·\\] Ï€Î¿Ï… Ï€Î±ÏÎ­Ï‡ÎµÏ„Î±Î¹."

#: src/exercises/day-1/luhn.md:3
#, fuzzy
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"ÎŸ [Î±Î»Î³ÏŒÏÎ¹Î¸Î¼Î¿Ï‚ Luhn](https://en.wikipedia.org/wiki/Luhn_algorithm) "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± ÎµÏ€Î¹ÎºÏÏÏ‰ÏƒÎ· Î±ÏÎ¹Î¸Î¼ÏÎ½ Ï€Î¹ÏƒÏ„Ï‰Ï„Î¹ÎºÏÎ½ ÎºÎ±ÏÏ„ÏÎ½. ÎŸ Î±Î»Î³ÏŒÏÎ¹Î¸Î¼Î¿Ï‚ "
"Ï€Î±Î¯ÏÎ½ÎµÎ¹ Î¼Î¹Î± ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬ Ï‰Ï‚ ÎµÎ¯ÏƒÎ¿Î´Î¿ ÎºÎ±Î¹ ÎºÎ¬Î½ÎµÎ¹ Ï„Î¿ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ Î³Î¹Î± Î½Î± ÎµÏ€Î¹ÎºÏ…ÏÏÏƒÎµÏ„Îµ "
"Ï„Î¿Î½ Î±ÏÎ¹Î¸Î¼ÏŒ Ï„Î·Ï‚ Ï€Î¹ÏƒÏ„Ï‰Ï„Î¹ÎºÎ®Ï‚ ÎºÎ¬ÏÏ„Î±Ï‚:"

#: src/exercises/day-1/luhn.md:7
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr ""

#: src/exercises/day-1/luhn.md:9
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""

#: src/exercises/day-1/luhn.md:12
msgid ""
"After doubling a digit, sum the digits. So doubling `7` becomes `14` which "
"becomes `5`."
msgstr ""

#: src/exercises/day-1/luhn.md:15
msgid "Sum all the undoubled and doubled digits."
msgstr ""

#: src/exercises/day-1/luhn.md:17
msgid "The credit card number is valid if the sum ends with `0`."
msgstr ""

#: src/exercises/day-1/luhn.md:19
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"function."
msgstr ""
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ "
"ÎµÏ†Î±ÏÎ¼ÏŒÏƒÏ„Îµ Ï„Î¿ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚:"

#: src/exercises/day-1/luhn.md:21
msgid ""
"Try to solve the problem the \"simple\" way first, using `for` loops and "
"integers. Then, revisit the solution and try to implement it with iterators."
msgstr ""

#: src/exercises/day-1/luhn.md:25
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/welcome-day-2.md:1
#, fuzzy
msgid "Welcome to Day 2"
msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Î—Î¼Î­ÏÎ± 2"

#: src/welcome-day-2.md:3
#, fuzzy
msgid "Now that we have seen a fair amount of Rust, we will continue with:"
msgstr "Î¤ÏÏÎ± Ï€Î¿Ï… ÎµÎ¯Î´Î±Î¼Îµ Î±ÏÎºÎµÏ„Î® Ï€Î¿ÏƒÏŒÏ„Î·Ï„Î± Rust, Î¸Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎ¿Ï…Î¼Îµ Î¼Îµ:"

#: src/welcome-day-2.md:5
msgid ""
"Memory management: stack vs heap, manual memory management, scope-based "
"memory management, and garbage collection."
msgstr ""

#: src/welcome-day-2.md:8
msgid ""
"Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
msgstr ""

#: src/welcome-day-2.md:10
#, fuzzy
msgid "Structs and methods."
msgstr "Î£Ï…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚ ÎºÎ±Î¹ Î•Ï€Î±Î½Î±Î»Î®Ï€Ï„ÎµÏ‚"

#: src/welcome-day-2.md:12
msgid ""
"The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
"`Rc` and `Arc`."
msgstr ""

#: src/welcome-day-2.md:15
msgid "Modules: visibility, paths, and filesystem hierarchy."
msgstr ""

#: src/memory-management.md:3
#, fuzzy
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "Î Î±ÏÎ±Î´Î¿ÏƒÎ¹Î±ÎºÎ¬, Î¿Î¹ Î³Î»ÏÏƒÏƒÎµÏ‚ Ï‡Ï‰ÏÎ¯Î¶Î¿Î½Ï„Î±Î¹ ÏƒÎµ Î´ÏÎ¿ Î¼ÎµÎ³Î¬Î»ÎµÏ‚ ÎºÎ±Ï„Î·Î³Î¿ÏÎ¯ÎµÏ‚:"

#: src/memory-management.md:5
#, fuzzy
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr ""
"Î Î»Î®ÏÎ·Ï‚ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Î¼Î­ÏƒÏ‰ Ï‡ÎµÎ¹ÏÎ¿ÎºÎ¯Î½Î·Ï„Î·Ï‚ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ Î¼Î½Î®Î¼Î·Ï‚: C, C++, Pascal, ..."

#: src/memory-management.md:6
#, fuzzy
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr ""
"Î Î»Î®ÏÎ·Ï‚ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Î¼Î­ÏƒÏ‰ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î·Ï‚ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ Î¼Î½Î®Î¼Î·Ï‚ ÎºÎ±Ï„Î¬ Ï„Î·Î½ ÎµÎºÏ„Î­Î»ÎµÏƒÎ·: Java, "
"Python, Go, Haskell, ..."

#: src/memory-management.md:8
#, fuzzy
msgid "Rust offers a new mix:"
msgstr "Î— Rust Ï€ÏÎ¿ÏƒÏ†Î­ÏÎµÎ¹ Î­Î½Î± Î½Î­Î¿ Î¼ÎµÎ¯Î³Î¼Î±:"

#: src/memory-management.md:10
#, fuzzy
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr ""
"Î Î»Î®ÏÎ·Ï‚ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ _ÎºÎ±Î¹_ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Î¼Î­ÏƒÏ‰ ÎµÏ€Î¹Î²Î¿Î»Î®Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚ Ï„Î·Ï‚ ÏƒÏ‰ÏƒÏ„Î®Ï‚ "
"Î¼Î½Î®Î¼Î·Ï‚ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·."

#: src/memory-management.md:13
#, fuzzy
msgid "It does this with an explicit ownership concept."
msgstr "Î¤Î¿ ÎºÎ¬Î½ÎµÎ¹ Î±Ï…Ï„ÏŒ Î¼Îµ Î¼Î¹Î± ÏÎ·Ï„Î® Î­Î½Î½Î¿Î¹Î± Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±Ï‚."

#: src/memory-management.md:15
#, fuzzy
msgid "First, let's refresh how memory management works."
msgstr "Î‘ÏÏ‡Î¹ÎºÎ¬, Î±Ï‚ Î±Î½Î±Î½ÎµÏÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Î½ Ï„ÏÏŒÏ€Î¿ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±Ï‚ Ï„Î·Ï‚ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ Î¼Î½Î®Î¼Î·Ï‚."

#: src/memory-management/stack-vs-heap.md:1
#, fuzzy
msgid "The Stack vs The Heap"
msgstr "The Stack vs The Heap"

#: src/memory-management/stack-vs-heap.md:3
#, fuzzy
msgid "Stack: Continuous area of memory for local variables."
msgstr "Î£Ï„Î¿Î¯Î²Î±: Î£Ï…Î½ÎµÏ‡Î®Ï‚ Ï€ÎµÏÎ¹Î¿Ï‡Î® Î¼Î½Î®Î¼Î·Ï‚ Î³Î¹Î± Ï„Î¿Ï€Î¹ÎºÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚."

#: src/memory-management/stack-vs-heap.md:4
#, fuzzy
msgid "Values have fixed sizes known at compile time."
msgstr "ÎŸÎ¹ Ï„Î¹Î¼Î­Ï‚ Î­Ï‡Î¿Ï…Î½ ÏƒÏ„Î±Î¸ÎµÏÎ¬ Î¼ÎµÎ³Î­Î¸Î· Î³Î½Ï‰ÏƒÏ„Î¬ ÎºÎ±Ï„Î¬ Ï„Î¿ Ï‡ÏÏŒÎ½Î¿ Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚."

#: src/memory-management/stack-vs-heap.md:5
#, fuzzy
msgid "Extremely fast: just move a stack pointer."
msgstr "Î•Î¾Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ Î³ÏÎ®Î³Î¿ÏÎ¿: Î±Ï€Î»ÏÏ‚ Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÏ„Îµ Î­Î½Î±Î½ Î´ÎµÎ¯ÎºÏ„Î· ÏƒÏ„Î¿Î¯Î²Î±Ï‚."

#: src/memory-management/stack-vs-heap.md:6
#, fuzzy
msgid "Easy to manage: follows function calls."
msgstr "Î•ÏÎºÎ¿Î»Î¿ ÏƒÏ„Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·: Î±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ ÎºÎ»Î®ÏƒÎµÎ¹Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÏÎ½."

#: src/memory-management/stack-vs-heap.md:7
#, fuzzy
msgid "Great memory locality."
msgstr "ÎœÎµÎ³Î¬Î»Î· Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î± Î¼Î½Î®Î¼Î·Ï‚."

#: src/memory-management/stack-vs-heap.md:9
msgid "Heap: Storage of values outside of function calls."
msgstr ""

#: src/memory-management/stack-vs-heap.md:10
msgid "Values have dynamic sizes determined at runtime."
msgstr ""

#: src/memory-management/stack-vs-heap.md:11
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr ""

#: src/memory-management/stack-vs-heap.md:12
msgid "No guarantee of memory locality."
msgstr ""

#: src/memory-management/stack.md:1
#, fuzzy
msgid "Stack and Heap Example"
msgstr "Î£Ï„Î¿Î¯Î²Î± ÎºÎ±Î¹ Î£Ï‰ÏÏŒÏ‚"

#: src/memory-management/stack.md:3
#, fuzzy
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"Î— Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎµÎ½ÏŒÏ‚ \"String\" Ï„Î¿Ï€Î¿Î¸ÎµÏ„ÎµÎ¯ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ„Î±Î¸ÎµÏÎ¿Ï Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚ ÏƒÏ„Î· ÏƒÏ„Î¿Î¯Î²Î± "
"ÎºÎ±Î¹ Î´Ï…Î½Î±Î¼Î¹ÎºÎ¬ Î¼ÎµÎ³Î­Î¸Î· Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î³Î¹Î± Ï„Î¿ ÏƒÏ‰ÏÏŒ:"

#: src/memory-management/stack.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1 = String::from(\"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/stack.md:12
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - -.\n"
":                           :     :                               :\n"
":    s1                     :     :                               :\n"
":   +-----------+-------+   :     :   +----+----+----+----+----+  :\n"
":   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  |  :\n"
":   | len       |     5 |   :     :   +----+----+----+----+----+  :\n"
":   | capacity  |     5 |   :     :                               :\n"
":   +-----------+-------+   :     :                               :\n"
":                           :     `- - - - - - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/memory-management/stack.md:28
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""

#: src/memory-management/stack.md:30
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""

#: src/memory-management/stack.md:32
msgid ""
"We can inspect the memory layout with `unsafe` code. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""

#: src/memory-management/stack.md:34
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::from(\"Hello\");\n"
"    s1.push(' ');\n"
"    s1.push_str(\"world\");\n"
"    // DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
"    unsafe {\n"
"        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
"transmute(s1);\n"
"        println!(\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:3
#, fuzzy
msgid "You allocate and deallocate heap memory yourself."
msgstr "Î•ÎºÏ‡Ï‰ÏÎµÎ¯Ï„Îµ ÎºÎ±Î¹ ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Îµ Ï„Î· Î¼Î½Î®Î¼Î· ÏƒÏ‰ÏÎ¿Ï Î¼ÏŒÎ½Î¿Î¹ ÏƒÎ±Ï‚."

#: src/memory-management/manual.md:5
#, fuzzy
msgid ""
"If not done with care, this can lead to crashes, bugs, security "
"vulnerabilities, and memory leaks."
msgstr ""
"Î•Î¬Î½ Î´ÎµÎ½ Î³Î¯Î½ÎµÎ¹ Î¼Îµ Ï€ÏÎ¿ÏƒÎ¿Ï‡Î®, Î±Ï…Ï„ÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î¿Î´Î·Î³Î®ÏƒÎµÎ¹ ÏƒÎµ ÏƒÏ†Î¬Î»Î¼Î±Ï„Î±, ÏƒÏ†Î¬Î»Î¼Î±Ï„Î±, "
"ÎµÏ…Ï€Î¬Î¸ÎµÎ¹ÎµÏ‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ ÎºÎ±Î¹ Î´Î¹Î±ÏÏÎ¿Î­Ï‚ Î¼Î½Î®Î¼Î·Ï‚."

#: src/memory-management/manual.md:7
#, fuzzy
msgid "C Example"
msgstr "Î“ Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±"

#: src/memory-management/manual.md:9
#, fuzzy
msgid "You must call `free` on every pointer you allocate with `malloc`:"
msgstr ""
"Î ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ±Î»ÎµÎ¯Ï„Îµ \"Î´Ï‰ÏÎµÎ¬Î½\" ÏƒÎµ ÎºÎ¬Î¸Îµ Î´ÎµÎ¯ÎºÏ„Î· Ï€Î¿Ï… ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Îµ Î¼Îµ Ï„Î¿ \"malloc\":"

#: src/memory-management/manual.md:11
msgid ""
"```c\n"
"void foo(size_t n) {\n"
"    int* int_array = malloc(n * sizeof(int));\n"
"    //\n"
"    // ... lots of code\n"
"    //\n"
"    free(int_array);\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/manual.md:21
#, fuzzy
msgid ""
"Memory is leaked if the function returns early between `malloc` and `free`: "
"the pointer is lost and we cannot deallocate the memory. Worse, freeing the "
"pointer twice, or accessing a freed pointer can lead to exploitable security "
"vulnerabilities."
msgstr ""
"Î— Î¼Î½Î®Î¼Î· Î´Î¹Î±ÏÏÎ­ÎµÎ¹ ÎµÎ¬Î½ Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎµÎ¹ Î½Ï‰ÏÎ¯Ï‚ Î¼ÎµÏ„Î±Î¾Ï \"malloc\" ÎºÎ±Î¹ "
"\"free\": Ï„Î¿ ÎŸ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Ï‡Î¬Î½ÎµÏ„Î±Î¹ ÎºÎ±Î¹ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± ÎµÎºÏ‡Ï‰ÏÎ®ÏƒÎ¿Ï…Î¼Îµ Ï„Î· Î¼Î½Î®Î¼Î·."

#: src/memory-management/scope-based.md:3
#, fuzzy
msgid ""
"Constructors and destructors let you hook into the lifetime of an object."
msgstr ""
"ÎŸÎ¹ ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î±ÏƒÏ„Î­Ï‚ ÎºÎ±Î¹ Î¿Î¹ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†ÎµÎ¯Ï‚ ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î½ Î½Î± ÎºÎ¿Î»Î»Î®ÏƒÎµÏ„Îµ ÏƒÏ„Î· "
"Î´Î¹Î¬ÏÎºÎµÎ¹Î± Î¶Ï‰Î®Ï‚ ÎµÎ½ÏŒÏ‚ Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï…."

#: src/memory-management/scope-based.md:5
#, fuzzy
msgid ""
"By wrapping a pointer in an object, you can free memory when the object is "
"destroyed. The compiler guarantees that this happens, even if an exception "
"is raised."
msgstr ""
"Î¤Ï…Î»Î¯Î³Î¿Î½Ï„Î±Ï‚ Î­Î½Î±Î½ Î´ÎµÎ¯ÎºÏ„Î· ÏƒÎµ Î­Î½Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎ»ÎµÏ…Î¸ÎµÏÏÏƒÎµÏ„Îµ Î¼Î½Î®Î¼Î· "
"ÏŒÏ„Î±Î½ Ï„Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¬Ï†Î·ÎºÎµ Î±Ï€ÏŒ. ÎŸ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ ÎµÎ³Î³Ï…Î¬Ï„Î±Î¹ "
"ÏŒÏ„Î¹ Î±Ï…Ï„ÏŒ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹, Î±ÎºÏŒÎ¼Î± ÎºÎ¹ Î±Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ ÎµÎ¾Î±Î¯ÏÎµÏƒÎ· Î±Î½Ï…ÏˆÏÎ¸Î·ÎºÎµ."

#: src/memory-management/scope-based.md:9
#, fuzzy
msgid ""
"This is often called _resource acquisition is initialization_ (RAII) and "
"gives you smart pointers."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÏƒÏ…Ï‡Î½Î¬ Î¿Î½Î¿Î¼Î¬Î¶ÎµÏ„Î±Î¹ _Î±Ï€ÏŒÎºÏ„Î·ÏƒÎ· Ï€ÏŒÏÏ‰Î½ ÎµÎ¯Î½Î±Î¹ Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ·_ (RAII) ÎºÎ±Î¹ Î´Î¯Î½ÎµÎ¹ "
"Î­Î¾Ï…Ï€Î½Î¿Î¹ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚."

#: src/memory-management/scope-based.md:12
#, fuzzy
msgid "C++ Example"
msgstr "Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± C++"

#: src/memory-management/scope-based.md:14
msgid ""
"```c++\n"
"void say_hello(std::unique_ptr<Person> person) {\n"
"  std::cout << \"Hello \" << person->name << std::endl;\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/scope-based.md:20
#, fuzzy
msgid ""
"The `std::unique_ptr` object is allocated on the stack, and points to memory "
"allocated on the heap."
msgstr ""
"Î¤Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ `std::unique_ptr` ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Î±Î¹ ÏƒÏ„Î· ÏƒÏ„Î¿Î¯Î²Î± ÎºÎ±Î¹ Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ ÏƒÎµ Î¼Î½Î®Î¼Î· "
"Ï€Î¿Ï… ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Î±Î¹ ÏƒÏ„Î¿ ÏƒÏ‰ÏÏŒ."

#: src/memory-management/scope-based.md:22
#, fuzzy
msgid "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
msgstr ""
"Î£Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î¿Ï… Â«say_helloÂ», Î¸Î± ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„ÎµÎ¯ Î¿ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†Î­Î±Ï‚ Â«std::unique_ptrÂ»."

#: src/memory-management/scope-based.md:23
#, fuzzy
msgid "The destructor frees the `Person` object it points to."
msgstr "ÎŸ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†Î­Î±Ï‚ ÎµÎ»ÎµÏ…Î¸ÎµÏÏÎ½ÎµÎ¹ Ï„Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Â«PersonÂ» ÏƒÏ„Î¿ Î¿Ï€Î¿Î¯Î¿ Î´ÎµÎ¯Ï‡Î½ÎµÎ¹."

#: src/memory-management/scope-based.md:25
#, fuzzy
msgid ""
"Special move constructors are used when passing ownership to a function:"
msgstr ""
"ÎŸÎ¹ ÎµÎ¹Î´Î¹ÎºÎ¿Î¯ ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î±ÏƒÏ„Î­Ï‚ Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ ÏŒÏ„Î±Î½ Î¼ÎµÏ„Î±Î²Î¹Î²Î¬Î¶ÎµÏ„Î±Î¹ Î· "
"Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± ÏƒÎµ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·:"

#: src/memory-management/scope-based.md:27
msgid ""
"```c++\n"
"std::unique_ptr<Person> person = find_person(\"Carla\");\n"
"say_hello(std::move(person));\n"
"```"
msgstr ""

#: src/memory-management/garbage-collection.md:1
#, fuzzy
msgid "Automatic Memory Management"
msgstr "Î‘Ï…Ï„ÏŒÎ¼Î±Ï„Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚"

#: src/memory-management/garbage-collection.md:3
#, fuzzy
msgid ""
"An alternative to manual and scope-based memory management is automatic "
"memory management:"
msgstr ""
"ÎœÎ¹Î± ÎµÎ½Î±Î»Î»Î±ÎºÏ„Î¹ÎºÎ® Î»ÏÏƒÎ· ÏƒÏ„Î· Ï‡ÎµÎ¹ÏÎ¿ÎºÎ¯Î½Î·Ï„Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚ ÎºÎ±Î¹ Ï„Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· "
"Î¼Î½Î®Î¼Î·Ï‚ Î²Î¬ÏƒÎµÎ¹ ÎµÏÏÎ¿Ï…Ï‚ ÎµÎ¯Î½Î±Î¹ Î· Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î· Î¼Î½Î®Î¼Î· Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·:"

#: src/memory-management/garbage-collection.md:6
#, fuzzy
msgid "The programmer never allocates or deallocates memory explicitly."
msgstr "ÎŸ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î®Ï‚ Ï€Î¿Ï„Î­ Î´ÎµÎ½ ÎµÎºÏ‡Ï‰ÏÎµÎ¯ Î® ÎµÎºÏ‡Ï‰ÏÎµÎ¯ Î¼Î½Î®Î¼Î· ÏÎ·Ï„Î¬."

#: src/memory-management/garbage-collection.md:7
#, fuzzy
msgid ""
"A garbage collector finds unused memory and deallocates it for the "
"programmer."
msgstr ""
"ÎˆÎ½Î±Ï‚ ÏƒÏ…Î»Î»Î­ÎºÏ„Î·Ï‚ ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¹ÏÎ½ Î²ÏÎ¯ÏƒÎºÎµÎ¹ Î±Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·Ï„Î· Î¼Î½Î®Î¼Î· ÎºÎ±Î¹ Ï„Î·Î½ ÎµÎºÏ‡Ï‰ÏÎµÎ¯ ÏƒÏ„Î¿Î½ "
"Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î®."

#: src/memory-management/garbage-collection.md:9
#, fuzzy
msgid "Java Example"
msgstr "Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Java"

#: src/memory-management/garbage-collection.md:11
#, fuzzy
msgid "The `person` object is not deallocated after `sayHello` returns:"
msgstr ""
"Î¤Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ \"person\" Î´ÎµÎ½ ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Î±Î¹ Î¼ÎµÏ„Î¬ Ï„Î·Î½ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Ï„Î¿Ï… \"sayHello\":"

#: src/memory-management/garbage-collection.md:13
msgid ""
"```java\n"
"void sayHello(Person person) {\n"
"  System.out.println(\"Hello \" + person.getName());\n"
"}\n"
"```"
msgstr ""

#: src/memory-management/rust.md:1
#, fuzzy
msgid "Memory Management in Rust"
msgstr "Î”Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚ ÏƒÎµ Rust"

#: src/memory-management/rust.md:3
#, fuzzy
msgid "Memory management in Rust is a mix:"
msgstr "Î— Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚ ÏƒÏ„Î¿ Rust ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ ÏƒÏ…Î½Î´Ï…Î±ÏƒÎ¼ÏŒÏ‚:"

#: src/memory-management/rust.md:5
#, fuzzy
msgid "Safe and correct like Java, but without a garbage collector."
msgstr "Î‘ÏƒÏ†Î±Î»Î­Ï‚ ÎºÎ±Î¹ ÏƒÏ‰ÏƒÏ„ÏŒ ÏŒÏ€Ï‰Ï‚ Î· Java, Î±Î»Î»Î¬ Ï‡Ï‰ÏÎ¯Ï‚ ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¿ÏƒÏ…Î»Î»Î­ÎºÏ„Î·."

#: src/memory-management/rust.md:6
#, fuzzy
msgid ""
"Depending on which abstraction (or combination of abstractions) you choose, "
"can be a single unique pointer, reference counted, or atomically reference "
"counted."
msgstr ""
"Î‘Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î¿ Ï€Î¿Î¹Î± Î±Ï†Î±Î¯ÏÎµÏƒÎ· (Î® ÏƒÏ…Î½Î´Ï…Î±ÏƒÎ¼ÏŒ Î±Ï†Î±Î¹ÏÎ­ÏƒÎµÏ‰Î½) ÎµÏ€Î¹Î»Î­Î³ÎµÏ„Îµ, Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Î¼Î¿Î½Î±Î´Î¹ÎºÏŒÏ‚ Î´ÎµÎ¯ÎºÏ„Î·Ï‚, Î½Î± Î¼ÎµÏ„ÏÎ¬Ï„Î±Î¹ Î· Î±Î½Î±Ï†Î¿ÏÎ¬ Î® Î½Î± Î¼ÎµÏ„ÏÎ¬Ï„Î±Î¹ Î±Ï„Î¿Î¼Î¹ÎºÎ¬ Î· "
"Î±Î½Î±Ï†Î¿ÏÎ¬."

#: src/memory-management/rust.md:7
#, fuzzy
msgid "Scope-based like C++, but the compiler enforces full adherence."
msgstr ""
"Î’Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Ï€ÎµÎ´Î¯Î¿ ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚ ÏŒÏ€Ï‰Ï‚ Î· C++, Î±Î»Î»Î¬ Î¿ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ ÎµÏ€Î¹Î²Î¬Î»Î»ÎµÎ¹ "
"Ï„Î·Î½ Ï€Î»Î®ÏÎ· ÏƒÏ…Î¼Î¼ÏŒÏÏ†Ï‰ÏƒÎ·."

#: src/memory-management/rust.md:8
#, fuzzy
msgid ""
"A Rust user can choose the right abstraction for the situation, some even "
"have no cost at runtime like C."
msgstr ""
"ÎˆÎ½Î±Ï‚ Ï‡ÏÎ®ÏƒÏ„Î·Ï‚ Ï„Î¿Ï… Rust Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÏ€Î¹Î»Î­Î¾ÎµÎ¹ Ï„Î· ÏƒÏ‰ÏƒÏ„Î® Î±Ï†Î±Î¯ÏÎµÏƒÎ· Î³Î¹Î± Ï„Î·Î½ "
"ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·, Î¼ÎµÏÎ¹ÎºÎ¿Î¯ Î¼Î¬Î»Î¹ÏƒÏ„Î± Î´ÎµÎ½ Î­Ï‡Î¿Ï…Î½ ÎºÏŒÏƒÏ„Î¿Ï‚ ÎºÎ±Ï„Î¬ Ï„Î· Î´Î¹Î¬ÏÎºÎµÎ¹Î± ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚ ÏŒÏ€Ï‰Ï‚ "
"Ï„Î¿ C."

#: src/memory-management/rust.md:10
#, fuzzy
msgid "Rust achieves this by modeling _ownership_ explicitly."
msgstr "Î‘Ï…Ï„ÏŒ Ï„Î¿ ÎµÏ€Î¹Ï„Ï…Î³Ï‡Î¬Î½ÎµÎ¹ Î´Î¹Î±Î¼Î¿ÏÏ†ÏÎ½Î¿Î½Ï„Î±Ï‚ ÏÎ·Ï„Î¬ Ï„Î·Î½ _ownership_."

#: src/memory-management/rust.md:14
#, fuzzy
msgid ""
"If asked how at this point, you can mention that in Rust this is usually "
"handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
"boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct.Vec."
"html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
"(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
"ownership and memory allocation via various means, and prevent the potential "
"errors in C."
msgstr ""
"Î•Î¬Î½ ÏÏ‰Ï„Î®ÏƒÎµÏ„Îµ Ï€ÏÏ‚ ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î±Î½Î±Ï†Î­ÏÎµÏ„Îµ ÏŒÏ„Î¹ ÏƒÏ„Î¿ Rust Î±Ï…Ï„ÏŒ "
"ÏƒÏ…Î½Î®Î¸Ï‰Ï‚ Î±Î½Ï„Î¹Î¼ÎµÏ„Ï‰Ï€Î¯Î¶ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€ÎµÏÎ¹Ï„Ï…Î»Î¯Î³Î¼Î±Ï„Î¿Ï‚ RAII ÏŒÏ€Ï‰Ï‚ [Box](https://"
"doc.rust-lang.org/std/boxed/struct.Box.html), [Vec](https://doc.rust-lang."
"org/std/vec/struct.Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct."
"Rc.html) Î® [Arc](https://doc.rust-lang.org/std/sync/struct.Arc.html). Î‘Ï…Ï„Î¬ "
"ÎµÎ½ÏƒÏ‰Î¼Î±Ï„ÏÎ½Î¿Ï…Î½ Ï„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± ÎºÎ±Î¹ Ï„Î·Î½ ÎµÎºÏ‡ÏÏÎ·ÏƒÎ· Î¼Î½Î®Î¼Î·Ï‚ Î¼Îµ Î´Î¹Î¬Ï†Î¿ÏÎ± Î¼Î­ÏƒÎ± ÎºÎ±Î¹ "
"Î±Ï€Î¿Ï„ÏÎ­Ï€Î¿Ï…Î½ Ï„Î± Ï€Î¹Î¸Î±Î½Î¬ ÏƒÏ†Î¬Î»Î¼Î±Ï„Î± ÏƒÏ„Î¿ C."

#: src/memory-management/rust.md:16
msgid ""
"You may be asked about destructors here, the [Drop](https://doc.rust-lang."
"org/std/ops/trait.Drop.html) trait is the Rust equivalent."
msgstr ""

#: src/memory-management/comparison.md:3
#, fuzzy
msgid "Here is a rough comparison of the memory management techniques."
msgstr "Î‘ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Î¼Î¹Î± Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ· ÏƒÏÎ³ÎºÏÎ¹ÏƒÎ· Ï„Ï‰Î½ Ï„ÎµÏ‡Î½Î¹ÎºÏÎ½ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ Î¼Î½Î®Î¼Î·Ï‚."

#: src/memory-management/comparison.md:5
#, fuzzy
msgid "Pros of Different Memory Management Techniques"
msgstr "Î Î»ÎµÎ¿Î½ÎµÎºÏ„Î®Î¼Î±Ï„Î± Î”Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏÎ½ Î¤ÎµÏ‡Î½Î¹ÎºÏÎ½ Î”Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ ÎœÎ½Î®Î¼Î·Ï‚"

#: src/memory-management/comparison.md:7 src/memory-management/comparison.md:22
#, fuzzy
msgid "Manual like C:"
msgstr "Î•Î³Ï‡ÎµÎ¹ÏÎ¯Î´Î¹Î¿ ÏŒÏ€Ï‰Ï‚ C:"

#: src/memory-management/comparison.md:8 src/memory-management/comparison.md:14
#: src/memory-management/comparison.md:17
#, fuzzy
msgid "No runtime overhead."
msgstr "Î§Ï‰ÏÎ¯Ï‚ ÎµÏ€Î¹Î²Î¬ÏÏ…Î½ÏƒÎ· Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚."

#: src/memory-management/comparison.md:9 src/memory-management/comparison.md:26
#, fuzzy
msgid "Automatic like Java:"
msgstr "Î‘Ï…Ï„ÏŒÎ¼Î±Ï„Î¿ ÏŒÏ€Ï‰Ï‚ Java:"

#: src/memory-management/comparison.md:10
#, fuzzy
msgid "Fully automatic."
msgstr "Î•Î½Ï„ÎµÎ»ÏÏ‚ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î¿."

#: src/memory-management/comparison.md:11
#: src/memory-management/comparison.md:18
#, fuzzy
msgid "Safe and correct."
msgstr "Î‘ÏƒÏ†Î±Î»Î­Ï‚ ÎºÎ±Î¹ ÏƒÏ‰ÏƒÏ„ÏŒ."

#: src/memory-management/comparison.md:12
#: src/memory-management/comparison.md:29
#, fuzzy
msgid "Scope-based like C++:"
msgstr "Î’Î±ÏƒÎ¹ÏƒÎ¼Î­Î½Î¿ ÏƒÎµ Ï€ÎµÎ´Î¯Î¿ ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚ ÏŒÏ€Ï‰Ï‚ Î· C++:"

#: src/memory-management/comparison.md:13
#, fuzzy
msgid "Partially automatic."
msgstr "ÎœÎµÏÎ¹ÎºÏÏ‚ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î¿."

#: src/memory-management/comparison.md:15
#, fuzzy
msgid "Compiler-enforced scope-based like Rust:"
msgstr "Î’Î±ÏƒÎ¹ÏƒÎ¼Î­Î½Î¿ ÏƒÎµ ÎµÏÏÎ¿Ï‚ Î¼Îµ ÎµÏ€Î¹Î²Î¿Î»Î® Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® ÏŒÏ€Ï‰Ï‚ Ï„Î¿ Rust:"

#: src/memory-management/comparison.md:16
#, fuzzy
msgid "Enforced by compiler."
msgstr "Î•Ï€Î¹Î²Î¬Î»Î»ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®."

#: src/memory-management/comparison.md:20
#, fuzzy
msgid "Cons of Different Memory Management Techniques"
msgstr "ÎœÎµÎ¹Î¿Î½ÎµÎºÏ„Î®Î¼Î±Ï„Î± Ï„Ï‰Î½ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏÎ½ Ï„ÎµÏ‡Î½Î¹ÎºÏÎ½ Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ Î¼Î½Î®Î¼Î·Ï‚"

#: src/memory-management/comparison.md:23
#, fuzzy
msgid "Use-after-free."
msgstr "Î§ÏÎ®ÏƒÎ·-Î¼ÎµÏ„Î¬-Î´Ï‰ÏÎµÎ¬Î½."

#: src/memory-management/comparison.md:24
#, fuzzy
msgid "Double-frees."
msgstr "Î”Î¹Ï€Î»ÏŒ Î´Ï‰ÏÎµÎ¬Î½."

#: src/memory-management/comparison.md:25
#, fuzzy
msgid "Memory leaks."
msgstr "Î”Î¹Î±ÏÏÎ¿Î­Ï‚ Î¼Î½Î®Î¼Î·Ï‚."

#: src/memory-management/comparison.md:27
#, fuzzy
msgid "Garbage collection pauses."
msgstr "Î Î±ÏÏƒÎµÎ¹Ï‚ Î±Ï€Î¿ÎºÎ¿Î¼Î¹Î´Î®Ï‚ ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¹ÏÎ½."

#: src/memory-management/comparison.md:28
#, fuzzy
msgid "Destructor delays."
msgstr "ÎšÎ±Î¸Ï…ÏƒÏ„ÎµÏÎ®ÏƒÎµÎ¹Ï‚ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†Î­Ï‰Î½."

#: src/memory-management/comparison.md:30
#, fuzzy
msgid "Complex, opt-in by programmer (on C++)."
msgstr "Î£ÏÎ½Î¸ÎµÏ„Î¿, ÏƒÏ…Î¼Î¼ÎµÏ„Î¿Ï‡Î® Î±Ï€ÏŒ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î®."

#: src/memory-management/comparison.md:31
msgid "Circular references can lead to memory leaks"
msgstr ""

#: src/memory-management/comparison.md:32
#, fuzzy
msgid "Potential runtime overhead"
msgstr "Î§Ï‰ÏÎ¯Ï‚ ÎµÏ€Î¹Î²Î¬ÏÏ…Î½ÏƒÎ· Ï‡ÏÏŒÎ½Î¿Ï… ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚."

#: src/memory-management/comparison.md:33
#, fuzzy
msgid "Compiler-enforced and scope-based like Rust:"
msgstr "Î•Ï€Î¹Î²Î¬Î»Î»ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® ÎºÎ±Î¹ Î²Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÎµ ÎµÏÏÎ¿Ï‚ ÏŒÏ€Ï‰Ï‚ Ï„Î¿ Rust:"

#: src/memory-management/comparison.md:34
#, fuzzy
msgid "Some upfront complexity."
msgstr "ÎšÎ¬Ï€Î¿Î¹Î± ÎµÎº Ï„Ï‰Î½ Ï€ÏÎ¿Ï„Î­ÏÏ‰Î½ Ï€Î¿Î»Ï…Ï€Î»Î¿ÎºÏŒÏ„Î·Ï„Î±."

#: src/memory-management/comparison.md:35
#, fuzzy
msgid "Can reject valid programs."
msgstr "ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± Î±Ï€Î¿ÏÏÎ¯ÏˆÎµÎ¹ Î­Î³ÎºÏ…ÏÎ± Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î±."

#: src/ownership.md:3
#, fuzzy
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr ""
"ÎŒÎ»ÎµÏ‚ Î¿Î¹ Î´ÎµÏƒÎ¼ÎµÏÏƒÎµÎ¹Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ Î­Ï‡Î¿Ï…Î½ _scope_ ÏŒÏ€Î¿Ï… ÎµÎ¯Î½Î±Î¹ Î­Î³ÎºÏ…ÏÎµÏ‚ ÎºÎ±Î¹ ÎµÎ¯Î½Î±Î¹ "
"ÏƒÏ†Î¬Î»Î¼Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® ÎµÎºÏ„ÏŒÏ‚ Ï„Î¿Ï… Ï€ÎµÎ´Î¯Î¿Ï… ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚ Ï„Î·Ï‚:"

#: src/ownership.md:6
msgid ""
"```rust,editable,compile_fail\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    {\n"
"        let p = Point(3, 4);\n"
"        println!(\"x: {}\", p.0);\n"
"    }\n"
"    println!(\"y: {}\", p.1);\n"
"}\n"
"```"
msgstr ""

#: src/ownership.md:18
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed."
msgstr ""
"Î£Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î¿Ï… ÎµÏÏÎ¿Ï…Ï‚, Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® _Î±Ï€Î¿Ï„Î­Î¸Î·ÎºÎµ_ ÎºÎ±Î¹ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÎµÎ»ÎµÏ…Î¸ÎµÏÏÎ½Î¿Î½Ï„Î±Î¹."

#: src/ownership.md:19
#, fuzzy
msgid "A destructor can run here to free up resources."
msgstr "ÎˆÎ½Î±Ï‚ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†Î­Î±Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï„ÏÎ­Î¾ÎµÎ¹ ÎµÎ´Ï Î³Î¹Î± Î½Î± ÎµÎ»ÎµÏ…Î¸ÎµÏÏÏƒÎµÎ¹ Ï€ÏŒÏÎ¿Ï…Ï‚."

#: src/ownership.md:20
#, fuzzy
msgid "We say that the variable _owns_ the value."
msgstr "Î›Î­Î¼Îµ ÏŒÏ„Î¹ Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® _ÎºÎ±Ï„Î­Ï‡ÎµÎ¹_ Ï„Î·Î½ Ï„Î¹Î¼Î®."

#: src/ownership/move-semantics.md:3
#, fuzzy
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "ÎœÎ¹Î± Î±Î½Î¬Î¸ÎµÏƒÎ· Î¸Î± Î¼ÎµÏ„Î±Î²Î¹Î²Î¬ÏƒÎµÎ¹ Ï„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± Î¼ÎµÏ„Î±Î¾Ï Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½:"

#: src/ownership/move-semantics.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Hello!\");\n"
"    let s2: String = s1;\n"
"    println!(\"s2: {s2}\");\n"
"    // println!(\"s1: {s1}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/move-semantics.md:14
#, fuzzy
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "Î— ÎµÎºÏ‡ÏÏÎ·ÏƒÎ· Ï„Î¿Ï… `s1` ÏƒÏ„Î¿ `s2` Î¼ÎµÏ„Î±Î²Î¹Î²Î¬Î¶ÎµÎ¹ Ï„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±."

#: src/ownership/move-semantics.md:15
#, fuzzy
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr ""
"ÎŒÏ„Î±Î½ Ï„Î¿ `s1` Î²Î³Î±Î¯Î½ÎµÎ¹ ÎµÎºÏ„ÏŒÏ‚ Ï€ÎµÎ´Î¯Î¿Ï… ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚, Î´ÎµÎ½ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹ Ï„Î¯Ï€Î¿Ï„Î±: Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ "
"Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±."

#: src/ownership/move-semantics.md:16
#, fuzzy
msgid "When `s2` goes out of scope, the string data is freed."
msgstr ""
"ÎŒÏ„Î±Î½ Ï„Î¿ `s2` Î²Î³Î±Î¯Î½ÎµÎ¹ ÎµÎºÏ„ÏŒÏ‚ ÎµÏÏÎ¿Ï…Ï‚, Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬Ï‚ ÎµÎ»ÎµÏ…Î¸ÎµÏÏÎ½Î¿Î½Ï„Î±Î¹."

#: src/ownership/move-semantics.md:17
#, fuzzy
msgid "There is always _exactly_ one variable binding which owns a value."
msgstr "Î¥Ï€Î¬ÏÏ‡ÎµÎ¹ Ï€Î¬Î½Ï„Î± _exactly_ Î¼Î¯Î± Î´Î­ÏƒÎ¼ÎµÏ…ÏƒÎ· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î®Ï‚ Ï€Î¿Ï… ÎºÎ±Ï„Î­Ï‡ÎµÎ¹ Î¼Î¹Î± Ï„Î¹Î¼Î®."

#: src/ownership/move-semantics.md:21
#, fuzzy
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"Î‘Î½Î±Ï†Î­ÏÎµÏ„Îµ ÏŒÏ„Î¹ Î±Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Î±Î½Ï„Î¯Î¸ÎµÏ„Î¿ Î±Ï€ÏŒ Ï„Î¹Ï‚ Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚ Ï„Î·Ï‚ C++, Î· Î¿Ï€Î¿Î¯Î± "
"Î±Î½Ï„Î¹Î³ÏÎ¬Ï†ÎµÎ¹ Î¼Îµ Î²Î¬ÏƒÎ· Ï„Î·Î½ Ï„Î¹Î¼Î®, ÎµÎºÏ„ÏŒÏ‚ ÎºÎ±Î¹ Î±Î½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ `std::move` "
"(ÎºÎ±Î¹ Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î¿ ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î±ÏƒÏ„Î®Ï‚ ÎºÎ¯Î½Î·ÏƒÎ·Ï‚!)."

#: src/ownership/move-semantics.md:23
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""

#: src/ownership/move-semantics.md:25
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr ""

#: src/ownership/move-semantics.md:27
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr ""

#: src/ownership/moved-strings-rust.md:3
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s1: String = String::from(\"Rust\");\n"
"    let s2: String = s1;\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:10
#, fuzzy
msgid "The heap data from `s1` is reused for `s2`."
msgstr "Î¤Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ‰ÏÎ¿Ï Î±Ï€ÏŒ Ï„Î¿ `s1` ÎµÏ€Î±Î½Î±Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± Ï„Î¿ `s2`."

#: src/ownership/moved-strings-rust.md:11
#, fuzzy
msgid "When `s1` goes out of scope, nothing happens (it has been moved from)."
msgstr ""
"ÎŒÏ„Î±Î½ Ï„Î¿ `s1` Î²Î³Î±Î¯Î½ÎµÎ¹ ÎµÎºÏ„ÏŒÏ‚ Ï€ÎµÎ´Î¯Î¿Ï… ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚, Î´ÎµÎ½ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹ Ï„Î¯Ï€Î¿Ï„Î± (Î­Ï‡ÎµÎ¹ "
"Î¼ÎµÏ„Î±ÎºÎ¹Î½Î·Î¸ÎµÎ¯ Î±Ï€ÏŒ)."

#: src/ownership/moved-strings-rust.md:13
#, fuzzy
msgid "Before move to `s2`:"
msgstr "Î ÏÎ¹Î½ Î¼ÎµÏ„Î±Î²ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ `s2`:"

#: src/ownership/moved-strings-rust.md:15
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1                     :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+-----+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :     :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :     :                           :\n"
":   +-----------+-------+   :     :                           :\n"
":                           :     `- - - - - - - - - - - - - -'\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moved-strings-rust.md:30
#, fuzzy
msgid "After move to `s2`:"
msgstr "ÎœÎµÏ„Î¬ Ï„Î· Î¼ÎµÏ„Î¬Î²Î±ÏƒÎ· ÏƒÏ„Î¿ `s2`:"

#: src/ownership/moved-strings-rust.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:1
#, fuzzy
msgid "Extra Work in Modern C++"
msgstr "Î”Î¹Ï€Î»Î­Ï‚ Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏÏƒÎµÎ¹Ï‚ Î¼Î½Î®Î¼Î·Ï‚ ÏƒÏ„Î· ÏƒÏÎ³Ï‡ÏÎ¿Î½Î· C++"

#: src/ownership/double-free-modern-cpp.md:3
#, fuzzy
msgid "Modern C++ solves this differently:"
msgstr "Î— ÏƒÏÎ³Ï‡ÏÎ¿Î½Î· C++ Ï„Î¿ Î»ÏÎ½ÎµÎ¹ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬:"

#: src/ownership/double-free-modern-cpp.md:5
msgid ""
"```c++\n"
"std::string s1 = \"Cpp\";\n"
"std::string s2 = s1;  // Duplicate the data in s1.\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:10
#, fuzzy
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr ""
"Î¤Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ‰ÏÎ¿Ï Î±Ï€ÏŒ Ï„Î¿ `s1` ÎµÎ¯Î½Î±Î¹ Î´Î¹Ï€Î»Î¬ ÎºÎ±Î¹ Ï„Î¿ `s2` Î±Ï€Î¿ÎºÏ„Î¬ Ï„Î¿ Î´Î¹ÎºÏŒ Ï„Î¿Ï… "
"Î±Î½ÎµÎ¾Î¬ÏÏ„Î·Ï„Î¿ Î±Î½Ï„Î¯Î³ÏÎ±Ï†Î¿."

#: src/ownership/double-free-modern-cpp.md:11
#, fuzzy
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr ""
"ÎŒÏ„Î±Î½ Ï„Î± Â«s1Â» ÎºÎ±Î¹ Â«s2Â» Î²Î³Î±Î¯Î½Î¿Ï…Î½ ÎµÎºÏ„ÏŒÏ‚ Ï€ÎµÎ´Î¯Î¿Ï… ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚, Ï„Î¿ ÎºÎ±Î¸Î­Î½Î± "
"Î±Ï€ÎµÎ»ÎµÏ…Î¸ÎµÏÏÎ½ÎµÎ¹ Ï„Î· Î´Î¹ÎºÎ® Ï„Î¿Ï… Î¼Î½Î®Î¼Î·."

#: src/ownership/double-free-modern-cpp.md:13
#, fuzzy
msgid "Before copy-assignment:"
msgstr "Î ÏÎ¹Î½ Ï„Î·Î½ Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î®-Î±Î½Î¬Î¸ÎµÏƒÎ·:"

#: src/ownership/double-free-modern-cpp.md:16
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/double-free-modern-cpp.md:30
#, fuzzy
msgid "After copy-assignment:"
msgstr "ÎœÎµÏ„Î¬ Ï„Î·Î½ Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î®-Î±Î½Î¬Î¸ÎµÏƒÎ·:"

#: src/ownership/double-free-modern-cpp.md:32
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.\n"
":                           :     :                       :\n"
":    s1                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     :                       :\n"
":    s2                     :     :                       :\n"
":   +-----------+-------+   :     :   +----+----+----+    :\n"
":   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :\n"
":   | len       |     3 |   :     :   +----+----+----+    :\n"
":   | capacity  |     3 |   :     :                       :\n"
":   +-----------+-------+   :     :                       :\n"
":                           :     `- - - - - - - - - - - -'\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:3
#, fuzzy
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr ""
"ÎŒÏ„Î±Î½ Î¼ÎµÏ„Î±Î²Î¹Î²Î¬Î¶ÎµÏ„Îµ Î¼Î¹Î± Ï„Î¹Î¼Î® ÏƒÎµ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·, Î· Ï„Î¹Î¼Î® ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Î±Î¹ ÏƒÏ„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· "
"Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Ï‚. Î‘Ï…Ï„ÏŒ Î¼ÎµÏ„Î±Î²Î¹Î²Î¬Î¶ÎµÎ¹ Ï„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±:"

#: src/ownership/moves-function-calls.md:6
msgid ""
"```rust,editable\n"
"fn say_hello(name: String) {\n"
"    println!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let name = String::from(\"Alice\");\n"
"    say_hello(name);\n"
"    // say_hello(name);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/moves-function-calls.md:20
#, fuzzy
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"ÎœÎµ Ï„Î·Î½ Ï€ÏÏÏ„Î· ÎºÎ»Î®ÏƒÎ· ÏƒÏ„Î¿ \"say_hello\", Î¿ \"main\" Ï€Î±ÏÎ±Î¹Ï„ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î·Î½ "
"Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± Ï„Î¿Ï… \"name\". Î£Ï„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, Ï„Î¿ \"ÏŒÎ½Î¿Î¼Î±\" Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Ï€Î»Î­Î¿Î½ ÏƒÏ„Î¿ \"ÎºÏÏÎ¹Î¿\"."

#: src/ownership/moves-function-calls.md:21
#, fuzzy
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr ""
"Î— Î¼Î½Î®Î¼Î· ÏƒÏ‰ÏÎ¿Ï Ï€Î¿Ï… Î­Ï‡ÎµÎ¹ ÎµÎºÏ‡Ï‰ÏÎ·Î¸ÎµÎ¯ Î³Î¹Î± Ï„Î¿ \"ÏŒÎ½Î¿Î¼Î±\" Î¸Î± ÎµÎ»ÎµÏ…Î¸ÎµÏÏ‰Î¸ÎµÎ¯ ÏƒÏ„Î¿ Ï„Î­Î»Î¿Ï‚ "
"Ï„Î·Ï‚ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ \"say_hello\"."

#: src/ownership/moves-function-calls.md:22
#, fuzzy
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"Î¤Î¿ \"main\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î´Î¹Î±Ï„Î·ÏÎ®ÏƒÎµÎ¹ Ï„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± ÎµÎ¬Î½ Î¼ÎµÏ„Î±Î²Î¹Î²Î¬ÏƒÎµÎ¹ Ï„Î¿ \"name\" "
"Ï‰Ï‚ Î±Î½Î±Ï†Î¿ÏÎ¬ (\"&name\") ÎºÎ±Î¹ ÎµÎ¬Î½ Ï„Î¿ \"say_hello\" Î±Ï€Î¿Î´ÎµÏ‡Ï„ÎµÎ¯ Î¼Î¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ Ï‰Ï‚ "
"Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿."

#: src/ownership/moves-function-calls.md:23
#, fuzzy
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr ""
"Î•Î½Î±Î»Î»Î±ÎºÏ„Î¹ÎºÎ¬, Ï„Î¿ \"main\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÎµÏÎ¬ÏƒÎµÎ¹ Î­Î½Î±Î½ ÎºÎ»ÏÎ½Î¿ Ï„Î¿Ï… \"name\" ÏƒÏ„Î·Î½ "
"Ï€ÏÏÏ„Î· ÎºÎ»Î®ÏƒÎ· (\"name.clone()\")."

#: src/ownership/moves-function-calls.md:24
#, fuzzy
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"Î¤Î¿ Rust ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ Î´Ï…ÏƒÎºÎ¿Î»ÏŒÏ„ÎµÏÎ¿ Î±Ï€ÏŒ Ï„Î·Î½ C++ Ï„Î·Î½ Î±ÎºÎ¿ÏÏƒÎ¹Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î±Î½Ï„Î¹Î³ÏÎ¬Ï†Ï‰Î½ "
"ÎºÎ±Î¸Î¹ÏƒÏ„ÏÎ½Ï„Î±Ï‚ Ï„Î· ÏƒÎ·Î¼Î±ÏƒÎ¹Î¿Î»Î¿Î³Î¯Î± ÎºÎ¯Î½Î·ÏƒÎ·Ï‚ Ï‰Ï‚ Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î® ÎºÎ±Î¹ Î±Î½Î±Î³ÎºÎ¬Î¶Î¿Î½Ï„Î±Ï‚ Ï„Î¿Ï…Ï‚ "
"Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚ Î½Î± ÎºÎ¬Î½Î¿Ï…Î½ Ï„Î¿Ï…Ï‚ ÎºÎ»ÏÎ½Î¿Ï…Ï‚ Î¾ÎµÎºÎ¬Î¸Î±ÏÎ¿Ï…Ï‚."

#: src/ownership/copy-clone.md:3
#, fuzzy
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr ""
"Î•Î½Ï Î· ÏƒÎ·Î¼Î±ÏƒÎ¹Î¿Î»Î¿Î³Î¯Î± Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚ ÎµÎ¯Î½Î±Î¹ Î· Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®, Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î¿Î¹ Ï„ÏÏ€Î¿Î¹ "
"Î±Î½Ï„Î¹Î³ÏÎ¬Ï†Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®:"

#: src/ownership/copy-clone.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let x = 42;\n"
"    let y = x;\n"
"    println!(\"x: {x}\");\n"
"    println!(\"y: {y}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:14
#, fuzzy
msgid "These types implement the `Copy` trait."
msgstr "Î‘Ï…Ï„Î¿Î¯ Î¿Î¹ Ï„ÏÏ€Î¿Î¹ ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«Î‘Î½Ï„Î¹Î³ÏÎ±Ï†Î®Â»."

#: src/ownership/copy-clone.md:16
#, fuzzy
msgid "You can opt-in your own types to use copy semantics:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹Î»Î­Î¾ÎµÏ„Îµ Ï„Î¿Ï…Ï‚ Î´Î¹ÎºÎ¿ÏÏ‚ ÏƒÎ±Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ Î³Î¹Î± Ï‡ÏÎ®ÏƒÎ· ÏƒÎ·Î¼Î±ÏƒÎ¹Î¿Î»Î¿Î³Î¯Î±Ï‚ "
"Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î®Ï‚:"

#: src/ownership/copy-clone.md:18
msgid ""
"```rust,editable\n"
"#[derive(Copy, Clone, Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = p1;\n"
"    println!(\"p1: {p1:?}\");\n"
"    println!(\"p2: {p2:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/copy-clone.md:30
#, fuzzy
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr ""
"ÎœÎµÏ„Î¬ Ï„Î·Î½ Î±Î½Î¬Î¸ÎµÏƒÎ·, Ï„ÏŒÏƒÎ¿ Ï„Î¿ Â«p1Â» ÎºÎ±Î¹ Ï„Î¿ Â«p2Â» Î­Ï‡Î¿Ï…Î½ Ï„Î± Î´Î¹ÎºÎ¬ Ï„Î¿Ï…Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Î±."

#: src/ownership/copy-clone.md:31
#, fuzzy
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr ""
"ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿ Â«p1.clone()Â» Î³Î¹Î± Î½Î± Î±Î½Ï„Î¹Î³ÏÎ¬ÏˆÎ¿Ï…Î¼Îµ ÏÎ·Ï„Î¬ "
"Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î±."

#: src/ownership/copy-clone.md:35
#, fuzzy
msgid "Copying and cloning are not the same thing:"
msgstr "Î— Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î® ÎºÎ±Î¹ Î· ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Î¯Î´Î¹Î¿ Ï€ÏÎ¬Î³Î¼Î±:"

#: src/ownership/copy-clone.md:37
#, fuzzy
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr ""
"Î— Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î® Î±Î½Î±Ï†Î­ÏÎµÏ„Î±Î¹ ÏƒÎµ Î±Î½Ï„Î¯Î³ÏÎ±Ï†Î± bitwise Ï€ÎµÏÎ¹Î¿Ï‡ÏÎ½ Î¼Î½Î®Î¼Î·Ï‚ ÎºÎ±Î¹ Î´ÎµÎ½ "
"Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÏƒÎµ Î±Ï…Î¸Î±Î¯ÏÎµÏ„Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î±."

#: src/ownership/copy-clone.md:38
#, fuzzy
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr ""
"Î— Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î® Î´ÎµÎ½ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½Î· Î»Î¿Î³Î¹ÎºÎ® (ÏƒÎµ Î±Î½Ï„Î¯Î¸ÎµÏƒÎ· Î¼Îµ Ï„Î¿Ï…Ï‚ "
"ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î±ÏƒÏ„Î­Ï‚ Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î®Ï‚ ÏƒÏ„Î· C++)."

#: src/ownership/copy-clone.md:39
#, fuzzy
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr ""
"Î— ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Ï€Î¹Î¿ Î³ÎµÎ½Î¹ÎºÎ® Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± ÎºÎ±Î¹ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ "
"Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ Î¼Îµ Ï„Î·Î½ ÎµÏ†Î±ÏÎ¼Î¿Î³Î® Ï„Î¿Ï… Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¿Ï Â«ÎšÎ»Ï‰Î½Î¿Ï€Î¿Î¯Î·ÏƒÎ·Â»."

#: src/ownership/copy-clone.md:40
#, fuzzy
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr ""
"Î— Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î® Î´ÎµÎ½ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÏƒÎµ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€Î¿Ï… ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«DropÂ»."

#: src/ownership/copy-clone.md:42 src/ownership/lifetimes-function-calls.md:29
#, fuzzy
msgid "In the above example, try the following:"
msgstr "Î£Ï„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Ï„Î± ÎµÎ¾Î®Ï‚:"

#: src/ownership/copy-clone.md:44
#, fuzzy
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Î­Î½Î± Ï€ÎµÎ´Î¯Î¿ Â«StringÂ» ÏƒÏ„Î¿ Â«struct PointÂ». Î”ÎµÎ½ Î¸Î± Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„ÎµÎ¯ "
"ÎµÏ€ÎµÎ¹Î´Î® Ï„Î¿ \"String\" Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï„ÏÏ€Î¿Ï‚ \"Î‘Î½Ï„Î¹Î³ÏÎ±Ï†Î®\"."

#: src/ownership/copy-clone.md:45
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for  `p1`."
msgstr ""
"ÎšÎ±Ï„Î±ÏÎ³Î®ÏƒÏ„Îµ Ï„Î¿ \"Copy\" Î±Ï€ÏŒ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ \"derive\". Î¤Î¿ ÏƒÏ†Î¬Î»Î¼Î± "
"Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Ï„ÏÏÎ± ÏƒÏ„Î¿ Â«println!Â» Î³Î¹Î± Ï„Î¿ Â«p1Â»."

#: src/ownership/copy-clone.md:46
#, fuzzy
msgid "Show that it works if you clone `p1` instead."
msgstr "Î”ÎµÎ¯Î¾Ï„Îµ ÏŒÏ„Î¹ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÎµÎ¬Î½ Î±Î½Ï„' Î±Ï…Ï„Î¿Ï ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ \"p1\"."

#: src/ownership/copy-clone.md:48
#, fuzzy
msgid ""
"If students ask about `derive`, it is sufficient to say that this is a way "
"to generate code in Rust at compile time. In this case the default "
"implementations of `Copy` and `Clone` traits are generated."
msgstr ""
"Î•Î¬Î½ Î¿Î¹ Î¼Î±Î¸Î·Ï„Î­Ï‚ ÏÏ‰Ï„Î®ÏƒÎ¿Ï…Î½ Î³Î¹Î± Ï„Î¿ Â«deriveÂ», Î±ÏÎºÎµÎ¯ Î½Î± Ï€Î¿ÏÎ¼Îµ ÏŒÏ„Î¹ Î±Ï…Ï„ÏŒÏ‚ ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ "
"Ï„ÏÏŒÏ€Î¿Ï‚ Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î±Ï‚ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ Rust Ï„Î·Î½ ÏÏÎ± Ï„Î·Ï‚ Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚. Î£Îµ Î±Ï…Ï„Î®Î½ Ï„Î·Î½ "
"Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¿ÏÎ½Ï„Î±Î¹ Î¿Î¹ Ï€ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½ÎµÏ‚ Ï…Î»Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹Ï‚ Ï„Ï‰Î½ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½ "
"Â«Î‘Î½Ï„Î¹Î³ÏÎ±Ï†Î®Â» ÎºÎ±Î¹ Â«ÎšÎ»Ï‰Î½Î¿Ï€Î¿Î¯Î·ÏƒÎ·Â»."

#: src/ownership/borrowing.md:3
#, fuzzy
msgid ""
"Instead of transferring ownership when calling a function, you can let a "
"function _borrow_ the value:"
msgstr ""
"Î‘Î½Ï„Î¯ Î½Î± Î¼ÎµÏ„Î±Î²Î¹Î²Î¬Î¶ÎµÏ„Îµ Ï„Î·Î½ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± ÎºÎ±Ï„Î¬ Ï„Î·Î½ ÎºÎ»Î®ÏƒÎ· Î¼Î¹Î±Ï‚ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ "
"Î½Î± Î±Ï†Î®ÏƒÎµÏ„Îµ Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· _borrow_ Ï„Î·Î½ Ï„Î¹Î¼Î®:"

#: src/ownership/borrowing.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    Point(p1.0 + p2.0, p1.1 + p2.1)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/borrowing.md:22
#, fuzzy
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr ""
"Î— ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Â«Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Â» _Î´Î±Î½ÎµÎ¯Î¶ÎµÏ„Î±Î¹_ Î´ÏÎ¿ ÏƒÎ·Î¼ÎµÎ¯Î± ÎºÎ±Î¹ ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î­Î½Î± Î½Î­Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿."

#: src/ownership/borrowing.md:23
#, fuzzy
msgid "The caller retains ownership of the inputs."
msgstr "ÎŸ ÎºÎ±Î»ÏÎ½ Î´Î¹Î±Ï„Î·ÏÎµÎ¯ Ï„Î·Î½ ÎºÏ…ÏÎ¹ÏŒÏ„Î·Ï„Î± Ï„Ï‰Î½ ÎµÎ¹ÏƒÏŒÎ´Ï‰Î½."

#: src/ownership/borrowing.md:27
msgid "Notes on stack returns:"
msgstr ""

#: src/ownership/borrowing.md:28
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/) or look at the "
"assembly in [Godbolt](https://rust.godbolt.org/). In the \"DEBUG\" "
"optimization level, the addresses should change, while they stay the same "
"when changing to the \"RELEASE\" setting:"
msgstr ""

#: src/ownership/borrowing.md:30
#, fuzzy
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn add(p1: &Point, p2: &Point) -> Point {\n"
"    let p = Point(p1.0 + p2.0, p1.1 + p2.1);\n"
"    println!(\"&p.0: {:p}\", &p.0);\n"
"    p\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let p1 = Point(3, 4);\n"
"    let p2 = Point(10, 20);\n"
"    let p3 = add(&p1, &p2);\n"
"    println!(\"&p3.0: {:p}\", &p3.0);\n"
"    println!(\"{p1:?} + {p2:?} = {p3:?}\");\n"
"}\n"
"```"
msgstr "ÎˆÎ½Î±Ï‚ Î¬Î»Î»Î¿Ï‚ Ï„ÏÏŒÏ€Î¿Ï‚ Î½Î± Ï„Î¿ ÎµÎ¾Î·Î³Î®ÏƒÎµÏ„Îµ:"

#: src/ownership/borrowing.md:48
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr ""

#: src/ownership/borrowing.md:49
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""

#: src/ownership/shared-unique-borrows.md:3
#, fuzzy
msgid "Rust puts constraints on the ways you can borrow values:"
msgstr ""
"Î¤Î¿ Rust Î¸Î­Ï„ÎµÎ¹ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿ÏÏ‚ ÏƒÏ„Î¿Ï…Ï‚ Ï„ÏÏŒÏ€Î¿Ï…Ï‚ Î¼Îµ Ï„Î¿Ï…Ï‚ Î¿Ï€Î¿Î¯Î¿Ï…Ï‚ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"Î´Î±Î½ÎµÎ¹ÏƒÏ„ÎµÎ¯Ï„Îµ Ï„Î¹Î¼Î­Ï‚:"

#: src/ownership/shared-unique-borrows.md:5
#, fuzzy
msgid "You can have one or more `&T` values at any given time, _or_"
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î­Ï‡ÎµÏ„Îµ Î¼Î¯Î± Î® Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ Ï„Î¹Î¼Î­Ï‚ \"&T\" Î±Î½Î¬ Ï€Î¬ÏƒÎ± ÏƒÏ„Î¹Î³Î¼Î®, _Î®_"

#: src/ownership/shared-unique-borrows.md:6
#, fuzzy
msgid "You can have exactly one `&mut T` value."
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î­Ï‡ÎµÏ„Îµ Î±ÎºÏÎ¹Î²ÏÏ‚ Î¼Î¯Î± Ï„Î¹Î¼Î® Â«&mut TÂ»."

#: src/ownership/shared-unique-borrows.md:8
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let mut a: i32 = 10;\n"
"    let b: &i32 = &a;\n"
"\n"
"    {\n"
"        let c: &mut i32 = &mut a;\n"
"        *c = 20;\n"
"    }\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/shared-unique-borrows.md:25
#, fuzzy
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"ÎŸ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Î´ÎµÎ½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¯Î¶ÎµÏ„Î±Î¹ ÎµÏ€ÎµÎ¹Î´Î® Ï„Î¿ Â«aÂ» Î´Î±Î½ÎµÎ¯Î¶ÎµÏ„Î±Î¹ Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î± "
"Ï‰Ï‚ mutable (Î¼Î­ÏƒÏ‰ Â«cÂ») ÎºÎ±Î¹ Ï‰Ï‚ Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î¿ (Î¼Î­ÏƒÏ‰ Â«bÂ»)."

#: src/ownership/shared-unique-borrows.md:26
#, fuzzy
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"ÎœÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÏ„Îµ Ï„Î· Î´Î®Î»Ï‰ÏƒÎ· Â«println!Â» Î³Î¹Î± Ï„Î¿ Â«bÂ» Ï€ÏÎ¹Î½ Î±Ï€ÏŒ Ï„Î¿ ÎµÏÏÎ¿Ï‚ Ï€Î¿Ï… ÎµÎ¹ÏƒÎ¬Î³ÎµÎ¹ Ï„Î¿ "
"Â«cÂ» Î³Î¹Î± Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ· Ï„Î¿Ï… ÎºÏÎ´Î¹ÎºÎ±."

#: src/ownership/shared-unique-borrows.md:27
#, fuzzy
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"ÎœÎµÏ„Î¬ Î±Ï€ÏŒ Î±Ï…Ï„Î®Î½ Ï„Î·Î½ Î±Î»Î»Î±Î³Î®, Î¿ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ ÏƒÏ…Î½ÎµÎ¹Î´Î·Ï„Î¿Ï€Î¿Î¹ÎµÎ¯ ÏŒÏ„Î¹ Ï„Î¿ \"b\" "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î¼ÏŒÎ½Î¿ Ï€ÏÎ¹Î½ Î±Ï€ÏŒ Ï„Î¿ Î½Î­Î¿ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏŒ Î´Î¬Î½ÎµÎ¹Î¿ Ï„Î¿Ï… \"a\" Î­Ï‰Ï‚ Ï„Î¿ "
"\"c\". Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï„Î¿Ï… ÎµÎ»ÎµÎ³ÎºÏ„Î® Î´Î±Î½ÎµÎ¹ÏƒÎ¼Î¿Ï Ï€Î¿Ï… Î¿Î½Î¿Î¼Î¬Î¶ÎµÏ„Î±Î¹ "
"\"Î¼Î· Î»ÎµÎ¾Î¹Î»Î¿Î³Î¹ÎºÎ­Ï‚ Î¶Ï‰Î­Ï‚\"."

#: src/ownership/lifetimes.md:3
#, fuzzy
msgid "A borrowed value has a _lifetime_:"
msgstr "ÎœÎ¹Î± Î´Î±Î½ÎµÎ¹ÏƒÎ¼Î­Î½Î· Î±Î¾Î¯Î± Î­Ï‡ÎµÎ¹ _Î´Î¹Î¬ÏÎºÎµÎ¹Î± Î¶Ï‰Î®Ï‚_:"

#: src/ownership/lifetimes.md:5
msgid "The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`."
msgstr ""

#: src/ownership/lifetimes.md:6
msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
msgstr ""

#: src/ownership/lifetimes.md:7 src/ownership/lifetimes-function-calls.md:23
#, fuzzy
msgid ""
"Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
"lifetime `a`\"."
msgstr ""
"Î”Î¹Î±Î²Î¬ÏƒÏ„Îµ Ï„Î¿ '&'a Point' Ï‰Ï‚ \"Î­Î½Î± Î´Î±Î½ÎµÎ¹ÎºÏŒ \"Point\" Ï€Î¿Ï… Î¹ÏƒÏ‡ÏÎµÎ¹ Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ "
"Î³Î¹Î± Ï„Î¿ Î´Î¹Î¬ÏÎºÎµÎ¹Î± Î¶Ï‰Î®Ï‚ Â«Î±Â»Â»."

#: src/ownership/lifetimes.md:9
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself."
msgstr ""

#: src/ownership/lifetimes.md:11
msgid ""
"Lifetime annotations create constraints; the compiler verifies that there is "
"a valid solution."
msgstr ""

#: src/ownership/lifetimes.md:13
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html)."
msgstr ""

#: src/ownership/lifetimes-function-calls.md:3
#, fuzzy
msgid ""
"In addition to borrowing its arguments, a function can return a borrowed "
"value:"
msgstr ""
"Î•ÎºÏ„ÏŒÏ‚ Î±Ï€ÏŒ Ï„Î¿Î½ Î´Î±Î½ÎµÎ¹ÏƒÎ¼ÏŒ Ï„Ï‰Î½ Î¿ÏÎ¹ÏƒÎ¼Î¬Ï„Ï‰Î½ Ï„Î·Ï‚, Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎµÎ¹ "
"Î¼Î¹Î± Î´Î±Î½ÎµÎ¹ÏƒÎ¼Î­Î½Î· Ï„Î¹Î¼Î®:"

#: src/ownership/lifetimes-function-calls.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p2: Point = Point(20, 20);\n"
"    let p3: &Point = left_most(&p1, &p2);\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-function-calls.md:21
#, fuzzy
msgid "`'a` is a generic parameter, it is inferred by the compiler."
msgstr "Î¤Î¿ `'a` ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î³ÎµÎ½Î¹ÎºÎ® Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Ï‚, ÏƒÏ…Î½Î¬Î³ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®."

#: src/ownership/lifetimes-function-calls.md:22
#, fuzzy
msgid "Lifetimes start with `'` and `'a` is a typical default name."
msgstr ""
"ÎŸÎ¹ Î´Î¹Î¬ÏÎºÎµÎ¹ÎµÏ‚ Î¶Ï‰Î®Ï‚ Î¾ÎµÎºÎ¹Î½Î¿ÏÎ½ Î¼Îµ \"\"\" ÎºÎ±Î¹ Ï„Î¿ \"a\" ÎµÎ¯Î½Î±Î¹ Î­Î½Î± Ï„Ï…Ï€Î¹ÎºÏŒ "
"Ï€ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½Î¿ ÏŒÎ½Î¿Î¼Î±."

#: src/ownership/lifetimes-function-calls.md:25
#, fuzzy
msgid ""
"The _at least_ part is important when parameters are in different scopes."
msgstr ""
"Î¤Î¿ Ï„Î¼Î®Î¼Î± _Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½_ ÎµÎ¯Î½Î±Î¹ ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ ÏŒÏ„Î±Î½ Î¿Î¹ Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Î¹ Î²ÏÎ¯ÏƒÎºÎ¿Î½Ï„Î±Î¹ ÏƒÎµ "
"Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬ Ï€ÎµÎ´Î¯Î±."

#: src/ownership/lifetimes-function-calls.md:31
#, fuzzy
msgid ""
"Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
"resulting in the following code:"
msgstr ""
"Î•Ï€Î±Î½Î±Ï†Î­ÏÎµÏ„Îµ Ï„Î¿Î½ Ï‡ÏÏÎ¿ ÎµÏÎ³Î±ÏƒÎ¯Î±Ï‚ ÎºÎ±Î¹ Î±Î»Î»Î¬Î¾Ï„Îµ Ï„Î·Î½ Ï…Ï€Î¿Î³ÏÎ±Ï†Î® Ï„Î·Ï‚ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ ÏƒÎµ `fn "
"left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. Î‘Ï…Ï„ÏŒ Î´ÎµÎ½ Î¸Î± "
"Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„ÎµÎ¯ ÎµÏ€ÎµÎ¹Î´Î® Î· ÏƒÏ‡Î­ÏƒÎ· Î¼ÎµÏ„Î±Î¾Ï Ï„Ï‰Î½ Ï‡ÏÏŒÎ½Ï‰Î½ Î¶Ï‰Î®Ï‚ \"a\" ÎºÎ±Î¹ \"b\" ÎµÎ¯Î½Î±Î¹ "
"Î±ÏƒÎ±Ï†Î®Ï‚."

#: src/ownership/lifetimes-function-calls.md:32
#, fuzzy
msgid ""
"```rust,ignore\n"
"#[derive(Debug)]\n"
"struct Point(i32, i32);\n"
"\n"
"fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {\n"
"    if p1.0 < p2.0 { p1 } else { p2 }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1: Point = Point(10, 10);\n"
"    let p3: &Point;\n"
"    {\n"
"        let p2: Point = Point(20, 20);\n"
"        p3 = left_most(&p1, &p2);\n"
"    }\n"
"    println!(\"left-most point: {:?}\", p3);\n"
"}\n"
"```"
msgstr "ÎˆÎ½Î±Ï‚ Î¬Î»Î»Î¿Ï‚ Ï„ÏÏŒÏ€Î¿Ï‚ Î½Î± Ï„Î¿ ÎµÎ¾Î·Î³Î®ÏƒÎµÏ„Îµ:"

#: src/ownership/lifetimes-function-calls.md:50
#, fuzzy
msgid "Note how this does not compile since `p3` outlives `p2`."
msgstr ""
"Î”ÏÎ¿ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚ ÏƒÎµ Î´ÏÎ¿ Ï„Î¹Î¼Î­Ï‚ Î´Î±Î½ÎµÎ¯Î¶Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· ÎºÎ±Î¹ Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· "
"ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î¬Î»Î»Î· Î±Î½Î±Ï†Î¿ÏÎ¬."

#: src/ownership/lifetimes-function-calls.md:52
#, fuzzy
msgid ""
"Reset the workspace and change the function signature to `fn left_most<'a, "
"'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will not compile "
"because the relationship between the lifetimes `'a` and `'b` is unclear."
msgstr ""
"Î ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€ÏÎ¿Î­ÏÏ‡ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Î¼Î¯Î± Î±Ï€ÏŒ Î±Ï…Ï„Î­Ï‚ Ï„Î¹Ï‚ Î´ÏÎ¿ ÎµÎ¹ÏƒÏŒÎ´Î¿Ï…Ï‚ (Î® Î±Ï€ÏŒ Î¼Î¹Î± ÎºÎ±Î¸Î¿Î»Î¹ÎºÎ® "
"Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î®)."

#: src/ownership/lifetimes-function-calls.md:53
#, fuzzy
msgid "Another way to explain it:"
msgstr ""
"Î Î¿Î¹Î¿ ÎµÎ¯Î½Î±Î¹ Î±Ï€ 'ÏŒÎ»Î±? ÎŸ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î³Î½Ï‰ÏÎ¯Î¶ÎµÎ¹, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ ÏƒÏ„Î¿Î½ "
"Î¹ÏƒÏ„ÏŒÏ„Î¿Ï€Î¿ ÎºÎ»Î®ÏƒÎ·Ï‚ Î´ÎµÎ½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î· ÎµÏ€Î¹ÏƒÏ„ÏÎµÏ†ÏŒÎ¼ÎµÎ½Î· Î±Î½Î±Ï†Î¿ÏÎ¬ Î³Î¹Î± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ "
"Î±Ï€ÏŒ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î±Ï€ÏŒ Ï„Î·Î½ Î¿Ï€Î¿Î¯Î± Ï€ÏÎ¿Î®Î»Î¸Îµ Î· Î±Î½Î±Ï†Î¿ÏÎ¬."

#: src/ownership/lifetimes-function-calls.md:54
msgid ""
"Two references to two values are borrowed by a function and the function "
"returns another reference."
msgstr ""

#: src/ownership/lifetimes-function-calls.md:56
msgid ""
"It must have come from one of those two inputs (or from a global variable)."
msgstr ""

#: src/ownership/lifetimes-function-calls.md:57
msgid ""
"Which one is it? The compiler needs to know, so at the call site the "
"returned reference is not used for longer than a variable from where the "
"reference came from."
msgstr ""

#: src/ownership/lifetimes-data-structures.md:3
#, fuzzy
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr ""
"Î•Î¬Î½ Î­Î½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î±Ï€Î¿Î¸Î·ÎºÎµÏÎµÎ¹ Î´Î±Î½ÎµÎ¹ÏƒÎ¼Î­Î½Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î±, Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"ÏƒÏ‡Î¿Î»Î¹Î¬Î¶ÎµÏ„Î±Î¹ Î¼Îµ Î¼Î¹Î± Î´Î¹Î¬ÏÎºÎµÎ¹Î± Î¶Ï‰Î®Ï‚:"

#: src/ownership/lifetimes-data-structures.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Highlight<'doc>(&'doc str);\n"
"\n"
"fn erase(text: String) {\n"
"    println!(\"Bye {text}!\");\n"
"}\n"
"\n"
"fn main() {\n"
"    let text = String::from(\"The quick brown fox jumps over the lazy dog."
"\");\n"
"    let fox = Highlight(&text[4..19]);\n"
"    let dog = Highlight(&text[35..43]);\n"
"    // erase(text);\n"
"    println!(\"{fox:?}\");\n"
"    println!(\"{dog:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/ownership/lifetimes-data-structures.md:25
#, fuzzy
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"Î£Ï„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î¿ ÏƒÏ‡Î¿Î»Î¹Î±ÏƒÎ¼ÏŒÏ‚ ÏƒÏ„Î¿ \"Highlight\" ÎµÏ€Î¹Î²Î¬Î»Î»ÎµÎ¹ ÏŒÏ„Î¹ Ï„Î± "
"Î´ÎµÎ´Î¿Î¼Î­Î½Î± Ï€Î¿Ï… Î²ÏÎ¯ÏƒÎºÎ¿Î½Ï„Î±Î¹ ÎºÎ¬Ï„Ï‰ Î±Ï€ÏŒ Ï„Î¿ Ï€ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ \"&str\" Î¶Î¿Ï…Î½ Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ "
"Î³Î¹Î± ÏŒÏƒÎ¿ Ï‡ÏÎ¿Î½Î¹ÎºÏŒ Î´Î¹Î¬ÏƒÏ„Î·Î¼Î± Î¿Ï€Î¿Î¹Î¿Î´Î®Ï€Î¿Ï„Îµ ÏƒÏ„Î¹Î³Î¼Î¹ÏŒÏ„Ï…Ï€Î¿ Ï„Î¿Ï… \"Highlight\" Ï€Î¿Ï… "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Î±Ï…Ï„Î¬ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î±."

#: src/ownership/lifetimes-data-structures.md:26
#, fuzzy
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"Î•Î¬Î½ Ï„Î¿ Â«ÎºÎµÎ¯Î¼ÎµÎ½Î¿Â» ÎºÎ±Ï„Î±Î½Î±Î»Ï‰Î¸ÎµÎ¯ Ï€ÏÎ¹Î½ Î±Ï€ÏŒ Ï„Î¿ Ï„Î­Î»Î¿Ï‚ Ï„Î·Ï‚ Î´Î¹Î¬ÏÎºÎµÎ¹Î±Ï‚ Î¶Ï‰Î®Ï‚ Ï„Î¿Ï… "
"Â«Î±Î»ÎµÏ€Î¿ÏÂ» (Î® Ï„Î¿Ï… Â«ÏƒÎºÏÎ»Î¿Ï…Â»), Î¿ ÎµÎ»ÎµÎ³ÎºÏ„Î®Ï‚ Î´Î±Î½ÎµÎ¯Î¿Ï… ÎºÎ¬Î½ÎµÎ¹ Î­Î½Î± ÏƒÏ†Î¬Î»Î¼Î±."

#: src/ownership/lifetimes-data-structures.md:27
#, fuzzy
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"ÎŸÎ¹ Ï„ÏÏ€Î¿Î¹ Î¼Îµ Î´Î±Î½ÎµÎ¹ÎºÎ¬ Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î±Î½Î±Î³ÎºÎ¬Î¶Î¿Ï…Î½ Ï„Î¿Ï…Ï‚ Ï‡ÏÎ®ÏƒÏ„ÎµÏ‚ Î½Î± Ï€Î±ÏÎ±Î¼ÎµÎ¯Î½Î¿Ï…Î½ ÏƒÏ„Î± "
"Î±ÏÏ‡Î¹ÎºÎ¬ Î´ÎµÎ´Î¿Î¼Î­Î½Î±. Î‘Ï…Ï„ÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ Î³Î¹Î± Ï„Î· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎµÎ»Î±Ï†ÏÎ¹ÏÎ½ "
"Ï€ÏÎ¿Î²Î¿Î»ÏÎ½, Î±Î»Î»Î¬ Î³ÎµÎ½Î¹ÎºÎ¬ Ï„Î¹Ï‚ ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ ÎºÎ¬Ï€Ï‰Ï‚ Ï€Î¹Î¿ Î´ÏÏƒÎºÎ¿Î»ÎµÏ‚ ÏƒÏ„Î· Ï‡ÏÎ®ÏƒÎ·."

#: src/ownership/lifetimes-data-structures.md:28
#, fuzzy
msgid "When possible, make data structures own their data directly."
msgstr ""
"ÎŒÏ„Î±Î½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒÎ½, ÎºÎ¬Î½Ï„Îµ Ï„Î¹Ï‚ Î´Î¿Î¼Î­Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î½Î± ÎºÎ±Ï„Î­Ï‡Î¿Ï…Î½ Î±Ï€ÎµÏ…Î¸ÎµÎ¯Î±Ï‚ Ï„Î± "
"Î´ÎµÎ´Î¿Î¼Î­Î½Î± Ï„Î¿Ï…Ï‚."

#: src/ownership/lifetimes-data-structures.md:29
#, fuzzy
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"ÎŸÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î´Î¿Î¼Î­Ï‚ Î¼Îµ Ï€Î¿Î»Î»Î±Ï€Î»Î­Ï‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚ ÏƒÏ„Î¿ ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡Î¿Ï…Î½ "
"Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿Ï…Ï‚ Î±Ï€ÏŒ Î­Î½Î±Î½ ÏƒÏ‡Î¿Î»Î¹Î±ÏƒÎ¼Î¿ÏÏ‚ Î´Î¹Î¬ÏÎºÎµÎ¹Î±Ï‚ Î¶Ï‰Î®Ï‚. Î‘Ï…Ï„ÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ "
"Î±Ï€Î±ÏÎ±Î¯Ï„Î·Ï„Î¿ ÎµÎ¬Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î±Î½Î¬Î³ÎºÎ· Î½Î± Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î¿ÏÎ½ ÏƒÏ‡Î­ÏƒÎµÎ¹Ï‚ Î´Î¹Î¬ÏÎºÎµÎ¹Î±Ï‚ Î¶Ï‰Î®Ï‚ Î¼ÎµÏ„Î±Î¾Ï "
"Ï„Ï‰Î½ Î¯Î´Î¹Ï‰Î½ Ï„Ï‰Î½ Î±Î½Î±Ï†Î¿ÏÏÎ½, ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ Ï„Î·Ï‚ Î´Î¹Î¬ÏÎºÎµÎ¹Î±Ï‚ Î¶Ï‰Î®Ï‚ Ï„Î·Ï‚ Î¯Î´Î¹Î±Ï‚ Ï„Î·Ï‚ Î´Î¿Î¼Î®Ï‚. "
"Î•Î¯Î½Î±Î¹ Ï€Î¿Î»Ï Ï€ÏÎ¿Î·Î³Î¼Î­Î½ÎµÏ‚ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚ Ï‡ÏÎ®ÏƒÎ·Ï‚."

#: src/exercises/day-2/morning.md:1
#, fuzzy
msgid "Day 2: Morning Exercises"
msgstr "Î—Î¼Î­ÏÎ± 2: Î ÏÏ‰Î¹Î½Î­Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-2/morning.md:3
#, fuzzy
msgid "We will look at implementing methods in two contexts:"
msgstr "Î˜Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ ÎµÏ†Î±ÏÎ¼Î¿Î³Î® Î¼ÎµÎ¸ÏŒÎ´Ï‰Î½ ÏƒÎµ Î´ÏÎ¿ Ï€Î»Î±Î¯ÏƒÎ¹Î±:"

#: src/exercises/day-2/morning.md:5
#, fuzzy
msgid "Simple struct which tracks health statistics."
msgstr "Î Î¿Î»Î»Î±Ï€Î»Î­Ï‚ Î´Î¿Î¼Î­Ï‚ ÎºÎ±Î¹ Î±ÏÎ¹Î¸Î¼Î¿Î¯ Î³Î¹Î± Î¼Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· ÏƒÏ‡ÎµÎ´Î¯Ï‰Î½."

#: src/exercises/day-2/morning.md:7
msgid "Multiple structs and enums for a drawing library."
msgstr ""

#: src/exercises/day-2/book-library.md:3
#, fuzzy
msgid ""
"We will learn much more about structs and the `Vec<T>` type tomorrow. For "
"now, you just need to know part of its API:"
msgstr ""
"Î˜Î± Î¼Î¬Î¸Î¿Ï…Î¼Îµ Ï€Î¿Î»Î»Î¬ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± Î³Î¹Î± Ï„Î¹Ï‚ Î´Î¿Î¼Î­Ï‚ ÎºÎ±Î¹ Ï„Î¿Î½ Ï„ÏÏ€Î¿ `Vec<T>` Î±ÏÏÎ¹Î¿. Î ÏÎ¿Ï‚ "
"Ï„Î¿ Ï€Î±ÏÏŒÎ½, Î±Ï€Î»Î¬ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î³Î½Ï‰ÏÎ¯Î¶ÎµÏ„Îµ Î¼Î­ÏÎ¿Ï‚ Ï„Î¿Ï… API Ï„Î¿Ï…:"

#: src/exercises/day-2/book-library.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut vec = vec![10, 20];\n"
"    vec.push(30);\n"
"    let midpoint = vec.len() / 2;\n"
"    println!(\"middle value: {}\", vec[midpoint]);\n"
"    for item in &vec {\n"
"        println!(\"item: {item}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/book-library.md:18
#, fuzzy
msgid ""
"Use this to model a library's book collection. Copy the code below to "
"<https://play.rust-lang.org/> and update the types to make it compile:"
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Î±Ï…Ï„ÏŒ Î³Î¹Î± Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î¼Î¹Î± ÎµÏ†Î±ÏÎ¼Î¿Î³Î® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚. "
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏ‰Î´Î¹ÎºÏŒ ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ "
"ÎµÎ½Î·Î¼ÎµÏÏÏƒÏ„Îµ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ Î³Î¹Î± Î½Î± Î³Î¯Î½ÎµÎ¹ Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·:"

#: src/exercises/day-2/book-library.md:21
msgid ""
"```rust,should_panic\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    fn new() -> Library {\n"
"        todo!(\"Initialize and return a `Library` value\")\n"
"    }\n"
"\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"}\n"
"\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", library."
"is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/book-library.md:102
#, fuzzy
msgid "[Solution](solutions-afternoon.md#designing-a-library)"
msgstr ""
"\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>\n"
"\n"
"[Î›ÏÏƒÎ·](solutions-afternoon.md#designing-a-library)"

#: src/exercises/day-2/iterators-and-ownership.md:3
#, fuzzy
msgid ""
"The ownership model of Rust affects many APIs. An example of this is the "
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"traits."
msgstr ""
"Î¤Î¿ Î¼Î¿Î½Ï„Î­Î»Î¿ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±Ï‚ Ï„Î¿Ï… Rust ÎµÏ€Î·ÏÎµÎ¬Î¶ÎµÎ¹ Ï€Î¿Î»Î»Î¬ API. ÎˆÎ½Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Î±Ï…Ï„Î¿Ï "
"ÎµÎ¯Î½Î±Î¹ Ï„Î¿ [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html) ÎºÎ±Î¹ [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait."
"IntoIterator.html) Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬."

#: src/exercises/day-2/iterators-and-ownership.md:8 src/bare-metal/no_std.md:28
#, fuzzy
msgid "`Iterator`"
msgstr "Â«IteratorÂ»."

#: src/exercises/day-2/iterators-and-ownership.md:10
#, fuzzy
msgid ""
"Traits are like interfaces: they describe behavior (methods) for a type. The "
"`Iterator` trait simply says that you can call `next` until you get `None` "
"back:"
msgstr ""
"Î¤Î± Î³Î½Ï‰ÏÎ¯ÏƒÎ¼Î±Ï„Î± ÎµÎ¯Î½Î±Î¹ ÏƒÎ±Î½ Î´Î¹ÎµÏ€Î±Ï†Î­Ï‚: Ï€ÎµÏÎ¹Î³ÏÎ¬Ï†Î¿Ï…Î½ Ï„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ (Î¼Î­Î¸Î¿Î´Î¿Î¹) Î³Î¹Î± "
"Î­Î½Î±Î½ Ï„ÏÏ€Î¿. Î¿ Î¤Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«IteratorÂ» Î»Î­ÎµÎ¹ Î±Ï€Î»ÏÏ‚ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Â«ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿Â» Î¼Î­Ï‡ÏÎ¹ Î½Î± Î»Î¬Î²ÎµÏ„Îµ Ï€Î¯ÏƒÏ‰ Ï„Î¿ Â«ÎšÎ±Î½Î­Î½Î±Â»:"

#: src/exercises/day-2/iterators-and-ownership.md:13
msgid ""
"```rust\n"
"pub trait Iterator {\n"
"    type Item;\n"
"    fn next(&mut self) -> Option<Self::Item>;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:20
#, fuzzy
msgid "You use this trait like this:"
msgstr "Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Î±Ï…Ï„ÏŒ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï‰Ï‚ ÎµÎ¾Î®Ï‚:"

#: src/exercises/day-2/iterators-and-ownership.md:22
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    println!(\"v[0]: {:?}\", iter.next());\n"
"    println!(\"v[1]: {:?}\", iter.next());\n"
"    println!(\"v[2]: {:?}\", iter.next());\n"
"    println!(\"No more items: {:?}\", iter.next());\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:34
#, fuzzy
msgid "What is the type returned by the iterator? Test your answer here:"
msgstr ""
"Î Î¿Î¹Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î¿ ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·Ï‚; Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Ï„Î·Î½ Î±Ï€Î¬Î½Ï„Î·ÏƒÎ® ÏƒÎ±Ï‚ "
"ÎµÎ´Ï:"

#: src/exercises/day-2/iterators-and-ownership.md:36
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<i8> = vec![10, 20, 30];\n"
"    let mut iter = v.iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:46
#, fuzzy
msgid "Why is this type used?"
msgstr "Î“Î¹Î±Ï„Î¯ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î±Ï…Ï„ÏŒÏ‚ Î¿ Ï„ÏÏ€Î¿Ï‚;"

#: src/exercises/day-2/iterators-and-ownership.md:48
#, fuzzy
msgid "`IntoIterator`"
msgstr "Â«IntoIteratorÂ»."

#: src/exercises/day-2/iterators-and-ownership.md:50
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait `IntoIterator` tells you how to create the "
"iterator:"
msgstr ""
"Î¤Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ \"Iterator\" ÏƒÎ¬Ï‚ Î»Î­ÎµÎ¹ Ï€ÏÏ‚ Î½Î± _ÎµÏ€Î±Î½Î¬Î»Î·ÏˆÎ·_ Î±Ï†Î¿Ï "
"Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î­Î½Î± ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·Ï‚. Î¤Î¿ ÏƒÏ‡ÎµÏ„Î¹ÎºÏŒ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«IntoIteratorÂ» ÏƒÎ¬Ï‚ "
"Î»Î­ÎµÎ¹ Ï€ÏÏ‚ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Ï„Î¿Î½ ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·:"

#: src/exercises/day-2/iterators-and-ownership.md:53
msgid ""
"```rust\n"
"pub trait IntoIterator {\n"
"    type Item;\n"
"    type IntoIter: Iterator<Item = Self::Item>;\n"
"\n"
"    fn into_iter(self) -> Self::IntoIter;\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:62
#, fuzzy
msgid ""
"The syntax here means that every implementation of `IntoIterator` must "
"declare two types:"
msgstr ""
"Î— ÏƒÏÎ½Ï„Î±Î¾Î· ÎµÎ´Ï ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ ÎºÎ¬Î¸Îµ Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… Â«IntoIteratorÂ» Ï€ÏÎ­Ï€ÎµÎ¹ Î”Î·Î»ÏÏƒÏ„Îµ "
"Î´ÏÎ¿ Ï„ÏÏ€Î¿Ï…Ï‚:"

#: src/exercises/day-2/iterators-and-ownership.md:65
#, fuzzy
msgid "`Item`: the type we iterate over, such as `i8`,"
msgstr "\"Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î¿\": Î¿ Ï„ÏÏ€Î¿Ï‚ Ï€Î¿Ï… ÎµÏ€Î±Î½Î±Î»Î±Î¼Î²Î¬Î½Î¿Ï…Î¼Îµ, ÏŒÏ€Ï‰Ï‚ \"i8\","

#: src/exercises/day-2/iterators-and-ownership.md:66
#, fuzzy
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr ""
"Â«IntoIterÂ»: Î¿ Ï„ÏÏ€Î¿Ï‚ Â«IteratorÂ» Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÏ„Î±Î¹ Î¼Îµ Ï„Î· Î¼Î­Î¸Î¿Î´Î¿ Â«into_iterÂ»."

#: src/exercises/day-2/iterators-and-ownership.md:68
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ ÏŒÏ„Î¹ Ï„Î¿ \"IntoIter\" ÎºÎ±Î¹ Ï„Î¿ \"Item\" ÎµÎ¯Î½Î±Î¹ ÏƒÏ…Î½Î´ÎµÎ´ÎµÎ¼Î­Î½Î±: Î¿ "
"ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î­Ï‡ÎµÎ¹ Ï„Î¿ Î¯Î´Î¹Î¿ Î¤ÏÏ€Î¿Ï‚ Â«Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î¿Â», Ï€Î¿Ï… ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ "
"ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Â«Î•Ï€Î¹Î»Î¿Î³Î®\\<Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î¿>Â»."

#: src/exercises/day-2/iterators-and-ownership.md:71
#, fuzzy
msgid "Like before, what  is the type returned by the iterator?"
msgstr "ÎŒÏ€Ï‰Ï‚ ÎºÎ±Î¹ Ï€ÏÎ¹Î½, Ï€Î¿Î¹Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î¿ ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·Ï‚;"

#: src/exercises/day-2/iterators-and-ownership.md:73
msgid ""
"```rust,editable,compile_fail\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"    let mut iter = v.into_iter();\n"
"\n"
"    let v0: Option<..> = iter.next();\n"
"    println!(\"v0: {v0:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:83
#, fuzzy
msgid "`for` Loops"
msgstr "Î’ÏÏŒÏ‡Î¿Î¹ Â«Î³Î¹Î±Â»."

#: src/exercises/day-2/iterators-and-ownership.md:85
#, fuzzy
msgid ""
"Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
"loops. They call `into_iter()` on an expression and iterates over the "
"resulting iterator:"
msgstr ""
"Î¤ÏÏÎ± Ï€Î¿Ï… Î³Î½Ï‰ÏÎ¯Î¶Î¿Ï…Î¼Îµ ÎºÎ±Î¹ Ï„Î± Î´ÏÎ¿ \"Iterator\" ÎºÎ±Î¹ \"IntoIterator\", Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ "
"Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î²ÏÏŒÏ‡Î¿Ï…Ï‚ \"for\". ÎšÎ±Î»Î¿ÏÎ½ Â«into_iter()Â» ÏƒÎµ Î¼Î¹Î± Î­ÎºÏ†ÏÎ±ÏƒÎ· ÎºÎ±Î¹ "
"ÎµÏ€Î±Î½Î±Î»Î±Î¼Î²Î¬Î½ÎµÏ„Î±Î¹ Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î¿ Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„Î·Ï‚:"

#: src/exercises/day-2/iterators-and-ownership.md:89
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let v: Vec<String> = vec![String::from(\"foo\"), String::"
"from(\"bar\")];\n"
"\n"
"    for word in &v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"\n"
"    for word in v {\n"
"        println!(\"word: {word}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/iterators-and-ownership.md:103
#, fuzzy
msgid "What is the type of `word` in each loop?"
msgstr "Î Î¿Î¹Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ Ï„Î·Ï‚ Î»Î­Î¾Î·Ï‚ ÏƒÎµ ÎºÎ¬Î¸Îµ Î²ÏÏŒÏ‡Î¿;"

#: src/exercises/day-2/iterators-and-ownership.md:105
#, fuzzy
msgid ""
"Experiment with the code above and then consult the documentation for [`impl "
"IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) and [`impl IntoIterator for "
"Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
"for-Vec%3CT,+A%3E) to check your answers."
msgstr ""
"Î ÎµÎ¹ÏÎ±Î¼Î±Ï„Î¹ÏƒÏ„ÎµÎ¯Ï„Îµ Î¼Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÎºÎ±Î¹, ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, ÏƒÏ…Î¼Î²Î¿Ï…Î»ÎµÏ…Ï„ÎµÎ¯Ï„Îµ Ï„Î·Î½ "
"Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ· Î³Î¹Î± [`impl IntoIterator Î³Î¹Î± &Vec<T>`](https://doc.rust-lang.org/"
"std/vec/struct.Vec.html#impl-IntoIterator-for-%26%27a%20Vec%3CT%2C%20A%3E) "
"ÎºÎ±Î¹ [`impl IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#impl-IntoIterator-for-Vec%3CT%2C%20A%3E) Î³Î¹Î± Î½Î± ÎµÎ»Î­Î³Î¾ÎµÏ„Îµ Ï„Î¹Ï‚ "
"Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚ ÏƒÎ±Ï‚."

#: src/structs.md:3
#, fuzzy
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "ÎŒÏ€Ï‰Ï‚ Î· C ÎºÎ±Î¹ Î· C++, Î· Rust Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÎ¹ Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½ÎµÏ‚ Î´Î¿Î¼Î­Ï‚:"

#: src/structs.md:5
msgid ""
"```rust,editable\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    peter.age = 28;\n"
"    println!(\"{} is {} years old\", peter.name, peter.age);\n"
"    \n"
"    let jackie = Person {\n"
"        name: String::from(\"Jackie\"),\n"
"        ..peter\n"
"    };\n"
"    println!(\"{} is {} years old\", jackie.name, jackie.age);\n"
"}\n"
"```"
msgstr ""

#: src/structs.md:33
msgid "Structs work like in C or C++."
msgstr ""

#: src/structs.md:34
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr ""

#: src/structs.md:35
msgid "Unlike in C++, there is no inheritance between structs."
msgstr ""

#: src/structs.md:36
msgid ""
"Methods are defined in an `impl` block, which we will see in following "
"slides."
msgstr ""

#: src/structs.md:37
msgid ""
"This may be a good time to let people know there are different types of "
"structs. "
msgstr ""

#: src/structs.md:38
msgid ""
"Zero-sized structs `e.g., struct Foo;` might be used when implementing a "
"trait on some type but donâ€™t have any data that you want to store in the "
"value itself. "
msgstr ""

#: src/structs.md:39
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr ""

#: src/structs.md:40
msgid ""
"The syntax `..peter` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""

#: src/structs/tuple-structs.md:3
#, fuzzy
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr ""
"Î•Î¬Î½ Ï„Î± Î¿Î½ÏŒÎ¼Î±Ï„Î± Ï„Ï‰Î½ Ï€ÎµÎ´Î¯Ï‰Î½ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÎ¬, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ "
"Î¼Î¹Î± Î´Î¿Î¼Î® Ï€Î»ÎµÎ¹Î¬Î´Î±Ï‚:"

#: src/structs/tuple-structs.md:5
msgid ""
"```rust,editable\n"
"struct Point(i32, i32);\n"
"\n"
"fn main() {\n"
"    let p = Point(17, 23);\n"
"    println!(\"({}, {})\", p.0, p.1);\n"
"}\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:14
#, fuzzy
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr ""
"Î‘Ï…Ï„ÏŒ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ ÏƒÏ…Ï‡Î½Î¬ Î³Î¹Î± Ï€ÎµÏÎ¹Ï„Ï…Î»Î¯Î³Î¼Î±Ï„Î± ÎµÎ½ÏŒÏ‚ Ï€ÎµÎ´Î¯Î¿Ï… (Ï€Î¿Ï… Î¿Î½Î¿Î¼Î¬Î¶Î¿Î½Ï„Î±Î¹ "
"Î½Î­Î¿Î¹ Ï„ÏÏ€Î¿Î¹):"

#: src/structs/tuple-structs.md:16
msgid ""
"```rust,editable,compile_fail\n"
"struct PoundsOfForce(f64);\n"
"struct Newtons(f64);\n"
"\n"
"fn compute_thruster_force() -> PoundsOfForce {\n"
"    todo!(\"Ask a rocket scientist at NASA\")\n"
"}\n"
"\n"
"fn set_thruster_force(force: Newtons) {\n"
"    // ...\n"
"}\n"
"\n"
"fn main() {\n"
"    let force = compute_thruster_force();\n"
"    set_thruster_force(force);\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/structs/tuple-structs.md:37
#, fuzzy
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"ÎŸÎ¹ Î½Î­Î¿Î¹ Ï„ÏÏ€Î¿Î¹ ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Ï€Î¿Î»Ï ÎºÎ±Î»ÏŒÏ‚ Ï„ÏÏŒÏ€Î¿Ï‚ Î³Î¹Î± Î½Î± ÎºÏ‰Î´Î¹ÎºÎ¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï€ÏÏŒÏƒÎ¸ÎµÏ„ÎµÏ‚ "
"Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î·Î½ Ï„Î¹Î¼Î® ÏƒÎµ Î­Î½Î±Î½ Ï€ÏÏ‰Ï„ÏŒÎ³Î¿Î½Î¿ Ï„ÏÏ€Î¿, Î³Î¹Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±:"

#: src/structs/tuple-structs.md:38
#, fuzzy
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr ""
"ÎŸ Î±ÏÎ¹Î¸Î¼ÏŒÏ‚ Î¼ÎµÏ„ÏÎ¹Î­Ï„Î±Î¹ ÏƒÎµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î¼Î¿Î½Î¬Î´ÎµÏ‚: Â«NewtonsÂ» ÏƒÏ„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±."

#: src/structs/tuple-structs.md:39
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: 'PhoneNumber(String)`or`OddNumber(u32)\\`."
msgstr ""
"Î— Ï„Î¹Î¼Î® Ï€Î­ÏÎ±ÏƒÎµ ÎºÎ¬Ï€Î¿Î¹Î± ÎµÏ€Î¹ÎºÏÏÏ‰ÏƒÎ· ÏŒÏ„Î±Î½ Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®Î¸Î·ÎºÎµ, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Î´ÎµÎ½ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏ„Î±Î¹ "
"Ï€Î»Î­Î¿Î½ Î½Î± Ï„Î·Î½ ÎµÏ€Î¹ÎºÏ…ÏÏÎ½ÎµÏ„Îµ Î¾Î±Î½Î¬ ÏƒÎµ ÎºÎ¬Î¸Îµ Ï‡ÏÎ®ÏƒÎ·: Â«PhoneNumber(String)Â» Î® "
"Â«OddNumber(u32)Â»."

#: src/structs/tuple-structs.md:40
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""

#: src/structs/tuple-structs.md:41
msgid ""
"Rust generally doesnâ€™t like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr ""

#: src/structs/tuple-structs.md:42
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr ""

#: src/structs/tuple-structs.md:43
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""

#: src/structs/field-shorthand.md:3
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand:"
msgstr ""
"Î•Î¬Î½ Î­Ï‡ÎµÏ„Îµ Î®Î´Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Î¼Îµ Ï„Î± ÏƒÏ‰ÏƒÏ„Î¬ Î¿Î½ÏŒÎ¼Î±Ï„Î±, Ï„ÏŒÏ„Îµ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ "
"Ï„Î¹Ï‚ Î´ÏŒÎ¼Î·ÏƒÎ· Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ ÏƒÏ…Î½Ï„Î¿Î¼Î¿Î³ÏÎ±Ï†Î¯Î±:"

#: src/structs/field-shorthand.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Person {\n"
"        Person { name, age }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person::new(String::from(\"Peter\"), 27);\n"
"    println!(\"{peter:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:27
msgid ""
"The `new` function could be written using `Self` as a type, as it is "
"interchangeable with the struct type name"
msgstr ""

#: src/structs/field-shorthand.md:29
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"impl Person {\n"
"    fn new(name: String, age: u8) -> Self {\n"
"        Self { name, age }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:41
msgid ""
"Implement the `Default` trait for the struct. Define some fields and use the "
"default values for the other fields."
msgstr ""

#: src/structs/field-shorthand.md:43
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"impl Default for Person {\n"
"    fn default() -> Person {\n"
"        Person {\n"
"            name: \"Bot\".to_string(),\n"
"            age: 0,\n"
"        }\n"
"    }\n"
"}\n"
"fn create_default() {\n"
"    let tmp = Person {\n"
"        ..Person::default()\n"
"    };\n"
"    let tmp = Person {\n"
"        name: \"Sam\".to_string(),\n"
"        ..Person::default()\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/structs/field-shorthand.md:68
msgid "Methods are defined in the `impl` block."
msgstr ""

#: src/structs/field-shorthand.md:69
msgid ""
"Use struct update syntax to define a new structure using `peter`. Note that "
"the variable `peter` will no longer be accessible afterwards."
msgstr ""

#: src/structs/field-shorthand.md:70
msgid ""
"Use `{:#?}` when printing structs to request the `Debug` representation."
msgstr ""

#: src/methods.md:3
#, fuzzy
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr ""
"Î¤Î¿ Rust ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± ÏƒÏ…ÏƒÏ‡ÎµÏ„Î¯Î¶ÎµÏ„Îµ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Î¼Îµ Ï„Î¿Ï…Ï‚ Î½Î­Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ ÏƒÎ±Ï‚. "
"Î¤Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î±Ï…Ï„ÏŒ Î¼Îµ Î­Î½Î± Î¼Ï€Î»Î¿Îº \"impl\":"

#: src/methods.md:6
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Person {\n"
"    name: String,\n"
"    age: u8,\n"
"}\n"
"\n"
"impl Person {\n"
"    fn say_hello(&self) {\n"
"        println!(\"Hello, my name is {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let peter = Person {\n"
"        name: String::from(\"Peter\"),\n"
"        age: 27,\n"
"    };\n"
"    peter.say_hello();\n"
"}\n"
"```"
msgstr ""

#: src/methods.md:31
#, fuzzy
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/methods.md:32
#, fuzzy
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î· Î· ÎµÎ¹ÏƒÎ±Î³Ï‰Î³Î® Î¼ÎµÎ¸ÏŒÎ´Ï‰Î½ ÏƒÏ…Î³ÎºÏÎ¯Î½Î¿Î½Ï„Î¬Ï‚ Ï„ÎµÏ‚ Î¼Îµ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚."

#: src/methods.md:33
#, fuzzy
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"ÎŸÎ¹ Î¼Î­Î¸Î¿Î´Î¿Î¹ ÎºÎ±Î»Î¿ÏÎ½Ï„Î±Î¹ ÏƒÎµ Î¼Î¹Î± Ï€Î±ÏÎ¿Ï…ÏƒÎ¯Î± ÎµÎ½ÏŒÏ‚ Ï„ÏÏ€Î¿Ï… (ÏŒÏ€Ï‰Ï‚ Î¼Î¹Î± Î´Î¿Î¼Î® Î® Î­Î½Î± enum), "
"Î· Ï€ÏÏÏ„Î· Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Ï‚ Î±Î½Ï„Î¹Ï€ÏÎ¿ÏƒÏ‰Ï€ÎµÏÎµÎ¹ Ï„Î·Î½ Ï€Î±ÏÎ¿Ï…ÏƒÎ¯Î± Ï‰Ï‚ \"self\"."

#: src/methods.md:34
#, fuzzy
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr ""
"ÎŸÎ¹ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± ÎµÏ€Î¹Î»Î­Î¾Î¿Ï…Î½ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î½ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ Î³Î¹Î± Î½Î± "
"ÎµÏ€Ï‰Ï†ÎµÎ»Î·Î¸Î¿ÏÎ½ Î±Ï€ÏŒ Ï„Î· ÏƒÏÎ½Ï„Î±Î¾Î· Ï„Î¿Ï… Î´Î­ÎºÏ„Î· Î¼ÎµÎ¸ÏŒÎ´Ï‰Î½ ÎºÎ±Î¹ Î½Î± Ï„Î¿Ï…Ï‚ Î²Î¿Î·Î¸Î®ÏƒÎ¿Ï…Î½ Î½Î± "
"Î´Î¹Î±Ï„Î·ÏÎ·Î¸Î¿ÏÎ½ Ï€Î¹Î¿ Î¿ÏÎ³Î±Î½Ï‰Î¼Î­Î½Î¿Î¹. Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± "
"Î´Î¹Î±Ï„Î·ÏÎ®ÏƒÎ¿Ï…Î¼Îµ ÏŒÎ»Î¿ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚ ÏƒÎµ Î­Î½Î± Ï€ÏÎ¿Î²Î»Î­ÏˆÎ¹Î¼Î¿ Î¼Î­ÏÎ¿Ï‚."

#: src/methods.md:35
#, fuzzy
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr "Î•Ï€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Ï„Î· Ï‡ÏÎ®ÏƒÎ· Ï„Î·Ï‚ Î»Î­Î¾Î·Ï‚-ÎºÎ»ÎµÎ¹Î´Î¹Î¿Ï Â«selfÂ», ÎµÎ½ÏŒÏ‚ Î´Î­ÎºÏ„Î· Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…."

#: src/methods.md:36
#, fuzzy
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr ""
"Î”ÎµÎ¯Î¾Ï„Îµ ÏŒÏ„Î¹ ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ ÏƒÏ…Î½Ï„Î¿Î¼ÎµÏ…Î¼Î­Î½Î¿Ï‚ ÏŒÏÎ¿Ï‚ Î³Î¹Î± Ï„Î¿ \"self:&Self\" ÎºÎ±Î¹ Î¯ÏƒÏ‰Ï‚ "
"Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï€ÏÏ‚ Î¸Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Ï„Î¿ ÏŒÎ½Î¿Î¼Î± Ï„Î·Ï‚ Î´Î¿Î¼Î®Ï‚."

#: src/methods.md:37
#, fuzzy
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"Î•Î¾Î·Î³Î®ÏƒÏ„Îµ ÏŒÏ„Î¹ Ï„Î¿ Self ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏˆÎµÏ…Î´ÏÎ½Ï…Î¼Î¿ Ï„ÏÏ€Î¿Ï… Î³Î¹Î± Ï„Î¿Î½ Ï„ÏÏ€Î¿ ÏƒÏ„Î¿Î½ Î¿Ï€Î¿Î¯Î¿ "
"Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Ï„Î¿ Î¼Ï€Î»Î¿Îº Â«implÂ» ÎºÎ±Î¹ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î±Î»Î»Î¿Ï ÏƒÏ„Î¿ Î¼Ï€Î»Î¿Îº."

#: src/methods.md:38
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by modifying the code and trying to run say_hello twice."
msgstr ""
"Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ Ï€ÏÏ‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î¿ ÎµÎ±Ï…Ï„ÏŒÏ‚ ÏŒÏ€Ï‰Ï‚ ÎºÎ±Î¹ Î¬Î»Î»ÎµÏ‚ Î´Î¿Î¼Î­Ï‚ ÎºÎ±Î¹ Î¿ "
"ÏƒÏ…Î¼Î²Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚ ÎºÎ¿Ï…ÎºÎºÎ¯Î´Ï‰Î½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î³Î¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎµ Î¼ÎµÎ¼Î¿Î½Ï‰Î¼Î­Î½Î± "
"Ï€ÎµÎ´Î¯Î±."

#: src/methods.md:39
#, fuzzy
msgid "We describe the distinction between method receivers next."
msgstr ""
"Î‘Ï…Ï„Î® Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÎºÎ±Î»Î® ÏƒÏ„Î¹Î³Î¼Î® Î³Î¹Î± Î½Î± Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï€ÏÏ‚ Ï„Î¿ \"&self\" "
"Î´Î¹Î±Ï†Î­ÏÎµÎ¹ Î±Ï€ÏŒ Ï„Î¿ \"self\" Ï„ÏÎ¿Ï€Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± ÎºÎ±Î¹ Ï€ÏÎ¿ÏƒÏ€Î±Î¸ÏÎ½Ï„Î±Ï‚ Î½Î± "
"ÎµÎºÏ„ÎµÎ»Î­ÏƒÎµÏ„Îµ Ï„Î¿ say_hello Î´ÏÎ¿ Ï†Î¿ÏÎ­Ï‚.\n"
"\n"
"Î£Ï„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î± Ï€ÎµÏÎ¹Î³ÏÎ¬Ï†Î¿Ï…Î¼Îµ Ï„Î· Î´Î¹Î¬ÎºÏÎ¹ÏƒÎ· Î¼ÎµÏ„Î±Î¾Ï Ï„Ï‰Î½ Î´ÎµÎºÏ„ÏÎ½ Î¼ÎµÎ¸ÏŒÎ´Ï‰Î½."

#: src/methods/receiver.md:3
#, fuzzy
msgid ""
"The `&self` above indicates that the method borrows the object immutably. "
"There are other possible receivers for a method:"
msgstr ""
"Î¤Î¿ \"&self\" Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï…Ï€Î¿Î´ÎµÎ¹ÎºÎ½ÏÎµÎ¹ ÏŒÏ„Î¹ Î· Î¼Î­Î¸Î¿Î´Î¿Ï‚ Î´Î±Î½ÎµÎ¯Î¶ÎµÏ„Î±Î¹ Ï„Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ "
"Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î±. Î•ÎºÎµÎ¯ ÎµÎ¯Î½Î±Î¹ Î¬Î»Î»Î¿Î¹ Ï€Î¹Î¸Î±Î½Î¿Î¯ Î´Î­ÎºÏ„ÎµÏ‚ Î³Î¹Î± Î¼Î¹Î± Î¼Î­Î¸Î¿Î´Î¿:"

#: src/methods/receiver.md:6
#, fuzzy
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"Â«&selfÂ»: Î´Î±Î½ÎµÎ¯Î¶ÎµÏ„Î±Î¹ Ï„Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î±Ï€ÏŒ Ï„Î¿Î½ ÎºÎ±Î»Î¿ÏÎ½Ï„Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Î­Î½Î± "
"ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î¿ ÎºÎ±Î¹ Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î¿ Î±Î½Î±Ï†Î¿ÏÎ¬. Î¤Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ "
"Î¾Î±Î½Î¬ Î¼ÎµÏ„Î¬."

#: src/methods/receiver.md:8
#, fuzzy
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"\"&mut self\": Î´Î±Î½ÎµÎ¯Î¶ÎµÏ„Î±Î¹ Ï„Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î±Ï€ÏŒ Ï„Î¿Î½ ÎºÎ±Î»Î¿ÏÎ½Ï„Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ "
"Î­Î½Î± Î¼Î¿Î½Î±Î´Î¹ÎºÏŒ ÎºÎ±Î¹ ÎµÏ…Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î¿ Î±Î½Î±Ï†Î¿ÏÎ¬. Î¤Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¾Î±Î½Î¬ Î¼ÎµÏ„Î¬."

#: src/methods/receiver.md:10
#, fuzzy
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"Â«selfÂ»: Î±Î½Î±Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï„Î·Î½ ÎºÏ…ÏÎ¹ÏŒÏ„Î·Ï„Î± Ï„Î¿Ï… Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï… ÎºÎ±Î¹ Ï„Î¿ Î±Ï€Î¿Î¼Î±ÎºÏÏÎ½ÎµÎ¹ Î±Ï€ÏŒ "
"Ï„Î¿Î½ ÎºÎ±Î»Î¿ÏÎ½Ï„Î±. Î¿ Î¼Î­Î¸Î¿Î´Î¿Ï‚ Î³Î¯Î½ÎµÏ„Î±Î¹ Î¿ Î¹Î´Î¹Î¿ÎºÏ„Î®Ï„Î·Ï‚ Ï„Î¿Ï… Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï…. Î¤Î¿ "
"Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î¸Î± Î±Ï€Î¿ÏÏÎ¹Ï†Î¸ÎµÎ¯ (ÎºÎ±Ï„Î±Î½ÎµÎ¼Î·Î¸ÎµÎ¯) ÏŒÏ„Î±Î½ Î· Î¼Î­Î¸Î¿Î´Î¿Ï‚ ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹, ÎµÎºÏ„ÏŒÏ‚ ÎµÎ¬Î½ "
"Î· Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± Ï„Î·Ï‚ ÎµÎ¯Î½Î±Î¹ ÏÎ·Ï„Î¬ Î¼ÎµÏ„Î±Î´ÏŒÎ¸Î·ÎºÎµ."

#: src/methods/receiver.md:14
msgid "`mut self`: same as above, but the method can mutate the object. "
msgstr ""

#: src/methods/receiver.md:15
#, fuzzy
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"Î§Ï‰ÏÎ¯Ï‚ Î´Î­ÎºÏ„Î·: Î±Ï…Ï„ÏŒ Î³Î¯Î½ÎµÏ„Î±Î¹ Î¼Î¹Î± ÏƒÏ„Î±Ï„Î¹ÎºÎ® Î¼Î­Î¸Î¿Î´Î¿Ï‚ ÏƒÏ„Î· Î´Î¿Î¼Î®. Î£Ï…Î½Î®Î¸Ï‰Ï‚ "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ ÏƒÎµ Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î±ÏƒÏ„Î­Ï‚ Ï€Î¿Ï… Î¿Î½Î¿Î¼Î¬Î¶Î¿Î½Ï„Î±Î¹ Â«Î½Î­Î¿Î¹Â» ÎºÎ±Ï„Î¬ "
"ÏƒÏÎ¼Î²Î±ÏƒÎ·."

#: src/methods/receiver.md:18
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"Î Î­ÏÎ± Î±Ï€ÏŒ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚ ÏƒÏ„Î¿Î½ Â«ÎµÎ±Ï…Ï„ÏŒÂ», Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÎµÏ€Î¯ÏƒÎ·Ï‚ [ÎµÎ¹Î´Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹ "
"Ï€ÎµÏÎ¹Ï„Ï…Î»Î¯Î³Î¼Î±Ï„Î¿Ï‚](https://doc.rust-lang.org/reference/special-types-and-traits."
"html) ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÏ„Î±Î¹ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎºÏ„ÏÎ½, ÏŒÏ€Ï‰Ï‚ \"Box\n"
"\n"
"\"."

#: src/methods/receiver.md:24
#, fuzzy
msgid ""
"Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
"These constraints always come together in Rust due to borrow checker rules, "
"and `self` is no exception. It isn't possible to reference a struct from "
"multiple locations and call a mutating (`&mut self`) method on it."
msgstr ""
"\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>\n"
"\n"
"Î•Î¾ÎµÏ„Î¬ÏƒÏ„Îµ Ï„Î¿ ÎµÎ½Î´ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ Î½Î± Î´ÏÏƒÎµÏ„Îµ Î­Î¼Ï†Î±ÏƒÎ· ÏƒÏ„Î¿ \"ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î¿ ÎºÎ±Î¹ Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î¿\" "
"ÎºÎ±Î¹ ÏƒÏ„Î¿ \"Î¼Î¿Î½Î±Î´Î¹ÎºÏŒ ÎºÎ±Î¹ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏŒ\". Î‘Ï…Ï„Î¿Î¯ Î¿Î¹ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿Î¯ Î­ÏÏ‡Î¿Î½Ï„Î±Î¹ Ï€Î¬Î½Ï„Î± Î¼Î±Î¶Î¯ "
"ÏƒÏ„Î¿ Rust Î»ÏŒÎ³Ï‰ Ï„Ï‰Î½ ÎºÎ±Î½ÏŒÎ½Ï‰Î½ Ï„Î¿Ï… ÎµÎ»ÎµÎ³ÎºÏ„Î® Î´Î±Î½ÎµÎ¯Î¿Ï…, ÎºÎ±Î¹ Ï„Î¿ \"self\" Î´ÎµÎ½ Î±Ï€Î¿Ï„ÎµÎ»ÎµÎ¯ "
"ÎµÎ¾Î±Î¯ÏÎµÏƒÎ·. Î”ÎµÎ½ Î¸Î± ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒÎ½ Î‘Î½Î±Ï†Î­ÏÎµÏ„Îµ Î¼Î¹Î± Î´Î¿Î¼Î® Î±Ï€ÏŒ Ï€Î¿Î»Î»Î­Ï‚ Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯ÎµÏ‚ ÎºÎ±Î¹ "
"ÎºÎ±Î»Î­ÏƒÏ„Îµ Î¼Î¹Î± Î¼Î­Î¸Î¿Î´Î¿ Î¼ÎµÏ„Î±Î»Î»Î¬Î¾ÎµÏ‰Ï‚ (`&mut self`) ÏƒÎµ Î±Ï…Ï„Î®Î½."

#: src/methods/example.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Race {\n"
"    name: String,\n"
"    laps: Vec<i32>,\n"
"}\n"
"\n"
"impl Race {\n"
"    fn new(name: &str) -> Race {  // No receiver, a static method\n"
"        Race { name: String::from(name), laps: Vec::new() }\n"
"    }\n"
"\n"
"    fn add_lap(&mut self, lap: i32) {  // Exclusive borrowed read-write "
"access to self\n"
"        self.laps.push(lap);\n"
"    }\n"
"\n"
"    fn print_laps(&self) {  // Shared and read-only borrowed access to self\n"
"        println!(\"Recorded {} laps for {}:\", self.laps.len(), self.name);\n"
"        for (idx, lap) in self.laps.iter().enumerate() {\n"
"            println!(\"Lap {idx}: {lap} sec\");\n"
"        }\n"
"    }\n"
"\n"
"    fn finish(self) {  // Exclusive ownership of self\n"
"        let total = self.laps.iter().sum::<i32>();\n"
"        println!(\"Race {} is finished, total lap time: {}\", self.name, "
"total);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut race = Race::new(\"Monaco Grand Prix\");\n"
"    race.add_lap(70);\n"
"    race.add_lap(68);\n"
"    race.print_laps();\n"
"    race.add_lap(71);\n"
"    race.print_laps();\n"
"    race.finish();\n"
"    // race.add_lap(42);\n"
"}\n"
"```"
msgstr ""

#: src/methods/example.md:47
#, fuzzy
msgid "All four methods here use a different method receiver."
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/methods/example.md:48
#, fuzzy
msgid ""
"You can point out how that changes what the function can do with the "
"variable values and if/how it can be used again in `main`."
msgstr "Î’Î±ÏƒÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±:"

#: src/methods/example.md:49
#, fuzzy
msgid ""
"You can showcase the error that appears when trying to call `finish` twice."
msgstr "ÎšÎ±Î¹ Î¿Î¹ Ï„Î­ÏƒÏƒÎµÏÎ¹Ï‚ Î¼Î­Î¸Î¿Î´Î¿Î¹ ÎµÎ´Ï Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏŒ Î´Î­ÎºÏ„Î· Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…."

#: src/methods/example.md:50
#, fuzzy
msgid ""
"Note that although the method receivers are different, the non-static "
"functions are called the same way in the main body. Rust enables automatic "
"referencing and dereferencing when calling methods. Rust automatically adds "
"in the `&`, `*`, `muts` so that that object matches the method signature."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Ï€ÏÏ‚ Î±Î»Î»Î¬Î¶ÎµÎ¹ Î±Ï…Ï„ÏŒ Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎºÎ¬Î½ÎµÎ¹ Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î¼Îµ "
"Ï„Î¹Ï‚ Ï„Î¹Î¼Î­Ï‚ Ï„Ï‰Î½ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ ÎºÎ±Î¹ ÎµÎ¬Î½/Ï€ÏÏ‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¾Î±Î½Î¬ ÏƒÏ„Î¿ "
"\"main\"."

#: src/methods/example.md:51
#, fuzzy
msgid ""
"You might point out that `print_laps` is using a vector that is iterated "
"over. We describe vectors in more detail in the afternoon. "
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹Î´ÎµÎ¯Î¾ÎµÏ„Îµ Ï„Î¿ ÏƒÏ†Î¬Î»Î¼Î± Ï€Î¿Ï… ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹ ÏŒÏ„Î±Î½ Ï€ÏÎ¿ÏƒÏ€Î±Î¸ÎµÎ¯Ï„Îµ Î½Î± "
"ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Ï„Î¿ \"finish\" Î´ÏÎ¿ Ï†Î¿ÏÎ­Ï‚.\n"
"\n"
"Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ ÏŒÏ„Î¹ Ï€Î±ÏÏŒÎ»Î¿ Ï€Î¿Ï… Î¿Î¹ Î´Î­ÎºÏ„ÎµÏ‚ Ï„Î·Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï… ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¿Î¯, Î¿Î¹ Î¼Î· "
"ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Î¿Î½Î¿Î¼Î¬Î¶Î¿Î½Ï„Î±Î¹ Î¼Îµ Ï„Î¿Î½ Î¯Î´Î¹Î¿ Ï„ÏÏŒÏ€Î¿ ÏƒÏ„Î¿ ÎºÏÏÎ¹Î¿ ÏƒÏÎ¼Î±. Î¤Î¿ Rust "
"ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Ï„Î·Î½ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î· Î±Î½Î±Ï†Î¿ÏÎ¬ ÎºÎ±Î¹ Î±Ï€Î¿Î±Î½Î±Ï†Î¿ÏÎ¬ ÎºÎ±Ï„Î¬ Ï„Î·Î½ ÎºÎ»Î®ÏƒÎ· Î¼ÎµÎ¸ÏŒÎ´Ï‰Î½. Î¤Î¿ "
"Rust Ï€ÏÎ¿ÏƒÎ¸Î­Ï„ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï„Î± \"&\", \"\\*\", \"muts\", Î­Ï„ÏƒÎ¹ ÏÏƒÏ„Îµ Î±Ï…Ï„ÏŒ Ï„Î¿ "
"Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î½Î± Ï„Î±Î¹ÏÎ¹Î¬Î¶ÎµÎ¹ Î¼Îµ Ï„Î·Î½ Ï…Ï€Î¿Î³ÏÎ±Ï†Î® Ï„Î·Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï….\n"
"\n"
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ ÏŒÏ„Î¹ Ï„Î¿ \"print_laps\" Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Î­Î½Î± Î´Î¹Î¬Î½Ï…ÏƒÎ¼Î± Ï€Î¿Ï… "
"ÎµÏ€Î±Î½Î±Î»Î±Î¼Î²Î¬Î½ÎµÏ„Î±Î¹. Î ÎµÏÎ¹Î³ÏÎ¬Ï†Î¿Ï…Î¼Îµ Î´Î¹Î±Î½ÏÏƒÎ¼Î±Ï„Î± Î¼Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ Ï„Î¿ "
"Î±Ï€ÏŒÎ³ÎµÏ…Î¼Î±."

#: src/exercises/day-2/afternoon.md:1
#, fuzzy
msgid "Day 2: Afternoon Exercises"
msgstr "Î—Î¼Î­ÏÎ± 2: Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-2/afternoon.md:3
#, fuzzy
msgid "The exercises for this afternoon will focus on strings and iterators."
msgstr ""
"ÎŸÎ¹ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ Î³Î¹Î± ÏƒÎ®Î¼ÎµÏÎ± Ï„Î¿ Î±Ï€ÏŒÎ³ÎµÏ…Î¼Î± Î¸Î± ÎµÏ€Î¹ÎºÎµÎ½Ï„ÏÏ‰Î¸Î¿ÏÎ½ ÏƒÎµ Î­Î³Ï‡Î¿ÏÎ´Î± ÎºÎ±Î¹ "
"ÎµÏ€Î±Î½Î±Î»Î®Ï€Ï„ÎµÏ‚."

#: src/exercises/day-2/health-statistics.md:3
#, fuzzy
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"Î•ÏÎ³Î¬Î¶ÎµÏƒÏ„Îµ Î³Î¹Î± Ï„Î·Î½ ÎµÏ†Î±ÏÎ¼Î¿Î³Î® ÎµÎ½ÏŒÏ‚ ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î·ÏƒÎ·Ï‚ Ï„Î·Ï‚ Ï…Î³ÎµÎ¯Î±Ï‚. Î©Ï‚ "
"Î¼Î­ÏÎ¿Ï‚ Î±Ï…Ï„Î¿Ï, ÎµÏƒÎµÎ¯Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Ï„Î± ÏƒÏ„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± Ï…Î³ÎµÎ¯Î±Ï‚ Ï„Ï‰Î½ "
"Ï‡ÏÎ·ÏƒÏ„ÏÎ½."

#: src/exercises/day-2/health-statistics.md:6
#, fuzzy
msgid ""
"You'll start with some stubbed functions in an `impl` block as well as a "
"`User` struct definition. Your goal is to implement the stubbed out methods "
"on the `User` `struct` defined in the `impl` block."
msgstr ""
"Î˜Î± Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ Î¼Îµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î±Ï€Î¿ÎºÎ¿Î¼Î¼Î­Î½ÎµÏ‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ ÏƒÎµ Î­Î½Î± Î¼Ï€Î»Î¿Îº \"impl\" "
"ÎºÎ±Î¸ÏÏ‚ ÎºÎ±Î¹ ÏƒÎµ Î­Î½Î± \"User\". Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î®Ï‚. ÎŸ ÏƒÏ„ÏŒÏ‡Î¿Ï‚ ÏƒÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ Î½Î± "
"ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ Ï„Î¹Ï‚ Î±Ï€Î¿ÎºÎ¿Î¼Î¼Î­Î½ÎµÏ‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ ÏƒÏ„Î¿ Î— Î´Î¿Î¼Î® \"User\" Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Î¼Ï€Î»Î¿Îº "
"\"impl\"."

#: src/exercises/day-2/health-statistics.md:10
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"methods:"
msgstr ""
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ "
"ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î¿Î½ ÎºÏ‰Î´Î¹ÎºÏŒ Ï€Î¿Ï… Î»ÎµÎ¯Ï€ÎµÎ¹ Î¼Î­Î¸Î¿Î´Î¿Î¹:"

#: src/exercises/day-2/health-statistics.md:13
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct User {\n"
"    name: String,\n"
"    age: u32,\n"
"    height: f32,\n"
"    visit_count: usize,\n"
"    last_blood_pressure: Option<(u32, u32)>,\n"
"}\n"
"\n"
"pub struct Measurements {\n"
"    height: f32,\n"
"    blood_pressure: (u32, u32),\n"
"}\n"
"\n"
"pub struct HealthReport<'a> {\n"
"    patient_name: &'a str,\n"
"    visit_count: u32,\n"
"    height_change: f32,\n"
"    blood_pressure_change: Option<(i32, i32)>,\n"
"}\n"
"\n"
"impl User {\n"
"    pub fn new(name: String, age: u32, height: f32) -> Self {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn name(&self) -> &str {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn age(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn height(&self) -> f32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn doctor_visits(&self) -> u32 {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_age(&mut self, new_age: u32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn set_height(&mut self, new_height: f32) {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    pub fn visit_doctor(&mut self, measurements: Measurements) -> "
"HealthReport {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    println!(\"I'm {} and my age is {}\", bob.name(), bob.age());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_height() {\n"
"    let bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.height(), 155.2);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_set_age() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.age(), 32);\n"
"    bob.set_age(33);\n"
"    assert_eq!(bob.age(), 33);\n"
"}\n"
"\n"
"#[test]\n"
"fn test_visit() {\n"
"    let mut bob = User::new(String::from(\"Bob\"), 32, 155.2);\n"
"    assert_eq!(bob.doctor_visits(), 0);\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (120, 80),\n"
"    });\n"
"    assert_eq!(report.patient_name, \"Bob\");\n"
"    assert_eq!(report.visit_count, 1);\n"
"    assert_eq!(report.blood_pressure_change, None);\n"
"\n"
"    let report = bob.visit_doctor(Measurements {\n"
"        height: 156.1,\n"
"        blood_pressure: (115, 76),\n"
"    });\n"
"\n"
"    assert_eq!(report.visit_count, 2);\n"
"    assert_eq!(report.blood_pressure_change, Some((-5, -4)));\n"
"}\n"
"```"
msgstr ""

#: src/std.md:3
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust library and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Î¤Î¿ Rust ÏƒÏ…Î½Î¿Î´ÎµÏÎµÏ„Î±Î¹ Î±Ï€ÏŒ Î¼Î¹Î± Ï„Ï…Ï€Î¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Ï€Î¿Ï… Î²Î¿Î·Î¸Î¬ ÏƒÏ„Î· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎµÎ½ÏŒÏ‚ "
"ÏƒÏ…Î½ÏŒÎ»Î¿Ï… ÎºÎ¿Î¹Î½ÏÎ½ Ï„ÏÏ€Ï‰Î½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î· Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· ÎºÎ±Î¹ Ï„Î± Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î± "
"Ï„Î·Ï‚ Rust. ÎœÎµ Î±Ï…Ï„ÏŒÎ½ Ï„Î¿Î½ Ï„ÏÏŒÏ€Î¿, Î´ÏÎ¿ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± ÏƒÏ…Î½ÎµÏÎ³Î±ÏƒÏ„Î¿ÏÎ½ Î¿Î¼Î±Î»Î¬ "
"Î³Î¹Î±Ï„Î¯ ÎºÎ±Î¹ Î¿Î¹ Î´ÏÎ¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î¿Î½ Î¯Î´Î¹Î¿ Ï„ÏÏ€Î¿ Â«StringÂ»."

#: src/std.md:7
#, fuzzy
msgid "The common vocabulary types include:"
msgstr "ÎŸÎ¹ ÏƒÏ…Î½Î®Î¸ÎµÎ¹Ï‚ Ï„ÏÏ€Î¿Î¹ Î»ÎµÎ¾Î¹Î»Î¿Î³Î¯Î¿Ï… Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½Î¿Ï…Î½:"

#: src/std.md:9
msgid ""
"[`Option` and `Result`](std/option-result.md) types: used for optional "
"values and [error handling](error-handling.md)."
msgstr ""

#: src/std.md:12
msgid "[`String`](std/string.md): the default string type used for owned data."
msgstr ""

#: src/std.md:14
msgid "[`Vec`](std/vec.md): a standard extensible vector."
msgstr ""

#: src/std.md:16
msgid ""
"[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
"algorithm."
msgstr ""

#: src/std.md:19
msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
msgstr ""

#: src/std.md:21
msgid ""
"[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
"data."
msgstr ""

#: src/std.md:25
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`. "
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/std.md:26
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system. "
msgstr ""
"Î£Ï„Î·Î½ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒÏ„Î·Ï„Î±, Ï„Î¿ Rust Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Ï€Î¿Î»Î»Î¬ ÎµÏ€Î¯Ï€ÎµÎ´Î± Ï„Î·Ï‚ Ï„Ï…Ï€Î¹ÎºÎ®Ï‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚: "
"Â«coreÂ», Â«allocÂ» ÎºÎ±Î¹ Â«stdÂ»."

#: src/std.md:28
#, fuzzy
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr ""
"ÎŸ Â«Ï€Ï…ÏÎ®Î½Î±Ï‚Â» Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï„Î¿Ï…Ï‚ Ï€Î¹Î¿ Î²Î±ÏƒÎ¹ÎºÎ¿ÏÏ‚ Ï„ÏÏ€Î¿Ï…Ï‚ ÎºÎ±Î¹ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Ï€Î¿Ï… Î´ÎµÎ½ "
"ÎµÎ¾Î±ÏÏ„ÏÎ½Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿ Â«libcÂ», Ï„Î¿Î½ ÎµÎºÏ‡Ï‰ÏÎ·Ï„Î® Î® Î±ÎºÏŒÎ¼Î· ÎºÎ±Î¹ Î· Ï€Î±ÏÎ¿Ï…ÏƒÎ¯Î± ÎµÎ½ÏŒÏ‚ "
"Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ¿Ï ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚."

#: src/std.md:29
#, fuzzy
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr ""
"Î¤Î¿ \"alloc\" Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€Î¿Ï… Î±Ï€Î±Î¹Ï„Î¿ÏÎ½ ÎºÎ±Î¸Î¿Î»Î¹ÎºÏŒ ÎµÎºÏ‡Ï‰ÏÎ·Ï„Î® ÏƒÏ‰ÏÎ¿Ï, ÏŒÏ€Ï‰Ï‚ "
"\"Vec\", \"Box\" ÎºÎ±Î¹ \"Arc\".\n"
"\n"
"ÎŸÎ¹ ÎµÏ†Î±ÏÎ¼Î¿Î³Î­Ï‚ Embedded Rust Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ ÏƒÏ…Ï‡Î½Î¬ Î¼ÏŒÎ½Î¿ Â«coreÂ» ÎºÎ±Î¹ Î¼ÎµÏÎ¹ÎºÎ­Ï‚ Ï†Î¿ÏÎ­Ï‚ "
"Â«allocÂ»."

#: src/std/option-result.md:1
#, fuzzy
msgid "`Option` and `Result`"
msgstr "Â«Î•Ï€Î¹Î»Î¿Î³Î®Â» ÎºÎ±Î¹ Â«Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±Â»."

#: src/std/option-result.md:3
#, fuzzy
msgid "The types represent optional data:"
msgstr "ÎŸÎ¹ Ï„ÏÏ€Î¿Î¹ Î±Î½Ï„Î¹Ï€ÏÎ¿ÏƒÏ‰Ï€ÎµÏÎ¿Ï…Î½ Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ Î´ÎµÎ´Î¿Î¼Î­Î½Î±:"

#: src/std/option-result.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let numbers = vec![10, 20, 30];\n"
"    let first: Option<&i8> = numbers.first();\n"
"    println!(\"first: {first:?}\");\n"
"\n"
"    let idx: Result<usize, usize> = numbers.binary_search(&10);\n"
"    println!(\"idx: {idx:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/option-result.md:18
#, fuzzy
msgid "`Option` and `Result` are widely used not just in the standard library."
msgstr ""
"Î— ÎµÏ€Î¹Î»Î¿Î³Î® Â«Î•Ï€Î¹Î»Î¿Î³Î®Â» ÎºÎ±Î¹ Â«Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±Â» Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ ÎµÏ…ÏÎ­Ï‰Ï‚ ÏŒÏ‡Î¹ Î¼ÏŒÎ½Î¿ ÏƒÏ„Î·Î½ "
"Ï„Ï…Ï€Î¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·."

#: src/std/option-result.md:19
#, fuzzy
msgid "`Option<&T>` has zero space overhead compared to `&T`."
msgstr "Î¤Î¿ \"Option\\<&T>\" Î­Ï‡ÎµÎ¹ Î¼Î·Î´ÎµÎ½Î¹ÎºÏŒ Ï‡ÏÏÎ¿ ÏƒÎµ ÏƒÏÎ³ÎºÏÎ¹ÏƒÎ· Î¼Îµ Ï„Î¿ \"&T\"."

#: src/std/option-result.md:20
#, fuzzy
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr ""
"Î¤Î¿ \"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\" ÎµÎ¯Î½Î±Î¹ Î¿ Ï„Ï…Ï€Î¹ÎºÏŒÏ‚ Ï„ÏÏ€Î¿Ï‚ Î³Î¹Î± Ï„Î·Î½ Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… Ï‡ÎµÎ¹ÏÎ¹ÏƒÎ¼Î¿Ï "
"ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½, ÏŒÏ€Ï‰Ï‚ Î¸Î± Î´Î¿ÏÎ¼Îµ Ï„Î·Î½ Î—Î¼Î­ÏÎ± 3."

#: src/std/option-result.md:21
#, fuzzy
msgid "`binary_search` returns `Result<usize, usize>`."
msgstr "Î— \"Î´Ï…Î±Î´Î¹ÎºÎ®_Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·\" ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ \"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\\<Ï‡ÏÎ®ÏƒÎ·, Ï‡ÏÎ®ÏƒÎ·>\"."

#: src/std/option-result.md:22
#, fuzzy
msgid "If found, `Result::Ok` holds the index where the element is found."
msgstr ""
"Î•Î¬Î½ Î²ÏÎµÎ¸ÎµÎ¯, Ï„Î¿ Â«Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±::ÎŸÎºÂ» Î´Î¹Î±Ï„Î·ÏÎµÎ¯ Ï„Î¿ ÎµÏ…ÏÎµÏ„Î®ÏÎ¹Î¿ ÏŒÏ€Î¿Ï… Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Ï„Î¿ "
"ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î¿."

#: src/std/option-result.md:23
#, fuzzy
msgid ""
"Otherwise, `Result::Err` contains the index where such an element should be "
"inserted."
msgstr ""
"Î”Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬, Ï„Î¿ \"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±::Î£Ï†Î¬Î»Î¼Î±\" Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Ï„Î¿ ÎµÏ…ÏÎµÏ„Î®ÏÎ¹Î¿ ÏŒÏ€Î¿Ï… Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ "
"Î½Î± ÎµÎ¹ÏƒÎ±Ï‡Î¸ÎµÎ¯ Î­Î½Î± Ï„Î­Ï„Î¿Î¹Î¿ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î¿."

#: src/std/string.md:3
#, fuzzy
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"Î¤Î¿ [`String`](https://doc.rust-lang.org/std/string/struct.String.html) ÎµÎ¯Î½Î±Î¹ "
"Ï„Î¿ Ï„Ï…Ï€Î¹ÎºÏŒ buffer ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÏÎ½ UTF-8 Ï€Î¿Ï… ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Î±Î¹ ÏƒÎµ ÏƒÏ‰ÏÏŒ:"

#: src/std/string.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut s1 = String::new();\n"
"    s1.push_str(\"Hello\");\n"
"    println!(\"s1: len = {}, capacity = {}\", s1.len(), s1.capacity());\n"
"\n"
"    let mut s2 = String::with_capacity(s1.len() + 1);\n"
"    s2.push_str(&s1);\n"
"    s2.push('!');\n"
"    println!(\"s2: len = {}, capacity = {}\", s2.len(), s2.capacity());\n"
"\n"
"    let s3 = String::from(\"ğŸ‡¨ğŸ‡­\");\n"
"    println!(\"s3: len = {}, number of chars = {}\", s3.len(),\n"
"             s3.chars().count());\n"
"}\n"
"```"
msgstr ""

#: src/std/string.md:22
#, fuzzy
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"Î¤Î¿ `String` Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), Ï€Î¿Ï… ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ ÏŒÎ»Î± ÎœÎ­Î¸Î¿Î´Î¿Î¹ `str` ÏƒÎµ Î¼Î¹Î± ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬."

#: src/std/string.md:30
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""

#: src/std/string.md:31
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""

#: src/std/string.md:32
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""

#: src/std/string.md:33
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr ""

#: src/std/string.md:34
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""

#: src/std/string.md:35
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""

#: src/std/string.md:36
msgid "Write and compare `let s3 = s1.deref();` and  `let s3 = &*s1`;."
msgstr ""

#: src/std/string.md:37
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""

#: src/std/string.md:38
msgid "Compare the different ways to index a `String`:"
msgstr ""

#: src/std/string.md:39
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr ""

#: src/std/string.md:40
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""

#: src/std/vec.md:1
#, fuzzy
msgid "`Vec`"
msgstr "Â«VecÂ»."

#: src/std/vec.md:3
#, fuzzy
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"Î¤Î¿ [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) ÎµÎ¯Î½Î±Î¹ Ï„Î¿ "
"Ï„Ï…Ï€Î¹ÎºÏŒ buffer Î¼Îµ Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„Î± Î±Î»Î»Î±Î³Î®Ï‚ Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚ Ï€Î¿Ï… ÎµÎºÏ‡Ï‰ÏÎµÎ¯Ï„Î±Î¹ ÏƒÎµ ÏƒÏ‰ÏÏŒ:"

#: src/std/vec.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut v1 = Vec::new();\n"
"    v1.push(42);\n"
"    println!(\"v1: len = {}, capacity = {}\", v1.len(), v1.capacity());\n"
"\n"
"    let mut v2 = Vec::with_capacity(v1.len() + 1);\n"
"    v2.extend(v1.iter());\n"
"    v2.push(9999);\n"
"    println!(\"v2: len = {}, capacity = {}\", v2.len(), v2.capacity());\n"
"\n"
"    // Canonical macro to initialize a vector with elements.\n"
"    let mut v3 = vec![0, 0, 1, 2, 3, 4];\n"
"\n"
"    // Retain only the even elements.\n"
"    v3.retain(|x| x % 2 == 0);\n"
"    println!(\"{v3:?}\");\n"
"\n"
"    // Remove consecutive duplicates.\n"
"    v3.dedup();\n"
"    println!(\"{v3:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/vec.md:29
#, fuzzy
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"Î¤Î¿ `Vec` Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/"
"vec/struct.Vec.html#deref-methods-%5BT%5D), Ï€Î¿Ï… ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Ï„Î¿ slice Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ ÏƒÎµ Î­Î½Î± Â«VecÂ»."

#: src/std/vec.md:37
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be  known at compile time. It can grow or shrink at runtime."
msgstr ""

#: src/std/vec.md:40
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""

#: src/std/vec.md:42
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""

#: src/std/vec.md:44
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""

#: src/std/vec.md:46
msgid ""
"Show iterating over a vector and mutating the value: `for e in &mut v { *e "
"+= 50; }`"
msgstr ""

#: src/std/hashmap.md:1 src/bare-metal/no_std.md:46
#, fuzzy
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/std/hashmap.md:3
#, fuzzy
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "Î¤Ï…Ï€Î¹ÎºÏŒÏ‚ Ï‡Î¬ÏÏ„Î·Ï‚ ÎºÎ±Ï„Î±ÎºÎµÏÎ¼Î±Ï„Î¹ÏƒÎ¼Î¿Ï Î¼Îµ Ï€ÏÎ¿ÏƒÏ„Î±ÏƒÎ¯Î± Î±Ï€ÏŒ ÎµÏ€Î¹Î¸Î­ÏƒÎµÎ¹Ï‚ HashDoS:"

#: src/std/hashmap.md:5
msgid ""
"```rust,editable\n"
"use std::collections::HashMap;\n"
"\n"
"fn main() {\n"
"    let mut page_counts = HashMap::new();\n"
"    page_counts.insert(\"Adventures of Huckleberry Finn\".to_string(), "
"207);\n"
"    page_counts.insert(\"Grimms' Fairy Tales\".to_string(), 751);\n"
"    page_counts.insert(\"Pride and Prejudice\".to_string(), 303);\n"
"\n"
"    if !page_counts.contains_key(\"Les MisÃ©rables\") {\n"
"        println!(\"We know about {} books, but not Les MisÃ©rables.\",\n"
"                 page_counts.len());\n"
"    }\n"
"\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        match page_counts.get(book) {\n"
"            Some(count) => println!(\"{book}: {count} pages\"),\n"
"            None => println!(\"{book} is unknown.\")\n"
"        }\n"
"    }\n"
"\n"
"    // Use the .entry() method to insert a value if nothing is found.\n"
"    for book in [\"Pride and Prejudice\", \"Alice's Adventure in "
"Wonderland\"] {\n"
"        let page_count: &mut i32 = page_counts.entry(book.to_string())."
"or_insert(0);\n"
"        *page_count += 1;\n"
"    }\n"
"\n"
"    println!(\"{page_counts:#?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/hashmap.md:38
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr ""

#: src/std/hashmap.md:39
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""

#: src/std/hashmap.md:41
msgid ""
"```rust,ignore\n"
"  let pc1 = page_counts\n"
"      .get(\"Harry Potter and the Sorcerer's Stone \")\n"
"      .unwrap_or(&336);\n"
"  let pc2 = page_counts\n"
"      .entry(\"The Hunger Games\".to_string())\n"
"      .or_insert(374);\n"
"```"
msgstr ""

#: src/std/hashmap.md:49
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr ""

#: src/std/hashmap.md:50
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""

#: src/std/hashmap.md:52
msgid ""
"```rust,ignore\n"
"  let page_counts = HashMap::from([\n"
"    (\"Harry Potter and the Sorcerer's Stone\".to_string(), 336),\n"
"    (\"The Hunger Games\".to_string(), 374),\n"
"  ]);\n"
"```"
msgstr ""

#: src/std/hashmap.md:59
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr ""

#: src/std/hashmap.md:60
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""

#: src/std/hashmap.md:62
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""

#: src/std/hashmap.md:64
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""

#: src/std/box.md:1
#, fuzzy
msgid "`Box`"
msgstr "Â«ÎšÎ¿Ï…Ï„Î¯Â»."

#: src/std/box.md:3
#, fuzzy
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"Î¤Î¿ [`Î Î»Î±Î¯ÏƒÎ¹Î¿`](https://doc.rust-lang.org/std/boxed/struct.Box.html) ÎµÎ¯Î½Î±Î¹ "
"Î­Î½Î±Ï‚ Î¹Î´Î¹ÏŒÎºÏ„Î·Ï„Î¿Ï‚ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ ÏƒÎµ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ„Î¿ ÏƒÏ‰ÏÏŒ:"

#: src/std/box.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let five = Box::new(5);\n"
"    println!(\"five: {}\", *five);\n"
"}\n"
"```"
msgstr ""

#: src/std/box.md:13
msgid ""
"```bob\n"
" Stack                     Heap\n"
".- - - - - - -.     .- - - - - - -.\n"
":             :     :             :\n"
":    five     :     :             :\n"
":   +-----+   :     :   +-----+   :\n"
":   | o---|---+-----+-->|  5  |   :\n"
":   +-----+   :     :   +-----+   :\n"
":             :     :             :\n"
":             :     :             :\n"
"`- - - - - - -'     `- - - - - - -'\n"
"```"
msgstr ""

#: src/std/box.md:26
#, fuzzy
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"Î¤Î¿ \"Box\n"
"\n"
"\" Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ \"Deref\\<Target = T>\", Ï€Î¿Ï… ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ [Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ "
"ÎºÎ»Î®ÏƒÎ·Ï‚ Î±Ï€ÏŒ Ï„Î¿ \"T\" Î±Ï€ÎµÏ…Î¸ÎµÎ¯Î±Ï‚ ÏƒÎµ Î­Î½Î± \"Box\n"
"\n"
"\"](https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-"
"coercion)."

#: src/std/box.md:34
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null. "
msgstr ""

#: src/std/box.md:35
msgid ""
"In the above example, you can even leave out the `*` in the `println!` "
"statement thanks to `Deref`. "
msgstr ""

#: src/std/box.md:36
msgid "A `Box` can be useful when you:"
msgstr ""

#: src/std/box.md:37
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr ""

#: src/std/box.md:38
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""

#: src/std/box-recursive.md:1
#, fuzzy
msgid "Box with Recursive Data Structures"
msgstr "Î Î»Î±Î¯ÏƒÎ¹Î¿ Î¼Îµ Î±Î½Î±Î´ÏÎ¿Î¼Î¹ÎºÎ­Ï‚ Î´Î¿Î¼Î­Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½"

#: src/std/box-recursive.md:3
#, fuzzy
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr ""
"ÎŸÎ¹ Î±Î½Î±Î´ÏÎ¿Î¼Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î® Î¿Î¹ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î¼Îµ Î´Ï…Î½Î±Î¼Î¹ÎºÎ¬ Î¼ÎµÎ³Î­Î¸Î· "
"Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½ Î­Î½Î± Â«Î Î»Î±Î¯ÏƒÎ¹Î¿Â»:"

#: src/std/box-recursive.md:5 src/std/box-niche.md:3
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
"\n"
"fn main() {\n"
"    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::"
"new(List::Nil))));\n"
"    println!(\"{list:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/box-recursive.md:18
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""

#: src/std/box-recursive.md:33
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not compute a fixed size of the struct in memory "
"(`List` would be of infinite size)."
msgstr ""

#: src/std/box-recursive.md:36
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""

#: src/std/box-recursive.md:39
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""

#: src/std/box-niche.md:16
#, fuzzy
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"ÎˆÎ½Î± Â«Î Î»Î±Î¯ÏƒÎ¹Î¿Â» Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ ÎºÎµÎ½ÏŒ, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Î¿ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ ÎµÎ¯Î½Î±Î¹ Ï€Î¬Î½Ï„Î± "
"Î­Î³ÎºÏ…ÏÎ¿Ï‚ ÎºÎ±Î¹ Î¼Î· Â«Î¼Î·Î´ÎµÎ½Î¹ÎºÏŒÏ‚Â». Î‘Ï…Ï„ÏŒ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ ÏƒÏ„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Î½Î± "
"Î²ÎµÎ»Ï„Î¹ÏƒÏ„Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹ Ï„Î· Î´Î¹Î¬Ï„Î±Î¾Î· Ï„Î·Ï‚ Î¼Î½Î®Î¼Î·Ï‚:"

#: src/std/box-niche.md:19
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""

#: src/std/rc.md:1
#, fuzzy
msgid "`Rc`"
msgstr "Â«RcÂ»."

#: src/std/rc.md:3
#, fuzzy
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"Î¤Î¿ [`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ "
"ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î¿Ï‚ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Î¼Îµ Î¼Î­Ï„ÏÎ·ÏƒÎ· Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚. Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î¿ ÏŒÏ„Î±Î½ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"Î±Î½Î±Ï„ÏÎ­Î¾ÎµÏ„Îµ ÏƒÏ„Î± Î¯Î´Î¹Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î±Ï€ÏŒ Ï€Î¿Î»Î»Î¬ Î¼Î­ÏÎ·:"

#: src/std/rc.md:6
msgid ""
"```rust,editable\n"
"use std::rc::Rc;\n"
"\n"
"fn main() {\n"
"    let mut a = Rc::new(10);\n"
"    let mut b = Rc::clone(&a);\n"
"\n"
"    println!(\"a: {a}\");\n"
"    println!(\"b: {b}\");\n"
"}\n"
"```"
msgstr ""

#: src/std/rc.md:18
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""

#: src/std/rc.md:19
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""

#: src/std/rc.md:29
#, fuzzy
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr "ÎŒÏ€Ï‰Ï‚ Ï„Î¿ `std::shared_ptr` Ï„Î·Ï‚ C++."

#: src/std/rc.md:30
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr ""

#: src/std/rc.md:31
#, fuzzy
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"Î¤Î¿ `make_mut` ÏƒÏ„Î·Î½ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒÏ„Î·Ï„Î± ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î·Î½ ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÎ® Ï„Î¹Î¼Î® ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ "
"Î±Ï€Î±ÏÎ±Î¯Ï„Î·Ï„Î¿ (\"clone-on-write\") ÎºÎ±Î¹ ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î¼Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î±Î½Î±Ï†Î¿ÏÎ¬."

#: src/std/rc.md:32
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""

#: src/std/rc.md:33
msgid "Use `Rc::strong_count` to check the reference count."
msgstr ""

#: src/std/rc.md:34
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`, "
"on the next slide)."
msgstr ""

#: src/std/cell.md:1
msgid "`Cell` and `RefCell`"
msgstr ""

#: src/std/cell.md:3
#, fuzzy
msgid ""
"[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) and [`RefCell`]"
"(https://doc.rust-lang.org/std/cell/struct.RefCell.html) implement what Rust "
"calls _interior mutability:_ mutation of values in an immutable context."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿ \"Read\" ÎºÎ±Î¹ Ï„Î¿ \"BufRead\", Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î±Ï†Î±Î¹ÏÎ­ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ "
"Ï€Î·Î³Î­Ï‚ \"u8\":"

#: src/std/cell.md:8
msgid ""
"`Cell` is typically used for simple types, as it requires copying or moving "
"values. More complex interior types typically use `RefCell`, which tracks "
"shared and exclusive references at runtime and panics if they are misused."
msgstr ""

#: src/std/cell.md:12
msgid ""
"```rust,editable\n"
"use std::cell::RefCell;\n"
"use std::rc::Rc;\n"
"\n"
"#[derive(Debug, Default)]\n"
"struct Node {\n"
"    value: i64,\n"
"    children: Vec<Rc<RefCell<Node>>>,\n"
"}\n"
"\n"
"impl Node {\n"
"    fn new(value: i64) -> Rc<RefCell<Node>> {\n"
"        Rc::new(RefCell::new(Node { value, ..Node::default() }))\n"
"    }\n"
"\n"
"    fn sum(&self) -> i64 {\n"
"        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::"
"<i64>()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let root = Node::new(1);\n"
"    root.borrow_mut().children.push(Node::new(5));\n"
"    let subtree = Node::new(10);\n"
"    subtree.borrow_mut().children.push(Node::new(11));\n"
"    subtree.borrow_mut().children.push(Node::new(12));\n"
"    root.borrow_mut().children.push(subtree);\n"
"\n"
"    println!(\"graph: {root:#?}\");\n"
"    println!(\"graph sum: {}\", root.borrow().sum());\n"
"}\n"
"```"
msgstr ""

#: src/std/cell.md:47
msgid ""
"If we were using `Cell` instead of `RefCell` in this example, we would have "
"to move the `Node` out of the `Rc` to push children, then move it back in. "
"This is safe because there's always one, un-referenced value in the cell, "
"but it's not ergonomic."
msgstr ""

#: src/std/cell.md:48
msgid ""
"To do anything with a Node, you must call a `RefCell` method, usually "
"`borrow` or `borrow_mut`."
msgstr ""

#: src/std/cell.md:49
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children` (don't try to print it!)."
msgstr ""

#: src/std/cell.md:50
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""

#: src/modules.md:3
#, fuzzy
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr ""
"Î•Î¯Î´Î±Î¼Îµ Ï€ÏÏ‚ Ï„Î± Î¼Ï€Î»Î¿Îº Â«implÂ» Î¼Î±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î½ Î½Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Î¿ Ï‡ÏÏÎ¿Ï‚ Î¿Î½Î¿Î¼Î¬Ï„Ï‰Î½ ÏƒÎµ "
"Î­Î½Î±Î½ Ï„ÏÏ€Î¿."

#: src/modules.md:5
#, fuzzy
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "ÎŸÎ¼Î¿Î¯Ï‰Ï‚, Ï„Î¿ Â«modÂ» Î¼Î±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Ï„ÏÏ€Î¿Ï…Ï‚ ÎºÎ±Î¹ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Î¿Î½Î¿Î¼Î¬Ï„Ï‰Î½:"

#: src/modules.md:7
msgid ""
"```rust,editable\n"
"mod foo {\n"
"    pub fn do_something() {\n"
"        println!(\"In the foo module\");\n"
"    }\n"
"}\n"
"\n"
"mod bar {\n"
"    pub fn do_something() {\n"
"        println!(\"In the bar module\");\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    foo::do_something();\n"
"    bar::do_something();\n"
"}\n"
"```"
msgstr ""

#: src/modules.md:28
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""

#: src/modules.md:29
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""

#: src/modules.md:30
msgid "Modules define organization, scope, and are the focus of this section."
msgstr ""

#: src/modules/visibility.md:3
#, fuzzy
msgid "Modules are a privacy boundary:"
msgstr "ÎŸÎ¹ ÎµÎ½ÏŒÏ„Î·Ï„ÎµÏ‚ Î±Ï€Î¿Ï„ÎµÎ»Î¿ÏÎ½ ÏŒÏÎ¹Î¿ Î±Ï€Î¿ÏÏÎ®Ï„Î¿Ï…:"

#: src/modules/visibility.md:5
#, fuzzy
msgid "Module items are private by default (hides implementation details)."
msgstr ""
"Î¤Î± ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± Ï„Î·Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚ ÎµÎ¯Î½Î±Î¹ Î¹Î´Î¹Ï‰Ï„Î¹ÎºÎ¬ Î±Ï€ÏŒ Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î® (Î±Ï€Î¿ÎºÏÏÏ€Ï„ÎµÎ¹ Ï„Î¹Ï‚ "
"Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚)."

#: src/modules/visibility.md:6
#, fuzzy
msgid "Parent and sibling items are always visible."
msgstr "Î¤Î± ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± Î³Î¿Î½Î­Î± ÎºÎ±Î¹ Î±Î´ÎµÎ»Ï†ÏÎ½ ÎµÎ¯Î½Î±Î¹ Ï€Î¬Î½Ï„Î± Î¿ÏÎ±Ï„Î¬."

#: src/modules/visibility.md:7
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""

#: src/modules/visibility.md:10
msgid ""
"```rust,editable\n"
"mod outer {\n"
"    fn private() {\n"
"        println!(\"outer::private\");\n"
"    }\n"
"\n"
"    pub fn public() {\n"
"        println!(\"outer::public\");\n"
"    }\n"
"\n"
"    mod inner {\n"
"        fn private() {\n"
"            println!(\"outer::inner::private\");\n"
"        }\n"
"\n"
"        pub fn public() {\n"
"            println!(\"outer::inner::public\");\n"
"            super::private();\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    outer::public();\n"
"}\n"
"```"
msgstr ""

#: src/modules/visibility.md:39
msgid "Use the `pub` keyword to make modules public."
msgstr ""

#: src/modules/visibility.md:41
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr ""

#: src/modules/visibility.md:43
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""

#: src/modules/visibility.md:44
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr ""

#: src/modules/visibility.md:45
msgid "Less commonly, you can give visibility to a specific path."
msgstr ""

#: src/modules/visibility.md:46
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr ""

#: src/modules/paths.md:3
#, fuzzy
msgid "Paths are resolved as follows:"
msgstr "ÎŸÎ¹ Î´Î¹Î±Î´ÏÎ¿Î¼Î­Ï‚ ÎµÏ€Î¹Î»ÏÎ¿Î½Ï„Î±Î¹ Ï‰Ï‚ ÎµÎ¾Î®Ï‚:"

#: src/modules/paths.md:5
#, fuzzy
msgid "As a relative path:"
msgstr "Î©Ï‚ Î±Ï€ÏŒÎ»Ï…Ï„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î®:"

#: src/modules/paths.md:6
#, fuzzy
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr ""
"Î¤Î¿ \"crate::foo\" Î±Î½Î±Ï†Î­ÏÎµÏ„Î±Î¹ ÏƒÏ„Î¿ \"foo\" ÏƒÏ„Î· ÏÎ¯Î¶Î± Ï„Î¿Ï… Ï„ÏÎ­Ï‡Î¿Î½Ï„Î¿Ï‚ ÎºÎ¹Î²Ï‰Ï„Î¯Î¿Ï…,"

#: src/modules/paths.md:7
#, fuzzy
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "Î¤Î¿ Â«bar::fooÂ» Î±Î½Î±Ï†Î­ÏÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Â«fooÂ» ÏƒÏ„Î¿ ÎºÎ¹Î²ÏÏ„Î¹Î¿ Â«barÂ»."

#: src/modules/paths.md:9
msgid "As an absolute path:"
msgstr ""

#: src/modules/paths.md:10
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr ""

#: src/modules/paths.md:11
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr ""

#: src/modules/paths.md:13
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""

#: src/modules/paths.md:16
msgid ""
"```rust,editable\n"
"use std::collections::HashSet;\n"
"use std::mem::transmute;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:3
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr ""

#: src/modules/filesystem.md:5
msgid ""
"```rust,editable,compile_fail\n"
"mod garden;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:9
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""

#: src/modules/filesystem.md:12
#, fuzzy
msgid "The `crate` root is in:"
msgstr "Î— ÏÎ¯Î¶Î± Â«ÎºÎ»Î¿Ï…Î²Î¯Â» Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ ÏƒÎµ:"

#: src/modules/filesystem.md:14
#, fuzzy
msgid "`src/lib.rs` (for a library crate)"
msgstr "`src/lib.rs` (Î³Î¹Î± ÎºÎ»Î¿Ï…Î²Î¯ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚)"

#: src/modules/filesystem.md:15
#, fuzzy
msgid "`src/main.rs` (for a binary crate)"
msgstr "`src/main.rs` (Î³Î¹Î± Î´Ï…Î±Î´Î¹ÎºÏŒ ÎºÎ¹Î²ÏÏ„Î¹Î¿)"

#: src/modules/filesystem.md:17
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""

#: src/modules/filesystem.md:20
msgid ""
"```rust,editable,compile_fail\n"
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
"\n"
"// Re-export types from this module.\n"
"pub use seeds::SeedPacket;\n"
"pub use garden::Garden;\n"
"\n"
"/// Sow the given seed packets.\n"
"pub fn sow(seeds: Vec<SeedPacket>) { todo!() }\n"
"\n"
"/// Harvest the produce in the garden that is ready.\n"
"pub fn harvest(garden: &mut Garden) { todo!() }\n"
"```"
msgstr ""

#: src/modules/filesystem.md:37
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""

#: src/modules/filesystem.md:39
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""

#: src/modules/filesystem.md:42
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr ""

#: src/modules/filesystem.md:44
msgid ""
"```ignore\n"
"src/\n"
"â”œâ”€â”€ main.rs\n"
"â”œâ”€â”€ top_module.rs\n"
"â””â”€â”€ top_module/\n"
"    â””â”€â”€ sub_module.rs\n"
"```"
msgstr ""

#: src/modules/filesystem.md:52
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr ""

#: src/modules/filesystem.md:54
msgid ""
"```rust,ignore\n"
"#[path = \"some/path.rs\"]\n"
"mod some_module;\n"
"```"
msgstr ""

#: src/modules/filesystem.md:59
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""

#: src/exercises/day-2/strings-iterators.md:3
#, fuzzy
msgid ""
"In this exercise, you are implementing a routing component of a web server. "
"The server is configured with a number of _path prefixes_ which are matched "
"against _request paths_. The path prefixes can contain a wildcard character "
"which matches a full segment. See the unit tests below."
msgstr ""
"Î£Îµ Î±Ï…Ï„Î®Î½ Ï„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·, Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Î­Î½Î± ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î¿ Î´ÏÎ¿Î¼Î¿Î»ÏŒÎ³Î·ÏƒÎ·Ï‚ ÎµÎ½ÏŒÏ‚ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î® "
"web. Î¿ ÎŸ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î®Ï‚ Î­Ï‡ÎµÎ¹ ÏÏ…Î¸Î¼Î¹ÏƒÏ„ÎµÎ¯ Î¼Îµ Î­Î½Î±Î½ Î±ÏÎ¹Î¸Î¼ÏŒ Ï€ÏÎ¿Î¸ÎµÎ¼Î¬Ï„Ï‰Î½ _Î´Î¹Î±Î´ÏÎ¿Î¼ÏÎ½_ Î¼Îµ "
"Ï„Î± Î¿Ï€Î¿Î¯Î± Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯Î¶Î¿Î½Ï„Î±Î¹ _Î±Î¯Ï„Î·Î¼Î± Î¼Î¿Î½Î¿Ï€Î±Ï„Î¹ÏÎ½_. Î¤Î± Ï€ÏÎ¿Î¸Î­Î¼Î±Ï„Î± Î´Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ "
"Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Ï€ÎµÏÎ¹Î­Ï‡Î¿Ï…Î½ Î­Î½Î±Î½ Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎ± Î¼Ï€Î±Î»Î±Î½Ï„Î­Ï Ï€Î¿Ï… Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯ ÏƒÎµ Î­Î½Î± Ï€Î»Î®ÏÎµÏ‚ "
"Ï„Î¼Î®Î¼Î±. Î”ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰."

#: src/exercises/day-2/strings-iterators.md:8
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Try avoiding allocating a `Vec` for your intermediate results:"
msgstr ""
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ ÎºÎ¬Î½Ï„Îµ "
"Ï„Î¹Ï‚ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Ï€Î­ÏÎ±ÏƒÎ¼Î±. Î ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÏ„Îµ Î½Î± Î±Ï€Î¿Ï†ÏÎ³ÎµÏ„Îµ Î½Î± ÎµÎºÏ‡Ï‰ÏÎ®ÏƒÎµÏ„Îµ Î­Î½Î± Â«VecÂ» Î³Î¹Î± Ï„Î± "
"ÎµÎ½Î´Î¹Î¬Î¼ÎµÏƒÎ± Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î¬ ÏƒÎ±Ï‚:"

#: src/exercises/day-2/strings-iterators.md:12
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    unimplemented!()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/welcome-day-3.md:1
#, fuzzy
msgid "Welcome to Day 3"
msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Î—Î¼Î­ÏÎ± 3"

#: src/welcome-day-3.md:3
#, fuzzy
msgid "Today, we will cover some more advanced topics of Rust:"
msgstr "Î£Î®Î¼ÎµÏÎ±, Î¸Î± ÎºÎ±Î»ÏÏˆÎ¿Ï…Î¼Îµ Î¼ÎµÏÎ¹ÎºÎ¬ Ï€Î¹Î¿ Ï€ÏÎ¿Ï‡Ï‰ÏÎ·Î¼Î­Î½Î± Î¸Î­Î¼Î±Ï„Î± Ï„Î¿Ï… Rust:"

#: src/welcome-day-3.md:5
msgid ""
"Traits: deriving traits, default methods, and important standard library "
"traits."
msgstr ""

#: src/welcome-day-3.md:8
msgid ""
"Generics: generic data types, generic methods, monomorphization, and trait "
"objects."
msgstr ""

#: src/welcome-day-3.md:11
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr ""

#: src/welcome-day-3.md:13
msgid "Testing: unit tests, documentation tests, and integration tests."
msgstr ""

#: src/welcome-day-3.md:15
msgid ""
"Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
"functions."
msgstr ""

#: src/generics.md:3
#, fuzzy
msgid ""
"Rust support generics, which lets you abstract algorithms or data structures "
"(such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Î“ÎµÎ½Î¹ÎºÎ¬ Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚, Ï€Î¿Ï… ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± Î±Ï†Î±Î¹ÏÎ­ÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î±Î»Î³ÏŒÏÎ¹Î¸Î¼Î¿ "
"(ÏŒÏ€Ï‰Ï‚ Ï„Î±Î¾Î¹Î½ÏŒÎ¼Î·ÏƒÎ·) Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ ÏƒÏ„Î¿Î½ Î±Î»Î³ÏŒÏÎ¹Î¸Î¼Î¿."

#: src/generics/data-types.md:3
#, fuzzy
msgid "You can use generics to abstract over the concrete field type:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î³ÎµÎ½Î¹ÎºÎ¬ Î³Î¹Î± Î½Î± Î±Ï†Î±Î¹ÏÎ­ÏƒÎµÏ„Îµ Ï„Î¿Î½ ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿ Ï„ÏÏ€Î¿ "
"Ï€ÎµÎ´Î¯Î¿Ï…:"

#: src/generics/data-types.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T> {\n"
"    x: T,\n"
"    y: T,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Point { x: 5, y: 10 };\n"
"    let float = Point { x: 1.0, y: 4.0 };\n"
"    println!(\"{integer:?} and {float:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/generics/data-types.md:21
msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
msgstr ""

#: src/generics/data-types.md:23
msgid "Fix the code to allow points that have elements of different types."
msgstr ""

#: src/generics/methods.md:3
#, fuzzy
msgid "You can declare a generic type on your `impl` block:"
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î»ÏÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î³ÎµÎ½Î¹ÎºÏŒ Ï„ÏÏ€Î¿ ÏƒÏ„Î¿ Î¼Ï€Î»Î¿Îº `impl`:"

#: src/generics/methods.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug)]\n"
"struct Point<T>(T, T);\n"
"\n"
"impl<T> Point<T> {\n"
"    fn x(&self) -> &T {\n"
"        &self.0  // + 10\n"
"    }\n"
"\n"
"    // fn set_x(&mut self, x: T)\n"
"}\n"
"\n"
"fn main() {\n"
"    let p = Point(5, 10);\n"
"    println!(\"p.x = {}\", p.x());\n"
"}\n"
"```"
msgstr ""

#: src/generics/methods.md:25
#, fuzzy
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"_Î•:_ Î“Î¹Î±Ï„Î¯ Ï„Î¿ `T` ÎºÎ±Î¸Î¿ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î´ÏÎ¿ Ï†Î¿ÏÎ­Ï‚ ÏƒÏ„Î¿ `impl<T> Point<T> {}`; Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ "
"Ï€ÎµÏÎ¹Ï„Ï„ÏŒ;"

#: src/generics/methods.md:26
#, fuzzy
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹ ÎµÏ€ÎµÎ¹Î´Î® ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î³ÎµÎ½Î¹ÎºÎ® ÎµÎ½ÏŒÏ„Î·Ï„Î± Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚ Î³Î¹Î± Î³ÎµÎ½Î¹ÎºÏŒ Ï„ÏÏ€Î¿. "
"Î•Î¯Î½Î±Î¹ Î±Î½ÎµÎ¾Î¬ÏÏ„Î·Ï„Î± Î³ÎµÎ½Î¹ÎºÎ¬."

#: src/generics/methods.md:27
#, fuzzy
msgid "It means these methods are defined for any `T`."
msgstr "Î£Î·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î±Ï…Ï„Î­Ï‚ Î¿Î¹ Î¼Î­Î¸Î¿Î´Î¿Î¹ Î¿ÏÎ¯Î¶Î¿Î½Ï„Î±Î¹ Î³Î¹Î± Î¿Ï€Î¿Î¹Î¿Î´Î®Ï€Î¿Ï„Îµ Â«TÂ»."

#: src/generics/methods.md:28
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`. "
msgstr "Î•Î¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒ Î½Î± Î³ÏÎ¬ÏˆÎµÏ„Îµ `impl Point<u32> { .. }`."

#: src/generics/methods.md:29
#, fuzzy
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"Î¤Î¿ \"Point\" ÎµÎ¾Î±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î³ÎµÎ½Î¹ÎºÏŒ ÎºÎ±Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ "
"\"Point\n"
"\n"
"\", Î±Î»Î»Î¬ Î¿Î¹ Î¼Î­Î¸Î¿Î´Î¿Î¹ ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ Î¼Ï€Î»Î¿Îº Î¸Î± ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼ÎµÏ‚ Î¼ÏŒÎ½Î¿ Î³Î¹Î± Ï„Î¿ "
"\"Point\n"
"\n"
"\"."

#: src/generics/monomorphization.md:3
#, fuzzy
msgid "Generic code is turned into non-generic code based on the call sites:"
msgstr ""
"ÎŸ Î³ÎµÎ½Î¹ÎºÏŒÏ‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Î¼ÎµÏ„Î±Ï„ÏÎ­Ï€ÎµÏ„Î±Î¹ ÏƒÎµ Î¼Î· Î³ÎµÎ½Î¹ÎºÏŒ ÎºÏÎ´Î¹ÎºÎ± Î²Î¬ÏƒÎµÎ¹ Ï„Ï‰Î½ Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¹ÏÎ½ "
"ÎºÎ»Î®ÏƒÎµÏ‰Î½:"

#: src/generics/monomorphization.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let integer = Some(5);\n"
"    let float = Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:12
#, fuzzy
msgid "behaves as if you wrote"
msgstr "ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î­ÏÎµÏ„Î±Î¹ ÏƒÎ±Î½ Î½Î± Î­Î³ÏÎ±ÏˆÎµÏ‚"

#: src/generics/monomorphization.md:14
msgid ""
"```rust,editable\n"
"enum Option_i32 {\n"
"    Some(i32),\n"
"    None,\n"
"}\n"
"\n"
"enum Option_f64 {\n"
"    Some(f64),\n"
"    None,\n"
"}\n"
"\n"
"fn main() {\n"
"    let integer = Option_i32::Some(5);\n"
"    let float = Option_f64::Some(5.0);\n"
"}\n"
"```"
msgstr ""

#: src/generics/monomorphization.md:31
#, fuzzy
msgid ""
"This is a zero-cost abstraction: you get exactly the same result as if you "
"had hand-coded the data structures without the abstraction."
msgstr ""
"Î‘Ï…Ï„Î® ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± Î±Ï†Î±Î¯ÏÎµÏƒÎ· Î¼Î·Î´ÎµÎ½Î¹ÎºÎ¿Ï ÎºÏŒÏƒÏ„Î¿Ï…Ï‚: Ï€Î±Î¯ÏÎ½ÎµÏ„Îµ Î±ÎºÏÎ¹Î²ÏÏ‚ Ï„Î¿ Î¯Î´Î¹Î¿ "
"Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± ÏŒÏ€Ï‰Ï‚ Î±Î½ ÎµÎ¯Ï‡Î±Ï„Îµ ÎºÏ‰Î´Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ±Î½ Ï„Î¹Ï‚ Î´Î¿Î¼Î­Ï‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Ï‡Ï‰ÏÎ¯Ï‚ Ï„Î·Î½ "
"Î±Ï†Î±Î¯ÏÎµÏƒÎ·."

#: src/traits.md:3
#, fuzzy
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr ""
"Î¤Î¿ Rust ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± Î±Ï†Î·ÏÎµÎ¯Ï„Îµ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ Î¼Îµ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬. Î•Î¯Î½Î±Î¹ "
"Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Ï„Î¹Ï‚ Î´Î¹ÎµÏ€Î±Ï†Î­Ï‚:"

#: src/traits.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it "
"anyway.\n"
"    }\n"
"}\n"
"\n"
"fn greet<P: Pet>(pet: &P) {\n"
"    println!(\"Who's a cutie? {} is!\", pet.name());\n"
"}\n"
"\n"
"fn main() {\n"
"    let fido = Dog { name: \"Fido\".into() };\n"
"    greet(&fido);\n"
"\n"
"    let captain_floof = Cat;\n"
"    greet(&captain_floof);\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:3
#, fuzzy
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÏƒÎºÎµÏ†Ï„ÎµÎ¯Ï„Îµ Ï‰Ï‚ Â«ÎºÎµÎ½ÏŒÂ» Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÏƒÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿Î¹ÎºÎµÎ¯Î¿ Î±Ï€ÏŒ Î¬Î»Î»Î¿Ï…Ï‚ "
"Î³Î»ÏÏƒÏƒÎµÏ‚ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î¿Ï."

#: src/traits/trait-objects.md:5
msgid ""
"```rust,editable\n"
"trait Pet {\n"
"    fn name(&self) -> String;\n"
"}\n"
"\n"
"struct Dog {\n"
"    name: String,\n"
"}\n"
"\n"
"struct Cat;\n"
"\n"
"impl Pet for Dog {\n"
"    fn name(&self) -> String {\n"
"        self.name.clone()\n"
"    }\n"
"}\n"
"\n"
"impl Pet for Cat {\n"
"    fn name(&self) -> String {\n"
"        String::from(\"The cat\") // No name, cats won't respond to it "
"anyway.\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let pets: Vec<Box<dyn Pet>> = vec![\n"
"        Box::new(Cat),\n"
"        Box::new(Dog { name: String::from(\"Fido\") }),\n"
"    ];\n"
"    for pet in pets {\n"
"        println!(\"Hello {}!\", pet.name());\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:40
#, fuzzy
msgid "Memory layout after allocating `pets`:"
msgstr "Î”Î¹Î¬Ï„Î±Î¾Î· Î¼Î½Î®Î¼Î·Ï‚ Î¼ÎµÏ„Î¬ Ï„Î·Î½ ÎµÎºÏ‡ÏÏÎ·ÏƒÎ· Â«xsÂ»:"

#: src/traits/trait-objects.md:42
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    "
"pets                   :     :                                             :\n"
":   +-----------+-------+   :     :   +-----+-----"
"+                             :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o "
"|                             :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-"
"+                             :\n"
":   | capacity  |     2 |   :     :     | |   | |   +---------------"
"+           :\n"
":   +-----------+-------+   :     :     | |   | '-->| name: \"Fido\"  "
"|           :\n"
":                           :     :     | |   |     +---------------"
"+           :\n"
"`- - - - - - - - - - - - - -'     :     | |   "
"|                                 :\n"
"                                  :     | |   |     +----------------------"
"+    :   \n"
"                                  :     | |   '---->| \"<Dog as Pet>::name\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    : \n"
"                                  :     | "
"|                                     : \n"
"                                  :     | |   +-"
"+                               :   \n"
"                                  :     | '-->|"
"\\|                               :     \n"
"                                  :     |     +-"
"+                               :    \n"
"                                  :     "
"|                                       : \n"
"                                  :     |     +----------------------"
"+          : \n"
"                                  :     '---->| \"<Cat as Pet>::name\" "
"|          : \n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"\n"
"```"
msgstr ""

#: src/traits/trait-objects.md:72
#, fuzzy
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<Pet>` in the example above."
msgstr ""
"Î¤Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÏÎ¿ÏƒÎ´Î¹Î¿ÏÎ¯Î¶Î¿Ï…Î½ Ï€ÏÎ¿-ÎµÏ†Î±ÏÎ¼Î¿ÏƒÎ¼Î­Î½ÎµÏ‚ (Ï€ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½ÎµÏ‚) "
"Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ ÎºÎ±Î¹ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ Ï€Î¿Ï… Î±Ï€Î±Î¹Ï„ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Ï…Ï‚ Ï‡ÏÎ®ÏƒÏ„ÎµÏ‚ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎ¿Ï…Î½ Î¿Î¹ "
"Î¯Î´Î¹Î¿Î¹. ÎŸÎ¹ Î¼Î­Î¸Î¿Î´Î¿Î¹ Î¼Îµ Ï€ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½ÎµÏ‚ Ï…Î»Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹Ï‚ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î²Î±ÏƒÎ¯Î¶Î¿Î½Ï„Î±Î¹ ÏƒÏ„Î¹Ï‚ "
"Î±Ï€Î±Î¹Ï„Î¿ÏÎ¼ÎµÎ½ÎµÏ‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚."

#: src/traits/trait-objects.md:73
#, fuzzy
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr ""
"ÎŸÎ¹ Ï„ÏÏ€Î¿Î¹ Ï€Î¿Ï… ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Î­Î½Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ "
"Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏÎ½ Î¼ÎµÎ³ÎµÎ¸ÏÎ½. Î‘Ï…Ï„ÏŒ ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ Î±Î´ÏÎ½Î±Ï„Î¿ Î½Î± Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Ï€ÏÎ¬Î³Î¼Î±Ï„Î± ÏŒÏ€Ï‰Ï‚ Ï„Î¿ \"Vec"

#: src/traits/trait-objects.md:74
#, fuzzy
msgid ""
"In the example, `pets` holds _fat pointers_ to objects that implement `Pet`. "
"The fat pointer consists of two components, a pointer to the actual object "
"and a pointer to the virtual method table for the `Pet` implementation of "
"that particular object."
msgstr "\" ÏƒÏ„Î¿ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±."

#: src/traits/trait-objects.md:75
#, fuzzy
msgid "Compare these outputs in the above example:"
msgstr ""
"Î¤Î¿ \"dyn Greet\" ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Ï„ÏÏŒÏ€Î¿Ï‚ Î½Î± Ï€ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Î­Î½Î±Î½ Ï„ÏÏ€Î¿ "
"Î´Ï…Î½Î±Î¼Î¹ÎºÎ¿Ï Î¼ÎµÎ³Î­Î¸Î¿Ï…Ï‚ Ï€Î¿Ï… Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ \"Greet\"."

#: src/traits/trait-objects.md:76
#, fuzzy
msgid ""
"```rust,ignore\n"
"    println!(\"{} {}\", std::mem::size_of::<Dog>(), std::mem::size_of::"
"<Cat>());\n"
"    println!(\"{} {}\", std::mem::size_of::<&Dog>(), std::mem::size_of::"
"<&Cat>());\n"
"    println!(\"{}\", std::mem::size_of::<&dyn Pet>());\n"
"    println!(\"{}\", std::mem::size_of::<Box<dyn Pet>>());\n"
"```"
msgstr ""
"Î£Ï„Î¿ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Ï„Î± Â«ÎºÎ±Ï„Î¿Î¹ÎºÎ¯Î´Î¹Î±Â» ÎºÏÎ±Ï„Î¿ÏÎ½ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ Î»Î¯Ï€Î¿Ï…Ï‚ ÏƒÎµ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Ï€Î¿Ï… "
"Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î¿ Â«Î§Î±Î¹ÏÎµÏ„Î¹ÏƒÎ¼ÏŒÏ‚Â». ÎŸ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Î»Î¯Ï€Î¿Ï…Ï‚ Î±Ï€Î¿Ï„ÎµÎ»ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Î´ÏÎ¿ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±, "
"Î­Î½Î±Î½ Î´ÎµÎ¯ÎºÏ„Î· Ï€ÏÎ¿Ï‚ Ï„Î¿ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎºÎ±Î¹ Î­Î½Î±Î½ Î´ÎµÎ¯ÎºÏ„Î· ÏƒÏ„Î¿Î½ Ï€Î¯Î½Î±ÎºÎ± "
"ÎµÎ¹ÎºÎ¿Î½Î¹ÎºÎ®Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï… Î³Î¹Î± Ï„Î·Î½ Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Â«GreetÂ» Ï„Î¿Ï… ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿Ï… Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï…."

#: src/traits/deriving-traits.md:3
msgid ""
"Rust derive macros work by automatically generating code that implements the "
"specified traits for a data structure."
msgstr ""

#: src/traits/deriving-traits.md:5
#, fuzzy
msgid "You can let the compiler derive a number of traits as follows:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î±Ï†Î®ÏƒÎµÏ„Îµ Ï„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Î½Î± Î±Î½Ï„Î»Î®ÏƒÎµÎ¹ Î­Î½Î±Î½ Î±ÏÎ¹Î¸Î¼ÏŒ "
"Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½:"

#: src/traits/deriving-traits.md:7
msgid ""
"```rust,editable\n"
"#[derive(Debug, Clone, PartialEq, Eq, Default)]\n"
"struct Player {\n"
"    name: String,\n"
"    strength: u8,\n"
"    hit_points: u8,\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Player::default();\n"
"    let p2 = p1.clone();\n"
"    println!(\"Is {:?}\\nequal to {:?}?\\nThe answer is {}!\", &p1, &p2,\n"
"             if p1 == p2 { \"yes\" } else { \"no\" });\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:3
#, fuzzy
msgid "Traits can implement behavior in terms of other trait methods:"
msgstr ""
"Î¤Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎ¿Ï…Î½ Ï„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ ÏƒÎµ ÏƒÏ‡Î­ÏƒÎ· Î¼Îµ Î¬Î»Î»ÎµÏ‚ "
"Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½:"

#: src/traits/default-methods.md:5
msgid ""
"```rust,editable\n"
"trait Equals {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Centimeter(i16);\n"
"\n"
"impl Equals for Centimeter {\n"
"    fn equals(&self, other: &Centimeter) -> bool {\n"
"        self.0 == other.0\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Centimeter(10);\n"
"    let b = Centimeter(20);\n"
"    println!(\"{a:?} equals {b:?}: {}\", a.equals(&b));\n"
"    println!(\"{a:?} not_equals {b:?}: {}\", a.not_equals(&b));\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:32
msgid ""
"Traits may specify pre-implemented (default) methods and methods that users "
"are required to implement themselves. Methods with default implementations "
"can rely on required methods."
msgstr ""

#: src/traits/default-methods.md:35
msgid "Move method `not_equals` to a new trait `NotEquals`."
msgstr ""

#: src/traits/default-methods.md:37
msgid "Make `Equals` a super trait for `NotEquals`."
msgstr ""

#: src/traits/default-methods.md:38
msgid ""
"```rust,editable,compile_fail\n"
"trait NotEquals: Equals {\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:46
msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
msgstr ""

#: src/traits/default-methods.md:47
msgid ""
"```rust,editable,compile_fail\n"
"trait NotEquals {\n"
"    fn not_equals(&self, other: &Self) -> bool;\n"
"}\n"
"\n"
"impl<T> NotEquals for T where T: Equals {\n"
"    fn not_equals(&self, other: &Self) -> bool {\n"
"        !self.equals(other)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/default-methods.md:58
msgid ""
"With the blanket implementation, you no longer need `Equals` as a super "
"trait for `NotEqual`."
msgstr ""

#: src/traits/trait-bounds.md:3
#, fuzzy
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"ÎŒÏ„Î±Î½ ÎµÏÎ³Î¬Î¶ÎµÏƒÏ„Îµ Î¼Îµ Î³ÎµÎ½ÏŒÏƒÎ·Î¼Î±, ÏƒÏ…Ï‡Î½Î¬ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Ï€ÎµÏÎ¹Î¿ÏÎ¯ÏƒÎµÏ„Îµ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚. "
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î±Ï…Ï„ÏŒ Î¼Îµ \"T: Trait\" Î® \"immpl Trait\":"

#: src/traits/trait-bounds.md:6
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr ""

#: src/traits/trait-bounds.md:8
msgid ""
"```rust,editable\n"
"fn duplicate<T: Clone>(a: T) -> (T, T) {\n"
"    (a.clone(), a.clone())\n"
"}\n"
"\n"
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
"fn add_42_millions(x: impl Into<i32>) -> i32 {\n"
"    x.into() + 42_000_000\n"
"}\n"
"\n"
"// struct NotClonable;\n"
"\n"
"fn main() {\n"
"    let foo = String::from(\"foo\");\n"
"    let pair = duplicate(foo);\n"
"    println!(\"{pair:?}\");\n"
"\n"
"    let many = add_42_millions(42_i8);\n"
"    println!(\"{many}\");\n"
"    let many_more = add_42_millions(10_000_000);\n"
"    println!(\"{many_more}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:35
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr ""

#: src/traits/trait-bounds.md:37
msgid ""
"```rust,ignore\n"
"fn duplicate<T>(a: T) -> (T, T)\n"
"where\n"
"    T: Clone,\n"
"{\n"
"    (a.clone(), a.clone())\n"
"}\n"
"```"
msgstr ""

#: src/traits/trait-bounds.md:46
#, fuzzy
msgid "It declutters the function signature if you have many parameters."
msgstr "ÎšÎ±Ï„Î±ÏÎ³ÎµÎ¯ Ï„Î·Î½ Ï…Ï€Î¿Î³ÏÎ±Ï†Î® Ï„Î·Ï‚ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ ÎµÎ¬Î½ Î­Ï‡ÎµÏ„Îµ Ï€Î¿Î»Î»Î­Ï‚ Ï€Î±ÏÎ±Î¼Î­Ï„ÏÎ¿Ï…Ï‚."

#: src/traits/trait-bounds.md:47
#, fuzzy
msgid "It has additional features making it more powerful."
msgstr "Î”Î¹Î±Î¸Î­Ï„ÎµÎ¹ Ï€ÏÏŒÏƒÎ¸ÎµÏ„Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Ï€Î¿Ï… Ï„Î¿ ÎºÎ¬Î½Î¿Ï…Î½ Ï€Î¹Î¿ Î¹ÏƒÏ‡Ï…ÏÏŒ."

#: src/traits/trait-bounds.md:48
#, fuzzy
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"Î•Î¬Î½ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ ÏÏ‰Ï„Î®ÏƒÎµÎ¹, Ï„Î¿ ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ ÎµÎ¯Î½Î±Î¹ ÏŒÏ„Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ ÏƒÏ„Î± "
"Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬ Ï„Î¿Ï… \":\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î±Ï…Î¸Î±Î¯ÏÎµÏ„Î¿Ï‚, ÏŒÏ€Ï‰Ï‚ \"Î•Ï€Î¹Î»Î¿Î³Î®\n"
"\n"
"\"."

#: src/traits/impl-trait.md:1
#, fuzzy
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/traits/impl-trait.md:3
#, fuzzy
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr ""
"Î Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Ï„Î± ÏŒÏÎ¹Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½, Î¼Î¹Î± ÏƒÏÎ½Ï„Î±Î¾Î· Â«impl TraitÂ» Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ ÏƒÏ„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î¿ÏÎ¯ÏƒÎ¼Î±Ï„Î± ÎºÎ±Î¹ Ï„Î¹Î¼Î­Ï‚ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚:"

#: src/traits/impl-trait.md:6
msgid ""
"```rust,editable\n"
"use std::fmt::Display;\n"
"\n"
"fn get_x(name: impl Display) -> impl Display {\n"
"    format!(\"Hello {name}\")\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = get_x(\"foo\");\n"
"    println!(\"{x}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/impl-trait.md:19
#, fuzzy
msgid "`impl Trait` allows you to work with types which you cannot name."
msgstr ""
"Î¤Î¿ \"impl Trait\" Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î¼Îµ Ï„Î· ÏƒÏÎ½Ï„Î±Î¾Î· \"::\\<\\>\" "
"turbo fish.\n"
"\n"
"Î¤Î¿ \"impl Trait\" ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÏÎ³Î¬Î¶ÎµÏƒÏ„Îµ Î¼Îµ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€Î¿Ï… Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"Î¿Î½Î¿Î¼Î¬ÏƒÎµÏ„Îµ."

#: src/traits/impl-trait.md:23
#, fuzzy
msgid ""
"The meaning of `impl Trait` is a bit different in the different positions."
msgstr ""
"Î— Î­Î½Î½Î¿Î¹Î± Ï„Î¿Ï… Â«impl TraitÂ» ÎµÎ¯Î½Î±Î¹ Î»Î¯Î³Î¿ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ® ÏƒÏ„Î¹Ï‚ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚."

#: src/traits/impl-trait.md:25
#, fuzzy
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr ""
"Î“Î¹Î± Î¼Î¹Î± Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿, Ï„Î¿ \"impl Trait\" ÎµÎ¯Î½Î±Î¹ ÏƒÎ±Î½ Î¼Î¹Î± Î±Î½ÏÎ½Ï…Î¼Î· Î³ÎµÎ½Î¹ÎºÎ® Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Ï‚ "
"Î¼Îµ Î´ÎµÏƒÎ¼ÎµÏ…Î¼Î­Î½Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ."

#: src/traits/impl-trait.md:27
#, fuzzy
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"Î“Î¹Î± Î­Î½Î±Î½ Ï„ÏÏ€Î¿ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚, ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚ ÎµÎ¯Î½Î±Î¹ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ "
"ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿Ï‚ Ï„ÏÏ€Î¿Ï‚ Ï€Î¿Ï… Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ, Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Î¿Î½Î¿Î¼Î¬ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Î½ "
"Ï„ÏÏ€Î¿. Î‘Ï…Ï„ÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ ÏŒÏ„Î±Î½ Î´ÎµÎ½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± ÎµÎºÎ¸Î­ÏƒÎµÏ„Îµ Ï„Î¿Î½ Ï„ÏÏ€Î¿ "
"ÏƒÎºÏ…ÏÎ¿Î´Î­Î¼Î±Ï„Î¿Ï‚ ÏƒÏ„Î¿ Î± Î´Î·Î¼ÏŒÏƒÎ¹Î¿ API."

#: src/traits/impl-trait.md:31
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""

#: src/traits/impl-trait.md:37
#, fuzzy
msgid ""
"This example is great, because it uses `impl Display` twice. It helps to "
"explain that nothing here enforces that it is _the same_ `impl Display` "
"type. If we used a single  `T: Display`, it would enforce the constraint "
"that input `T` and return `T` type are the same type. It would not work for "
"this particular function, as the type we expect as input is likely not what "
"`format!` returns. If we wanted to do the same via `: Display` syntax, we'd "
"need two independent generic parameters."
msgstr ""
"Î‘Ï…Ï„ÏŒ Ï„Î¿ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± ÎµÎ¯Î½Î±Î¹ Ï…Ï€Î­ÏÎ¿Ï‡Î¿, ÎµÏ€ÎµÎ¹Î´Î® Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ \"immpl Display\" "
"Î´ÏÎ¿ Ï†Î¿ÏÎ­Ï‚. Î’Î¿Î·Î¸Î¬ Î½Î± Ï„Î¿ ÎµÎ¾Î·Î³Î®ÏƒÏ‰ Ï„Î¯Ï€Î¿Ï„Î± ÎµÎ´Ï Î´ÎµÎ½ ÎµÏ€Î¹Î²Î¬Î»Î»ÎµÎ¹ ÏŒÏ„Î¹ ÎµÎ¯Î½Î±Î¹ _Î¿ Î¯Î´Î¹Î¿Ï‚_ "
"Ï„ÏÏ€Î¿Ï‚ \"impl Display\". Î‘Î½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÏƒÎ±Î¼Îµ Î­Î½Î± Î¼Î¿Î½ÏŒ Â«T: Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ·Â», Î¸Î± "
"ÎµÏ€Î¹Î²Î¬Î»ÎµÎ¹ Ï„Î¿Î½ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼ÏŒ ÏŒÏ„Î¹ Î· ÎµÎ¯ÏƒÎ¿Î´Î¿Ï‚ Â«TÂ» ÎºÎ±Î¹ Î· ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Ï„Î¿Ï… Ï„ÏÏ€Î¿Ï… Â«TÂ» "
"ÎµÎ¯Î½Î±Î¹ Ï„Î¿Ï… Î¯Î´Î¹Î¿Ï… Ï„ÏÏ€Î¿Ï…. Î”ÎµÎ½ Î¸Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÏƒÎµ Î³Î¹Î± Ï„Î· ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î· Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±, "
"ÎºÎ±Î¸ÏÏ‚ Î¿ Ï„ÏÏ€Î¿Ï‚ Ï€Î¿Ï… Ï€ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î¼Îµ Ï‰Ï‚ ÎµÎ¯ÏƒÎ¿Î´Î¿ ÎµÎ¯Î½Î±Î¹ Ï€Î¹Î¸Î±Î½ÏŒ Î½Î± Î¼Î·Î½ ÎµÎ¯Î½Î±Î¹ Ï„Î¹ "
"Â«Î¼Î¿ÏÏ†Î®!Â» ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹. Î‘Î½ Î¸Î­Î»Î±Î¼Îµ Î½Î± ÎºÎ¬Î½Î¿Ï…Î¼Îµ Ï„Î¿ Î¯Î´Î¹Î¿ Î¼Î­ÏƒÏ‰ Ï„Î·Ï‚ ÏƒÏÎ½Ï„Î±Î¾Î·Ï‚ `: "
"Display`, Î¸Î± Ï‡ÏÎµÎ¹Î±Î¶ÏŒÎ¼Î±ÏƒÏ„Î±Î½ Î´ÏÎ¿ Î±Î½ÎµÎ¾Î¬ÏÏ„Î·Ï„ÎµÏ‚ Î³ÎµÎ½Î¹ÎºÎ­Ï‚ Ï€Î±ÏÎ±Î¼Î­Ï„ÏÎ¿Ï…Ï‚."

#: src/traits/important-traits.md:3
#, fuzzy
msgid ""
"We will now look at some of the most common traits of the Rust standard "
"library:"
msgstr ""
"Î˜Î± Î´Î¿ÏÎ¼Îµ Ï„ÏÏÎ± Î¼ÎµÏÎ¹ÎºÎ¬ Î±Ï€ÏŒ Ï„Î± Ï€Î¹Î¿ ÎºÎ¿Î¹Î½Î¬ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Ï„Î·Ï‚ Î²Î±ÏƒÎ¹ÎºÎ®Ï‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚ "
"Rust:"

#: src/traits/important-traits.md:5
#, fuzzy
msgid ""
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
"[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html) "
"used in `for` loops,"
msgstr "Â«IteratorÂ» ÎºÎ±Î¹ Â«IntoIteratorÂ» Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ ÏƒÎµ Î²ÏÏŒÏ‡Î¿Ï…Ï‚ Â«forÂ»,"

#: src/traits/important-traits.md:6
#, fuzzy
msgid ""
"[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and [`Into`]"
"(https://doc.rust-lang.org/std/convert/trait.Into.html) used to convert "
"values,"
msgstr "Î¤Î± \"From\" ÎºÎ±Î¹ \"Into\" Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± Ï„Î· Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î® Ï„Î¹Î¼ÏÎ½,"

#: src/traits/important-traits.md:7
#, fuzzy
msgid ""
"[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
"(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
msgstr "Â«ReadÂ» ÎºÎ±Î¹ Â«WriteÂ» Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± IO,"

#: src/traits/important-traits.md:8
#, fuzzy
msgid ""
"[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`](https://"
"doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
"overloading, and"
msgstr "Â«Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Â», Â«MulÂ», ... Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Ï…Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ· Ï‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î® ÎºÎ±Î¹"

#: src/traits/important-traits.md:9
#, fuzzy
msgid ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) used for "
"defining destructors."
msgstr "Â«DropÂ» Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Ï„Î¿Î½ Î¿ÏÎ¹ÏƒÎ¼ÏŒ Ï„Ï‰Î½ ÎºÎ±Ï„Î±ÏƒÏ„ÏÎ¿Ï†Î­Ï‰Î½."

#: src/traits/important-traits.md:10
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) used "
"to construct a default instance of a type."
msgstr ""

#: src/traits/iterator.md:1
#, fuzzy
msgid "Iterators"
msgstr "Î•Ï€Î±Î½Î±Î»Î·Ï€Ï„Î¹ÎºÎ¿Î¯"

#: src/traits/iterator.md:3
#, fuzzy
msgid ""
"You can implement the [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) trait on your own types:"
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«IteratorÂ» ÏƒÏ„Î¿Ï…Ï‚ Î´Î¹ÎºÎ¿ÏÏ‚ ÏƒÎ±Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚:"

#: src/traits/iterator.md:5
msgid ""
"```rust,editable\n"
"struct Fibonacci {\n"
"    curr: u32,\n"
"    next: u32,\n"
"}\n"
"\n"
"impl Iterator for Fibonacci {\n"
"    type Item = u32;\n"
"\n"
"    fn next(&mut self) -> Option<Self::Item> {\n"
"        let new_next = self.curr + self.next;\n"
"        self.curr = self.next;\n"
"        self.next = new_next;\n"
"        Some(self.curr)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = Fibonacci { curr: 0, next: 1 };\n"
"    for (i, n) in fib.enumerate().take(5) {\n"
"        println!(\"fib({i}): {n}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/traits/iterator.md:32
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections  (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""

#: src/traits/iterator.md:37
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""

#: src/traits/from-iterator.md:3
#, fuzzy
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"Î¤Î¿ \"FromIterator\" ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î¼Î¹Î± ÏƒÏ…Î»Î»Î¿Î³Î® Î±Ï€ÏŒ Î­Î½Î± "
"\"Iterator\"."

#: src/traits/from-iterator.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let primes = vec![2, 3, 5, 7];\n"
"    let prime_squares = primes\n"
"        .into_iter()\n"
"        .map(|prime| prime * prime)\n"
"        .collect::<Vec<_>>();\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-iterator.md:17
#, fuzzy
msgid ""
"`Iterator` implements `fn collect<B>(self) -> B where B: FromIterator<Self::"
"Item>, Self: Sized`"
msgstr ""
"Î¤Î¿ Â«IteratorÂ» Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ `fn collect<B>(self) -> B Ï€Î¿Ï… Î’: FromIterator<Self::"
"Item>, Self: ÎœÎ­Î³ÎµÎ¸Î¿Ï‚`"

#: src/traits/from-iterator.md:23
#, fuzzy
msgid ""
"There are also implementations which let you do cool things like convert an "
"`Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"Î¥Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÎµÏ€Î¯ÏƒÎ·Ï‚ Ï…Î»Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î½ Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ ÎºÎ±Ï„Î±Ï€Î»Î·ÎºÏ„Î¹ÎºÎ¬ "
"Ï€ÏÎ¬Î³Î¼Î±Ï„Î± ÏŒÏ€Ï‰Ï‚ Î· Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î® ÎµÎ½ÏŒÏ‚ \"Iterator\\<Item = Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\\<V, E>>\" ÏƒÎµ "
"Î­Î½Î± \"Result\\<Vec\n"
"\n"
", E>\"."

#: src/traits/from-into.md:1
#, fuzzy
msgid "`From` and `Into`"
msgstr "Â«Î‘Ï€ÏŒÂ» ÎºÎ±Î¹ Â«ÎœÎ­ÏƒÎ±Â»."

#: src/traits/from-into.md:3
#, fuzzy
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"ÎŸÎ¹ Ï„ÏÏ€Î¿Î¹ ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Ï„Î± Â«Î‘Ï€ÏŒÂ» ÎºÎ±Î¹ Â«ÎœÎ­ÏƒÎ±Â» Î³Î¹Î± Î½Î± Î´Î¹ÎµÏ…ÎºÎ¿Î»ÏÎ½Î¿Ï…Î½ Ï„Î¹Ï‚ Î¼ÎµÏ„Î±Ï„ÏÎ¿Ï€Î­Ï‚ "
"Ï„ÏÏ€Ï‰Î½:"

#: src/traits/from-into.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s = String::from(\"hello\");\n"
"    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);\n"
"    let one = i16::from(true);\n"
"    let bigger = i32::from(123i16);\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:15
#, fuzzy
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr "Î¤Î¿ \"Into\" Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± ÏŒÏ„Î±Î½ Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Ï„Î¿ \"From\":"

#: src/traits/from-into.md:17
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let s: String = \"hello\".into();\n"
"    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();\n"
"    let one: i16 = true.into();\n"
"    let bigger: i32 = 123i16.into();\n"
"    println!(\"{s}, {addr}, {one}, {bigger}\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/from-into.md:29
#, fuzzy
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/traits/from-into.md:30
#, fuzzy
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"Î‘Ï…Ï„ÏŒÏ‚ ÎµÎ¯Î½Î±Î¹ Î¿ Î»ÏŒÎ³Î¿Ï‚ Î³Î¹Î± Ï„Î¿Î½ Î¿Ï€Î¿Î¯Î¿ ÎµÎ¯Î½Î±Î¹ ÏƒÏÎ½Î·Î¸ÎµÏ‚ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÎ¶ÎµÏ„Îµ Î¼ÏŒÎ½Î¿ Ï„Î¿ "
"\"From\", ÎºÎ±Î¸ÏÏ‚ Î¿ Ï„ÏÏ€Î¿Ï‚ ÏƒÎ±Ï‚ Î¸Î± Î»Î¬Î²ÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Ï„Î·Î½ ÎµÏ†Î±ÏÎ¼Î¿Î³Î® \"Into\".\n"
"\n"
"ÎŒÏ„Î±Î½ Î´Î·Î»ÏÎ½ÎµÏ„Îµ Î­Î½Î±Î½ Ï„ÏÏ€Î¿ ÎµÎ¹ÏƒÏŒÎ´Î¿Ï… Î¿ÏÎ¯ÏƒÎ¼Î±Ï„Î¿Ï‚ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ ÏŒÏ€Ï‰Ï‚ \"Î¿Ï„Î¹Î´Î®Ï€Î¿Ï„Îµ Î¼Ï€Î¿ÏÎµÎ¯ "
"Î½Î± Î¼ÎµÏ„Î±Ï„ÏÎ±Ï€ÎµÎ¯ ÏƒÎµ \"Î£Ï…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ¬\", Î¿ ÎºÎ±Î½ÏŒÎ½Î±Ï‚ ÎµÎ¯Î½Î±Î¹ Î±Î½Ï„Î¯Î¸ÎµÏ„Î¿Ï‚, Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ \"Into\". Î— ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ® ÏƒÎ±Ï‚ Î¸Î± Î´Î­Ï‡ÎµÏ„Î±Î¹ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€Î¿Ï… Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ "
"Ï„Î¿ \"From\" ÎºÎ±Î¹ ÎµÎºÎµÎ¯Î½Î¿Ï…Ï‚ Ï€Î¿Ï… _only_ Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î¿ \"Into\"."

#: src/traits/read-write.md:1
#, fuzzy
msgid "`Read` and `Write`"
msgstr "Â«Î”Î¹Î±Î²Î¬ÏƒÏ„ÎµÂ» ÎºÎ±Î¹ Â«Î“ÏÎ¬ÏˆÏ„ÎµÂ»."

#: src/traits/read-write.md:3
#, fuzzy
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿ \"Read\" ÎºÎ±Î¹ Ï„Î¿ \"BufRead\", Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î±Ï†Î±Î¹ÏÎ­ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ "
"Ï€Î·Î³Î­Ï‚ \"u8\":"

#: src/traits/read-write.md:5
msgid ""
"```rust,editable\n"
"use std::io::{BufRead, BufReader, Read, Result};\n"
"\n"
"fn count_lines<R: Read>(reader: R) -> usize {\n"
"    let buf_reader = BufReader::new(reader);\n"
"    buf_reader.lines().count()\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let slice: &[u8] = b\"foo\\nbar\\nbaz\\n\";\n"
"    println!(\"lines in slice: {}\", count_lines(slice));\n"
"\n"
"    let file = std::fs::File::open(std::env::current_exe()?)?;\n"
"    println!(\"lines in file: {}\", count_lines(file));\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/read-write.md:23
#, fuzzy
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"Î Î±ÏÎ¿Î¼Î¿Î¯Ï‰Ï‚, Ï„Î¿ Â«WriteÂ» ÏƒÎ¬Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ Î±Ï†Î·ÏÎ®ÏƒÎµÎ¹Ï‚ Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î± Î½ÎµÏÎ¿Ï‡ÏÏ„Î± "
"Â«u8Â»:"

#: src/traits/read-write.md:25
msgid ""
"```rust,editable\n"
"use std::io::{Result, Write};\n"
"\n"
"fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {\n"
"    writer.write_all(msg.as_bytes())?;\n"
"    writer.write_all(\"\\n\".as_bytes())\n"
"}\n"
"\n"
"fn main() -> Result<()> {\n"
"    let mut buffer = Vec::new();\n"
"    log(&mut buffer, \"Hello\")?;\n"
"    log(&mut buffer, \"World\")?;\n"
"    println!(\"Logged: {:?}\", buffer);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:1
#, fuzzy
msgid "The `Drop` Trait"
msgstr "Î¤Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«DropÂ»."

#: src/traits/drop.md:3
#, fuzzy
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"ÎŸÎ¹ Ï„Î¹Î¼Î­Ï‚ Ï€Î¿Ï… ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Ï„Î¿ \"Drop\" Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± ÎºÎ±Î¸Î¿ÏÎ¯ÏƒÎ¿Ï…Î½ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± Ï€Î¿Ï… Î¸Î± "
"ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Î±Î¹ ÏŒÏ„Î±Î½ ÎµÎ¾Î­ÏÏ‡Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿ Ï€ÎµÎ´Î¯Î¿ ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚:"

#: src/traits/drop.md:5
msgid ""
"```rust,editable\n"
"struct Droppable {\n"
"    name: &'static str,\n"
"}\n"
"\n"
"impl Drop for Droppable {\n"
"    fn drop(&mut self) {\n"
"        println!(\"Dropping {}\", self.name);\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let a = Droppable { name: \"a\" };\n"
"    {\n"
"        let b = Droppable { name: \"b\" };\n"
"        {\n"
"            let c = Droppable { name: \"c\" };\n"
"            let d = Droppable { name: \"d\" };\n"
"            println!(\"Exiting block B\");\n"
"        }\n"
"        println!(\"Exiting block A\");\n"
"    }\n"
"    drop(a);\n"
"    println!(\"Exiting main\");\n"
"}\n"
"```"
msgstr ""

#: src/traits/drop.md:34 src/traits/operators.md:26
#, fuzzy
msgid "Discussion points:"
msgstr "Î£Î·Î¼ÎµÎ¯Î± ÏƒÏ…Î¶Î®Ï„Î·ÏƒÎ·Ï‚:"

#: src/traits/drop.md:36
#, fuzzy
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "Î“Î¹Î±Ï„Î¯ Ï„Î¿ Â«Drop::dropÂ» Î´ÎµÎ½ ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ Â«selfÂ»;"

#: src/traits/drop.md:37
#, fuzzy
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"Î£ÏÎ½Ï„Î¿Î¼Î· Î±Ï€Î¬Î½Ï„Î·ÏƒÎ·: Î•Î¬Î½ ÏƒÏ…Î½Î­Î²Î±Î¹Î½Îµ, Ï„Î¿ `std::mem::drop` Î¸Î± ÎºÎ±Î»Î¿ÏÎ½Ï„Î±Î½ ÏƒÏ„Î¿ Ï„Î­Î»Î¿Ï‚ "
"Ï„Î¿Ï… Ï„Î¿ Î¼Ï€Î»Î¿Îº, Î¼Îµ Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± Î¼Î¹Î± Î¬Î»Î»Î· ÎºÎ»Î®ÏƒÎ· ÏƒÏ„Î¿ Â«Drop::dropÂ» ÎºÎ±Î¹ Î¼Î¹Î± ÏƒÏ„Î¿Î¯Î²Î± "
"Î¾ÎµÏ‡ÎµÎ¯Î»Î¹ÏƒÎ¼Î±!"

#: src/traits/drop.md:40
#, fuzzy
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Î½Î± Î±Î½Ï„Î¹ÎºÎ±Ï„Î±ÏƒÏ„Î®ÏƒÎµÏ„Îµ Ï„Î¿ Â«drop(a)Â» Î¼Îµ Ï„Î¿ Â«a.drop()Â»."

#: src/traits/default.md:1
#, fuzzy
msgid "The `Default` Trait"
msgstr "Î¤Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«DropÂ»."

#: src/traits/default.md:3
#, fuzzy
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«IteratorÂ» ÏƒÏ„Î¿Ï…Ï‚ Î´Î¹ÎºÎ¿ÏÏ‚ ÏƒÎ±Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚:"

#: src/traits/default.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Default)]\n"
"struct Derived {\n"
"    x: u32,\n"
"    y: String,\n"
"    z: Implemented,\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct Implemented(String);\n"
"\n"
"impl Default for Implemented {\n"
"    fn default() -> Self {\n"
"        Self(\"John Smith\".into())\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let default_struct = Derived::default();\n"
"    println!(\"{default_struct:#?}\");\n"
"\n"
"    let almost_default_struct = Derived {\n"
"        y: \"Y is set!\".into(),\n"
"        ..Derived::default()\n"
"    };\n"
"    println!(\"{almost_default_struct:#?}\");\n"
"\n"
"    let nothing: Option<Derived> = None;\n"
"    println!(\"{:#?}\", nothing.unwrap_or_default());\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/traits/default.md:40
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr ""

#: src/traits/default.md:41
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr ""

#: src/traits/default.md:42
msgid "This means all types in the struct must implement `Default` too."
msgstr ""

#: src/traits/default.md:43
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""

#: src/traits/default.md:44
msgid "The partial struct copy works nicely with default."
msgstr ""

#: src/traits/default.md:45
msgid ""
"Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr ""

#: src/traits/default.md:46
msgid ""
"the `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)"
msgstr ""

#: src/traits/operators.md:1
#, fuzzy
msgid "`Add`, `Mul`, ..."
msgstr "\"Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ·\", \"Mul\", ..."

#: src/traits/operators.md:3
#, fuzzy
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"Î— Ï…Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ· Ï‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î® Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î¼Î­ÏƒÏ‰ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½ ÏƒÏ„Î¿ `std::ops`:"

#: src/traits/operators.md:5
msgid ""
"```rust,editable\n"
"#[derive(Debug, Copy, Clone)]\n"
"struct Point { x: i32, y: i32 }\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self {\n"
"        Self {x: self.x + other.x, y: self.y + other.y}\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let p1 = Point { x: 10, y: 20 };\n"
"    let p2 = Point { x: 100, y: 200 };\n"
"    println!(\"{:?} + {:?} = {:?}\", p1, p2, p1 + p2);\n"
"}\n"
"```"
msgstr ""

#: src/traits/operators.md:28
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful? "
msgstr ""
"Î˜Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Ï„Îµ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ Ï„Î¿ \"Add\" Î³Î¹Î± Ï„Î¿ \"&Point\". Î£Îµ Ï€Î¿Î¹ÎµÏ‚ "
"Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚ ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿;"

#: src/traits/operators.md:29
#, fuzzy
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"Î‘Ï€Î¬Î½Ï„Î·ÏƒÎ·: Î¤Î¿ Â«Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ·: Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Â» ÎºÎ±Ï„Î±Î½Î±Î»ÏÎ½ÎµÎ¹ Ï„Î¿Î½ Â«ÎµÎ±Ï…Ï„ÏŒÂ». Î‘Î½ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»Î¿Î³Î®ÏƒÏ„Îµ "
"`T` Î³Î¹Î± Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ ÎµÎ¯ÏƒÏ„Îµ Î— Ï…Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ· Ï„Î¿Ï… Ï‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î® Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Â«Î‘Î½Ï„Î¹Î³ÏÎ±Ï†Î®Â», Î¸Î± "
"Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎµÏ„Îµ Ï„Î·Î½ Ï…Ï€ÎµÏÏ†ÏŒÏÏ„Ï‰ÏƒÎ· Î¿ Ï‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î®Ï‚ Î³Î¹Î± Ï„Î¿ Â«&TÂ» ÎµÏ€Î¯ÏƒÎ·Ï‚. Î‘Ï…Ï„ÏŒ "
"Î±Ï€Î¿Ï†ÎµÏÎ³ÎµÎ¹ Ï„Î·Î½ Ï€ÎµÏÎ¹Ï„Ï„Î® ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÏƒÏ„Î¿ Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î± ÎºÎ»Î®ÏƒÎ·Ï‚."

#: src/traits/operators.md:33
#, fuzzy
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr ""
"Î“Î¹Î±Ï„Î¯ Ï„Î¿ \"ÎˆÎ¾Î¿Î´Î¿Ï‚\" ÎµÎ¯Î½Î±Î¹ ÏƒÏ…ÏƒÏ‡ÎµÏ„Î¹ÏƒÎ¼Î­Î½Î¿Ï‚ Ï„ÏÏ€Î¿Ï‚; Î˜Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎµ Î½Î± Î³Î¯Î½ÎµÎ¹ "
"Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Ï‚ Ï„ÏÏ€Î¿Ï…;"

#: src/traits/operators.md:34
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementor of a "
"trait."
msgstr ""
"Î£ÏÎ½Ï„Î¿Î¼Î· Î±Ï€Î¬Î½Ï„Î·ÏƒÎ·: ÎŸÎ¹ Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Î¹ Ï„ÏÏ€Î¿Ï… ÎµÎ»Î­Î³Ï‡Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ ÎºÎ±Î»Î¿ÏÎ½Ï„Î±, Î±Î»Î»Î¬ Î¿Î¹ "
"ÏƒÏ…ÏƒÏ‡ÎµÏ„Î¹ÏƒÎ¼Î­Î½Î¿Î¹ Ï„ÏÏ€Î¿Î¹ (ÏŒÏ€Ï‰Ï‚ \"ÎˆÎ¾Î¿Î´Î¿Ï‚\") ÎµÎ»Î­Î³Ï‡Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ Ï…Î»Î¿Ï€Î¿Î¹Î·Ï„Î® Ï„Î¿Ï… a "
"Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ."

#: src/traits/operators.md:37
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""

#: src/traits/closures.md:1
msgid "Closures"
msgstr "ÎšÎ»ÎµÎ¹ÏƒÎ¯Î¼Î±Ï„Î±"

#: src/traits/closures.md:3
#, fuzzy
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"Î¤Î± ÎºÎ»ÎµÎ¹ÏƒÎ¯Î¼Î±Ï„Î± Î® Î¿Î¹ ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Î»Î¬Î¼Î´Î± Î­Ï‡Î¿Ï…Î½ Ï„ÏÏ€Î¿Ï…Ï‚ Ï€Î¿Ï… Î´ÎµÎ½ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± "
"Î¿Î½Î¿Î¼Î±ÏƒÏ„Î¿ÏÎ½. Î©ÏƒÏ„ÏŒÏƒÎ¿, Î±Ï…Ï„Î¿Î¯ ÎµÏ†Î±ÏÎ¼Î¿Î³Î® ÎµÎ¹Î´Î¹ÎºÎ¿Ï [`Fn`](https://doc.rust-lang.org/"
"std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait."
"FnMut.html) ÎºÎ±Î¹ [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce."
"html) Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬:"

#: src/traits/closures.md:8
msgid ""
"```rust,editable\n"
"fn apply_with_log(func: impl FnOnce(i32) -> i32, input: i32) -> i32 {\n"
"    println!(\"Calling function on {input}\");\n"
"    func(input)\n"
"}\n"
"\n"
"fn main() {\n"
"    let add_3 = |x| x + 3;\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 10));\n"
"    println!(\"add_3: {}\", apply_with_log(add_3, 20));\n"
"\n"
"    let mut v = Vec::new();\n"
"    let mut accumulate = |x: i32| {\n"
"        v.push(x);\n"
"        v.iter().sum::<i32>()\n"
"    };\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 4));\n"
"    println!(\"accumulate: {}\", apply_with_log(&mut accumulate, 5));\n"
"\n"
"    let multiply_sum = |x| x * v.into_iter().sum::<i32>();\n"
"    println!(\"multiply_sum: {}\", apply_with_log(multiply_sum, 3));\n"
"}\n"
"```"
msgstr ""

#: src/traits/closures.md:34
#, fuzzy
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"ÎˆÎ½Î± \"Fn\" Î¿ÏÏ„Îµ ÎºÎ±Ï„Î±Î½Î±Î»ÏÎ½ÎµÎ¹ Î¿ÏÏ„Îµ Î¼ÎµÏ„Î±Î»Î»Î¬ÏƒÏƒÎµÎ¹ Ï„Î¹Ï‚ ÎºÎ±Ï„Î±Î³ÎµÎ³ÏÎ±Î¼Î¼Î­Î½ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚ Î® "
"Î¯ÏƒÏ‰Ï‚ Î´ÎµÎ½ ÎºÎ±Ï„Î±Î³ÏÎ¬Ï†ÎµÎ¹ Ï„Î¯Ï€Î¿Ï„Î± Î±Ï€Î¿Î»ÏÏ„Ï‰Ï‚, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ ÎºÎ±Î»ÎµÎ¯Ï„Î±Î¹ Ï€Î¿Î»Î»Î­Ï‚ Ï†Î¿ÏÎ­Ï‚ "
"Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î±."

#: src/traits/closures.md:37
#, fuzzy
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"ÎˆÎ½Î± \"FnMut\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î¼ÎµÏ„Î±Î»Î»Î¬Î¾ÎµÎ¹ Ï„Î¹Ï‚ ÎºÎ±Ï„Î±Î³ÎµÎ³ÏÎ±Î¼Î¼Î­Î½ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚, ÏÏƒÏ„Îµ Î½Î± "
"Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Ï€Î¿Î»Î»Î­Ï‚ Ï†Î¿ÏÎ­Ï‚ Î±Î»Î»Î¬ ÏŒÏ‡Î¹ Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î±."

#: src/traits/closures.md:40
#, fuzzy
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"Î•Î¬Î½ Î­Ï‡ÎµÏ„Îµ Î­Î½Î± \"FnOnce\", Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Î¼ÏŒÎ½Î¿ Î¼Î¯Î± Ï†Î¿ÏÎ¬. ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± "
"ÎºÎ±Ï„Î±Î½Î±Î»ÏÏƒÎµÎ¹ ÎºÎ±Ï„Î±Î³ÎµÎ³ÏÎ±Î¼Î¼Î­Î½ÎµÏ‚ Ï„Î¹Î¼Î­Ï‚."

#: src/traits/closures.md:43
#, fuzzy
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"Î¤Î¿ \"FnMut\" ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Ï…Ï€Î¿Ï„ÏÏ€Î¿Ï‚ Ï„Î¿Ï… \"FnOnce\". Î¤Î¿ \"Fn\" ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ "
"Ï…Ï€Î¿Ï„ÏÏ€Î¿Ï‚ Ï„Ï‰Î½ \"FnMut\" ÎºÎ±Î¹ \"FnOnce\". Î”Î·Î». Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î­Î½Î± "
"Â«FnMutÂ» ÏŒÏ€Î¿Ï… Î¶Î·Ï„ÎµÎ¯Ï„Î±Î¹ Î­Î½Î± Â«FnOnceÂ» ÎºÎ±Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î­Î½Î± Â«FnÂ» "
"ÏŒÏ€Î¿Ï… Î­Î½Î± Â«FnMutÂ» Î® Â«FnOnceÂ» ÎºÎ±Î»ÎµÎ¯Ï„Î±Î¹."

#: src/traits/closures.md:47
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""

#: src/traits/closures.md:50
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""

#: src/traits/closures.md:52
msgid ""
"```rust,editable\n"
"fn make_greeter(prefix: String) -> impl Fn(&str) {\n"
"    return move |name| println!(\"{} {}\", prefix, name)\n"
"}\n"
"\n"
"fn main() {\n"
"    let hi = make_greeter(\"Hi\".to_string());\n"
"    hi(\"there\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/morning.md:1
#, fuzzy
msgid "Day 3: Morning Exercises"
msgstr "Î—Î¼Î­ÏÎ± 3: Î ÏÏ‰Î¹Î½Î­Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-3/morning.md:3
#, fuzzy
msgid "We will design a classical GUI library using traits and trait objects."
msgstr ""
"Î˜Î± ÏƒÏ‡ÎµÎ´Î¹Î¬ÏƒÎ¿Ï…Î¼Îµ Î¼Î¹Î± ÎºÎ»Î±ÏƒÎ¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· GUI Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ ÎºÎ±Î¹ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± "
"Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½."

#: src/exercises/day-3/morning.md:5
msgid ""
"We will also look at enum dispatch with an exercise involving points and "
"polygons."
msgstr ""

#: src/exercises/day-3/simple-gui.md:3
#, fuzzy
msgid ""
"Let us design a classical GUI library using our new knowledge of traits and "
"trait objects."
msgstr ""
"Î‘Ï‚ ÏƒÏ‡ÎµÎ´Î¹Î¬ÏƒÎ¿Ï…Î¼Îµ Î¼Î¹Î± ÎºÎ»Î±ÏƒÎ¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· GUI Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¹Ï‚ Î½Î­ÎµÏ‚ Î¼Î±Ï‚ "
"Î³Î½ÏÏƒÎµÎ¹Ï‚ Î³Î¹Î± Ï„Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ ÎºÎ±Î¹ Î³Î½Ï‰ÏÎ¯ÏƒÎ¼Î±Ï„Î± Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Ï‰Î½."

#: src/exercises/day-3/simple-gui.md:6
#, fuzzy
msgid "We will have a number of widgets in our library:"
msgstr "Î˜Î± Î­Ï‡Î¿Ï…Î¼Îµ Î­Î½Î±Î½ Î±ÏÎ¹Î¸Î¼ÏŒ Î³ÏÎ±Ï†Î¹ÎºÏÎ½ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Ï‰Î½ ÏƒÏ„Î· Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Î¼Î±Ï‚:"

#: src/exercises/day-3/simple-gui.md:8
#, fuzzy
msgid "`Window`: has a `title` and contains other widgets."
msgstr "Â«Î Î±ÏÎ¬Î¸Ï…ÏÎ¿Â»: Î­Ï‡ÎµÎ¹ Â«Ï„Î¯Ï„Î»Î¿Â» ÎºÎ±Î¹ Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î¬Î»Î»Î± Î³ÏÎ±Ï†Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±."

#: src/exercises/day-3/simple-gui.md:9
#, fuzzy
msgid ""
"`Button`: has a `label` and a callback function which is invoked when the "
"button is pressed."
msgstr ""
"Â«ÎšÎ¿Ï…Î¼Ï€Î¯Â»: Î­Ï‡ÎµÎ¹ Î¼Î¹Î± Â«ÎµÏ„Î¹ÎºÎ­Ï„Î±Â» ÎºÎ±Î¹ Î¼Î¹Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± ÎµÏ€Î±Î½Î¬ÎºÎ»Î·ÏƒÎ·Ï‚ Ï€Î¿Ï… ÎºÎ±Î»ÎµÎ¯Ï„Î±Î¹ "
"ÏŒÏ„Î±Î½ Ï„Î¿ Ï€Î±Ï„Î¹Î­Ï„Î±Î¹ Ï„Î¿ ÎºÎ¿Ï…Î¼Ï€Î¯."

#: src/exercises/day-3/simple-gui.md:11
#, fuzzy
msgid "`Label`: has a `label`."
msgstr "\"Î•Ï„Î¹ÎºÎ­Ï„Î±\": Î­Ï‡ÎµÎ¹ \"ÎµÏ„Î¹ÎºÎ­Ï„Î±\"."

#: src/exercises/day-3/simple-gui.md:13
#, fuzzy
msgid "The widgets will implement a `Widget` trait, see below."
msgstr ""
"Î¤Î± Î³ÏÎ±Ï†Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± Î¸Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎ¿Ï…Î½ Î­Î½Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«Î“ÏÎ±Ï†Î¹ÎºÏŒ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î¿Â», "
"Î´ÎµÎ¯Ï„Îµ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰."

#: src/exercises/day-3/simple-gui.md:15
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
"`draw_into` methods so that you implement the `Widget` trait:"
msgstr ""
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/>, "
"ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î¿Î½ ÎºÏ‰Î´Î¹ÎºÏŒ Ï€Î¿Ï… Î»ÎµÎ¯Ï€ÎµÎ¹ ÎœÎ­Î¸Î¿Î´Î¿Î¹ \"draw_into\", ÏÏƒÏ„Îµ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ "
"Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ \"Widget\":"

#: src/exercises/day-3/simple-gui.md:18
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        unimplemented!()\n"
"    }\n"
"\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:130
#, fuzzy
msgid "The output of the above program can be something simple like this:"
msgstr ""
"Î— Î­Î¾Î¿Î´Î¿Ï‚ Ï„Î¿Ï… Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ ÎºÎ¬Ï„Î¹ Î±Ï€Î»ÏŒ ÏŒÏ€Ï‰Ï‚ Î±Ï…Ï„ÏŒ:"

#: src/exercises/day-3/simple-gui.md:132
msgid ""
"```text\n"
"========\n"
"Rust GUI Demo 1.23\n"
"========\n"
"\n"
"This is a small text GUI demo.\n"
"\n"
"| Click me! |\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:142
#, fuzzy
msgid ""
"If you want to draw aligned text, you can use the [fill/alignment](https://"
"doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting operators. In "
"particular, notice how you can pad with different characters (here a `'/'`) "
"and how you can control alignment:"
msgstr ""
"Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± ÏƒÏ‡ÎµÎ´Î¹Î¬ÏƒÎµÏ„Îµ ÏƒÏ„Î¿Î¹Ï‡Î¹ÏƒÎ¼Î­Î½Î¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ "
"[fill/alignment](https://doc.rust-lang.org/std/fmt/index.html#fillalignment) "
"Ï„ÎµÎ»ÎµÏƒÏ„Î­Ï‚ Î¼Î¿ÏÏ†Î¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚. Î•Î¹Î´Î¹ÎºÏŒÏ„ÎµÏÎ±, Ï€Î±ÏÎ±Ï„Î·ÏÎ®ÏƒÏ„Îµ Ï€ÏÏ‚ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î³ÎµÎ¼Î¯ÏƒÎµÏ„Îµ "
"Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬ Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÎµÏ‚ (ÎµÎ´Ï Î­Î½Î± `'/'`) ÎºÎ±Î¹ Ï€ÏÏ‚ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎ»Î­Î³Î¾ÎµÏ„Îµ Ï„Î· "
"ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ·:"

#: src/exercises/day-3/simple-gui.md:147
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let width = 10;\n"
"    println!(\"left aligned:  |{:/<width$}|\", \"foo\");\n"
"    println!(\"centered:      |{:/^width$}|\", \"foo\");\n"
"    println!(\"right aligned: |{:/>width$}|\", \"foo\");\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-3/simple-gui.md:156
#, fuzzy
msgid ""
"Using such alignment tricks, you can for example produce output like this:"
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î­Ï„Î¿Î¹Î± ÎºÏŒÎ»Ï€Î± ÎµÏ…Î¸Ï…Î³ÏÎ¬Î¼Î¼Î¹ÏƒÎ·Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î³Î¹Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Î½Î± "
"Ï€Î±ÏÎ¬Î³ÎµÏ„Îµ Î­Î¾Î¿Î´Î¿ ÏŒÏ€Ï‰Ï‚ Î±Ï…Ï„ÏŒ:"

#: src/exercises/day-3/simple-gui.md:158
msgid ""
"```text\n"
"+--------------------------------+\n"
"|       Rust GUI Demo 1.23       |\n"
"+================================+\n"
"| This is a small text GUI demo. |\n"
"| +-----------+                  |\n"
"| | Click me! |                  |\n"
"| +-----------+                  |\n"
"+--------------------------------+\n"
"```"
msgstr ""

#: src/exercises/day-3/points-polygons.md:1
#, fuzzy
msgid "Polygon Struct"
msgstr "Î Î¿Î»Ï…Î³Ï‰Î½Î¹ÎºÎ® ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î®"

#: src/exercises/day-3/points-polygons.md:3
#, fuzzy
msgid ""
"We will create a `Polygon` struct which contain some points. Copy the code "
"below to <https://play.rust-lang.org/> and fill in the missing methods to "
"make the tests pass:"
msgstr ""
"Î˜Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î¼Î¹Î± Î´Î¿Î¼Î® Â«Î Î¿Î»ÏÎ³Ï‰Î½Î¿Â» Ï€Î¿Ï… Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î¼ÎµÏÎ¹ÎºÎ¬ ÏƒÎ·Î¼ÎµÎ¯Î±. Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ "
"Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏ‰Î´Î¹ÎºÏŒ ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î¹Ï‚ "
"Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ Ï€Î¿Ï… Î»ÎµÎ¯Ï€Î¿Ï…Î½ Î³Î¹Î± Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î¿Î¹ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Ï€ÎµÏÎ½Î¿ÏÎ½:"

#: src/exercises/day-3/points-polygons.md:7
msgid ""
"```rust\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_variables, dead_code)]\n"
"\n"
"pub struct Point {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Point {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Polygon {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Polygon {\n"
"    // add methods\n"
"}\n"
"\n"
"pub struct Circle {\n"
"    // add fields\n"
"}\n"
"\n"
"impl Circle {\n"
"    // add methods\n"
"}\n"
"\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"\n"
"#[allow(dead_code)]\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/points-polygons.md:117
#, fuzzy
msgid ""
"Since the method signatures are missing from the problem statements, the key "
"part of the exercise is to specify those correctly. You don't have to modify "
"the tests."
msgstr ""
"Î”ÎµÎ´Î¿Î¼Î­Î½Î¿Ï… ÏŒÏ„Î¹ Î¿Î¹ Ï…Ï€Î¿Î³ÏÎ±Ï†Î­Ï‚ Ï„Î·Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï… Î»ÎµÎ¯Ï€Î¿Ï…Î½ Î±Ï€ÏŒ Ï„Î¹Ï‚ Î´Î·Î»ÏÏƒÎµÎ¹Ï‚ Ï€ÏÎ¿Î²Î»Î·Î¼Î¬Ï„Ï‰Î½, "
"Ï„Î¿ Î²Î±ÏƒÎ¹ÎºÏŒ Î¼Î­ÏÎ¿Ï‚ Ï„Î·Ï‚ Î¬ÏƒÎºÎ·ÏƒÎ·Ï‚ ÎµÎ¯Î½Î±Î¹ Î½Î± Ï„Î± Ï€ÏÎ¿ÏƒÎ´Î¹Î¿ÏÎ¯ÏƒÎµÏ„Îµ ÏƒÏ‰ÏƒÏ„Î¬."

#: src/exercises/day-3/points-polygons.md:120
msgid "Other interesting parts of the exercise:"
msgstr ""

#: src/exercises/day-3/points-polygons.md:122
#, fuzzy
msgid ""
"Derive a `Copy` trait for some structs, as in tests the methods sometimes "
"don't borrow their arguments."
msgstr "Î†Î»Î»Î± ÎµÎ½Î´Î¹Î±Ï†Î­ÏÎ¿Î½Ï„Î± Î¼Î­ÏÎ· Ï„Î·Ï‚ Î¬ÏƒÎºÎ·ÏƒÎ·Ï‚:"

#: src/exercises/day-3/points-polygons.md:123
#, fuzzy
msgid ""
"Discover that `Add` trait must be implemented for two objects to be addable "
"via \"+\". Note that we do not discuss generics until Day 3."
msgstr ""
"Î•Î¾Î¬Î³ÎµÏ„Îµ Î­Î½Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«Î‘Î½Ï„Î¹Î³ÏÎ±Ï†Î®Â» Î³Î¹Î± Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î´Î¿Î¼Î­Ï‚, ÎºÎ±Î¸ÏÏ‚ ÏƒÏ„Î¹Ï‚ "
"Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Î¿Î¹ Î¼Î­Î¸Î¿Î´Î¿Î¹ Î¼ÎµÏÎ¹ÎºÎ­Ï‚ Ï†Î¿ÏÎ­Ï‚ Î´ÎµÎ½ Î´Î±Î½ÎµÎ¯Î¶Î¿Î½Ï„Î±Î¹ Ï„Î± ÎµÏ€Î¹Ï‡ÎµÎ¹ÏÎ®Î¼Î±Ï„Î¬ Ï„Î¿Ï…Ï‚.\n"
"\n"
"Î‘Î½Î±ÎºÎ±Î»ÏÏˆÏ„Îµ ÏŒÏ„Î¹ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Â» Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÏ†Î±ÏÎ¼Î¿ÏƒÏ„ÎµÎ¯ Î³Î¹Î± Î´ÏÎ¿ "
"Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Ï€Î¿Ï… Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸Î¿ÏÎ½ Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… Â«+Â»."

#: src/error-handling.md:3
#, fuzzy
msgid "Error handling in Rust is done using explicit control flow:"
msgstr ""
"ÎŸ Ï‡ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ ÏƒÏ„Î¿ Rust Î³Î¯Î½ÎµÏ„Î±Î¹ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ ÏÎ·Ï„Î® ÏÎ¿Î® ÎµÎ»Î­Î³Ï‡Î¿Ï…:"

#: src/error-handling.md:5
#, fuzzy
msgid "Functions that can have errors list this in their return type,"
msgstr ""
"ÎŸÎ¹ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡Î¿Ï…Î½ ÏƒÏ†Î¬Î»Î¼Î±Ï„Î± Ï„Î¿ Î±Î½Î±Ï†Î­ÏÎ¿Ï…Î½ ÏƒÏ„Î¿Î½ Ï„ÏÏ€Î¿ "
"ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚ Ï„Î¿Ï…Ï‚,"

#: src/error-handling.md:6
#, fuzzy
msgid "There are no exceptions."
msgstr "Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÎµÎ¾Î±Î¹ÏÎ­ÏƒÎµÎ¹Ï‚."

#: src/error-handling/panics.md:3
#, fuzzy
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr ""
"Î¤Î¿ Rust Î¸Î± Ï€ÏÎ¿ÎºÎ±Î»Î­ÏƒÎµÎ¹ Ï€Î±Î½Î¹ÎºÏŒ ÎµÎ¬Î½ ÏƒÏ…Î¼Î²ÎµÎ¯ Î­Î½Î± Î¼Î¿Î¹ÏÎ±Î¯Î¿ ÏƒÏ†Î¬Î»Î¼Î± ÎºÎ±Ï„Î¬ Ï„Î· Î´Î¹Î¬ÏÎºÎµÎ¹Î± "
"Ï„Î·Ï‚ ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚:"

#: src/error-handling/panics.md:5
msgid ""
"```rust,editable,should_panic\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    println!(\"v[100]: {}\", v[100]);\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panics.md:12
#, fuzzy
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "ÎŸÎ¹ Ï€Î±Î½Î¹ÎºÎ¿Î¯ Î±Ï†Î¿ÏÎ¿ÏÎ½ Î¼Î· Î±Î½Î±ÏƒÏ„ÏÎ­ÏˆÎ¹Î¼Î± ÎºÎ±Î¹ Î±Ï€ÏÎ¿ÏƒÎ´ÏŒÎºÎ·Ï„Î± ÏƒÏ†Î¬Î»Î¼Î±Ï„Î±."

#: src/error-handling/panics.md:13
#, fuzzy
msgid "Panics are symptoms of bugs in the program."
msgstr "ÎŸÎ¹ Ï€Î±Î½Î¹ÎºÎ¿Î¯ ÎµÎ¯Î½Î±Î¹ ÏƒÏ…Î¼Ï€Ï„ÏÎ¼Î±Ï„Î± ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ ÏƒÏ„Î¿ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î±."

#: src/error-handling/panics.md:14
#, fuzzy
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ API Ï€Î¿Ï… Î´ÎµÎ½ Ï€ÏÎ¿ÎºÎ±Î»Î¿ÏÎ½ Ï€Î±Î½Î¹ÎºÏŒ (ÏŒÏ€Ï‰Ï‚ \"Vec::get\") ÎµÎ¬Î½ Ï„Î¿ "
"ÏƒÏ†Î¬Î»Î¼Î± Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î¿Î´ÎµÎºÏ„ÏŒ."

#: src/error-handling/panic-unwind.md:1
#, fuzzy
msgid "Catching the Stack Unwinding"
msgstr "Î‘Î»Î¯ÎµÏ…ÏƒÎ· Ï„Î·Ï‚ ÏƒÏ„Î¿Î¯Î²Î±Ï‚ ÎÎµÏ„ÏÎ»Î¹Î³Î¼Î±"

#: src/error-handling/panic-unwind.md:3
#, fuzzy
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr ""
"Î‘Ï€ÏŒ Ï€ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î®, Î­Î½Î±Ï‚ Ï€Î±Î½Î¹ÎºÏŒÏ‚ Î¸Î± Ï€ÏÎ¿ÎºÎ±Î»Î­ÏƒÎµÎ¹ Ï„Î¿ Î¾ÎµÏ„ÏÎ»Î¹Î³Î¼Î± Ï„Î·Ï‚ ÏƒÏ„Î¿Î¯Î²Î±Ï‚. Î¤Î¿ "
"Î¾ÎµÏ„ÏÎ»Î¹Î³Î¼Î± Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€Î¹Î±ÏƒÏ„ÎµÎ¯:"

#: src/error-handling/panic-unwind.md:5
msgid ""
"```rust,editable\n"
"use std::panic;\n"
"\n"
"fn main() {\n"
"    let result = panic::catch_unwind(|| {\n"
"        println!(\"hello!\");\n"
"    });\n"
"    assert!(result.is_ok());\n"
"    \n"
"    let result = panic::catch_unwind(|| {\n"
"        panic!(\"oh no!\");\n"
"    });\n"
"    assert!(result.is_err());\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/panic-unwind.md:21
#, fuzzy
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"Î‘Ï…Ï„ÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ ÏƒÎµ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚ Ï€Î¿Ï… Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎ¿Ï…Î½ Î½Î± "
"ÎµÎºÏ„ÎµÎ»Î¿ÏÎ½Ï„Î±Î¹ Î±ÎºÏŒÎ¼Î± ÎºÎ±Î¹ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î¼ÏŒÎ½Î¿Î¹ ÎºÎ¿Î»Î»Î¬ÎµÎ¹ Ï„Î¿ Î±Î¯Ï„Î·Î¼Î±."

#: src/error-handling/panic-unwind.md:23
#, fuzzy
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr ""
"Î‘Ï…Ï„ÏŒ Î´ÎµÎ½ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÎµÎ¬Î½ Ï„Î¿ \"panic = \"abort\" Î­Ï‡ÎµÎ¹ Î¿ÏÎ¹ÏƒÏ„ÎµÎ¯ ÏƒÏ„Î¿ \"Cargo."
"toml\"."

#: src/error-handling/result.md:1
#, fuzzy
msgid "Structured Error Handling with `Result`"
msgstr "Î§ÎµÎ¹ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Î´Î¿Î¼Î·Î¼Î­Î½Î¿Ï… ÏƒÏ†Î¬Î»Î¼Î±Ï„Î¿Ï‚ Î¼Îµ Â«Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±Â»."

#: src/error-handling/result.md:3
#, fuzzy
msgid ""
"We have already seen the `Result` enum. This is used pervasively when errors "
"are expected as part of normal operation:"
msgstr ""
"ÎˆÏ‡Î¿Ï…Î¼Îµ Î®Î´Î· Î´ÎµÎ¹ Ï„Î¿Î½ Î±ÏÎ¹Î¸Î¼ÏŒ Â«Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±Â». Î‘Ï…Ï„ÏŒ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ ÎµÏ…ÏÎ­Ï‰Ï‚ ÏŒÏ„Î±Î½ "
"Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ†Î¬Î»Î¼Î±Ï„Î± Î±Î½Î±Î¼Î­Î½ÎµÏ„Î±Î¹ Ï‰Ï‚ Î¼Î­ÏÎ¿Ï‚ Ï„Î·Ï‚ ÎºÎ±Î½Î¿Î½Î¹ÎºÎ®Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±Ï‚:"

#: src/error-handling/result.md:6
msgid ""
"```rust,editable\n"
"use std::fs;\n"
"use std::io::Read;\n"
"\n"
"fn main() {\n"
"    let file = fs::File::open(\"diary.txt\");\n"
"    match file {\n"
"        Ok(mut file) => {\n"
"            let mut contents = String::new();\n"
"            file.read_to_string(&mut contents);\n"
"            println!(\"Dear diary: {contents}\");\n"
"        },\n"
"        Err(err) => {\n"
"            println!(\"The diary could not be opened: {err}\");\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/result.md:27
#, fuzzy
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"ÎŒÏ€Ï‰Ï‚ ÎºÎ±Î¹ Î¼Îµ Ï„Î·Î½ \"Î•Ï€Î¹Î»Î¿Î³Î®\", Î· ÎµÏ€Î¹Ï„Ï…Ï‡Î·Î¼Î­Î½Î· Ï„Î¹Î¼Î® Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ "
"\"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\", Î±Î½Î±Î³ÎºÎ¬Î¶Î¿Î½Ï„Î±Ï‚ Ï„Î¿Î½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î® Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÎ¹ Ï„Î¿ ÎµÎ¾Î¬Î³ÎµÏ„Îµ ÏÎ·Ï„Î¬. "
"Î‘Ï…Ï„ÏŒ ÎµÎ½Î¸Î±ÏÏÏÎ½ÎµÎ¹ Ï„Î¿Î½ Î­Î»ÎµÎ³Ï‡Î¿ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½. Î£Ï„Î·Î½ Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· Ï€Î¿Ï… Î´ÎµÎ½ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"ÏƒÏ…Î¼Î²ÎµÎ¯ Ï€Î¿Ï„Î­ Î»Î¬Î¸Î¿Ï‚, Î¤Î¿ \"unwrap()\" Î® Ï„Î¿ \"expect()\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎºÎ»Î·Î¸ÎµÎ¯, ÎºÎ±Î¹ "
"Î±Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î­Î½Î± ÏƒÎ®Î¼Î± Ï„Î·Ï‚ Ï€ÏÏŒÎ¸ÎµÏƒÎ·Ï‚ Ï„Î¿Ï… Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î®."

#: src/error-handling/result.md:30
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning.  It contains a lot of convenience methods and functions "
"that help functional-style programming. "
msgstr ""
"Î— Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ· Â«Î‘Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î¿Ï‚Â» ÏƒÏ…Î½Î¹ÏƒÏ„Î¬Ï„Î±Î¹ Î³Î¹Î± Î±Î½Î¬Î³Î½Ï‰ÏƒÎ·. ÎŒÏ‡Î¹ ÎºÎ±Ï„Î¬ Ï„Î· Î´Î¹Î¬ÏÎºÎµÎ¹Î± "
"Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚, Î±Î»Î»Î¬ Î±Î¾Î¯Î¶ÎµÎ¹ Î½Î± Î±Î½Î±Ï†ÎµÏÎ¸ÎµÎ¯. Î ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Ï€Î¿Î»Î»Î­Ï‚ Ï€ÏÎ±ÎºÏ„Î¹ÎºÎ­Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï…Ï‚ "
"ÎºÎ±Î¹ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Ï€Î¿Ï… Î²Î¿Î·Î¸Î¿ÏÎ½ Ï„Î¿Î½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼ÏŒ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ¿Ï ÏƒÏ„Ï…Î»."

#: src/error-handling/try-operator.md:1
#, fuzzy
msgid "Propagating Errors with `?`"
msgstr "Î£Ï†Î¬Î»Î¼Î±Ï„Î± Î´Î¹Î¬Î´Î¿ÏƒÎ·Ï‚ Î¼Îµ Ï„Î¿ \"?\"."

#: src/error-handling/try-operator.md:3
#, fuzzy
msgid ""
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"ÎŸ Ï„ÎµÎ»ÎµÏƒÏ„Î®Ï‚ Î´Î¿ÎºÎ¹Î¼Î®Ï‚ `?` Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î³Î¹Î± Ï„Î·Î½ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ ÏƒÏ„Î¿Î½ "
"ÎºÎ±Î»Î¿ÏÎ½Ï„Î±. Î£Î±Ï‚ Î±Ï†Î®Î½ÎµÎ¹ Î½Î± ÏƒÏ„ÏÎ¯ÏˆÎµÏ„Îµ Ï„Î¿ ÎºÎ¿Î¹Î½ÏŒ"

#: src/error-handling/try-operator.md:6
msgid ""
"```rust,ignore\n"
"match some_expression {\n"
"    Ok(value) => value,\n"
"    Err(err) => return Err(err),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:13
#, fuzzy
msgid "into the much simpler"
msgstr "ÏƒÏ„Î¿ Ï€Î¿Î»Ï Ï€Î¹Î¿ Î±Ï€Î»ÏŒ"

#: src/error-handling/try-operator.md:15
msgid ""
"```rust,ignore\n"
"some_expression?\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:19
#, fuzzy
msgid "We can use this to simplify our error handling code:"
msgstr ""
"ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Ï„Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Î³Î¹Î± Î½Î± Î±Ï€Î»Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Î½ ÎºÏ‰Î´Î¹ÎºÏŒ Ï€Î±ÏÎ¬Î´Î¿ÏƒÎ·Ï‚ "
"ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½:"

#: src/error-handling/try-operator.md:21
msgid ""
"```rust,editable\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"\n"
"fn read_username(path: &str) -> Result<String, io::Error> {\n"
"    let username_file_result = fs::File::open(path);\n"
"    let mut username_file = match username_file_result {\n"
"        Ok(file) => file,\n"
"        Err(err) => return Err(err),\n"
"    };\n"
"\n"
"    let mut username = String::new();\n"
"    match username_file.read_to_string(&mut username) {\n"
"        Ok(_) => Ok(username),\n"
"        Err(err) => Err(err),\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"alice\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/try-operator.md:50
#: src/error-handling/converting-error-types-example.md:52
#, fuzzy
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr ""
"Î— Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® \"username\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ ÎµÎ¯Ï„Îµ \"Ok(string)\" ÎµÎ¯Ï„Îµ "
"\"Err(error)\"."

#: src/error-handling/try-operator.md:51
#: src/error-handling/converting-error-types-example.md:53
#, fuzzy
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î·Î½ ÎºÎ»Î®ÏƒÎ· `fs::write` Î³Î¹Î± Î½Î± Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÎµÏ„Îµ Ï„Î± Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¬ "
"ÏƒÎµÎ½Î¬ÏÎ¹Î±: ÎºÎ±Î½Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿, ÎºÎµÎ½ÏŒ Î±ÏÏ‡ÎµÎ¯Î¿, Î±ÏÏ‡ÎµÎ¯Î¿ Î¼Îµ ÏŒÎ½Î¿Î¼Î± Ï‡ÏÎ®ÏƒÏ„Î·."

#: src/error-handling/try-operator.md:52
msgid ""
"The return type of the function has to be compatible with the nested "
"functions it calls. For instance, a function returning a `Result<T, Err>` "
"can only apply the `?` operator on a function returning a  `Result<AnyT, "
"Err>`. It cannot apply the `?` operator on a function returning an "
"`Option<AnyT>` or `Result<T, OtherErr>` unless `OtherErr` implements "
"`From<Err>`. Reciprocally, a function returning an `Option<T>` can only "
"apply the `?` operator  on a function returning an `Option<AnyT>`."
msgstr ""

#: src/error-handling/try-operator.md:57
msgid ""
"You can convert incompatible types into one another with the different "
"`Option` and `Result` methods  such as `Option::ok_or`, `Result::ok`, "
"`Result::err`."
msgstr ""

#: src/error-handling/converting-error-types.md:3
#, fuzzy
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr ""
"Î— Î±Ï€Î¿Ï„ÎµÎ»ÎµÏƒÎ¼Î±Ï„Î¹ÎºÎ® ÎµÏ€Î­ÎºÏ„Î±ÏƒÎ· Ï„Î¿Ï… Â«?Â» ÎµÎ¯Î½Î±Î¹ Î»Î¯Î³Î¿ Ï€Î¹Î¿ Ï€ÎµÏÎ¯Ï€Î»Î¿ÎºÎ· Î±Ï€ÏŒ ÏŒ,Ï„Î¹ "
"Î±Î½Î±Ï†Î­ÏÎ¸Î·ÎºÎµ Ï€ÏÎ¿Î·Î³Î¿Ï…Î¼Î­Î½Ï‰Ï‚:"

#: src/error-handling/converting-error-types.md:5
msgid ""
"```rust,ignore\n"
"expression?\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:9
#, fuzzy
msgid "works the same as"
msgstr "Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Ï„Î¿ Î¯Î´Î¹Î¿ Î¼Îµ"

#: src/error-handling/converting-error-types.md:11
msgid ""
"```rust,ignore\n"
"match expression {\n"
"    Ok(value) => value,\n"
"    Err(err)  => return Err(From::from(err)),\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types.md:18
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function:"
msgstr ""
"Î— ÎºÎ»Î®ÏƒÎ· \"From::from\" ÎµÎ´Ï ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î¿ÏÎ¼Îµ Î½Î± Î¼ÎµÏ„Î±Ï„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ Ï„Î¿Î½ Ï„ÏÏ€Î¿ "
"ÏƒÏ†Î¬Î»Î¼Î±Ï„Î¿Ï‚ ÏƒÏ„Î¿ Ï„ÏÏ€Î¿Ï‚ Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Ï„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·:"

#: src/error-handling/converting-error-types-example.md:3
msgid ""
"```rust,editable\n"
"use std::error::Error;\n"
"use std::fmt::{self, Display, Formatter};\n"
"use std::fs::{self, File};\n"
"use std::io::{self, Read};\n"
"\n"
"#[derive(Debug)]\n"
"enum ReadUsernameError {\n"
"    IoError(io::Error),\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"impl Error for ReadUsernameError {}\n"
"\n"
"impl Display for ReadUsernameError {\n"
"    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n"
"        match self {\n"
"            Self::IoError(e) => write!(f, \"IO error: {e}\"),\n"
"            Self::EmptyUsername(filename) => write!(f, \"Found no username "
"in {filename}\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl From<io::Error> for ReadUsernameError {\n"
"    fn from(err: io::Error) -> ReadUsernameError {\n"
"        ReadUsernameError::IoError(err)\n"
"    }\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::with_capacity(100);\n"
"    File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    let username = read_username(\"config.dat\");\n"
"    println!(\"username or error: {username:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/converting-error-types-example.md:55
msgid ""
"It is good practice for all error types that don't need to be `no_std` to "
"implement `std::error::Error`, which requires `Debug` and `Display`. The "
"`Error` crate for `core` is only available in [nightly](https://github.com/"
"rust-lang/rust/issues/103765), so not fully `no_std` compatible yet."
msgstr ""

#: src/error-handling/converting-error-types-example.md:57
#, fuzzy
msgid ""
"It's generally helpful for them to implement `Clone` and `Eq` too where "
"possible, to make life easier for tests and consumers of your library. In "
"this case we can't easily do so, because `io::Error` doesn't implement them."
msgstr ""
"Î•Î¯Î½Î±Î¹ ÎºÎ±Î»Î® Ï€ÏÎ±ÎºÏ„Î¹ÎºÎ® Î³Î¹Î± ÏŒÎ»Î¿Ï…Ï‚ Ï„Î¿Ï…Ï‚ Ï„ÏÏ€Î¿Ï…Ï‚ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Ï„Î¿ \"std::"
"error::Error\", Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ Î±Ï€Î±Î¹Ï„ÎµÎ¯ \"Debug\" ÎºÎ±Î¹ 'Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ·'. Î•Î¯Î½Î±Î¹ Î³ÎµÎ½Î¹ÎºÎ¬ "
"Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ Î³Î¹ 'Î±Ï…Ï„Î¿ÏÏ‚ Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎ¿Ï…Î½ Ï„Î¿ \"Clone\" ÎºÎ±Î¹ Ï„Î¿ \"Eq\" ÏŒÏ€Î¿Ï… ÎµÎ¯Î½Î±Î¹ "
"Î´Ï…Î½Î±Ï„ÏŒÎ½ ÎµÏ…ÎºÎ¿Î»ÏŒÏ„ÎµÏÎ· Î¶Ï‰Î® Î³Î¹Î± Ï„Î± Ï„ÎµÏƒÏ„ ÎºÎ±Î¹ Ï„Î¿Ï…Ï‚ ÎºÎ±Ï„Î±Î½Î±Î»Ï‰Ï„Î­Ï‚ Ï„Î·Ï‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚ ÏƒÎ±Ï‚. "
"Î£Îµ Î±Ï…Ï„Î® Ï„Î·Î½ Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· Î´ÎµÎ½ Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ ÎµÏÎºÎ¿Î»Î± Î½Î± Ï„Î¿ ÎºÎ¬Î½Î¿Ï…Î¼Îµ, Î³Î¹Î±Ï„Î¯ Î¤Î¿ `io::"
"Error` Î´ÎµÎ½ Ï„Î± Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯."

#: src/error-handling/deriving-error-enums.md:3
#, fuzzy
msgid ""
"The [thiserror](https://docs.rs/thiserror/) crate is a popular way to create "
"an error enum like we did on the previous page:"
msgstr ""
"Î¤Î¿ ÎºÎ¹Î²ÏÏ„Î¹Î¿ [thiserror](https://docs.rs/thiserror/) ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Î´Î·Î¼Î¿Ï†Î¹Î»Î®Ï‚ "
"Ï„ÏÏŒÏ€Î¿Ï‚ Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î±Ï‚ enum ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ ÏŒÏ€Ï‰Ï‚ ÎºÎ¬Î½Î±Î¼Îµ ÏƒÏ„Î·Î½ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î· ÏƒÎµÎ»Î¯Î´Î±:"

#: src/error-handling/deriving-error-enums.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Debug, Error)]\n"
"enum ReadUsernameError {\n"
"    #[error(\"Could not read: {0}\")]\n"
"    IoError(#[from] io::Error),\n"
"    #[error(\"Found no username in {0}\")]\n"
"    EmptyUsername(String),\n"
"}\n"
"\n"
"fn read_username(path: &str) -> Result<String, ReadUsernameError> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(ReadUsernameError::EmptyUsername(String::from(path)));\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/deriving-error-enums.md:39
#, fuzzy
msgid ""
"`thiserror`'s derive macro automatically implements `std::error::Error`, and "
"optionally `Display` (if the `#[error(...)]` attributes are provided) and "
"`From` (if the `#[from]` attribute is added). It also works for structs."
msgstr ""
"Î— Î¼Î±ÎºÏÎ¿ÎµÎ½Ï„Î¿Î»Î® ÎµÎ¾Î±Î³Ï‰Î³Î®Ï‚ \"thiserror\" ÎµÏ†Î±ÏÎ¼ÏŒÎ¶ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï„Î¿ \"std::error::"
"Error\" ÎºÎ±Î¹ Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÎ¬ Ï„Î¿ \"Display\" (ÎµÎ¬Î½ Ï€Î±ÏÎ­Ï‡Î¿Î½Ï„Î±Î¹ Ï„Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ "
"\"#\\[ÏƒÏ†Î¬Î»Î¼Î±(...)\\]\") ÎºÎ±Î¹ \"Î‘Ï€ÏŒ\" (Î±Î½ Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ "
"\"#\\[Î±Ï€ÏŒ\\]\". Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î³Î¹Î± Î´Î¿Î¼Î­Ï‚."

#: src/error-handling/deriving-error-enums.md:43
#, fuzzy
msgid "It doesn't affect your public API, which makes it good for libraries."
msgstr ""
"Î”ÎµÎ½ ÎµÏ€Î·ÏÎµÎ¬Î¶ÎµÎ¹ Ï„Î¿ Î´Î·Î¼ÏŒÏƒÎ¹Î¿ API ÏƒÎ±Ï‚, ÎºÎ¬Ï„Î¹ Ï€Î¿Ï… Ï„Î¿ ÎºÎ¬Î½ÎµÎ¹ ÎºÎ±Î»ÏŒ Î³Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚."

#: src/error-handling/dynamic-errors.md:3
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. `std::error::Error` "
"makes this easy."
msgstr ""
"ÎœÎµÏÎ¹ÎºÎ­Ï‚ Ï†Î¿ÏÎ­Ï‚ Î¸Î­Î»Î¿Ï…Î¼Îµ Î½Î± ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ Ï„Î·Î½ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Î¿Ï€Î¿Î¹Î¿Ï…Î´Î®Ï€Î¿Ï„Îµ Ï„ÏÏ€Î¿Ï… "
"ÏƒÏ†Î¬Î»Î¼Î±Ï„Î¿Ï‚ Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Î³ÏÎ¬ÏˆÎ¿Ï…Î¼Îµ Ï„Î¿ Î´Î¹ÎºÏŒ Î¼Î±Ï‚ ÎºÎ¬Î»Ï…Î¼Î¼Î± enum ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ "
"Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„ÎµÏ‚. Î¤Î¿ `std::error::Error` Ï„Î¿ ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ ÎµÏÎºÎ¿Î»Î¿."

#: src/error-handling/dynamic-errors.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use std::fs;\n"
"use std::io::Read;\n"
"use thiserror::Error;\n"
"use std::error::Error;\n"
"\n"
"#[derive(Clone, Debug, Eq, Error, PartialEq)]\n"
"#[error(\"Found no username in {0}\")]\n"
"struct EmptyUsernameError(String);\n"
"\n"
"fn read_username(path: &str) -> Result<String, Box<dyn Error>> {\n"
"    let mut username = String::new();\n"
"    fs::File::open(path)?.read_to_string(&mut username)?;\n"
"    if username.is_empty() {\n"
"        return Err(EmptyUsernameError(String::from(path)).into());\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/dynamic-errors.md:36
#, fuzzy
msgid ""
"This saves on code, but gives up the ability to cleanly handle different "
"error cases differently in the program. As such it's generally not a good "
"idea to use `Box<dyn Error>` in the public API of a library, but it can be a "
"good option in a program where you just want to display the error message "
"somewhere."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÎµÎ¾Î¿Î¹ÎºÎ¿Î½Î¿Î¼ÎµÎ¯ ÎºÏÎ´Î¹ÎºÎ±, Î±Î»Î»Î¬ Ï€Î±ÏÎ±Î¹Ï„ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î· Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„Î± ÎºÎ±Î¸Î±ÏÎ®Ï‚ "
"Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ·Ï‚ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏÎ½ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÏ‰Î½ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ Î¼Îµ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÏŒ Ï„ÏÏŒÏ€Î¿ Ï„Î¿ "
"Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î±. Î©Ï‚ ÎµÎº Ï„Î¿ÏÏ„Î¿Ï…, Î³ÎµÎ½Î¹ÎºÎ¬ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎºÎ±Î»Î® Î¹Î´Î­Î± Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ "
"\"Box\n"
"\n"
"\" ÏƒÏ„Î¿ Î´Î·Î¼ÏŒÏƒÎ¹Î¿ API ÎµÎ½ÏŒÏ‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·, Î±Î»Î»Î¬ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÎºÎ±Î»Î® ÎµÏ€Î¹Î»Î¿Î³Î® ÏƒÎµ "
"Î­Î½Î± Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± ÏŒÏ€Î¿Ï… Î¸Î­Î»ÎµÏ„Îµ Î±Ï€Î»ÏÏ‚ Î½Î± ÎµÎ¼Ï†Î±Î½Î¯ÏƒÎµÏ„Îµ Ï„Î¿ Î¼Î®Î½Ï…Î¼Î± ÏƒÏ†Î¬Î»Î¼Î±Ï„Î¿Ï‚ ÎºÎ¬Ï€Î¿Ï…."

#: src/error-handling/error-contexts.md:3
#, fuzzy
msgid ""
"The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
"contextual information to your errors and allows you to have fewer custom "
"error types:"
msgstr ""
"Î¤Î¿ ÎµÏ…ÏÎ­Ï‰Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼ÎµÎ½Î¿ ÎºÎ¹Î²ÏÏ„Î¹Î¿ [anyhow](https://docs.rs/anyhow/) Î¼Ï€Î¿ÏÎµÎ¯ "
"Î½Î± ÏƒÎ±Ï‚ Î²Î¿Î·Î¸Î®ÏƒÎµÎ¹ Î½Î± Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÎµÏ„Îµ Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ Î³Î¹Î± Ï„Î± Î»Î¬Î¸Î· ÏƒÎ±Ï‚ ÎºÎ±Î¹ ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ "
"Î½Î± Î­Ï‡ÎµÏ„Îµ Î»Î¹Î³ÏŒÏ„ÎµÏÎ± Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½Î¿Î¹ Ï„ÏÏ€Î¿Î¹ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½:"

#: src/error-handling/error-contexts.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use std::{fs, io};\n"
"use std::io::Read;\n"
"use anyhow::{Context, Result, bail};\n"
"\n"
"fn read_username(path: &str) -> Result<String> {\n"
"    let mut username = String::with_capacity(100);\n"
"    fs::File::open(path)\n"
"        .with_context(|| format!(\"Failed to open {path}\"))?\n"
"        .read_to_string(&mut username)\n"
"        .context(\"Failed to read\")?;\n"
"    if username.is_empty() {\n"
"        bail!(\"Found no username in {path}\");\n"
"    }\n"
"    Ok(username)\n"
"}\n"
"\n"
"fn main() {\n"
"    //fs::write(\"config.dat\", \"\").unwrap();\n"
"    match read_username(\"config.dat\") {\n"
"        Ok(username) => println!(\"Username: {username}\"),\n"
"        Err(err)     => println!(\"Error: {err:?}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/error-handling/error-contexts.md:35
#, fuzzy
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr ""
"Î¤Î¿ `Î¿ÏÏ„Ï‰Ï‚ Î® Î¬Î»Î»Ï‰Ï‚::Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±<V>` ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏˆÎµÏ…Î´ÏÎ½Ï…Î¼Î¿ Ï„ÏÏ€Î¿Ï… Î³Î¹Î± Ï„Î¿ "
"\"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\\<V, Î¿ÏÏ„Ï‰Ï‚ Î® Î¬Î»Î»Ï‰Ï‚::Î£Ï†Î¬Î»Î¼Î±>\"."

#: src/error-handling/error-contexts.md:36
#, fuzzy
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr ""
"Î¤Î¿ \"anyhow::Error\" ÎµÎ¯Î½Î±Î¹ Î¿Ï…ÏƒÎ¹Î±ÏƒÏ„Î¹ÎºÎ¬ Î­Î½Î± Ï€ÎµÏÎ¹Ï„ÏÎ»Î¹Î³Î¼Î± Î³ÏÏÏ‰ Î±Ï€ÏŒ Ï„Î¿ \"Box"

#: src/error-handling/error-contexts.md:38
#, fuzzy
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr ""
"\". Î©Ï‚ Ï„Î­Ï„Î¿Î¹Î¿ ÎºÎ±Î¹ Ï€Î¬Î»Î¹ Î³ÎµÎ½Î¹ÎºÎ¬ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÎºÎ±Î»Î® ÎµÏ€Î¹Î»Î¿Î³Î® Î³Î¹Î± Ï„Î¿ Î´Î·Î¼ÏŒÏƒÎ¹Î¿ API "
"Î¼Î¹Î±Ï‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚, Î±Î»Î»Î¬ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ ÎµÏ…ÏÎ­Ï‰Ï‚ ÏƒÎµ ÎµÏ†Î±ÏÎ¼Î¿Î³Î­Ï‚."

#: src/error-handling/error-contexts.md:39
#, fuzzy
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"ÎŸ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒÏ‚ Ï„ÏÏ€Î¿Ï‚ ÏƒÏ†Î¬Î»Î¼Î±Ï„Î¿Ï‚ ÏƒÏ„Î¿ ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÏŒ Ï„Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¾Î±Ï‡Î¸ÎµÎ¯ Î³Î¹Î± "
"ÎµÎ¾Î­Ï„Î±ÏƒÎ· ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ Î±Ï€Î±ÏÎ±Î¯Ï„Î·Ï„Î¿.\n"
"\n"
"Î— Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± Ï€Î¿Ï… Ï€Î±ÏÎ­Ï‡ÎµÏ„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿ \"anyhow::Result\n"
"\n"
"\" Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¿Î¹ÎºÎµÎ¯Î± ÏƒÏ„Î¿Ï…Ï‚ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚ Ï„Î·Ï‚ Go, ÎºÎ±Î¸ÏÏ‚ Ï€Î±ÏÎ­Ï‡ÎµÎ¹ "
"Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Î¿Ï„Î¯Î²Î± Ï‡ÏÎ®ÏƒÎ·Ï‚ ÎºÎ±Î¹ ÎµÏÎ³Î¿Î½Î¿Î¼Î¯Î± Î¼Îµ Ï„Î¿ Â«(T, error)Â» Î±Ï€ÏŒ Ï„Î¿ Go."

#: src/testing.md:3
#, fuzzy
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Î¤Î¿ Rust and Cargo ÏƒÏ…Î½Î¿Î´ÎµÏÎµÏ„Î±Î¹ Î±Ï€ÏŒ Î­Î½Î± Î±Ï€Î»ÏŒ Ï€Î»Î±Î¯ÏƒÎ¹Î¿ Î´Î¿ÎºÎ¹Î¼Î®Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚:"

#: src/testing.md:5
#, fuzzy
msgid "Unit tests are supported throughout your code."
msgstr "ÎŸÎ¹ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ ÎµÎ½ÏƒÏ‰Î¼Î¬Ï„Ï‰ÏƒÎ·Ï‚ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶Î¿Î½Ï„Î±Î¹ Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… ÎºÎ±Ï„Î±Î»ÏŒÎ³Î¿Ï… Â«tests/Â»."

#: src/testing.md:7
msgid "Integration tests are supported via the `tests/` directory."
msgstr ""

#: src/testing/unit-tests.md:3
#, fuzzy
msgid "Mark unit tests with `#[test]`:"
msgstr "Î•Ï€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Ï„Î¹Ï‚ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚ Î¼Îµ Â«#\\[test\\]Â»:"

#: src/testing/unit-tests.md:5
msgid ""
"```rust,editable,ignore\n"
"fn first_word(text: &str) -> &str {\n"
"    match text.find(' ') {\n"
"        Some(idx) => &text[..idx],\n"
"        None => &text,\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty() {\n"
"    assert_eq!(first_word(\"\"), \"\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_word() {\n"
"    assert_eq!(first_word(\"Hello\"), \"Hello\");\n"
"}\n"
"\n"
"#[test]\n"
"fn test_multiple_words() {\n"
"    assert_eq!(first_word(\"Hello World\"), \"Hello\");\n"
"}\n"
"```"
msgstr ""

#: src/testing/unit-tests.md:29
#, fuzzy
msgid "Use `cargo test` to find and run the unit tests."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î· Â«Î´Î¿ÎºÎ¹Î¼Î® Ï†Î¿ÏÏ„Î¯Î¿Ï…Â» Î³Î¹Î± Î½Î± Î²ÏÎµÎ¯Ï„Îµ ÎºÎ±Î¹ Î½Î± ÎµÎºÏ„ÎµÎ»Î­ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ "
"Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚."

#: src/testing/test-modules.md:3
#, fuzzy
msgid ""
"Unit tests are often put in a nested module (run tests on the [Playground]"
"(https://play.rust-lang.org/)):"
msgstr ""
"ÎŸÎ¹ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Î¼Î¿Î½Î¬Î´Î±Ï‚ Ï„Î¿Ï€Î¿Î¸ÎµÏ„Î¿ÏÎ½Ï„Î±Î¹ ÏƒÏ…Ï‡Î½Î¬ ÏƒÎµ Î¼Î¹Î± Î­Î½Î¸ÎµÏ„Î· ÎµÎ½ÏŒÏ„Î·Ï„Î± (ÎµÎºÏ„ÎµÎ»Î­ÏƒÏ„Îµ "
"Î´Î¿ÎºÎ¹Î¼Î­Ï‚ ÏƒÏ„Î¿ [Î Î±Î¹Î´Î¹ÎºÎ® Ï‡Î±ÏÎ¬](https://play.rust-lang.org/)):"

#: src/testing/test-modules.md:6
msgid ""
"```rust,editable\n"
"fn helper(a: &str, b: &str) -> String {\n"
"    format!(\"{a} {b}\")\n"
"}\n"
"\n"
"pub fn main() {\n"
"    println!(\"{}\", helper(\"Hello\", \"World\"));\n"
"}\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    #[test]\n"
"    fn test_helper() {\n"
"        assert_eq!(helper(\"foo\", \"bar\"), \"foo bar\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/testing/test-modules.md:26
#, fuzzy
msgid "This lets you unit test private helpers."
msgstr "Î‘Ï…Ï„ÏŒ ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÎµÏ„Îµ Î¹Î´Î¹Ï‰Ï„Î¹ÎºÎ¿ÏÏ‚ Î²Î¿Î·Î¸Î¿ÏÏ‚ Î¼Î¿Î½Î¬Î´Î±Ï‚."

#: src/testing/test-modules.md:27
#, fuzzy
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr ""
"Î¤Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Â«#\\[cfg(test)\\]Â» ÎµÎ¯Î½Î±Î¹ ÎµÎ½ÎµÏÎ³ÏŒ Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Îµ "
"Â«Î´Î¿ÎºÎ¹Î¼Î® Ï†Î¿ÏÏ„Î¯Î¿Ï…Â»."

#: src/testing/doc-tests.md:3
#, fuzzy
msgid "Rust has built-in support for documentation tests:"
msgstr "Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î· Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ·Ï‚:"

#: src/testing/doc-tests.md:5
msgid ""
"```rust\n"
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
"pub fn shorten_string(s: &str, length: usize) -> &str {\n"
"    &s[..std::cmp::min(length, s.len())]\n"
"}\n"
"```"
msgstr ""

#: src/testing/doc-tests.md:18
#, fuzzy
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr ""
"Î¤Î± Î¼Ï€Î»Î¿Îº ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î± ÏƒÏ‡ÏŒÎ»Î¹Î± `///` ÎµÎ¼Ï†Î±Î½Î¯Î¶Î¿Î½Ï„Î±Î¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï‰Ï‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Rust."

#: src/testing/doc-tests.md:19
#, fuzzy
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr ""
"ÎŸ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Î¸Î± Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„ÎµÎ¯ ÎºÎ±Î¹ Î¸Î± ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„ÎµÎ¯ Ï‰Ï‚ Î¼Î­ÏÎ¿Ï‚ Ï„Î·Ï‚ Â«Î´Î¿ÎºÎ¹Î¼Î®Ï‚ Ï†Î¿ÏÏ„Î¯Î¿Ï…Â»."

#: src/testing/doc-tests.md:20
#, fuzzy
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ [Rust Playground](https://play.rust-lang."
"org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."

#: src/testing/integration-tests.md:3
#, fuzzy
msgid "If you want to test your library as a client, use an integration test."
msgstr ""
"Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÎµÏ„Îµ Ï„Î· Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· ÏƒÎ±Ï‚ Ï‰Ï‚ Ï€ÎµÎ»Î¬Ï„Î·, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Î¼Î¹Î± "
"Î´Î¿ÎºÎ¹Î¼Î® ÎµÎ½Î¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚."

#: src/testing/integration-tests.md:5
#, fuzzy
msgid "Create a `.rs` file under `tests/`:"
msgstr "Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿ Â«.rsÂ» ÎºÎ¬Ï„Ï‰ Î±Ï€ÏŒ Ï„Î¿ Â«tests/Â»:"

#: src/testing/integration-tests.md:7
msgid ""
"```rust,ignore\n"
"use my_library::init;\n"
"\n"
"#[test]\n"
"fn test_init() {\n"
"    assert!(init().is_ok());\n"
"}\n"
"```"
msgstr ""

#: src/testing/integration-tests.md:16
#, fuzzy
msgid "These tests only have access to the public API of your crate."
msgstr "Î‘Ï…Ï„Î­Ï‚ Î¿Î¹ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Î­Ï‡Î¿Ï…Î½ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· Î¼ÏŒÎ½Î¿ ÏƒÏ„Î¿ Î´Î·Î¼ÏŒÏƒÎ¹Î¿ API Ï„Î¿Ï… ÎºÎ»Î¿Ï…Î²Î¹Î¿Ï ÏƒÎ±Ï‚."

#: src/testing/useful-crates.md:1
msgid "Useful crates for writing tests"
msgstr ""

#: src/testing/useful-crates.md:3
#, fuzzy
msgid "Rust comes with only basic support for writing tests."
msgstr "Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î· Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ·Ï‚:"

#: src/testing/useful-crates.md:5
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr ""

#: src/testing/useful-crates.md:7
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""

#: src/testing/useful-crates.md:8
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr ""

#: src/testing/useful-crates.md:9
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr ""

#: src/unsafe.md:3
#, fuzzy
msgid "The Rust language has two parts:"
msgstr "Î— Î³Î»ÏÏƒÏƒÎ± Rust Î­Ï‡ÎµÎ¹ Î´ÏÎ¿ Î¼Î­ÏÎ·:"

#: src/unsafe.md:5
#, fuzzy
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr ""
"**Safe Rust:** Î±ÏƒÏ†Î±Î»Î®Ï‚ Î¼Î½Î®Î¼Î·, Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î· Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬."

#: src/unsafe.md:6
#, fuzzy
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr ""
"**ÎœÎ· Î±ÏƒÏ†Î±Î»Î®Ï‚ ÏƒÎºÎ¿Ï…ÏÎ¹Î¬:** Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÏÎ¿ÎºÎ±Î»Î­ÏƒÎµÎ¹ Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ ÎµÎ¬Î½ "
"Ï€Î±ÏÎ±Î²Î¹Î¬Î¶Î¿Î½Ï„Î±Î¹ Ï€ÏÎ¿Ï‹Ï€Î¿Î¸Î­ÏƒÎµÎ¹Ï‚."

#: src/unsafe.md:8
#, fuzzy
msgid ""
"We will be seeing mostly safe Rust in this course, but it's important to "
"know what Unsafe Rust is."
msgstr ""
"Î˜Î± Î´Î¿ÏÎ¼Îµ ÎºÏ…ÏÎ¯Ï‰Ï‚ Î±ÏƒÏ†Î±Î»Î® Rust ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î±, Î±Î»Î»Î¬ ÎµÎ¯Î½Î±Î¹ ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ Î½Î± Ï„Î¿ "
"Î³Î½Ï‰ÏÎ¯Î¶Î¿Ï…Î¼Îµ Ï„Î¹ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Unsafe Rust."

#: src/unsafe.md:11
#, fuzzy
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"ÎŸ Î¼Î· Î±ÏƒÏ†Î±Î»Î®Ï‚ ÎºÏÎ´Î¹ÎºÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ ÏƒÏ…Î½Î®Î¸Ï‰Ï‚ Î¼Î¹ÎºÏÏŒÏ‚ ÎºÎ±Î¹ Î±Ï€Î¿Î¼Î¿Î½Ï‰Î¼Î­Î½Î¿Ï‚ ÎºÎ±Î¹ Î· Î¿ÏÎ¸ÏŒÏ„Î·Ï„Î¬ "
"Ï„Î¿Ï… Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î³Î¯Î½ÎµÏ„Î±Î¹ Ï€ÏÎ¿ÏƒÎµÎºÏ„Î¹ÎºÎ¬ Ï„ÎµÎºÎ¼Î·ÏÎ¹Ï‰Î¼Î­Î½Î·. Î£Ï…Î½Î®Î¸Ï‰Ï‚ ÎµÎ¯Î½Î±Î¹ Ï„Ï…Î»Î¹Î³Î¼Î­Î½Î¿ ÏƒÎµ "
"Î­Î½Î± Î±ÏƒÏ†Î±Î»Î­Ï‚ ÏƒÏ„ÏÏÎ¼Î± Î±Ï†Î±Î¯ÏÎµÏƒÎ·Ï‚."

#: src/unsafe.md:14
#, fuzzy
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "Î¤Î¿ Unsafe Rust ÏƒÎ¬Ï‚ Î´Î¯Î½ÎµÎ¹ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÎµ Ï€Î­Î½Ï„Îµ Î½Î­ÎµÏ‚ Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„ÎµÏ‚:"

#: src/unsafe.md:16
#, fuzzy
msgid "Dereference raw pointers."
msgstr "Î‘Î½Î±Ï†Î¿ÏÎ¬ Î±ÎºÎ±Ï„Î­ÏÎ³Î±ÏƒÏ„Ï‰Î½ Î´ÎµÎ¹ÎºÏ„ÏÎ½."

#: src/unsafe.md:17
#, fuzzy
msgid "Access or modify mutable static variables."
msgstr "Î ÏÏŒÏƒÎ²Î±ÏƒÎ· Î® Ï„ÏÎ¿Ï€Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ ÏƒÏ„Î±Ï„Î¹ÎºÏÎ½ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½."

#: src/unsafe.md:18
#, fuzzy
msgid "Access `union` fields."
msgstr "Î ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î± Ï€ÎµÎ´Î¯Î± Â«Î­Î½Ï‰ÏƒÎ·Â»."

#: src/unsafe.md:19
#, fuzzy
msgid "Call `unsafe` functions, including `extern` functions."
msgstr ""
"ÎšÎ±Î»Î­ÏƒÏ„Îµ Â«Î¼Î· Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚Â» ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚, ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î±Î½Î¿Î¼Î­Î½Ï‰Î½ Ï„Ï‰Î½ Â«ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÏÎ½Â» "
"ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½."

#: src/unsafe.md:20
#, fuzzy
msgid "Implement `unsafe` traits."
msgstr "Î•Ï†Î±ÏÎ¼ÏŒÏƒÏ„Îµ Â«Î¼Î· Î±ÏƒÏ†Î±Î»Î®Â» Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬."

#: src/unsafe.md:22
#, fuzzy
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"Î˜Î± ÎºÎ±Î»ÏÏˆÎ¿Ï…Î¼Îµ ÎµÎ½ ÏƒÏ…Î½Ï„Î¿Î¼Î¯Î± Ï„Î¹Ï‚ Î¼Î· Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚ Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„ÎµÏ‚ ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±. Î“Î¹Î± "
"Ï€Î»Î®ÏÎµÎ¹Ï‚ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚, Î´ÎµÎ¯Ï„Îµ [ÎšÎµÏ†Î¬Î»Î±Î¹Î¿ 19.1 ÏƒÏ„Î¿ Î²Î¹Î²Î»Î¯Î¿ Ï„Î·Ï‚ ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚](https://"
"doc.rust-lang.org/book/ch19-01-unsafe-rust.html) ÎºÎ±Î¹ Ï„Î¿ [Rustonomicon]"
"(https://doc.rust-lang.org/nomicon/)."

#: src/unsafe.md:28
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off the compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"Î¤Î¿ Unsafe Rust Î´ÎµÎ½ ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿ ÎºÏ‰Î´Î¹ÎºÏŒÏ‚ ÎµÎ¯Î½Î±Î¹ ÎµÏƒÏ†Î±Î»Î¼Î­Î½Î¿Ï‚. Î£Î·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿Î¹ "
"Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚ Î­Ï‡Î¿Ï…Î½ Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¹Ï‚ Î´Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„ÎµÏ‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ Ï„Î¿Ï… "
"Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® ÎºÎ±Î¹ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î³ÏÎ¬ÏˆÎµÎ¹ Ï„Î¿Î½ ÏƒÏ‰ÏƒÏ„ÏŒ ÎºÏÎ´Î¹ÎºÎ± Î±Ï€ÏŒ Ï„Î¿Ï…Ï‚ ÎµÎ±Ï…Ï„Î¿ÏÏ‚ Ï„Î¿Ï…Ï‚. "
"Î£Î·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ Î´ÎµÎ½ ÎµÏ€Î¹Î²Î¬Î»Î»ÎµÎ¹ Ï€Î»Î­Î¿Î½ Ï„Î¿Ï…Ï‚ ÎºÎ±Î½ÏŒÎ½ÎµÏ‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ Ï„Î·Ï‚ "
"Î¼Î½Î®Î¼Î·Ï‚ Ï„Î¿Ï… Rust."

#: src/unsafe/raw-pointers.md:3
#, fuzzy
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr ""
"Î— Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î´ÎµÎ¹ÎºÏ„ÏÎ½ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î®Ï‚, Î±Î»Î»Î¬ Î· Î±Ï€Î¿ÏƒÏÎ½Î´ÎµÏƒÎ® Ï„Î¿Ï…Ï‚ Î±Ï€Î±Î¹Ï„ÎµÎ¯ \"Î¼Î· "
"Î±ÏƒÏ†Î±Î»Î®\":"

#: src/unsafe/raw-pointers.md:5
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let mut num = 5;\n"
"\n"
"    let r1 = &mut num as *mut i32;\n"
"    let r2 = r1 as *const i32;\n"
"\n"
"    // Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
"    unsafe {\n"
"        println!(\"r1 is: {}\", *r1);\n"
"        *r1 = 10;\n"
"        println!(\"r2 is: {}\", *r2);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/raw-pointers.md:27
#, fuzzy
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"Î•Î¯Î½Î±Î¹ ÎºÎ±Î»Î® Ï€ÏÎ±ÎºÏ„Î¹ÎºÎ® (ÎºÎ±Î¹ Î±Ï€Î±Î¹Ï„ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿Î½ Î¿Î´Î·Î³ÏŒ ÏƒÏ„Ï…Î» Android Rust) Î½Î± "
"Î³ÏÎ¬ÏˆÎµÏ„Îµ Î­Î½Î± ÏƒÏ‡ÏŒÎ»Î¹Î¿ Î³Î¹Î± Ï„Î¿ ÎºÎ±Î¸Î­Î½Î± ÎœÏ€Î»Î¿Îº \"Î¼Î· Î±ÏƒÏ†Î±Î»Î®Ï‚\" Ï€Î¿Ï… ÎµÎ¾Î·Î³ÎµÎ¯ Ï€ÏÏ‚ Î¿ "
"ÎºÏ‰Î´Î¹ÎºÏŒÏ‚ Î¼Î­ÏƒÎ± ÏƒÎµ Î±Ï…Ï„ÏŒ Î¹ÎºÎ±Î½Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¹Ï‚ Î±Ï€Î±Î¹Ï„Î®ÏƒÎµÎ¹Ï‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ Ï„Î¿Ï… Î¼Î· Î±ÏƒÏ†Î±Î»Î¿ÏÏ‚ "
"Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Ï€Î¿Ï… ÎºÎ¬Î½ÎµÎ¹."

#: src/unsafe/raw-pointers.md:31
#, fuzzy
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"Î£Ï„Î·Î½ Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· Ï„Ï‰Î½ Î±Ï€Î¿Î±Î½Î±Ï†Î¿ÏÏÎ½ Î´ÎµÎ¯ÎºÏ„Î·, Î±Ï…Ï„ÏŒ ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿Î¹ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ Ï€ÏÎ­Ï€ÎµÎ¹ "
"Î½Î± ÎµÎ¯Î½Î±Î¹ [_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), Ï€."
"Ï‡.:"

#: src/unsafe/raw-pointers.md:34
#, fuzzy
msgid "The pointer must be non-null."
msgstr "ÎŸ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Î´ÎµÎ½ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¼Î·Î´ÎµÎ½Î¹ÎºÏŒÏ‚."

#: src/unsafe/raw-pointers.md:35
#, fuzzy
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr ""
"ÎŸ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ _dereferenceable_ (ÎµÎ½Ï„ÏŒÏ‚ Ï„Ï‰Î½ Î¿ÏÎ¯Ï‰Î½ ÎµÎ½ÏŒÏ‚ "
"Î¼ÎµÎ¼Î¿Î½Ï‰Î¼Î­Î½Î¿Ï… Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Î¿Ï…)."

#: src/unsafe/raw-pointers.md:36
#, fuzzy
msgid "The object must not have been deallocated."
msgstr "Î¤Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î´ÎµÎ½ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î­Ï‡ÎµÎ¹ ÎµÎºÏ‡Ï‰ÏÎ·Î¸ÎµÎ¯."

#: src/unsafe/raw-pointers.md:37
#, fuzzy
msgid "There must not be concurrent accesses to the same location."
msgstr "Î”ÎµÎ½ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½ÎµÏ‚ Ï€ÏÎ¿ÏƒÎ²Î¬ÏƒÎµÎ¹Ï‚ ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î±."

#: src/unsafe/raw-pointers.md:38
#, fuzzy
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"Î•Î¬Î½ Î¿ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Î»Î®Ï†Î¸Î·ÎºÎµ Î¼Îµ Ï„Î· Î¼ÎµÏ„Î¬Î´Î¿ÏƒÎ· Î¼Î¹Î±Ï‚ Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚, Ï„Î¿ Ï…Ï€Î¿ÎºÎµÎ¯Î¼ÎµÎ½Î¿ "
"Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ Î¶Ï‰Î½Ï„Î±Î½ÏŒ ÎºÎ±Î¹ ÏŒÏ‡Î¹ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î±Î½Î±Ï†Î¿ÏÎ¬ "
"Î³Î¹Î± Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î· Î¼Î½Î®Î¼Î·."

#: src/unsafe/raw-pointers.md:41
#, fuzzy
msgid "In most cases the pointer must also be properly aligned."
msgstr ""
"Î£Ï„Î¹Ï‚ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚ Î¿ Î´ÎµÎ¯ÎºÏ„Î·Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± ÎµÎ¯Î½Î±Î¹ ÏƒÏ‰ÏƒÏ„Î¬ "
"ÎµÏ…Î¸Ï…Î³ÏÎ±Î¼Î¼Î¹ÏƒÎ¼Î­Î½Î¿Ï‚."

#: src/unsafe/mutable-static-variables.md:3
#, fuzzy
msgid "It is safe to read an immutable static variable:"
msgstr "Î•Î¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î­Ï‚ Î½Î± Î´Î¹Î±Î²Î¬ÏƒÎµÏ„Îµ Î¼Î¹Î± Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î· ÏƒÏ„Î±Ï„Î¹ÎºÎ® Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î®:"

#: src/unsafe/mutable-static-variables.md:5
msgid ""
"```rust,editable\n"
"static HELLO_WORLD: &str = \"Hello, world!\";\n"
"\n"
"fn main() {\n"
"    println!(\"HELLO_WORLD: {HELLO_WORLD}\");\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:13
#, fuzzy
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr ""
"Î©ÏƒÏ„ÏŒÏƒÎ¿, Î´ÎµÎ´Î¿Î¼Î­Î½Î¿Ï… ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€ÏÎ¿ÎºÏÏˆÎ¿Ï…Î½ Î±Î³ÏÎ½ÎµÏ‚ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½, Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ "
"Î±ÏƒÏ†Î±Î»Î­Ï‚ Î½Î± Î´Î¹Î±Î²Î¬Î¶ÎµÏ„Îµ ÎºÎ±Î¹ Î½Î± Î³ÏÎ¬Ï†ÎµÏ„Îµ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î¬ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚:"

#: src/unsafe/mutable-static-variables.md:16
msgid ""
"```rust,editable\n"
"static mut COUNTER: u32 = 0;\n"
"\n"
"fn add_to_counter(inc: u32) {\n"
"    unsafe { COUNTER += inc; }  // Potential data race!\n"
"}\n"
"\n"
"fn main() {\n"
"    add_to_counter(42);\n"
"\n"
"    unsafe { println!(\"COUNTER: {COUNTER}\"); }  // Potential data race!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/mutable-static-variables.md:32
#, fuzzy
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"Î— Ï‡ÏÎ®ÏƒÎ· ÎµÎ½ÏŒÏ‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î¿Ï ÏƒÏ„Î±Ï„Î¹ÎºÎ¿Ï ÎµÎ¯Î½Î±Î¹ Î³ÎµÎ½Î¹ÎºÎ¬ ÎºÎ±ÎºÎ® Î¹Î´Î­Î±, Î±Î»Î»Î¬ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ "
"Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Ï€ÎµÏÎ¹Ï€Ï„ÏÏƒÎµÎ¹Ï‚ ÏŒÏ€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡ÎµÎ¹ Î½ÏŒÎ·Î¼Î± ÏƒÎµ ÎºÏÎ´Î¹ÎºÎ± Â«no_stdÂ» Ï‡Î±Î¼Î·Î»Î¿Ï "
"ÎµÏ€Î¹Ï€Î­Î´Î¿Ï…, ÏŒÏ€Ï‰Ï‚ Î· ÎµÏ†Î±ÏÎ¼Î¿Î³Î® ÎµÎ½ÏŒÏ‚ ÎºÎ±Ï„Î±Î½ÎµÎ¼Î·Ï„Î® ÏƒÏ‰ÏÎ¿Ï Î® Î· ÎµÏÎ³Î±ÏƒÎ¯Î± Î¼Îµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î± C "
"API."

#: src/unsafe/unions.md:3
#, fuzzy
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr ""
"Î¤Î± ÏƒÏ…Î½Î´Î¹ÎºÎ¬Ï„Î± ÎµÎ¯Î½Î±Î¹ ÏƒÎ±Î½ Ï„Î± enums, Î±Î»Î»Î¬ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯Ï„Îµ Î¼ÏŒÎ½Î¿Î¹ ÏƒÎ±Ï‚ Ï„Î¿ "
"ÎµÎ½ÎµÏÎ³ÏŒ Ï€ÎµÎ´Î¯Î¿:"

#: src/unsafe/unions.md:5
msgid ""
"```rust,editable\n"
"#[repr(C)]\n"
"union MyUnion {\n"
"    i: u8,\n"
"    b: bool,\n"
"}\n"
"\n"
"fn main() {\n"
"    let u = MyUnion { i: 42 };\n"
"    println!(\"int: {}\", unsafe { u.i });\n"
"    println!(\"bool: {}\", unsafe { u.b });  // Undefined behavior!\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/unions.md:21
#, fuzzy
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"ÎŸÎ¹ ÎµÎ½ÏÏƒÎµÎ¹Ï‚ Ï‡ÏÎµÎ¹Î¬Î¶Î¿Î½Ï„Î±Î¹ Ï€Î¿Î»Ï ÏƒÏ€Î¬Î½Î¹Î± ÏƒÏ„Î¿ Rust ÎºÎ±Î¸ÏÏ‚ ÏƒÏ…Î½Î®Î¸Ï‰Ï‚ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î­Î½Î± enum. Î ÎµÏÎ¹ÏƒÏ„Î±ÏƒÎ¹Î±ÎºÎ¬ Ï‡ÏÎµÎ¹Î¬Î¶Î¿Î½Ï„Î±Î¹ Î³Î¹Î± Î±Î»Î»Î·Î»ÎµÏ€Î¯Î´ÏÎ±ÏƒÎ· Î¼Îµ API "
"Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·Ï‚ C."

#: src/unsafe/unions.md:24
#, fuzzy
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î±Ï€Î»ÏÏ‚ Î½Î± ÎµÏÎ¼Î·Î½ÎµÏÏƒÎµÏ„Îµ Î¾Î±Î½Î¬ Ï„Î± byte Ï‰Ï‚ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ¿Ï Ï„ÏÏ€Î¿Ï…, Î¼Î¬Î»Î»Î¿Î½ "
"Î¸Î­Î»ÎµÏ„Îµ [`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) Î® Ï‡ÏÎ·Î¼Î±Ï„Î¿ÎºÎ¹Î²ÏÏ„Î¹Î¿ Ï€ÎµÏÎ¹Ï„ÏÎ»Î¹Î³Î¼Î± ÏŒÏ€Ï‰Ï‚ Ï„Î¿ ÎºÎ¹Î²ÏÏ„Î¹Î¿ [`zerocopy`]"
"(https://crates.io/crates/zerocopy)."

#: src/unsafe/calling-unsafe-functions.md:3
#, fuzzy
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"ÎœÎ¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î® Î¼Î¹Î± Î¼Î­Î¸Î¿Î´Î¿Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î±Î½Î¸ÎµÎ¯ Ï‰Ï‚ Â«Î¼Î· Î±ÏƒÏ†Î±Î»Î®Ï‚Â» ÎµÎ¬Î½ Î­Ï‡ÎµÎ¹ "
"ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ Ï€ÏÎ¿Ï‹Ï€Î¿Î¸Î­ÏƒÎµÎ¹Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï„Î·ÏÎµÎ¯ Î³Î¹Î± Ï„Î·Î½ Î±Ï€Î¿Ï†Ï…Î³Î® Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î·Ï‚ "
"ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬Ï‚:"

#: src/unsafe/calling-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"fn main() {\n"
"    let emojis = \"ğŸ—»âˆˆğŸŒ\";\n"
"\n"
"    // Safe because the indices are in the correct order, within the bounds "
"of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
"    unsafe {\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(0..4));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(4..7));\n"
"        println!(\"emoji: {}\", emojis.get_unchecked(7..11));\n"
"    }\n"
"\n"
"    println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..7) }));\n"
"\n"
"    // Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"
"}\n"
"\n"
"fn count_chars(s: &str) -> usize {\n"
"    s.chars().map(|_| 1).sum()\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:3
#, fuzzy
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Ï„Î¹Ï‚ Î´Î¹ÎºÎ­Ï‚ ÏƒÎ±Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Ï‰Ï‚ \"Î¼Î· Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚\" ÎµÎ¬Î½ "
"Î±Ï€Î±Î¹Ï„Î¿ÏÎ½ ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½ÎµÏ‚ ÏƒÏ…Î½Î¸Î®ÎºÎµÏ‚ Î³Î¹Î± Î½Î± Î±Ï€Î¿Ï†ÎµÏ…Ï‡Î¸Î¿ÏÎ½ Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„ÎµÏ‚ Î· "
"Î£Î¥ÎœÎ Î•Î¡Î™Î¦ÎŸÎ¡Î‘."

#: src/unsafe/writing-unsafe-functions.md:6
msgid ""
"```rust,editable\n"
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
"unsafe fn swap(a: *mut u8, b: *mut u8) {\n"
"    let temp = *a;\n"
"    *a = *b;\n"
"    *b = temp;\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut a = 42;\n"
"    let mut b = 66;\n"
"\n"
"    // Safe because ...\n"
"    unsafe {\n"
"        swap(&mut a, &mut b);\n"
"    }\n"
"\n"
"    println!(\"a = {}, b = {}\", a, b);\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/writing-unsafe-functions.md:33
#, fuzzy
msgid ""
"We wouldn't actually use pointers for this because it can be done safely "
"with references."
msgstr ""
"Î£Ï„Î·Î½ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒÏ„Î·Ï„Î± Î´ÎµÎ½ Î¸Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÏƒÎ±Î¼Îµ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ Î³Î¹Î± Î±Ï…Ï„ÏŒ, ÎµÏ€ÎµÎ¹Î´Î® Î¼Ï€Î¿ÏÎµÎ¯ "
"Î½Î± Î³Î¯Î½ÎµÎ¹ Î¼Îµ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î± Î¼Îµ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚."

#: src/unsafe/writing-unsafe-functions.md:35
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens."
msgstr ""
"Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ ÏŒÏ„Î¹ Î¿ Î¼Î· Î±ÏƒÏ†Î±Î»Î®Ï‚ ÎºÏ‰Î´Î¹ÎºÏŒÏ‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÏ„Î±Î¹ ÏƒÎµ Î¼Î¹Î± Î¼Î· Î±ÏƒÏ†Î±Î»Î® ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· "
"Ï‡Ï‰ÏÎ¯Ï‚ Î¼Ï€Î»Î¿Îº \"Î¼Î· Î±ÏƒÏ†Î±Î»Î®Ï‚\". ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Î±Ï€Î±Î³Î¿ÏÎµÏÏƒÏ„Îµ Î±Ï…Ï„ÏŒ Î¼Îµ "
"\"#\\[deny(unsafe_op_in_unsafe_fn)\\]\". Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Î½Î± Ï„Î¿ Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÎµÏ„Îµ ÎºÎ±Î¹ "
"Î´ÎµÎ¯Ï„Îµ Ï„Î¹ Î¸Î± ÏƒÏ…Î¼Î²ÎµÎ¯."

#: src/unsafe/extern-functions.md:1
#, fuzzy
msgid "Calling External Code"
msgstr "ÎšÎ»Î®ÏƒÎ· ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÎ¿Ï ÎºÏ‰Î´Î¹ÎºÎ¿Ï"

#: src/unsafe/extern-functions.md:3
#, fuzzy
msgid ""
"Functions from other languages might violate the guarantees of Rust. Calling "
"them is thus unsafe:"
msgstr ""
"Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Î±Ï€ÏŒ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚ ÎµÎ½Î´Î­Ï‡ÎµÏ„Î±Î¹ Î½Î± Ï€Î±ÏÎ±Î²Î¹Î¬Î¶Î¿Ï…Î½ Ï„Î¹Ï‚ ÎµÎ³Î³Ï…Î®ÏƒÎµÎ¹Ï‚ Ï„Î¿Ï… "
"Rust. ÎšÎ»Î®ÏƒÎ· ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Î±Î½Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚:"

#: src/unsafe/extern-functions.md:6
msgid ""
"```rust,editable\n"
"extern \"C\" {\n"
"    fn abs(input: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    unsafe {\n"
"        // Undefined behavior if abs misbehaves.\n"
"        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/unsafe/extern-functions.md:21
#, fuzzy
msgid ""
"This is usually only a problem for extern functions which do things with "
"pointers which might violate Rust's memory model, but in general any C "
"function might have undefined behaviour under any arbitrary circumstances."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ ÏƒÏ…Î½Î®Î¸Ï‰Ï‚ Î­Î½Î± Ï€ÏÏŒÎ²Î»Î·Î¼Î± Î¼ÏŒÎ½Î¿ Î³Î¹Î± ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÎ­Ï‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… ÎºÎ¬Î½Î¿Ï…Î½ "
"Ï€ÏÎ¬Î³Î¼Î±Ï„Î± Î¼Îµ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Ï€Î±ÏÎ±Î²Î¹Î¬Î¶Î¿Ï…Î½ Ï„Î¿ Î¼Î¿Î½Ï„Î­Î»Î¿ Î¼Î½Î®Î¼Î·Ï‚ Ï„Î¿Ï… Rust, Î±Î»Î»Î¬ "
"Î³ÎµÎ½Î¹ÎºÎ¬ Î¿Ï€Î¿Î¹Î±Î´Î®Ï€Î¿Ï„Îµ ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· C Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î­Ï‡ÎµÎ¹ Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ ÎºÎ¬Ï„Ï‰ "
"Î±Ï€ÏŒ Î¿Ï€Î¿Î¹Î±Î´Î®Ï€Î¿Ï„Îµ Î±Ï…Î¸Î±Î¯ÏÎµÏ„ÎµÏ‚ Ï€ÎµÏÎ¹ÏƒÏ„Î¬ÏƒÎµÎ¹Ï‚."

#: src/unsafe/extern-functions.md:25
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""

#: src/unsafe/unsafe-traits.md:3
#, fuzzy
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"ÎŒÏ€Ï‰Ï‚ ÎºÎ±Î¹ Î¼Îµ Ï„Î¹Ï‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹ÏƒÎ·Î¼Î¬Î½ÎµÏ„Îµ Î­Î½Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï‰Ï‚ "
"\"Î¼Î· Î±ÏƒÏ†Î±Î»Î­Ï‚\", ÎµÎ¬Î½ Î· Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ ÎµÎ³Î³Ï…Î·Î¼Î­Î½Î· ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½ÎµÏ‚ "
"ÏƒÏ…Î½Î¸Î®ÎºÎµÏ‚ Î³Î¹Î± Ï„Î·Î½ Î±Ï€Î¿Ï†Ï…Î³Î® Î±Ï€ÏÎ¿ÏƒÎ´Î¹ÏŒÏÎ¹ÏƒÏ„Î·Ï‚ ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬Ï‚."

#: src/unsafe/unsafe-traits.md:6
#, fuzzy
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"Î“Î¹Î± Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Ï„Î¿ ÎºÎ¹Î²ÏÏ„Î¹Î¿ Â«zerocopyÂ» Î­Ï‡ÎµÎ¹ Î­Î½Î± Î¼Î· Î±ÏƒÏ†Î±Î»Î­Ï‚ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï€Î¿Ï… "
"Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ [ÎºÎ¬Ï„Î¹ ÏƒÎ±Î½ Î±Ï…Ï„ÏŒ](https://docs.rs/zerocopy/latest/zerocopy/trait."
"AsBytes.html):"

#: src/unsafe/unsafe-traits.md:9
#, fuzzy
msgid ""
"```rust,editable\n"
"use std::mem::size_of_val;\n"
"use std::slice;\n"
"\n"
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
"pub unsafe trait AsBytes {\n"
"    fn as_bytes(&self) -> &[u8] {\n"
"        unsafe {\n"
"            slice::from_raw_parts(self as *const Self as *const u8, "
"size_of_val(self))\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Safe because u32 has a defined representation and no padding.\n"
"unsafe impl AsBytes for u32 {}\n"
"```"
msgstr ""
"///... /// # Î‘ÏƒÏ†Î¬Î»ÎµÎ¹Î± /// ÎŸ Ï„ÏÏ€Î¿Ï‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î­Ï‡ÎµÎ¹ ÎºÎ±Î¸Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î· Î±Î½Î±Ï€Î±ÏÎ¬ÏƒÏ„Î±ÏƒÎ· "
"ÎºÎ±Î¹ Ï‡Ï‰ÏÎ¯Ï‚ Î³Î­Î¼Î¹ÏƒÎ·. Î¼Î· Î±ÏƒÏ†Î±Î»Î­Ï‚ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï€Î±Î¼Ï€ AsBytes { fn "
"as_bytes(&self) -> &\\[u8\\] { Î¼Î· Î±ÏƒÏ†Î±Î»Î­Ï‚ { slice::from_raw_parts(self as "
"\\*const Self as \\*const u8, size_of_val(self)) } } }"

#: src/unsafe/unsafe-traits.md:30
#, fuzzy
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"Î˜Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¼Î¹Î± ÎµÎ½ÏŒÏ„Î·Ï„Î± Â«# Î‘ÏƒÏ†Î¬Î»ÎµÎ¹Î±Â» ÏƒÏ„Î¿ Rustdoc Î³Î¹Î± Ï„Î¿ "
"Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï€Î¿Ï… ÎµÎ¾Î·Î³ÎµÎ¯ Ï„Î¹Ï‚ Î±Ï€Î±Î¹Ï„Î®ÏƒÎµÎ¹Ï‚ Î³Î¹Î± Ï„Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ Ï€Î¿Ï… Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
"ÎµÏ†Î±ÏÎ¼Î¿ÏƒÏ„ÎµÎ¯ Î¼Îµ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î±."

#: src/unsafe/unsafe-traits.md:33
#, fuzzy
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr ""
"Î— Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÎ® ÎµÎ½ÏŒÏ„Î·Ï„Î± Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î±Ï‚ Î³Î¹Î± Ï„Î± \"AsBytes\" ÎµÎ¯Î½Î±Î¹ Î¼Î¬Î»Î»Î¿Î½ Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ· "
"ÎºÎ±Î¹ Ï€Î¹Î¿ Ï€ÎµÏÎ¯Ï€Î»Î¿ÎºÎ·."

#: src/unsafe/unsafe-traits.md:35
#, fuzzy
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr ""
"Î¤Î± ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®Â» ÎºÎ±Î¹ Â«Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â» Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ "
"Î±ÏƒÏ†Î±Î»Î®."

#: src/exercises/day-3/afternoon.md:1
#, fuzzy
msgid "Day 3: Afternoon Exercises"
msgstr "Î—Î¼Î­ÏÎ± 3: Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-3/afternoon.md:3
#, fuzzy
msgid "Let us build a safe wrapper for reading directory content!"
msgstr ""
"Î‘Ï‚ Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î­Î½Î± Î±ÏƒÏ†Î±Î»Î­Ï‚ Ï€ÎµÏÎ¹Ï„ÏÎ»Î¹Î³Î¼Î± Î³Î¹Î± Ï„Î·Î½ Î±Î½Î¬Î³Î½Ï‰ÏƒÎ· Ï€ÎµÏÎ¹ÎµÏ‡Î¿Î¼Î­Î½Î¿Ï… "
"ÎºÎ±Ï„Î±Î»ÏŒÎ³Î¿Ï…!"

#: src/exercises/day-3/afternoon.md:5
msgid ""
"For this exercise, we suggest using a local dev environment instead of the "
"Playground. This will allow you to run your binary on your own machine."
msgstr ""

#: src/exercises/day-3/afternoon.md:8
msgid ""
"To get started, follow the [running locally](../../cargo/running-locally.md) "
"instructions."
msgstr ""

#: src/exercises/day-3/afternoon.md:14
#, fuzzy
msgid ""
"After looking at the exercise, you can look at the [solution](solutions-"
"afternoon.md) provided."
msgstr "Î‘Ï†Î¿Ï Î´ÎµÎ¯Ï„Îµ Ï„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î· \\[Î»ÏÏƒÎ·\\] Ï€Î¿Ï… Ï€Î±ÏÎ­Ï‡ÎµÏ„Î±Î¹."

#: src/exercises/day-3/safe-ffi-wrapper.md:3
#, fuzzy
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the filenames of a directory."
msgstr ""
"Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ Î¼ÎµÎ³Î¬Î»Î· Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Ï„Î·Î½ ÎºÎ»Î®ÏƒÎ· ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½ Î¼Î­ÏƒÏ‰ Î¼Î¹Î±Ï‚ "
"ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·Ï‚ _foreign Î´Î¹ÎµÏ€Î±Ï†Î®_ (FFI). Î˜Î± Ï„Î¿ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Î³Î¹Î± Î½Î± "
"Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î­Î½Î± Î±ÏƒÏ†Î±Î»Î­Ï‚ Ï€ÎµÏÎ¹Ï„ÏÎ»Î¹Î³Î¼Î± Î³Î¹Î± Ï„Î¿ `libc` ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… Î¸Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÏƒÎ±Ï„Îµ Î±Ï€ÏŒ Ï„Î¿ C Î³Î¹Î± Î½Î± Î´Î¹Î±Î²Î¬ÏƒÎµÏ„Îµ Ï„Î± Î¿Î½ÏŒÎ¼Î±Ï„Î± Î±ÏÏ‡ÎµÎ¯Ï‰Î½ ÎµÎ½ÏŒÏ‚ ÎºÎ±Ï„Î±Î»ÏŒÎ³Î¿Ï…."

#: src/exercises/day-3/safe-ffi-wrapper.md:7
#, fuzzy
msgid "You will want to consult the manual pages:"
msgstr "Î˜Î± Î¸ÎµÎ»Î®ÏƒÎµÏ„Îµ Î½Î± ÏƒÏ…Î¼Î²Î¿Ï…Î»ÎµÏ…Ï„ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ ÏƒÎµÎ»Î¯Î´ÎµÏ‚ Ï„Î¿Ï… ÎµÎ³Ï‡ÎµÎ¹ÏÎ¹Î´Î¯Î¿Ï…:"

#: src/exercises/day-3/safe-ffi-wrapper.md:9
#, fuzzy
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:10
#, fuzzy
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:11
#, fuzzy
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/exercises/day-3/safe-ffi-wrapper.md:13
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Encoding"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:16
msgid "Use"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:18
#, fuzzy
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr "Â«ReadÂ» ÎºÎ±Î¹ Â«WriteÂ» Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± IO,"

#: src/exercises/day-3/safe-ffi-wrapper.md:18
msgid "UTF-8"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:18
#, fuzzy
msgid "Text processing in Rust"
msgstr "ÎœÎµÏ„Î±ÎºÎ¹Î½Î·Î¼Î­Î½ÎµÏ‚ ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÎ­Ï‚ ÏƒÏ„Î· Rust"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
#, fuzzy
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr "Â«ReadÂ» ÎºÎ±Î¹ Â«WriteÂ» Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± IO,"

#: src/exercises/day-3/safe-ffi-wrapper.md:19
msgid "NUL-terminated"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:19
msgid "Communicating with C functions"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:20
#, fuzzy
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr "Â«ReadÂ» ÎºÎ±Î¹ Â«WriteÂ» Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± IO,"

#: src/exercises/day-3/safe-ffi-wrapper.md:20
msgid "OS-specific"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:20
msgid "Communicating with the OS"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:22
msgid "You will convert between all these types:"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:24
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:25
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:26
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:27
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknow data\","
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:28
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:31
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:34
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""

#: src/exercises/day-3/safe-ffi-wrapper.md:45
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ "
"ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î¿Î½ ÎºÏ‰Î´Î¹ÎºÏŒ Ï€Î¿Ï… Î»ÎµÎ¯Ï€ÎµÎ¹ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ ÎºÎ±Î¹ Î¼Î­Î¸Î¿Î´Î¿Î¹:"

#: src/exercises/day-3/safe-ffi-wrapper.md:48
msgid ""
"```rust,should_panic\n"
"// TODO: remove this when you're done with your implementation.\n"
"#![allow(unused_imports, unused_variables, dead_code)]\n"
"\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        unimplemented!()\n"
"    }\n"
"}\n"
"\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android.md:1
msgid "Welcome to Rust in Android"
msgstr ""

#: src/android.md:3
#, fuzzy
msgid ""
"Rust is supported for native platform development on Android. This means "
"that you can write new operating system services in Rust, as well as "
"extending existing services."
msgstr ""
"Î¤Î¿ Rust Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î³Î¹Î± Î±Î½Î¬Ï€Ï„Ï…Î¾Î· ÎµÎ³Î³ÎµÎ½Î¿ÏÏ‚ Ï€Î»Î±Ï„Ï†ÏŒÏÎ¼Î±Ï‚ ÏƒÏ„Î¿ Android. Î‘Ï…Ï„ÏŒ "
"ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î³ÏÎ¬ÏˆÎµÏ„Îµ Î½Î­ÎµÏ‚ Ï…Ï€Î·ÏÎµÏƒÎ¯ÎµÏ‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ¿Ï ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ ÏƒÏ„Î¿ "
"Rust, ÎºÎ±Î¸ÏÏ‚ ÎºÎ±Î¹ Î½Î± ÎµÏ€ÎµÎºÏ„ÎµÎ¯Î½ÎµÏ„Îµ Ï…Ï€Î¬ÏÏ‡Î¿Ï…ÏƒÎµÏ‚ Ï…Ï€Î·ÏÎµÏƒÎ¯ÎµÏ‚."

#: src/android.md:7
#, fuzzy
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"Î˜Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸Î®ÏƒÎ¿Ï…Î¼Îµ Î½Î± ÎºÎ±Î»Î­ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Î½ Rust Î±Ï€ÏŒ Î­Î½Î± Î±Ï€ÏŒ Ï„Î± Î´Î¹ÎºÎ¬ ÏƒÎ±Ï‚ Î­ÏÎ³Î± ÏƒÎ®Î¼ÎµÏÎ±. "
"Î ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Î»Î¿Î¹Ï€ÏŒÎ½ Î²ÏÎµÎ¯Ï„Îµ Î¼Î¹Î± Î¼Î¹ÎºÏÎ® Î³Ï‰Î½Î¯Î± Ï„Î·Ï‚ Î²Î¬ÏƒÎ·Ï‚ Ï„Î¿Ï… ÎºÏÎ´Î¹ÎºÎ± ÏŒÏ€Î¿Ï… Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ "
"Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÎ¿Ï…Î¼Îµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î³ÏÎ±Î¼Î¼Î­Ï‚ ÎºÏÎ´Î¹ÎºÎ± Î£ÎºÎ¿Ï…ÏÎ¹Î¬. ÎŒÏƒÎ¿ Î»Î¹Î³ÏŒÏ„ÎµÏÎµÏ‚ ÎµÎ¾Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ "
"ÎºÎ±Î¹ Â«ÎµÎ¾Ï‰Ï„Î¹ÎºÎ¿Î¯Â» Ï„ÏÏ€Î¿Î¹ Ï„ÏŒÏƒÎ¿ Ï„Î¿ ÎºÎ±Î»ÏÏ„ÎµÏÎ¿. ÎšÎ¬Ï„Î¹ Ï€Î¿Ï… Î· Î±Î½Î¬Î»Ï…ÏƒÎ· Î¿ÏÎ¹ÏƒÎ¼Î­Î½Ï‰Î½ "
"Î±ÎºÎ±Ï„Î­ÏÎ³Î±ÏƒÏ„Ï‰Î½ byte Î¸Î± Î®Ï„Î±Î½ Î¹Î´Î±Î½Î¹ÎºÎ®."

#: src/android/setup.md:3
#, fuzzy
msgid ""
"We will be using an Android Virtual Device to test our code. Make sure you "
"have access to one or create a new one with:"
msgstr ""
"Î˜Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Î¼Î¹Î± ÎµÎ¹ÎºÎ¿Î½Î¹ÎºÎ® ÏƒÏ…ÏƒÎºÎµÏ…Î® Android Î³Î¹Î± Î½Î± Î´Î¿ÎºÎ¹Î¼Î¬ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Î½ "
"ÎºÏÎ´Î¹ÎºÎ¬ Î¼Î±Ï‚. Î’ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Î­Ï‡ÎµÏ„Îµ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÎµ Î­Î½Î± Î® Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î­Î½Î± Î½Î­Î¿ Î¼Îµ:"

#: src/android/setup.md:6
msgid ""
"```shell\n"
"source build/envsetup.sh\n"
"lunch aosp_cf_x86_64_phone-userdebug\n"
"acloud create\n"
"```"
msgstr ""

#: src/android/setup.md:12
#, fuzzy
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"Î‘Î½Î±Ï„ÏÎ­Î¾Ï„Îµ ÏƒÏ„Î¿ [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) Î³Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚."

#: src/android/build-rules.md:3
#, fuzzy
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr ""
"Î¤Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î®Ï‚ Android (Soong) Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÎ¹ Ï„Î¿ Rust Î¼Î­ÏƒÏ‰ Î¼Î¹Î±Ï‚ ÏƒÎµÎ¹ÏÎ¬Ï‚ "
"Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏÎ½ Î¼Î¿Î½Î¬Î´Ï‰Î½:"

#: src/android/build-rules.md:5
#, fuzzy
msgid "Module Type"
msgstr ""
"\\| Î¤ÏÏ€Î¿Ï‚ ÎµÎ½ÏŒÏ„Î·Ï„Î±Ï‚ | Î ÎµÏÎ¹Î³ÏÎ±Ï†Î® | "
"\\|------------------------------------------------- "
"-------------------------------------------------- ---------------------| "
"\\| `rust_binary` | Î Î±ÏÎ¬Î³ÎµÎ¹ Î­Î½Î± Rust Î´Ï…Î±Î´Î¹ÎºÏŒ. | \\| `rust_library` | Î Î±ÏÎ¬Î³ÎµÎ¹ "
"Î¼Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Rust ÎºÎ±Î¹ Ï€Î±ÏÎ­Ï‡ÎµÎ¹ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚ Â«rlibÂ» ÎºÎ±Î¹ Â«dylibÂ». | \\| "
"`rust_ffi` | Î Î±ÏÎ¬Î³ÎµÎ¹ Î¼Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Rust C Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Î±Ï€ÏŒ "
"Î¼Î¿Î½Î¬Î´ÎµÏ‚ Â«ccÂ» ÎºÎ±Î¹ Ï€Î±ÏÎ­Ï‡ÎµÎ¹ Ï„ÏŒÏƒÎ¿ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ ÏŒÏƒÎ¿ ÎºÎ±Î¹ ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„ÎµÏ‚ Ï€Î±ÏÎ±Î»Î»Î±Î³Î­Ï‚. | "
"\\| `rust_proc_macro` | Î Î±ÏÎ¬Î³ÎµÎ¹ Î¼Î¹Î± Â«proc-macroÂ» Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Rust. Î‘Ï…Ï„Î¬ ÎµÎ¯Î½Î±Î¹ "
"Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î± Ï€ÏÏŒÏƒÎ¸ÎµÏ„Î± Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®. | \\| Â«Î´Î¿ÎºÎ¹Î¼Î®_ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚Â» | Î Î±ÏÎ¬Î³ÎµÎ¹ Î­Î½Î± "
"Î´Ï…Î±Î´Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î± Î´Î¿ÎºÎ¹Î¼Î®Ï‚ Rust Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î·Î½ Ï„Ï…Ï€Î¹ÎºÎ® Î¶ÏÎ½Î· Î´Î¿ÎºÎ¹Î¼Î®Ï‚ Rust. "
"| \\| `rust_fuzz` | Î Î±ÏÎ¬Î³ÎµÎ¹ Î­Î½Î± Rust fuzz Î´Ï…Î±Î´Î¹ÎºÏŒ Î¼ÏŒÏ‡Î»ÎµÏ…ÏƒÎ·Ï‚ Â«libfuzzerÂ». | "
"\\| `rust_protobuf` | Î”Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯ Ï€Î·Î³Î® ÎºÎ±Î¹ Ï€Î±ÏÎ¬Î³ÎµÎ¹ Î¼Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Rust Ï€Î¿Ï… "
"Ï€Î±ÏÎ­Ï‡ÎµÎ¹ Î¼Î¹Î± Î´Î¹ÎµÏ€Î±Ï†Î® Î³Î¹Î± Î­Î½Î± ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î¿ protobuf. | \\| `rust_bindgen` | "
"Î”Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯ Ï€Î·Î³Î® ÎºÎ±Î¹ Ï€Î±ÏÎ¬Î³ÎµÎ¹ Î¼Î¹Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Rust Ï€Î¿Ï… Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î´ÎµÏƒÎ¼ÎµÏÏƒÎµÎ¹Ï‚ Rust "
"ÏƒÎµ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚ C. |"

#: src/android/build-rules.md:5
msgid "Description"
msgstr ""

#: src/android/build-rules.md:7
msgid "`rust_binary`"
msgstr ""

#: src/android/build-rules.md:7
msgid "Produces a Rust binary."
msgstr ""

#: src/android/build-rules.md:8
msgid "`rust_library`"
msgstr ""

#: src/android/build-rules.md:8
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr ""

#: src/android/build-rules.md:9
msgid "`rust_ffi`"
msgstr ""

#: src/android/build-rules.md:9
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr ""

#: src/android/build-rules.md:10
msgid "`rust_proc_macro`"
msgstr ""

#: src/android/build-rules.md:10
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr ""

#: src/android/build-rules.md:11
msgid "`rust_test`"
msgstr ""

#: src/android/build-rules.md:11
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr ""

#: src/android/build-rules.md:12
msgid "`rust_fuzz`"
msgstr ""

#: src/android/build-rules.md:12
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr ""

#: src/android/build-rules.md:13
msgid "`rust_protobuf`"
msgstr ""

#: src/android/build-rules.md:13
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr ""

#: src/android/build-rules.md:14
msgid "`rust_bindgen`"
msgstr ""

#: src/android/build-rules.md:14
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr ""

#: src/android/build-rules.md:16
#, fuzzy
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "Î£Ï„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î± Î¸Î± Î´Î¿ÏÎ¼Îµ Ï„Î± Â«rust_binaryÂ» ÎºÎ±Î¹ Â«rust_libraryÂ»."

#: src/android/build-rules/binary.md:1
#, fuzzy
msgid "Rust Binaries"
msgstr "Rust Binaries"

#: src/android/build-rules/binary.md:3
#, fuzzy
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr ""
"Î‘Ï‚ Î¾ÎµÎºÎ¹Î½Î®ÏƒÎ¿Ï…Î¼Îµ Î¼Îµ Î¼Î¹Î± Î±Ï€Î»Î® ÎµÏ†Î±ÏÎ¼Î¿Î³Î®. Î£Ï„Î· ÏÎ¯Î¶Î± ÎµÎ½ÏŒÏ‚ Ï„Î±Î¼ÎµÎ¯Î¿Ï… AOSP, "
"Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Ï„Î± Î±ÎºÏŒÎ»Î¿Ï…Î¸Î± Î±ÏÏ‡ÎµÎ¯Î±:"

#: src/android/build-rules/binary.md:6 src/android/build-rules/library.md:13
#, fuzzy
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust\",\n"
"    crate_name: \"hello_rust\",\n"
"    srcs: [\"src/main.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:16 src/android/build-rules/library.md:34
#, fuzzy
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md:18
msgid ""
"```rust\n"
"//! Rust demo.\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"Hello from Rust!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:27
#, fuzzy
msgid "You can now build, push, and run the binary:"
msgstr ""
"Î¤ÏÏÎ± Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ, Î½Î± Ï€ÏÎ¿Ï‰Î¸Î®ÏƒÎµÏ„Îµ ÎºÎ±Î¹ Î½Î± ÎµÎºÏ„ÎµÎ»Î­ÏƒÎµÏ„Îµ Ï„Î¿ Î´Ï…Î±Î´Î¹ÎºÏŒ:"

#: src/android/build-rules/binary.md:29
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp\"\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""

#: src/android/build-rules/binary.md:35
msgid ""
"```text\n"
"Hello from Rust!\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:1
#, fuzzy
msgid "Rust Libraries"
msgstr "Î’Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚ Rust"

#: src/android/build-rules/library.md:3
#, fuzzy
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Ï„Î¿ \"rust_library\" Î³Î¹Î± Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î¼Î¹Î± Î½Î­Î± Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· "
"Rust Î³Î¹Î± Android."

#: src/android/build-rules/library.md:5
#, fuzzy
msgid "Here we declare a dependency on two libraries:"
msgstr "Î•Î´Ï Î´Î·Î»ÏÎ½Î¿Ï…Î¼Îµ Î¼Î¹Î± ÎµÎ¾Î¬ÏÏ„Î·ÏƒÎ· Î±Ï€ÏŒ Î´ÏÎ¿ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎµÏ‚:"

#: src/android/build-rules/library.md:7
#, fuzzy
msgid "`libgreeting`, which we define below,"
msgstr "'libgreeting', Ï€Î¿Ï… Î¿ÏÎ¯Î¶Î¿Ï…Î¼Îµ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰,"

#: src/android/build-rules/library.md:8
#, fuzzy
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"Â«libtextwrapÂ», Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÎºÎ¹Î²ÏÏ„Î¹Î¿ Ï€Î¿Ï… Î­Ï‡ÎµÎ¹ Î®Î´Î· Ï€Ï‰Î»Î·Î¸ÎµÎ¯ \\[`ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÎ¬/"
"ÏƒÎºÎ¿Ï…ÏÎ¹Î¬/ÎºÎ¹Î²ÏÏ„Î¹Î±/`\\]\\[ÎºÎ¹Î²ÏÏ„Î¹Î±\\]."

#: src/android/build-rules/library.md:15
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_with_dep\",\n"
"    crate_name: \"hello_rust_with_dep\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libgreetings\",\n"
"        \"libtextwrap\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"\n"
"rust_library {\n"
"    name: \"libgreetings\",\n"
"    crate_name: \"greetings\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:36
msgid ""
"```rust,ignore\n"
"//! Rust demo.\n"
"\n"
"use greetings::greeting;\n"
"use textwrap::fill;\n"
"\n"
"/// Prints a greeting to standard output.\n"
"fn main() {\n"
"    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:48
#, fuzzy
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md:50
msgid ""
"```rust,ignore\n"
"//! Greeting library.\n"
"\n"
"/// Greet `name`.\n"
"pub fn greeting(name: &str) -> String {\n"
"    format!(\"Hello {name}, it is very nice to meet you!\")\n"
"}\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:59
#, fuzzy
msgid "You build, push, and run the binary like before:"
msgstr "Î”Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯Ï„Îµ, Ï€Î¹Î­Î¶ÎµÏ„Îµ ÎºÎ±Î¹ Ï„ÏÎ­Ï‡ÎµÏ„Îµ Ï„Î¿ Î´Ï…Î±Î´Î¹ÎºÏŒ Î±ÏÏ‡ÎµÎ¯Î¿ ÏŒÏ€Ï‰Ï‚ Ï€ÏÎ¹Î½:"

#: src/android/build-rules/library.md:61
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""

#: src/android/build-rules/library.md:67
msgid ""
"```text\n"
"Hello Bob, it is very\n"
"nice to meet you!\n"
"```"
msgstr ""

#: src/android/aidl.md:3
#, fuzzy
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Î— [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Rust:"

#: src/android/aidl.md:6
#, fuzzy
msgid "Rust code can call existing AIDL servers,"
msgstr "ÎŸ ÎºÏÎ´Î¹ÎºÎ±Ï‚ ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎºÎ±Î»Î­ÏƒÎµÎ¹ Ï…Ï€Î¬ÏÏ‡Î¿Î½Ï„ÎµÏ‚ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚ AIDL,"

#: src/android/aidl.md:7
#, fuzzy
msgid "You can create new AIDL servers in Rust."
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î½Î­Î¿Ï…Ï‚ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚ AIDL ÏƒÏ„Î¿ Rust."

#: src/android/aidl/interface.md:1
#, fuzzy
msgid "AIDL Interfaces"
msgstr "Î”Î¹ÎµÏ€Î±Ï†Î­Ï‚ AIDL"

#: src/android/aidl/interface.md:3
#, fuzzy
msgid "You declare the API of your service using an AIDL interface:"
msgstr "Î”Î·Î»ÏÎ½ÎµÏ„Îµ Ï„Î¿ API Ï„Î·Ï‚ Ï…Ï€Î·ÏÎµÏƒÎ¯Î±Ï‚ ÏƒÎ±Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Î¼Î¹Î± Î´Î¹ÎµÏ€Î±Ï†Î® AIDL:"

#: src/android/aidl/interface.md:5
#, fuzzy
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md:7
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years);\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:17
#, fuzzy
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md:19
msgid ""
"```javascript\n"
"aidl_interface {\n"
"    name: \"com.example.birthdayservice\",\n"
"    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
"    unstable: true,\n"
"    backend: {\n"
"        rust: { // Rust is not enabled by default\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/interface.md:32
#, fuzzy
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¿ \"vendor_available: true\" ÎµÎ¬Î½ Ï„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ AIDL ÏƒÎ±Ï‚ "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Î­Î½Î± Î´Ï…Î±Î´Î¹ÎºÏŒ Î±ÏÏ‡ÎµÎ¯Î¿ ÏƒÏ„Î¿Î½ Ï€ÏÎ¿Î¼Î·Î¸ÎµÏ…Ï„Î® Ï‡ÏÏÎ¹ÏƒÎ¼Î±."

#: src/android/aidl/implementation.md:1
#, fuzzy
msgid "Service Implementation"
msgstr "Î¥Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï…Ï€Î·ÏÎµÏƒÎ¯Î±Ï‚"

#: src/android/aidl/implementation.md:3
#, fuzzy
msgid "We can now implement the AIDL service:"
msgstr "ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Ï„ÏÏÎ± Î½Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ Ï…Ï€Î·ÏÎµÏƒÎ¯Î± AIDL:"

#: src/android/aidl/implementation.md:5
#, fuzzy
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md:7
msgid ""
"```rust,ignore\n"
"//! Implementation of the `IBirthdayService` AIDL interface.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"/// The `IBirthdayService` implementation.\n"
"pub struct BirthdayService;\n"
"\n"
"impl binder::Interface for BirthdayService {}\n"
"\n"
"impl IBirthdayService for BirthdayService {\n"
"    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
"Result<String> {\n"
"        Ok(format!(\n"
"            \"Happy Birthday {name}, congratulations with the {years} years!"
"\"\n"
"        ))\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/implementation.md:26 src/android/aidl/server.md:28
#: src/android/aidl/client.md:37
#, fuzzy
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md:28
msgid ""
"```javascript\n"
"rust_library {\n"
"    name: \"libbirthdayservice\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    crate_name: \"birthdayservice\",\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:1
#, fuzzy
msgid "AIDL Server"
msgstr "Î”Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î®Ï‚ AIDL"

#: src/android/aidl/server.md:3
#, fuzzy
msgid "Finally, we can create a server which exposes the service:"
msgstr ""
"Î¤Î­Î»Î¿Ï‚, Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î­Î½Î±Î½ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î® Ï€Î¿Ï… ÎµÎºÎ¸Î­Ï„ÎµÎ¹ Ï„Î·Î½ Ï…Ï€Î·ÏÎµÏƒÎ¯Î±:"

#: src/android/aidl/server.md:5
#, fuzzy
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use birthdayservice::BirthdayService;\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::BnBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Entry point for birthday service.\n"
"fn main() {\n"
"    let birthday_service = BirthdayService;\n"
"    let birthday_service_binder = BnBirthdayService::new_binder(\n"
"        birthday_service,\n"
"        binder::BinderFeatures::default(),\n"
"    );\n"
"    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
"as_binder())\n"
"        .expect(\"Failed to register service\");\n"
"    binder::ProcessState::join_thread_pool()\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/server.md:30
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_server\",\n"
"    crate_name: \"birthday_server\",\n"
"    srcs: [\"src/server.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"        \"libbirthdayservice\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:3
#, fuzzy
msgid "We can now build, push, and start the service:"
msgstr ""
"ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Ï„ÏÏÎ± Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ, Î½Î± Ï€ÏÎ¿Ï‰Î¸Î®ÏƒÎ¿Ï…Î¼Îµ ÎºÎ±Î¹ Î½Î± Î¾ÎµÎºÎ¹Î½Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ "
"Ï…Ï€Î·ÏÎµÏƒÎ¯Î±:"

#: src/android/aidl/deploy.md:5
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:11
#, fuzzy
msgid "In another terminal, check that the service runs:"
msgstr "Î£Îµ Î¬Î»Î»Î¿ Ï„ÎµÏÎ¼Î±Ï„Î¹ÎºÏŒ, ÎµÎ»Î­Î³Î¾Ï„Îµ ÏŒÏ„Î¹ Î· Ï…Ï€Î·ÏÎµÏƒÎ¯Î± ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Î±Î¹:"

#: src/android/aidl/deploy.md:13
msgid ""
"```shell\n"
"adb shell service check birthdayservice\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:17
msgid ""
"```text\n"
"Service birthdayservice: found\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:21
#, fuzzy
msgid "You can also call the service with `service call`:"
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Ï„Î·Î½ Ï…Ï€Î·ÏÎµÏƒÎ¯Î± Î¼Îµ Â«ÎºÎ»Î®ÏƒÎ· Ï…Ï€Î·ÏÎµÏƒÎ¯Î±Ï‚Â»:"

#: src/android/aidl/deploy.md:23
msgid ""
"```shell\n"
"adb shell service call birthdayservice 1 s16 Bob i32 24\n"
"```"
msgstr ""

#: src/android/aidl/deploy.md:27
msgid ""
"```text\n"
"Result: Parcel(\n"
"  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'\n"
"  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'\n"
"  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'\n"
"  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'\n"
"  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'\n"
"  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'\n"
"  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'\n"
"  0x00000070: 00210073 00000000                   's.!.....        ')\n"
"```"
msgstr ""

#: src/android/aidl/client.md:1
#, fuzzy
msgid "AIDL Client"
msgstr "Î ÎµÎ»Î¬Ï„Î·Ï‚ AIDL"

#: src/android/aidl/client.md:3
#, fuzzy
msgid "Finally, we can create a Rust client for our new service."
msgstr ""
"Î¤Î­Î»Î¿Ï‚, Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î­Î½Î±Î½ Ï€ÎµÎ»Î¬Ï„Î· Rust Î³Î¹Î± Ï„Î· Î½Î­Î± Î¼Î±Ï‚ Ï…Ï€Î·ÏÎµÏƒÎ¯Î±."

#: src/android/aidl/client.md:5
#, fuzzy
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md:7
msgid ""
"```rust,ignore\n"
"//! Birthday service.\n"
"use com_example_birthdayservice::aidl::com::example::birthdayservice::"
"IBirthdayService::IBirthdayService;\n"
"use com_example_birthdayservice::binder;\n"
"\n"
"const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
"\n"
"/// Connect to the BirthdayService.\n"
"pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
"StatusCode> {\n"
"    binder::get_interface(SERVICE_IDENTIFIER)\n"
"}\n"
"\n"
"/// Call the birthday service.\n"
"fn main() -> Result<(), binder::Status> {\n"
"    let name = std::env::args()\n"
"        .nth(1)\n"
"        .unwrap_or_else(|| String::from(\"Bob\"));\n"
"    let years = std::env::args()\n"
"        .nth(2)\n"
"        .and_then(|arg| arg.parse::<i32>().ok())\n"
"        .unwrap_or(42);\n"
"\n"
"    binder::ProcessState::start_thread_pool();\n"
"    let service = connect().expect(\"Failed to connect to "
"BirthdayService\");\n"
"    let msg = service.wishHappyBirthday(&name, years)?;\n"
"    println!(\"{msg}\");\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:39
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"birthday_client\",\n"
"    crate_name: \"birthday_client\",\n"
"    srcs: [\"src/client.rs\"],\n"
"    rustlibs: [\n"
"        \"com.example.birthdayservice-rust\",\n"
"        \"libbinder_rs\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/aidl/client.md:52
#, fuzzy
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ ÏŒÏ„Î¹ Î¿ Ï€ÎµÎ»Î¬Ï„Î·Ï‚ Î´ÎµÎ½ ÎµÎ¾Î±ÏÏ„Î¬Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿ \"libbirthdayservice\"."

#: src/android/aidl/client.md:54
#, fuzzy
msgid "Build, push, and run the client on your device:"
msgstr "Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ, Ï€ÏÎ¿Ï‰Î¸Î®ÏƒÏ„Îµ ÎºÎ±Î¹ ÎµÎºÏ„ÎµÎ»Î­ÏƒÏ„Îµ Ï„Î¿Î½ Ï€ÎµÎ»Î¬Ï„Î· ÏƒÏ„Î· ÏƒÏ…ÏƒÎºÎµÏ…Î® ÏƒÎ±Ï‚:"

#: src/android/aidl/client.md:56
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""

#: src/android/aidl/client.md:62
msgid ""
"```text\n"
"Happy Birthday Charlie, congratulations with the 60 years!\n"
"```"
msgstr ""

#: src/android/aidl/changing.md:3
#, fuzzy
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr ""
"Î‘Ï‚ ÎµÏ€ÎµÎºÏ„ÎµÎ¯Î½Î¿Ï…Î¼Îµ Ï„Î¿ API Î¼Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ· Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î±: Î¸Î­Î»Î¿Ï…Î¼Îµ Î½Î± "
"ÎµÏ€Î¹Ï„ÏÎ­ÏˆÎ¿Ï…Î¼Îµ ÏƒÏ„Î¿Ï…Ï‚ Ï€ÎµÎ»Î¬Ï„ÎµÏ‚ Î½Î± ÎºÎ±Î¸Î¿ÏÎ¯ÏƒÎ¿Ï…Î½ Î± Î»Î¯ÏƒÏ„Î± Î³ÏÎ±Î¼Î¼ÏÎ½ Î³Î¹Î± Ï„Î·Î½ ÎºÎ¬ÏÏ„Î± "
"Î³ÎµÎ½ÎµÎ¸Î»Î¯Ï‰Î½:"

#: src/android/aidl/changing.md:6
msgid ""
"```java\n"
"package com.example.birthdayservice;\n"
"\n"
"/** Birthday service interface. */\n"
"interface IBirthdayService {\n"
"    /** Generate a Happy Birthday message. */\n"
"    String wishHappyBirthday(String name, int years, in String[] text);\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:3
#, fuzzy
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"Î˜Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ ÎºÎ¹Î²ÏÏ„Î¹Î¿ Â«logÂ» Î³Î¹Î± Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î· ÏƒÏÎ½Î´ÎµÏƒÎ· ÏƒÏ„Î¿ "
"Â«logcatÂ» (ÏƒÎµ ÏƒÏ…ÏƒÎºÎµÏ…Î®) Î® `stdout` (ÏƒÏ„Î¿Î½ Î¿Î¹ÎºÎ¿Î´ÎµÏƒÏ€ÏŒÏ„Î·):"

#: src/android/logging.md:6
#, fuzzy
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md:8
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"hello_rust_logs\",\n"
"    crate_name: \"hello_rust_logs\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"liblog_rust\",\n"
"        \"liblogger\",\n"
"    ],\n"
"    prefer_rlib: true,\n"
"    host_supported: true,\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:22
#, fuzzy
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md:24
msgid ""
"```rust,ignore\n"
"//! Rust logging demo.\n"
"\n"
"use log::{debug, error, info};\n"
"\n"
"/// Logs a greeting.\n"
"fn main() {\n"
"    logger::init(\n"
"        logger::Config::default()\n"
"            .with_tag_on_device(\"rust\")\n"
"            .with_min_level(log::Level::Trace),\n"
"    );\n"
"    debug!(\"Starting program.\");\n"
"    info!(\"Things are going fine.\");\n"
"    error!(\"Something went wrong!\");\n"
"}\n"
"```"
msgstr ""

#: src/android/logging.md:42 src/android/interoperability/with-c/bindgen.md:98
#: src/android/interoperability/with-c/rust.md:73
#, fuzzy
msgid "Build, push, and run the binary on your device:"
msgstr "Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ, ÏƒÏ€ÏÏÎ¾Ï„Îµ ÎºÎ±Î¹ ÎµÎºÏ„ÎµÎ»Î­ÏƒÏ„Îµ Ï„Î¿ Î´Ï…Î±Î´Î¹ÎºÏŒ ÏƒÏ„Î· ÏƒÏ…ÏƒÎºÎµÏ…Î® ÏƒÎ±Ï‚:"

#: src/android/logging.md:44
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""

#: src/android/logging.md:50
#, fuzzy
msgid "The logs show up in `adb logcat`:"
msgstr "Î¤Î± Î±ÏÏ‡ÎµÎ¯Î± ÎºÎ±Ï„Î±Î³ÏÎ±Ï†Î®Ï‚ ÎµÎ¼Ï†Î±Î½Î¯Î¶Î¿Î½Ï„Î±Î¹ ÏƒÏ„Î¿ `adb logcat`:"

#: src/android/logging.md:52
msgid ""
"```shell\n"
"adb logcat -s rust\n"
"```"
msgstr ""

#: src/android/logging.md:56
msgid ""
"```text\n"
"09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.\n"
"09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going "
"fine.\n"
"09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went "
"wrong!\n"
"```"
msgstr ""

#: src/android/interoperability.md:3
#, fuzzy
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr ""
"Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ ÎµÎ¾Î±Î¹ÏÎµÏ„Î¹ÎºÎ® Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Î´Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± Î¼Îµ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚. "
"Î‘Ï…Ï„ÏŒ ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î±:"

#: src/android/interoperability.md:6
#, fuzzy
msgid "Call Rust functions from other languages."
msgstr "ÎšÎ±Î»Î­ÏƒÏ„Îµ Ï„Î¹Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Rust Î±Ï€ÏŒ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚."

#: src/android/interoperability.md:7
#, fuzzy
msgid "Call functions written in other languages from Rust."
msgstr "ÎšÎ»Î®ÏƒÎ· ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½ Î³ÏÎ±Î¼Î¼Î­Î½Ï‰Î½ ÏƒÎµ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚ Î±Ï€ÏŒ Ï„Î¿ Rust."

#: src/android/interoperability.md:9
#, fuzzy
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"ÎŒÏ„Î±Î½ ÎºÎ±Î»ÎµÎ¯Ï„Îµ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ ÏƒÎµ Î¼Î¹Î± Î¾Î­Î½Î· Î³Î»ÏÏƒÏƒÎ±, Î»Î­Î¼Îµ ÏŒÏ„Î¹ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ a _Î¾Î­Î½Î· "
"Î´Î¹ÎµÏ€Î±Ï†Î® Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±Ï‚_, ÎµÏ€Î¯ÏƒÎ·Ï‚ Î³Î½Ï‰ÏƒÏ„Î® Ï‰Ï‚ FFI."

#: src/android/interoperability/with-c.md:1
#, fuzzy
msgid "Interoperability with C"
msgstr "Î”Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± Î¼Îµ C"

#: src/android/interoperability/with-c.md:3
#, fuzzy
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ Ï€Î»Î®ÏÎ· Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Ï„Î· ÏƒÏÎ½Î´ÎµÏƒÎ· Î±ÏÏ‡ÎµÎ¯Ï‰Î½ Î±Î½Ï„Î¹ÎºÎµÎ¹Î¼Î­Î½Ï‰Î½ Î¼Îµ Î¼Î¹Î± "
"ÏƒÏÎ¼Î²Î±ÏƒÎ· ÎºÎ»Î®ÏƒÎ·Ï‚ C. ÎŸÎ¼Î¿Î¯Ï‰Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎ¾Î¬Î³ÎµÏ„Îµ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Rust ÎºÎ±Î¹ Î½Î± Ï„Î¹Ï‚ "
"ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Î±Ï€ÏŒ Ï„Î¿ C."

#: src/android/interoperability/with-c.md:6
#, fuzzy
msgid "You can do it by hand if you want:"
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î¼Îµ Ï„Î¿ Ï‡Î­ÏÎ¹ Î±Î½ Î¸Î­Î»ÎµÏ„Îµ:"

#: src/android/interoperability/with-c.md:8
msgid ""
"```rust\n"
"extern \"C\" {\n"
"    fn abs(x: i32) -> i32;\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -42;\n"
"    let abs_x = unsafe { abs(x) };\n"
"    println!(\"{x}, {abs_x}\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c.md:20
#, fuzzy
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"Î¤Î¿ ÎµÎ¯Î´Î±Î¼Îµ Î®Î´Î· ÏƒÏ„Î¿ [Safe FFI Wrapper Î¬ÏƒÎºÎ·ÏƒÎ·](../../exercises/day-3/safe-ffi-"
"wrapper.md)."

#: src/android/interoperability/with-c.md:23
#, fuzzy
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr ""
"Î‘Ï…Ï„ÏŒ Ï€ÏÎ¿Ï‹Ï€Î¿Î¸Î­Ï„ÎµÎ¹ Ï€Î»Î®ÏÎ· Î³Î½ÏÏƒÎ· Ï„Î·Ï‚ Ï€Î»Î±Ï„Ï†ÏŒÏÎ¼Î±Ï‚-ÏƒÏ„ÏŒÏ‡Î¿Ï…. Î”ÎµÎ½ ÏƒÏ…Î½Î¹ÏƒÏ„Î¬Ï„Î±Î¹ Î³Î¹Î± "
"Ï€Î±ÏÎ±Î³Ï‰Î³Î®."

#: src/android/interoperability/with-c.md:26
#, fuzzy
msgid "We will look at better options next."
msgstr "Î˜Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎ¿Ï…Î¼Îµ ÎºÎ±Î»ÏÏ„ÎµÏÎµÏ‚ ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚ ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±."

#: src/android/interoperability/with-c/bindgen.md:1
#, fuzzy
msgid "Using Bindgen"
msgstr "Î§ÏÎ®ÏƒÎ· Bindgen"

#: src/android/interoperability/with-c/bindgen.md:3
#, fuzzy
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"Î¤Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿ [bindgen](https://rust-lang.github.io/rust-bindgen/introduction."
"html) Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Î´ÎµÏƒÎ¼ÎµÏÏƒÎµÎ¹Ï‚ Î±Ï€ÏŒ Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿ ÎºÎµÏ†Î±Î»Î¯Î´Î±Ï‚ C."

#: src/android/interoperability/with-c/bindgen.md:6
#, fuzzy
msgid "First create a small C library:"
msgstr "Î ÏÏÏ„Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î¼Î¹Î± Î¼Î¹ÎºÏÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· C:"

#: src/android/interoperability/with-c/bindgen.md:8
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "_interoperability/bindgen/libbirthday.h_:"

#: src/android/interoperability/with-c/bindgen.md:10
msgid ""
"```c\n"
"typedef struct card {\n"
"  const char* name;\n"
"  int years;\n"
"} card;\n"
"\n"
"void print_card(const card* card);\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:19
#, fuzzy
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md:21
msgid ""
"```c\n"
"#include <stdio.h>\n"
"#include \"libbirthday.h\"\n"
"\n"
"void print_card(const card* card) {\n"
"  printf(\"+--------------\\n\");\n"
"  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
"  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
"  printf(\"+--------------\\n\");\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:33
#, fuzzy
msgid "Add this to your `Android.bp` file:"
msgstr "Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Î±Ï…Ï„ÏŒ ÏƒÏ„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ ÏƒÎ±Ï‚ Â«Android.bpÂ»:"

#: src/android/interoperability/with-c/bindgen.md:35
#: src/android/interoperability/with-c/bindgen.md:55
#: src/android/interoperability/with-c/bindgen.md:69
#: src/android/interoperability/with-c/bindgen.md:108
#, fuzzy
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperability/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md:37
msgid ""
"```javascript\n"
"cc_library {\n"
"    name: \"libbirthday\",\n"
"    srcs: [\"libbirthday.c\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:44
#, fuzzy
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr ""
"Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿ ÎºÎµÏ†Î±Î»Î¯Î´Î±Ï‚ Ï€ÎµÏÎ¹Ï„Ï…Î»Î¯Î³Î¼Î±Ï„Î¿Ï‚ Î³Î¹Î± Ï„Î· Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· (Î´ÎµÎ½ "
"Î±Ï€Î±Î¹Ï„ÎµÎ¯Ï„Î±Î¹ Î±Ï…ÏƒÏ„Î·ÏÎ¬ ÏƒÎµ Î±Ï…Ï„ÏŒ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±):"

#: src/android/interoperability/with-c/bindgen.md:47
#, fuzzy
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md:49
msgid ""
"```c\n"
"#include \"libbirthday.h\"\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:53
#, fuzzy
msgid "You can now auto-generate the bindings:"
msgstr "Î¤ÏÏÎ± Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï„Î¹Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎµÎ¹Ï‚:"

#: src/android/interoperability/with-c/bindgen.md:57
msgid ""
"```javascript\n"
"rust_bindgen {\n"
"    name: \"libbirthday_bindgen\",\n"
"    crate_name: \"birthday_bindgen\",\n"
"    wrapper_src: \"libbirthday_wrapper.h\",\n"
"    source_stem: \"bindings\",\n"
"    static_libs: [\"libbirthday\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:67
#, fuzzy
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "Î¤Î­Î»Î¿Ï‚, Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¹Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎµÎ¹Ï‚ ÏƒÏ„Î¿ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Rust:"

#: src/android/interoperability/with-c/bindgen.md:71
msgid ""
"```javascript\n"
"rust_binary {\n"
"    name: \"print_birthday_card\",\n"
"    srcs: [\"main.rs\"],\n"
"    rustlibs: [\"libbirthday_bindgen\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:79
#, fuzzy
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md:81
msgid ""
"```rust,compile_fail\n"
"//! Bindgen demo.\n"
"\n"
"use birthday_bindgen::{card, print_card};\n"
"\n"
"fn main() {\n"
"    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
"    let card = card {\n"
"        name: name.as_ptr(),\n"
"        years: 42,\n"
"    };\n"
"    unsafe {\n"
"        print_card(&card as *const card);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:100
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:106
#, fuzzy
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr ""
"Î¤Î­Î»Î¿Ï‚, Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± ÎµÎºÏ„ÎµÎ»Î­ÏƒÎ¿Ï…Î¼Îµ Î´Î¿ÎºÎ¹Î¼Î­Ï‚ Ï€Î¿Ï… Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¿ÏÎ½Ï„Î±Î¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Î³Î¹Î± Î½Î± "
"Î´Î¹Î±ÏƒÏ†Î±Î»Î¯ÏƒÎ¿Ï…Î¼Îµ ÏŒÏ„Î¹ Î¿Î¹ Î´ÎµÏƒÎ¼ÎµÏÏƒÎµÎ¹Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÎ½:"

#: src/android/interoperability/with-c/bindgen.md:110
msgid ""
"```javascript\n"
"rust_test {\n"
"    name: \"libbirthday_bindgen_test\",\n"
"    srcs: [\":libbirthday_bindgen\"],\n"
"    crate_name: \"libbirthday_bindgen_test\",\n"
"    test_suites: [\"general-tests\"],\n"
"    auto_gen_config: true,\n"
"    clippy_lints: \"none\", // Generated file, skip linting\n"
"    lints: \"none\",\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md:122
msgid ""
"```shell\n"
"atest libbirthday_bindgen_test\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:1
#, fuzzy
msgid "Calling Rust"
msgstr "Calling Rust"

#: src/android/interoperability/with-c/rust.md:3
#, fuzzy
msgid "Exporting Rust functions and types to C is easy:"
msgstr "Î— ÎµÎ¾Î±Î³Ï‰Î³Î® Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÏÎ½ ÎºÎ±Î¹ Ï„ÏÏ€Ï‰Î½ Rust ÏƒÏ„Î¿ C ÎµÎ¯Î½Î±Î¹ ÎµÏÎºÎ¿Î»Î·:"

#: src/android/interoperability/with-c/rust.md:5
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md:7
msgid ""
"```rust,editable\n"
"//! Rust FFI demo.\n"
"#![deny(improper_ctypes_definitions)]\n"
"\n"
"use std::os::raw::c_int;\n"
"\n"
"/// Analyze the numbers.\n"
"#[no_mangle]\n"
"pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
"    if x < y {\n"
"        println!(\"x ({x}) is smallest!\");\n"
"    } else {\n"
"        println!(\"y ({y}) is probably larger than x ({x})\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:24
#, fuzzy
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md:26
msgid ""
"```c\n"
"#ifndef ANALYSE_H\n"
"#define ANALYSE_H\n"
"\n"
"extern \"C\" {\n"
"void analyze_numbers(int x, int y);\n"
"}\n"
"\n"
"#endif\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:37
#, fuzzy
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:39
msgid ""
"```javascript\n"
"rust_ffi {\n"
"    name: \"libanalyze_ffi\",\n"
"    crate_name: \"analyze_ffi\",\n"
"    srcs: [\"analyze.rs\"],\n"
"    include_dirs: [\".\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:48
#, fuzzy
msgid "We can now call this from a C binary:"
msgstr "ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Ï„ÏÏÎ± Î½Î± Ï„Î¿ Î¿Î½Î¿Î¼Î¬ÏƒÎ¿Ï…Î¼Îµ Î±Ï…Ï„ÏŒ Î±Ï€ÏŒ Î­Î½Î± Î´Ï…Î±Î´Î¹ÎºÏŒ C:"

#: src/android/interoperability/with-c/rust.md:50
#, fuzzy
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md:52
msgid ""
"```c\n"
"#include \"analyze.h\"\n"
"\n"
"int main() {\n"
"  analyze_numbers(10, 20);\n"
"  analyze_numbers(123, 123);\n"
"  return 0;\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:62
#, fuzzy
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md:64
msgid ""
"```javascript\n"
"cc_binary {\n"
"    name: \"analyze_numbers\",\n"
"    srcs: [\"main.c\"],\n"
"    static_libs: [\"libanalyze_ffi\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:75
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""

#: src/android/interoperability/with-c/rust.md:83
#, fuzzy
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"Î¤Î¿ \"#\\[no_mangle\\]\" Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î· ÏƒÏ…Î½Î®Î¸Î· Ï€Î±ÏÎ±Ï€Î¿Î¯Î·ÏƒÎ· Î¿Î½ÏŒÎ¼Î±Ï„Î¿Ï‚ Ï„Î¿Ï… "
"Rust, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Ï„Î¿ ÏƒÏÎ¼Î²Î¿Î»Î¿ Ï€Î¿Ï… Î¸Î± ÎµÎ¾Î±Ï‡Î¸ÎµÎ¯ Î¸Î± ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»ÏÏ‚ Ï„Î¿ ÏŒÎ½Î¿Î¼Î± Ï„Î¿Ï… Î· "
"Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±. ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ `#[export_name = "
"\"some_name\"]` Î³Î¹Î± Î½Î± ÎºÎ±Î¸Î¿ÏÎ¯ÏƒÎµÏ„Îµ ÏŒÏ€Î¿Î¹Î¿ ÏŒÎ½Î¿Î¼Î± Î¸Î­Î»ÎµÏ„Îµ."

#: src/android/interoperability/cpp.md:3
#, fuzzy
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"Î¤Î¿ [CXX crate](https://cxx.rs/) ÎºÎ±Î¸Î¹ÏƒÏ„Î¬ Î´Ï…Î½Î±Ï„Î® Ï„Î·Î½ Î±ÏƒÏ†Î±Î»Î® Î´Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± "
"Î¼ÎµÏ„Î±Î¾Ï Ï„Î¿Ï… Rust ÎºÎ±Î¹ C++."

#: src/android/interoperability/cpp.md:6
#, fuzzy
msgid "The overall approach looks like this:"
msgstr "Î— ÏƒÏ…Î½Î¿Î»Î¹ÎºÎ® Ï€ÏÎ¿ÏƒÎ­Î³Î³Î¹ÏƒÎ· Î¼Î¿Î¹Î¬Î¶ÎµÎ¹ Î¼Îµ Î±Ï…Ï„ÏŒ:"

#: src/android/interoperability/cpp.md:10
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for an full example of "
"using this."
msgstr ""
"Î”ÎµÎ¯Ï„Îµ Ï„Î¿ [CXX tutorial](https://cxx.rs/tutorial.html) Î³Î¹Î± Î­Î½Î± Ï€Î»Î®ÏÎµÏ‚ "
"Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Ï‡ÏÎ®ÏƒÎ·Ï‚ Î±Ï…Ï„Î¿Ï."

#: src/android/interoperability/cpp.md:14
msgid ""
"At this point, the instructor should switch to the [CXX tutorial](https://"
"cxx.rs/tutorial.html)."
msgstr ""

#: src/android/interoperability/cpp.md:16
msgid "Walk the students through the tutorial step by step."
msgstr ""

#: src/android/interoperability/cpp.md:18
msgid ""
"Highlight how CXX presents a clean interface without unsafe code in _both "
"languages_."
msgstr ""

#: src/android/interoperability/cpp.md:20
msgid ""
"Show the correspondence between [Rust and C++ types](https://cxx.rs/bindings."
"html):"
msgstr ""

#: src/android/interoperability/cpp.md:22
msgid ""
"Explain how a Rust `String` cannot map to a C++ `std::string` (the latter "
"does not uphold the UTF-8 invariant). Show that despite being different "
"types, `rust::String` in C++ can be easily constructed from a C++ `std::"
"string`, making it very ergonomic to use."
msgstr ""

#: src/android/interoperability/cpp.md:28
msgid ""
"Explain that a Rust function returning `Result<T, E>` becomes a function "
"which throws a `E` exception in C++ (and vice versa)."
msgstr ""

#: src/android/interoperability/java.md:1
#, fuzzy
msgid "Interoperability with Java"
msgstr "Î”Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± Î¼Îµ Java"

#: src/android/interoperability/java.md:3
#, fuzzy
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Î— Java Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï†Î¿ÏÏ„ÏÏƒÎµÎ¹ ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î± Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… [Java Native "
"Interface (JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface). Î¤Î¿ "
"[`jni` crate](https://docs.rs/jni/) ÏƒÎ±Ï‚ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ Î¼Î¹Î± "
"ÏƒÏ…Î¼Î²Î±Ï„Î® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·."

#: src/android/interoperability/java.md:7
#, fuzzy
msgid "First, we create a Rust function to export to Java:"
msgstr "Î‘ÏÏ‡Î¹ÎºÎ¬, Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¿ÏÎ¼Îµ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Rust Î³Î¹Î± ÎµÎ¾Î±Î³Ï‰Î³Î® ÏƒÎµ Java:"

#: src/android/interoperability/java.md:9
#, fuzzy
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md:11
msgid ""
"```rust,compile_fail\n"
"//! Rust <-> Java FFI demo.\n"
"\n"
"use jni::objects::{JClass, JString};\n"
"use jni::sys::jstring;\n"
"use jni::JNIEnv;\n"
"\n"
"/// HelloWorld::hello method implementation.\n"
"#[no_mangle]\n"
"pub extern \"system\" fn Java_HelloWorld_hello(\n"
"    env: JNIEnv,\n"
"    _class: JClass,\n"
"    name: JString,\n"
") -> jstring {\n"
"    let input: String = env.get_string(name).unwrap().into();\n"
"    let greeting = format!(\"Hello, {input}!\");\n"
"    let output = env.new_string(greeting).unwrap();\n"
"    output.into_inner()\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:32
#: src/android/interoperability/java.md:62
#, fuzzy
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md:34
msgid ""
"```javascript\n"
"rust_ffi_shared {\n"
"    name: \"libhello_jni\",\n"
"    crate_name: \"hello_jni\",\n"
"    srcs: [\"src/lib.rs\"],\n"
"    rustlibs: [\"libjni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:43
#, fuzzy
msgid "Finally, we can call this function from Java:"
msgstr "Î¤Î­Î»Î¿Ï‚, Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± ÎºÎ±Î»Î­ÏƒÎ¿Ï…Î¼Îµ Î±Ï…Ï„Î® Ï„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î±Ï€ÏŒ Ï„Î·Î½ Java:"

#: src/android/interoperability/java.md:45
#, fuzzy
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md:47
msgid ""
"```java\n"
"class HelloWorld {\n"
"    private static native String hello(String name);\n"
"\n"
"    static {\n"
"        System.loadLibrary(\"hello_jni\");\n"
"    }\n"
"\n"
"    public static void main(String[] args) {\n"
"        String output = HelloWorld.hello(\"Alice\");\n"
"        System.out.println(output);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:64
msgid ""
"```javascript\n"
"java_binary {\n"
"    name: \"helloworld_jni\",\n"
"    srcs: [\"HelloWorld.java\"],\n"
"    main_class: \"HelloWorld\",\n"
"    required: [\"libhello_jni\"],\n"
"}\n"
"```"
msgstr ""

#: src/android/interoperability/java.md:73
#, fuzzy
msgid "Finally, you can build, sync, and run the binary:"
msgstr ""
"Î¤Î­Î»Î¿Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ, Î½Î± ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¯ÏƒÎµÏ„Îµ ÎºÎ±Î¹ Î½Î± ÎµÎºÏ„ÎµÎ»Î­ÏƒÎµÏ„Îµ Ï„Î¿ "
"Î´Ï…Î±Î´Î¹ÎºÏŒ:"

#: src/android/interoperability/java.md:75
msgid ""
"```shell\n"
"m helloworld_jni\n"
"adb sync  # requires adb root && adb remount\n"
"adb shell /system/bin/helloworld_jni\n"
"```"
msgstr ""

#: src/exercises/android/morning.md:3
#, fuzzy
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"Î“Î¹Î± Ï„Î·Î½ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± Î¬ÏƒÎºÎ·ÏƒÎ·, Î¸Î± Î´Î¿ÏÎ¼Îµ Î­Î½Î± Î±Ï€ÏŒ Ï„Î± Î­ÏÎ³Î± Î¼Îµ Ï„Î± Î¿Ï€Î¿Î¯Î± ÎµÏÎ³Î¬Î¶ÎµÏƒÏ„Îµ. "
"Î‘Ï†Î®ÏƒÏ„Îµ Î¼Î±Ï‚ Î¿Î¼Î±Î´Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ ÎºÎ±Î¹ ÎºÎ¬Î½Ï„Îµ Î±Ï…Ï„ÏŒ Î¼Î±Î¶Î¯. ÎœÎµÏÎ¹ÎºÎ­Ï‚ Ï€ÏÎ¿Ï„Î¬ÏƒÎµÎ¹Ï‚:"

#: src/exercises/android/morning.md:6
#, fuzzy
msgid "Call your AIDL service with a client written in Rust."
msgstr "ÎœÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÏ„Îµ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î±Ï€ÏŒ Ï„Î¿ Î­ÏÎ³Î¿ ÏƒÎ±Ï‚ ÏƒÏ„Î¿ Rust ÎºÎ±Î¹ ÎºÎ±Î»Î­ÏƒÏ„Îµ Ï„Î·Î½."

#: src/exercises/android/morning.md:8
msgid "Move a function from your project to Rust and call it."
msgstr ""

#: src/exercises/android/morning.md:12
#, fuzzy
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"Î”ÎµÎ½ Ï€Î±ÏÎ­Ï‡ÎµÏ„Î±Î¹ Î»ÏÏƒÎ· ÎµÎ´Ï, Î´ÎµÎ´Î¿Î¼Î­Î½Î¿Ï… ÏŒÏ„Î¹ Î±Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î±Î½Î¿Î¹Ï‡Ï„ÏŒ: Î²Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÎµ "
"ÎºÎ¬Ï€Î¿Î¹Î¿Î½ Î¼Î­ÏƒÎ± Î· Ï„Î¬Î¾Î· Î­Ï‡ÎµÎ¹ Î­Î½Î± ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ ÎºÏÎ´Î¹ÎºÎ± Ï€Î¿Ï… Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î¼ÎµÏ„Î±Ï†Î­ÏÎµÏ„Îµ ÏƒÏ„Î¿ "
"Rust on the fly."

#: src/bare-metal.md:1
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Comprehensive Rust ğŸ¦€"

#: src/bare-metal.md:3
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""

#: src/bare-metal.md:7
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""

#: src/bare-metal.md:10
msgid "What is `no_std` Rust?"
msgstr ""

#: src/bare-metal.md:11
msgid "Writing firmware for microcontrollers."
msgstr ""

#: src/bare-metal.md:12
msgid "Writing bootloader / kernel code for application processors."
msgstr ""

#: src/bare-metal.md:13
msgid "Some useful crates for bare-metal Rust development."
msgstr ""

#: src/bare-metal.md:15
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""

#: src/bare-metal.md:20
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr ""

#: src/bare-metal.md:22
msgid ""
"```bash\n"
"sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-"
"config qemu-system-arm\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal.md:30
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr ""

#: src/bare-metal.md:32
msgid ""
"```bash\n"
"echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", "
"GROUP=\"plugdev\"' |\\\n"
"  sudo tee /etc/udev/rules.d/50-microbit.rules\n"
"sudo udevadm control --reload-rules\n"
"```"
msgstr ""

#: src/bare-metal.md:38
msgid "On MacOS:"
msgstr ""

#: src/bare-metal.md:40
msgid ""
"```bash\n"
"xcode-select --install\n"
"brew install gdb picocom qemu\n"
"brew install --cask gcc-aarch64-embedded\n"
"rustup update\n"
"rustup target add aarch64-unknown-none thumbv7em-none-eabihf\n"
"rustup component add llvm-tools-preview\n"
"cargo install cargo-binutils cargo-embed\n"
"```"
msgstr ""

#: src/bare-metal/no_std.md:1
msgid "`no_std`"
msgstr ""

#: src/bare-metal/no_std.md:7
msgid "`core`"
msgstr ""

#: src/bare-metal/no_std.md:12 src/bare-metal/alloc.md:1
msgid "`alloc`"
msgstr ""

#: src/bare-metal/no_std.md:17
msgid "`std`"
msgstr ""

#: src/bare-metal/no_std.md:24
msgid "Slices, `&str`, `CStr`"
msgstr ""

#: src/bare-metal/no_std.md:25
msgid "`NonZeroU8`..."
msgstr ""

#: src/bare-metal/no_std.md:26
msgid "`Option`, `Result`"
msgstr ""

#: src/bare-metal/no_std.md:27
msgid "`Display`, `Debug`, `write!`..."
msgstr ""

#: src/bare-metal/no_std.md:29
msgid "`panic!`, `assert_eq!`..."
msgstr ""

#: src/bare-metal/no_std.md:30
msgid "`NonNull` and all the usual pointer-related functions"
msgstr ""

#: src/bare-metal/no_std.md:31
msgid "`Future` and `async`/`await`"
msgstr ""

#: src/bare-metal/no_std.md:32
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr ""

#: src/bare-metal/no_std.md:33
msgid "`Duration`"
msgstr ""

#: src/bare-metal/no_std.md:38
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr ""

#: src/bare-metal/no_std.md:39
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr ""

#: src/bare-metal/no_std.md:40
msgid "`String`, `CString`, `format!`"
msgstr ""

#: src/bare-metal/no_std.md:45
msgid "`Error`"
msgstr ""

#: src/bare-metal/no_std.md:47
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr ""

#: src/bare-metal/no_std.md:48
msgid "`File` and the rest of `fs`"
msgstr ""

#: src/bare-metal/no_std.md:49
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr ""

#: src/bare-metal/no_std.md:50
msgid "`Path`, `OsString`"
msgstr ""

#: src/bare-metal/no_std.md:51
msgid "`net`"
msgstr ""

#: src/bare-metal/no_std.md:52
msgid "`Command`, `Child`, `ExitCode`"
msgstr ""

#: src/bare-metal/no_std.md:53
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr ""

#: src/bare-metal/no_std.md:54
msgid "`SystemTime`, `Instant`"
msgstr ""

#: src/bare-metal/no_std.md:62
msgid "`HashMap` depends on RNG."
msgstr ""

#: src/bare-metal/no_std.md:63
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr ""

#: src/bare-metal/minimal.md:1
msgid "A minimal `no_std` program"
msgstr ""

#: src/bare-metal/minimal.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::panic::PanicInfo;\n"
"\n"
"#[panic_handler]\n"
"fn panic(_panic: &PanicInfo) -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/minimal.md:17
msgid "This will compile to an empty binary."
msgstr ""

#: src/bare-metal/minimal.md:18
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr ""

#: src/bare-metal/minimal.md:19
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr ""

#: src/bare-metal/minimal.md:20
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""

#: src/bare-metal/minimal.md:22
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""

#: src/bare-metal/alloc.md:3
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""

#: src/bare-metal/alloc.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate alloc;\n"
"extern crate panic_halt as _;\n"
"\n"
"use alloc::string::ToString;\n"
"use alloc::vec::Vec;\n"
"use buddy_system_allocator::LockedHeap;\n"
"\n"
"#[global_allocator]\n"
"static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();\n"
"\n"
"static mut HEAP: [u8; 65536] = [0; 65536];\n"
"\n"
"pub fn entry() {\n"
"    // Safe because `HEAP` is only used here and `entry` is only called "
"once.\n"
"    unsafe {\n"
"        // Give the allocator some memory to allocate.\n"
"        HEAP_ALLOCATOR\n"
"            .lock()\n"
"            .init(HEAP.as_mut_ptr() as usize, HEAP.len());\n"
"    }\n"
"\n"
"    // Now we can do things that require heap allocation.\n"
"    let mut v = Vec::new();\n"
"    v.push(\"A string\".to_string());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/alloc.md:39
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""

#: src/bare-metal/alloc.md:41
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""

#: src/bare-metal/alloc.md:43
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""

#: src/bare-metal/alloc.md:45
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""

#: src/bare-metal/alloc.md:47
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr ""

#: src/bare-metal/microcontrollers.md:3
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""

#: src/bare-metal/microcontrollers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use cortex_m_rt::entry;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers.md:21
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr ""

#: src/bare-metal/microcontrollers.md:25
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""

#: src/bare-metal/microcontrollers.md:27
msgid "Run the example with `cargo embed --bin minimal`"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:3
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"mod interrupts;\n"
"\n"
"use core::mem::size_of;\n"
"use cortex_m_rt::entry;\n"
"\n"
"/// GPIO port 0 peripheral address\n"
"const GPIO_P0: usize = 0x5000_0000;\n"
"\n"
"// GPIO peripheral offsets\n"
"const PIN_CNF: usize = 0x700;\n"
"const OUTSET: usize = 0x508;\n"
"const OUTCLR: usize = 0x50c;\n"
"\n"
"// PIN_CNF fields\n"
"const DIR_OUTPUT: u32 = 0x1;\n"
"const INPUT_DISCONNECT: u32 = 0x1 << 1;\n"
"const PULL_DISABLED: u32 = 0x0 << 2;\n"
"const DRIVE_S0S1: u32 = 0x0 << 8;\n"
"const SENSE_DISABLED: u32 = 0x0 << 16;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::<u32>()) as *mut "
"u32;\n"
"    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::<u32>()) as *mut "
"u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        pin_cnf_21.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"        pin_cnf_28.write_volatile(\n"
"            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | "
"SENSE_DISABLED,\n"
"        );\n"
"    }\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;\n"
"    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;\n"
"    // Safe because the pointers are to valid peripheral control registers, "
"and\n"
"    // no aliases exist.\n"
"    unsafe {\n"
"        gpio0_outclr.write_volatile(1 << 28);\n"
"        gpio0_outset.write_volatile(1 << 21);\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:64
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:66
#: src/bare-metal/microcontrollers/pacs.md:59
#: src/bare-metal/microcontrollers/hals.md:43
#: src/bare-metal/microcontrollers/board-support.md:34
msgid "Run the example with:"
msgstr ""

#: src/bare-metal/microcontrollers/mmio.md:68
msgid ""
"```sh\n"
"cargo embed --bin mmio\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:1
msgid "Peripheral Access Crates"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:3
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_pac::Peripherals;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p.P0;\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    gpio0.pin_cnf[21].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"    gpio0.pin_cnf[28].write(|w| {\n"
"        w.dir().output();\n"
"        w.input().disconnect();\n"
"        w.pull().disabled();\n"
"        w.drive().s0s1();\n"
"        w.sense().disabled();\n"
"        w\n"
"    });\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    gpio0.outclr.write(|w| w.pin28().clear());\n"
"    gpio0.outset.write(|w| w.pin21().set());\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:49
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:51
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:53
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:55
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:56
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""

#: src/bare-metal/microcontrollers/pacs.md:61
msgid ""
"```sh\n"
"cargo embed --bin pac\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:1
msgid "HAL crates"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:3
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:7
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use nrf52833_hal::gpio::{p0, Level};\n"
"use nrf52833_hal::pac::Peripherals;\n"
"use nrf52833_hal::prelude::*;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"\n"
"    // Create HAL wrapper for GPIO port 0.\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
"    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);\n"
"    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);\n"
"\n"
"    // Set pin 28 low and pin 21 high to turn the LED on.\n"
"    col1.set_low().unwrap();\n"
"    row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:39
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:40
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""

#: src/bare-metal/microcontrollers/hals.md:45
msgid ""
"```sh\n"
"cargo embed --bin hal\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:1
#, fuzzy
msgid "Board support crates"
msgstr "Î£Ï…Î½Ï„Î¿Î¼ÎµÏÏƒÎµÎ¹Ï‚ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»Î¿Î³Î¯Î¿Ï…"

#: src/bare-metal/microcontrollers/board-support.md:3
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use cortex_m_rt::entry;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::Board;\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let mut board = Board::take().unwrap();\n"
"\n"
"    board.display_pins.col1.set_low().unwrap();\n"
"    board.display_pins.row1.set_high().unwrap();\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:28
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:30
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:32
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr ""

#: src/bare-metal/microcontrollers/board-support.md:36
msgid ""
"```sh\n"
"cargo embed --bin board_support\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:1
msgid "The type state pattern"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:3
msgid ""
"```rust,editable,compile_fail\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let p = Peripherals::take().unwrap();\n"
"    let gpio0 = p0::Parts::new(p.P0);\n"
"\n"
"    let pin: P0_01<Disconnected> = gpio0.p0_01;\n"
"\n"
"    // let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
"    let pin_input: P0_01<Input<Floating>> = pin.into_floating_input();\n"
"    if pin_input.is_high().unwrap() {\n"
"        // ...\n"
"    }\n"
"    let mut pin_output: P0_01<Output<OpenDrain>> = pin_input\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    pin_output.set_high().unwrap();\n"
"    // pin_input.is_high(); // Error, moved.\n"
"\n"
"    let _pin2: P0_02<Output<OpenDrain>> = gpio0\n"
"        .p0_02\n"
"        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, "
"Level::Low);\n"
"    let _pin3: P0_03<Output<PushPull>> = gpio0.p0_03."
"into_push_pull_output(Level::Low);\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:32
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:34
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"canâ€™t keep use the old instance afterwards."
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:36
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:40
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""

#: src/bare-metal/microcontrollers/type-state.md:41
msgid "Many HAL crates follow this pattern."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:1
msgid "`embedded-hal`"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:3
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:6
msgid "GPIO"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:7
msgid "ADC"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:8
msgid "I2C, SPI, UART, CAN"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:9
msgid "RNG"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:10
msgid "Timers"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:11
msgid "Watchdogs"
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:13
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:19
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""

#: src/bare-metal/microcontrollers/embedded-hal.md:21
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:1
msgid "`probe-rs`, `cargo-embed`"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:3
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:6
msgid "SWD"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:6
msgid " and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid "GDB stub and Microsoft "
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid "DAP"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:7
msgid " server"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:8
msgid "Cargo integration"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:10
msgid "`cargo-embed` is a cargo subcommand to build and flash binaries, log "
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:11
msgid "RTT"
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:11
msgid ""
" output and connect GDB. It's configured by an `Embed.toml` file in your "
"project directory."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:16
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:19
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:21
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:22
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:23
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:25
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr ""

#: src/bare-metal/microcontrollers/probe-rs.md:26
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:3
msgid "Embed.toml:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:5
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:13
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:15
msgid ""
"```sh\n"
"cargo embed --bin board_support debug\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:19
#, fuzzy
msgid "In another terminal in the same directory:"
msgstr "Î£Îµ Î¬Î»Î»Î¿ Ï„ÎµÏÎ¼Î±Ï„Î¹ÎºÏŒ, ÎµÎ»Î­Î³Î¾Ï„Îµ ÏŒÏ„Î¹ Î· Ï…Ï€Î·ÏÎµÏƒÎ¯Î± ÎµÎºÏ„ÎµÎ»ÎµÎ¯Ï„Î±Î¹:"

#: src/bare-metal/microcontrollers/debugging.md:21
msgid ""
"```sh\n"
"gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-"
"command=\"target remote :1337\"\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:27
msgid "In GDB, try running:"
msgstr ""

#: src/bare-metal/microcontrollers/debugging.md:29
msgid ""
"```gdb\n"
"b src/bin/board_support.rs:29\n"
"b src/bin/board_support.rs:30\n"
"b src/bin/board_support.rs:32\n"
"c\n"
"c\n"
"c\n"
"```"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:1
#: src/bare-metal/aps/other-projects.md:1
msgid "Other projects"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:3
msgid "[RTIC](https://rtic.rs/)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:4
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:5
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:6
msgid "[Embassy](https://embassy.dev/)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:7
msgid "`async` executors with priorities, timers, networking, USB"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:8
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:9
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:10
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:11
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:12
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:13
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:18
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:19
msgid "It doesn't include any HALs."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:20
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:22
msgid "Cortex-M only."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:23
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr ""

#: src/bare-metal/microcontrollers/other-projects.md:24
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr ""

#: src/exercises/bare-metal/morning.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr ""

#: src/exercises/bare-metal/compass.md:3
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""

#: src/exercises/bare-metal/compass.md:6
msgid "Hints:"
msgstr ""

#: src/exercises/bare-metal/compass.md:8
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""

#: src/exercises/bare-metal/compass.md:11
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr ""

#: src/exercises/bare-metal/compass.md:12
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr ""

#: src/exercises/bare-metal/compass.md:13
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""

#: src/exercises/bare-metal/compass.md:17
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""

#: src/exercises/bare-metal/compass.md:19
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""

#: src/exercises/bare-metal/compass.md:23
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/compass.md:26 src/exercises/bare-metal/rtc.md:19
#, fuzzy
msgid "`src/main.rs`:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/compass.md:30
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};\n"
"\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
"\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // TODO\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:64 src/exercises/bare-metal/rtc.md:385
msgid "`Cargo.toml` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:68
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"compass\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"cortex-m-rt = \"0.7.3\"\n"
"embedded-hal = \"0.2.6\"\n"
"lsm303agr = \"0.2.2\"\n"
"microbit-v2 = \"0.13.0\"\n"
"panic-halt = \"0.2.0\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:85
msgid "`Embed.toml` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:89
msgid ""
"```toml\n"
"[default.general]\n"
"chip = \"nrf52833_xxAA\"\n"
"\n"
"[debug.gdb]\n"
"enabled = true\n"
"\n"
"[debug.reset]\n"
"halt_afterwards = true\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:100 src/exercises/bare-metal/rtc.md:985
msgid "`.cargo/config.toml` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/compass.md:104
msgid ""
"```toml\n"
"[build]\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\"-C\", \"link-arg=-Tlink.x\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:112
msgid "See the serial output on Linux with:"
msgstr ""

#: src/exercises/bare-metal/compass.md:114
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/ttyACM0\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:118
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr ""

#: src/exercises/bare-metal/compass.md:120
msgid ""
"```sh\n"
"picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502\n"
"```"
msgstr ""

#: src/exercises/bare-metal/compass.md:124
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr ""

#: src/bare-metal/aps.md:1
msgid "Application processors"
msgstr ""

#: src/bare-metal/aps.md:3
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""

#: src/bare-metal/aps.md:9
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""

#: src/bare-metal/aps.md:11
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""

#: src/bare-metal/aps/entry-point.md:3
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr ""

#: src/bare-metal/aps/entry-point.md:5
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""

#: src/bare-metal/aps/entry-point.md:77
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""

#: src/bare-metal/aps/entry-point.md:79
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""

#: src/bare-metal/aps/entry-point.md:83
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""

#: src/bare-metal/aps/entry-point.md:85
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr ""

#: src/bare-metal/aps/entry-point.md:86
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""

#: src/bare-metal/aps/entry-point.md:89
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cachable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""

#: src/bare-metal/aps/entry-point.md:94
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""

#: src/bare-metal/aps/entry-point.md:97
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr ""

#: src/bare-metal/aps/entry-point.md:98
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:1
msgid "Inline assembly"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:3
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an "
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:4
msgid "HVC"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:4
msgid " to tell the firmware to power off the system:"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use core::arch::asm;\n"
"use core::panic::PanicInfo;\n"
"\n"
"mod exceptions;\n"
"\n"
"const PSCI_SYSTEM_OFF: u32 = 0x84000008;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {\n"
"    // Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
"    unsafe {\n"
"        asm!(\"hvc #0\",\n"
"            inout(\"w0\") PSCI_SYSTEM_OFF => _,\n"
"            inout(\"w1\") 0 => _,\n"
"            inout(\"w2\") 0 => _,\n"
"            inout(\"w3\") 0 => _,\n"
"            inout(\"w4\") 0 => _,\n"
"            inout(\"w5\") 0 => _,\n"
"            inout(\"w6\") 0 => _,\n"
"            inout(\"w7\") 0 => _,\n"
"            options(nomem, nostack)\n"
"        );\n"
"    }\n"
"\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:39
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:43
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:46
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:49
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:51
msgid ""
"`_x0`â€“`_x3` are the values of registers `x0`â€“`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`â€“`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""

#: src/bare-metal/aps/inline-assembly.md:56
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/mmio.md:1
msgid "Volatile memory access for MMIO"
msgstr ""

#: src/bare-metal/aps/mmio.md:3
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr ""

#: src/bare-metal/aps/mmio.md:4
msgid "Never hold a reference."
msgstr ""

#: src/bare-metal/aps/mmio.md:5
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr ""

#: src/bare-metal/aps/mmio.md:9
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""

#: src/bare-metal/aps/mmio.md:11
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""

#: src/bare-metal/aps/mmio.md:13
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""

#: src/bare-metal/aps/mmio.md:15
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr ""

#: src/bare-metal/aps/uart.md:1
msgid "Let's write a UART driver"
msgstr ""

#: src/bare-metal/aps/uart.md:3
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""

#: src/bare-metal/aps/uart.md:5
msgid ""
"```rust,editable\n"
"const FLAG_REGISTER_OFFSET: usize = 0x18;\n"
"const FR_BUSY: u8 = 1 << 3;\n"
"const FR_TXFF: u8 = 1 << 5;\n"
"\n"
"/// Minimal driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    base_address: *mut u8,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u8) -> Self {\n"
"        Self { base_address }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register() & FR_TXFF != 0 {}\n"
"\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            self.base_address.write_volatile(byte);\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register() & FR_BUSY != 0 {}\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> u8 {\n"
"        // Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET)."
"read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart.md:55
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""

#: src/bare-metal/aps/uart.md:60
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""

#: src/bare-metal/aps/uart.md:63
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:1
#, fuzzy
msgid "More traits"
msgstr "Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬"

#: src/bare-metal/aps/uart/traits.md:3
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use core::fmt::{self, Write};\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/bare-metal/aps/uart/traits.md:24
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""

#: src/bare-metal/aps/uart/traits.md:25
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/better-uart.md:1
msgid "A better UART driver"
msgstr ""

#: src/bare-metal/aps/better-uart.md:3
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""

#: src/bare-metal/aps/better-uart.md:7
msgid "Offset"
msgstr ""

#: src/bare-metal/aps/better-uart.md:7
msgid "Register name"
msgstr ""

#: src/bare-metal/aps/better-uart.md:7
msgid "Width"
msgstr ""

#: src/bare-metal/aps/better-uart.md:9
msgid "0x00"
msgstr ""

#: src/bare-metal/aps/better-uart.md:9
msgid "DR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:9
msgid "12"
msgstr ""

#: src/bare-metal/aps/better-uart.md:10
msgid "0x04"
msgstr ""

#: src/bare-metal/aps/better-uart.md:10
msgid "RSR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:10
msgid "4"
msgstr ""

#: src/bare-metal/aps/better-uart.md:11
msgid "0x18"
msgstr ""

#: src/bare-metal/aps/better-uart.md:11
msgid "FR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:11
msgid "9"
msgstr ""

#: src/bare-metal/aps/better-uart.md:12
msgid "0x20"
msgstr ""

#: src/bare-metal/aps/better-uart.md:12
msgid "ILPR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:12 src/bare-metal/aps/better-uart.md:15
msgid "8"
msgstr ""

#: src/bare-metal/aps/better-uart.md:13
msgid "0x24"
msgstr ""

#: src/bare-metal/aps/better-uart.md:13
msgid "IBRD"
msgstr ""

#: src/bare-metal/aps/better-uart.md:13 src/bare-metal/aps/better-uart.md:16
msgid "16"
msgstr ""

#: src/bare-metal/aps/better-uart.md:14
msgid "0x28"
msgstr ""

#: src/bare-metal/aps/better-uart.md:14
msgid "FBRD"
msgstr ""

#: src/bare-metal/aps/better-uart.md:14 src/bare-metal/aps/better-uart.md:17
msgid "6"
msgstr ""

#: src/bare-metal/aps/better-uart.md:15
msgid "0x2c"
msgstr ""

#: src/bare-metal/aps/better-uart.md:15
msgid "LCR_H"
msgstr ""

#: src/bare-metal/aps/better-uart.md:16
msgid "0x30"
msgstr ""

#: src/bare-metal/aps/better-uart.md:16
msgid "CR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:17
msgid "0x34"
msgstr ""

#: src/bare-metal/aps/better-uart.md:17
msgid "IFLS"
msgstr ""

#: src/bare-metal/aps/better-uart.md:18
msgid "0x38"
msgstr ""

#: src/bare-metal/aps/better-uart.md:18
msgid "IMSC"
msgstr ""

#: src/bare-metal/aps/better-uart.md:18 src/bare-metal/aps/better-uart.md:19
#: src/bare-metal/aps/better-uart.md:20 src/bare-metal/aps/better-uart.md:21
msgid "11"
msgstr ""

#: src/bare-metal/aps/better-uart.md:19
msgid "0x3c"
msgstr ""

#: src/bare-metal/aps/better-uart.md:19
msgid "RIS"
msgstr ""

#: src/bare-metal/aps/better-uart.md:20
msgid "0x40"
msgstr ""

#: src/bare-metal/aps/better-uart.md:20
msgid "MIS"
msgstr ""

#: src/bare-metal/aps/better-uart.md:21
msgid "0x44"
msgstr ""

#: src/bare-metal/aps/better-uart.md:21
msgid "ICR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:22
msgid "0x48"
msgstr ""

#: src/bare-metal/aps/better-uart.md:22
msgid "DMACR"
msgstr ""

#: src/bare-metal/aps/better-uart.md:22
msgid "3"
msgstr ""

#: src/bare-metal/aps/better-uart.md:26
msgid "There are also some ID registers which have been omitted for brevity."
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:3
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/bitflags.md:37
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:1
msgid "Multiple registers"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:3
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/registers.md:41
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:3
msgid "Now let's use the new `Registers` struct in our driver."
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:5
msgid ""
"```rust,editable,compile_fail\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/driver.md:64
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:1
#: src/bare-metal/aps/logging/using.md:1
#, fuzzy
msgid "Using it"
msgstr "Î§ÏÎ®ÏƒÎ· Bindgen"

#: src/bare-metal/aps/better-uart/using.md:3
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:6
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use core::panic::PanicInfo;\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"\n"
"    writeln!(uart, \"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\").unwrap();\n"
"\n"
"    loop {\n"
"        if let Some(byte) = uart.read_byte() {\n"
"            uart.write_byte(byte);\n"
"            match byte {\n"
"                b'\\r' => {\n"
"                    uart.write_byte(b'\\n');\n"
"                }\n"
"                b'q' => break,\n"
"                _ => {}\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    writeln!(uart, \"Bye!\").unwrap();\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:51
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""

#: src/bare-metal/aps/better-uart/using.md:53
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""

#: src/bare-metal/aps/logging.md:3
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""

#: src/bare-metal/aps/logging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging.md:50
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""

#: src/bare-metal/aps/logging/using.md:3
msgid "We need to initialise the logger before we use it."
msgstr ""

#: src/bare-metal/aps/logging/using.md:5
msgid ""
"```rust,editable,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\");\n"
"\n"
"    assert_eq!(x1, 42);\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/logging/using.md:46
msgid "Note that our panic handler can now log details of panics."
msgstr ""

#: src/bare-metal/aps/logging/using.md:47
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""

#: src/bare-metal/aps/exceptions.md:3
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""

#: src/bare-metal/aps/exceptions.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use log::error;\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/aps/exceptions.md:64
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr ""

#: src/bare-metal/aps/exceptions.md:65
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""

#: src/bare-metal/aps/exceptions.md:67
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr ""

#: src/bare-metal/aps/exceptions.md:69
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""

#: src/bare-metal/aps/other-projects.md:3
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr ""

#: src/bare-metal/aps/other-projects.md:4
msgid "\"coreboot without the C\""
msgstr ""

#: src/bare-metal/aps/other-projects.md:5
msgid "Supports x86, aarch64 and RISC-V."
msgstr ""

#: src/bare-metal/aps/other-projects.md:6
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr ""

#: src/bare-metal/aps/other-projects.md:7
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""

#: src/bare-metal/aps/other-projects.md:8
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""

#: src/bare-metal/aps/other-projects.md:10
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""

#: src/bare-metal/aps/other-projects.md:12
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr ""

#: src/bare-metal/aps/other-projects.md:13
msgid "Static analysis to determine maximum stack usage."
msgstr ""

#: src/bare-metal/aps/other-projects.md:17
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""

#: src/bare-metal/aps/other-projects.md:19
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""

#: src/bare-metal/aps/other-projects.md:22
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cachable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""

#: src/bare-metal/useful-crates.md:3
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:1
msgid "`zerocopy`"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:3
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use zerocopy::AsBytes;\n"
"\n"
"#[repr(u32)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"enum RequestType {\n"
"    #[default]\n"
"    In = 0,\n"
"    Out = 1,\n"
"    Flush = 4,\n"
"}\n"
"\n"
"#[repr(C)]\n"
"#[derive(AsBytes, Debug, Default)]\n"
"struct VirtioBlockRequest {\n"
"    request_type: RequestType,\n"
"    reserved: u32,\n"
"    sector: u64,\n"
"}\n"
"\n"
"fn main() {\n"
"    let request = VirtioBlockRequest {\n"
"        request_type: RequestType::Flush,\n"
"        sector: 42,\n"
"        ..Default::default()\n"
"    };\n"
"\n"
"    assert_eq!(\n"
"        request.as_bytes(),\n"
"        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:40
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:45
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:47
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:49
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr ""

#: src/bare-metal/useful-crates/zerocopy.md:50
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:1
msgid "`aarch64-paging`"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:3
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:6
msgid ""
"```rust,editable,compile_fail\n"
"use aarch64_paging::{\n"
"    idmap::IdMap,\n"
"    paging::{Attributes, MemoryRegion},\n"
"};\n"
"\n"
"const ASID: usize = 1;\n"
"const ROOT_LEVEL: usize = 1;\n"
"\n"
"// Create a new page table with identity mapping.\n"
"let mut idmap = IdMap::new(ASID, ROOT_LEVEL);\n"
"// Map a 2 MiB region of memory as read-only.\n"
"idmap.map_range(\n"
"    &MemoryRegion::new(0x80200000, 0x80400000),\n"
"    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,\n"
").unwrap();\n"
"// Set `TTBR0_EL1` to activate the page table.\n"
"idmap.activate();\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:28
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:30
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""

#: src/bare-metal/useful-crates/aarch64-paging.md:31
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:1
msgid "`buddy_system_allocator`"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:3
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use buddy_system_allocator::FrameAllocator;\n"
"use core::alloc::Layout;\n"
"\n"
"fn main() {\n"
"    let mut allocator = FrameAllocator::<32>::new();\n"
"    allocator.add_frame(0x200_0000, 0x400_0000);\n"
"\n"
"    let layout = Layout::from_size_align(0x100, 0x100).unwrap();\n"
"    let bar = allocator\n"
"        .alloc_aligned(layout)\n"
"        .expect(\"Failed to allocate 0x100 byte MMIO region\");\n"
"    println!(\"Allocated 0x100 byte MMIO region at {:#x}\", bar);\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:26
msgid "PCI BARs always have alignment equal to their size."
msgstr ""

#: src/bare-metal/useful-crates/buddy_system_allocator.md:27
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:1
msgid "`tinyvec`"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:3
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use tinyvec::{array_vec, ArrayVec};\n"
"\n"
"fn main() {\n"
"    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.push(7);\n"
"    println!(\"{numbers:?}\");\n"
"    numbers.remove(1);\n"
"    println!(\"{numbers:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:23
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr ""

#: src/bare-metal/useful-crates/tinyvec.md:24
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:1
#, fuzzy
msgid "`spin`"
msgstr "Â«ÏƒÏ„Î±Ï„Î¹ÎºÏŒÂ»."

#: src/bare-metal/useful-crates/spin.md:3
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:7
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:9
msgid ""
"```rust,editable,compile_fail\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static counter: SpinMutex<u32> = SpinMutex::new(0);\n"
"\n"
"fn main() {\n"
"    println!(\"count: {}\", counter.lock());\n"
"    *counter.lock() += 2;\n"
"    println!(\"count: {}\", counter.lock());\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/useful-crates/spin.md:23
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:24
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`;  and `Lazy` for lazy initialisation."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:26
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""

#: src/bare-metal/useful-crates/spin.md:28
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr ""

#: src/bare-metal/android.md:3
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""

#: src/bare-metal/android.md:7
msgid ""
"```soong\n"
"rust_ffi_static {\n"
"    name: \"libvmbase_example\",\n"
"    defaults: [\"vmbase_ffi_defaults\"],\n"
"    crate_name: \"vmbase_example\",\n"
"    srcs: [\"src/main.rs\"],\n"
"    rustlibs: [\n"
"        \"libvmbase\",\n"
"    ],\n"
"}\n"
"\n"
"cc_binary {\n"
"    name: \"vmbase_example\",\n"
"    defaults: [\"vmbase_elf_defaults\"],\n"
"    srcs: [\n"
"        \"idmap.S\",\n"
"    ],\n"
"    static_libs: [\n"
"        \"libvmbase_example\",\n"
"    ],\n"
"    linker_scripts: [\n"
"        \"image.ld\",\n"
"        \":vmbase_sections\",\n"
"    ],\n"
"}\n"
"\n"
"raw_binary {\n"
"    name: \"vmbase_example_bin\",\n"
"    stem: \"vmbase_example.bin\",\n"
"    src: \":vmbase_example\",\n"
"    enabled: false,\n"
"    target: {\n"
"        android_arm64: {\n"
"            enabled: true,\n"
"        },\n"
"    },\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:3
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""

#: src/bare-metal/android/vmbase.md:6
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"use vmbase::{main, println};\n"
"\n"
"main!(main);\n"
"\n"
"pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {\n"
"    println!(\"Hello world\");\n"
"}\n"
"```"
msgstr ""

#: src/bare-metal/android/vmbase.md:21
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr ""

#: src/bare-metal/android/vmbase.md:22
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""

#: src/exercises/bare-metal/afternoon.md:3
msgid "We will write a driver for the PL031 real-time clock device."
msgstr ""

#: src/exercises/bare-metal/rtc.md:1
#: src/exercises/bare-metal/solutions-afternoon.md:3
msgid "RTC driver"
msgstr ""

#: src/exercises/bare-metal/rtc.md:3
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""

#: src/exercises/bare-metal/rtc.md:6
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""

#: src/exercises/bare-metal/rtc.md:8
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""

#: src/exercises/bare-metal/rtc.md:10
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""

#: src/exercises/bare-metal/rtc.md:12
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr ""

#: src/exercises/bare-metal/rtc.md:13
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""

#: src/exercises/bare-metal/rtc.md:16
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""

#: src/exercises/bare-metal/rtc.md:23
msgid ""
"```rust,compile_fail\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"\n"
"    // TODO: Create instance of RTC driver and print current time.\n"
"\n"
"    // TODO: Wait for 3 seconds.\n"
"\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:75
msgid ""
"`src/exceptions.rs` (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:79
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use arm_gic::gicv3::GicV3;\n"
"use log::{error, info, trace};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_exception_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_exception_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_current(_elr: u64, _spsr: u64) {\n"
"    trace!(\"irq_current\");\n"
"    let intid = GicV3::get_and_acknowledge_interrupt().expect(\"No pending "
"interrupt\");\n"
"    info!(\"IRQ {intid:?}\");\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_current(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_current\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn sync_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"sync_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn irq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"irq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn fiq_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"fiq_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[no_mangle]\n"
"extern \"C\" fn serr_lower(_elr: u64, _spsr: u64) {\n"
"    error!(\"serr_lower\");\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:149
msgid "`src/logger.rs` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:153
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: main\n"
"use crate::pl011::Uart;\n"
"use core::fmt::Write;\n"
"use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};\n"
"use spin::mutex::SpinMutex;\n"
"\n"
"static LOGGER: Logger = Logger {\n"
"    uart: SpinMutex::new(None),\n"
"};\n"
"\n"
"struct Logger {\n"
"    uart: SpinMutex<Option<Uart>>,\n"
"}\n"
"\n"
"impl Log for Logger {\n"
"    fn enabled(&self, _metadata: &Metadata) -> bool {\n"
"        true\n"
"    }\n"
"\n"
"    fn log(&self, record: &Record) {\n"
"        writeln!(\n"
"            self.uart.lock().as_mut().unwrap(),\n"
"            \"[{}] {}\",\n"
"            record.level(),\n"
"            record.args()\n"
"        )\n"
"        .unwrap();\n"
"    }\n"
"\n"
"    fn flush(&self) {}\n"
"}\n"
"\n"
"/// Initialises UART logger.\n"
"pub fn init(uart: Uart, max_level: LevelFilter) -> Result<(), "
"SetLoggerError> {\n"
"    LOGGER.uart.lock().replace(uart);\n"
"\n"
"    log::set_logger(&LOGGER)?;\n"
"    log::set_max_level(max_level);\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:210
msgid "`src/pl011.rs` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:214
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#![allow(unused)]\n"
"\n"
"use core::fmt::{self, Write};\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"// ANCHOR: Flags\n"
"use bitflags::bitflags;\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART flag register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct Flags: u16 {\n"
"        /// Clear to send.\n"
"        const CTS = 1 << 0;\n"
"        /// Data set ready.\n"
"        const DSR = 1 << 1;\n"
"        /// Data carrier detect.\n"
"        const DCD = 1 << 2;\n"
"        /// UART busy transmitting data.\n"
"        const BUSY = 1 << 3;\n"
"        /// Receive FIFO is empty.\n"
"        const RXFE = 1 << 4;\n"
"        /// Transmit FIFO is full.\n"
"        const TXFF = 1 << 5;\n"
"        /// Receive FIFO is full.\n"
"        const RXFF = 1 << 6;\n"
"        /// Transmit FIFO is empty.\n"
"        const TXFE = 1 << 7;\n"
"        /// Ring indicator.\n"
"        const RI = 1 << 8;\n"
"    }\n"
"}\n"
"// ANCHOR_END: Flags\n"
"\n"
"bitflags! {\n"
"    /// Flags from the UART Receive Status Register / Error Clear Register.\n"
"    #[repr(transparent)]\n"
"    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"    struct ReceiveStatus: u16 {\n"
"        /// Framing error.\n"
"        const FE = 1 << 0;\n"
"        /// Parity error.\n"
"        const PE = 1 << 1;\n"
"        /// Break error.\n"
"        const BE = 1 << 2;\n"
"        /// Overrun error.\n"
"        const OE = 1 << 3;\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Registers\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    dr: u16,\n"
"    _reserved0: [u8; 2],\n"
"    rsr: ReceiveStatus,\n"
"    _reserved1: [u8; 19],\n"
"    fr: Flags,\n"
"    _reserved2: [u8; 6],\n"
"    ilpr: u8,\n"
"    _reserved3: [u8; 3],\n"
"    ibrd: u16,\n"
"    _reserved4: [u8; 2],\n"
"    fbrd: u8,\n"
"    _reserved5: [u8; 3],\n"
"    lcr_h: u8,\n"
"    _reserved6: [u8; 3],\n"
"    cr: u16,\n"
"    _reserved7: [u8; 3],\n"
"    ifls: u8,\n"
"    _reserved8: [u8; 3],\n"
"    imsc: u16,\n"
"    _reserved9: [u8; 2],\n"
"    ris: u16,\n"
"    _reserved10: [u8; 2],\n"
"    mis: u16,\n"
"    _reserved11: [u8; 2],\n"
"    icr: u16,\n"
"    _reserved12: [u8; 2],\n"
"    dmacr: u8,\n"
"    _reserved13: [u8; 3],\n"
"}\n"
"// ANCHOR_END: Registers\n"
"\n"
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
"#[derive(Debug)]\n"
"pub struct Uart {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Uart {\n"
"    /// Constructs a new instance of the UART driver for a PL011 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Writes a single byte to the UART.\n"
"    pub fn write_byte(&self, byte: u8) {\n"
"        // Wait until there is room in the TX buffer.\n"
"        while self.read_flag_register().contains(Flags::TXFF) {}\n"
"\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe {\n"
"            // Write to the TX buffer.\n"
"            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());\n"
"        }\n"
"\n"
"        // Wait until the UART is no longer busy.\n"
"        while self.read_flag_register().contains(Flags::BUSY) {}\n"
"    }\n"
"\n"
"    /// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"
"    pub fn read_byte(&self) -> Option<u8> {\n"
"        if self.read_flag_register().contains(Flags::RXFE) {\n"
"            None\n"
"        } else {\n"
"            let data = unsafe { addr_of!((*self.registers).dr)."
"read_volatile() };\n"
"            // TODO: Check for error conditions in bits 8-11.\n"
"            Some(data as u8)\n"
"        }\n"
"    }\n"
"\n"
"    fn read_flag_register(&self) -> Flags {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).fr).read_volatile() }\n"
"    }\n"
"}\n"
"// ANCHOR_END: Uart\n"
"\n"
"impl Write for Uart {\n"
"    fn write_str(&mut self, s: &str) -> fmt::Result {\n"
"        for c in s.as_bytes() {\n"
"            self.write_byte(*c);\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Uart {}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:389
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"[package]\n"
"name = \"rtc\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"arm-gic = \"0.1.0\"\n"
"bitflags = \"2.0.0\"\n"
"chrono = { version = \"0.4.24\", default-features = false }\n"
"log = \"0.4.17\"\n"
"smccc = \"0.1.1\"\n"
"spin = \"0.9.8\"\n"
"\n"
"[build-dependencies]\n"
"cc = \"1.0.73\"\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:410
msgid "`build.rs` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:414
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use cc::Build;\n"
"use std::env;\n"
"\n"
"fn main() {\n"
"    #[cfg(target_os = \"linux\")]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-linux-gnu\");\n"
"    #[cfg(not(target_os = \"linux\"))]\n"
"    env::set_var(\"CROSS_COMPILE\", \"aarch64-none-elf\");\n"
"\n"
"    Build::new()\n"
"        .file(\"entry.S\")\n"
"        .file(\"exceptions.S\")\n"
"        .file(\"idmap.S\")\n"
"        .compile(\"empty\")\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:446
msgid "`entry.S` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:450
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:595
msgid "`exceptions.S` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:599
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:780
msgid "`idmap.S` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:784
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:829
msgid "`image.ld` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:833
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:940
msgid "`Makefile` (you shouldn't need to change this):"
msgstr ""

#: src/exercises/bare-metal/rtc.md:944
msgid ""
"```makefile\n"
"# Copyright 2023 Google LLC\n"
"#\n"
"# Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"# you may not use this file except in compliance with the License.\n"
"# You may obtain a copy of the License at\n"
"#\n"
"#      http://www.apache.org/licenses/LICENSE-2.0\n"
"#\n"
"# Unless required by applicable law or agreed to in writing, software\n"
"# distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"# See the License for the specific language governing permissions and\n"
"# limitations under the License.\n"
"\n"
"UNAME := $(shell uname -s)\n"
"ifeq ($(UNAME),Linux)\n"
"\tTARGET = aarch64-linux-gnu\n"
"else\n"
"\tTARGET = aarch64-none-elf\n"
"endif\n"
"OBJCOPY = $(TARGET)-objcopy\n"
"\n"
".PHONY: build qemu_minimal qemu qemu_logger\n"
"\n"
"all: rtc.bin\n"
"\n"
"build:\n"
"\tcargo build\n"
"\n"
"rtc.bin: build\n"
"\t$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@\n"
"\n"
"qemu: rtc.bin\n"
"\tqemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio "
"-display none -kernel $< -s\n"
"\n"
"clean:\n"
"\tcargo clean\n"
"\trm -f *.bin\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:989
msgid ""
"```toml\n"
"[build]\n"
"target = \"aarch64-unknown-none\"\n"
"rustflags = [\"-C\", \"link-arg=-Timage.ld\"]\n"
"```"
msgstr ""

#: src/exercises/bare-metal/rtc.md:995
msgid "Run the code in QEMU with `make qemu`."
msgstr ""

#: src/concurrency.md:1
#, fuzzy
msgid "Welcome to Concurrency in Rust"
msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Comprehensive Rust ğŸ¦€"

#: src/concurrency.md:3
#, fuzzy
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr ""
"Î¤Î¿ Rust Î­Ï‡ÎµÎ¹ Ï€Î»Î®ÏÎ· Ï…Ï€Î¿ÏƒÏ„Î®ÏÎ¹Î¾Î· Î³Î¹Î± Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î· Ï‡ÏÎ®ÏƒÎ· Î½Î·Î¼Î¬Ï„Ï‰Î½ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ¿Ï "
"ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ Î¼Îµ mutexes ÎºÎ±Î¹ ÎºÎ±Î½Î±Î»Î¹ÏÎ½."

#: src/concurrency.md:6
#, fuzzy
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Î¤Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± Ï„ÏÏ€Î¿Ï… Rust Ï€Î±Î¯Î¶ÎµÎ¹ ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ ÏÏŒÎ»Î¿ ÏƒÏ„Î· Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Ï€Î¿Î»Î»ÏÎ½ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½ "
"ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼Î¿Ï Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ· Ï‡ÏÎ¿Î½Î¹ÎºÏÎ½ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½. Î‘Ï…Ï„ÏŒ Î±Î½Î±Ï†Î­ÏÎµÏ„Î±Î¹ ÏƒÏ…Ï‡Î½Î¬ Ï‰Ï‚ "
"_Î±Ï„ÏÏŒÎ¼Î·Ï„Î¿Ï‚ ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚_ Î±Ï†Î¿Ï ÎµÏƒÎµÎ¯Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î²Î±ÏƒÎ¹ÏƒÏ„ÎµÎ¯ ÏƒÏ„Î¿Î½ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® "
"Î³Î¹Î± Î½Î± Î´Î¹Î±ÏƒÏ†Î±Î»Î¯ÏƒÎµÎ¹ Ï„Î·Î½ Î¿ÏÎ¸ÏŒÏ„Î·Ï„Î± ÎºÎ±Ï„Î¬ Ï„Î¿ Ï‡ÏÏŒÎ½Î¿ ÎµÎºÏ„Î­Î»ÎµÏƒÎ·Ï‚."

#: src/concurrency/threads.md:3
#, fuzzy
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Î¤Î± Î½Î®Î¼Î±Ï„Î± ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÎ½ Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Ï„Î± Î½Î®Î¼Î±Ï„Î± ÏƒÎµ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚:"

#: src/concurrency/threads.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    thread::spawn(|| {\n"
"        for i in 1..10 {\n"
"            println!(\"Count in thread: {i}!\");\n"
"            thread::sleep(Duration::from_millis(5));\n"
"        }\n"
"    });\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main thread: {i}\");\n"
"        thread::sleep(Duration::from_millis(5));\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/threads.md:24
#, fuzzy
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr "Î¤Î± Î½Î®Î¼Î±Ï„Î± ÎµÎ¯Î½Î±Î¹ ÏŒÎ»Î± Î½Î®Î¼Î±Ï„Î± Î´Î±Î¯Î¼Î¿Î½Î±, Ï„Î¿ ÎºÏÏÎ¹Î¿ Î½Î®Î¼Î± Î´ÎµÎ½ Ï„Î± Ï€ÎµÏÎ¹Î¼Î­Î½ÎµÎ¹."

#: src/concurrency/threads.md:25
#, fuzzy
msgid "Thread panics are independent of each other."
msgstr "ÎŸÎ¹ Ï€Î±Î½Î¹ÎºÎ¿Î¯ Ï„Ï‰Î½ Î½Î·Î¼Î¬Ï„Ï‰Î½ ÎµÎ¯Î½Î±Î¹ Î±Î½ÎµÎ¾Î¬ÏÏ„Î·Ï„Î¿Î¹ Î¿ Î­Î½Î±Ï‚ Î±Ï€ÏŒ Ï„Î¿Î½ Î¬Î»Î»Î¿."

#: src/concurrency/threads.md:26
#, fuzzy
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr ""
"ÎŸÎ¹ Ï€Î±Î½Î¹ÎºÎ¿Î¯ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î¼ÎµÏ„Î±Ï†Î­ÏÎ¿Ï…Î½ Î­Î½Î± Ï‰Ï†Î­Î»Î¹Î¼Î¿ Ï†Î¿ÏÏ„Î¯Î¿, Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"Î±Ï€Î¿ÏƒÏ…Î¼Ï€Î¹ÎµÏƒÏ„ÎµÎ¯ Î¼Îµ Ï„Î¿ Â«downcast_refÂ»."

#: src/concurrency/threads.md:32
msgid ""
"Notice that the thread is stopped before it reaches 10 â€” the main thread is "
"not waiting."
msgstr ""

#: src/concurrency/threads.md:35
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""

#: src/concurrency/threads.md:38
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr ""

#: src/concurrency/threads.md:40
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""

#: src/concurrency/scoped-threads.md:3
#, fuzzy
msgid "Normal threads cannot borrow from their environment:"
msgstr "Î¤Î± ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬ Î½Î®Î¼Î±Ï„Î± Î´ÎµÎ½ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î´Î±Î½ÎµÎ¹ÏƒÏ„Î¿ÏÎ½ Î±Ï€ÏŒ Ï„Î¿ Ï€ÎµÏÎ¹Î²Î¬Î»Î»Î¿Î½ Ï„Î¿Ï…Ï‚:"

#: src/concurrency/scoped-threads.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"\n"
"fn foo() {\n"
"    let s = String::from(\"Hello\");\n"
"    thread::spawn(|| {\n"
"        println!(\"Length: {}\", s.len());\n"
"    });\n"
"}\n"
"\n"
"fn main() {\n"
"    foo();\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:20
#, fuzzy
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"Î©ÏƒÏ„ÏŒÏƒÎ¿, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î­Î½Î± [Î½Î®Î¼Î± ÎµÎ¼Î²Î­Î»ÎµÎ¹Î±Ï‚](https://doc.rust-"
"lang.org/std/thread/fn.scope.html) Î³Î¹Î± Î±Ï…Ï„ÏŒ:"

#: src/concurrency/scoped-threads.md:22
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let s = String::from(\"Hello\");\n"
"\n"
"    thread::scope(|scope| {\n"
"        scope.spawn(|| {\n"
"            println!(\"Length: {}\", s.len());\n"
"        });\n"
"    });\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/scoped-threads.md:40
#, fuzzy
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/concurrency/scoped-threads.md:41
#, fuzzy
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"ÎŸ Î»ÏŒÎ³Î¿Ï‚ Î³Î¹Î± Î±Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ ÏŒÏ„Î¹ ÏŒÏ„Î±Î½ Î¿Î»Î¿ÎºÎ»Î·ÏÏ‰Î¸ÎµÎ¯ Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· `thread::scope`, ÏŒÎ»Î± "
"Ï„Î± Î½Î®Î¼Î±Ï„Î± ÎµÎ¯Î½Î±Î¹ ÎµÎ³Î³Ï…Î·Î¼Î­Î½Î± ÏŒÏ„Î¹ Î¸Î± ÎµÎ½Ï‰Î¸Î¿ÏÎ½, ÏÏƒÏ„Îµ Î½Î± Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎ¿Ï…Î½ Ï„Î± "
"Î´ÎµÎ´Î¿Î¼Î­Î½Î± Ï€Î¿Ï… Î­Ï‡Î¿Ï…Î½ Î´Î±Î½ÎµÎ¹ÏƒÏ„ÎµÎ¯.\n"
"\n"
"Î™ÏƒÏ‡ÏÎ¿Ï…Î½ Î¿Î¹ ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¿Î¯ ÎºÎ±Î½ÏŒÎ½ÎµÏ‚ Î´Î±Î½ÎµÎ¹ÏƒÎ¼Î¿Ï Rust: Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ ÎµÎ¯Ï„Îµ Î½Î± Î´Î±Î½ÎµÎ¹ÏƒÏ„ÎµÎ¯Ï„Îµ "
"Î¼ÎµÏ„Î±Î»Î»Î¬Î¾Î¹Î¼Î± Î¼Îµ Î­Î½Î± Î½Î®Î¼Î± Î® Î±Î¼ÎµÏ„Î¬Î²Î»Î·Ï„Î± Î¼Îµ Î¿Ï€Î¿Î¹Î¿Î½Î´Î®Ï€Î¿Ï„Îµ Î±ÏÎ¹Î¸Î¼ÏŒ Î½Î·Î¼Î¬Ï„Ï‰Î½."

#: src/concurrency/channels.md:3
#, fuzzy
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Î¤Î± ÎºÎ±Î½Î¬Î»Î¹Î± Rust Î­Ï‡Î¿Ï…Î½ Î´ÏÎ¿ Î¼Î­ÏÎ·: Î­Î½Î± \"Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î­Î±Ï‚\n"
"\n"
"\" ÎºÎ±Î¹ Î­Î½Î± \"Î”Î­ÎºÏ„Î·Ï‚\n"
"\n"
"\". Î¤Î± Î´ÏÎ¿ Î¼Î­ÏÎ· ÏƒÏ…Î½Î´Î­Î¿Î½Ï„Î±Î¹ Î¼Î­ÏƒÏ‰ Ï„Î¿Ï… ÎºÎ±Î½Î±Î»Î¹Î¿Ï, Î±Î»Î»Î¬ Î²Î»Î­Ï€ÎµÏ„Îµ Î¼ÏŒÎ½Î¿ Ï„Î± Ï„ÎµÎ»Î¹ÎºÎ¬ "
"ÏƒÎ·Î¼ÎµÎ¯Î±."

#: src/concurrency/channels.md:6
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    tx.send(10).unwrap();\n"
"    tx.send(20).unwrap();\n"
"\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"\n"
"    let tx2 = tx.clone();\n"
"    tx2.send(30).unwrap();\n"
"    println!(\"Received: {:?}\", rx.recv());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels.md:27
#, fuzzy
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"Î¤Î¿ Â«mpscÂ» ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ Multi-Producer, Single-Consumer. Î¤Î¿ \"Sender\" ÎºÎ±Î¹ Ï„Î¿ "
"\"SyncSender\" Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î¿ \"Clone\" (Î­Ï„ÏƒÎ¹ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÏ„Îµ "
"Ï€Î¿Î»Î»Î¿ÏÏ‚ Ï€Î±ÏÎ±Î³Ï‰Î³Î¿ÏÏ‚) Î±Î»Î»Î¬ Î¿ Â«Î”Î­ÎºÏ„Î·Ï‚Â» ÏŒÏ‡Î¹."

#: src/concurrency/channels.md:29
#, fuzzy
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"Î¤Î¿ \"send()\" ÎºÎ±Î¹ Ï„Î¿ \"recv()\" ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†Î¿Ï…Î½ \"Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±\". Î•Î¬Î½ ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎ¿Ï…Î½ "
"\"Err\", ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ Ï„Î¿ Î±Î½Ï„Î¯ÏƒÏ„Î¿Î¹Ï‡Î¿ \"Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î­Î±Ï‚\" Î® ÎŸ \"Î´Î­ÎºÏ„Î·Ï‚\" Ï€Î­Ï†Ï„ÎµÎ¹ ÎºÎ±Î¹ Ï„Î¿ "
"ÎºÎ±Î½Î¬Î»Î¹ ÎµÎ¯Î½Î±Î¹ ÎºÎ»ÎµÎ¹ÏƒÏ„ÏŒ."

#: src/concurrency/channels/unbounded.md:3
#, fuzzy
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "Î›Î±Î¼Î²Î¬Î½ÎµÏ„Îµ Î­Î½Î± Î±Ï€ÎµÏÎ¹ÏŒÏÎ¹ÏƒÏ„Î¿ ÎºÎ±Î¹ Î±ÏƒÏÎ³Ï‡ÏÎ¿Î½Î¿ ÎºÎ±Î½Î¬Î»Î¹ Î¼Îµ `mpsc::channel()`:"

#: src/concurrency/channels/unbounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::channel();\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:3
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr ""
"Î¤Î± Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î± ÎºÎ±Î¹ Ï„Î± ÏƒÏÎ³Ï‡ÏÎ¿Î½Î± ÎºÎ±Î½Î¬Î»Î¹Î± ÎºÎ¬Î½Î¿Ï…Î½ Ï„Î¿ \"send\" Î½Î± Î¼Ï€Î»Î¿ÎºÎ¬ÏÎµÎ¹ Ï„Î¿ "
"Ï„ÏÎ­Ï‡Î¿Î½ Î½Î®Î¼Î±:"

#: src/concurrency/channels/bounded.md:5
msgid ""
"```rust,editable\n"
"use std::sync::mpsc;\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"fn main() {\n"
"    let (tx, rx) = mpsc::sync_channel(3);\n"
"\n"
"    thread::spawn(move || {\n"
"        let thread_id = thread::current().id();\n"
"        for i in 1..10 {\n"
"            tx.send(format!(\"Message {i}\")).unwrap();\n"
"            println!(\"{thread_id:?}: sent Message {i}\");\n"
"        }\n"
"        println!(\"{thread_id:?}: done\");\n"
"    });\n"
"    thread::sleep(Duration::from_millis(100));\n"
"\n"
"    for msg in rx.iter() {\n"
"        println!(\"Main: got {msg}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/channels/bounded.md:31
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""

#: src/concurrency/channels/bounded.md:32
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""

#: src/concurrency/channels/bounded.md:33
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""

#: src/concurrency/send-sync.md:1
#, fuzzy
msgid "`Send` and `Sync`"
msgstr "Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®Â» ÎºÎ±Î¹ Â«Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â»."

#: src/concurrency/send-sync.md:3
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across thread? The answer is in "
"two traits:"
msgstr ""
"Î ÏÏ‚ Î³Î½Ï‰ÏÎ¯Î¶ÎµÎ¹ Î· Rust ÏŒÏ„Î¹ Î±Ï€Î±Î³Î¿ÏÎµÏÎµÎ¹ Ï„Î·Î½ ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î· Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÎµ ÏŒÎ»Î± Ï„Î± "
"Î½Î®Î¼Î±Ï„Î±; Î— Î±Ï€Î¬Î½Ï„Î·ÏƒÎ· ÎµÎ¯Î½Î±Î¹ ÏƒÎµ Î´ÏÎ¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬:"

#: src/concurrency/send-sync.md:5
#, fuzzy
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[\"Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®\"](https://doc.rust-lang.org/std/marker/trait.Send.html): Î­Î½Î±Ï‚ "
"Ï„ÏÏ€Î¿Ï‚ \"T\" ÎµÎ¯Î½Î±Î¹ \"Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®\" ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î­Ï‚ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ Î­Î½Î± \"T\" "
"ÏƒÎµ Î­Î½Î± Î½Î®Î¼Î± ÎŒÏÎ¹Î¿."

#: src/concurrency/send-sync.md:7
#, fuzzy
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[\"Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚\"](https://doc.rust-lang.org/std/marker/trait.Sync.html): "
"Î­Î½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ \"T\" ÎµÎ¯Î½Î±Î¹ \"Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚\" ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î­Ï‚ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ "
"Î­Î½Î± \"&T\" ÏƒÎµ Î­Î½Î± Î½Î®Î¼Î± ÎŒÏÎ¹Î¿."

#: src/concurrency/send-sync.md:10
#, fuzzy
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"Î— \"Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®\" ÎºÎ±Î¹ Î· \"Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚\" ÎµÎ¯Î½Î±Î¹ [Î¼Î· Î±ÏƒÏ†Î±Î»Î® Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬](../"
"unsafe/unsafe-traits.md). ÎŸ Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î®Ï‚ Î¸Î± Ï„Î± Ï€Î±ÏÎ¬Î³ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Î³Î¹Î± Ï„Î¿Ï…Ï‚ "
"Ï„ÏÏ€Î¿Ï…Ï‚ ÏƒÎ±Ï‚ ÎµÏ†ÏŒÏƒÎ¿Î½ Ï€ÎµÏÎ¹Î­Ï‡Î¿Ï…Î½ Î¼ÏŒÎ½Î¿ Ï„ÏÏ€Î¿Ï…Ï‚ Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®Â» ÎºÎ±Î¹ Â«Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â». "
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï„Î± ÎµÏ†Î±ÏÎ¼ÏŒÏƒÎµÏ„Îµ Ï‡ÎµÎ¹ÏÎ¿ÎºÎ¯Î½Î·Ï„Î± ÏŒÏ„Î±Î½ Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î½Î± Î¾Î­ÏÎµÎ¹Ï‚ ÏŒÏ„Î¹ "
"Î¹ÏƒÏ‡ÏÎµÎ¹."

#: src/concurrency/send-sync.md:20
#, fuzzy
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr ""
"ÎšÎ¬Ï€Î¿Î¹Î¿Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÏƒÎºÎµÏ†Ï„ÎµÎ¯ Î±Ï…Ï„Î¬ Ï„Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬ Ï‰Ï‚ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ ÏŒÏ„Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ Î­Ï‡ÎµÎ¹ "
"Î¿ÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î¹Î´Î¹ÏŒÏ„Î·Ï„ÎµÏ‚ Î±ÏƒÏ†Î±Î»ÎµÎ¯Î±Ï‚ Î½Î®Î¼Î±Ï„Î¿Ï‚."

#: src/concurrency/send-sync.md:21
#, fuzzy
msgid "They can be used in the generic constraints as normal traits."
msgstr ""
"ÎœÏ€Î¿ÏÎ¿ÏÎ½ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸Î¿ÏÎ½ ÏƒÏ„Î¿Ï…Ï‚ Î³ÎµÎ½Î¹ÎºÎ¿ÏÏ‚ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î¿ÏÏ‚ Ï‰Ï‚ Ï†Ï…ÏƒÎ¹Î¿Î»Î¿Î³Î¹ÎºÎ¬ "
"Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬."

#: src/concurrency/send-sync/send.md:1
#, fuzzy
msgid "`Send`"
msgstr "Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®Â»."

#: src/concurrency/send-sync/send.md:3
#, fuzzy
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"ÎˆÎ½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ `T` ÎµÎ¯Î½Î±Î¹ [`Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®`](https://doc.rust-lang.org/std/marker/trait."
"Send.html) ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î­Ï‚ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ Î¼Î¹Î± Ï„Î¹Î¼Î® `T` ÏƒÎµ Î¬Î»Î»Î¿ Î½Î®Î¼Î±."

#: src/concurrency/send-sync/send.md:5
#, fuzzy
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"Î¤Î¿ Î±Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î± Ï„Î·Ï‚ Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î±Ï‚ ÏƒÎµ Î¬Î»Î»Î¿ Î½Î®Î¼Î± ÎµÎ¯Î½Î±Î¹ ÏŒÏ„Î¹ Î¿Î¹ "
"_destructors_ Î¸Î± ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„Î¿ÏÎ½ ÏƒÎµ Î±Ï…Ï„ÏŒ Ï„Î¿ Î½Î®Î¼Î±. Î¤Î¿ ÎµÏÏÏ„Î·Î¼Î± Î»Î¿Î¹Ï€ÏŒÎ½ ÎµÎ¯Î½Î±Î¹ Ï€ÏŒÏ„Îµ "
"Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÎºÏ‡Ï‰ÏÎ®ÏƒÎµÏ„Îµ Î¼Î¹Î± Ï„Î¹Î¼Î® ÏƒÎµ Î­Î½Î± Î½Î®Î¼Î± ÎºÎ±Î¹ Î½Î± Ï„Î¿ Î´Î¹Î±Î¸Î­ÏƒÎµÎ¹ ÏƒÎµ Î¬Î»Î»Î¿."

#: src/concurrency/send-sync/send.md:13
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr ""

#: src/concurrency/send-sync/sync.md:1
#, fuzzy
msgid "`Sync`"
msgstr "`Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚`"

#: src/concurrency/send-sync/sync.md:3
#, fuzzy
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"ÎˆÎ½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ `T` ÎµÎ¯Î½Î±Î¹ [`Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚`](https://doc.rust-lang.org/std/marker/"
"trait.Sync.html) ÎµÎ¬Î½ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î®Ï‚ Î· Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÎµ Î¼Î¹Î± Ï„Î¹Î¼Î® `T` Î±Ï€ÏŒ Ï€Î¿Î»Î»Î±Ï€Î»Î­Ï‚ "
"Î½Î®Î¼Î±Ï„Î± Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î±."

#: src/concurrency/send-sync/sync.md:6
#, fuzzy
msgid "More precisely, the definition is:"
msgstr "Î Î¹Î¿ ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î±, Î¿ Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÎµÎ¯Î½Î±Î¹:"

#: src/concurrency/send-sync/sync.md:8
#, fuzzy
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr ""
"Î¤Î¿ \"T\" ÎµÎ¯Î½Î±Î¹ \"Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚\" ÎµÎ¬Î½ ÎºÎ±Î¹ Î¼ÏŒÎ½Î¿ ÎµÎ¬Î½ Ï„Î¿ \"&T\" ÎµÎ¯Î½Î±Î¹ "
"\"Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®\"."

#: src/concurrency/send-sync/sync.md:14
#, fuzzy
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"Î‘Ï…Ï„Î® Î· Î´Î®Î»Ï‰ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Î¿Ï…ÏƒÎ¹Î±ÏƒÏ„Î¹ÎºÎ¬ Î­Î½Î±Ï‚ ÏƒÏ…Î½Î¿Ï€Ï„Î¹ÎºÏŒÏ‚ Ï„ÏÏŒÏ€Î¿Ï‚ Î³Î¹Î± Î½Î± Ï€Î¿ÏÎ¼Îµ ÏŒÏ„Î¹ ÎµÎ¬Î½ "
"Î­Î½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î®Ï‚ Ï‰Ï‚ Ï€ÏÎ¿Ï‚ Ï„Î¿ Î½Î®Î¼Î± Î³Î¹Î± ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î· Ï‡ÏÎ®ÏƒÎ·, ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ "
"Î±ÏƒÏ†Î±Î»Î­Ï‚ Î³Î¹Î± Ï„Î¿ Î½Î®Î¼Î± Î½Î± Î¼ÎµÏ„Î±Î²Î¹Î²Î¬Î¶Î¿Î½Ï„Î±Î¹ Î¿Î¹ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚ Ï„Î¿Ï… ÏƒÏ„Î± Î½Î®Î¼Î±Ï„Î±."

#: src/concurrency/send-sync/sync.md:16
#, fuzzy
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"Î‘Ï…Ï„ÏŒ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹ ÎµÏ€ÎµÎ¹Î´Î® ÎµÎ¬Î½ Î­Î½Î±Ï‚ Ï„ÏÏ€Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Sync ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"ÎºÎ¿Î¹Î½Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ ÏƒÎµ Ï€Î¿Î»Î»Î¬ Î½Î®Î¼Î±Ï„Î± Ï‡Ï‰ÏÎ¯Ï‚ Ï„Î¿Î½ ÎºÎ¯Î½Î´Ï…Î½Î¿ Ï†Ï…Î»ÏÎ½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Î® Î¬Î»Î»Ï‰Î½ "
"Ï€ÏÎ¿Î²Î»Î·Î¼Î¬Ï„Ï‰Î½ ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼Î¿Ï, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»Î­Ï‚ Î½Î± Ï„Î¿Î½ Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ ÏƒÎµ Î¬Î»Î»Î¿ "
"Î½Î®Î¼Î±. ÎœÎ¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÏ„Î¿Î½ Ï„ÏÏ€Î¿ ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î±ÏƒÏ†Î±Î»Î®Ï‚ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î·Î¸ÎµÎ¯ ÏƒÎµ Î¬Î»Î»Î¿ "
"Î½Î®Î¼Î±, ÎµÏ€ÎµÎ¹Î´Î® Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Ï€Î¿Ï… Ï€Î±ÏÎ±Ï€Î­Î¼Ï€ÎµÎ¹ ÎµÎ¯Î½Î±Î¹ Ï€ÏÎ¿ÏƒÎ²Î¬ÏƒÎ¹Î¼Î± Î±Ï€ÏŒ Î¿Ï€Î¿Î¹Î¿Î´Î®Ï€Î¿Ï„Îµ "
"Î½Î®Î¼Î± Î¼Îµ Î±ÏƒÏ†Î¬Î»ÎµÎ¹Î±."

#: src/concurrency/send-sync/examples.md:3
#, fuzzy
msgid "`Send + Sync`"
msgstr "Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â»."

#: src/concurrency/send-sync/examples.md:5
#, fuzzy
msgid "Most types you come across are `Send + Sync`:"
msgstr "ÎŸÎ¹ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿Î¹ Ï„ÏÏ€Î¿Î¹ Ï€Î¿Ï… ÏƒÏ…Î½Î±Î½Ï„Î¬Ï„Îµ ÎµÎ¯Î½Î±Î¹ Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â»:"

#: src/concurrency/send-sync/examples.md:7
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr ""

#: src/concurrency/send-sync/examples.md:8
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr ""

#: src/concurrency/send-sync/examples.md:9
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr ""

#: src/concurrency/send-sync/examples.md:10
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr ""

#: src/concurrency/send-sync/examples.md:11
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr ""

#: src/concurrency/send-sync/examples.md:12
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr ""

#: src/concurrency/send-sync/examples.md:14
#, fuzzy
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr ""
"ÎŸÎ¹ Î³ÎµÎ½Î¹ÎºÎ¿Î¯ Ï„ÏÏ€Î¿Î¹ ÎµÎ¯Î½Î±Î¹ ÏƒÏ…Î½Î®Î¸Ï‰Ï‚ Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â» ÏŒÏ„Î±Î½ Î¿Î¹ Ï€Î±ÏÎ¬Î¼ÎµÏ„ÏÎ¿Î¹ "
"Ï„ÏÏ€Î¿Ï… ÎµÎ¯Î½Î±Î¹ Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â»."

#: src/concurrency/send-sync/examples.md:17
#, fuzzy
msgid "`Send + !Sync`"
msgstr "`Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + !Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚`"

#: src/concurrency/send-sync/examples.md:19
#, fuzzy
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"Î‘Ï…Ï„Î¿Î¯ Î¿Î¹ Ï„ÏÏ€Î¿Î¹ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î·Î¸Î¿ÏÎ½ ÏƒÎµ Î¬Î»Î»Î± Î½Î®Î¼Î±Ï„Î±, Î±Î»Î»Î¬ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ "
"Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚ Î³Î¹Î± Î½Î®Î¼Î±Ï„Î±. Î¤Ï…Ï€Î¹ÎºÎ¬ Î»ÏŒÎ³Ï‰ Ï„Î·Ï‚ ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÎ®Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏŒÏ„Î·Ï„Î±Ï‚:"

#: src/concurrency/send-sync/examples.md:22
#, fuzzy
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î­Î±Ï‚<T>`"

#: src/concurrency/send-sync/examples.md:23
#, fuzzy
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Î”Î­ÎºÏ„Î·Ï‚<T>`"

#: src/concurrency/send-sync/examples.md:24
#, fuzzy
msgid "`Cell<T>`"
msgstr "`ÎšÎµÎ»Î»Î¯<T>`"

#: src/concurrency/send-sync/examples.md:25
#, fuzzy
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md:27
#, fuzzy
msgid "`!Send + Sync`"
msgstr "`!Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚`"

#: src/concurrency/send-sync/examples.md:29
#, fuzzy
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr ""
"Î‘Ï…Ï„Î¿Î¯ Î¿Î¹ Ï„ÏÏ€Î¿Î¹ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚ Î³Î¹Î± Î½Î®Î¼Î±, Î±Î»Î»Î¬ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î·Î¸Î¿ÏÎ½ ÏƒÎµ "
"Î¬Î»Î»Î¿ Î½Î®Î¼Î±:"

#: src/concurrency/send-sync/examples.md:31
#, fuzzy
msgid ""
"`MutexGuard<T>`: Uses OS level primitives which must be deallocated on the "
"thread which created them."
msgstr ""
"`MutexGuard<T>`: Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï€ÏÏ‰Ï„ÏŒÎ³Î¿Î½Î± ÎµÏ€Î¹Ï€Î­Î´Î¿Ï… Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ¿Ï ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ Ï€Î¿Ï… "
"Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ±Ï„Î±Î½ÎµÎ¼Î·Î¸Î¿ÏÎ½ ÏƒÏ„Î¿ Î½Î®Î¼Î± Ï€Î¿Ï… Ï„Î± Î´Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏƒÎµ."

#: src/concurrency/send-sync/examples.md:34
#, fuzzy
msgid "`!Send + !Sync`"
msgstr "`!Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î® + !Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚`"

#: src/concurrency/send-sync/examples.md:36
#, fuzzy
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr ""
"Î‘Ï…Ï„Î¿Î¯ Î¿Î¹ Ï„ÏÏ€Î¿Î¹ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î±ÏƒÏ†Î±Î»ÎµÎ¯Ï‚ Î³Î¹Î± Î½Î®Î¼Î± ÎºÎ±Î¹ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Î¼ÎµÏ„Î±ÎºÎ¹Î½Î·Î¸Î¿ÏÎ½ "
"ÏƒÎµ Î¬Î»Î»Î± Î½Î®Î¼Î±Ï„Î±:"

#: src/concurrency/send-sync/examples.md:38
#, fuzzy
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr "`Rc<T>`: ÎºÎ¬Î¸Îµ Â«Rc"

#: src/concurrency/send-sync/examples.md:40
#, fuzzy
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"Â» Î­Ï‡ÎµÎ¹ Î¼Î¹Î± Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎµ Î­Î½Î± Â«RcBox\n"
"\n"
"Â», Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î­Î½Î± Î¼Î· Î±Ï„Î¿Î¼Î¹ÎºÎ® Î¼Î­Ï„ÏÎ·ÏƒÎ· Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚.\n"
"\n"
"`*const T`, `*mut T`: Î¤Î¿ Rust Ï…Ï€Î¿Î¸Î­Ï„ÎµÎ¹ ÏŒÏ„Î¹ Î¿Î¹ Î±ÎºÎ±Ï„Î­ÏÎ³Î±ÏƒÏ„Î¿Î¹ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
"Î­Ï‡Î¿Ï…Î½ ÎµÎ¹Î´Î¹ÎºÎ¿ÏÏ‚ Î¶Î·Ï„Î®Î¼Î±Ï„Î± Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î·Ï‚ ÏÏ€Î±ÏÎ¾Î·Ï‚."

#: src/concurrency/shared_state.md:3
#, fuzzy
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr ""
"Î¤Î¿ Rust Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± Ï„ÏÏ€Ï‰Î½ Î³Î¹Î± Î½Î± ÎµÏ€Î¹Î²Î¬Î»ÎµÎ¹ Ï„Î¿ ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒ Ï„Ï‰Î½ "
"ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Ï‰Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½. Î‘Ï…Ï„ÏŒ ÎµÎ¯Î½Î±Î¹ Î³Î¯Î½ÎµÏ„Î±Î¹ ÎºÏ…ÏÎ¯Ï‰Ï‚ Î¼Î­ÏƒÏ‰ Î´ÏÎ¿ Ï„ÏÏ€Ï‰Î½:"

#: src/concurrency/shared_state.md:6
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), Î· Î±Ï„Î¿Î¼Î¹ÎºÎ® "
"Î±Î½Î±Ï†Î¿ÏÎ¬ Î¼ÎµÏ„ÏÎ¬Ï„Î±Î¹ Ï‰Ï‚ \"T\": Ï‡ÎµÎ¹ÏÎ¯Î¶ÎµÏ„Î±Î¹ Ï„Î·Î½ ÎºÎ¿Î¹Î½Î® Ï‡ÏÎ®ÏƒÎ· Î¼ÎµÏ„Î±Î¾Ï Î½Î·Î¼Î¬Ï„Ï‰Î½ ÎºÎ±Î¹ "
"Ï†ÏÎ¿Î½Ï„Î¯Î¶ÎµÎ¹ Î½Î± ÎºÎ±Ï„Î±Î½ÎµÎ¯Î¼ÎµÎ¹ Ï„Î¿ \"T\" ÏŒÏ„Î±Î½ Î±Ï€Î¿ÏÏÎ¹Ï†Î¸ÎµÎ¯ Î· Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± Î±Î½Î±Ï†Î¿ÏÎ¬,"

#: src/concurrency/shared_state.md:8
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): "
"ÎµÎ¾Î±ÏƒÏ†Î±Î»Î¯Î¶ÎµÎ¹ Î±Î¼Î¿Î¹Î²Î±Î¯Î± Î±Ï€Î¿ÎºÎ»ÎµÎ¹ÏƒÏ„Î¹ÎºÎ® Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î·Î½ Ï„Î¹Î¼Î® \"T\"."

#: src/concurrency/shared_state/arc.md:1
#, fuzzy
msgid "`Arc`"
msgstr "Â«Î¤ÏŒÎ¾Î¿Â»."

#: src/concurrency/shared_state/arc.md:3
#, fuzzy
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"Î¤Î¿ [`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ "
"Ï„Î·Î½ ÎºÎ¿Î¹Î½ÏŒÏ‡ÏÎ·ÏƒÏ„Î· Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· Î¼ÏŒÎ½Î¿ Î³Î¹Î± Î±Î½Î¬Î³Î½Ï‰ÏƒÎ· Î¼Î­ÏƒÏ‰ Ï„Î·Ï‚ Î¼ÎµÎ¸ÏŒÎ´Î¿Ï… \"clone\" Ï„Î¿Ï…:"

#: src/concurrency/shared_state/arc.md:5
msgid ""
"```rust,editable\n"
"use std::thread;\n"
"use std::sync::Arc;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(vec![10, 20, 30]);\n"
"    let mut handles = Vec::new();\n"
"    for _ in 1..5 {\n"
"        let v = Arc::clone(&v);\n"
"        handles.push(thread::spawn(move || {\n"
"            let thread_id = thread::current().id();\n"
"            println!(\"{thread_id:?}: {v:?}\");\n"
"        }));\n"
"    }\n"
"\n"
"    handles.into_iter().for_each(|h| h.join().unwrap());\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/arc.md:29
#, fuzzy
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr ""
"Î¤Î¿ \"Arc\" ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ \"Atomic Reference Counted\", Î¼Î¹Î± Î±ÏƒÏ†Î±Î»Î®Ï‚ Î­ÎºÎ´Î¿ÏƒÎ· Î½Î·Î¼Î¬Ï„Ï‰Î½ "
"Ï„Î¿Ï… \"Rc\" Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Î±Ï„Î¿Î¼Î¹ÎºÎ® ÎµÏ€Î¹Ï‡ÎµÎ¹ÏÎ®ÏƒÎµÎ¹Ï‚."

#: src/concurrency/shared_state/arc.md:31
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr "Î¤Î¿ \"Arc"

#: src/concurrency/shared_state/arc.md:33
#, fuzzy
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"\" Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ \"Clone\" ÎµÎ¯Ï„Îµ Ï„Î¿ ÎºÎ¬Î½ÎµÎ¹ Ï„Î¿ \"T\" ÎµÎ¯Ï„Îµ ÏŒÏ‡Î¹. Î•Ï†Î±ÏÎ¼ÏŒÎ¶ÎµÎ¹ "
"Â«Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®Â» ÎºÎ±Î¹ Â«Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚Â» Î±Î½ Â«TÂ». Ï„Î± ÎµÏ†Î±ÏÎ¼ÏŒÎ¶ÎµÎ¹ ÎºÎ±Î¹ Ï„Î± Î´ÏÎ¿."

#: src/concurrency/shared_state/arc.md:35
#, fuzzy
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr ""
"Î¤Î¿ \"Arc::clone()\" Î­Ï‡ÎµÎ¹ Ï„Î¿ ÎºÏŒÏƒÏ„Î¿Ï‚ Ï„Ï‰Î½ Î±Ï„Î¿Î¼Î¹ÎºÏÎ½ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÏÎ½ Ï€Î¿Ï… ÎµÎºÏ„ÎµÎ»Î¿ÏÎ½Ï„Î±Î¹, "
"Î±Î»Î»Î¬ Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ Î±Ï…Ï„ÏŒ Î· Ï‡ÏÎ®ÏƒÎ· Ï„Î¿Ï… Î¤Î¿ \"T\" ÎµÎ¯Î½Î±Î¹ Î´Ï‰ÏÎµÎ¬Î½."

#: src/concurrency/shared_state/arc.md:36
#, fuzzy
msgid "`std::sync::Weak` can help."
msgstr ""
"Î ÏÎ¿ÏƒÎ¿Ï‡Î® ÏƒÏ„Î¿Ï…Ï‚ ÎºÏÎºÎ»Î¿Ï…Ï‚ Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚, Ï„Î¿ Â«ArcÂ» Î´ÎµÎ½ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ ÏƒÏ…Î»Î»Î­ÎºÏ„Î· "
"ÏƒÎºÎ¿Ï…Ï€Î¹Î´Î¹ÏÎ½ Î³Î¹Î± Î½Î± Ï„Î¿Ï…Ï‚ ÎµÎ½Ï„Î¿Ï€Î¯ÏƒÎµÎ¹.\n"
"\n"
"Î¤Î¿ `std::sync::Weak` Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î²Î¿Î·Î¸Î®ÏƒÎµÎ¹."

#: src/concurrency/shared_state/mutex.md:1
#, fuzzy
msgid "`Mutex`"
msgstr "Â«MutexÂ»."

#: src/concurrency/shared_state/mutex.md:3
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface:"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) "
"Î´Î¹Î±ÏƒÏ†Î±Î»Î¯Î¶ÎµÎ¹ Ï„Î·Î½ Î±Î¼Î¿Î¹Î²Î±Î¯Î± ÎµÎ¾Î±Î¯ÏÎµÏƒÎ· _ÎºÎ±Î¹_ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÎ¹ Ï„Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î¿ "
"\"T\" Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Î¼Î¹Î± Î´Î¹ÎµÏ€Î±Ï†Î® Î¼ÏŒÎ½Î¿ Î³Î¹Î± Î±Î½Î¬Î³Î½Ï‰ÏƒÎ·:"

#: src/concurrency/shared_state/mutex.md:6
msgid ""
"```rust,editable\n"
"use std::sync::Mutex;\n"
"\n"
"fn main() {\n"
"    let v = Mutex::new(vec![10, 20, 30]);\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"\n"
"    {\n"
"        let mut guard = v.lock().unwrap();\n"
"        guard.push(40);\n"
"    }\n"
"\n"
"    println!(\"v: {:?}\", v.lock().unwrap());\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/mutex.md:22
#, fuzzy
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"Î Î±ÏÎ±Ï„Î·ÏÎ®ÏƒÏ„Îµ Ï€ÏÏ‚ Î­Ï‡Î¿Ï…Î¼Îµ Î¼Î¹Î± ÎºÎ¿Ï…Î²Î­ÏÏ„Î± [`impl<T: Send> Sync for Mutex<T>`]"
"(https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-"
"Mutex%3CT%3E) ÎµÎºÏ„Î­Î»ÎµÏƒÎ·."

#: src/concurrency/shared_state/mutex.md:31
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element - the "
"protected data."
msgstr "\\<Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚>"

#: src/concurrency/shared_state/mutex.md:32
#, fuzzy
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr ""
"Î¤Î¿ \"Mutex\" ÏƒÏ„Î¿ Rust Î¼Î¿Î¹Î¬Î¶ÎµÎ¹ Î¼Îµ Î¼Î¹Î± ÏƒÏ…Î»Î»Î¿Î³Î® Î¼Îµ Î­Î½Î± Î¼ÏŒÎ½Î¿ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î¿ - Ï„Î± "
"Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏ…Î¼Î­Î½Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î±."

#: src/concurrency/shared_state/mutex.md:33
#, fuzzy
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„ÏŒ Î½Î± Î¾ÎµÏ‡Î¬ÏƒÎµÏ„Îµ Î½Î± Î±Ï€Î¿ÎºÏ„Î®ÏƒÎµÏ„Îµ Ï„Î¿ mutex Ï€ÏÎ¹Î½ Î±Ï€Î¿ÎºÏ„Î®ÏƒÎµÏ„Îµ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· "
"ÏƒÏ„Î± Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏ…Î¼Î­Î½Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î±."

#: src/concurrency/shared_state/mutex.md:35
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï€Î¬ÏÎµÏ„Îµ Î­Î½Î± Â«&mut TÂ» Î±Ï€ÏŒ Î­Î½Î± Â«&Mutex"

#: src/concurrency/shared_state/mutex.md:36
#, fuzzy
msgid "A read-write lock counterpart - `RwLock`."
msgstr ""
"Â» Ï€Î±Î¯ÏÎ½Î¿Î½Ï„Î±Ï‚ Ï„Î·Î½ ÎºÎ»ÎµÎ¹Î´Î±ÏÎ¹Î¬. Î¤Î¿ Â«MutexGuardÂ» Î´Î¹Î±ÏƒÏ†Î±Î»Î¯Î¶ÎµÎ¹ ÏŒÏ„Î¹ Ï„Î¿ Î¤Î¿ \"&mut T\" "
"Î´ÎµÎ½ Î¾ÎµÏ€ÎµÏÎ½Î¬ Ï„Î·Î½ ÎºÎ»ÎµÎ¹Î´Î±ÏÎ¹Î¬ Ï€Î¿Ï… ÎºÏÎ±Ï„Î¹Î­Ï„Î±Î¹."

#: src/concurrency/shared_state/mutex.md:37
#, fuzzy
msgid "Why does `lock()` return a `Result`? "
msgstr "Î¤Î¿ \"Mutex"

#: src/concurrency/shared_state/mutex.md:38
#, fuzzy
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"\" Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ ÎºÎ±Î¹ Ï„Î¿ \"Send\" ÎºÎ±Î¹ Ï„Î¿ \"Sync\" ÎµÎ¬Î½ Ï„Î¿ \"T\" Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ "
"\"Send\".\n"
"\n"
"ÎˆÎ½Î± Î±Î½Ï„Î¯ÏƒÏ„Î¿Î¹Ï‡Î¿ ÎºÎ»ÎµÎ¯Î´Ï‰Î¼Î± Î±Î½Î¬Î³Î½Ï‰ÏƒÎ·Ï‚-ÎµÎ³Î³ÏÎ±Ï†Î®Ï‚ - Â«RwLockÂ».\n"
"\n"
"Î“Î¹Î±Ï„Î¯ Ï„Î¿ Â«lock()Â» ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Î­Î½Î± Â«Î‘Ï€Î¿Ï„Î­Î»ÎµÏƒÎ¼Î±Â»;\n"
"\n"
"Î•Î¬Î½ Ï„Î¿ Î½Î®Î¼Î± Ï€Î¿Ï… ÏƒÏ…Î³ÎºÏÎ±Ï„Î¿ÏÏƒÎµ Ï„Î¿ \"Mutex\" Ï€Î±Î½Î¹ÎºÎ¿Î²Î»Î®Î¸Î·ÎºÎµ, Ï„Î¿ \"Mutex\" Î³Î¯Î½ÎµÏ„Î±Î¹ "
"\"Î´Î·Î»Î·Ï„Î·ÏÎ¹Î±ÏƒÎ¼Î­Î½Î¿\" Î³Î¹Î± Î½Î± ÏƒÎ·Î¼Î±Ï„Î¿Î´Î¿Ï„Î®ÏƒÎµÎ¹ ÏŒÏ„Î¹ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Ï€Î¿Ï… Ï€ÏÎ¿ÏƒÏ„Î±Ï„ÎµÏÎµÎ¹ "
"ÎµÎ½Î´Î­Ï‡ÎµÏ„Î±Î¹ Î½Î± ÎµÎ¯Î½Î±Î¹ ÏƒÎµ Î±ÏƒÏ…Î½ÎµÏ€Î® ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·. ÎšÎ»Î®ÏƒÎ· Â«lock()Â» ÏƒÎµ Î­Î½Î± "
"Î´Î·Î»Î·Ï„Î·ÏÎ¹Î±ÏƒÎ¼Î­Î½Î¿ mutex Î±Ï€Î¿Ï„Ï…Î³Ï‡Î¬Î½ÎµÎ¹ Î¼Îµ Î­Î½Î± [`PoisonError`](https://doc.rust-"
"lang.org/std/sync/struct.PoisonError.html). ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎºÎ±Î»Î­ÏƒÎµÏ„Îµ Ï„Î¿ "
"Â«into_inner()Â» ÏƒÏ„Î¿ ÏƒÏ†Î¬Î»Î¼Î± Î³Î¹Î± Î½Î± Î±Î½Î±ÎºÏ„Î®ÏƒÎµÏ„Îµ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î‘Î½ÎµÎ¾Î¬ÏÏ„Î·Ï„Î±."

#: src/concurrency/shared_state/example.md:3
#, fuzzy
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "Î‘Ï‚ Î´Î¿ÏÎ¼Îµ Ï„Î± \"Arc\" ÎºÎ±Î¹ \"Mutex\" ÏƒÎµ Î´ÏÎ¬ÏƒÎ·:"

#: src/concurrency/shared_state/example.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use std::thread;\n"
"// use std::sync::{Arc, Mutex};\n"
"\n"
"fn main() {\n"
"    let v = vec![10, 20, 30];\n"
"    let handle = thread::spawn(|| {\n"
"        v.push(10);\n"
"    });\n"
"    v.push(1000);\n"
"\n"
"    handle.join().unwrap();\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:23
msgid "Possible solution:"
msgstr ""

#: src/concurrency/shared_state/example.md:25
msgid ""
"```rust,editable\n"
"use std::sync::{Arc, Mutex};\n"
"use std::thread;\n"
"\n"
"fn main() {\n"
"    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
"\n"
"    let v2 = Arc::clone(&v);\n"
"    let handle = thread::spawn(move || {\n"
"        let mut v2 = v2.lock().unwrap();\n"
"        v2.push(10);\n"
"    });\n"
"\n"
"    {\n"
"        let mut v = v.lock().unwrap();\n"
"        v.push(1000);\n"
"    }\n"
"\n"
"    handle.join().unwrap();\n"
"\n"
"    println!(\"v: {v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/concurrency/shared_state/example.md:49
msgid "Notable parts:"
msgstr ""

#: src/concurrency/shared_state/example.md:51
#, fuzzy
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr ""
"Î¤Î¿ \"v\" ÎµÎ¯Î½Î±Î¹ Ï„Ï…Î»Î¹Î³Î¼Î­Î½Î¿ ÎºÎ±Î¹ ÏƒÎµ \"Arc\" ÎºÎ±Î¹ \"Mutex\", ÎµÏ€ÎµÎ¹Î´Î® Î¿Î¹ Î±Î½Î·ÏƒÏ…Ï‡Î¯ÎµÏ‚ "
"Ï„Î¿Ï…Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿ÏÎ¸Î¿Î³ÏÎ½Î¹ÎµÏ‚."

#: src/concurrency/shared_state/example.md:52
#, fuzzy
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr ""
"Î¤Î¿ Ï„ÏÎ»Î¹Î³Î¼Î± ÎµÎ½ÏŒÏ‚ \"Mutex\" ÏƒÎµ Î­Î½Î± \"Arc\" ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏƒÏ…Î½Î·Î¸Î¹ÏƒÎ¼Î­Î½Î¿ Î¼Î¿Ï„Î¯Î²Î¿ Î³Î¹Î± "
"ÎºÎ¿Î¹Î½Î® Ï‡ÏÎ®ÏƒÎ· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î®Ï‚ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚ Î¼ÎµÏ„Î±Î¾Ï Ï„Ï‰Î½ Î½Î·Î¼Î¬Ï„Ï‰Î½."

#: src/concurrency/shared_state/example.md:53
#, fuzzy
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"Î¤Î¿ `v: Î¤Î¿ Arc<_>` Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ»Ï‰Î½Î¿Ï€Î¿Î¹Î·Î¸ÎµÎ¯ Ï‰Ï‚ `v2` Î³Î¹Î± Î½Î± Î¼Ï€Î¿ÏÎ­ÏƒÎµÎ¹ Î½Î± "
"Î¼ÎµÏ„Î±ÎºÎ¹Î½Î·Î¸ÎµÎ¯ ÏƒÎµ Î¬Î»Î»Î¿ Î½Î®Î¼Î±. Î— ÏƒÎ·Î¼ÎµÎ¯Ï‰ÏƒÎ· \"move\" Ï€ÏÎ¿ÏƒÏ„Î­Î¸Î·ÎºÎµ ÏƒÏ„Î·Î½ Ï…Ï€Î¿Î³ÏÎ±Ï†Î® Î»Î¬Î¼Î´Î±."

#: src/concurrency/shared_state/example.md:54
#, fuzzy
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr ""
"Î¤Î± Î¼Ï€Î»Î¿Îº ÎµÎ¹ÏƒÎ¬Î³Î¿Î½Ï„Î±Î¹ Î³Î¹Î± Î½Î± Ï€ÎµÏÎ¹Î¿ÏÎ¯ÏƒÎ¿Ï…Î½ ÏŒÏƒÎ¿ Ï„Î¿ Î´Ï…Î½Î±Ï„ÏŒÎ½ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ Ï„Î¿ Ï€ÎµÎ´Î¯Î¿ "
"ÎµÏ†Î±ÏÎ¼Î¿Î³Î®Ï‚ Ï„Î¿Ï… \"LockGuard\".\n"
"\n"
"Î ÏÎ­Ï€ÎµÎ¹ Î±ÎºÏŒÎ¼Î± Î½Î± Î±Ï€Î¿ÎºÏ„Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿ Â«MutexÂ» Î³Î¹Î± Î½Î± ÎµÎºÏ„Ï…Ï€ÏÏƒÎ¿Ï…Î¼Îµ Ï„Î¿ Â«VecÂ» Î¼Î±Ï‚."

#: src/exercises/concurrency/morning.md:3
#, fuzzy
msgid "Let us practice our new concurrency skills with"
msgstr "Î‘Ï‚ ÎµÎ¾Î±ÏƒÎºÎ®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¹Ï‚ Î½Î­ÎµÏ‚ Î¼Î±Ï‚ Î´ÎµÎ¾Î¹ÏŒÏ„Î·Ï„ÎµÏ‚ ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼Î¿Ï Î¼Îµ"

#: src/exercises/concurrency/morning.md:5
#, fuzzy
msgid "Dining philosophers: a classic problem in concurrency."
msgstr ""
"ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Ï‰Î½ Ï€Î¿Î»Î»Î±Ï€Î»ÏÎ½ Î½Î·Î¼Î¬Ï„Ï‰Î½: Î­Î½Î± Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿ Î­ÏÎ³Î¿ ÏƒÏ„Î¿ Î¿Ï€Î¿Î¯Î¿ Î¸Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Cargo ÎºÎ±Ï„ÎµÎ²Î¬ÏƒÏ„Îµ Ï„Î¹Ï‚ ÎµÎ¾Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ ÎºÎ±Î¹, ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, ÎµÎ»Î­Î³Î¾Ï„Îµ "
"Ï„Î¿Ï…Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Î¿Ï…Ï‚ Ï€Î±ÏÎ¬Î»Î»Î·Î»Î±."

#: src/exercises/concurrency/morning.md:7
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:3
#, fuzzy
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr ""
"Î¤Î¿ Ï€ÏÏŒÎ²Î»Î·Î¼Î± Ï„Ï‰Î½ Ï†Î¹Î»Î¿ÏƒÏŒÏ†Ï‰Î½ Ï„ÏÎ±Ï€ÎµÎ¶Î±ÏÎ¯Î±Ï‚ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÎºÎ»Î±ÏƒÎ¹ÎºÏŒ Ï€ÏÏŒÎ²Î»Î·Î¼Î± Ï„Î±Ï…Ï„ÏŒÏ‡ÏÎ¿Î½Î±:"

#: src/exercises/concurrency/dining-philosophers.md:5
#, fuzzy
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"Î Î­Î½Ï„Îµ Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Î¹ Î´ÎµÎ¹Ï€Î½Î¿ÏÎ½ Î¼Î±Î¶Î¯ ÏƒÏ„Î¿ Î¯Î´Î¹Î¿ Ï„ÏÎ±Ï€Î­Î¶Î¹. ÎšÎ¬Î¸Îµ Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Ï‚ Î­Ï‡ÎµÎ¹ Ï„Î¿ Î´Î¹ÎºÏŒ "
"Ï„Î¿Ï… Î´Î¹ÎºÎ® ÏƒÎ¿Ï… Î¸Î­ÏƒÎ· ÏƒÏ„Î¿ Ï„ÏÎ±Ï€Î­Î¶Î¹. Î‘Î½Î¬Î¼ÎµÏƒÎ± ÏƒÎµ ÎºÎ¬Î¸Îµ Ï€Î¹Î¬Ï„Î¿ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î­Î½Î± Ï€Î¹ÏÎ¿ÏÎ½Î¹. Î¤Î¿ "
"Ï€Î¹Î¬Ï„Î¿ Ï€Î¿Ï… ÏƒÎµÏÎ²Î¯ÏÎµÏ„Î±Î¹ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÎµÎ¯Î´Î¿Ï‚ ÏƒÏ€Î±Î³Î³Î­Ï„Î¹ Ï€Î¿Ï… Ï„ÏÏÎ³ÎµÏ„Î±Î¹ Î¼Îµ Î´ÏÎ¿ Ï€Î¹ÏÎ¿ÏÎ½Î¹Î±. "
"ÎšÎ¬Î¸Îµ Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î¼ÏŒÎ½Î¿ ÎµÎ½Î±Î»Î»Î¬Î¾ ÏƒÎºÎµÏ†Ï„ÎµÎ¯Ï„Îµ ÎºÎ±Î¹ Ï„ÏÏÏ„Îµ. Î•Ï€Î¹Ï€Î»Î­Î¿Î½, Î­Î½Î±Ï‚ "
"Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï†Î¬ÎµÎ¹ Î¼ÏŒÎ½Î¿ Ï„Î¿Ï…Ï‚ Î¼Î±ÎºÎ±ÏÏŒÎ½Î¹Î± ÏŒÏ„Î±Î½ Î­Ï‡Î¿Ï…Î½ ÎºÎ±Î¹ Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ ÎºÎ±Î¹ "
"Î´ÎµÎ¾Î¯ Ï€Î¹ÏÎ¿ÏÎ½Î¹. ÎˆÏ„ÏƒÎ¹ Î¸Î± Î¼ÏŒÎ½Î¿ Î´ÏÎ¿ Ï€Î¹ÏÎ¿ÏÎ½Î¹Î± Î½Î± ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿Î¹ ÏŒÏ„Î±Î½ Î¿Î¹ Î´ÏÎ¿ "
"ÎºÎ¿Î½Ï„Î¹Î½ÏŒÏ„ÎµÏÎ¿Î¹ Î³ÎµÎ¯Ï„Î¿Î½Î­Ï‚ Ï„Î¿Ï…Ï‚ ÏƒÎºÎ­Ï†Ï„Î¿Î½Ï„Î±Î¹ ÎºÎ±Î¹ Î´ÎµÎ½ Ï„ÏÏÎ½Îµ. ÎœÎµÏ„Î¬ Î­Î½Î±Ï‚ Î¼ÎµÎ¼Î¿Î½Ï‰Î¼Î­Î½Î¿Ï‚ "
"Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Ï‚ Ï„ÎµÎ»ÎµÎ¹ÏÎ½ÎµÎ¹ Ï„Î¿ Ï†Î±Î³Î·Ï„ÏŒ, Î¸Î± Î²Î¬Î»ÎµÎ¹ ÎºÎ¬Ï„Ï‰ ÎºÎ±Î¹ Ï„Î± Î´ÏÎ¿ Ï€Î¹ÏÎ¿ÏÎ½Î¹Î±."

#: src/exercises/concurrency/dining-philosophers.md:13
#, fuzzy
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Î˜Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Î¼Î¹Î± Ï„Î¿Ï€Î¹ÎºÎ® [Î•Î³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Ï†Î¿ÏÏ„Î¯Î¿Ï…](../../cargo/running-locally."
"md) Î³Î¹Î± Î±Ï…Ï„Î® Î· Î¬ÏƒÎºÎ·ÏƒÎ·. Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ \\`src/main."
"rs, ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î± ÎºÎµÎ½Î¬, ÎºÎ±Î¹ ÎµÎ»Î­Î³Î¾Ï„Îµ ÏŒÏ„Î¹ Ï„Î¿ Â«cargo runÂ» Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î±Î´Î¹Î­Î¾Î¿Î´Î¿:"

#: src/exercises/concurrency/dining-philosophers.md:19
msgid ""
"```rust,compile_fail\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make each of them think and eat 100 times\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:61
msgid "You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers.md:65
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:3
#, fuzzy
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"Î‘Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¹Ï‚ Î½Î­ÎµÏ‚ Î³Î½ÏÏƒÎµÎ¹Ï‚ Î¼Î±Ï‚ Î³Î¹Î± Î½Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎ¿Ï…Î¼Îµ Î­Î½Î±Î½ Î­Î»ÎµÎ³Ï‡Î¿ "
"ÏƒÏ…Î½Î´Î­ÏƒÎ¼Ï‰Î½ Ï€Î¿Î»Î»Î±Ï€Î»ÏÎ½ Î½Î·Î¼Î¬Ï„Ï‰Î½. Î˜Î± Î­Ï€ÏÎµÏ€Îµ Î¾ÎµÎºÎ¹Î½Î®ÏƒÏ„Îµ Î±Ï€ÏŒ Î¼Î¹Î± Î¹ÏƒÏ„Î¿ÏƒÎµÎ»Î¯Î´Î± ÎºÎ±Î¹ "
"ÎµÎ»Î­Î³Î¾Ï„Îµ ÏŒÏ„Î¹ Î¿Î¹ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Î¹ ÏƒÏ„Î· ÏƒÎµÎ»Î¯Î´Î± ÎµÎ¯Î½Î±Î¹ Î­Î³ÎºÏ…ÏÎ¿Î¹. Î˜Î± Î­Ï€ÏÎµÏ€Îµ ÎµÎ»Î­Î³Î¾Ï„Îµ "
"Î±Î½Î±Î´ÏÎ¿Î¼Î¹ÎºÎ¬ Î¬Î»Î»ÎµÏ‚ ÏƒÎµÎ»Î¯Î´ÎµÏ‚ ÏƒÏ„Î¿Î½ Î¯Î´Î¹Î¿ Ï„Î¿Î¼Î­Î± ÎºÎ±Î¹ ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÏ„Îµ Î½Î± Ï„Î¿ ÎºÎ¬Î½ÎµÏ„Îµ Î±Ï…Ï„ÏŒ "
"Î¼Î­Ï‡ÏÎ¹ Î½Î± Ï„ÎµÎ»ÎµÎ¹ÏÏƒÎµÎ¹ Î¿Î¹ ÏƒÎµÎ»Î¯Î´ÎµÏ‚ Î­Ï‡Î¿Ï…Î½ ÎµÏ€Î¹ÎºÏ…ÏÏ‰Î¸ÎµÎ¯."

#: src/exercises/concurrency/link-checker.md:8
#, fuzzy
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"Î“Î¹Î± Î±Ï…Ï„ÏŒ, Î¸Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Î­Î½Î± Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î±-Ï€ÎµÎ»Î¬Ï„Î· HTTP ÏŒÏ€Ï‰Ï‚ Ï„Î¿ "
"\\[`reqwest`\\]\\[1\\]. Î”Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏƒÎµ Î­Î½Î± Î½Î­Î¿ ÎˆÏÎ³Î¿ Ï†Î¿ÏÏ„Î¯Î¿Ï… ÎºÎ±Î¹ Ï„Î¿ Â«Î¶Î®Ï„Î·ÏƒÎµÂ» Ï‰Ï‚ "
"ÎµÎ¾Î¬ÏÏ„Î·ÏƒÎ· Î¼Îµ:"

#: src/exercises/concurrency/link-checker.md:11
msgid ""
"```shell\n"
"cargo new link-checker\n"
"cd link-checker\n"
"cargo add --features blocking,rustls-tls reqwest\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:17
#, fuzzy
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"Î•Î¬Î½ Î· Â«Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎ· Ï†Î¿ÏÏ„Î¯Î¿Ï…Â» Î±Ï€Î¿Ï„ÏÏ‡ÎµÎ¹ Î¼Îµ Â«ÏƒÏ†Î¬Î»Î¼Î±: Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï„Î­Ï„Î¿Î¹Î± Ï…Ï€Î¿ÎµÎ½Ï„Î¿Î»Î®Â», "
"Ï„ÏŒÏ„Îµ ÎµÏ€ÎµÎ¾ÎµÏÎ³Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Ï„Î¿ Î‘ÏÏ‡ÎµÎ¯Î¿ Â«Cargo.tomlÂ» Î¼Îµ Ï„Î¿ Ï‡Î­ÏÎ¹. Î ÏÎ¿ÏƒÎ¸Î­ÏƒÏ„Îµ Ï„Î¹Ï‚ "
"ÎµÎ¾Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… Î±Î½Î±Ï†Î­ÏÎ¿Î½Ï„Î±Î¹ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰."

#: src/exercises/concurrency/link-checker.md:20
#, fuzzy
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr ""
"Î˜Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î­Î½Î±Î½ Ï„ÏÏŒÏ€Î¿ Î½Î± Î²ÏÎµÎ¯Ï„Îµ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Î¿Ï…Ï‚. ÎœÏ€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿ \\[`scraper`\\]\\[2\\] Î³Î¹Î± Î±Ï…Ï„ÏŒ:"

#: src/exercises/concurrency/link-checker.md:22
msgid ""
"```shell\n"
"cargo add scraper\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:26
#, fuzzy
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"Î¤Î­Î»Î¿Ï‚, Î¸Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„Î¿ÏÎ¼Îµ ÎºÎ¬Ï€Î¿Î¹Î¿ Ï„ÏÏŒÏ€Î¿ Ï‡ÎµÎ¹ÏÎ¹ÏƒÎ¼Î¿Ï Ï„Ï‰Î½ ÏƒÏ†Î±Î»Î¼Î¬Ï„Ï‰Î½. Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼Îµ "
"\\[`Î±Ï…Ï„ÏŒ Ï„Î¿ ÏƒÏ†Î¬Î»Î¼Î±`\\]\\[3\\] Î³Î¹Î± ÏŒÏ„Î¹:"

#: src/exercises/concurrency/link-checker.md:29
msgid ""
"```shell\n"
"cargo add thiserror\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:33
#, fuzzy
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr ""
"ÎŸÎ¹ ÎºÎ»Î®ÏƒÎµÎ¹Ï‚ \"cargo add\" Î¸Î± ÎµÎ½Î·Î¼ÎµÏÏÏƒÎ¿Ï…Î½ Ï„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ \"Cargo.toml\" ÏÏƒÏ„Îµ Î½Î± "
"Î­Ï‡ÎµÎ¹ Ï„Î·Î½ ÎµÎ¾Î®Ï‚ Î¼Î¿ÏÏ†Î®:"

#: src/exercises/concurrency/link-checker.md:37
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:50
#, fuzzy
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"Î¤ÏÏÎ± Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ Î»Î®ÏˆÎ· Ï„Î·Ï‚ Î±ÏÏ‡Î¹ÎºÎ®Ï‚ ÏƒÎµÎ»Î¯Î´Î±Ï‚. Î”Î¿ÎºÎ¹Î¼Î¬ÏƒÏ„Îµ Î¼Îµ Î­Î½Î± Î¼Î¹ÎºÏÏŒ "
"site ÏŒÏ€Ï‰Ï‚ Ï€.Ï‡ `https://www.google.org/`."

#: src/exercises/concurrency/link-checker.md:53
#, fuzzy
msgid "Your `src/main.rs` file should look something like this:"
msgstr "Î¤Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ `src/main.rs` Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î¼Î¿Î¹Î¬Î¶ÎµÎ¹ ÎºÎ¬Ï€Ï‰Ï‚ Î­Ï„ÏƒÎ¹:"

#: src/exercises/concurrency/link-checker.md:57
msgid ""
"```rust,compile_fail\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"\n"
"fn main() {\n"
"    let client = Client::new();\n"
"    let start_url = Url::parse(\"https://www.google.org\").unwrap();\n"
"    let crawl_command = CrawlCommand{ url: start_url, extract_links: "
"true };\n"
"    match visit_page(&client, &crawl_command) {\n"
"        Ok(links) => println!(\"Links: {links:#?}\"),\n"
"        Err(err) => println!(\"Could not extract links: {err:#}\"),\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:120
#, fuzzy
msgid "Run the code in `src/main.rs` with"
msgstr "Î•ÎºÏ„ÎµÎ»Î­ÏƒÏ„Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ `src/main.rs` Î¼Îµ"

#: src/exercises/concurrency/link-checker.md:122
msgid ""
"```shell\n"
"cargo run\n"
"```"
msgstr ""

#: src/exercises/concurrency/link-checker.md:128
#, fuzzy
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Î½Î®Î¼Î±Ï„Î± Î³Î¹Î± Î½Î± ÎµÎ»Î­Î³Î¾ÎµÏ„Îµ Ï„Î¿Ï…Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Î¿Ï…Ï‚ Ï€Î±ÏÎ¬Î»Î»Î·Î»Î±: ÏƒÏ„ÎµÎ¯Î»Ï„Îµ Ï„Î¹Ï‚ "
"Î´Î¹ÎµÏ…Î¸ÏÎ½ÏƒÎµÎ¹Ï‚ URL Ï€Î¿Ï… Î¸Î± ÎµÎ»ÎµÎ³Ï‡Î¸Î¿ÏÎ½ ÏƒÏ„Î¿ a ÎºÎ±Î½Î¬Î»Î¹ ÎºÎ±Î¹ Î±Ï†Î®ÏƒÏ„Îµ Î¼ÎµÏÎ¹ÎºÎ¬ Î½Î®Î¼Î±Ï„Î± Î½Î± "
"ÎµÎ»Î­Î³Î¾Î¿Ï…Î½ Ï„Î¹Ï‚ Î´Î¹ÎµÏ…Î¸ÏÎ½ÏƒÎµÎ¹Ï‚ URL Ï€Î±ÏÎ¬Î»Î»Î·Î»Î±."

#: src/exercises/concurrency/link-checker.md:130
#, fuzzy
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"Î•Ï€ÎµÎºÏ„ÎµÎ¯Î½ÎµÏ„Îµ Î±Ï…Ï„ÏŒ Î³Î¹Î± Î½Î± ÎµÎ¾Î±Î³Î¬Î³ÎµÏ„Îµ Î±Î½Î±Î´ÏÎ¿Î¼Î¹ÎºÎ¬ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Î¿Ï…Ï‚ Î±Ï€ÏŒ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ ÏƒÎµÎ»Î¯Î´ÎµÏ‚ "
"Ï„Î¿Ï… Ï„Î¿Î¼Î­Î±Ï‚ `www.google.org`. Î’Î¬Î»Ï„Îµ Î­Î½Î± Î±Î½ÏÏ„Î±Ï„Î¿ ÏŒÏÎ¹Î¿ 100 ÏƒÎµÎ»Î¯Î´Ï‰Î½ Ï€ÎµÏÎ¯Ï€Î¿Ï… Î­Ï„ÏƒÎ¹ "
"ÏÏƒÏ„Îµ Î½Î± Î¼Î·Î½ ÎºÎ±Ï„Î±Î»Î®Î¾ÎµÏ„Îµ Î½Î± Î±Ï€Î¿ÎºÎ»ÎµÎ¹ÏƒÏ„ÎµÎ¯Ï„Îµ Î±Ï€ÏŒ Ï„Î¿Î½ Î¹ÏƒÏ„ÏŒÏ„Î¿Ï€Î¿."

#: src/async.md:1
#, fuzzy
msgid "Async Rust"
msgstr "Î“Î¹Î±Ï„Î¯ Rust;"

#: src/async.md:3
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""

#: src/async.md:10
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""

#: src/async.md:14
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr ""

#: src/async.md:17
#, fuzzy
msgid "Comparisons"
msgstr "Î£ÏÎ³ÎºÏÎ¹ÏƒÎ·"

#: src/async.md:19
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""

#: src/async.md:23
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""

#: src/async/async-await.md:1
msgid "`async`/`await`"
msgstr ""

#: src/async/async-await.md:3
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr ""

#: src/async/async-await.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use futures::executor::block_on;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count is: {i}!\");\n"
"    }\n"
"}\n"
"\n"
"async fn async_main(count: i32) {\n"
"    count_to(count).await;\n"
"}\n"
"\n"
"fn main() {\n"
"    block_on(async_main(10));\n"
"}\n"
"```"
msgstr ""

#: src/async/async-await.md:27
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""

#: src/async/async-await.md:30
#, fuzzy
msgid "What is the return type of an async call?"
msgstr "Î Î¿Î¹Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î¿ Ï„ÏÏ€Î¿Ï‚ Ï„Î·Ï‚ Î»Î­Î¾Î·Ï‚ ÏƒÎµ ÎºÎ¬Î¸Îµ Î²ÏÏŒÏ‡Î¿;"

#: src/async/async-await.md:31
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr ""

#: src/async/async-await.md:33
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future. "
msgstr ""

#: src/async/async-await.md:36
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""

#: src/async/async-await.md:39
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion. "
msgstr ""

#: src/async/async-await.md:42
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""

#: src/async/async-await.md:45
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later). "
msgstr ""

#: src/async/futures.md:3
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""

#: src/async/futures.md:8
msgid ""
"```rust\n"
"use std::pin::Pin;\n"
"use std::task::Context;\n"
"\n"
"pub trait Future {\n"
"    type Output;\n"
"    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::"
"Output>;\n"
"}\n"
"\n"
"pub enum Poll<T> {\n"
"    Ready(T),\n"
"    Pending,\n"
"}\n"
"```"
msgstr ""

#: src/async/futures.md:23
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""

#: src/async/futures.md:27
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""

#: src/async/futures.md:32
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""

#: src/async/futures.md:35
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""

#: src/async/futures.md:38
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr ""

#: src/async/futures.md:41
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""

#: src/async/runtimes.md:3
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""

#: src/async/runtimes.md:7
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""

#: src/async/runtimes.md:10
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""

#: src/async/runtimes.md:12
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr ""

#: src/async/runtimes.md:14
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""

#: src/async/runtimes.md:20
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""

#: src/async/runtimes.md:24
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""

#: src/async/runtimes/tokio.md:4
msgid "Tokio provides: "
msgstr ""

#: src/async/runtimes/tokio.md:6
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr ""

#: src/async/runtimes/tokio.md:7
msgid "An asynchronous version of the standard library."
msgstr ""

#: src/async/runtimes/tokio.md:8
msgid "A large ecosystem of libraries."
msgstr ""

#: src/async/runtimes/tokio.md:10
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::time;\n"
"\n"
"async fn count_to(count: i32) {\n"
"    for i in 1..=count {\n"
"        println!(\"Count in task: {i}!\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    tokio::spawn(count_to(10));\n"
"\n"
"    for i in 1..5 {\n"
"        println!(\"Main task: {i}\");\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/runtimes/tokio.md:33
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr ""

#: src/async/runtimes/tokio.md:35
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr ""

#: src/async/runtimes/tokio.md:37
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""

#: src/async/runtimes/tokio.md:39
msgid "**Further exploration:**"
msgstr ""

#: src/async/runtimes/tokio.md:41
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""

#: src/async/runtimes/tokio.md:45
msgid "Try `count_to(10).await` instead of spawning."
msgstr ""

#: src/async/runtimes/tokio.md:47
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr ""

#: src/async/tasks.md:3
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr ""

#: src/async/tasks.md:5
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""

#: src/async/tasks.md:10
msgid ""
"```rust,compile_fail\n"
"use tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n"
"use tokio::net::TcpListener;\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> io::Result<()> {\n"
"    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;\n"
"\tprintln!(\"listening on port 6142\");\n"
"\n"
"    loop {\n"
"        let (mut socket, addr) = listener.accept().await?;\n"
"\n"
"        println!(\"connection from {addr:?}\");\n"
"\n"
"        tokio::spawn(async move {\n"
"            if let Err(e) = socket.write_all(b\"Who are you?\\n\").await {\n"
"                println!(\"socket error: {e:?}\");\n"
"                return;\n"
"            }\n"
"\n"
"            let mut buf = vec![0; 1024];\n"
"            let reply = match socket.read(&mut buf).await {\n"
"                Ok(n) => {\n"
"                    let name = std::str::from_utf8(&buf[..n]).unwrap()."
"trim();\n"
"                    format!(\"Thanks for dialing in, {name}!\\n\")\n"
"                }\n"
"                Err(e) => {\n"
"                    println!(\"socket error: {e:?}\");\n"
"                    return;\n"
"                }\n"
"            };\n"
"\n"
"            if let Err(e) = socket.write_all(reply.as_bytes()).await {\n"
"                println!(\"socket error: {e:?}\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/tasks.md:52 src/async/control-flow/join.md:36
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr ""

#: src/async/tasks.md:54
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""

#: src/async/tasks.md:57
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`. "
msgstr ""

#: src/async/tasks.md:61
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr ""

#: src/async/channels.md:3
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr ""

#: src/async/channels.md:5
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"\n"
"async fn ping_handler(mut input: Receiver<()>) {\n"
"    let mut count: usize = 0;\n"
"\n"
"    while let Some(_) = input.recv().await {\n"
"        count += 1;\n"
"        println!(\"Received {count} pings so far.\");\n"
"    }\n"
"\n"
"    println!(\"ping_handler complete\");\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (sender, receiver) = mpsc::channel(32);\n"
"    let ping_handler_task = tokio::spawn(ping_handler(receiver));\n"
"    for i in 0..10 {\n"
"        sender.send(()).await.expect(\"Failed to send ping.\");\n"
"        println!(\"Sent {} pings so far.\", i + 1);\n"
"    }\n"
"\n"
"    drop(sender);\n"
"    ping_handler_task.await.expect(\"Something went wrong in ping handler "
"task.\");\n"
"}\n"
"```"
msgstr ""

#: src/async/channels.md:35
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr ""

#: src/async/channels.md:37
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""

#: src/async/channels.md:40
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr ""

#: src/async/channels.md:42
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""

#: src/async/channels.md:46
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""

#: src/async/control-flow.md:1
#, fuzzy
msgid "Futures Control Flow"
msgstr "Î¡Î¿Î® ÎµÎ»Î­Î³Ï‡Î¿Ï…"

#: src/async/control-flow.md:3
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""

#: src/async/control-flow.md:6
msgid "[Join](control-flow/join.md)"
msgstr ""

#: src/async/control-flow.md:7
msgid "[Select](control-flow/select.md)"
msgstr ""

#: src/async/control-flow/join.md:3
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""

#: src/async/control-flow/join.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use anyhow::Result;\n"
"use futures::future;\n"
"use reqwest;\n"
"use std::collections::HashMap;\n"
"\n"
"async fn size_of_page(url: &str) -> Result<usize> {\n"
"    let resp = reqwest::get(url).await?;\n"
"    Ok(resp.text().await?.len())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let urls: [&str; 4] = [\n"
"        \"https://google.com\",\n"
"        \"https://httpbin.org/ip\",\n"
"        \"https://play.rust-lang.org/\",\n"
"        \"BAD_URL\",\n"
"    ];\n"
"    let futures_iter = urls.into_iter().map(size_of_page);\n"
"    let results = future::join_all(futures_iter).await;\n"
"    let page_sizes_dict: HashMap<&str, Result<usize>> =\n"
"        urls.into_iter().zip(results.into_iter()).collect();\n"
"    println!(\"{:?}\", page_sizes_dict);\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/join.md:38
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""

#: src/async/control-flow/join.md:42
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall. "
msgstr ""

#: src/async/control-flow/join.md:45
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""

#: src/async/control-flow/select.md:3
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""

#: src/async/control-flow/select.md:8
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When the `future` is "
"ready, the `statement` is executed with the variables in `pattern` bound to "
"the `future`'s result."
msgstr ""

#: src/async/control-flow/select.md:13
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::mpsc::{self, Receiver};\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[derive(Debug, PartialEq)]\n"
"enum Animal {\n"
"    Cat { name: String },\n"
"    Dog { name: String },\n"
"}\n"
"\n"
"async fn first_animal_to_finish_race(\n"
"    mut cat_rcv: Receiver<String>,\n"
"    mut dog_rcv: Receiver<String>,\n"
") -> Option<Animal> {\n"
"    tokio::select! {\n"
"        cat_name = cat_rcv.recv() => Some(Animal::Cat { name: cat_name? }),\n"
"        dog_name = dog_rcv.recv() => Some(Animal::Dog { name: dog_name? })\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (cat_sender, cat_receiver) = mpsc::channel(32);\n"
"    let (dog_sender, dog_receiver) = mpsc::channel(32);\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(500)).await;\n"
"        cat_sender\n"
"            .send(String::from(\"Felix\"))\n"
"            .await\n"
"            .expect(\"Failed to send cat.\");\n"
"    });\n"
"    tokio::spawn(async move {\n"
"        sleep(Duration::from_millis(50)).await;\n"
"        dog_sender\n"
"            .send(String::from(\"Rex\"))\n"
"            .await\n"
"            .expect(\"Failed to send dog.\");\n"
"    });\n"
"\n"
"    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)\n"
"        .await\n"
"        .expect(\"Failed to receive winner\");\n"
"\n"
"    println!(\"Winner is {winner:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/async/control-flow/select.md:62
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms seconds."
msgstr ""

#: src/async/control-flow/select.md:67
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""

#: src/async/control-flow/select.md:70
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr ""

#: src/async/control-flow/select.md:73
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""

#: src/async/control-flow/select.md:76
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""

#: src/async/pitfalls.md:1
msgid "Pitfalls of async/await"
msgstr ""

#: src/async/pitfalls.md:3
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""

#: src/async/pitfalls.md:5
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr ""

#: src/async/pitfalls.md:6
msgid "[Pin](pitfalls/pin.md)"
msgstr ""

#: src/async/pitfalls.md:7
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr ""

#: src/async/pitfalls.md:8
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:1
msgid "Blocking the executor"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:3
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use futures::future::join_all;\n"
"use std::time::Instant;\n"
"\n"
"async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {\n"
"    std::thread::sleep(std::time::Duration::from_millis(duration_ms));\n"
"    println!(\n"
"        \"future {id} slept for {duration_ms}ms, finished after {}ms\",\n"
"        start.elapsed().as_millis()\n"
"    );\n"
"}\n"
"\n"
"#[tokio::main(flavor = \"current_thread\")]\n"
"async fn main() {\n"
"    let start = Instant::now();\n"
"    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));\n"
"    join_all(sleep_futures).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/blocking-executor.md:29
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:32
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:36
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:38
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:41
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""

#: src/async/pitfalls/blocking-executor.md:47
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""

#: src/async/pitfalls/pin.md:3
msgid ""
"When you await a future, all local variables (that would ordinarily be "
"stored on a stack frame) are instead stored in the Future for the current "
"async block. If your future has pointers to data on the stack, those "
"pointers might get invalidated. This is unsafe."
msgstr ""

#: src/async/pitfalls/pin.md:8
msgid ""
"Therefore, you must guarantee that the addresses your future points to don't "
"change. That is why we need to `pin` futures. Using the same future "
"repeatedly in a `select!` often leads to issues with pinned values."
msgstr ""

#: src/async/pitfalls/pin.md:12
msgid ""
"```rust,editable,compile_fail\n"
"use tokio::sync::{mpsc, oneshot};\n"
"use tokio::task::spawn;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
"#[derive(Debug)]\n"
"struct Work {\n"
"    input: u32,\n"
"    respond_on: oneshot::Sender<u32>,\n"
"}\n"
"\n"
"// A worker which listens for work on a queue and performs it.\n"
"async fn worker(mut work_queue: mpsc::Receiver<Work>) {\n"
"    let mut iterations = 0;\n"
"    loop {\n"
"        tokio::select! {\n"
"            Some(work) = work_queue.recv() => {\n"
"                sleep(Duration::from_millis(10)).await; // Pretend to work.\n"
"                work.respond_on\n"
"                    .send(work.input * 1000)\n"
"                    .expect(\"failed to send response\");\n"
"                iterations += 1;\n"
"            }\n"
"            // TODO: report number of iterations every 100ms\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// A requester which requests work and waits for it to complete.\n"
"async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {\n"
"    let (tx, rx) = oneshot::channel();\n"
"    work_queue\n"
"        .send(Work {\n"
"            input,\n"
"            respond_on: tx,\n"
"        })\n"
"        .await\n"
"        .expect(\"failed to send on work queue\");\n"
"    rx.await.expect(\"failed waiting for response\")\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let (tx, rx) = mpsc::channel(10);\n"
"    spawn(worker(rx));\n"
"    for i in 0..100 {\n"
"        let resp = do_work(&tx, i).await;\n"
"        println!(\"work result for iteration {i}: {resp}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:68
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr ""

#: src/async/pitfalls/pin.md:71
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr ""

#: src/async/pitfalls/pin.md:74
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""

#: src/async/pitfalls/pin.md:77
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr ""

#: src/async/pitfalls/pin.md:79
msgid ""
"```rust,compile_fail\n"
"let mut timeout_fut = sleep(Duration::from_millis(100));\n"
"loop {\n"
"    select! {\n"
"        ..,\n"
"        _ = timeout_fut => { println!(..); },\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:88
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""

#: src/async/pitfalls/pin.md:92
msgid ""
"```rust,compile_fail\n"
"let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));\n"
"loop {\n"
"    select! {\n"
"        ..,\n"
"        _ = &mut timeout_fut => { println!(..); },\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/pin.md:102
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""

#: src/async/pitfalls/pin.md:106
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""

#: src/async/pitfalls/pin.md:110
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""

#: src/async/pitfalls/async-traits.md:3
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""

#: src/async/pitfalls/async-traits.md:5
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""

#: src/async/pitfalls/async-traits.md:7
msgid ""
"```rust,editable,compile_fail\n"
"use async_trait::async_trait;\n"
"use std::time::Instant;\n"
"use tokio::time::{sleep, Duration};\n"
"\n"
"#[async_trait]\n"
"trait Sleeper {\n"
"    async fn sleep(&self);\n"
"}\n"
"\n"
"struct FixedSleeper {\n"
"    sleep_ms: u64,\n"
"}\n"
"\n"
"#[async_trait]\n"
"impl Sleeper for FixedSleeper {\n"
"    async fn sleep(&self) {\n"
"        sleep(Duration::from_millis(self.sleep_ms)).await;\n"
"    }\n"
"}\n"
"\n"
"async fn run_all_sleepers_multiple_times(sleepers: Vec<Box<dyn Sleeper>>, "
"n_times: usize) {\n"
"    for _ in 0..n_times {\n"
"        println!(\"running all sleepers..\");\n"
"        for sleeper in &sleepers {\n"
"            let start = Instant::now();\n"
"            sleeper.sleep().await;\n"
"            println!(\"slept for {}ms\", start.elapsed().as_millis());\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    let sleepers: Vec<Box<dyn Sleeper>> = vec![\n"
"        Box::new(FixedSleeper { sleep_ms: 50 }),\n"
"        Box::new(FixedSleeper { sleep_ms: 100 }),\n"
"    ];\n"
"    run_all_sleepers_multiple_times(sleepers, 5).await;\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/async-traits.md:51
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""

#: src/async/pitfalls/async-traits.md:54
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""

#: src/async/pitfalls/async-traits.md:60
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""

#: src/async/pitfalls/cancellation.md:3
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""

#: src/async/pitfalls/cancellation.md:8
msgid ""
"```rust,editable,compile_fail\n"
"use std::io::{self, ErrorKind};\n"
"use std::time::Duration;\n"
"use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};\n"
"\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream }\n"
"    }\n"
"\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        let mut bytes = Vec::new();\n"
"        let mut buf = [0];\n"
"        while self.stream.read(&mut buf[..]).await? != 0 {\n"
"            bytes.push(buf[0]);\n"
"            if buf[0] == b'\\n' {\n"
"                break;\n"
"            }\n"
"        }\n"
"        if bytes.is_empty() {\n"
"            return Ok(None)\n"
"        }\n"
"        let s = String::from_utf8(bytes)\n"
"            .map_err(|_| io::Error::new(ErrorKind::InvalidData, \"not "
"UTF-8\"))?;\n"
"        Ok(Some(s))\n"
"    }\n"
"}\n"
"\n"
"async fn slow_copy(source: String, mut dest: DuplexStream) -> std::io::"
"Result<()> {\n"
"    for b in source.bytes() {\n"
"        dest.write_u8(b).await?;\n"
"        tokio::time::sleep(Duration::from_millis(10)).await\n"
"    }\n"
"    Ok(())\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> std::io::Result<()> {\n"
"    let (client, server) = tokio::io::duplex(5);\n"
"    let handle = tokio::spawn(slow_copy(\"hi\\nthere\\n\".to_owned(), "
"client));\n"
"\n"
"    let mut lines = LinesReader::new(server);\n"
"    let mut interval = tokio::time::interval(Duration::from_millis(60));\n"
"    loop {\n"
"        tokio::select! {\n"
"            _ = interval.tick() => println!(\"tick!\"),\n"
"            line = lines.next() => if let Some(l) = line? {\n"
"                print!(\"{}\", l)\n"
"            } else {\n"
"                break\n"
"            },\n"
"        }\n"
"    }\n"
"    handle.await.unwrap()?;\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/cancellation.md:72
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""

#: src/async/pitfalls/cancellation.md:75
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr ""

#: src/async/pitfalls/cancellation.md:78
msgid "The example loses parts of the string."
msgstr ""

#: src/async/pitfalls/cancellation.md:80
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr ""

#: src/async/pitfalls/cancellation.md:82
msgid ""
"`LinesReader` can be made cancellation-safe by makeing `buf` part of the "
"struct:"
msgstr ""

#: src/async/pitfalls/cancellation.md:83
msgid ""
"```rust,compile_fail\n"
"struct LinesReader {\n"
"    stream: DuplexStream,\n"
"    bytes: Vec<u8>,\n"
"    buf: [u8; 1],\n"
"}\n"
"\n"
"impl LinesReader {\n"
"    fn new(stream: DuplexStream) -> Self {\n"
"        Self { stream, bytes: Vec::new(), buf: [0] }\n"
"    }\n"
"    async fn next(&mut self) -> io::Result<Option<String>> {\n"
"        // prefix buf and bytes with self.\n"
"        // ...\n"
"        let raw = std::mem::take(&mut self.bytes);\n"
"        let s = String::from_utf8(raw)\n"
"        // ...\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/async/pitfalls/cancellation.md:104
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""

#: src/async/pitfalls/cancellation.md:107
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""

#: src/async/pitfalls/cancellation.md:110
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""

#: src/exercises/concurrency/afternoon.md:3
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr ""

#: src/exercises/concurrency/afternoon.md:5
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""

#: src/exercises/concurrency/afternoon.md:8
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:1
#: src/exercises/concurrency/solutions-afternoon.md:3
#, fuzzy
msgid "Dining Philosophers - Async"
msgstr "Î”ÎµÎ¯Ï€Î½Î¿ Î¼Îµ Ï†Î¹Î»ÏŒÏƒÎ¿Ï†Î¿Ï…Ï‚"

#: src/exercises/concurrency/dining-philosophers-async.md:3
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:6
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"Î˜Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯Ï„Îµ Î¼Î¹Î± Ï„Î¿Ï€Î¹ÎºÎ® [Î•Î³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Ï†Î¿ÏÏ„Î¯Î¿Ï…](../../cargo/running-locally."
"md) Î³Î¹Î± Î±Ï…Ï„Î® Î· Î¬ÏƒÎºÎ·ÏƒÎ·. Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿ \\`src/main."
"rs, ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î± ÎºÎµÎ½Î¬, ÎºÎ±Î¹ ÎµÎ»Î­Î³Î¾Ï„Îµ ÏŒÏ„Î¹ Ï„Î¿ Â«cargo runÂ» Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î±Î´Î¹Î­Î¾Î¿Î´Î¿:"

#: src/exercises/concurrency/dining-philosophers-async.md:13
msgid ""
"```rust,compile_fail\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
"}\n"
"\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // Create forks\n"
"\n"
"    // Create philosophers\n"
"\n"
"    // Make them think and eat\n"
"\n"
"    // Output their thoughts\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:57
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:62
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:72
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr ""

#: src/exercises/concurrency/dining-philosophers-async.md:77
msgid "Can you make your implementation single-threaded? "
msgstr ""

#: src/exercises/concurrency/chat-app.md:3
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""

#: src/exercises/concurrency/chat-app.md:9
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/0.3.2/tokio_websockets/) for the "
"communication between the client and the server."
msgstr ""

#: src/exercises/concurrency/chat-app.md:13
msgid "Create a new Cargo project and add the following dependencies:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:15
msgid "`Cargo.toml`:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:19
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = \"0.3.28\"\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = \"0.3.2\"\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:32
msgid "The required APIs"
msgstr ""

#: src/exercises/concurrency/chat-app.md:33
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/0.3.2/"
"tokio_websockets/). Spend a few minutes to familiarize yourself with the "
"API. "
msgstr ""

#: src/exercises/concurrency/chat-app.md:37
msgid ""
"[WebsocketStream::next()](https://docs.rs/tokio-websockets/0.3.2/"
"tokio_websockets/proto/struct.WebsocketStream.html#method.next): for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""

#: src/exercises/concurrency/chat-app.md:39
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebsocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""

#: src/exercises/concurrency/chat-app.md:41
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""

#: src/exercises/concurrency/chat-app.md:43
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""

#: src/exercises/concurrency/chat-app.md:46
#, fuzzy
msgid "Two binaries"
msgstr "Rust Binaries"

#: src/exercises/concurrency/chat-app.md:48
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries)). "
msgstr ""

#: src/exercises/concurrency/chat-app.md:55
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below. "
msgstr ""

#: src/exercises/concurrency/chat-app.md:59
#: src/exercises/concurrency/solutions-afternoon.md:123
#, fuzzy
msgid "`src/bin/server.rs`:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/concurrency/chat-app.md:63
msgid ""
"```rust,compile_fail\n"
"use futures_util::sink::SinkExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:102
#: src/exercises/concurrency/solutions-afternoon.md:208
#, fuzzy
msgid "`src/bin/client.rs`:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/concurrency/chat-app.md:106
msgid ""
"```rust,compile_fail\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let mut ws_stream = ClientBuilder::from_uri(Uri::"
"from_static(\"ws://127.0.0.1:2000\"))\n"
"        .connect()\n"
"        .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"\n"
"    // TODO: For a hint, see the description of the task below.\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:127
#, fuzzy
msgid "Running the binaries"
msgstr "Î”Î¹ÎµÎ¾Î±Î³Ï‰Î³Î® Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚"

#: src/exercises/concurrency/chat-app.md:128
msgid "Run the server with:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:130
msgid ""
"```shell\n"
"cargo run --bin server\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:134
msgid "and the client with:"
msgstr ""

#: src/exercises/concurrency/chat-app.md:136
msgid ""
"```shell\n"
"cargo run --bin client\n"
"```"
msgstr ""

#: src/exercises/concurrency/chat-app.md:142
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr ""

#: src/exercises/concurrency/chat-app.md:143
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""

#: src/exercises/concurrency/chat-app.md:146
msgid "Complete the main function in `src/bin/client.rs`."
msgstr ""

#: src/exercises/concurrency/chat-app.md:147
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""

#: src/exercises/concurrency/chat-app.md:151
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr ""

#: src/thanks.md:3
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust ğŸ¦€!_ We hope you enjoyed it and "
"that it was useful."
msgstr ""
"_Î£Î±Ï‚ ÎµÏ…Ï‡Î±ÏÎ¹ÏƒÏ„Î¿ÏÎ¼Îµ Ï€Î¿Ï… Ï€Î®ÏÎ±Ï„Îµ Ï„Î¿ Comprehensive Rust ğŸ¦€!_ Î•Î»Ï€Î¯Î¶Î¿Ï…Î¼Îµ Î½Î± ÏƒÎ±Ï‚ "
"Î¬ÏÎµÏƒÎµ ÎºÎ±Î¹ Î½Î± Î®Ï„Î±Î½ Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿."

#: src/thanks.md:6
#, fuzzy
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"Î”Î¹Î±ÏƒÎºÎµÎ´Î¬ÏƒÎ±Î¼Îµ Ï€Î¿Î»Ï ÏŒÏ„Î±Î½ ÏƒÏ…Î½Î´Ï…Î¬ÏƒÎ±Î¼Îµ Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î±. Î¤Î¿ Î¼Î¬Î¸Î·Î¼Î± Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï„Î­Î»ÎµÎ¹Î¿, "
"Î¿Ï€ÏŒÏ„Îµ Î±Î½ ÎµÎ½Ï„Î¿Ï€Î¯ÏƒÎ±Ï„Îµ Î»Î¬Î¸Î· Î® Î­Ï‡ÎµÏ„Îµ Î¹Î´Î­ÎµÏ‚ Î³Î¹Î± Î²ÎµÎ»Ï„Î¹ÏÏƒÎµÎ¹Ï‚, Ï€Î±ÏÎ±ÎºÎ±Î»Î¿ÏÎ¼Îµ Î¼Ï€ÎµÎ¯Ï„Îµ "
"[ÎµÏ€Î¹ÎºÎ¿Î¹Î½Ï‰Î½Î®ÏƒÏ„Îµ Î¼Î±Î¶Î¯ Î¼Î±Ï‚ ÏƒÏ„Î¿ GitHub](https://github.com/google/comprehensive-"
"rust/discussions). Î˜Î± Î±Î³Î±Ï€Î¿ÏÏƒÎ±Î¼Îµ Î½Î± Î±ÎºÎ¿ÏÏƒÏ‰ Î±Ï€ÏŒ ÏƒÎ­Î½Î±."

#: src/other-resources.md:1
#, fuzzy
msgid "Other Rust Resources"
msgstr "Î†Î»Î»Î¿Î¹ Ï€ÏŒÏÎ¿Î¹ ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚"

#: src/other-resources.md:3
#, fuzzy
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr ""
"Î— ÎºÎ¿Î¹Î½ÏŒÏ„Î·Ï„Î± Ï„Î¿Ï… Rust Î­Ï‡ÎµÎ¹ Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÎµÎ¹ Î­Î½Î±Î½ Ï€Î»Î¿ÏÏ„Î¿ Ï…ÏˆÎ·Î»Î®Ï‚ Ï€Î¿Î¹ÏŒÏ„Î·Ï„Î±Ï‚ ÎºÎ±Î¹ "
"Î´Ï‰ÏÎµÎ¬Î½ Ï€ÏŒÏÏ‰Î½ Î£Îµ ÏƒÏÎ½Î´ÎµÏƒÎ·."

#: src/other-resources.md:6
#, fuzzy
msgid "Official Documentation"
msgstr "Î•Ï€Î¯ÏƒÎ·Î¼Î· Î¤ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ·"

#: src/other-resources.md:8
#, fuzzy
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "Î¤Î¿ Î­ÏÎ³Î¿ Rust Ï†Î¹Î»Î¿Î¾ÎµÎ½ÎµÎ¯ Ï€Î¿Î»Î»Î¿ÏÏ‚ Ï€ÏŒÏÎ¿Ï…Ï‚. Î‘Ï…Ï„Î¬ ÎºÎ±Î»ÏÏ€Ï„Î¿Ï…Î½ Ï„Î¿ Rust Î³ÎµÎ½Î¹ÎºÎ¬:"

#: src/other-resources.md:10
#, fuzzy
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): Ï„Î¿ "
"ÎºÎ±Î½Î¿Î½Î¹ÎºÏŒ Î´Ï‰ÏÎµÎ¬Î½ Î²Î¹Î²Î»Î¯Î¿ Î³Î¹Î± Ï„Î¿ Rust. ÎšÎ±Î»ÏÏ€Ï„ÎµÎ¹ Î±Î½Î±Î»Ï…Ï„Î¹ÎºÎ¬ Ï„Î· Î³Î»ÏÏƒÏƒÎ± ÎºÎ±Î¹ "
"Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î± Î»Î¯Î³Î± Î­ÏÎ³Î± Î³Î¹Î± Î½Î± ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î¬ÏƒÎ¿Ï…Î½ Î¿Î¹ Î¬Î½Î¸ÏÏ‰Ï€Î¿Î¹."

#: src/other-resources.md:13
#, fuzzy
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î· "
"ÏƒÎºÎ¿Ï…ÏÎ¹Î¬ ÏƒÏÎ½Ï„Î±Î¾Î· Î¼Î­ÏƒÏ‰ Î¼Î¹Î±Ï‚ ÏƒÎµÎ¹ÏÎ¬Ï‚ Ï€Î±ÏÎ±Î´ÎµÎ¹Î³Î¼Î¬Ï„Ï‰Î½ Ï€Î¿Ï… Ï€Î±ÏÎ¿Ï…ÏƒÎ¹Î¬Î¶Î¿Ï…Î½ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ "
"ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î­Ï‚. Î©ÏÎµÏ‚ Ï‰ÏÎµÏ‚ Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î¼Î¹ÎºÏÎ­Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ ÏŒÏ€Î¿Ï… ÏƒÎ±Ï‚ Î¶Î·Ï„ÎµÎ¯Ï„Î±Î¹ Î½Î± "
"Î±Î½Î±Ï€Ï„ÏÎ¾ÎµÏ„Îµ Ï„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ Ï€Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î±."

#: src/other-resources.md:17
#, fuzzy
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): Ï€Î»Î®ÏÎ·Ï‚ Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ· "
"Ï„Î¿Ï… Î· Ï„Ï…Ï€Î¹ÎºÎ® Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· Î³Î¹Î± Ï„Î¿ Rust."

#: src/other-resources.md:19
#, fuzzy
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): Î­Î½Î± Î·Î¼Î¹Ï„ÎµÎ»Î­Ï‚ "
"Î²Î¹Î²Î»Î¯Î¿ Ï€Î¿Ï… Ï€ÎµÏÎ¹Î³ÏÎ¬Ï†ÎµÎ¹ Ï„Î¿ Î¼Î¿Î½Ï„Î­Î»Î¿ Ï„Î·Ï‚ Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÎºÎ®Ï‚ ÎºÎ±Î¹ Ï„Î·Ï‚ Î¼Î½Î®Î¼Î·Ï‚ Rust."

#: src/other-resources.md:22
#, fuzzy
msgid "More specialized guides hosted on the official Rust site:"
msgstr ""
"Î ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿Î¹ ÎµÎ¾ÎµÎ¹Î´Î¹ÎºÎµÏ…Î¼Î­Î½Î¿Î¹ Î¿Î´Î·Î³Î¿Î¯ Ï€Î¿Ï… Ï†Î¹Î»Î¿Î¾ÎµÎ½Î¿ÏÎ½Ï„Î±Î¹ ÏƒÏ„Î¿Î½ ÎµÏ€Î¯ÏƒÎ·Î¼Î¿ Î¹ÏƒÏ„ÏŒÏ„Î¿Ï€Î¿ "
"Ï„Î·Ï‚ Rust:"

#: src/other-resources.md:24
#, fuzzy
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î¿ Î¼Î· "
"Î±ÏƒÏ†Î±Î»Î­Ï‚ Rust, ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î±Î½Î¿Î¼Î­Î½Î·Ï‚ Ï„Î·Ï‚ ÎµÏÎ³Î±ÏƒÎ¯Î±Ï‚ Î¼Îµ Î±ÎºÎ±Ï„Î­ÏÎ³Î±ÏƒÏ„Î¿Ï…Ï‚ Î´ÎµÎ¯ÎºÏ„ÎµÏ‚ ÎºÎ±Î¹ "
"Ï„Î·Ï‚ Î´Î¹ÎµÏ€Î±Ï†Î®Ï‚ Î¼Îµ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚ (FFI)."

#: src/other-resources.md:27
#, fuzzy
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î¿ Î½Î­Î¿ Î¼Î¿Î½Ï„Î­Î»Î¿ Î±ÏƒÏÎ³Ï‡ÏÎ¿Î½Î¿Ï… Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼Î¿Ï Ï€Î¿Ï… ÎµÎ¹ÏƒÎ®Ï‡Î¸Î· Î¼ÎµÏ„Î¬ Ï„Î¿ Î¤Î¿ "
"Rust Book Î³ÏÎ¬Ï†Ï„Î·ÎºÎµ."

#: src/other-resources.md:30
#, fuzzy
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"ÎµÎ¹ÏƒÎ±Î³Ï‰Î³Î® ÏƒÏ„Î· Ï‡ÏÎ®ÏƒÎ· Ï„Î¿Ï… Rust ÏƒÎµ ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½ÎµÏ‚ ÏƒÏ…ÏƒÎºÎµÏ…Î­Ï‚ Ï‡Ï‰ÏÎ¯Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ "
"ÏƒÏÏƒÏ„Î·Î¼Î±."

#: src/other-resources.md:33
#, fuzzy
msgid "Unofficial Learning Material"
msgstr "Î‘Î½ÎµÏ€Î¯ÏƒÎ·Î¼Î¿ Î•ÎºÏ€Î±Î¹Î´ÎµÏ…Ï„Î¹ÎºÏŒ Î¥Î»Î¹ÎºÏŒ"

#: src/other-resources.md:35
#, fuzzy
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "ÎœÎ¹Î± Î¼Î¹ÎºÏÎ® ÎµÏ€Î¹Î»Î¿Î³Î® Î¬Î»Î»Ï‰Î½ Î¿Î´Î·Î³ÏÎ½ ÎºÎ±Î¹ Î¿Î´Î·Î³ÏÎ½ Î³Î¹Î± Ï„Î¿ Rust:"

#: src/other-resources.md:37
#, fuzzy
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î¿ "
"Rust Î±Ï€ÏŒ Ï„Î·Î½ Î¿Ï€Ï„Î¹ÎºÎ® Î³Ï‰Î½Î¯Î± Ï„Ï‰Î½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„ÏÎ½ Ï‡Î±Î¼Î·Î»Î¿Ï ÎµÏ€Î¹Ï€Î­Î´Î¿Ï… C."

#: src/other-resources.md:39
#, fuzzy
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[Rust for Embedded C Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î¿ Rust Î±Ï€ÏŒ Î· Ï€ÏÎ¿Î¿Ï€Ï„Î¹ÎºÎ® Ï„Ï‰Î½ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„ÏÎ½ Ï€Î¿Ï… "
"Î³ÏÎ¬Ï†Î¿Ï…Î½ Ï…Î»Î¹ÎºÎ¿Î»Î¿Î³Î¹ÏƒÎ¼Î¹ÎºÏŒ ÏƒÎµ C."

#: src/other-resources.md:42
#, fuzzy
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust Î³Î¹Î± ÎµÏ€Î±Î³Î³ÎµÎ»Î¼Î±Ï„Î¯ÎµÏ‚](https://overexact.com/rust-for-professionals/): "
"ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î· ÏƒÏÎ½Ï„Î±Î¾Î· Ï„Î¿Ï… Rust Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ ÏƒÏ…Î³ÎºÏÎ¯ÏƒÎµÎ¹Ï‚ Î´Î¯Ï€Î»Î±-Î´Î¯Ï€Î»Î± Î¼Îµ Î¬Î»Î»ÎµÏ‚ "
"Î³Î»ÏÏƒÏƒÎµÏ‚ ÏŒÏ€Ï‰Ï‚ C, C++, Java, JavaScript ÎºÎ±Î¹ Python."

#: src/other-resources.md:45
#, fuzzy
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ Î³Î¹Î± "
"Î²Î¿Î®Î¸ÎµÎ¹Î± Î¼Î±Î¸Î±Î¯Î½ÎµÎ¹Ï‚ Rust."

#: src/other-resources.md:47
#, fuzzy
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Î£Î¹Î´Î®ÏÎ¿Ï… Î”Î¹Î´Î±ÏƒÎºÎ±Î»Î¯Î± Î¥Î»Î¹ÎºÏŒ](https://ferrous-systems.github.io/teaching-"
"material/index.html): Î± ÏƒÎµÎ¹ÏÎ¬ Î¼Î¹ÎºÏÏÎ½ Ï€Î±ÏÎ¿Ï…ÏƒÎ¹Î¬ÏƒÎµÏ‰Î½ Ï€Î¿Ï… ÎºÎ±Î»ÏÏ€Ï„Î¿Ï…Î½ Ï„ÏŒÏƒÎ¿ Î²Î±ÏƒÎ¹ÎºÏŒ "
"ÏŒÏƒÎ¿ ÎºÎ±Î¹ Ï€ÏÎ¿Ï‡Ï‰ÏÎ·Î¼Î­Î½Î¿ Î¼Î­ÏÎ¿Ï‚ Ï„Î¿Ï… Î“Î»ÏÏƒÏƒÎ± ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚. Î†Î»Î»Î± Î¸Î­Î¼Î±Ï„Î± ÏŒÏ€Ï‰Ï‚ Ï„Î¿ "
"WebAssembly ÎºÎ±Î¹ Ï„Î¿ async/wait ÎµÎ¯Î½Î±Î¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ ÏƒÎºÎµÏ€Î±ÏƒÏ„ÏŒÏ‚."

#: src/other-resources.md:52
#, fuzzy
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) ÎºÎ±Î¹ [ÎšÎ¬Î½Ï„Îµ Ï„Î± Ï€ÏÏÏ„Î± ÏƒÎ±Ï‚ Î²Î®Î¼Î±Ï„Î± Î¼Îµ Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): Î´ÏÎ¿ ÎŸÎ´Î·Î³Î¿Î¯ Rust Ï€Î¿Ï… "
"Î±Ï€ÎµÏ…Î¸ÏÎ½Î¿Î½Ï„Î±Î¹ ÏƒÎµ Î½Î­Î¿Ï…Ï‚ Ï€ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î­Ï‚. Î¤Î¿ Ï€ÏÏÏ„Î¿ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏƒÏÎ½Î¿Î»Î¿ 35 Î²Î¯Î½Ï„ÎµÎ¿ "
"ÎºÎ±Î¹ Ï„Î¿ Î¤Î¿ Î´ÎµÏÏ„ÎµÏÎ¿ ÎµÎ¯Î½Î±Î¹ Î­Î½Î± ÏƒÏÎ½Î¿Î»Î¿ 11 ÎµÎ½Î¿Ï„Î®Ï„Ï‰Î½ Ï€Î¿Ï… ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î· ÏƒÏÎ½Ï„Î±Î¾Î· Ï„Î¿Ï… "
"Rust ÎºÎ±Î¹ Ï„Î¹Ï‚ Î²Î±ÏƒÎ¹ÎºÎ­Ï‚ Î´Î¿Î¼Î­Ï‚."

#: src/other-resources.md:58
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""

#: src/other-resources.md:63
#, fuzzy
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"Î”ÎµÎ¯Ï„Îµ Ï„Î¿ [Little Book of Rust Books](https://lborb.github.io/book/) Î³Î¹Î± "
"Î±ÎºÏŒÎ¼Î± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± Î²Î¹Î²Î»Î¯Î± Rust."

#: src/credits.md:3
#, fuzzy
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"Î¤Î¿ Ï…Î»Î¹ÎºÏŒ ÎµÎ´Ï Î²Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¹Ï‚ Ï€Î¿Î»Î»Î­Ï‚ ÏƒÏ€Î¿Ï…Î´Î±Î¯ÎµÏ‚ Ï€Î·Î³Î­Ï‚ Ï„ÎµÎºÎ¼Î·ÏÎ¯Ï‰ÏƒÎ·Ï‚ Ï„Î¿Ï… Rust. "
"Î”ÎµÎ¯Ï„Îµ Ï„Î· ÏƒÎµÎ»Î¯Î´Î± ÏƒÏ„Î¿ [other resources](other-resources.md) Î³Î¹Î± Î¼Î¹Î± Ï€Î»Î®ÏÎ· "
"Î»Î¯ÏƒÏ„Î± Ï‡ÏÎ®ÏƒÎ¹Î¼Ï‰Î½ Ï€ÏŒÏÎ¿Î¹."

#: src/credits.md:7
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"Î¤Î¿ Ï…Î»Î¹ÎºÏŒ Ï„Î¿Ï… Comprehensive Rust Î­Ï‡ÎµÎ¹ Î¬Î´ÎµÎ¹Î± Ï‡ÏÎ®ÏƒÎ·Ï‚ ÏƒÏÎ¼Ï†Ï‰Î½Î± Î¼Îµ Ï„Î¿Ï…Ï‚ ÏŒÏÎ¿Ï…Ï‚ Ï„Î¿Ï… "
"Apache 2.0 Î¬Î´ÎµÎ¹Î±, Î±Î½Î±Ï„ÏÎ­Î¾Ï„Îµ ÏƒÏ„Î·Î½ ÎµÎ½ÏŒÏ„Î·Ï„Î± [`Î‘Î”Î•Î™Î‘`](../LICENSE) Î³Î¹Î± "
"Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚."

#: src/credits.md:12
#, fuzzy
msgid "Rust by Example"
msgstr "Î£ÎºÎ¿Ï…ÏÎ¹Î¬ Î±Ï€ÏŒ Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±"

#: src/credits.md:14
#, fuzzy
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"ÎŸÏÎ¹ÏƒÎ¼Î­Î½Î± Ï€Î±ÏÎ±Î´ÎµÎ¯Î³Î¼Î±Ï„Î± ÎºÎ±Î¹ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ Î­Ï‡Î¿Ï…Î½ Î±Î½Ï„Î¹Î³ÏÎ±Ï†ÎµÎ¯ ÎºÎ±Î¹ Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÏ„ÎµÎ¯ Î±Ï€ÏŒ Ï„Î¿ "
"[Rust by Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±](https://doc.rust-lang.org/rust-by-example/). Î Î±ÏÎ±ÎºÎ±Î»Ï "
"Î´ÎµÎ¯Ï„Îµ Ï„Î¿ ÎšÎ±Ï„Î¬Î»Î¿Î³Î¿Ï‚ `third_party/rust-by-example/` Î³Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚, "
"ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î±Î½Î¿Î¼Î­Î½Î·Ï‚ Ï„Î·Ï‚ Î¬Î´ÎµÎ¹Î±Ï‚ Ï‡ÏÎ®ÏƒÎ·Ï‚ ÏŒÏÎ¿Î¹."

#: src/credits.md:19
#, fuzzy
msgid "Rust on Exercism"
msgstr "Î£ÎºÎ¿Ï…ÏÎ¹Î¬ ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·"

#: src/credits.md:21
#, fuzzy
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"ÎŸÏÎ¹ÏƒÎ¼Î­Î½ÎµÏ‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ Î­Ï‡Î¿Ï…Î½ Î±Î½Ï„Î¹Î³ÏÎ±Ï†ÎµÎ¯ ÎºÎ±Î¹ Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÏ„ÎµÎ¯ Î±Ï€ÏŒ Ï„Î¿ [Rust on Î†ÏƒÎºÎ·ÏƒÎ·]"
"(https://exercism.org/tracks/rust). Î Î±ÏÎ±ÎºÎ±Î»Ï Î´ÎµÎ¯Ï„Îµ Ï„Î¿ ÎšÎ±Ï„Î¬Î»Î¿Î³Î¿Ï‚ `third_party/"
"rust-on-exercism/` Î³Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚, ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î±Î½Î¿Î¼Î­Î½Î·Ï‚ Ï„Î·Ï‚ Î¬Î´ÎµÎ¹Î±Ï‚ ÏŒÏÎ¿Î¹."

#: src/credits.md:26
#, fuzzy
msgid "CXX"
msgstr "CXX"

#: src/credits.md:28
#, fuzzy
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"Î— ÎµÎ½ÏŒÏ„Î·Ï„Î± [Î”Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± Î¼Îµ C++](android/interoperability/cpp.md) "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Î­Î½Î± ÎµÎ¹ÎºÏŒÎ½Î± Î±Ï€ÏŒ [CXX](https://cxx.rs/). Î”ÎµÎ¯Ï„Îµ Ï„Î¿Î½ ÎºÎ±Ï„Î¬Î»Î¿Î³Î¿ "
"`third_party/cxx/` Î³Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚, ÏƒÏ…Î¼Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î±Î½Î¿Î¼Î­Î½Ï‰Î½ Ï„Ï‰Î½ ÏŒÏÏ‰Î½ Î¬Î´ÎµÎ¹Î±Ï‚."

#: src/exercises/solutions.md:3
#, fuzzy
msgid "You will find solutions to the exercises on the following pages."
msgstr "Î˜Î± Î²ÏÎµÎ¯Ï„Îµ Î»ÏÏƒÎµÎ¹Ï‚ ÏƒÏ„Î¹Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ ÏƒÏ„Î¹Ï‚ ÎµÏ€ÏŒÎ¼ÎµÎ½ÎµÏ‚ ÏƒÎµÎ»Î¯Î´ÎµÏ‚."

#: src/exercises/solutions.md:5
#, fuzzy
msgid ""
"Feel free to ask questions about the solutions [on GitHub](https://github."
"com/google/comprehensive-rust/discussions). Let us know if you have a "
"different or better solution than what is presented here."
msgstr ""
"ÎœÎ· Î´Î¹ÏƒÏ„Î¬ÏƒÎµÏ„Îµ Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ ÎµÏÏ‰Ï„Î®ÏƒÎµÎ¹Ï‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ¬ Î¼Îµ Ï„Î¹Ï‚ Î»ÏÏƒÎµÎ¹Ï‚ [on GitHub](https://"
"github.com/google/comprehensive-rust/discussions). Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ­ Î¼Î±Ï‚ ÎµÎ¬Î½ Î­Ï‡ÎµÏ„Îµ "
"Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ® Î® ÎºÎ±Î»ÏÏ„ÎµÏÎ· Î»ÏÏƒÎ· Î±Ï€ÏŒ Î±Ï…Ï„Î® Ï€Î¿Ï… Ï€Î±ÏÎ¿Ï…ÏƒÎ¹Î¬Î¶ÎµÏ„Î±Î¹ ÎµÎ´Ï."

#: src/exercises/solutions.md:10
#, fuzzy
msgid ""
"**Note:** Please ignore the `// ANCHOR: label` and `// ANCHOR_END: label` "
"comments you see in the solutions. They are there to make it possible to re-"
"use parts of the solutions as the exercises."
msgstr ""
"**Î£Î·Î¼ÎµÎ¯Ï‰ÏƒÎ·:** Î‘Î³Î½Î¿Î®ÏƒÏ„Îµ Ï„Î± \"// ANCHOR: label\" ÎºÎ±Î¹ \"// ANCHOR_END: label\" "
"ÏƒÏ‡ÏŒÎ»Î¹Î± Ï€Î¿Ï… Î²Î»Î­Ï€ÎµÏ„Îµ ÏƒÏ„Î¹Ï‚ Î»ÏÏƒÎµÎ¹Ï‚. Î•Î¯Î½Î±Î¹ ÎµÎºÎµÎ¯ Î³Î¹Î± Î½Î± Ï„Î¿ ÎºÎ¬Î½Î¿Ï…Î½ Î´Ï…Î½Î±Ï„ÏŒ "
"ÎµÏ€Î±Î½Î±Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Î¼Î­ÏÎ· Ï„Ï‰Î½ Î»ÏÏƒÎµÏ‰Î½ Ï‰Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚."

#: src/exercises/day-1/solutions-morning.md:1
#, fuzzy
msgid "Day 1 Morning Exercises"
msgstr "Î ÏÏ‰Î¹Î½Î­Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚ 1Î·Ï‚ Î·Î¼Î­ÏÎ±Ï‚"

#: src/exercises/day-1/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](for-loops.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](for-loops.md))"

#: src/exercises/day-1/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: transpose\n"
"fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
"    // ANCHOR_END: transpose\n"
"    let mut result = [[0; 3]; 3];\n"
"    for i in 0..3 {\n"
"        for j in 0..3 {\n"
"            result[j][i] = matrix[i][j];\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ANCHOR: pretty_print\n"
"fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
"    // ANCHOR_END: pretty_print\n"
"    for row in matrix {\n"
"        println!(\"{row:?}\");\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: tests\n"
"#[test]\n"
"fn test_transpose() {\n"
"    let matrix = [\n"
"        [101, 102, 103], //\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"    let transposed = transpose(matrix);\n"
"    assert_eq!(\n"
"        transposed,\n"
"        [\n"
"            [101, 201, 301], //\n"
"            [102, 202, 302],\n"
"            [103, 203, 303],\n"
"        ]\n"
"    );\n"
"}\n"
"// ANCHOR_END: tests\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let matrix = [\n"
"        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
"        [201, 202, 203],\n"
"        [301, 302, 303],\n"
"    ];\n"
"\n"
"    println!(\"matrix:\");\n"
"    pretty_print(&matrix);\n"
"\n"
"    let transposed = transpose(matrix);\n"
"    println!(\"transposed:\");\n"
"    pretty_print(&transposed);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:78
#, fuzzy
msgid "Bonus question"
msgstr "Î•ÏÏÏ„Î·ÏƒÎ· Î¼Ï€ÏŒÎ½Î¿Ï…Ï‚"

#: src/exercises/day-1/solutions-morning.md:80
#, fuzzy
msgid ""
"It requires more advanced concepts. It might seem that we could use a slice-"
"of-slices (`&[&[i32]]`) as the input type to transpose and thus make our "
"function handle any size of matrix. However, this quickly breaks down: the "
"return type cannot be `&[&[i32]]` since it needs to own the data you return."
msgstr ""
"Î•Î¹Î»Î¹ÎºÏÎ¹Î½Î¬ Î´ÎµÎ½ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Ï„ÏŒÏƒÎ¿ ÎºÎ±Î»Î¬. ÎœÏ€Î¿ÏÎµÎ¯ Î½Î± Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ ÏŒÏ„Î¹ Î¸Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎ±Î¼Îµ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Î­Î½Î± slice-of-slices (`&[&[i32]]`) Ï‰Ï‚ Ï„ÏÏ€Î¿ ÎµÎ¹ÏƒÏŒÎ´Î¿Ï… Î³Î¹Î± Î½Î± "
"Î¼ÎµÏ„Î±Ï†Î­ÏÎ¿Ï…Î¼Îµ ÎºÎ±Î¹ Î­Ï„ÏƒÎ¹ Î½Î± ÎºÎ¬Î½Î¿Ï…Î¼Îµ Ï„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ® Î¼Î±Ï‚ Î½Î± Ï‡ÎµÎ¹ÏÎ¯Î¶ÎµÏ„Î±Î¹ Î¿Ï€Î¿Î¹Î¿Î´Î®Ï€Î¿Ï„Îµ "
"Î¼Î­Î³ÎµÎ¸Î¿Ï‚ Ï€Î¯Î½Î±ÎºÎ±. Î©ÏƒÏ„ÏŒÏƒÎ¿, Î±Ï…Ï„ÏŒ Î±Î½Î±Î»ÏÎµÏ„Î±Î¹ Î³ÏÎ®Î³Î¿ÏÎ±: Î¿ Ï„ÏÏ€Î¿Ï‚ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î®Ï‚ Î´ÎµÎ½ "
"Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ \"&\\[&\\[i32\\]\\]\", ÎºÎ±Î¸ÏÏ‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ ÎºÎ¬Ï„Î¿Ï‡Î¿Ï‚ Ï„Ï‰Î½ "
"Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ Ï€Î¿Ï… ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÏ„Îµ."

#: src/exercises/day-1/solutions-morning.md:82
#, fuzzy
msgid ""
"You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't work "
"out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
"`&[&[i32]]` so now you cannot easily use `pretty_print` either."
msgstr ""
"ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± ÎµÏ€Î¹Ï‡ÎµÎ¹ÏÎ®ÏƒÎµÏ„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ ÎºÎ¬Ï„Î¹ ÏƒÎ±Î½ `Vec<Vec<i32>>`, Î±Î»Î»Î¬ "
"Î¿ÏÏ„Îµ Î±Ï…Ï„ÏŒ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Ï€Î¿Î»Ï ÎºÎ±Î»Î¬: ÎµÎ¯Î½Î±Î¹ Î´ÏÏƒÎºÎ¿Î»Î¿ Î½Î± Î¼ÎµÏ„Î±Ï„ÏÎ­ÏˆÎµÏ„Îµ Î±Ï€ÏŒ "
"`Vec<Vec<i32>>` ÏƒÎµ \\`&\\[&\\[i32\\]\\] ÎˆÏ„ÏƒÎ¹ Ï„ÏÏÎ± Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
"Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ ÎµÏÎºÎ¿Î»Î± Î¿ÏÏ„Îµ Ï„Î¿ \"pretty_print\"."

#: src/exercises/day-1/solutions-morning.md:84
msgid ""
"Once we get to traits and generics, we'll be able to use the [`std::convert::"
"AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) trait to "
"abstract over anything that can be referenced as a slice."
msgstr ""

#: src/exercises/day-1/solutions-morning.md:86
msgid ""
"```rust\n"
"use std::convert::AsRef;\n"
"use std::fmt::Debug;\n"
"\n"
"fn pretty_print<T, Line, Matrix>(matrix: Matrix)\n"
"where\n"
"    T: Debug,\n"
"    // A line references a slice of items\n"
"    Line: AsRef<[T]>,\n"
"    // A matrix references a slice of lines\n"
"    Matrix: AsRef<[Line]>\n"
"{\n"
"    for row in matrix.as_ref() {\n"
"        println!(\"{:?}\", row.as_ref());\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // &[&[i32]]\n"
"    pretty_print(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);\n"
"    // [[&str; 2]; 2]\n"
"    pretty_print([[\"a\", \"b\"], [\"c\", \"d\"]]);\n"
"    // Vec<Vec<i32>>\n"
"    pretty_print(vec![vec![1, 2], vec![3, 4]]);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-morning.md:113
#, fuzzy
msgid ""
"In addition, the type itself would not enforce that the child slices are of "
"the same length, so such variable could contain an invalid matrix."
msgstr ""
"Î•Ï€Î¹Ï€Î»Î­Î¿Î½, Î¿ Î¯Î´Î¹Î¿Ï‚ Î¿ Ï„ÏÏ€Î¿Ï‚ Î´ÎµÎ½ Î¸Î± ÎµÏ€Î¹Î²Î¬Î»Î»ÎµÎ¹ ÏŒÏ„Î¹ Î¿Î¹ Î¸Ï…Î³Î±Ï„ÏÎ¹ÎºÎ­Ï‚ Ï†Î­Ï„ÎµÏ‚ Î­Ï‡Î¿Ï…Î½ Ï„Î¿ "
"Î¯Î´Î¹Î¿ Î¼Î®ÎºÎ¿Ï‚, ÎµÏ€Î¿Î¼Î­Î½Ï‰Ï‚ Î¼Î¹Î± Ï„Î­Ï„Î¿Î¹Î± Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® Î¸Î± Î¼Ï€Î¿ÏÎ¿ÏÏƒÎµ Î½Î± Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î­Î½Î±Î½ Î¼Î· "
"Î­Î³ÎºÏ…ÏÎ¿ Ï€Î¯Î½Î±ÎºÎ±."

#: src/exercises/day-1/solutions-afternoon.md:1
#, fuzzy
msgid "Day 1 Afternoon Exercises"
msgstr "1Î· Î·Î¼Î­ÏÎ± Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-1/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](luhn.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](luhn.md))"

#: src/exercises/day-1/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: luhn\n"
"pub fn luhn(cc_number: &str) -> bool {\n"
"    // ANCHOR_END: luhn\n"
"    let mut digits_seen = 0;\n"
"    let mut sum = 0;\n"
"    for (i, ch) in cc_number.chars().rev().filter(|&ch| ch != ' ')."
"enumerate() {\n"
"        match ch.to_digit(10) {\n"
"            Some(d) => {\n"
"                sum += if i % 2 == 1 {\n"
"                    let dd = d * 2;\n"
"                    dd / 10 + dd % 10\n"
"                } else {\n"
"                    d\n"
"                };\n"
"                digits_seen += 1;\n"
"            }\n"
"            None => return false,\n"
"        }\n"
"    }\n"
"\n"
"    if digits_seen < 2 {\n"
"        return false;\n"
"    }\n"
"\n"
"    sum % 10 == 0\n"
"}\n"
"\n"
"fn main() {\n"
"    let cc_number = \"1234 5678 1234 5670\";\n"
"    println!(\n"
"        \"Is {cc_number} a valid credit card number? {}\",\n"
"        if luhn(cc_number) { \"yes\" } else { \"no\" }\n"
"    );\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_non_digit_cc_number() {\n"
"    assert!(!luhn(\"foo\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_empty_cc_number() {\n"
"    assert!(!luhn(\"\"));\n"
"    assert!(!luhn(\" \"));\n"
"    assert!(!luhn(\"  \"));\n"
"    assert!(!luhn(\"    \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_single_digit_cc_number() {\n"
"    assert!(!luhn(\"0\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_two_digit_cc_number() {\n"
"    assert!(luhn(\" 0 0 \"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_valid_cc_number() {\n"
"    assert!(luhn(\"4263 9826 4026 9299\"));\n"
"    assert!(luhn(\"4539 3195 0343 6467\"));\n"
"    assert!(luhn(\"7992 7398 713\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_invalid_cc_number() {\n"
"    assert!(!luhn(\"4223 9826 4026 9299\"));\n"
"    assert!(!luhn(\"4539 3195 0343 6476\"));\n"
"    assert!(!luhn(\"8273 1232 7352 0569\"));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"```"
msgstr ""

#: src/exercises/day-1/solutions-afternoon.md:97
#, fuzzy
msgid "Pattern matching"
msgstr "Î‘Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· Ï€ÏÎ¿Ï„ÏÏ€Ï‰Î½"

#: src/exercises/day-1/solutions-afternoon.md:99
msgid "TBD."
msgstr ""

#: src/exercises/day-2/solutions-morning.md:1
#, fuzzy
msgid "Day 2 Morning Exercises"
msgstr "2Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¹Î½Î­Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-2/solutions-morning.md:3
msgid "Designing a Library"
msgstr "Î£Ï‡ÎµÎ´Î¹Î±ÏƒÎ¼ÏŒÏ‚ Î’Î¹Î²Î»Î¹Î¿Î¸Î·ÎºÏÎ½"

#: src/exercises/day-2/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](book-library.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](book-library.md))"

#: src/exercises/day-2/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"struct Library {\n"
"    books: Vec<Book>,\n"
"}\n"
"\n"
"struct Book {\n"
"    title: String,\n"
"    year: u16,\n"
"}\n"
"\n"
"impl Book {\n"
"    // This is a constructor, used below.\n"
"    fn new(title: &str, year: u16) -> Book {\n"
"        Book {\n"
"            title: String::from(title),\n"
"            year,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Implement the methods below. Update the `self` parameter to\n"
"// indicate the method's required level of ownership over the object:\n"
"//\n"
"// - `&self` for shared read-only access,\n"
"// - `&mut self` for unique and mutable access,\n"
"// - `self` for unique access by value.\n"
"impl Library {\n"
"    // ANCHOR_END: setup\n"
"\n"
"    // ANCHOR: Library_new\n"
"    fn new() -> Library {\n"
"        // ANCHOR_END: Library_new\n"
"        Library { books: Vec::new() }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_len\n"
"    //fn len(self) -> usize {\n"
"    //    todo!(\"Return the length of `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_len\n"
"    fn len(&self) -> usize {\n"
"        self.books.len()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_is_empty\n"
"    //fn is_empty(self) -> bool {\n"
"    //    todo!(\"Return `true` if `self.books` is empty\")\n"
"    //}\n"
"    // ANCHOR_END: Library_is_empty\n"
"    fn is_empty(&self) -> bool {\n"
"        self.books.is_empty()\n"
"    }\n"
"\n"
"    // ANCHOR: Library_add_book\n"
"    //fn add_book(self, book: Book) {\n"
"    //    todo!(\"Add a new book to `self.books`\")\n"
"    //}\n"
"    // ANCHOR_END: Library_add_book\n"
"    fn add_book(&mut self, book: Book) {\n"
"        self.books.push(book)\n"
"    }\n"
"\n"
"    // ANCHOR: Library_print_books\n"
"    //fn print_books(self) {\n"
"    //    todo!(\"Iterate over `self.books` and each book's title and "
"year\")\n"
"    //}\n"
"    // ANCHOR_END: Library_print_books\n"
"    fn print_books(&self) {\n"
"        for book in &self.books {\n"
"            println!(\"{}, published in {}\", book.title, book.year);\n"
"        }\n"
"    }\n"
"\n"
"    // ANCHOR: Library_oldest_book\n"
"    //fn oldest_book(self) -> Option<&Book> {\n"
"    //    todo!(\"Return a reference to the oldest book (if any)\")\n"
"    //}\n"
"    // ANCHOR_END: Library_oldest_book\n"
"    fn oldest_book(&self) -> Option<&Book> {\n"
"        // Using a closure and a built-in method:\n"
"        // self.books.iter().min_by_key(|book| book.year)\n"
"\n"
"        // Longer hand-written solution:\n"
"        let mut oldest: Option<&Book> = None;\n"
"        for book in self.books.iter() {\n"
"            if oldest.is_none() || book.year < oldest.unwrap().year {\n"
"                oldest = Some(book);\n"
"            }\n"
"        }\n"
"\n"
"        oldest\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"// This shows the desired behavior. Uncomment the code below and\n"
"// implement the missing methods. You will need to update the\n"
"// method signatures, including the \"self\" parameter! You may\n"
"// also need to update the variable bindings within main.\n"
"fn main() {\n"
"    let library = Library::new();\n"
"\n"
"    //println!(\"The library is empty: library.is_empty() -> {}\", library."
"is_empty());\n"
"    //\n"
"    //library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    //library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    //\n"
"    //println!(\"The library is no longer empty: library.is_empty() -> {}\", "
"library.is_empty());\n"
"    //\n"
"    //\n"
"    //library.print_books();\n"
"    //\n"
"    //match library.oldest_book() {\n"
"    //    Some(book) => println!(\"The oldest book is {}\", book.title),\n"
"    //    None => println!(\"The library is empty!\"),\n"
"    //}\n"
"    //\n"
"    //println!(\"The library has {} books\", library.len());\n"
"    //library.print_books();\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[test]\n"
"fn test_library_len() {\n"
"    let mut library = Library::new();\n"
"    assert_eq!(library.len(), 0);\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(library.len(), 2);\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_is_empty() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.is_empty());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert!(!library.is_empty());\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_print_books() {\n"
"    let mut library = Library::new();\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    // We could try and capture stdout, but let us just call the\n"
"    // method to start with.\n"
"    library.print_books();\n"
"}\n"
"\n"
"#[test]\n"
"fn test_library_oldest_book() {\n"
"    let mut library = Library::new();\n"
"    assert!(library.oldest_book().is_none());\n"
"\n"
"    library.add_book(Book::new(\"Lord of the Rings\", 1954));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Lord of the Rings\")\n"
"    );\n"
"\n"
"    library.add_book(Book::new(\"Alice's Adventures in Wonderland\", "
"1865));\n"
"    assert_eq!(\n"
"        library.oldest_book().map(|b| b.title.as_str()),\n"
"        Some(\"Alice's Adventures in Wonderland\")\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/exercises/day-2/solutions-afternoon.md:1
#, fuzzy
msgid "Day 2 Afternoon Exercises"
msgstr "2Î· Î¼Î­ÏÎ± Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-2/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](strings-iterators.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](strings-iterators.md))"

#: src/exercises/day-2/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: prefix_matches\n"
"pub fn prefix_matches(prefix: &str, request_path: &str) -> bool {\n"
"    // ANCHOR_END: prefix_matches\n"
"\n"
"    let mut request_segments = request_path.split('/');\n"
"\n"
"    for prefix_segment in prefix.split('/') {\n"
"        let Some(request_segment) = request_segments.next() else {\n"
"            return false;\n"
"        };\n"
"        if request_segment != prefix_segment && prefix_segment != \"*\" {\n"
"            return false;\n"
"        }\n"
"    }\n"
"    true\n"
"\n"
"    // Alternatively, Iterator::zip() lets us iterate simultaneously over "
"prefix\n"
"    // and request segments. The zip() iterator is finished as soon as one "
"of\n"
"    // the source iterators is finished, but we need to iterate over all "
"request\n"
"    // segments. A neat trick that makes zip() work is to use map() and "
"chain()\n"
"    // to produce an iterator that returns Some(str) for each pattern "
"segments,\n"
"    // and then returns None indefinitely.\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[test]\n"
"fn test_matches_without_wildcard() {\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/"
"abc-123\"));\n"
"    assert!(prefix_matches(\"/v1/publishers\", \"/v1/publishers/abc/"
"books\"));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/publishersBooks\"));\n"
"    assert!(!prefix_matches(\"/v1/publishers\", \"/v1/parent/"
"publishers\"));\n"
"}\n"
"\n"
"#[test]\n"
"fn test_matches_with_wildcard() {\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/bar/books\"\n"
"    ));\n"
"    assert!(prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/books/book1\"\n"
"    ));\n"
"\n"
"    assert!(!prefix_matches(\"/v1/publishers/*/books\", \"/v1/"
"publishers\"));\n"
"    assert!(!prefix_matches(\n"
"        \"/v1/publishers/*/books\",\n"
"        \"/v1/publishers/foo/booksByAuthor\"\n"
"    ));\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:1
#, fuzzy
msgid "Day 3 Morning Exercise"
msgstr "3Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¹Î½Î® Î¬ÏƒÎºÎ·ÏƒÎ·"

#: src/exercises/day-3/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](simple-gui.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](simple-gui.md))"

#: src/exercises/day-3/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"pub trait Widget {\n"
"    /// Natural width of `self`.\n"
"    fn width(&self) -> usize;\n"
"\n"
"    /// Draw the widget into a buffer.\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);\n"
"\n"
"    /// Draw the widget on standard output.\n"
"    fn draw(&self) {\n"
"        let mut buffer = String::new();\n"
"        self.draw_into(&mut buffer);\n"
"        println!(\"{buffer}\");\n"
"    }\n"
"}\n"
"\n"
"pub struct Label {\n"
"    label: String,\n"
"}\n"
"\n"
"impl Label {\n"
"    fn new(label: &str) -> Label {\n"
"        Label {\n"
"            label: label.to_owned(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Button {\n"
"    label: Label,\n"
"    callback: Box<dyn FnMut()>,\n"
"}\n"
"\n"
"impl Button {\n"
"    fn new(label: &str, callback: Box<dyn FnMut()>) -> Button {\n"
"        Button {\n"
"            label: Label::new(label),\n"
"            callback,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub struct Window {\n"
"    title: String,\n"
"    widgets: Vec<Box<dyn Widget>>,\n"
"}\n"
"\n"
"impl Window {\n"
"    fn new(title: &str) -> Window {\n"
"        Window {\n"
"            title: title.to_owned(),\n"
"            widgets: Vec::new(),\n"
"        }\n"
"    }\n"
"\n"
"    fn add_widget(&mut self, widget: Box<dyn Widget>) {\n"
"        self.widgets.push(widget);\n"
"    }\n"
"\n"
"    fn inner_width(&self) -> usize {\n"
"        std::cmp::max(\n"
"            self.title.chars().count(),\n"
"            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),\n"
"        )\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: Window-width\n"
"impl Widget for Window {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
"        self.inner_width() + 4\n"
"    }\n"
"\n"
"    // ANCHOR: Window-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Window-draw_into\n"
"        let mut inner = String::new();\n"
"        for widget in &self.widgets {\n"
"            widget.draw_into(&mut inner);\n"
"        }\n"
"\n"
"        let inner_width = self.inner_width();\n"
"\n"
"        // TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"        writeln!(buffer, \"| {:^inner_width$} |\", &self.title).unwrap();\n"
"        writeln!(buffer, \"+={:=<inner_width$}=+\", \"\").unwrap();\n"
"        for line in inner.lines() {\n"
"            writeln!(buffer, \"| {:inner_width$} |\", line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+-{:-<inner_width$}-+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Button-width\n"
"impl Widget for Button {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Button-width\n"
"        self.label.width() + 8 // add a bit of padding\n"
"    }\n"
"\n"
"    // ANCHOR: Button-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Button-draw_into\n"
"        let width = self.width();\n"
"        let mut label = String::new();\n"
"        self.label.draw_into(&mut label);\n"
"\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"        for line in label.lines() {\n"
"            writeln!(buffer, \"|{:^width$}|\", &line).unwrap();\n"
"        }\n"
"        writeln!(buffer, \"+{:-<width$}+\", \"\").unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Label-width\n"
"impl Widget for Label {\n"
"    fn width(&self) -> usize {\n"
"        // ANCHOR_END: Label-width\n"
"        self.label\n"
"            .lines()\n"
"            .map(|line| line.chars().count())\n"
"            .max()\n"
"            .unwrap_or(0)\n"
"    }\n"
"\n"
"    // ANCHOR: Label-draw_into\n"
"    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {\n"
"        // ANCHOR_END: Label-draw_into\n"
"        writeln!(buffer, \"{}\", &self.label).unwrap();\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() {\n"
"    let mut window = Window::new(\"Rust GUI Demo 1.23\");\n"
"    window.add_widget(Box::new(Label::new(\"This is a small text GUI demo."
"\")));\n"
"    window.add_widget(Box::new(Button::new(\n"
"        \"Click me!\",\n"
"        Box::new(|| println!(\"You clicked the button!\")),\n"
"    )));\n"
"    window.draw();\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-morning.md:177
#, fuzzy
msgid "([back to exercise](points-polygons.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](points-polygons.md))"

#: src/exercises/day-3/solutions-morning.md:179
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n"
"// ANCHOR: Point\n"
"pub struct Point {\n"
"    // ANCHOR_END: Point\n"
"    x: i32,\n"
"    y: i32,\n"
"}\n"
"\n"
"// ANCHOR: Point-impl\n"
"impl Point {\n"
"    // ANCHOR_END: Point-impl\n"
"    pub fn new(x: i32, y: i32) -> Point {\n"
"        Point { x, y }\n"
"    }\n"
"\n"
"    pub fn magnitude(self) -> f64 {\n"
"        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()\n"
"    }\n"
"\n"
"    pub fn dist(self, other: Point) -> f64 {\n"
"        (self - other).magnitude()\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Add for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn add(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x + other.x,\n"
"            y: self.y + other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl std::ops::Sub for Point {\n"
"    type Output = Self;\n"
"\n"
"    fn sub(self, other: Self) -> Self::Output {\n"
"        Self {\n"
"            x: self.x - other.x,\n"
"            y: self.y - other.y,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Polygon\n"
"pub struct Polygon {\n"
"    // ANCHOR_END: Polygon\n"
"    points: Vec<Point>,\n"
"}\n"
"\n"
"// ANCHOR: Polygon-impl\n"
"impl Polygon {\n"
"    // ANCHOR_END: Polygon-impl\n"
"    pub fn new() -> Polygon {\n"
"        Polygon { points: Vec::new() }\n"
"    }\n"
"\n"
"    pub fn add_point(&mut self, point: Point) {\n"
"        self.points.push(point);\n"
"    }\n"
"\n"
"    pub fn left_most_point(&self) -> Option<Point> {\n"
"        self.points.iter().min_by_key(|p| p.x).copied()\n"
"    }\n"
"\n"
"    pub fn iter(&self) -> impl Iterator<Item = &Point> {\n"
"        self.points.iter()\n"
"    }\n"
"\n"
"    pub fn length(&self) -> f64 {\n"
"        if self.points.is_empty() {\n"
"            return 0.0;\n"
"        }\n"
"\n"
"        let mut result = 0.0;\n"
"        let mut last_point = self.points[0];\n"
"        for point in &self.points[1..] {\n"
"            result += last_point.dist(*point);\n"
"            last_point = *point;\n"
"        }\n"
"        result += last_point.dist(self.points[0]);\n"
"        result\n"
"        // Alternatively, Iterator::zip() lets us iterate over the points as "
"pairs\n"
"        // but we need to pair each point with the next one, and the last "
"point\n"
"        // with the first point. The zip() iterator is finished as soon as "
"one of \n"
"        // the source iterators is finished, a neat trick is to combine "
"Iterator::cycle\n"
"        // with Iterator::skip to create the second iterator for the zip and "
"using map \n"
"        // and sum to calculate the total length.\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Circle\n"
"pub struct Circle {\n"
"    // ANCHOR_END: Circle\n"
"    center: Point,\n"
"    radius: i32,\n"
"}\n"
"\n"
"// ANCHOR: Circle-impl\n"
"impl Circle {\n"
"    // ANCHOR_END: Circle-impl\n"
"    pub fn new(center: Point, radius: i32) -> Circle {\n"
"        Circle { center, radius }\n"
"    }\n"
"\n"
"    pub fn circumference(&self) -> f64 {\n"
"        2.0 * std::f64::consts::PI * f64::from(self.radius)\n"
"    }\n"
"\n"
"    pub fn dist(&self, other: &Self) -> f64 {\n"
"        self.center.dist(other.center)\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Shape\n"
"pub enum Shape {\n"
"    Polygon(Polygon),\n"
"    Circle(Circle),\n"
"}\n"
"// ANCHOR_END: Shape\n"
"\n"
"impl From<Polygon> for Shape {\n"
"    fn from(poly: Polygon) -> Self {\n"
"        Shape::Polygon(poly)\n"
"    }\n"
"}\n"
"\n"
"impl From<Circle> for Shape {\n"
"    fn from(circle: Circle) -> Self {\n"
"        Shape::Circle(circle)\n"
"    }\n"
"}\n"
"\n"
"impl Shape {\n"
"    pub fn perimeter(&self) -> f64 {\n"
"        match self {\n"
"            Shape::Polygon(poly) => poly.length(),\n"
"            Shape::Circle(circle) => circle.circumference(),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: unit-tests\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"\n"
"    fn round_two_digits(x: f64) -> f64 {\n"
"        (x * 100.0).round() / 100.0\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_magnitude() {\n"
"        let p1 = Point::new(12, 13);\n"
"        assert_eq!(round_two_digits(p1.magnitude()), 17.69);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_dist() {\n"
"        let p1 = Point::new(10, 10);\n"
"        let p2 = Point::new(14, 13);\n"
"        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_point_add() {\n"
"        let p1 = Point::new(16, 16);\n"
"        let p2 = p1 + Point::new(-4, 3);\n"
"        assert_eq!(p2, Point::new(12, 19));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_left_most_point() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"        assert_eq!(poly.left_most_point(), Some(p1));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_polygon_iter() {\n"
"        let p1 = Point::new(12, 13);\n"
"        let p2 = Point::new(16, 16);\n"
"\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(p1);\n"
"        poly.add_point(p2);\n"
"\n"
"        let points = poly.iter().cloned().collect::<Vec<_>>();\n"
"        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_shape_perimeters() {\n"
"        let mut poly = Polygon::new();\n"
"        poly.add_point(Point::new(12, 13));\n"
"        poly.add_point(Point::new(17, 11));\n"
"        poly.add_point(Point::new(16, 16));\n"
"        let shapes = vec![\n"
"            Shape::from(poly),\n"
"            Shape::from(Circle::new(Point::new(10, 20), 5)),\n"
"        ];\n"
"        let perimeters = shapes\n"
"            .iter()\n"
"            .map(Shape::perimeter)\n"
"            .map(round_two_digits)\n"
"            .collect::<Vec<_>>();\n"
"        assert_eq!(perimeters, vec![15.48, 31.42]);\n"
"    }\n"
"}\n"
"// ANCHOR_END: unit-tests\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/exercises/day-3/solutions-afternoon.md:1
#, fuzzy
msgid "Day 3 Afternoon Exercises"
msgstr "3Î· Î·Î¼Î­ÏÎ± Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/day-3/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](safe-ffi-wrapper.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](safe-ffi-wrapper.md))"

#: src/exercises/day-3/solutions-afternoon.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: ffi\n"
"mod ffi {\n"
"    use std::os::raw::{c_char, c_int};\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};\n"
"\n"
"    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
"    #[repr(C)]\n"
"    pub struct DIR {\n"
"        _data: [u8; 0],\n"
"        _marker: core::marker::PhantomData<(*mut u8, core::marker::"
"PhantomPinned)>,\n"
"    }\n"
"\n"
"    // Layout according to the Linux man page for readdir(3), where ino_t "
"and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
"    #[cfg(not(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_ino: c_ulong,\n"
"        pub d_off: c_long,\n"
"        pub d_reclen: c_ushort,\n"
"        pub d_type: c_uchar,\n"
"        pub d_name: [c_char; 256],\n"
"    }\n"
"\n"
"    // Layout according to the macOS man page for dir(5).\n"
"    #[cfg(all(target_os = \"macos\"))]\n"
"    #[repr(C)]\n"
"    pub struct dirent {\n"
"        pub d_fileno: u64,\n"
"        pub d_seekoff: u64,\n"
"        pub d_reclen: u16,\n"
"        pub d_namlen: u16,\n"
"        pub d_type: u8,\n"
"        pub d_name: [c_char; 1024],\n"
"    }\n"
"\n"
"    extern \"C\" {\n"
"        pub fn opendir(s: *const c_char) -> *mut DIR;\n"
"\n"
"        #[cfg(not(all(target_os = \"macos\", target_arch = \"x86_64\")))]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        // See https://github.com/rust-lang/libc/issues/414 and the section "
"on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
"        #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n"
"        #[link_name = \"readdir$INODE64\"]\n"
"        pub fn readdir(s: *mut DIR) -> *const dirent;\n"
"\n"
"        pub fn closedir(s: *mut DIR) -> c_int;\n"
"    }\n"
"}\n"
"\n"
"use std::ffi::{CStr, CString, OsStr, OsString};\n"
"use std::os::unix::ffi::OsStrExt;\n"
"\n"
"#[derive(Debug)]\n"
"struct DirectoryIterator {\n"
"    path: CString,\n"
"    dir: *mut ffi::DIR,\n"
"}\n"
"// ANCHOR_END: ffi\n"
"\n"
"// ANCHOR: DirectoryIterator\n"
"impl DirectoryIterator {\n"
"    fn new(path: &str) -> Result<DirectoryIterator, String> {\n"
"        // Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
"        // ANCHOR_END: DirectoryIterator\n"
"        let path = CString::new(path).map_err(|err| format!(\"Invalid path: "
"{err}\"))?;\n"
"        // SAFETY: path.as_ptr() cannot be NULL.\n"
"        let dir = unsafe { ffi::opendir(path.as_ptr()) };\n"
"        if dir.is_null() {\n"
"            Err(format!(\"Could not open {:?}\", path))\n"
"        } else {\n"
"            Ok(DirectoryIterator { path, dir })\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Iterator\n"
"impl Iterator for DirectoryIterator {\n"
"    type Item = OsString;\n"
"    fn next(&mut self) -> Option<OsString> {\n"
"        // Keep calling readdir until we get a NULL pointer back.\n"
"        // ANCHOR_END: Iterator\n"
"        // SAFETY: self.dir is never NULL.\n"
"        let dirent = unsafe { ffi::readdir(self.dir) };\n"
"        if dirent.is_null() {\n"
"            // We have reached the end of the directory.\n"
"            return None;\n"
"        }\n"
"        // SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
"        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };\n"
"        let os_str = OsStr::from_bytes(d_name.to_bytes());\n"
"        Some(os_str.to_owned())\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: Drop\n"
"impl Drop for DirectoryIterator {\n"
"    fn drop(&mut self) {\n"
"        // Call closedir as needed.\n"
"        // ANCHOR_END: Drop\n"
"        if !self.dir.is_null() {\n"
"            // SAFETY: self.dir is not NULL.\n"
"            if unsafe { ffi::closedir(self.dir) } != 0 {\n"
"                panic!(\"Could not close {:?}\", self.path);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ANCHOR: main\n"
"fn main() -> Result<(), String> {\n"
"    let iter = DirectoryIterator::new(\".\")?;\n"
"    println!(\"files: {:#?}\", iter.collect::<Vec<_>>());\n"
"    Ok(())\n"
"}\n"
"// ANCHOR_END: main\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use super::*;\n"
"    use std::error::Error;\n"
"\n"
"    #[test]\n"
"    fn test_nonexisting_directory() {\n"
"        let iter = DirectoryIterator::new(\"no-such-directory\");\n"
"        assert!(iter.is_err());\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_empty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\"]);\n"
"        Ok(())\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {\n"
"        let tmp = tempfile::TempDir::new()?;\n"
"        std::fs::write(tmp.path().join(\"foo.txt\"), \"The Foo "
"Diaries\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"bar.png\"), \"<PNG>\\n\")?;\n"
"        std::fs::write(tmp.path().join(\"crab.rs\"), \"//! Crab\\n\")?;\n"
"        let iter = DirectoryIterator::new(\n"
"            tmp.path().to_str().ok_or(\"Non UTF-8 character in path\")?,\n"
"        )?;\n"
"        let mut entries = iter.collect::<Vec<_>>();\n"
"        entries.sort();\n"
"        assert_eq!(entries, &[\".\", \"..\", \"bar.png\", \"crab.rs\", \"foo."
"txt\"]);\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-morning.md:1
#, fuzzy
msgid "Bare Metal Rust Morning Exercise"
msgstr "3Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¹Î½Î® Î¬ÏƒÎºÎ·ÏƒÎ·"

#: src/exercises/bare-metal/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](compass.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](for-loops.md))"

#: src/exercises/bare-metal/solutions-morning.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"extern crate panic_halt as _;\n"
"\n"
"use core::fmt::Write;\n"
"use cortex_m_rt::entry;\n"
"// ANCHOR_END: top\n"
"use core::cmp::{max, min};\n"
"use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};\n"
"use microbit::display::blocking::Display;\n"
"use microbit::hal::prelude::*;\n"
"use microbit::hal::twim::Twim;\n"
"use microbit::hal::uarte::{Baudrate, Parity, Uarte};\n"
"use microbit::hal::Timer;\n"
"use microbit::pac::twim0::frequency::FREQUENCY_A;\n"
"use microbit::Board;\n"
"\n"
"const COMPASS_SCALE: i32 = 30000;\n"
"const ACCELEROMETER_SCALE: i32 = 700;\n"
"\n"
"// ANCHOR: main\n"
"#[entry]\n"
"fn main() -> ! {\n"
"    let board = Board::take().unwrap();\n"
"\n"
"    // Configure serial port.\n"
"    let mut serial = Uarte::new(\n"
"        board.UARTE0,\n"
"        board.uart.into(),\n"
"        Parity::EXCLUDED,\n"
"        Baudrate::BAUD115200,\n"
"    );\n"
"\n"
"    // Set up the I2C controller and Inertial Measurement Unit.\n"
"    // ANCHOR_END: main\n"
"    writeln!(serial, \"Setting up IMU...\").unwrap();\n"
"    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::"
"K100);\n"
"    let mut imu = Lsm303agr::new_with_i2c(i2c);\n"
"    imu.init().unwrap();\n"
"    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();\n"
"    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();\n"
"    let mut imu = imu.into_mag_continuous().ok().unwrap();\n"
"\n"
"    // Set up display and timer.\n"
"    let mut timer = Timer::new(board.TIMER0);\n"
"    let mut display = Display::new(board.display_pins);\n"
"\n"
"    let mut mode = Mode::Compass;\n"
"    let mut button_pressed = false;\n"
"\n"
"    // ANCHOR: loop\n"
"    writeln!(serial, \"Ready.\").unwrap();\n"
"\n"
"    loop {\n"
"        // Read compass data and log it to the serial port.\n"
"        // ANCHOR_END: loop\n"
"        while !(imu.mag_status().unwrap().xyz_new_data\n"
"            && imu.accel_status().unwrap().xyz_new_data)\n"
"        {}\n"
"        let compass_reading = imu.mag_data().unwrap();\n"
"        let accelerometer_reading = imu.accel_data().unwrap();\n"
"        writeln!(\n"
"            serial,\n"
"            \"{},{},{}\\t{},{},{}\",\n"
"            compass_reading.x,\n"
"            compass_reading.y,\n"
"            compass_reading.z,\n"
"            accelerometer_reading.x,\n"
"            accelerometer_reading.y,\n"
"            accelerometer_reading.z,\n"
"        )\n"
"        .unwrap();\n"
"\n"
"        let mut image = [[0; 5]; 5];\n"
"        let (x, y) = match mode {\n"
"            Mode::Compass => (\n"
"                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, "
"4) as usize,\n"
"            ),\n"
"            Mode::Accelerometer => (\n"
"                scale(\n"
"                    accelerometer_reading.x,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"                scale(\n"
"                    -accelerometer_reading.y,\n"
"                    -ACCELEROMETER_SCALE,\n"
"                    ACCELEROMETER_SCALE,\n"
"                    0,\n"
"                    4,\n"
"                ) as usize,\n"
"            ),\n"
"        };\n"
"        image[y][x] = 255;\n"
"        display.show(&mut timer, image, 100);\n"
"\n"
"        // If button A is pressed, switch to the next mode and briefly blink "
"all LEDs on.\n"
"        if board.buttons.button_a.is_low().unwrap() {\n"
"            if !button_pressed {\n"
"                mode = mode.next();\n"
"                display.show(&mut timer, [[255; 5]; 5], 200);\n"
"            }\n"
"            button_pressed = true;\n"
"        } else {\n"
"            button_pressed = false;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n"
"enum Mode {\n"
"    Compass,\n"
"    Accelerometer,\n"
"}\n"
"\n"
"impl Mode {\n"
"    fn next(self) -> Self {\n"
"        match self {\n"
"            Self::Compass => Self::Accelerometer,\n"
"            Self::Accelerometer => Self::Compass,\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -"
"> i32 {\n"
"    let range_in = max_in - min_in;\n"
"    let range_out = max_out - min_out;\n"
"    cap(\n"
"        min_out + range_out * (value - min_in) / range_in,\n"
"        min_out,\n"
"        max_out,\n"
"    )\n"
"}\n"
"\n"
"fn cap(value: i32, min_value: i32, max_value: i32) -> i32 {\n"
"    max(min_value, min(value, max_value))\n"
"}\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](rtc.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](luhn.md))"

#: src/exercises/bare-metal/solutions-afternoon.md:7
msgid "`main.rs`:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:9
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: top\n"
"#![no_main]\n"
"#![no_std]\n"
"\n"
"mod exceptions;\n"
"mod logger;\n"
"mod pl011;\n"
"// ANCHOR_END: top\n"
"mod pl031;\n"
"\n"
"use crate::pl031::Rtc;\n"
"use arm_gic::gicv3::{IntId, Trigger};\n"
"use arm_gic::{irq_enable, wfi};\n"
"use chrono::{TimeZone, Utc};\n"
"use core::hint::spin_loop;\n"
"// ANCHOR: imports\n"
"use crate::pl011::Uart;\n"
"use arm_gic::gicv3::GicV3;\n"
"use core::panic::PanicInfo;\n"
"use log::{error, info, trace, LevelFilter};\n"
"use smccc::psci::system_off;\n"
"use smccc::Hvc;\n"
"\n"
"/// Base addresses of the GICv3.\n"
"const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;\n"
"const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;\n"
"\n"
"/// Base address of the primary PL011 UART.\n"
"const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;\n"
"// ANCHOR_END: imports\n"
"\n"
"/// Base address of the PL031 RTC.\n"
"const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;\n"
"/// The IRQ used by the PL031 RTC.\n"
"const PL031_IRQ: IntId = IntId::spi(2);\n"
"\n"
"// ANCHOR: main\n"
"#[no_mangle]\n"
"extern \"C\" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {\n"
"    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };\n"
"    logger::init(uart, LevelFilter::Trace).unwrap();\n"
"\n"
"    info!(\"main({:#x}, {:#x}, {:#x}, {:#x})\", x0, x1, x2, x3);\n"
"\n"
"    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the "
"base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
"    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, "
"GICR_BASE_ADDRESS) };\n"
"    gic.setup();\n"
"    // ANCHOR_END: main\n"
"\n"
"    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 "
"device,\n"
"    // and nothing else accesses that address range.\n"
"    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };\n"
"    let timestamp = rtc.read();\n"
"    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();\n"
"    info!(\"RTC: {time}\");\n"
"\n"
"    GicV3::set_priority_mask(0xff);\n"
"    gic.set_interrupt_priority(PL031_IRQ, 0x80);\n"
"    gic.set_trigger(PL031_IRQ, Trigger::Level);\n"
"    irq_enable();\n"
"    gic.enable_interrupt(PL031_IRQ, true);\n"
"\n"
"    // Wait for 3 seconds, without interrupts.\n"
"    let target = timestamp + 3;\n"
"    rtc.set_match(target);\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.matched() {\n"
"        spin_loop();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // Wait another 3 seconds for an interrupt.\n"
"    let target = timestamp + 6;\n"
"    info!(\n"
"        \"Waiting for {}\",\n"
"        Utc.timestamp_opt(target.into(), 0).unwrap()\n"
"    );\n"
"    rtc.set_match(target);\n"
"    rtc.clear_interrupt();\n"
"    rtc.enable_interrupt(true);\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    while !rtc.interrupt_pending() {\n"
"        wfi();\n"
"    }\n"
"    trace!(\n"
"        \"matched={}, interrupt_pending={}\",\n"
"        rtc.matched(),\n"
"        rtc.interrupt_pending()\n"
"    );\n"
"    info!(\"Finished waiting\");\n"
"\n"
"    // ANCHOR: main_end\n"
"    system_off::<Hvc>().unwrap();\n"
"}\n"
"\n"
"#[panic_handler]\n"
"fn panic(info: &PanicInfo) -> ! {\n"
"    error!(\"{info}\");\n"
"    system_off::<Hvc>().unwrap();\n"
"    loop {}\n"
"}\n"
"// ANCHOR_END: main_end\n"
"```"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:149
msgid "`pl031.rs`:"
msgstr ""

#: src/exercises/bare-metal/solutions-afternoon.md:151
msgid ""
"```rust\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use core::ptr::{addr_of, addr_of_mut};\n"
"\n"
"#[repr(C, align(4))]\n"
"struct Registers {\n"
"    /// Data register\n"
"    dr: u32,\n"
"    /// Match register\n"
"    mr: u32,\n"
"    /// Load register\n"
"    lr: u32,\n"
"    /// Control register\n"
"    cr: u8,\n"
"    _reserved0: [u8; 3],\n"
"    /// Interrupt Mask Set or Clear register\n"
"    imsc: u8,\n"
"    _reserved1: [u8; 3],\n"
"    /// Raw Interrupt Status\n"
"    ris: u8,\n"
"    _reserved2: [u8; 3],\n"
"    /// Masked Interrupt Status\n"
"    mis: u8,\n"
"    _reserved3: [u8; 3],\n"
"    /// Interrupt Clear Register\n"
"    icr: u8,\n"
"    _reserved4: [u8; 3],\n"
"}\n"
"\n"
"/// Driver for a PL031 real-time clock.\n"
"#[derive(Debug)]\n"
"pub struct Rtc {\n"
"    registers: *mut Registers,\n"
"}\n"
"\n"
"impl Rtc {\n"
"    /// Constructs a new instance of the RTC driver for a PL031 device at "
"the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
"    pub unsafe fn new(base_address: *mut u32) -> Self {\n"
"        Self {\n"
"            registers: base_address as *mut Registers,\n"
"        }\n"
"    }\n"
"\n"
"    /// Reads the current RTC value.\n"
"    pub fn read(&self) -> u32 {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of!((*self.registers).dr).read_volatile() }\n"
"    }\n"
"\n"
"    /// Writes a match value. When the RTC value matches this then an "
"interrupt\n"
"    /// will be generated (if it is enabled).\n"
"    pub fn set_match(&mut self, value: u32) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }\n"
"    }\n"
"\n"
"    /// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
"    pub fn matched(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).ris)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
"    pub fn interrupt_pending(&self) -> bool {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        let ris = unsafe { addr_of!((*self.registers).mis)."
"read_volatile() };\n"
"        (ris & 0x01) != 0\n"
"    }\n"
"\n"
"    /// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
"    pub fn enable_interrupt(&mut self, mask: bool) {\n"
"        let imsc = if mask { 0x01 } else { 0x00 };\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).imsc)."
"write_volatile(imsc) }\n"
"    }\n"
"\n"
"    /// Clears a pending interrupt, if any.\n"
"    pub fn clear_interrupt(&mut self) {\n"
"        // Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
"        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }\n"
"    }\n"
"}\n"
"\n"
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
"unsafe impl Send for Rtc {}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:1
#, fuzzy
msgid "Concurrency Morning Exercise"
msgstr "3Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¹Î½Î® Î¬ÏƒÎºÎ·ÏƒÎ·"

#: src/exercises/concurrency/solutions-morning.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md:7
msgid ""
"```rust\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::{mpsc, Arc, Mutex};\n"
"use std::thread;\n"
"use std::time::Duration;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: mpsc::SyncSender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    fn eat(&self) {\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        println!(\"{} is trying to eat\", &self.name);\n"
"        let left = self.left_fork.lock().unwrap();\n"
"        let right = self.right_fork.lock().unwrap();\n"
"\n"
"        // ANCHOR: Philosopher-eat-end\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        thread::sleep(Duration::from_millis(10));\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    let (tx, rx) = mpsc::sync_channel(10);\n"
"\n"
"    let forks = (0..PHILOSOPHERS.len())\n"
"        .map(|_| Arc::new(Mutex::new(Fork)))\n"
"        .collect::<Vec<_>>();\n"
"\n"
"    for i in 0..forks.len() {\n"
"        let tx = tx.clone();\n"
"        let mut left_fork = Arc::clone(&forks[i]);\n"
"        let mut right_fork = Arc::clone(&forks[(i + 1) % forks.len()]);\n"
"\n"
"        // To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
"        if i == forks.len() - 1 {\n"
"            std::mem::swap(&mut left_fork, &mut right_fork);\n"
"        }\n"
"\n"
"        let philosopher = Philosopher {\n"
"            name: PHILOSOPHERS[i].to_string(),\n"
"            thoughts: tx,\n"
"            left_fork,\n"
"            right_fork,\n"
"        };\n"
"\n"
"        thread::spawn(move || {\n"
"            for _ in 0..100 {\n"
"                philosopher.eat();\n"
"                philosopher.think();\n"
"            }\n"
"        });\n"
"    }\n"
"\n"
"    drop(tx);\n"
"    for thought in rx {\n"
"        println!(\"{thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-morning.md:104
#, fuzzy
msgid "Link Checker"
msgstr "ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Ï‰Î½ Ï€Î¿Î»Î»Î±Ï€Î»ÏÎ½ Î½Î·Î¼Î¬Ï„Ï‰Î½"

#: src/exercises/concurrency/solutions-morning.md:106
#, fuzzy
msgid "([back to exercise](link-checker.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](luhn.md))"

#: src/exercises/concurrency/solutions-morning.md:108
msgid ""
"```rust,compile_fail\n"
"// Copyright 2022 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};\n"
"\n"
"// ANCHOR: setup\n"
"use reqwest::{blocking::Client, Url};\n"
"use scraper::{Html, Selector};\n"
"use thiserror::Error;\n"
"\n"
"#[derive(Error, Debug)]\n"
"enum Error {\n"
"    #[error(\"request error: {0}\")]\n"
"    ReqwestError(#[from] reqwest::Error),\n"
"    #[error(\"bad http response: {0}\")]\n"
"    BadResponse(String),\n"
"}\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: visit_page\n"
"#[derive(Debug)]\n"
"struct CrawlCommand {\n"
"    url: Url,\n"
"    extract_links: bool,\n"
"}\n"
"\n"
"fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, "
"Error> {\n"
"    println!(\"Checking {:#}\", command.url);\n"
"    let response = client.get(command.url.clone()).send()?;\n"
"    if !response.status().is_success() {\n"
"        return Err(Error::BadResponse(response.status().to_string()));\n"
"    }\n"
"\n"
"    let mut link_urls = Vec::new();\n"
"    if !command.extract_links {\n"
"        return Ok(link_urls);\n"
"    }\n"
"\n"
"    let base_url = response.url().to_owned();\n"
"    let body_text = response.text()?;\n"
"    let document = Html::parse_document(&body_text);\n"
"\n"
"    let selector = Selector::parse(\"a\").unwrap();\n"
"    let href_values = document\n"
"        .select(&selector)\n"
"        .filter_map(|element| element.value().attr(\"href\"));\n"
"    for href in href_values {\n"
"        match base_url.join(href) {\n"
"            Ok(link_url) => {\n"
"                link_urls.push(link_url);\n"
"            }\n"
"            Err(err) => {\n"
"                println!(\"On {base_url:#}: ignored unparsable {href:?}: "
"{err}\");\n"
"            }\n"
"        }\n"
"    }\n"
"    Ok(link_urls)\n"
"}\n"
"// ANCHOR_END: visit_page\n"
"\n"
"struct CrawlState {\n"
"    domain: String,\n"
"    visited_pages: std::collections::HashSet<String>,\n"
"}\n"
"\n"
"impl CrawlState {\n"
"    fn new(start_url: &Url) -> CrawlState {\n"
"        let mut visited_pages = std::collections::HashSet::new();\n"
"        visited_pages.insert(start_url.as_str().to_string());\n"
"        CrawlState {\n"
"            domain: start_url.domain().unwrap().to_string(),\n"
"            visited_pages,\n"
"        }\n"
"    }\n"
"\n"
"    /// Determine whether links within the given page should be extracted.\n"
"    fn should_extract_links(&self, url: &Url) -> bool {\n"
"        let Some(url_domain) = url.domain() else {\n"
"            return false;\n"
"        };\n"
"        url_domain == self.domain\n"
"    }\n"
"\n"
"    /// Mark the given page as visited, returning true if it had already\n"
"    /// been visited.\n"
"    fn mark_visited(&mut self, url: &Url) -> bool {\n"
"        self.visited_pages.insert(url.as_str().to_string())\n"
"    }\n"
"}\n"
"\n"
"type CrawlResult = Result<Vec<Url>, (Url, Error)>;\n"
"fn spawn_crawler_threads(\n"
"    command_receiver: mpsc::Receiver<CrawlCommand>,\n"
"    result_sender: mpsc::Sender<CrawlResult>,\n"
"    thread_count: u32,\n"
") {\n"
"    let command_receiver = Arc::new(Mutex::new(command_receiver));\n"
"\n"
"    for _ in 0..thread_count {\n"
"        let result_sender = result_sender.clone();\n"
"        let command_receiver = command_receiver.clone();\n"
"        thread::spawn(move || {\n"
"            let client = Client::new();\n"
"            loop {\n"
"                let command_result = {\n"
"                    let receiver_guard = command_receiver.lock().unwrap();\n"
"                    receiver_guard.recv()\n"
"                };\n"
"                let Ok(crawl_command) = command_result else {\n"
"                    // The sender got dropped. No more commands coming in.\n"
"                    break;\n"
"                };\n"
"                let crawl_result = match visit_page(&client, &crawl_command) "
"{\n"
"                    Ok(link_urls) => Ok(link_urls),\n"
"                    Err(error) => Err((crawl_command.url, error)),\n"
"                };\n"
"                result_sender.send(crawl_result).unwrap();\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"\n"
"fn control_crawl(\n"
"    start_url: Url,\n"
"    command_sender: mpsc::Sender<CrawlCommand>,\n"
"    result_receiver: mpsc::Receiver<CrawlResult>,\n"
") -> Vec<Url> {\n"
"    let mut crawl_state = CrawlState::new(&start_url);\n"
"    let start_command = CrawlCommand { url: start_url, extract_links: "
"true };\n"
"    command_sender.send(start_command).unwrap();\n"
"    let mut pending_urls = 1;\n"
"\n"
"    let mut bad_urls = Vec::new();\n"
"    while pending_urls > 0 {\n"
"        let crawl_result = result_receiver.recv().unwrap();\n"
"        pending_urls -= 1;\n"
"\n"
"        match crawl_result {\n"
"            Ok(link_urls) => {\n"
"                for url in link_urls {\n"
"                    if crawl_state.mark_visited(&url) {\n"
"                        let extract_links = crawl_state."
"should_extract_links(&url);\n"
"                        let crawl_command = CrawlCommand { url, "
"extract_links };\n"
"                        command_sender.send(crawl_command).unwrap();\n"
"                        pending_urls += 1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            Err((url, error)) => {\n"
"                bad_urls.push(url);\n"
"                println!(\"Got crawling error: {:#}\", error);\n"
"                continue;\n"
"            }\n"
"        }\n"
"    }\n"
"    bad_urls\n"
"}\n"
"\n"
"fn check_links(start_url: Url) -> Vec<Url> {\n"
"    let (result_sender, result_receiver) = mpsc::channel::<CrawlResult>();\n"
"    let (command_sender, command_receiver) = mpsc::channel::"
"<CrawlCommand>();\n"
"    spawn_crawler_threads(command_receiver, result_sender, 16);\n"
"    control_crawl(start_url, command_sender, result_receiver)\n"
"}\n"
"\n"
"fn main() {\n"
"    let start_url = reqwest::Url::parse(\"https://www.google.org\")."
"unwrap();\n"
"    let bad_urls = check_links(start_url);\n"
"    println!(\"Bad URLs: {:#?}\", bad_urls);\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:1
#, fuzzy
msgid "Concurrency Afternoon Exercise"
msgstr "1Î· Î·Î¼Î­ÏÎ± Î‘Ï€Î¿Î³ÎµÏ…Î¼Î±Ï„Î¹Î½Î­Ï‚ Î‘ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚"

#: src/exercises/concurrency/solutions-afternoon.md:5
#, fuzzy
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-afternoon.md:7
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: Philosopher\n"
"use std::sync::Arc;\n"
"use tokio::time;\n"
"use tokio::sync::mpsc::{self, Sender};\n"
"use tokio::sync::Mutex;\n"
"\n"
"struct Fork;\n"
"\n"
"struct Philosopher {\n"
"    name: String,\n"
"    // ANCHOR_END: Philosopher\n"
"    left_fork: Arc<Mutex<Fork>>,\n"
"    right_fork: Arc<Mutex<Fork>>,\n"
"    thoughts: Sender<String>,\n"
"}\n"
"\n"
"// ANCHOR: Philosopher-think\n"
"impl Philosopher {\n"
"    async fn think(&self) {\n"
"        self.thoughts\n"
"            .send(format!(\"Eureka! {} has a new idea!\", &self.name))."
"await\n"
"            .unwrap();\n"
"    }\n"
"    // ANCHOR_END: Philosopher-think\n"
"\n"
"    // ANCHOR: Philosopher-eat\n"
"    async fn eat(&self) {\n"
"        // Pick up forks...\n"
"        // ANCHOR_END: Philosopher-eat\n"
"        let _first_lock = self.left_fork.lock().await;\n"
"        // Add a delay before picking the second fork to allow the "
"execution\n"
"        // to transfer to another task\n"
"        time::sleep(time::Duration::from_millis(1)).await;\n"
"        let _second_lock = self.right_fork.lock().await;\n"
"\n"
"        // ANCHOR: Philosopher-eat-body\n"
"        println!(\"{} is eating...\", &self.name);\n"
"        time::sleep(time::Duration::from_millis(5)).await;\n"
"        // ANCHOR_END: Philosopher-eat-body\n"
"\n"
"        // The locks are dropped here\n"
"        // ANCHOR: Philosopher-eat-end\n"
"    }\n"
"}\n"
"\n"
"static PHILOSOPHERS: &[&str] =\n"
"    &[\"Socrates\", \"Plato\", \"Aristotle\", \"Thales\", \"Pythagoras\"];\n"
"\n"
"#[tokio::main]\n"
"async fn main() {\n"
"    // ANCHOR_END: Philosopher-eat-end\n"
"    // Create forks\n"
"    let mut forks = vec![];\n"
"    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::"
"new(Fork))));\n"
"\n"
"    // Create philosophers\n"
"    let (philosophers, mut rx) = {\n"
"        let mut philosophers = vec![];\n"
"        let (tx, rx) = mpsc::channel(10);\n"
"        for (i, name) in PHILOSOPHERS.iter().enumerate() {\n"
"            let left_fork = Arc::clone(&forks[i]);\n"
"            let right_fork = Arc::clone(&forks[(i + 1) % PHILOSOPHERS."
"len()]);\n"
"            // To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
"            if i  == 0 {\n"
"                std::mem::swap(&mut left_fork, &mut right_fork);\n"
"            }\n"
"            philosophers.push(Philosopher {\n"
"                name: name.to_string(),\n"
"                left_fork,\n"
"                right_fork,\n"
"                thoughts: tx.clone(),\n"
"            });\n"
"        }\n"
"        (philosophers, rx)\n"
"        // tx is dropped here, so we don't need to explicitly drop it later\n"
"    };\n"
"\n"
"    // Make them think and eat\n"
"    for phil in philosophers {\n"
"        tokio::spawn(async move {\n"
"            for _ in 0..100 {\n"
"                phil.think().await;\n"
"                phil.eat().await;\n"
"            }\n"
"        });\n"
"\n"
"    }\n"
"\n"
"    // Output their thoughts\n"
"    while let Some(thought) = rx.recv().await {\n"
"        println!(\"Here is a thought: {thought}\");\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:121
#, fuzzy
msgid "([back to exercise](chat-app.md))"
msgstr "([ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÏƒÏ„Î·Î½ Î¬ÏƒÎºÎ·ÏƒÎ·](luhn.md))"

#: src/exercises/concurrency/solutions-afternoon.md:125
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::sink::SinkExt;\n"
"use std::error::Error;\n"
"use std::net::SocketAddr;\n"
"use tokio::net::{TcpListener, TcpStream};\n"
"use tokio::sync::broadcast::{channel, Sender};\n"
"use tokio_websockets::{Message, ServerBuilder, WebsocketStream};\n"
"// ANCHOR_END: setup\n"
"\n"
"// ANCHOR: handle_connection\n"
"async fn handle_connection(\n"
"    addr: SocketAddr,\n"
"    mut ws_stream: WebsocketStream<TcpStream>,\n"
"    bcast_tx: Sender<String>,\n"
") -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    // ANCHOR_END: handle_connection\n"
"\n"
"    ws_stream\n"
"        .send(Message::text(\"Welcome to chat! Type a message\".into()))\n"
"        .await?;\n"
"    let mut bcast_rx = bcast_tx.subscribe();\n"
"\n"
"    // A continuous loop for concurrently performing two tasks: (1) "
"receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => {\n"
"                        let msg = msg.as_text()?;\n"
"                        println!(\"From client {addr:?} {msg:?}\");\n"
"                        bcast_tx.send(msg.into())?;\n"
"                    }\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            msg = bcast_rx.recv() => {\n"
"                ws_stream.send(Message::text(msg?)).await?;\n"
"            }\n"
"        }\n"
"    }\n"
"    // ANCHOR: main\n"
"}\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n"
"    let (bcast_tx, _) = channel(16);\n"
"\n"
"    let listener = TcpListener::bind(\"127.0.0.1:2000\").await?;\n"
"    println!(\"listening on port 2000\");\n"
"\n"
"    loop {\n"
"        let (socket, addr) = listener.accept().await?;\n"
"        println!(\"New connection from {addr:?}\");\n"
"        let bcast_tx = bcast_tx.clone();\n"
"        tokio::spawn(async move {\n"
"            // Wrap the raw TCP stream into a websocket.\n"
"            let ws_stream = ServerBuilder::new().accept(socket).await?;\n"
"\n"
"            handle_connection(addr, ws_stream, bcast_tx).await\n"
"        });\n"
"    }\n"
"}\n"
"// ANCHOR_END: main\n"
"```"
msgstr ""

#: src/exercises/concurrency/solutions-afternoon.md:210
msgid ""
"```rust,compile_fail\n"
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
"\n"
"// ANCHOR: setup\n"
"use futures_util::SinkExt;\n"
"use http::Uri;\n"
"use tokio::io::{AsyncBufReadExt, BufReader};\n"
"use tokio_websockets::{ClientBuilder, Message};\n"
"\n"
"#[tokio::main]\n"
"async fn main() -> Result<(), tokio_websockets::Error> {\n"
"    let mut ws_stream = ClientBuilder::from_uri(Uri::"
"from_static(\"ws://127.0.0.1:2000\"))\n"
"        .connect()\n"
"        .await?;\n"
"\n"
"    let stdin = tokio::io::stdin();\n"
"    let mut stdin = BufReader::new(stdin).lines();\n"
"\n"
"    // ANCHOR_END: setup\n"
"    // Continuous loop for concurrently sending and receiving messages.\n"
"    loop {\n"
"        tokio::select! {\n"
"            incoming = ws_stream.next() => {\n"
"                match incoming {\n"
"                    Some(Ok(msg)) => println!(\"From server: {}\", msg."
"as_text()?),\n"
"                    Some(Err(err)) => return Err(err.into()),\n"
"                    None => return Ok(()),\n"
"                }\n"
"            }\n"
"            res = stdin.next_line() => {\n"
"                match res {\n"
"                    Ok(None) => return Ok(()),\n"
"                    Ok(Some(line)) => ws_stream.send(Message::text(line."
"to_string())).await?,\n"
"                    Err(err) => return Err(err.into()),\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#~ msgid "Day 4: Morning"
#~ msgstr "4Î· Î¼Î­ÏÎ±: Î ÏÏ‰Î¯"

#~ msgid "Day 4: Afternoon (Android)"
#~ msgstr "4Î· Î¼Î­ÏÎ±: Î‘Ï€ÏŒÎ³ÎµÏ…Î¼Î± (Android)"

#~ msgid "Day 4 Morning"
#~ msgstr "4Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¯"

#~ msgid "Build workflow"
#~ msgstr "Î¡Î¿Î® ÎµÏÎ³Î±ÏƒÎ¯Î±Ï‚ ÎºÎ±Ï„Î±ÏƒÎºÎµÏ…Î®Ï‚"

#~ msgid "GitHub contributors"
#~ msgstr "Î£Ï…Î½ÎµÏÎ³Î¬Ï„ÎµÏ‚ GitHub"

#~ msgid "GitHub stars"
#~ msgstr "Î‘ÏƒÏ„Î­ÏÎ¹Î± GitHub"

#~ msgid "On Day 4, we will cover Android-specific things such as:"
#~ msgstr ""
#~ "Î¤Î·Î½ 4Î· Î—Î¼Î­ÏÎ±, Î¸Î± ÎºÎ±Î»ÏÏˆÎ¿Ï…Î¼Îµ Ï€ÏÎ¬Î³Î¼Î±Ï„Î± Ï€Î¿Ï… Î±Ï†Î¿ÏÎ¿ÏÎ½ ÏƒÏ…Î³ÎºÎµÎºÏÎ¹Î¼Î­Î½Î± Ï„Î¿ Android, "
#~ "ÏŒÏ€Ï‰Ï‚:"

#~ msgid "Building Android components in Rust."
#~ msgstr "Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Android components Î¼Îµ Rust."

#~ msgid "AIDL servers and clients."
#~ msgstr "Î•Î¾Ï…Ï€Î·ÏÎµÏ„Î·Ï„Î­Ï‚ ÎºÎ±Î¹ Ï€ÎµÎ»Î¬Ï„ÎµÏ‚ AIDL."

#~ msgid "Interoperability with C, C++, and Java."
#~ msgstr "Î”Î¹Î±Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒÏ„Î·Ï„Î± Î¼Îµ C, C++ ÎºÎ±Î¹ Java."

#~ msgid ""
#~ "It is important to note that this course does not cover Android "
#~ "**application**  development in Rust, and that the Android-specific parts "
#~ "are specifically about writing code for Android itself, the operating "
#~ "system. "
#~ msgstr ""
#~ "Î•Î¯Î½Î±Î¹ ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ Î½Î± ÏƒÎ·Î¼ÎµÎ¹Ï‰Î¸ÎµÎ¯ ÏŒÏ„Î¹ Î±Ï…Ï„ÏŒ Ï„Î¿ Î¼Î¬Î¸Î·Î¼Î± Î´ÎµÎ½ ÎºÎ±Î»ÏÏ€Ï„ÎµÎ¹ Ï„Î·Î½ "
#~ "Î±Î½Î¬Ï€Ï„Ï…Î¾Î·**ÎµÏ†Î±ÏÎ¼Î¿Î³ÏÎ½** Android ÏƒÎµ Rust. Î¤Î¿ ÎºÎ¿Î¼Î¼Î¬Ï„Î¹ Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚ Ï€Î¿Ï… Î±Ï†Î¿ÏÎ¬ "
#~ "Ï„Î¿Android Î­Ï‡ÎµÎ¹ Î½Î± ÎºÎ¬Î½ÎµÎ¹ Î¼Îµ Î±Î½Î¬Ï€Ï„Ï…Î¾Î· ÎºÏÎ´Î¹ÎºÎ± Î³Î¹Î± Ï„Î¿ Î¯Î´Î¹Î¿ Ï„Î¿ Android, Ï‰Ï‚ "
#~ "Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÏŒ ÏƒÏÏƒÏ„Î·Î¼Î±."

#~ msgid ""
#~ "Learn how to use async Rust --- we'll only mention async Rust when "
#~ "covering traditional concurrency primitives. Please see [Asynchronous "
#~ "Programming in Rust](https://rust-lang.github.io/async-book/) instead for "
#~ "details on this topic."
#~ msgstr ""
#~ "Î§ÏÎ®ÏƒÎ· async Rust --- Î¸Î± Î±Î½Î±Ï†Î­ÏÎ¿Ï…Î¼Îµ ÏƒÏ„Î·Î½ async Rust Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ ÎºÎ±Î»ÏÏˆÎ¿Ï…Î¼Îµ Ï„Î± "
#~ "Ï€Î±ÏÎ±Î´Î¿ÏƒÎ¹Î±ÎºÎ¬ Î´Î¿Î¼Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼Î¿Ï. Î”ÎµÎ¯Ï„Îµ ÎºÎ±Î¹ [Î‘ÏƒÏÎ³Ï‡ÏÎ¿Î½Î¿Ï‚ "
#~ "Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÎ¼ÏŒÏ‚ ÏƒÎµ Rust](https://rust-lang.github.io/async-book/) Î³Î¹Î± "
#~ "Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ Î³Î¹Î± Î±Ï…Ï„ÏŒ Ï„Î¿ Î¸Î­Î¼Î±."

#~ msgid ""
#~ "Select your topic for the afternoon of the fourth day. This may be based "
#~ "on the audience you expect, or on your own expertise."
#~ msgstr ""
#~ "Î•Ï€Î¹Î»Î­Î¾Ï„Îµ Ï„Î¿ Î¸Î­Î¼Î± ÏƒÎ±Ï‚ Î³Î¹Î± Ï„Î¿ Î±Ï€ÏŒÎ³ÎµÏ…Î¼Î± Ï„Î·Ï‚ Ï„Î­Ï„Î±ÏÏ„Î·Ï‚ Î·Î¼Î­ÏÎ±Ï‚. Î‘Ï…Ï„ÏŒ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± "
#~ "Î²Î±ÏƒÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ ÎºÎ¿Î¹Î½ÏŒ Ï€Î¿Ï… Ï€ÎµÏÎ¹Î¼Î­Î½ÎµÏ„Îµ Î® ÏƒÏ„Î· Î´Î¹ÎºÎ® ÏƒÎ±Ï‚ ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î±."

#~ msgid ""
#~ "Prepare anything you need to have available for the afternoon of day 4."
#~ msgstr "Î•Ï„Î¿Î¹Î¼Î¬ÏƒÏ„Îµ Î¿Ï„Î¹Î´Î®Ï€Î¿Ï„Îµ Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏƒÏ„Îµ Î³Î¹Î± Ï„Î¿ Î±Ï€ÏŒÎ³ÎµÏ…Î¼Î± Ï„Î·Ï‚ 4Î·Ï‚ Î·Î¼Î­ÏÎ±Ï‚."

#~ msgid "Day 1: Basic Rust, ownership and the borrow checker."
#~ msgstr "Î—Î¼Î­ÏÎ± 1: Î’Î±ÏƒÎ¹ÎºÎ® Rust, Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± ÎºÎ±Î¹ Î¿ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Î´Î±Î½ÎµÎ¯Ï‰Î½."

#~ msgid "Day 4: Concurrency in Rust and seeing Rust in action."
#~ msgstr "Î—Î¼Î­ÏÎ± 4: Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ„Î· Rust. Rust ÏƒÏ„Î·Î½ Ï€ÏÎ¬Î¾Î·."

#~ msgid "Day 4"
#~ msgstr "Î—Î¼Î­ÏÎ± 4Î·"

#~ msgid ""
#~ "The afternoon of the fourth day should cover a topic of your choice. "
#~ "Include the topic in the announcement of the course, so that participants "
#~ "know what to expect."
#~ msgstr ""
#~ "Î¤Î¿ Î±Ï€ÏŒÎ³ÎµÏ…Î¼Î± Ï„Î·Ï‚ Ï„Î­Ï„Î±ÏÏ„Î·Ï‚ Î·Î¼Î­ÏÎ±Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎºÎ±Î»ÏÏˆÎµÎ¹ Î­Î½Î± Î¸Î­Î¼Î± Ï„Î·Ï‚Î±ÏÎµÏƒÎºÎµÎ¯Î±Ï‚ "
#~ "ÏƒÎ±Ï‚. Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ Ï„Î¿ Î¸Î­Î¼Î± Ï€Î¿Ï… ÎµÏ€Î¹Î»Î­Î¾Î±Ï„Îµ ÏƒÏ„Î·Î½ Î±Î½Î±ÎºÎ¿Î¯Î½Ï‰ÏƒÎ· Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚ ÏÏƒÏ„Îµ "
#~ "Î¿Î¹ÏƒÏ…Î¼Î¼ÎµÏ„Î­Ï‡Î¿Î½Ï„ÎµÏ‚ Î½Î± Î¾Î­ÏÎ¿Ï…Î½ Ï„Î¹ Î½Î± Ï€ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î½."

#~ msgid ""
#~ "This phase of the course is a chance for participants to see Rust in "
#~ "action on a codebase they might be familiar with. You can choose from the "
#~ "topics already defined here, or plan your own."
#~ msgstr ""
#~ "Î‘Ï…Ï„Î® Î· Ï†Î¬ÏƒÎ· Ï„Î¿Ï… Î¼Î±Î¸Î®Î¼Î±Ï„Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î¼Î¹Î± ÎµÏ…ÎºÎ±Î¹ÏÎ¯Î± Î³Î¹Î± Ï„Î¿Ï…Ï‚ ÏƒÏ…Î¼Î¼ÎµÏ„Î­Ï‡Î¿Î½Ï„ÎµÏ‚ Î½Î± "
#~ "Î´Î¿Ï…Î½ Ï„Î· Rust ÏƒÏ„Î·Î½ Ï€ÏÎ¬Î¾Î·, ÏƒÎµ Î­Î½Î± Ï€ÏÏŒÏ„Î¶ÎµÎºÏ„ Î¼Îµ Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Î®Î´Î· "
#~ "ÎµÎ¾Î¿Î¹ÎºÎµÎ¹Ï‰Î¼Î­Î½Î¿Î¹. ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î¹Î±Î»Î­Î¾ÎµÏ„Îµ Î¸Î­Î¼Î±Ï„Î± Ï€Î¿Ï… Î­Ï‡Î¿Ï…Î¼Îµ Î®Î´Î· Ï€ÏÎ¿ÎµÏ„Î¿Î¹Î¼Î¬ÏƒÎµÎ¹, "
#~ "Î® ÎºÎ¬Ï„Î¹ Î´Î¹ÎºÏŒ ÏƒÎ±Ï‚."

#~ msgid "Some topics need additional preparation:"
#~ msgstr "ÎšÎ¬Ï€Î¿Î¹Î± Î¸Î­Î¼Î±Ï„Î± Î±Ï€Î±Î¹Ï„Î¿ÏÎ½ ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ Ï€ÏÎ¿ÎµÏ„Î¿Î¹Î¼Î±ÏƒÎ¯Î±."

#, fuzzy
#~ msgid "Rustup (Recommended)"
#~ msgstr "Rustup (Î£Ï…Î½Î¹ÏƒÏ„Î¬Ï„Î±Î¹)"

#, fuzzy
#~ msgid ""
#~ "You can follow the instructions to install cargo and rust compiler, among "
#~ "other standard ecosystem tools with the [rustup](https://rust-analyzer."
#~ "github.io/) tool, which is maintained by the Rust Foundation."
#~ msgstr ""
#~ "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î±ÎºÎ¿Î»Î¿Ï…Î¸Î®ÏƒÎµÏ„Îµ Ï„Î¹Ï‚ Î¿Î´Î·Î³Î¯ÎµÏ‚ Î³Î¹Î± Ï„Î·Î½ ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· Ï„Î¿Ï… "
#~ "Î¼ÎµÏ„Î±Î³Î»Ï‰Ï„Ï„Î¹ÏƒÏ„Î® Ï†Î¿ÏÏ„Î¯Î¿Ï… ÎºÎ±Î¹ ÏƒÎºÎ¿Ï…ÏÎ¹Î¬Ï‚, Î¼ÎµÏ„Î±Î¾Ï Î¬Î»Î»Ï‰Î½ Ï„Ï…Ï€Î¹ÎºÏÎ½ ÎµÏÎ³Î±Î»ÎµÎ¯Ï‰Î½ "
#~ "Î¿Î¹ÎºÎ¿ÏƒÏ…ÏƒÏ„Î®Î¼Î±Ï„Î¿Ï‚ Î¼Îµ Ï„Î¿ ÎµÏÎ³Î±Î»ÎµÎ¯Î¿ [rustup](https://rust-analyzer.github.io/), "
#~ "Ï„Î¿ Î¿Ï€Î¿Î¯Î¿ Î´Î¹Î±Ï„Î·ÏÎµÎ¯Ï„Î±Î¹ Î±Ï€ÏŒ Ï„Î¿ Rust Foundation."

#, fuzzy
#~ msgid "Package Managers"
#~ msgstr "Î”Î¹Î±Ï‡ÎµÎ¹ÏÎ¹ÏƒÏ„Î­Ï‚ Ï€Î±ÎºÎ­Ï„Ï‰Î½"

#, fuzzy
#~ msgid "Debian"
#~ msgstr "Debian"

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    fizzbuzz_to(20);   // Defined below, no forward declaration needed\n"
#~ "}\n"
#~ "\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // Corner case, early return\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // The last expression in a block is the return "
#~ "value\n"
#~ "}\n"
#~ "\n"
#~ "fn fizzbuzz(n: u32) -> () {  // No return value means returning the unit "
#~ "type `()`\n"
#~ "    match (is_divisible_by(n, 3), is_divisible_by(n, 5)) {\n"
#~ "        (true,  true)  => println!(\"fizzbuzz\"),\n"
#~ "        (true,  false) => println!(\"fizz\"),\n"
#~ "        (false, true)  => println!(\"buzz\"),\n"
#~ "        (false, false) => println!(\"{n}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn fizzbuzz_to(n: u32) {  // `-> ()` is normally omitted\n"
#~ "    for i in 1..=n {\n"
#~ "        fizzbuzz(i);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "fn fizzbuzz(n: u32) -> () { // Î§Ï‰ÏÎ¯Ï‚ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Ï„Î¹Î¼Î®Ï‚ ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® "
#~ "Ï„Î¿Ï… Ï„ÏÏ€Î¿Ï… Î¼Î¿Î½Î¬Î´Î±Ï‚ `()` Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ· (is_divisible_by(n, 3), "
#~ "is_divisible_by(n, 5)) { (Î±Î»Î·Î¸Î¹Î½ÏŒ, Î±Î»Î·Î¸Î¹Î½ÏŒ) => println!(\"fizzbuzz\"), "
#~ "(Î±Î»Î·Î¸Î­Ï‚, Î»Î¬Î¸Î¿Ï‚) => println!(\"fizz\"), (ÏˆÎµÏ…Î´Î­Ï‚, Î±Î»Î·Î¸Î­Ï‚) => println!"
#~ "(\"buzz\"), (ÏˆÎµÏÏ„Î¹ÎºÎ¿, ÏˆÎµÏ…Î´Î­Ï‚) => println!(\"{n}\"), } }"

#, fuzzy
#~ msgid ""
#~ "After looking at the exercises, you can look at the \\[solutions\\] "
#~ "provided."
#~ msgstr ""
#~ "Î‘Ï†Î¿Ï Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ Î±ÏƒÎºÎ®ÏƒÎµÎ¹Ï‚, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î¹Ï‚ \\[Î»ÏÏƒÎµÎ¹Ï‚\\] Ï€Î¿Ï… "
#~ "Ï€Î±ÏÎ­Ï‡Î¿Î½Ï„Î±Î¹."

#, fuzzy
#~ msgid ""
#~ "Note that since `println!` is a macro, `x` is not moved, even using the "
#~ "function like syntax of `println!(\"x: {}\", x)`"
#~ msgstr ""
#~ "Î£Î·Î¼ÎµÎ¹ÏÏƒÏ„Îµ ÏŒÏ„Î¹ ÎµÏ€ÎµÎ¹Î´Î® Ï„Î¿ \"println!\" ÎµÎ¯Î½Î±Î¹ Î¼Î±ÎºÏÎ¿ÎµÎ½Ï„Î¿Î»Î®, Ï„Î¿ \"x\" Î´ÎµÎ½ "
#~ "Î¼ÎµÏ„Î±ÎºÎ¹Î½ÎµÎ¯Ï„Î±Î¹, Î±ÎºÏŒÎ¼Î· ÎºÎ±Î¹ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· ÏŒÏ€Ï‰Ï‚ Î· ÏƒÏÎ½Ï„Î±Î¾Î· Ï„Î¿Ï… "
#~ "\"println!(\"x: {}\", x)\""

#, fuzzy
#~ msgid "Global state is managed with static and constant variables."
#~ msgstr ""
#~ "Î— Î´Î¹Î±Ï‡ÎµÎ¯ÏÎ¹ÏƒÎ· Ï„Î·Ï‚ Ï€Î±Î³ÎºÏŒÏƒÎ¼Î¹Î±Ï‚ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚ Î³Î¯Î½ÎµÏ„Î±Î¹ Î¼Îµ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ ÎºÎ±Î¹ ÏƒÏ„Î±Î¸ÎµÏÎ­Ï‚ "
#~ "Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚."

#, fuzzy
#~ msgid "You can declare compile-time constants:"
#~ msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Î´Î·Î»ÏÏƒÎµÏ„Îµ ÏƒÏ„Î±Î¸ÎµÏÎ­Ï‚ Ï‡ÏÏŒÎ½Î¿Ï… Î¼ÎµÏ„Î±Î³Î»ÏÏ„Ï„Î¹ÏƒÎ·Ï‚:"

#, fuzzy
#~ msgid "You can also declare static variables:"
#~ msgstr "ÎœÏ€Î¿ÏÎµÎ¯Ï„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Î´Î·Î»ÏÏƒÎµÏ„Îµ ÏƒÏ„Î±Ï„Î¹ÎºÎ­Ï‚ Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚:"

#, fuzzy
#~ msgid ""
#~ "We will look at mutating static data in the [chapter on Unsafe Rust](../"
#~ "unsafe.md)."
#~ msgstr ""
#~ "Î˜Î± ÎµÎ¾ÎµÏ„Î¬ÏƒÎ¿Ï…Î¼Îµ Ï„Î· Î¼ÎµÏ„Î¬Î»Î»Î±Î¾Î· ÏƒÏ„Î±Ï„Î¹ÎºÏÎ½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ ÏƒÏ„Î¿ \\[ÎºÎµÏ†Î¬Î»Î±Î¹Î¿ Î³Î¹Î± Ï„Î·Î½ ÎœÎ· "
#~ "Î±ÏƒÏ†Î±Î»Î® ÏƒÎºÎ¿Ï…ÏÎ¹Î¬\\] (../unsafe.md)."

#, fuzzy
#~ msgid "Potential for use-after-free."
#~ msgstr "Î”Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„Î± Ï‡ÏÎ®ÏƒÎ·Ï‚-Î¼ÎµÏ„Î¬-Î´Ï‰ÏÎµÎ¬Î½."

#, fuzzy
#~ msgid "The data was _moved_ from `s1` and `s1` is no longer accessible."
#~ msgstr ""
#~ "Î¤Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± _Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®Î¸Î·ÎºÎ±Î½_ Î±Ï€ÏŒ Ï„Î¿ `s1` ÎºÎ±Î¹ Ï„Î¿ `s1` Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Ï€Î»Î­Î¿Î½ "
#~ "Ï€ÏÎ¿ÏƒÎ²Î¬ÏƒÎ¹Î¼Î¿."

#, fuzzy
#~ msgid "A small book library,"
#~ msgstr "Iterators ÎºÎ±Î¹ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± (ÏƒÎºÎ»Î·ÏÏŒ)."

#, fuzzy
#~ msgid ""
#~ "`mut self`: same as above, but while the method owns the object, it can "
#~ "mutate it too. Complete ownership does not automatically mean mutability."
#~ msgstr ""
#~ "`mut self`: ÏŒÏ€Ï‰Ï‚ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰, Î±Î»Î»Î¬ ÎµÎ½Ï Î· Î¼Î­Î¸Î¿Î´Î¿Ï‚ ÎºÎ±Ï„Î­Ï‡ÎµÎ¹ Ï„Î¿ Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿, "
#~ "Î¼Ï€Î¿ÏÎµÎ¯ Î¼ÎµÏ„Î±Î»Î»Î¬Î¾Ï„Îµ Ï„Î¿ ÎºÎ±Î¹ ÎµÏƒÎµÎ¯Ï‚. Î— Ï€Î»Î®ÏÎ·Ï‚ Î¹Î´Î¹Î¿ÎºÏ„Î·ÏƒÎ¯Î± Î´ÎµÎ½ ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± "
#~ "Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏŒÏ„Î·Ï„Î±."

#, fuzzy
#~ msgid "You use `if` very similarly to how you would in other languages:"
#~ msgstr ""
#~ "Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Îµ Ï„Î¿ \"if\" Ï€Î¿Î»Ï Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Î±Ï…Ï„ÏŒ Ï€Î¿Ï… Î¸Î± ÎºÎ¬Î½Î±Ï„Îµ ÏƒÎµ Î¬Î»Î»ÎµÏ‚ "
#~ "Î³Î»ÏÏƒÏƒÎµÏ‚:"

#, fuzzy
#~ msgid ""
#~ "If you want to match a value against a pattern, you can use `if let`:"
#~ msgstr ""
#~ "Î•Î¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Ï„Î±Î¹ÏÎ¹Î¬Î¾ÎµÏ„Îµ Î¼Î¹Î± Ï„Î¹Î¼Î® Î¼Îµ Î­Î½Î± Î¼Î¿Ï„Î¯Î²Î¿, Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± "
#~ "Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Â«Î±Î½ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÏ„Î±Î¹Â»:"

#, fuzzy
#~ msgid ""
#~ "`if let` can be more concise than `match`, e.g., when only one case is "
#~ "interesting. In contrast, `match` requires all branches to be covered."
#~ msgstr ""
#~ "Î¤Î¿ Â«Î±Î½ Î±Ï‚Â» Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ Ï€Î¹Î¿ ÏƒÏ…Î½Î¿Ï€Ï„Î¹ÎºÏŒ Î±Ï€ÏŒ Ï„Î¿ Â«Ï„Î±Î¯ÏÎ¹Î±ÏƒÎ¼Î±Â», Ï€.Ï‡., ÏŒÏ„Î±Î½ "
#~ "Î¼ÏŒÎ½Î¿ Î¼Î¯Î± Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· ÎµÎ¯Î½Î±Î¹ ÎµÎ½Î´Î¹Î±Ï†Î­ÏÎ¿Ï…ÏƒÎ±. Î‘Î½Ï„Î¯Î¸ÎµÏ„Î±, Ï„Î¿ \"match\" Î±Ï€Î±Î¹Ï„ÎµÎ¯ Î½Î± "
#~ "ÎºÎ±Î»ÏÏ€Ï„Î¿Î½Ï„Î±Î¹ ÏŒÎ»Î¿Î¹ Î¿Î¹ ÎºÎ»Î¬Î´Î¿Î¹."

#, fuzzy
#~ msgid ""
#~ "For the similar use case consider demonstrating a newly stabilized [`let "
#~ "else`](https://github.com/rust-lang/rust/pull/93628) feature."
#~ msgstr ""
#~ "Î“Î¹Î± Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Ï€ÎµÏÎ¯Ï€Ï„Ï‰ÏƒÎ· Ï‡ÏÎ®ÏƒÎ·Ï‚, ÎµÎ¾ÎµÏ„Î¬ÏƒÏ„Îµ Ï„Î¿ ÎµÎ½Î´ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ Î½Î± ÎµÏ€Î¹Î´ÎµÎ¯Î¾ÎµÏ„Îµ Î¼Î¹Î± "
#~ "Î½Î­Î± ÏƒÏ„Î±Î¸ÎµÏÎ¿Ï€Î¿Î¹Î·Î¼Î­Î½Î· Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± [`let else`](https://github.com/rust-lang/"
#~ "rust/pull/93628)."

#, fuzzy
#~ msgid "The `while` keyword works very similar to other languages:"
#~ msgstr "Î— Î»Î­Î¾Î·-ÎºÎ»ÎµÎ¹Î´Î¯ \"while\" Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Ï€Î¿Î»Ï Ï€Î±ÏÏŒÎ¼Î¿Î¹Î± Î¼Îµ Î¬Î»Î»ÎµÏ‚ Î³Î»ÏÏƒÏƒÎµÏ‚:"

#, fuzzy
#~ msgid "`for` expressions"
#~ msgstr "ÎµÎºÏ†ÏÎ¬ÏƒÎµÎ¹Ï‚ Â«Î³Î¹Î±Â»."

#, fuzzy
#~ msgid ""
#~ "If you need to mutate the data inside an `Rc`, you will need to wrap the "
#~ "data in a type such as [`Cell` or `RefCell`](../concurrency/shared_state/"
#~ "arc.md)."
#~ msgstr ""
#~ "Î•Î¬Î½ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Î¼ÎµÏ„Î±Î»Î»Î¬Î¾ÎµÏ„Îµ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î¼Î­ÏƒÎ± ÏƒÎµ Î­Î½Î± \"Rc\", Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± "
#~ "Ï„Ï…Î»Î¯Î¾ÎµÏ„Îµ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î¼Î­ÏƒÎ± Î­Î½Î±Î½ Ï„ÏÏ€Î¿ ÏŒÏ€Ï‰Ï‚ [`Cell` Î® `RefCell`](../"
#~ "concurrency/shared_state/arc.md). Î‘Î½Î±Ï„ÏÎ­Î¾Ï„Îµ ÏƒÏ„Î¿ [`Arc`](https://doc.rust-"
#~ "lang.org/std/sync/struct.Mutex.html) ÎµÎ¬Î½ Î²ÏÎ¯ÏƒÎºÎµÏƒÏ„Îµ ÏƒÎµ Î­Î½Î± multi-threaded "
#~ "ÏƒÏ…Î¼Ï†ÏÎ±Î¶ÏŒÎ¼ÎµÎ½Î±."

#, fuzzy
#~ msgid "Like C++'s `std::shared_ptr`."
#~ msgstr ""
#~ "Î¤Î¿ \"clone\" ÎµÎ¯Î½Î±Î¹ Ï†Î¸Î·Î½ÏŒ: Î´Î·Î¼Î¹Î¿Ï…ÏÎ³ÎµÎ¯ Î­Î½Î±Î½ Î´ÎµÎ¯ÎºÏ„Î· ÏƒÏ„Î·Î½ Î¯Î´Î¹Î± ÎºÎ±Ï„Î±Î½Î¿Î¼Î® ÎºÎ±Î¹ "
#~ "Î±Ï…Î¾Î¬Î½ÎµÎ¹ Ï„Î¿ Ï€Î»Î®Î¸Î¿Ï‚ Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚."

#, fuzzy
#~ msgid "The module content can be omitted:"
#~ msgstr "Î¤Î¿ Ï€ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ Ï„Î·Ï‚ ÎµÎ½ÏŒÏ„Î·Ï„Î±Ï‚ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Ï€Î±ÏÎ±Î»ÎµÎ¹Ï†Î¸ÎµÎ¯:"

#, fuzzy
#~ msgid "The `garden` module content is found at:"
#~ msgstr "Î¤Î¿ Ï€ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿ Ï„Î·Ï‚ ÎµÎ½ÏŒÏ„Î·Ï„Î±Ï‚ Â«gardenÂ» Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ ÏƒÏ„Î· Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ·:"

#, fuzzy
#~ msgid "`src/garden.rs` (modern Rust 2018 style)"
#~ msgstr "`src/garden.rs` (Î¼Î¿Î½Ï„Î­ÏÎ½Î¿ ÏƒÏ„Ï…Î» Rust 2018)"

#, fuzzy
#~ msgid "`src/garden/mod.rs` (older Rust 2015 style)"
#~ msgstr "`src/garden/mod.rs` (Ï€Î±Î»Î±Î¹ÏŒÏ„ÎµÏÎ¿ ÏƒÏ„Ï…Î» Rust 2015)"

#, fuzzy
#~ msgid "Similarly, a `garden::vegetables` module can be found at:"
#~ msgstr ""
#~ "ÎŸÎ¼Î¿Î¯Ï‰Ï‚, Î¼Î¹Î± ÎµÎ½ÏŒÏ„Î·Ï„Î± Â«garden:: Î»Î±Ï‡Î±Î½Î¹ÎºÎ¬Â» Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î²ÏÎµÎ¸ÎµÎ¯ ÏƒÏ„Î· Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ·:"

#, fuzzy
#~ msgid "`src/garden/vegetables.rs` (modern Rust 2018 style)"
#~ msgstr "`src/garden/vegetables.rs` (Î¼Î¿Î½Ï„Î­ÏÎ½Î¿ ÏƒÏ„Ï…Î» Rust 2018)"

#, fuzzy
#~ msgid "`src/garden/vegetables/mod.rs` (older Rust 2015 style)"
#~ msgstr "`src/garden/vegetables/mod.rs` (Ï€Î±Î»Î±Î¹ÏŒÏ„ÎµÏÎ¿ ÏƒÏ„Ï…Î» Rust 2015)"

#, fuzzy
#~ msgid ""
#~ "Copy the following code to <https://play.rust-lang.org/> and implement "
#~ "the function:"
#~ msgstr ""
#~ "Î‘Î½Ï„Î¹Î³ÏÎ¬ÏˆÏ„Îµ Ï„Î¿Î½ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÏÎ´Î¹ÎºÎ± ÏƒÏ„Î¿ <https://play.rust-lang.org/> ÎºÎ±Î¹ "
#~ "ÎµÏ†Î±ÏÎ¼ÏŒÏƒÏ„Îµ Ï„Î¿ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±:"

#, fuzzy
#~ msgid "`move` closures only implement `FnOnce`."
#~ msgstr "Î¤Î± ÎºÎ»ÎµÎ¹ÏƒÎ¯Î¼Î±Ï„Î± Â«Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚Â» ÎµÏ†Î±ÏÎ¼ÏŒÎ¶Î¿Ï…Î½ Î¼ÏŒÎ½Î¿ Ï„Î¿ Â«FnOnceÂ»."

#, fuzzy
#~ msgid ""
#~ "We've seen how a function can take arguments which implement a trait:"
#~ msgstr ""
#~ "Î•Î¯Î´Î±Î¼Îµ Ï€ÏÏ‚ Î¼Î¹Î± ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î»Î¬Î²ÎµÎ¹ Î¿ÏÎ¯ÏƒÎ¼Î±Ï„Î± Ï€Î¿Ï… Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Î­Î½Î± "
#~ "Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ:"

#, fuzzy
#~ msgid ""
#~ "However, how can we store a collection of mixed types which implement "
#~ "`Display`?"
#~ msgstr ""
#~ "Î©ÏƒÏ„ÏŒÏƒÎ¿, Ï€ÏÏ‚ Î¼Ï€Î¿ÏÎ¿ÏÎ¼Îµ Î½Î± Î±Ï€Î¿Î¸Î·ÎºÎµÏÏƒÎ¿Ï…Î¼Îµ Î¼Î¹Î± ÏƒÏ…Î»Î»Î¿Î³Î® Î¼Î¹ÎºÏ„ÏÎ½ Ï„ÏÏ€Ï‰Î½ Ï€Î¿Ï… "
#~ "Ï…Î»Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î¿ \"Display\";"

#, fuzzy
#~ msgid "For this, we need _trait objects_:"
#~ msgstr "Î“Î¹Î± Î±Ï…Ï„ÏŒ, Ï‡ÏÎµÎ¹Î±Î¶ÏŒÎ¼Î±ÏƒÏ„Îµ _trait Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î±_:"

#, fuzzy
#~ msgid ""
#~ "Similarly, you need a trait object if you want to return different types "
#~ "implementing a trait:"
#~ msgstr ""
#~ "ÎŸÎ¼Î¿Î¯Ï‰Ï‚, Ï‡ÏÎµÎ¹Î¬Î¶ÎµÏƒÏ„Îµ Î­Î½Î± Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏÎ½ ÎµÎ¬Î½ Î¸Î­Î»ÎµÏ„Îµ Î½Î± "
#~ "ÎµÏ€Î¹ÏƒÏ„ÏÎ­ÏˆÎµÏ„Îµ Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ­Ï‚ Ï„Î¹Î¼Î­Ï‚ Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÎµÎ½ÏŒÏ‚ Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¿Ï:"

#, fuzzy
#~ msgid ""
#~ "You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/"
#~ "std/ffi/) module, particular for [`CStr`](https://doc.rust-lang.org/std/"
#~ "ffi/struct.CStr.html) and [`CString`](https://doc.rust-lang.org/std/ffi/"
#~ "struct.CString.html) types which are used to hold NUL-terminated strings "
#~ "coming from C. The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) "
#~ "also has a very useful chapter about FFI."
#~ msgstr ""
#~ "Î˜Î± Î¸Î­Î»ÎµÏ„Îµ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î½Î± Ï€ÎµÏÎ¹Î·Î³Î·Î¸ÎµÎ¯Ï„Îµ ÏƒÏ„Î· Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¹ÎºÎ® Î¼Î¿Î½Î¬Î´Î± [`std::ffi`]"
#~ "(https://doc.rust-lang.org/std/ffi/), ÎµÎ¹Î´Î¹ÎºÎ¬ Î³Î¹Î± Ï„Î¿ [`CStr`](https://doc."
#~ "rust-lang.org/std/ffi/struct.CStr.html) ÎºÎ±Î¹ Ï„ÏÏ€Î¿Ï…Ï‚ [`CString`](https://"
#~ "doc.rust-lang.org/std/ffi/struct.CString.html) Ï€Î¿Ï… Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ½Ï„Î±Î¹ Î³Î¹Î± "
#~ "Ï„Î· Î´Î¹Î±Ï„Î®ÏÎ·ÏƒÎ· ÏƒÏ…Î¼Î²Î¿Î»Î¿ÏƒÎµÎ¹ÏÏÎ½ Î¼Îµ Ï„ÎµÏÎ¼Î±Ï„Î¹ÏƒÎ¼ÏŒ NUL Ï€Î¿Ï… Ï€ÏÎ¿Î­ÏÏ‡Î¿Î½Ï„Î±Î¹ Î±Ï€ÏŒ Î“. Î¤Î¿ "
#~ "[Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) Î­Ï‡ÎµÎ¹ ÎµÏ€Î¯ÏƒÎ·Ï‚ Î­Î½Î± "
#~ "Ï€Î¿Î»Ï Ï‡ÏÎ®ÏƒÎ¹Î¼Î¿ ÎºÎµÏ†Î¬Î»Î±Î¹Î¿ Î³Î¹Î± Ï„Î¿ FFI."

#, fuzzy
#~ msgid "Welcome to Day 4"
#~ msgstr "ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ ÏƒÏ„Î·Î½ Î—Î¼Î­ÏÎ± 4"

#, fuzzy
#~ msgid "Fearless Concurrency"
#~ msgstr "Î‘Ï„ÏÏŒÎ¼Î·Ï„Î¿Ï‚ Î£Ï…Î³Ï‡ÏÎ¿Î½Î¹ÏƒÎ¼ÏŒÏ‚"

#, fuzzy
#~ msgid "Day 4 Morning Exercise"
#~ msgstr "4Î· Î·Î¼Î­ÏÎ± Î ÏÏ‰Î¹Î½Î® Î¬ÏƒÎºÎ·ÏƒÎ·"
