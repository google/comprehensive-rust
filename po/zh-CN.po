msgid ""
msgstr ""
"Project-Id-Version: Comprehensive Rust 🦀\n"
"POT-Creation-Date: 2024-01-25T10:09:28-08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: Language zh-Hans\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/SUMMARY.md src/index.md
msgid "Welcome to Comprehensive Rust 🦀"
msgstr "欢迎来到 Comprehensive Rust 🦀"

#: src/SUMMARY.md src/running-the-course.md
msgid "Running the Course"
msgstr "授课"

#: src/SUMMARY.md src/running-the-course/course-structure.md
msgid "Course Structure"
msgstr "课程结构"

#: src/SUMMARY.md src/running-the-course/keyboard-shortcuts.md
msgid "Keyboard Shortcuts"
msgstr "键盘快捷键"

#: src/SUMMARY.md src/running-the-course/translations.md
msgid "Translations"
msgstr "翻译"

#: src/SUMMARY.md src/cargo.md
msgid "Using Cargo"
msgstr "使用 Cargo"

#: src/SUMMARY.md
msgid "Rust Ecosystem"
msgstr "Rust 生态系统"

#: src/SUMMARY.md
msgid "Code Samples"
msgstr "代码示例"

#: src/SUMMARY.md
msgid "Running Cargo Locally"
msgstr "在本地运行 Cargo"

#: src/SUMMARY.md
msgid "Day 1: Morning"
msgstr "第一天：上午"

#: src/SUMMARY.md
msgid "Welcome"
msgstr "欢迎"

#: src/SUMMARY.md src/hello-world.md src/hello-world/hello-world.md
msgid "Hello, World"
msgstr "Hello, World"

#: src/SUMMARY.md src/hello-world/what-is-rust.md
msgid "What is Rust?"
msgstr "什么是 Rust？"

#: src/SUMMARY.md src/hello-world/benefits.md
msgid "Benefits of Rust"
msgstr "Rust 的优势"

#: src/SUMMARY.md src/hello-world/playground.md
msgid "Playground"
msgstr "Playground"

#: src/SUMMARY.md src/types-and-values.md
msgid "Types and Values"
msgstr "类型和值"

#: src/SUMMARY.md src/types-and-values/variables.md
msgid "Variables"
msgstr "变量"

#: src/SUMMARY.md src/types-and-values/values.md
msgid "Values"
msgstr "值"

#: src/SUMMARY.md src/types-and-values/arithmetic.md
msgid "Arithmetic"
msgstr "算术"

#: src/SUMMARY.md src/types-and-values/strings.md
msgid "Strings"
msgstr "字符串"

#: src/SUMMARY.md src/types-and-values/inference.md
msgid "Type Inference"
msgstr "类型推导"

#: src/SUMMARY.md src/types-and-values/exercise.md
msgid "Exercise: Fibonacci"
msgstr "练习：Fibonacci"

#: src/SUMMARY.md src/types-and-values/solution.md
#: src/control-flow-basics/solution.md src/tuples-and-arrays/solution.md
#: src/references/solution.md src/user-defined-types/solution.md
#: src/pattern-matching/solution.md src/methods-and-traits/solution.md
#: src/generics/solution.md src/std-types/solution.md
#: src/std-traits/solution.md src/memory-management/solution.md
#: src/smart-pointers/solution.md src/borrowing/solution.md
#: src/slices-and-lifetimes/solution.md src/iterators/solution.md
#: src/modules/solution.md src/testing/solution.md
#: src/error-handling/solution.md src/unsafe-rust/solution.md
msgid "Solution"
msgstr "解答"

#: src/SUMMARY.md src/control-flow-basics.md
msgid "Control Flow Basics"
msgstr "控制流基础"

#: src/SUMMARY.md src/control-flow-basics/conditionals.md
msgid "Conditionals"
msgstr "条件控制"

#: src/SUMMARY.md src/control-flow-basics/loops.md
msgid "Loops"
msgstr "循环控制"

#: src/SUMMARY.md src/control-flow-basics/break-continue.md
msgid "`break` and `continue`"
msgstr "`break` 和 `continue`"

#: src/SUMMARY.md src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks and Scopes"
msgstr "代码块和作用域"

#: src/SUMMARY.md src/control-flow-basics/functions.md
msgid "Functions"
msgstr "函数"

#: src/SUMMARY.md src/control-flow-basics/macros.md
msgid "Macros"
msgstr "宏"

#: src/SUMMARY.md src/control-flow-basics/exercise.md
msgid "Exercise: Collatz Sequence"
msgstr "练习：考拉兹序列"

#: src/SUMMARY.md
msgid "Day 1: Afternoon"
msgstr "第一天：下午"

#: src/SUMMARY.md src/tuples-and-arrays.md
#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuples and Arrays"
msgstr "元组和数组"

#: src/SUMMARY.md src/tuples-and-arrays/iteration.md
msgid "Array Iteration"
msgstr "数组迭代"

#: src/SUMMARY.md src/tuples-and-arrays/match.md src/pattern-matching.md
msgid "Pattern Matching"
msgstr "模式匹配"

#: src/SUMMARY.md src/tuples-and-arrays/destructuring.md
#: src/pattern-matching/destructuring.md
msgid "Destructuring"
msgstr "解构"

#: src/SUMMARY.md src/tuples-and-arrays/exercise.md
msgid "Exercise: Nested Arrays"
msgstr "练习：嵌套数组"

#: src/SUMMARY.md src/references.md
msgid "References"
msgstr "引用"

#: src/SUMMARY.md src/references/shared.md
msgid "Shared References"
msgstr "共享引用"

#: src/SUMMARY.md src/references/exclusive.md
msgid "Exclusive References"
msgstr "独占引用"

#: src/SUMMARY.md src/references/exercise.md
msgid "Exercise: Geometry"
msgstr "练习：几何图形"

#: src/SUMMARY.md src/user-defined-types.md
msgid "User-Defined Types"
msgstr "用户定义的类型"

#: src/SUMMARY.md src/user-defined-types/named-structs.md
msgid "Named Structs"
msgstr "结构体"

#: src/SUMMARY.md src/user-defined-types/tuple-structs.md
msgid "Tuple Structs"
msgstr "元组结构体"

#: src/SUMMARY.md src/user-defined-types/enums.md
#: src/pattern-matching/destructuring.md
msgid "Enums"
msgstr "枚举"

#: src/SUMMARY.md src/user-defined-types/static-and-const.md
msgid "Static and Const"
msgstr "静态变量与常量"

#: src/SUMMARY.md src/user-defined-types/aliases.md
msgid "Type Aliases"
msgstr "类型别名"

#: src/SUMMARY.md src/user-defined-types/exercise.md
msgid "Exercise: Elevator Events"
msgstr "练习：电梯事件"

#: src/SUMMARY.md
msgid "Day 2: Morning"
msgstr "第二天：上午"

#: src/SUMMARY.md src/pattern-matching/let-control-flow.md
msgid "Let Control Flow"
msgstr "`let` 控制流"

#: src/SUMMARY.md src/pattern-matching/exercise.md
msgid "Exercise: Expression Evaluation"
msgstr "练习：表达式求值"

#: src/SUMMARY.md src/methods-and-traits.md
msgid "Methods and Traits"
msgstr "方法和特征"

#: src/SUMMARY.md src/methods-and-traits/methods.md
msgid "Methods"
msgstr "方法"

#: src/SUMMARY.md src/methods-and-traits/traits.md
msgid "Traits"
msgstr "特征（Trait）"

#: src/SUMMARY.md src/methods-and-traits/deriving.md
msgid "Deriving"
msgstr "派生特征"

#: src/SUMMARY.md src/methods-and-traits/exercise.md
msgid "Exercise: Generic Logger"
msgstr "练习：通用日志"

#: src/SUMMARY.md src/generics.md
msgid "Generics"
msgstr "泛型"

#: src/SUMMARY.md src/generics/generic-functions.md
msgid "Generic Functions"
msgstr "泛型函数"

#: src/SUMMARY.md src/generics/generic-data.md
msgid "Generic Data Types"
msgstr "泛型类型"

#: src/SUMMARY.md src/generics/trait-bounds.md
msgid "Trait Bounds"
msgstr "特征边界"

#: src/SUMMARY.md src/generics/impl-trait.md
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md src/generics/exercise.md
msgid "Exercise: Generic `min`"
msgstr "练习：通用 `min` 函数"

#: src/SUMMARY.md
msgid "Day 2: Afternoon"
msgstr "第二天：下午"

#: src/SUMMARY.md src/std-types.md
msgid "Standard Library Types"
msgstr "标准库类型"

#: src/SUMMARY.md src/std-types/std.md
msgid "Standard Library"
msgstr "标准库"

#: src/SUMMARY.md src/std-types/docs.md
msgid "Documentation"
msgstr "文档"

#: src/SUMMARY.md
msgid "`Option`"
msgstr "`Option`"

#: src/SUMMARY.md
msgid "`Result`"
msgstr "`Result`"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "`String`"
msgstr "String"

#: src/SUMMARY.md src/std-types/vec.md
msgid "`Vec`"
msgstr "`Vec`"

#: src/SUMMARY.md src/std-types/hashmap.md src/bare-metal/no_std.md
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md src/std-types/exercise.md
msgid "Exercise: Counter"
msgstr "练习：计数器"

#: src/SUMMARY.md src/std-traits.md
msgid "Standard Library Traits"
msgstr "标准库特征"

#: src/SUMMARY.md src/std-traits/comparisons.md src/async.md
msgid "Comparisons"
msgstr "比较"

#: src/SUMMARY.md src/std-traits/operators.md
msgid "Operators"
msgstr "运算符"

#: src/SUMMARY.md src/std-traits/from-and-into.md
msgid "`From` and `Into`"
msgstr "`From` 和 `Into`"

#: src/SUMMARY.md src/std-traits/casting.md
msgid "Casting"
msgstr "类型转换"

#: src/SUMMARY.md src/std-traits/read-and-write.md
msgid "`Read` and `Write`"
msgstr "`Read` 和 `Write`"

#: src/SUMMARY.md
msgid "`Default`, struct update syntax"
msgstr "`Default`，结构体更新语法"

#: src/SUMMARY.md src/std-traits/closures.md
msgid "Closures"
msgstr "闭包"

#: src/SUMMARY.md src/std-traits/exercise.md
msgid "Exercise: ROT13"
msgstr "练习：ROT13"

#: src/SUMMARY.md
msgid "Day 3: Morning"
msgstr "第三天：上午"

#: src/SUMMARY.md src/memory-management.md
msgid "Memory Management"
msgstr "内存管理"

#: src/SUMMARY.md src/memory-management/review.md
msgid "Review of Program Memory"
msgstr "回顾：程序的内存分配"

#: src/SUMMARY.md src/memory-management/approaches.md
msgid "Approaches to Memory Management"
msgstr "内存管理方法"

#: src/SUMMARY.md src/memory-management/ownership.md
msgid "Ownership"
msgstr "所有权"

#: src/SUMMARY.md src/memory-management/move.md
msgid "Move Semantics"
msgstr "移动语义"

#: src/SUMMARY.md
msgid "`Clone`"
msgstr "`Clone`"

#: src/SUMMARY.md src/memory-management/copy-types.md
msgid "Copy Types"
msgstr "复合类型"

#: src/SUMMARY.md
msgid "`Drop`"
msgstr "`Drop`"

#: src/SUMMARY.md src/memory-management/exercise.md
msgid "Exercise: Builder Type"
msgstr "练习：构建器类型"

#: src/SUMMARY.md src/smart-pointers.md
msgid "Smart Pointers"
msgstr "智能指针"

#: src/SUMMARY.md src/smart-pointers/box.md
#: src/android/interoperability/cpp/type-mapping.md
msgid "`Box<T>`"
msgstr "`Box<T>`"

#: src/SUMMARY.md src/smart-pointers/rc.md
msgid "`Rc`"
msgstr "`Rc`"

#: src/SUMMARY.md src/smart-pointers/trait-objects.md
msgid "Trait Objects"
msgstr "特征对象"

#: src/SUMMARY.md src/smart-pointers/exercise.md
msgid "Exercise: Binary Tree"
msgstr "练习：二叉树"

#: src/SUMMARY.md
msgid "Day 3: Afternoon"
msgstr "第三天：下午"

#: src/SUMMARY.md src/borrowing.md
msgid "Borrowing"
msgstr "借用"

#: src/SUMMARY.md src/borrowing/shared.md
msgid "Borrowing a Value"
msgstr "借用值"

#: src/SUMMARY.md src/borrowing/borrowck.md
msgid "Borrow Checking"
msgstr "借用检查"

#: src/SUMMARY.md src/borrowing/interior-mutability.md
msgid "Interior Mutability"
msgstr "内部可变性"

#: src/SUMMARY.md src/borrowing/exercise.md
msgid "Exercise: Health Statistics"
msgstr "练习：健康统计"

#: src/SUMMARY.md src/slices-and-lifetimes.md
msgid "Slices and Lifetimes"
msgstr "切片与生命周期"

#: src/SUMMARY.md
msgid "Slices: `&[T]`"
msgstr "切片：`&[T]`"

#: src/SUMMARY.md src/slices-and-lifetimes/str.md
msgid "String References"
msgstr "字符串引用"

#: src/SUMMARY.md src/slices-and-lifetimes/lifetime-annotations.md
msgid "Lifetime Annotations"
msgstr "生命周期注解"

#: src/SUMMARY.md
msgid "Lifetime Elision"
msgstr "生命周期省略"

#: src/SUMMARY.md
msgid "Struct Lifetimes"
msgstr "结构体生命周期"

#: src/SUMMARY.md src/slices-and-lifetimes/exercise.md
msgid "Exercise: Protobuf Parsing"
msgstr "练习：Protobuf 解析"

#: src/SUMMARY.md
msgid "Day 4: Morning"
msgstr "第四天：上午"

#: src/SUMMARY.md src/iterators.md
msgid "Iterators"
msgstr "迭代器"

#: src/SUMMARY.md src/iterators/iterator.md src/bare-metal/no_std.md
msgid "`Iterator`"
msgstr "`Iterator`"

#: src/SUMMARY.md src/iterators/intoiterator.md
msgid "`IntoIterator`"
msgstr "`IntoIterator`"

#: src/SUMMARY.md
msgid "`FromIterator`"
msgstr "`FromIterator`"

#: src/SUMMARY.md src/iterators/exercise.md
msgid "Exercise: Iterator Method Chaining"
msgstr "练习：迭代器方法链"

#: src/SUMMARY.md src/modules.md src/modules/modules.md
msgid "Modules"
msgstr "模块"

#: src/SUMMARY.md src/modules/filesystem.md
msgid "Filesystem Hierarchy"
msgstr "文件系统层级结构"

#: src/SUMMARY.md src/modules/visibility.md
msgid "Visibility"
msgstr "可见性"

#: src/SUMMARY.md
msgid "`use`, `super`, `self`"
msgstr "`use`、`super`、`self`"

#: src/SUMMARY.md src/modules/exercise.md
msgid "Exercise: Modules for a GUI Library"
msgstr "练习：面向 GUI 库的模块"

#: src/SUMMARY.md src/testing.md src/chromium/testing.md
msgid "Testing"
msgstr "测试"

#: src/SUMMARY.md
msgid "Test Modules"
msgstr "测试模块"

#: src/SUMMARY.md src/testing/other.md
msgid "Other Types of Tests"
msgstr "其他类型的测试"

#: src/SUMMARY.md src/testing/useful-crates.md
msgid "Useful Crates"
msgstr "实用 Crate"

#: src/SUMMARY.md src/testing/googletest.md
msgid "GoogleTest"
msgstr "GoogleTest"

#: src/SUMMARY.md src/testing/mocking.md
msgid "Mocking"
msgstr "模拟"

#: src/SUMMARY.md src/testing/lints.md
msgid "Compiler Lints and Clippy"
msgstr "编译器 Lint 和 Clippy"

#: src/SUMMARY.md src/testing/exercise.md
msgid "Exercise: Luhn Algorithm"
msgstr "练习：卢恩算法"

#: src/SUMMARY.md
msgid "Day 4: Afternoon"
msgstr "第四天：下午"

#: src/SUMMARY.md src/error-handling.md
msgid "Error Handling"
msgstr "错误处理"

#: src/SUMMARY.md src/error-handling/panics.md
msgid "Panics"
msgstr "Panics"

#: src/SUMMARY.md src/error-handling/try.md
msgid "Try Operator"
msgstr "尝试运算符"

#: src/SUMMARY.md src/error-handling/try-conversions.md
msgid "Try Conversions"
msgstr "尝试转换"

#: src/SUMMARY.md
msgid "`Error` Trait"
msgstr "`Error` 特征"

#: src/SUMMARY.md src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror` and `anyhow`"
msgstr "`thiserror` 和 `anyhow`"

#: src/SUMMARY.md
msgid "Exercise: Rewriting with `Result`"
msgstr "练习：使用 `Result` 进行重写"

#: src/SUMMARY.md src/unsafe-rust.md src/unsafe-rust/unsafe.md
msgid "Unsafe Rust"
msgstr "不安全 Rust"

#: src/SUMMARY.md
msgid "Unsafe"
msgstr "Unsafe"

#: src/SUMMARY.md src/unsafe-rust/dereferencing.md
msgid "Dereferencing Raw Pointers"
msgstr "解引用裸指针"

#: src/SUMMARY.md src/unsafe-rust/mutable-static.md
msgid "Mutable Static Variables"
msgstr "可变的静态变量"

#: src/SUMMARY.md src/unsafe-rust/unions.md
msgid "Unions"
msgstr "联合体"

#: src/SUMMARY.md src/unsafe-rust/unsafe-functions.md
msgid "Unsafe Functions"
msgstr "Unsafe 函数"

#: src/SUMMARY.md
msgid "Unsafe Traits"
msgstr "Unsafe 特征"

#: src/SUMMARY.md
msgid "Exercise: FFI Wrapper"
msgstr "练习：FFI 封装容器"

#: src/SUMMARY.md src/bare-metal/android.md
msgid "Android"
msgstr "Android"

#: src/SUMMARY.md src/android/setup.md src/chromium/setup.md
msgid "Setup"
msgstr "设置"

#: src/SUMMARY.md src/android/build-rules.md
msgid "Build Rules"
msgstr "构建规则"

#: src/SUMMARY.md
msgid "Binary"
msgstr "可执行文件"

#: src/SUMMARY.md
msgid "Library"
msgstr "库"

#: src/SUMMARY.md src/android/aidl.md
msgid "AIDL"
msgstr "AIDL"

#: src/SUMMARY.md
msgid "Interface"
msgstr "接口"

#: src/SUMMARY.md
msgid "Implementation"
msgstr "实现"

#: src/SUMMARY.md
msgid "Server"
msgstr "服务器"

#: src/SUMMARY.md src/android/aidl/deploy.md
msgid "Deploy"
msgstr "部署"

#: src/SUMMARY.md
msgid "Client"
msgstr "客户端"

#: src/SUMMARY.md src/android/aidl/changing.md
msgid "Changing API"
msgstr "更改 API"

#: src/SUMMARY.md src/android/logging.md src/bare-metal/aps/logging.md
msgid "Logging"
msgstr "日志记录"

#: src/SUMMARY.md src/android/interoperability.md
msgid "Interoperability"
msgstr "互操作性"

#: src/SUMMARY.md
msgid "With C"
msgstr "与 C 语言交互"

#: src/SUMMARY.md
msgid "Calling C with Bindgen"
msgstr "使用 Bindgen 调用 C 语言"

#: src/SUMMARY.md
msgid "Calling Rust from C"
msgstr "从 C 语言调用 Rust 语言"

#: src/SUMMARY.md src/android/interoperability/cpp.md
msgid "With C++"
msgstr "与 C++ 交互"

#: src/SUMMARY.md src/android/interoperability/cpp/bridge.md
msgid "The Bridge Module"
msgstr "桥接模块"

#: src/SUMMARY.md
msgid "Rust Bridge"
msgstr "Rust 桥接"

#: src/SUMMARY.md src/android/interoperability/cpp/generated-cpp.md
msgid "Generated C++"
msgstr "生成的 C++ 代码"

#: src/SUMMARY.md
msgid "C++ Bridge"
msgstr "C++ 桥接"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-types.md
msgid "Shared Types"
msgstr "共享类型"

#: src/SUMMARY.md src/android/interoperability/cpp/shared-enums.md
msgid "Shared Enums"
msgstr "共享枚举"

#: src/SUMMARY.md src/android/interoperability/cpp/rust-result.md
msgid "Rust Error Handling"
msgstr "Rust 错误处理"

#: src/SUMMARY.md src/android/interoperability/cpp/cpp-exception.md
msgid "C++ Error Handling"
msgstr "C++ 错误处理"

#: src/SUMMARY.md src/android/interoperability/cpp/type-mapping.md
msgid "Additional Types"
msgstr "其他类型"

#: src/SUMMARY.md
msgid "Building for Android: C++"
msgstr "为 Android 构建：C++"

#: src/SUMMARY.md
msgid "Building for Android: Genrules"
msgstr "为 Android 构建：Genrule"

#: src/SUMMARY.md
msgid "Building for Android: Rust"
msgstr "为 Android 构建：Rust"

#: src/SUMMARY.md
msgid "With Java"
msgstr "与 Java 交互"

#: src/SUMMARY.md src/exercises/android/morning.md
#: src/exercises/bare-metal/morning.md src/exercises/bare-metal/afternoon.md
#: src/exercises/concurrency/morning.md src/exercises/concurrency/afternoon.md
msgid "Exercises"
msgstr "习题"

#: src/SUMMARY.md
msgid "Chromium"
msgstr "Chromium"

#: src/SUMMARY.md src/chromium/cargo.md
msgid "Comparing Chromium and Cargo Ecosystems"
msgstr "Chromium 和 Cargo 的生态对比"

#: src/SUMMARY.md
msgid "Policy"
msgstr "政策"

#: src/SUMMARY.md
msgid "Unsafe Code"
msgstr "不安全代码"

#: src/SUMMARY.md src/chromium/build-rules/depending.md
msgid "Depending on Rust Code from Chromium C++"
msgstr "在 Chromium C++ 中导入 Rust 代码"

#: src/SUMMARY.md src/chromium/build-rules/vscode.md
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: src/SUMMARY.md src/exercises/chromium/third-party.md
msgid "Exercise"
msgstr "练习"

#: src/SUMMARY.md src/chromium/testing/rust-gtest-interop.md
msgid "`rust_gtest_interop` Library"
msgstr "`rust_gtest_interop` 库"

#: src/SUMMARY.md src/chromium/testing/build-gn.md
msgid "GN Rules for Rust Tests"
msgstr "Rust 测试的 GN 规则"

#: src/SUMMARY.md src/chromium/testing/chromium-import-macro.md
msgid "`chromium::import!` Macro"
msgstr "`chromium::import!` 宏"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp.md
msgid "Interoperability with C++"
msgstr "与 C++ 的互操作性"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Example Bindings"
msgstr "绑定示例"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Limitations of CXX"
msgstr "CXX 的局限性"

#: src/SUMMARY.md src/chromium/interoperability-with-cpp/error-handling.md
msgid "CXX Error Handling"
msgstr "CXX 错误处理"

#: src/SUMMARY.md
msgid "Error Handling: QR Example"
msgstr "错误处理：QR 码示例"

#: src/SUMMARY.md
msgid "Error Handling: PNG Example"
msgstr "错误处理：PNG 示例"

#: src/SUMMARY.md
msgid "Using CXX in Chromium"
msgstr "在 Chromium 中使用 CXX"

#: src/SUMMARY.md src/chromium/adding-third-party-crates.md
msgid "Adding Third Party Crates"
msgstr "添加第三方 Crate"

#: src/SUMMARY.md
msgid "Configuring Cargo.toml"
msgstr "配置 Cargo.toml"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid "Configuring `gnrt_config.toml`"
msgstr "配置 `gnrt_config.toml`"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Downloading Crates"
msgstr "下载 Crate"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Generating `gn` Build Rules"
msgstr "生成 `gn` 构建规则"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Resolving Problems"
msgstr "解决问题"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid "Build Scripts Which Generate Code"
msgstr "构建用于生成代码的脚本"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Build Scripts Which Build C++ or Take Arbitrary Actions"
msgstr "构建用于构建 C++ 或执行任意操作的脚本"

#: src/SUMMARY.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "Depending on a Crate"
msgstr "依赖于 Crate"

#: src/SUMMARY.md
msgid "Reviews and Audits"
msgstr "审查和审核"

#: src/SUMMARY.md
msgid "Checking into Chromium Source Code"
msgstr "提交到 Chromium 源代码"

#: src/SUMMARY.md src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid "Keeping Crates Up to Date"
msgstr "及时更新 Crate"

#: src/SUMMARY.md
msgid "Bringing It Together - Exercise"
msgstr "综合应用练习"

#: src/SUMMARY.md src/exercises/chromium/solutions.md
msgid "Exercise Solutions"
msgstr "练习解答"

#: src/SUMMARY.md
msgid "Bare Metal: Morning"
msgstr "裸机：上午"

#: src/SUMMARY.md src/bare-metal/no_std.md
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md
msgid "A Minimal Example"
msgstr "最小示例"

#: src/SUMMARY.md src/bare-metal/no_std.md src/bare-metal/alloc.md
msgid "`alloc`"
msgstr "`alloc`"

#: src/SUMMARY.md src/bare-metal/microcontrollers.md
msgid "Microcontrollers"
msgstr "微控制器"

#: src/SUMMARY.md src/bare-metal/microcontrollers/mmio.md
msgid "Raw MMIO"
msgstr "原始 MMIO"

#: src/SUMMARY.md
msgid "PACs"
msgstr "PAC"

#: src/SUMMARY.md
msgid "HAL Crates"
msgstr "HAL Crate"

#: src/SUMMARY.md
msgid "Board Support Crates"
msgstr "板级支持 Crate"

#: src/SUMMARY.md
msgid "The Type State Pattern"
msgstr "类型状态模式"

#: src/SUMMARY.md src/bare-metal/microcontrollers/embedded-hal.md
msgid "`embedded-hal`"
msgstr "`embedded-hal`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/probe-rs.md
msgid "`probe-rs` and `cargo-embed`"
msgstr "`probe-rs` 和 `cargo-embed`"

#: src/SUMMARY.md src/bare-metal/microcontrollers/debugging.md
msgid "Debugging"
msgstr "调试"

#: src/SUMMARY.md
msgid "Other Projects"
msgstr "其他项目"

#: src/SUMMARY.md src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "Compass"
msgstr "罗盘"

#: src/SUMMARY.md
msgid "Solutions"
msgstr "解答"

#: src/SUMMARY.md
msgid "Bare Metal: Afternoon"
msgstr "裸机：下午"

#: src/SUMMARY.md
msgid "Application Processors"
msgstr "应用处理器"

#: src/SUMMARY.md src/bare-metal/aps/entry-point.md
msgid "Getting Ready to Rust"
msgstr "准备使用 Rust"

#: src/SUMMARY.md
msgid "Inline Assembly"
msgstr "内联汇编"

#: src/SUMMARY.md
msgid "MMIO"
msgstr "MMIO"

#: src/SUMMARY.md
msgid "Let's Write a UART Driver"
msgstr "编写 UART 驱动程序"

#: src/SUMMARY.md
msgid "More Traits"
msgstr "更多特征"

#: src/SUMMARY.md
msgid "A Better UART Driver"
msgstr "优化 UART 驱动程序"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/bitflags.md
msgid "Bitflags"
msgstr "Bitflags"

#: src/SUMMARY.md
msgid "Multiple Registers"
msgstr "多寄存器"

#: src/SUMMARY.md src/bare-metal/aps/better-uart/driver.md
msgid "Driver"
msgstr "驱动程序"

#: src/SUMMARY.md
msgid "Using It"
msgstr "开始使用"

#: src/SUMMARY.md src/bare-metal/aps/exceptions.md
msgid "Exceptions"
msgstr "异常"

#: src/SUMMARY.md src/bare-metal/useful-crates/zerocopy.md
msgid "`zerocopy`"
msgstr "`zerocopy`"

#: src/SUMMARY.md src/bare-metal/useful-crates/aarch64-paging.md
msgid "`aarch64-paging`"
msgstr "`aarch64-paging`"

#: src/SUMMARY.md src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "`buddy_system_allocator`"
msgstr "`buddy_system_allocator`"

#: src/SUMMARY.md src/bare-metal/useful-crates/tinyvec.md
msgid "`tinyvec`"
msgstr "`tinyvec`"

#: src/SUMMARY.md src/bare-metal/useful-crates/spin.md
msgid "`spin`"
msgstr "`spin`"

#: src/SUMMARY.md
msgid "`vmbase`"
msgstr "`vmbase`"

#: src/SUMMARY.md
msgid "RTC Driver"
msgstr "RTC 驱动"

#: src/SUMMARY.md
msgid "Concurrency: Morning"
msgstr "并发：上午"

#: src/SUMMARY.md src/concurrency/threads.md
msgid "Threads"
msgstr "线程"

#: src/SUMMARY.md src/concurrency/scoped-threads.md
msgid "Scoped Threads"
msgstr "范围线程"

#: src/SUMMARY.md src/concurrency/channels.md
msgid "Channels"
msgstr "通道"

#: src/SUMMARY.md src/concurrency/channels/unbounded.md
msgid "Unbounded Channels"
msgstr "无界通道"

#: src/SUMMARY.md src/concurrency/channels/bounded.md
msgid "Bounded Channels"
msgstr "有界通道"

#: src/SUMMARY.md src/concurrency/send-sync.md
msgid "`Send` and `Sync`"
msgstr "`Send` 和 `Sync`"

#: src/SUMMARY.md src/concurrency/send-sync/send.md
msgid "`Send`"
msgstr "`Send`"

#: src/SUMMARY.md src/concurrency/send-sync/sync.md
msgid "`Sync`"
msgstr "`Sync`"

#: src/SUMMARY.md src/concurrency/send-sync/examples.md
msgid "Examples"
msgstr "示例"

#: src/SUMMARY.md src/concurrency/shared_state.md
msgid "Shared State"
msgstr "共享状态"

#: src/SUMMARY.md src/concurrency/shared_state/arc.md
msgid "`Arc`"
msgstr "`Arc`"

#: src/SUMMARY.md src/concurrency/shared_state/mutex.md
msgid "`Mutex`"
msgstr "互斥器（`Mutex`）"

#: src/SUMMARY.md src/memory-management/review.md
#: src/error-handling/try-conversions.md
#: src/concurrency/shared_state/example.md
msgid "Example"
msgstr "示例"

#: src/SUMMARY.md src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
msgid "Dining Philosophers"
msgstr "哲学家就餐问题"

#: src/SUMMARY.md src/exercises/concurrency/link-checker.md
msgid "Multi-threaded Link Checker"
msgstr "多线程链接检查器"

#: src/SUMMARY.md
msgid "Concurrency: Afternoon"
msgstr "并发：下午"

#: src/SUMMARY.md
msgid "Async Basics"
msgstr "异步基础"

#: src/SUMMARY.md src/async/async-await.md
msgid "`async`/`await`"
msgstr "`async`/`await`"

#: src/SUMMARY.md src/async/futures.md
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md src/async/runtimes.md
msgid "Runtimes"
msgstr "Runtimes"

#: src/SUMMARY.md src/async/runtimes/tokio.md
msgid "Tokio"
msgstr "Tokio"

#: src/SUMMARY.md src/exercises/concurrency/link-checker.md src/async/tasks.md
#: src/exercises/concurrency/chat-app.md
msgid "Tasks"
msgstr "任务"

#: src/SUMMARY.md src/async/channels.md
msgid "Async Channels"
msgstr "异步通道"

#: src/SUMMARY.md
msgid "Control Flow"
msgstr "控制流"

#: src/SUMMARY.md src/async/control-flow/join.md
msgid "Join"
msgstr "加入"

#: src/SUMMARY.md src/async/control-flow/select.md
msgid "Select"
msgstr "选择"

#: src/SUMMARY.md
msgid "Pitfalls"
msgstr "误区"

#: src/SUMMARY.md
msgid "Blocking the Executor"
msgstr "阻塞执行器"

#: src/SUMMARY.md src/async/pitfalls/pin.md
msgid "`Pin`"
msgstr "`Pin`"

#: src/SUMMARY.md src/async/pitfalls/async-traits.md
msgid "Async Traits"
msgstr "异步特征"

#: src/SUMMARY.md src/async/pitfalls/cancellation.md
msgid "Cancellation"
msgstr "消除"

#: src/SUMMARY.md src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "Broadcast Chat Application"
msgstr "广播聊天应用"

#: src/SUMMARY.md
msgid "Final Words"
msgstr "结束语"

#: src/SUMMARY.md src/thanks.md
msgid "Thanks!"
msgstr "谢谢！"

#: src/SUMMARY.md src/glossary.md
msgid "Glossary"
msgstr "词汇表"

#: src/SUMMARY.md
msgid "Other Resources"
msgstr "其他资源"

#: src/SUMMARY.md src/credits.md
msgid "Credits"
msgstr "鸣谢"

#: src/index.md
#, fuzzy
msgid ""
"[![Build workflow](https://img.shields.io/github/actions/workflow/status/"
"google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/"
"google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub contributors](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors) [![GitHub stars](https://img.shields."
"io/github/stars/google/comprehensive-rust?style=flat-square)](https://github."
"com/google/comprehensive-rust/stargazers)"
msgstr ""
"[![构建工作流](https://img.shields.io/github/actions/workflow/status/google/"
"comprehensive-rust/build.yml?style=flat-square)](https://github.com/google/"
"comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain) [!"
"[GitHub 贡献者](https://img.shields.io/github/contributors/google/"
"comprehensive-rust?style=flat-square)](https://github.com/google/"
"comprehensive-rust/graphs/contributors)"

#: src/index.md
msgid ""
"This is a free Rust course developed by the Android team at Google. The "
"course covers the full spectrum of Rust, from basic syntax to advanced "
"topics like generics and error handling."
msgstr ""
"这是由 Android 团队开发的免费 Rust 课程。该课程涵盖了 Rust 的全部范围，从基本"
"语法到高级主题如泛型和错误处理。"

#: src/index.md
msgid ""
"The latest version of the course can be found at <https://google.github.io/"
"comprehensive-rust/>. If you are reading somewhere else, please check there "
"for updates."
msgstr ""
"如需查看课程的最新版本，请访问 <https://google.github.io/comprehensive-rust/"
">。如果你是在其他地方阅读，请查看此网址了解是否有更新。"

#: src/index.md
msgid ""
"The goal of the course is to teach you Rust. We assume you don't know "
"anything about Rust and hope to:"
msgstr "本课程的目标是教授你 Rust。我们假设你对 Rust 一无所知，并希望能够："

#: src/index.md
msgid "Give you a comprehensive understanding of the Rust syntax and language."
msgstr "帮助你全面理解 Rust 的语法和语言。"

#: src/index.md
msgid "Enable you to modify existing programs and write new programs in Rust."
msgstr "使你能够修改现有的程序并用 Rust 编写新程序。"

#: src/index.md
msgid "Show you common Rust idioms."
msgstr "展示常见的 Rust 习语。"

#: src/index.md
#, fuzzy
msgid "We call the first four course days Rust Fundamentals."
msgstr "我们将前三天的课程称为“Rust 基础知识”。"

#: src/index.md
msgid ""
"Building on this, you're invited to dive into one or more specialized topics:"
msgstr "在此基础上，你可以选择深入学习一个或多个专门的主题："

#: src/index.md
msgid ""
"[Android](android.md): a half-day course on using Rust for Android platform "
"development (AOSP). This includes interoperability with C, C++, and Java."
msgstr ""
"[Android](android.md)：为期半天的课程，介绍如何在 Android 平台开发中使用 Rust"
"（AOSP）。课程内容包括与 C、C++ 和 Java 的互操作性。"

#: src/index.md
#, fuzzy
msgid ""
"[Chromium](chromium.md): a half-day course on using Rust within Chromium "
"based browsers. This includes interoperability with C++ and how to include "
"third-party crates in Chromium."
msgstr ""
"[Rust 在 Chromium 中的用法](../chromium.md) 深析是一个为期半天的课程，主要介"
"绍了如何在 Chromium 浏览器中使用 Rust。课程内容包括如何在 Chromium 的 `gn` 构"
"建系统中使用 Rust，引入第三方库 (\"crates\")，以及 C++ 的互操作性。"

#: src/index.md
msgid ""
"[Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal "
"(embedded) development. Both microcontrollers and application processors are "
"covered."
msgstr ""
"[Bare-metal](bare-metal.md)：为期一天的课程，介绍如何使用 Rust 进行裸机（嵌入"
"式）开发。课程内容涵盖微控制器和应用处理器。"

#: src/index.md
msgid ""
"[Concurrency](concurrency.md): a whole-day class on concurrency in Rust. We "
"cover both classical concurrency (preemptively scheduling using threads and "
"mutexes) and async/await concurrency (cooperative multitasking using "
"futures)."
msgstr ""
"[并发](concurrency.md)：为期一天的课程，介绍 Rust 中的并发性。我们将涵盖传统"
"并发（使用线程和互斥锁进行抢占式调度）和 async/await 并发（使用 futures 进行"
"协作式多任务处理）。"

#: src/index.md
msgid "Non-Goals"
msgstr "非目标"

#: src/index.md
msgid ""
"Rust is a large language and we won't be able to cover all of it in a few "
"days. Some non-goals of this course are:"
msgstr ""
"Rust 是一门庞大的语言，我们无法在几天内涵盖所有内容。本课程的一些非目标包括："

#: src/index.md
msgid ""
"Learning how to develop macros: please see [Chapter 19.5 in the Rust Book]"
"(https://doc.rust-lang.org/book/ch19-06-macros.html) and [Rust by Example]"
"(https://doc.rust-lang.org/rust-by-example/macros.html) instead."
msgstr ""
"了解如何开发宏，请参阅 [Rust Book 中的第 19.5 章](https://doc.rust-lang.org/"
"book/ch19-06-macros.html) 和 [Rust by Examples](https://doc.rust-lang.org/"
"rust-by-example/macros.html)。"

#: src/index.md
msgid "Assumptions"
msgstr "前提假设"

#: src/index.md
msgid ""
"The course assumes that you already know how to program. Rust is a "
"statically-typed language and we will sometimes make comparisons with C and "
"C++ to better explain or contrast the Rust approach."
msgstr ""
"本课程假设你已经具备编程知识。Rust 是一种静态类型语言，我们有时会与 C 和 C++ "
"进行比较，以更好地解释或对比 Rust 的方法。"

#: src/index.md
msgid ""
"If you know how to program in a dynamically-typed language such as Python or "
"JavaScript, then you will be able to follow along just fine too."
msgstr ""
"如果你已经了解如 Python 或 JavaScript 等动态类型语言的编程，那么你也能够很好"
"地跟上本课程。"

#: src/index.md
msgid ""
"This is an example of a _speaker note_. We will use these to add additional "
"information to the slides. This could be key points which the instructor "
"should cover as well as answers to typical questions which come up in class."
msgstr ""
"这是演讲者备注的示例。我们将使用这些备注来为幻灯片添加额外的信息。这可能包括"
"讲师应该涵盖的关键点，以及课堂上常见问题的答案。"

#: src/running-the-course.md src/running-the-course/course-structure.md
msgid "This page is for the course instructor."
msgstr "本页面适用于课程教师。"

#: src/running-the-course.md
msgid ""
"Here is a bit of background information about how we've been running the "
"course internally at Google."
msgstr "以下是有关 Google 内部授课方式的一些背景信息。"

#: src/running-the-course.md
#, fuzzy
msgid ""
"We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break "
"in the middle. This leaves 3 hours for the morning class and 3 hours for the "
"afternoon class. Both sessions contain multiple breaks and time for students "
"to work on exercises."
msgstr ""
"上课时间通常是从上午 10:00 到下午 4:00，中间有 1 小时的午餐休息时间。这样，上"
"午和下午各留了 2.5 小时的上课时间。请注意，这仅是建议：您也可以上午上课 3 小"
"时，让学员有更多的时间进行练习。上课时间较长的缺点是，学员上了整整 6 小时的"
"课，到了下午可能会非常疲倦。"

#: src/running-the-course.md
msgid "Before you run the course, you will want to:"
msgstr "在授课之前，你需要完成以下事项："

#: src/running-the-course.md
msgid ""
"Make yourself familiar with the course material. We've included speaker "
"notes to help highlight the key points (please help us by contributing more "
"speaker notes!). When presenting, you should make sure to open the speaker "
"notes in a popup (click the link with a little arrow next to \"Speaker "
"Notes\"). This way you have a clean screen to present to the class."
msgstr ""
"熟悉课程资料。我们添加了演讲者备注，借此强调要点（请帮个忙，多多贡献演讲者备"
"注！）。演示幻灯片时，你应确保在弹出式窗口中打开演讲者备注（点击对应的链接，"
"在“演讲者备注”旁边有一个小箭头）。这样，你就可以确保屏幕整洁有序，更好地向全"
"班学员展示课程内容。"

#: src/running-the-course.md
#, fuzzy
msgid ""
"Decide on the dates. Since the course takes four days, we recommend that you "
"schedule the days over two weeks. Course participants have said that they "
"find it helpful to have a gap in the course since it helps them process all "
"the information we give them."
msgstr ""
"确定培训日期。由于本课程至少需要三天的时间，因此我们建议你安排两周以上的时"
"间。课程学员曾表示，在每堂课之间留一段间隔会很有帮助，因为这有利于他们吸收我"
"们所提供的所有信息。"

#: src/running-the-course.md
msgid ""
"Find a room large enough for your in-person participants. We recommend a "
"class size of 15-25 people. That's small enough that people are comfortable "
"asking questions --- it's also small enough that one instructor will have "
"time to answer the questions. Make sure the room has _desks_ for yourself "
"and for the students: you will all need to be able to sit and work with your "
"laptops. In particular, you will be doing a lot of live-coding as an "
"instructor, so a lectern won't be very helpful for you."
msgstr ""
"找一间足以容纳全体线下学员的大教室。我们建议你将课程人数控制在 15-25 人之间。"
"这样，人数足够少，不仅便于学员提问问题，配备的一位教师也有时间答疑解惑。确保"
"教室备有供你和学生使用的“课桌”：你们都需要能够坐下来并操作各自的笔记本电脑。"
"特别是身为教师，你现场要进行大量编码，所以讲台对你来说用处不大。"

#: src/running-the-course.md
msgid ""
"On the day of your course, show up to the room a little early to set things "
"up. We recommend presenting directly using `mdbook serve` running on your "
"laptop (see the [installation instructions](https://github.com/google/"
"comprehensive-rust#building)). This ensures optimal performance with no lag "
"as you change pages. Using your laptop will also allow you to fix typos as "
"you or the course participants spot them."
msgstr ""
"在开课当天，请提前一点到教室，设置好教学设备。我们建议你直接在笔记本电脑上运"
"行 `mdbook serve` 来演示课程内容（请参阅[安装说明](https://github.com/google/"
"comprehensive-rust#building)）。这样可以确保你在切换页面时没有延迟，演示效果"
"更好。当你或课程学员发现拼写错误时，你也可以使用笔记本电脑及时更正。"

#: src/running-the-course.md
msgid ""
"Let people solve the exercises by themselves or in small groups. We "
"typically spend 30-45 minutes on exercises in the morning and in the "
"afternoon (including time to review the solutions). Make sure to ask people "
"if they're stuck or if there is anything you can help with. When you see "
"that several people have the same problem, call it out to the class and "
"offer a solution, e.g., by showing people where to find the relevant "
"information in the standard library."
msgstr ""
"让学员采取小组形式或独立解题。通常，我们会在上午和下午各安排 30-45 分钟的练习"
"时间（包括查看解决方案的时间）。请务必询问学员是否遇到困难，或是否需要任何帮"
"助。如果你看到多位学员遇到同样的问题，请在班级集体进行讲解，并提供相应的解决"
"方案，例如告诉大家在标准库的什么位置可以找到相关信息。"

#: src/running-the-course.md
msgid ""
"That is all, good luck running the course! We hope it will be as much fun "
"for you as it has been for us!"
msgstr "今天的分享就是这些，祝你授课顺利！希望你和我们一样，乐在其中！"

#: src/running-the-course.md
msgid ""
"Please [provide feedback](https://github.com/google/comprehensive-rust/"
"discussions/86) afterwards so that we can keep improving the course. We "
"would love to hear what worked well for you and what can be made better. "
"Your students are also very welcome to [send us feedback](https://github.com/"
"google/comprehensive-rust/discussions/100)!"
msgstr ""
"欢迎你课后[提供反馈](https://github.com/google/comprehensive-rust/"
"discussions/86)，帮助我们不断改进课程。我们非常期待了解哪些方面做得不错，哪些"
"方面还需要改进。同时非常欢迎学生们[向我们发送反馈](https://github.com/google/"
"comprehensive-rust/discussions/100)！"

#: src/running-the-course/course-structure.md
msgid "Rust Fundamentals"
msgstr "Rust 基础知识"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"The first four days make up [Rust Fundamentals](../welcome-day-1.md). The "
"days are fast paced and we cover a lot of ground!"
msgstr ""
"我们会在头三天介绍 [Rust 基础知识](../welcome-day-1.md)。这几天的步调会稍快,"
"因为我们要探讨许多层面:"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Course schedule:"
msgstr "课程结构"

#: src/running-the-course/course-structure.md
msgid "Day 1 Morning (3 hours, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-1.md) (5 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Hello, World](../hello-world.md) (20 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Types and Values](../types-and-values.md) (1 hour and 5 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Control Flow Basics](../control-flow-basics.md) (1 hour)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Day 1 Afternoon (2 hours and 55 minutes, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Tuples and Arrays](../tuples-and-arrays.md) (1 hour)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[References](../references.md) (50 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[User-Defined Types](../user-defined-types.md) (50 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Day 2 Morning (2 hours and 55 minutes, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-2.md) (3 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "[Pattern Matching](../pattern-matching.md) (50 minutes)"
msgstr ""
"如需详细了解 Rust 中 的模式，请参阅[模式匹配](../pattern-matching.md)。"

#: src/running-the-course/course-structure.md
msgid "[Methods and Traits](../methods-and-traits.md) (45 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Generics](../generics.md) (45 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Day 2 Afternoon (3 hours, including breaks)"
msgstr "第二天下午的练习"

#: src/running-the-course/course-structure.md
msgid "[Standard Library Types](../std-types.md) (1 hour and 10 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Standard Library Traits](../std-traits.md) (1 hour and 40 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Day 3 Morning (2 hours and 25 minutes, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-3.md) (3 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Memory Management](../memory-management.md) (1 hour and 10 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Smart Pointers](../smart-pointers.md) (55 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Day 3 Afternoon (2 hours and 20 minutes, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Borrowing](../borrowing.md) (1 hour)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid ""
"[Slices and Lifetimes](../slices-and-lifetimes.md) (1 hour and 10 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Day 4 Morning (3 hours and 5 minutes, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Welcome](../welcome-day-4.md) (3 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Iterators](../iterators.md) (45 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Modules](../modules.md) (40 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Testing](../testing.md) (1 hour and 5 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Day 4 Afternoon (2 hours, including breaks)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Error Handling](../error-handling.md) (45 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "[Unsafe Rust](../unsafe-rust.md) (1 hour and 5 minutes)"
msgstr ""

#: src/running-the-course/course-structure.md
msgid "Deep Dives"
msgstr "深入探究"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"In addition to the 4-day class on Rust Fundamentals, we cover some more "
"specialized topics:"
msgstr "除了为期 3 天的“Rust 基础知识”课程外，我们还推出了一些专题课程："

#: src/running-the-course/course-structure.md
msgid "Rust in Android"
msgstr "Android 中的 Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The [Rust in Android](../android.md) deep dive is a half-day course on using "
"Rust for Android platform development. This includes interoperability with "
"C, C++, and Java."
msgstr ""
"[深入探究 Android](../android.md)课程为期半天，旨在介绍如何使用 Rust 进行 "
"Android 平台开发。其中包括与 C、C++ 和 Java 的互操作性。"

#: src/running-the-course/course-structure.md
msgid ""
"You will need an [AOSP checkout](https://source.android.com/docs/setup/"
"download/downloading). Make a checkout of the [course repository](https://"
"github.com/google/comprehensive-rust) on the same machine and move the `src/"
"android/` directory into the root of your AOSP checkout. This will ensure "
"that the Android build system sees the `Android.bp` files in `src/android/`."
msgstr ""
"你将需要[签出 AOSP](https://source.android.com/docs/setup/download/"
"downloading)。在同一机器上签出[课程库](https://github.com/google/"
"comprehensive-rust)， 然后将 `src/android/` 目录移至所签出的 AOSP 的根目录。"
"这将确保 Android 构建系统能检测到 `src/android/` 中的 `Android.bp` 文件。"

#: src/running-the-course/course-structure.md
msgid ""
"Ensure that `adb sync` works with your emulator or real device and pre-build "
"all Android examples using `src/android/build_all.sh`. Read the script to "
"see the commands it runs and make sure they work when you run them by hand."
msgstr ""
"确保 `adb sync` 适用于你的模拟器或实际设备， 并使用 `src/android/build_all."
"sh` 预构建所有 Android 示例。请阅读脚本， 查看它所运行的命令，并确保这些命令"
"能在你手动运行时正确执行。"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid "Rust in Chromium"
msgstr "在 Chromium 中使用 CXX"

#: src/running-the-course/course-structure.md
#, fuzzy
msgid ""
"The [Rust in Chromium](../chromium.md) deep dive is a half-day course on "
"using Rust as part of the Chromium browser. It includes using Rust in "
"Chromium's `gn` build system, bringing in third-party libraries (\"crates\") "
"and C++ interoperability."
msgstr ""
"[Rust 在 Chromium 中的用法](../chromium.md) 深析是一个为期半天的课程，主要介"
"绍了如何在 Chromium 浏览器中使用 Rust。课程内容包括如何在 Chromium 的 `gn` 构"
"建系统中使用 Rust，引入第三方库 (\"crates\")，以及 C++ 的互操作性。"

#: src/running-the-course/course-structure.md
msgid ""
"You will need to be able to build Chromium --- a debug, component build is "
"[recommended](../chromium/setup.md) for speed but any build will work. "
"Ensure that you can run the Chromium browser that you've built."
msgstr ""
"您需要具备构建 Chromium 的能力。为了提高速度，[建议使用] 调试组件 build (../"
"chromium/setup.md)，但任何类型的 build 均可使用。请确保可以运行您所构建的 "
"Chromium 浏览器。"

#: src/running-the-course/course-structure.md
msgid "Bare-Metal Rust"
msgstr "裸金属 Rust"

#: src/running-the-course/course-structure.md
msgid ""
"The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on "
"using Rust for bare-metal (embedded) development. Both microcontrollers and "
"application processors are covered."
msgstr ""
"[深入探究裸金属 Rust](../bare-metal.md)课程为期一天，旨在介绍如何使用 Rust 进"
"行裸金属（嵌入式）开发。其中涵盖了微控制器和应用处理器。"

#: src/running-the-course/course-structure.md
msgid ""
"For the microcontroller part, you will need to buy the [BBC micro:bit]"
"(https://microbit.org/) v2 development board ahead of time. Everybody will "
"need to install a number of packages as described on the [welcome page](../"
"bare-metal.md)."
msgstr ""
"对于微控制器部分，你需要提前购买 [BBC micro:bit](https://microbit.org/) 第 2 "
"版开发板。每个人都需要安装多个软件包， 具体如[欢迎页面](../bare-metal.md)中所"
"述。"

#: src/running-the-course/course-structure.md
msgid "Concurrency in Rust"
msgstr "Rust 中的并发"

#: src/running-the-course/course-structure.md
msgid ""
"The [Concurrency in Rust](../concurrency.md) deep dive is a full day class "
"on classical as well as `async`/`await` concurrency."
msgstr ""
"[深入探究并发](../concurrency.md)课程为期一天，旨在介绍传统并发和 `async`/"
"`await` 并发。"

#: src/running-the-course/course-structure.md
msgid ""
"You will need a fresh crate set up and the dependencies downloaded and ready "
"to go. You can then copy/paste the examples into `src/main.rs` to experiment "
"with them:"
msgstr ""
"你需要设置一个新 crate，下载所需的依赖项， 做好课前准备。然后，你可以将示例复"
"制/粘贴到 `src/main.rs` 中， 以便对以下代码进行实验："

#: src/running-the-course/course-structure.md
msgid "Format"
msgstr "课程形式"

#: src/running-the-course/course-structure.md
msgid ""
"The course is meant to be very interactive and we recommend letting the "
"questions drive the exploration of Rust!"
msgstr "本课程的互动性非常强， 建议你以问题驱动探索 Rust！"

#: src/running-the-course/keyboard-shortcuts.md
msgid "There are several useful keyboard shortcuts in mdBook:"
msgstr "mdBook 中有一些实用键盘快捷键："

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Left"
msgstr "向左箭头"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the previous page."
msgstr "：转到上一页。"

#: src/running-the-course/keyboard-shortcuts.md
msgid "Arrow-Right"
msgstr "向右箭头"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Navigate to the next page."
msgstr "：转到下一页。"

#: src/running-the-course/keyboard-shortcuts.md src/cargo/code-samples.md
msgid "Ctrl + Enter"
msgstr "Ctrl + Enter"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Execute the code sample that has focus."
msgstr "：执行具有焦点的代码示例。"

#: src/running-the-course/keyboard-shortcuts.md
msgid "s"
msgstr "s"

#: src/running-the-course/keyboard-shortcuts.md
msgid ": Activate the search bar."
msgstr "：激活搜索栏。"

#: src/running-the-course/translations.md
msgid ""
"The course has been translated into other languages by a set of wonderful "
"volunteers:"
msgstr "一批优秀的志愿者已将本课程翻译成其他语言："

#: src/running-the-course/translations.md
msgid ""
"[Brazilian Portuguese](https://google.github.io/comprehensive-rust/pt-BR/) "
"by [@rastringer](https://github.com/rastringer), [@hugojacob](https://github."
"com/hugojacob), [@joaovicmendes](https://github.com/joaovicmendes), and "
"[@henrif75](https://github.com/henrif75)."
msgstr ""
"[巴西葡萄牙语版本](https://google.github.io/comprehensive-rust/pt-BR/) 译者："
"[@rastringer](https://github.com/rastringer)、[@hugojacob](https://github."
"com/hugojacob)、[@joaovicmendes](https://github.com/joaovicmendes) 和 "
"[@henrif75](https://github.com/henrif75)。"

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Chinese (Simplified)](https://google.github.io/comprehensive-rust/zh-CN/) "
"by [@suetfei](https://github.com/suetfei), [@wnghl](https://github.com/"
"wnghl), [@anlunx](https://github.com/anlunx), [@kongy](https://github.com/"
"kongy), [@noahdragon](https://github.com/noahdragon), [@superwhd](https://"
"github.com/superwhd), [@SketchK](https://github.com/SketchK), and [@nodmp]"
"(https://github.com/nodmp)."
msgstr ""
"[简体中文版本](https://google.github.io/comprehensive-rust/zh-CN/) 译者："
"[@suetfei](https://github.com/suetfei)、[@wnghl](https://github.com/wnghl), "
"[@anlunx](https://github.com/anlunx)、[@kongy](https://github.com/kongy), "
"[@noahdragon](https://github.com/noahdragon) 和 [@superwhd](https://github."
"com/superwhd)。"

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Chinese (Traditional)](https://google.github.io/comprehensive-rust/zh-TW/) "
"by [@hueich](https://github.com/hueich), [@victorhsieh](https://github.com/"
"victorhsieh), [@mingyc](https://github.com/mingyc), [@kuanhungchen](https://"
"github.com/kuanhungchen), and [@johnathan79717](https://github.com/"
"johnathan79717)."
msgstr ""
"[繁体中文版本](https://google.github.io/comprehensive-rust/zh-TW/) 译者："
"[@hueich](https://github.com/hueich)、[@victorhsieh](https://github.com/"
"victorhsieh)、[@mingyc](https://github.com/mingyc) 和 [@johnathan79717]"
"(https://github.com/johnathan79717)。"

#: src/running-the-course/translations.md
msgid ""
"[Korean](https://google.github.io/comprehensive-rust/ko/) by [@keispace]"
"(https://github.com/keispace), [@jiyongp](https://github.com/jiyongp), and "
"[@jooyunghan](https://github.com/jooyunghan)."
msgstr ""
"[韩语版本](https://google.github.io/comprehensive-rust/ko/) 译者：[@keispace]"
"(https://github.com/keispace)、[@jiyongp](https://github.com/jiyongp) 和 "
"[@jooyunghan](https://github.com/jooyunghan)。"

#: src/running-the-course/translations.md
msgid ""
"[Spanish](https://google.github.io/comprehensive-rust/es/) by [@deavid]"
"(https://github.com/deavid)."
msgstr ""
"[西班牙语版本](https://google.github.io/comprehensive-rust/es/) 译者："
"[@deavid](https://github.com/deavid)。"

#: src/running-the-course/translations.md
msgid ""
"Use the language picker in the top-right corner to switch between languages."
msgstr "使用右上角的语言选择器切换语言。"

#: src/running-the-course/translations.md
msgid "Incomplete Translations"
msgstr "未完成的翻译"

#: src/running-the-course/translations.md
msgid ""
"There is a large number of in-progress translations. We link to the most "
"recently updated translations:"
msgstr "多数语言版本仍在翻译中。我们会提供最近更新的翻译的链接："

#: src/running-the-course/translations.md
msgid ""
"[Bengali](https://google.github.io/comprehensive-rust/bn/) by [@raselmandol]"
"(https://github.com/raselmandol)."
msgstr ""
"[孟加拉语版本](https://google.github.io/comprehensive-rust/bn/) 译者："
"[@raselmandol](https://github.com/raselmandol)。"

#: src/running-the-course/translations.md
msgid ""
"[French](https://google.github.io/comprehensive-rust/fr/) by [@KookaS]"
"(https://github.com/KookaS) and [@vcaen](https://github.com/vcaen)."
msgstr ""
"[法语版本](https://google.github.io/comprehensive-rust/fr/) 译者：[@KookaS]"
"(https://github.com/KookaS) 和 [@vcaen](https://github.com/vcaen)。"

#: src/running-the-course/translations.md
msgid ""
"[German](https://google.github.io/comprehensive-rust/de/) by [@Throvn]"
"(https://github.com/Throvn) and [@ronaldfw](https://github.com/ronaldfw)."
msgstr ""
"[德语版本](https://google.github.io/comprehensive-rust/de/) 译者：[@Throvn]"
"(https://github.com/Throvn) 和 [@ronaldfw](https://github.com/ronaldfw)。"

#: src/running-the-course/translations.md
msgid ""
"[Japanese](https://google.github.io/comprehensive-rust/ja/) by [@CoinEZ-JPN]"
"(https://github.com/CoinEZ) and [@momotaro1105](https://github.com/"
"momotaro1105)."
msgstr ""
"[日语版本](https://google.github.io/comprehensive-rust/ja/) 译者：[@CoinEZ-"
"JPN](https://github.com/CoinEZ) 和 [@momotaro1105](https://github.com/"
"momotaro1105)。"

#: src/running-the-course/translations.md
#, fuzzy
msgid ""
"[Italian](https://google.github.io/comprehensive-rust/it/) by "
"[@henrythebuilder](https://github.com/henrythebuilder) and [@detro](https://"
"github.com/detro)."
msgstr ""
"[德语版本](https://google.github.io/comprehensive-rust/de/) 译者：[@Throvn]"
"(https://github.com/Throvn) 和 [@ronaldfw](https://github.com/ronaldfw)。"

#: src/running-the-course/translations.md
msgid ""
"If you want to help with this effort, please see [our instructions](https://"
"github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md) for how to "
"get going. Translations are coordinated on the [issue tracker](https://"
"github.com/google/comprehensive-rust/issues/282)."
msgstr ""
"如果你想帮助我们，请参阅[我们的说明](https://github.com/google/comprehensive-"
"rust/blob/main/TRANSLATIONS.md)，了解如何开始翻译。翻译工作将通过[问题跟踪器]"
"(https://github.com/google/comprehensive-rust/issues/282)跟踪。"

#: src/cargo.md
msgid ""
"When you start reading about Rust, you will soon meet [Cargo](https://doc."
"rust-lang.org/cargo/), the standard tool used in the Rust ecosystem to build "
"and run Rust applications. Here we want to give a brief overview of what "
"Cargo is and how it fits into the wider ecosystem and how it fits into this "
"training."
msgstr ""
"开始了解 Rust 后，你很快就会遇到 [Cargo](https://doc.rust-lang.org/cargo/)，"
"这是 Rust 生态系统中用于构建和运行 Rust 应用的标准工具。在这里，我们想简要介"
"绍一下什么是 Cargo、它如何融入更广泛的生态系统， 以及我们如何在本培训中合理利"
"用 Cargo。"

#: src/cargo.md
msgid "Installation"
msgstr "安装"

#: src/cargo.md
msgid "**Please follow the instructions on <https://rustup.rs/>.**"
msgstr "**请按照 <https://rustup.rs/> 上的说明操作。**"

#: src/cargo.md
msgid ""
"This will give you the Cargo build tool (`cargo`) and the Rust compiler "
"(`rustc`). You will also get `rustup`, a command line utility that you can "
"use to install to different compiler versions."
msgstr ""
"这将为你提供 Cargo 构建工具 (`cargo`)和 Rust 编译器 (`rustc`)。你还将获得 "
"`rustup`，这是一个命令行实用程序,你可以用它来安装不同的编译器版本。"

#: src/cargo.md
msgid ""
"After installing Rust, you should configure your editor or IDE to work with "
"Rust. Most editors do this by talking to [rust-analyzer](https://rust-"
"analyzer.github.io/), which provides auto-completion and jump-to-definition "
"functionality for [VS Code](https://code.visualstudio.com/), [Emacs](https://"
"rust-analyzer.github.io/manual.html#emacs), [Vim/Neovim](https://rust-"
"analyzer.github.io/manual.html#vimneovim), and many others. There is also a "
"different IDE available called [RustRover](https://www.jetbrains.com/rust/)."
msgstr ""
"安装Rust之后，你应当配置你的编辑器或 IDE 以开始使用 Rust。大多数编辑器使用"
"[rust-analyzer](https://rust-analyzer.github.io/)以达成此目的。它为[VS Code]"
"(https://code.visualstudio.com/)、[Emacs](https://rust-analyzer.github.io/"
"manual.html#emacs)、[Vim/Neovim](https://rust-analyzer.github.io/manual."
"html#vimneovim)及其他许多编辑器提供了自动补全及定义跳转的功能。同样也可以用一"
"个叫[RustRover](https://www.jetbrains.com/rust/)的IDE。"

#: src/cargo.md
msgid ""
"On Debian/Ubuntu, you can also install Cargo, the Rust source and the [Rust "
"formatter](https://github.com/rust-lang/rustfmt) via `apt`. However, this "
"gets you an outdated rust version and may lead to unexpected behavior. The "
"command would be:"
msgstr ""
"在 Debian/Ubuntu 上，你也可以通过 `apt` 安装 Cargo、Rust 源代码和 [Rust 格式"
"化工具](https://github.com/rust-lang/rustfmt)。但是，这样会得到一个过时的 "
"Rust 版本，这可能会导致意外的行为。命令如下:"

#: src/cargo/rust-ecosystem.md
msgid "The Rust Ecosystem"
msgstr "Rust 生态系统"

#: src/cargo/rust-ecosystem.md
msgid ""
"The Rust ecosystem consists of a number of tools, of which the main ones are:"
msgstr "Rust 生态系统由许多工具组成，其中的主要工具包括："

#: src/cargo/rust-ecosystem.md
msgid ""
"`rustc`: the Rust compiler which turns `.rs` files into binaries and other "
"intermediate formats."
msgstr "`rustc`：Rust 编译器，可将 `.rs` 文件转换为二进制文件和其他中间格式。"

#: src/cargo/rust-ecosystem.md
msgid ""
"`cargo`: the Rust dependency manager and build tool. Cargo knows how to "
"download dependencies, usually hosted on <https://crates.io>, and it will "
"pass them to `rustc` when building your project. Cargo also comes with a "
"built-in test runner which is used to execute unit tests."
msgstr ""
"`cargo`：Rust 依赖项管理器和构建工具。Cargo 知道如何下载托管在 <https://"
"crates.io> 上的依赖项,并在构建项目时将它们传递给 `rustc`。Cargo 还附带一个内"
"置的测试运行程序，用于执行单元测试。"

#: src/cargo/rust-ecosystem.md
#, fuzzy
msgid ""
"`rustup`: the Rust toolchain installer and updater. This tool is used to "
"install and update `rustc` and `cargo` when new versions of Rust are "
"released. In addition, `rustup` can also download documentation for the "
"standard library. You can have multiple versions of Rust installed at once "
"and `rustup` will let you switch between them as needed."
msgstr ""
"`rustup`：Rust 工具链安装程序和更新程序。发布新版本 Rust 时，此工具用于安装并"
"更新 `rustc` 和 `cargo`。 此外，`rustup` 还可以下载标准库的文档。你可以同时安"
"装多个版本的 Rust，并且 `rustup` 可让你根据需要在这些版本之间切换。"

#: src/cargo/rust-ecosystem.md src/hello-world/hello-world.md
#: src/tuples-and-arrays/tuples-and-arrays.md src/references/exclusive.md
#: src/pattern-matching/destructuring.md src/memory-management/move.md
#: src/error-handling/try.md src/android/setup.md src/concurrency/threads.md
#: src/async/async-await.md
msgid "Key points:"
msgstr "关键点："

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust has a rapid release schedule with a new release coming out every six "
"weeks. New releases maintain backwards compatibility with old releases --- "
"plus they enable new functionality."
msgstr ""
"Rust 有一个快速发布时间表，每六周就会发布一次 新版本。新版本保持与旧版本的向"
"后兼容性，还添加了新功能。"

#: src/cargo/rust-ecosystem.md
msgid ""
"There are three release channels: \"stable\", \"beta\", and \"nightly\"."
msgstr "共有三个发布阶段：“稳定版”、“Beta 版”和“夜间版”。"

#: src/cargo/rust-ecosystem.md
msgid ""
"New features are being tested on \"nightly\", \"beta\" is what becomes "
"\"stable\" every six weeks."
msgstr "我们会在“夜间版”上测试新功能，每六周将“Beta 版”升级为“稳定版”。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Dependencies can also be resolved from alternative [registries](https://doc."
"rust-lang.org/cargo/reference/registries.html), git, folders, and more."
msgstr ""
"您也可以通过备用的[注册数据库](https://doc.rust-lang.org/cargo/reference/"
"registries.html)、git及文件夹等资源来解析依赖项。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Rust also has [editions](https://doc.rust-lang.org/edition-guide/): the "
"current edition is Rust 2021. Previous editions were Rust 2015 and Rust 2018."
msgstr ""
"Rust 也有三个\\[版本\\]：当前版本是 Rust 2021。之前的版本是 Rust 2015 和 "
"Rust 2018。"

#: src/cargo/rust-ecosystem.md
msgid ""
"The editions are allowed to make backwards incompatible changes to the "
"language."
msgstr "这些版本支持对语言进行向后不兼容的更改。"

#: src/cargo/rust-ecosystem.md
msgid ""
"To prevent breaking code, editions are opt-in: you select the edition for "
"your crate via the `Cargo.toml` file."
msgstr ""
"为防止破坏代码，你可以自行选择版本： 通过 `Cargo.toml` 文件为 crate 选择合适"
"的版本。"

#: src/cargo/rust-ecosystem.md
msgid ""
"To avoid splitting the ecosystem, Rust compilers can mix code written for "
"different editions."
msgstr "为免分割生态系统，Rust 编译器可以混合使用为不同版本编写的代码。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Mention that it is quite rare to ever use the compiler directly not through "
"`cargo` (most users never do)."
msgstr ""
"提及不通过 `cargo` 而直接使用编译器的情况相当少见（大多数用户从不这样做）。"

#: src/cargo/rust-ecosystem.md
#, fuzzy
msgid ""
"It might be worth alluding that Cargo itself is an extremely powerful and "
"comprehensive tool. It is capable of many advanced features including but "
"not limited to:"
msgstr ""
"值得注意的是，Cargo 本身就是一个功能强大且全面的工具。它能够实现许多高级功"
"能，包括但不限于："

#: src/cargo/rust-ecosystem.md
msgid "Project/package structure"
msgstr "项目/软件包结构"

#: src/cargo/rust-ecosystem.md
msgid "[workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)"
msgstr "\\[工作区\\]"

#: src/cargo/rust-ecosystem.md
msgid "Dev Dependencies and Runtime Dependency management/caching"
msgstr "开发依赖项和运行时依赖项管理/缓存"

#: src/cargo/rust-ecosystem.md
msgid ""
"[build scripting](https://doc.rust-lang.org/cargo/reference/build-scripts."
"html)"
msgstr "\\[构建脚本\\]"

#: src/cargo/rust-ecosystem.md
msgid ""
"[global installation](https://doc.rust-lang.org/cargo/commands/cargo-install."
"html)"
msgstr "\\[全局安装\\] \\]"

#: src/cargo/rust-ecosystem.md
msgid ""
"It is also extensible with sub command plugins as well (such as [cargo "
"clippy](https://github.com/rust-lang/rust-clippy))."
msgstr ""
"它还可以使用子命令插件（例如 [cargo clippy](https://github.com/rust-lang/"
"rust-clippy)）进行扩展。"

#: src/cargo/rust-ecosystem.md
msgid ""
"Read more from the [official Cargo Book](https://doc.rust-lang.org/cargo/)"
msgstr "如需了解详情，请参阅\\[ Cargo 官方图书\\]"

#: src/cargo/code-samples.md
msgid "Code Samples in This Training"
msgstr "本培训中的代码示例"

#: src/cargo/code-samples.md
msgid ""
"For this training, we will mostly explore the Rust language through examples "
"which can be executed through your browser. This makes the setup much easier "
"and ensures a consistent experience for everyone."
msgstr ""
"在本培训中，我们将主要通过示例探索 Rust 语言，这些示例可通过浏览器执行。这能"
"大大简化设置过程， 并确保所有人都能获得一致的体验。"

#: src/cargo/code-samples.md
msgid ""
"Installing Cargo is still encouraged: it will make it easier for you to do "
"the exercises. On the last day, we will do a larger exercise which shows you "
"how to work with dependencies and for that you need Cargo."
msgstr ""
"我们仍然建议你安装 Cargo：它有助于你更轻松地完成练习。在最后一天，我们要做一"
"个更大的练习， 向你展示如何使用依赖项，因此你需要安装 Cargo。"

#: src/cargo/code-samples.md
msgid "The code blocks in this course are fully interactive:"
msgstr "本课程中的代码块是完全交互式的："

#: src/cargo/code-samples.md src/cargo/running-locally.md
msgid "\"Edit me!\""
msgstr "\"Edit me!\""

#: src/cargo/code-samples.md
msgid "You can use "
msgstr "当文本框为焦点时，你可以使用"

#: src/cargo/code-samples.md
#, fuzzy
msgid " to execute the code when focus is in the text box."
msgstr "来执行代码。"

#: src/cargo/code-samples.md
msgid ""
"Most code samples are editable like shown above. A few code samples are not "
"editable for various reasons:"
msgstr ""
"大多数代码示例都可修改（如上图所示）。少数代码示例可能会因各种原因而不可修"
"改："

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds cannot execute unit tests. Copy-paste the code and "
"open it in the real Playground to demonstrate unit tests."
msgstr ""
"嵌入式 Playground 无法执行单元测试。将代码复制并粘贴到实际 Playground 中，以"
"演示单元测试。"

#: src/cargo/code-samples.md
msgid ""
"The embedded playgrounds lose their state the moment you navigate away from "
"the page! This is the reason that the students should solve the exercises "
"using a local Rust installation or via the Playground."
msgstr ""
"嵌入式 Playground 会在你离开页面后立即丢失其状态！正因如此，学员应使用本地安"
"装的 Rust 或通过 Playground 解题。"

#: src/cargo/running-locally.md
msgid "Running Code Locally with Cargo"
msgstr "使用 Cargo 在本地运行代码"

#: src/cargo/running-locally.md
msgid ""
"If you want to experiment with the code on your own system, then you will "
"need to first install Rust. Do this by following the [instructions in the "
"Rust Book](https://doc.rust-lang.org/book/ch01-01-installation.html). This "
"should give you a working `rustc` and `cargo`. At the time of writing, the "
"latest stable Rust release has these version numbers:"
msgstr ""
"如果你想在自己的系统上对代码进行实验， 则需要先安装 Rust。为此，请按照 [Rust "
"图书中的说明](https://doc.rust-lang.org/book/ch01-01-installation.html)操作。"
"这应会为你提供一个有效的 `rustc` 和 `cargo`。在撰写本文时，最新的 Rust 稳定版"
"具有以下版本号："

#: src/cargo/running-locally.md
msgid ""
"You can use any later version too since Rust maintains backwards "
"compatibility."
msgstr "您也可以使用任何更高版本，因为 Rust 保持向后兼容性。"

#: src/cargo/running-locally.md
msgid ""
"With this in place, follow these steps to build a Rust binary from one of "
"the examples in this training:"
msgstr ""
"了解这些信息后，请按照以下步骤从本培训中的 一个示例中构建 Rust 二进制文件："

#: src/cargo/running-locally.md
msgid "Click the \"Copy to clipboard\" button on the example you want to copy."
msgstr "在你要复制的示例上点击“复制到剪贴板”按钮。"

#: src/cargo/running-locally.md
msgid ""
"Use `cargo new exercise` to create a new `exercise/` directory for your code:"
msgstr "使用 `cargo new exercise` 为你的代码新建一个 `exercise/` 目录："

#: src/cargo/running-locally.md
msgid ""
"Navigate into `exercise/` and use `cargo run` to build and run your binary:"
msgstr "导航至 `exercise/` 并使用 `cargo run` 构建并运行你的二进制文件："

#: src/cargo/running-locally.md
msgid ""
"Replace the boiler-plate code in `src/main.rs` with your own code. For "
"example, using the example on the previous page, make `src/main.rs` look like"
msgstr ""
"将 `src/main.rs` 中的样板代码替换为你自己的代码。例如， 使用上一页中的示例，"
"将 `src/main.rs` 改为："

#: src/cargo/running-locally.md
msgid "Use `cargo run` to build and run your updated binary:"
msgstr "使用 `cargo run` 构建并运行你更新后的二进制文件："

#: src/cargo/running-locally.md
msgid ""
"Use `cargo check` to quickly check your project for errors, use `cargo "
"build` to compile it without running it. You will find the output in `target/"
"debug/` for a normal debug build. Use `cargo build --release` to produce an "
"optimized release build in `target/release/`."
msgstr ""
"使用 `cargo check` 快速检查项目是否存在错误；使用 `cargo build` 只进行编译，"
"而不运行。你可以在 `target/debug/` 中找到常规调试 build 的输出。使用 `cargo "
"build --release` 在 `target/release/` 中生成经过优化的 发布 build。"

#: src/cargo/running-locally.md
msgid ""
"You can add dependencies for your project by editing `Cargo.toml`. When you "
"run `cargo` commands, it will automatically download and compile missing "
"dependencies for you."
msgstr ""
"你可以通过修改 `Cargo.toml` 为项目添加依赖项。当你 运行 `cargo` 命令时，系统"
"会自动为你下载和编译缺失 的依赖项。"

#: src/cargo/running-locally.md
msgid ""
"Try to encourage the class participants to install Cargo and use a local "
"editor. It will make their life easier since they will have a normal "
"development environment."
msgstr ""
"尽量鼓励全班学员安装 Cargo 并使用 本地编辑器。这能为他们营造常规 开发环境，让"
"工作变得更加轻松。"

#: src/welcome-day-1.md
msgid "Welcome to Day 1"
msgstr "欢迎来到第一天"

#: src/welcome-day-1.md
msgid ""
"This is the first day of Rust Fundamentals. We will cover a lot of ground "
"today:"
msgstr "今天是学习 Comprehensive Rust 的第一天。我们会涉及很多内容："

#: src/welcome-day-1.md
msgid ""
"Basic Rust syntax: variables, scalar and compound types, enums, structs, "
"references, functions, and methods."
msgstr ""
"Rust 基本语法：变量、标量（scalar）和复合（compound）类型、枚举（Enum）、结构"
"体（struct）、引用、函数和方法。"

#: src/welcome-day-1.md
#, fuzzy
msgid "Types and type inference."
msgstr "类型推导"

#: src/welcome-day-1.md
msgid "Control flow constructs: loops, conditionals, and so on."
msgstr "控制流结构：循环、条件语句等。"

#: src/welcome-day-1.md
msgid "User-defined types: structs and enums."
msgstr "用户定义的类型：结构体和枚举。"

#: src/welcome-day-1.md
msgid "Pattern matching: destructuring enums, structs, and arrays."
msgstr "模式匹配：解构枚举、结构体和数组（array）。"

#: src/welcome-day-1.md src/welcome-day-2.md src/welcome-day-3.md
#: src/welcome-day-4.md
msgid "Schedule"
msgstr "时间表"

#: src/welcome-day-1.md src/welcome-day-1-afternoon.md src/welcome-day-2.md
#: src/welcome-day-2-afternoon.md src/welcome-day-3.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4.md
#: src/welcome-day-4-afternoon.md
msgid "In this session:"
msgstr ""

#: src/welcome-day-1.md
msgid "[Welcome](./welcome-day-1.md) (5 minutes)"
msgstr ""

#: src/welcome-day-1.md
msgid "[Hello, World](./hello-world.md) (20 minutes)"
msgstr ""

#: src/welcome-day-1.md
msgid "[Types and Values](./types-and-values.md) (1 hour and 5 minutes)"
msgstr ""

#: src/welcome-day-1.md
msgid "[Control Flow Basics](./control-flow-basics.md) (1 hour)"
msgstr ""

#: src/welcome-day-1.md src/welcome-day-2-afternoon.md
msgid "Including 10 minute breaks, this session should take about 3 hours"
msgstr ""

#: src/welcome-day-1.md
msgid "Please remind the students that:"
msgstr "请提醒学生："

#: src/welcome-day-1.md
msgid ""
"They should ask questions when they get them, don't save them to the end."
msgstr "他们可以随时提问，不需要留到最后。"

#: src/welcome-day-1.md
msgid ""
"The class is meant to be interactive and discussions are very much "
"encouraged!"
msgstr "这个课程本应该是互动的，我们鼓励大家积极讨论。"

#: src/welcome-day-1.md
#, fuzzy
msgid ""
"As an instructor, you should try to keep the discussions relevant, i.e., "
"keep the discussions related to how Rust does things vs some other language. "
"It can be hard to find the right balance, but err on the side of allowing "
"discussions since they engage people much more than one-way communication."
msgstr ""
"作为讲师，你应该尽量保证讨论话题的相关性，例如，讨论围绕Rust是如何做某些事"
"情，而不是其他的语言如何如何。 这个平衡点不容易找到，但是尽量倾向于允许讨论，"
"因为讨论比起单方面的灌输更有利于让大家投入。"

#: src/welcome-day-1.md
msgid ""
"The questions will likely mean that we talk about things ahead of the slides."
msgstr "有些问题会导致我们提前谈到后面的内容。"

#: src/welcome-day-1.md
msgid ""
"This is perfectly okay! Repetition is an important part of learning. "
"Remember that the slides are just a support and you are free to skip them as "
"you like."
msgstr ""
"这完全没有问题！重复是学习的一个重要方法。请记住，这些幻灯片只是一种辅助，你"
"可以选择性地跳过。"

#: src/welcome-day-1.md
msgid ""
"The idea for the first day is to show the \"basic\" things in Rust that "
"should have immediate parallels in other languages. The more advanced parts "
"of Rust come on the subsequent days."
msgstr ""
"第一天的目标是展示 Rust 中与其他编程语言有明显相似之处的 “基础”内容。Rust 中"
"更高级复杂的内容将在后续几天中逐步介绍。"

#: src/welcome-day-1.md
msgid ""
"If you're teaching this in a classroom, this is a good place to go over the "
"schedule. Note that there is an exercise at the end of each segment, "
"followed by a break. Plan to cover the exercise solution after the break. "
"The times listed here are a suggestion in order to keep the course on "
"schedule. Feel free to be flexible and adjust as necessary!"
msgstr ""
"如果您是在教室里授课，则这是一个好时机，可对课程时间表进行讲解。请注意，每节"
"课结束之后会有练习内容，然后是休息时间。安排在休息结束后讲解练习内容的解答。"
"为了确保课程按时间表进行，此处所列时间仅供参考。请按需进行灵活调整！"

#: src/hello-world.md src/types-and-values.md src/control-flow-basics.md
#: src/tuples-and-arrays.md src/references.md src/user-defined-types.md
#: src/pattern-matching.md src/methods-and-traits.md src/generics.md
#: src/std-types.md src/std-traits.md src/memory-management.md
#: src/smart-pointers.md src/borrowing.md src/slices-and-lifetimes.md
#: src/iterators.md src/modules.md src/testing.md src/error-handling.md
#: src/unsafe-rust.md
msgid "In this segment:"
msgstr ""

#: src/hello-world.md
msgid "[What is Rust?](./hello-world/what-is-rust.md) (10 minutes)"
msgstr ""

#: src/hello-world.md
msgid "[Hello, World](./hello-world/hello-world.md) (5 minutes)"
msgstr ""

#: src/hello-world.md
msgid "[Benefits of Rust](./hello-world/benefits.md) (3 minutes)"
msgstr ""

#: src/hello-world.md
msgid "[Playground](./hello-world/playground.md) (2 minutes)"
msgstr ""

#: src/hello-world.md
msgid "This segment should take about 20 minutes"
msgstr ""

#: src/hello-world/what-is-rust.md
msgid ""
"Rust is a new programming language which had its [1.0 release in 2015]"
"(https://blog.rust-lang.org/2015/05/15/Rust-1.0.html):"
msgstr ""
"Rust 是一门新的编程语言，它的[1.0 版本于 2015 年发布](https://blog.rust-lang."
"org/2015/05/15/Rust-1.0.html)："

#: src/hello-world/what-is-rust.md
msgid "Rust is a statically compiled language in a similar role as C++"
msgstr "Rust 是一门静态编译语言，其功能定位与 C++ 相似"

#: src/hello-world/what-is-rust.md
msgid "`rustc` uses LLVM as its backend."
msgstr "`rustc` 使用 LLVM 作为它的后端。"

#: src/hello-world/what-is-rust.md
msgid ""
"Rust supports many [platforms and architectures](https://doc.rust-lang.org/"
"nightly/rustc/platform-support.html):"
msgstr ""
"Rust 支持多种[平台和架构](https://doc.rust-lang.org/nightly/rustc/platform-"
"support.html):"

#: src/hello-world/what-is-rust.md
msgid "x86, ARM, WebAssembly, ..."
msgstr "x86、ARM、WebAssembly......"

#: src/hello-world/what-is-rust.md
msgid "Linux, Mac, Windows, ..."
msgstr "Linux、Mac、Windows......"

#: src/hello-world/what-is-rust.md
msgid "Rust is used for a wide range of devices:"
msgstr "Rust 被广泛用于各种设备中："

#: src/hello-world/what-is-rust.md
msgid "firmware and boot loaders,"
msgstr "固件和引导程序，"

#: src/hello-world/what-is-rust.md
msgid "smart displays,"
msgstr "智能显示器，"

#: src/hello-world/what-is-rust.md
msgid "mobile phones,"
msgstr "手机，"

#: src/hello-world/what-is-rust.md
msgid "desktops,"
msgstr "桌面，"

#: src/hello-world/what-is-rust.md
msgid "servers."
msgstr "服务器。"

#: src/hello-world/what-is-rust.md
msgid "Rust fits in the same area as C++:"
msgstr "Rust 和 C++ 适用于类似的场景："

#: src/hello-world/what-is-rust.md
msgid "High flexibility."
msgstr "极高的灵活性。"

#: src/hello-world/what-is-rust.md
msgid "High level of control."
msgstr "高度的控制能力。"

#: src/hello-world/what-is-rust.md
msgid ""
"Can be scaled down to very constrained devices such as microcontrollers."
msgstr "能够在资源匮乏的设备（如手机）上运行。"

#: src/hello-world/what-is-rust.md
msgid "Has no runtime or garbage collection."
msgstr "没有运行时和垃圾收集。"

#: src/hello-world/what-is-rust.md
msgid "Focuses on reliability and safety without sacrificing performance."
msgstr "关注程序可靠性和安全性，而不会牺牲任何性能。"

#: src/hello-world/hello-world.md
msgid ""
"Let us jump into the simplest possible Rust program, a classic Hello World "
"program:"
msgstr "让我们进入最简单的 Rust 程序，一个经典的 Hello World 程序："

#: src/hello-world/hello-world.md
#, fuzzy
msgid "\"Hello 🌍!\""
msgstr "\"Hello 🌍!\""

#: src/hello-world/hello-world.md
msgid "What you see:"
msgstr "你看到的："

#: src/hello-world/hello-world.md
msgid "Functions are introduced with `fn`."
msgstr "函数以 `fn` 开头。"

#: src/hello-world/hello-world.md
msgid "Blocks are delimited by curly braces like in C and C++."
msgstr "像 C 和 C++ 一样，块由花括号分隔。"

#: src/hello-world/hello-world.md
msgid "The `main` function is the entry point of the program."
msgstr "`main` 函数是程序的入口点。"

#: src/hello-world/hello-world.md
msgid "Rust has hygienic macros, `println!` is an example of this."
msgstr "Rust 有卫生宏 (hygienic macros)，`println!` 就是一个例子。"

#: src/hello-world/hello-world.md
msgid "Rust strings are UTF-8 encoded and can contain any Unicode character."
msgstr "Rust 字符串是 UTF-8 编码的，可以包含任何 Unicode 字符。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"This slide tries to make the students comfortable with Rust code. They will "
"see a ton of it over the next four days so we start small with something "
"familiar."
msgstr ""
"这张幻灯片试图让学生们熟悉 Rust 代码。在接下来的四天里，他们会看到很多 Rust "
"代码, 所以我们从一些熟悉的东西开始。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"Rust is very much like other languages in the C/C++/Java tradition. It is "
"imperative and it doesn't try to reinvent things unless absolutely necessary."
msgstr ""
"Rust 非常像 C/C++/Java 等其他传统语言。它是指令式语言（而非函数式），而且除非"
"绝对必要，它不会尝试重新发明新的概念。"

#: src/hello-world/hello-world.md
msgid "Rust is modern with full support for things like Unicode."
msgstr "Rust 是一门现代编程语言，它完全支持 Unicode 等特性。"

#: src/hello-world/hello-world.md
#, fuzzy
msgid ""
"Rust uses macros for situations where you want to have a variable number of "
"arguments (no function [overloading](../control-flow-basics/functions.md))."
msgstr ""
"在需要处理可变数量的参数的情况下，Rust 使用宏（没有函数[重载](basic-syntax/"
"functions-interlude.md)）。"

#: src/hello-world/hello-world.md
msgid ""
"Macros being 'hygienic' means they don't accidentally capture identifiers "
"from the scope they are used in. Rust macros are actually only [partially "
"hygienic](https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene."
"html)."
msgstr ""
"宏是“卫生的”，这意味着它们不会意外地捕获它们所在作用域中的标识符。实际上，"
"Rust 的宏只是[部分卫生](https://veykril.github.io/tlborm/decl-macros/"
"minutiae/hygiene.html)。"

#: src/hello-world/hello-world.md
msgid ""
"Rust is multi-paradigm. For example, it has powerful [object-oriented "
"programming features](https://doc.rust-lang.org/book/ch17-00-oop.html), and, "
"while it is not a functional language, it includes a range of [functional "
"concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html)."
msgstr ""
"Rust 是多范式编程语言。例如，它具有强大的[面向对象的编程功能](https://doc."
"rust-lang.org/book/ch17-00-oop.html)，虽然它不是函数式语言，但包括一系列的[函"
"数概念](https://doc.rust-lang.org/book/ch13-00-functional-features.html)。"

#: src/hello-world/benefits.md
msgid "Some unique selling points of Rust:"
msgstr "Rust 有一些独特的卖点："

#: src/hello-world/benefits.md
msgid ""
"_Compile time memory safety_ - whole classes of memory bugs are prevented at "
"compile time"
msgstr "_编译时内存安全_：在编译时可防止所有类内存 bug"

#: src/hello-world/benefits.md
msgid "No uninitialized variables."
msgstr "不存在未初始化的变量。"

#: src/hello-world/benefits.md
msgid "No double-frees."
msgstr "不存在“双重释放”。"

#: src/hello-world/benefits.md
msgid "No use-after-free."
msgstr "不存在“释放后使用”。"

#: src/hello-world/benefits.md
msgid "No `NULL` pointers."
msgstr "不存在 `NULL` 指针。"

#: src/hello-world/benefits.md
msgid "No forgotten locked mutexes."
msgstr "不存在被遗忘的互斥锁。"

#: src/hello-world/benefits.md
msgid "No data races between threads."
msgstr "不存在线程之间的数据竞争。"

#: src/hello-world/benefits.md
msgid "No iterator invalidation."
msgstr "不存在迭代器失效。"

#: src/hello-world/benefits.md
msgid ""
"_No undefined runtime behavior_ - what a Rust statement does is never left "
"unspecified"
msgstr "_没有未定义的运行时行为_：每个 Rust 语句的行为都有明确定义"

#: src/hello-world/benefits.md
msgid "Array access is bounds checked."
msgstr "数组访问有边界检查。"

#: src/hello-world/benefits.md
msgid "Integer overflow is defined (panic or wrap-around)."
msgstr "整数溢出有明确定义（panic 或回绕）。"

#: src/hello-world/benefits.md
msgid ""
"_Modern language features_ - as expressive and ergonomic as higher-level "
"languages"
msgstr "_现代语言功能_：具有与高级语言一样丰富且人性化的表达能力"

#: src/hello-world/benefits.md
msgid "Enums and pattern matching."
msgstr "枚举和模式匹配。"

#: src/hello-world/benefits.md
msgid "Generics."
msgstr "泛型。"

#: src/hello-world/benefits.md
msgid "No overhead FFI."
msgstr "无额外开销的外部函数接口（FFI）。"

#: src/hello-world/benefits.md
msgid "Zero-cost abstractions."
msgstr "零成本抽象。"

#: src/hello-world/benefits.md
msgid "Great compiler errors."
msgstr "强大的编译器错误提示。"

#: src/hello-world/benefits.md
msgid "Built-in dependency manager."
msgstr "内置依赖管理器。"

#: src/hello-world/benefits.md
msgid "Built-in support for testing."
msgstr "对测试的内置支持。"

#: src/hello-world/benefits.md
msgid "Excellent Language Server Protocol support."
msgstr "优秀的语言服务协议（Language Server Protocol）支持。"

#: src/hello-world/benefits.md
msgid ""
"Do not spend much time here. All of these points will be covered in more "
"depth later."
msgstr "不用在这里占用过多时间。所有这些要点均会在后面进行详细讲解。"

#: src/hello-world/benefits.md
msgid ""
"Make sure to ask the class which languages they have experience with. "
"Depending on the answer you can highlight different features of Rust:"
msgstr "应该问问学生们都使用过哪些语言。根据答案侧重讲解 Rust 的不同特性："

#: src/hello-world/benefits.md
msgid ""
"Experience with C or C++: Rust eliminates a whole class of _runtime errors_ "
"via the borrow checker. You get performance like in C and C++, but you don't "
"have the memory unsafety issues. In addition, you get a modern language with "
"constructs like pattern matching and built-in dependency management."
msgstr ""
"使用过 C 或 C++：Rust 利用借用检查消除了一类 _运行时错误_ 。你可以达到堪比 C "
"和 C++ 的性能，而没有内存不安全的问题。并且你还可以得到些现代的语言构造，比如"
"模式匹配和内置依赖管理。"

#: src/hello-world/benefits.md
msgid ""
"Experience with Java, Go, Python, JavaScript...: You get the same memory "
"safety as in those languages, plus a similar high-level language feeling. In "
"addition you get fast and predictable performance like C and C++ (no garbage "
"collector) as well as access to low-level hardware (should you need it)"
msgstr ""
"使用过 Java、Go、Python、JavaScript......：你可以得到和这些语言相同的内存安全"
"特性，并拥有类似的使用高级语言的感受。同时你可以得到类似 C 和 C++ 的高速且可"
"预测的执行性能（无垃圾回收机制），以及在需要时对底层硬件的访问。"

#: src/hello-world/playground.md
#, fuzzy
msgid ""
"The [Rust Playground](https://play.rust-lang.org/) provides an easy way to "
"run short Rust programs, and is the basis for the examples and exercises in "
"this course. Try running the \"hello-world\" program it starts with. It "
"comes with a few handy features:"
msgstr ""
"[Rust Playground](https://play.rust-lang.org/) 提供了一种运行简短 Rust 程序的"
"简便方法，也是本课程所有示例和练习的依据所在。请尝试运行它初始提供的 \"hello-"
"world\" 程序。该程序提供了一些便捷功能："

#: src/hello-world/playground.md
msgid ""
"Under \"Tools\", use the `rustfmt` option to format your code in the "
"\"standard\" way."
msgstr "在 \"Tools\" 下，使用 `rustfmt` 选项以 \"standard\" 方式设置代码格式。"

#: src/hello-world/playground.md
msgid ""
"Rust has two main \"profiles\" for generating code: Debug (extra runtime "
"checks, less optimization) and Release (fewer runtime checks, lots of "
"optimization). These are accessible under \"Debug\" at the top."
msgstr ""
"Rust 具有两个用于生成代码的主要 “配置文件”：调试（进行额外运行时检查、较少优"
"化）和发布（较少运行时检查，进行大量优化）。可以在顶部的 \"Debug\" 下访问这些"
"内容。"

#: src/hello-world/playground.md
msgid ""
"If you're interested, use \"ASM\" under \"...\" to see the generated "
"assembly code."
msgstr "如果感兴趣，您可以使用 \"...\" 下的 \"ASM\" 查看生成的汇编代码。"

#: src/hello-world/playground.md
#, fuzzy
msgid ""
"As students head into the break, encourage them to open up the playground "
"and experiment a little. Encourage them to keep the tab open and try things "
"out during the rest of the course. This is particularly helpful for advanced "
"students who want to know more about Rust's optimizations or generated "
"assembly."
msgstr ""
"当学生开始休息时，鼓励他们打开 Playground 并进行一些实验。鼓励他们让该标签页"
"保持打开状态，并在课余时间里进行一些尝试。对于具有较高水平并且希望深入了解 "
"Rust 优化技巧或生成的汇编代码的学生，这尤其有益。"

#: src/types-and-values.md
msgid "[Variables](./types-and-values/variables.md) (5 minutes)"
msgstr ""

#: src/types-and-values.md
msgid "[Values](./types-and-values/values.md) (10 minutes)"
msgstr ""

#: src/types-and-values.md
msgid "[Arithmetic](./types-and-values/arithmetic.md) (5 minutes)"
msgstr ""

#: src/types-and-values.md
msgid "[Strings](./types-and-values/strings.md) (10 minutes)"
msgstr ""

#: src/types-and-values.md
msgid "[Type Inference](./types-and-values/inference.md) (5 minutes)"
msgstr ""

#: src/types-and-values.md
msgid "[Exercise: Fibonacci](./types-and-values/exercise.md) (30 minutes)"
msgstr ""

#: src/types-and-values.md src/testing.md src/unsafe-rust.md
msgid "This segment should take about 1 hour and 5 minutes"
msgstr ""

#: src/types-and-values/variables.md
#, fuzzy
msgid ""
"Rust provides type safety via static typing. Variable bindings are made with "
"`let`:"
msgstr "Rust 通过静态类型实现了类型安全。变量绑定默认是不可变的："

#: src/types-and-values/variables.md src/control-flow-basics/loops.md
#: src/control-flow-basics/break-continue.md
#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"x: {x}\""
msgstr "\"x: {x}\""

#: src/types-and-values/variables.md
msgid ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"
msgstr ""
"// x = 20;\n"
"    // println!(\"x: {x}\");\n"

#: src/types-and-values/variables.md
msgid ""
"Uncomment the `x = 20` to demonstrate that variables are immutable by "
"default. Add the `mut` keyword to allow changes."
msgstr ""
"取消备注 `x = 20`，以证明变量默认是不可变的。添加 `mut` 关键字以允许进行更"
"改。"

#: src/types-and-values/variables.md
msgid ""
"The `i32` here is the type of the variable. This must be known at compile "
"time, but type inference (covered later) allows the programmer to omit it in "
"many cases."
msgstr ""
"这里的 `i32` 是变量的类型。编译时必须已知类型，但在很多情况下，由于具有类型推"
"理功能（稍后介绍），程序员可以忽略这一点。"

#: src/types-and-values/values.md
msgid ""
"Here are some basic built-in types, and the syntax for literal values of "
"each type."
msgstr "以下是一些基本的内置类型以及每种类型的字面量值的语法。"

#: src/types-and-values/values.md src/tuples-and-arrays/tuples-and-arrays.md
#: src/unsafe-rust/exercise.md
msgid "Types"
msgstr "类型"

#: src/types-and-values/values.md src/tuples-and-arrays/tuples-and-arrays.md
msgid "Literals"
msgstr "字面量"

#: src/types-and-values/values.md
msgid "Signed integers"
msgstr "有符号整数"

#: src/types-and-values/values.md
msgid "`i8`, `i16`, `i32`, `i64`, `i128`, `isize`"
msgstr "`i8`、`i16`、`i32`、`i64`、`i128`、`isize`"

#: src/types-and-values/values.md
msgid "`-10`, `0`, `1_000`, `123_i64`"
msgstr "`-10`、`0`、`1_000`、`123_i64`"

#: src/types-and-values/values.md
msgid "Unsigned integers"
msgstr "无符号整数"

#: src/types-and-values/values.md
msgid "`u8`, `u16`, `u32`, `u64`, `u128`, `usize`"
msgstr "`u8`、`u16`、`u32`、`u64`、`u128`、`usize`"

#: src/types-and-values/values.md
msgid "`0`, `123`, `10_u16`"
msgstr "`0`、`123`、`10_u16`"

#: src/types-and-values/values.md
msgid "Floating point numbers"
msgstr "浮点数"

#: src/types-and-values/values.md
msgid "`f32`, `f64`"
msgstr "`f32`、`f64`"

#: src/types-and-values/values.md
msgid "`3.14`, `-10.0e20`, `2_f32`"
msgstr "`3.14`、`-10.0e20`、`2_f32`"

#: src/types-and-values/values.md
msgid "Unicode scalar values"
msgstr "Unicode 标量类型"

#: src/types-and-values/values.md
msgid "`char`"
msgstr "`char`"

#: src/types-and-values/values.md
msgid "`'a'`, `'α'`, `'∞'`"
msgstr "`'a'`、`'α'`、`'∞'`"

#: src/types-and-values/values.md
msgid "Booleans"
msgstr "布尔值"

#: src/types-and-values/values.md
msgid "`bool`"
msgstr "`bool`"

#: src/types-and-values/values.md
msgid "`true`, `false`"
msgstr "`true`、`false`"

#: src/types-and-values/values.md
msgid "The types have widths as follows:"
msgstr "各类型占用的空间为："

#: src/types-and-values/values.md
msgid "`iN`, `uN`, and `fN` are _N_ bits wide,"
msgstr "`iN`, `uN` 和 `fN` 占用 _N_ 位，"

#: src/types-and-values/values.md
msgid "`isize` and `usize` are the width of a pointer,"
msgstr "`isize` 和 `usize` 占用一个指针大小的空间，"

#: src/types-and-values/values.md
msgid "`char` is 32 bits wide,"
msgstr "`char` 占用 32 位空间，"

#: src/types-and-values/values.md
msgid "`bool` is 8 bits wide."
msgstr "`bool` 占用 8 位空间。"

#: src/types-and-values/values.md
msgid "There are a few syntaxes which are not shown above:"
msgstr "上表中还有一些未提及的语法："

#: src/types-and-values/values.md
msgid ""
"All underscores in numbers can be left out, they are for legibility only. So "
"`1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written "
"as `123i64`."
msgstr ""
"数字中的所有下划线均可忽略，它们只是为了方便辨识。因此，`1_000` 可以写为 "
"`1000`（或 `10_00`），而 `123_i64` 可以写为 `123i64`。"

#: src/types-and-values/arithmetic.md
msgid "\"result: {}\""
msgstr "\"result: {}\""

#: src/types-and-values/arithmetic.md
msgid ""
"This is the first time we've seen a function other than `main`, but the "
"meaning should be clear: it takes three integers, and returns an integer. "
"Functions will be covered in more detail later."
msgstr ""
"这是我们第一次看到除 `main` 之外的函数，不过其含义应该很明确：它接受三个整"
"数，然后返回一个整数。稍后会对这些函数进行详细介绍。"

#: src/types-and-values/arithmetic.md
msgid "Arithmetic is very similar to other languages, with similar precedence."
msgstr "算术和优先级均与其他语言极为相似。"

#: src/types-and-values/arithmetic.md
msgid ""
"What about integer overflow? In C and C++ overflow of _signed_ integers is "
"actually undefined, and might do different things on different platforms or "
"compilers. In Rust, it's defined."
msgstr ""
"整数溢出是什么样的？在 C 和 C++ 中，_有符号_ 整数溢出实际上是未定义的，可能会"
"在不同平台或编译器上执行不同的操作。在 Rust 中，整数溢出具有明确定义。"

#: src/types-and-values/arithmetic.md
#, fuzzy
msgid ""
"Change the `i32`'s to `i16` to see an integer overflow, which panics "
"(checked) in a debug build and wraps in a release build. There are other "
"options, such as overflowing, saturating, and carrying. These are accessed "
"with method syntax, e.g., `(a * b).saturating_add(b * c).saturating_add(c * "
"a)`."
msgstr ""
"将 `i32` 更改为 `i16` 即可看到整数溢出，在调试 build 中，这会触发 panic（已检"
"查），而在发布 build 中，则会发生封装。还有其他选项，例如溢出、饱和和进位等。"
"可以通过方法语法访问这些选项，例如`(a * b).saturating_add(b * c)."
"saturating_add(c * a)`。"

#: src/types-and-values/arithmetic.md
msgid ""
"In fact, the compiler will detect overflow of constant expressions, which is "
"why the example requires a separate function."
msgstr ""
"事实上，编译器会检测常量表达式的溢出情况，这便是为何该示例需要单独的函数。"

#: src/types-and-values/strings.md
#, fuzzy
msgid ""
"Rust has two types to represent strings, both of which will be covered in "
"more depth later. Both _always_ store UTF-8 encoded strings."
msgstr ""
"Rust 有两种用于表示字符串的类型，稍后会对它们进行更详细的介绍。两种类型都 _始"
"终_ 存储UTF-8 编码的字符串。"

#: src/types-and-values/strings.md
#, fuzzy
msgid "`String` - a modifiable, owned string."
msgstr "`String` 是一个可变字符串缓冲区。"

#: src/types-and-values/strings.md
msgid "`&str` - a read-only string. String literals have this type."
msgstr "`&str` 为只读字符串。字符串字面量属于此类型。"

#: src/types-and-values/strings.md
msgid "\"Greetings\""
msgstr "\"Greetings\""

#: src/types-and-values/strings.md
msgid "\"🪐\""
msgstr "\"🪐\""

#: src/types-and-values/strings.md
msgid "\", \""
msgstr "\", \""

#: src/types-and-values/strings.md
msgid "\"final sentence: {}\""
msgstr "\"final sentence: {}\""

#: src/types-and-values/strings.md src/async/control-flow/join.md
msgid "\"{:?}\""
msgstr "\"{:?}\""

#: src/types-and-values/strings.md
msgid "//println!(\"{:?}\", &sentence[12..13]);\n"
msgstr "//println!(\"{:?}\", &sentence[12..13]);\n"

#: src/types-and-values/strings.md
msgid ""
"This slide introduces strings. Everything here will be covered in more depth "
"later, but this is enough for subsequent slides and exercises to use strings."
msgstr ""
"此幻灯片介绍了字符串。此处所有内容均会在稍后进行更详细的介绍，但对于后续幻灯"
"片和练习而言，当前介绍足以支撑使用字符串了。"

#: src/types-and-values/strings.md
msgid "Invalid UTF-8 in a string is UB, and this not allowed in safe Rust."
msgstr "字符串中的无效 UTF-8 是未定义行为 (UB)，这在安全的 Rust 中是不允许的。"

#: src/types-and-values/strings.md
msgid ""
"`String` is a user-defined type with a constructor (`::new()`) and methods "
"like `s.push_str(..)`."
msgstr ""
"`String` 是一种用户定义的类型，具有构造函数 (`::new()`) 和类似 `s."
"push_str(..)` 的方法。"

#: src/types-and-values/strings.md
msgid ""
"The `&` in `&str` indicates that this is a reference. We will cover "
"references later, so for now just think of `&str` as a unit meaning \"a read-"
"only string\"."
msgstr ""
"`&str` 中的 `&` 表示这是一个引用。我们稍后将介绍引用，现在只需将 `&str` 视为"
"一个单位，表示 “只读字符”。"

#: src/types-and-values/strings.md
msgid ""
"The commented-out line is indexing into the string by byte position. "
"`12..13` does not end on a character boundary, so the program panics. Adjust "
"it to a range that does, based on the error message."
msgstr ""
"注释掉的行会按字节位置编入字符串的索引。`12..13` 不是以字符边界结尾，因此会导"
"致程序 panic。根据错误消息，将其调整至以字符边界结尾的范围。"

#: src/types-and-values/strings.md
msgid ""
"Raw strings allow you to create a `&str` value with escapes disabled: "
"`r\"\\n\" == \"\\\\n\"`. You can embed double-quotes by using an equal "
"amount of `#` on either side of the quotes:"
msgstr ""
"原始字符串可在创建 `&str` 时禁用转义：`r\"\\n\" == \"\\\\n\"`。可以在外层引号"
"两侧添加相同数量的 `#`，以在字符串中嵌入双引号："

#: src/types-and-values/inference.md
msgid "Rust will look at how the variable is _used_ to determine the type:"
msgstr "Rust 会根据变量的使用来确定其类型："

#: src/types-and-values/inference.md
msgid ""
"This slide demonstrates how the Rust compiler infers types based on "
"constraints given by variable declarations and usages."
msgstr "这张幻灯片演示了 Rust 编译器是如何根据变量声明和用法来推导其类型的。"

#: src/types-and-values/inference.md
msgid ""
"It is very important to emphasize that variables declared like this are not "
"of some sort of dynamic \"any type\" that can hold any data. The machine "
"code generated by such declaration is identical to the explicit declaration "
"of a type. The compiler does the job for us and helps us write more concise "
"code."
msgstr ""
"需要重点强调的是这样声明的变量并非像那种动态类型语言中可以持有任何数据的“任何"
"类型”。这种声明所生成的机器码与明确类型声明完全相同。编译器进行类型推导能够让"
"我们编写更简略的代码。"

#: src/types-and-values/inference.md
msgid ""
"When nothing constrains the type of an integer literal, Rust defaults to "
"`i32`. This sometimes appears as `{integer}` in error messages. Similarly, "
"floating-point literals default to `f64`."
msgstr ""
"当整数字面量的类型不受限制时，Rust 默认为 `i32`。这在错误消息中有时显示为 "
"`{integer}`。同样，浮点字面量默认为 `f64`。"

#: src/types-and-values/inference.md
msgid "// ERROR: no implementation for `{float} == {integer}`\n"
msgstr "// ERROR: no implementation for `{float} == {integer}`\n"

#: src/types-and-values/exercise.md
#, fuzzy
msgid ""
"The first and second Fibonacci numbers are both `1`. For n>2, the n'th "
"Fibonacci number is calculated recursively as the sum of the n-1'th and "
"n-2'th Fibonacci numbers."
msgstr ""
"第一个和第二个斐波那契数都是 `1`。如果 n>2，则第 n 个斐波那契数以递归方式计算"
"为第 n-1 个和第 n-2 个斐波那契数之和。"

#: src/types-and-values/exercise.md
#, fuzzy
msgid ""
"Write a function `fib(n)` that calculates the n'th Fibonacci number. When "
"will this function panic?"
msgstr "编写一个函数 `fib(n)`，用于计算第 n 个斐波那契数。何时该函数会 panic？"

#: src/types-and-values/exercise.md
msgid "// The base case.\n"
msgstr "// The base case.\n"

#: src/types-and-values/exercise.md src/control-flow-basics/exercise.md
#, fuzzy
msgid "\"Implement this\""
msgstr "实现"

#: src/types-and-values/exercise.md
msgid "// The recursive case.\n"
msgstr "// The recursive case.\n"

#: src/types-and-values/exercise.md src/types-and-values/solution.md
msgid "\"fib(n) = {}\""
msgstr "\"fib(n) = {}\""

#: src/control-flow-basics.md
msgid "[Conditionals](./control-flow-basics/conditionals.md) (5 minutes)"
msgstr ""

#: src/control-flow-basics.md
msgid "[Loops](./control-flow-basics/loops.md) (5 minutes)"
msgstr ""

#: src/control-flow-basics.md
msgid ""
"[break and continue](./control-flow-basics/break-continue.md) (5 minutes)"
msgstr ""

#: src/control-flow-basics.md
msgid ""
"[Blocks and Scopes](./control-flow-basics/blocks-and-scopes.md) (10 minutes)"
msgstr ""

#: src/control-flow-basics.md
msgid "[Functions](./control-flow-basics/functions.md) (3 minutes)"
msgstr ""

#: src/control-flow-basics.md
msgid "[Macros](./control-flow-basics/macros.md) (2 minutes)"
msgstr ""

#: src/control-flow-basics.md
msgid ""
"[Exercise: Collatz Sequence](./control-flow-basics/exercise.md) (30 minutes)"
msgstr ""

#: src/control-flow-basics.md src/tuples-and-arrays.md src/borrowing.md
msgid "This segment should take about 1 hour"
msgstr ""

#: src/control-flow-basics/conditionals.md
msgid "Much of the Rust syntax will be familiar to you from C, C++ or Java:"
msgstr "Rust 的许多语法与 C、C++ 和 Java 的语法相似："

#: src/control-flow-basics/conditionals.md
#, fuzzy
msgid "Blocks are delimited by curly braces."
msgstr "代码块和作用域都是由花括号来界定的。"

#: src/control-flow-basics/conditionals.md
msgid ""
"Line comments are started with `//`, block comments are delimited by `/* ... "
"*/`."
msgstr "行内注释以 `//` 起始，块注释使用 `/* ... */` 来界定。"

#: src/control-flow-basics/conditionals.md
msgid "Keywords like `if` and `while` work the same."
msgstr "`if` 和 `while` 等关键词作用与以上语言一致。"

#: src/control-flow-basics/conditionals.md
msgid "Variable assignment is done with `=`, comparison is done with `==`."
msgstr "变量赋值使用 `=`，值之间比较使用 `==`。"

#: src/control-flow-basics/conditionals.md
msgid "`if` expressions"
msgstr "`if` 表达式"

#: src/control-flow-basics/conditionals.md
msgid ""
"You use [`if` expressions](https://doc.rust-lang.org/reference/expressions/"
"if-expr.html#if-expressions) exactly like `if` statements in other languages:"
msgstr ""
"[`if` 表达式](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-expressions) 的用法与其他语言中的 `if` 语句完全一样。"

#: src/control-flow-basics/conditionals.md
msgid "\"small\""
msgstr "\"small\""

#: src/control-flow-basics/conditionals.md
msgid "\"biggish\""
msgstr "\"biggish\""

#: src/control-flow-basics/conditionals.md
msgid "\"huge\""
msgstr "\"huge\""

#: src/control-flow-basics/conditionals.md
msgid ""
"In addition, you can use `if` as an expression. The last expression of each "
"block becomes the value of the `if` expression:"
msgstr ""
"此外，你还可以将 `if` 用作一个表达式。每个块的最后一个表达式 将成为 `if` 表达"
"式的值："

#: src/control-flow-basics/conditionals.md
msgid "\"large\""
msgstr "\"large\""

#: src/control-flow-basics/conditionals.md
msgid "\"number size: {}\""
msgstr "\"number size: {}\""

#: src/control-flow-basics/conditionals.md
#, fuzzy
msgid ""
"Because `if` is an expression and must have a particular type, both of its "
"branch blocks must have the same type. Show what happens if you add `;` "
"after `\"small\"` in the second example."
msgstr ""
"由于 `if` 是一个表达式且必须有一个特定的类型，因此它的两个分支块必须有相同的"
"类型。考虑在第二个示例中将 `;` 添加到 `x / 2` 的后面，看看会出现什么情况。"

#: src/control-flow-basics/conditionals.md
msgid ""
"When `if` is used in an expression, the expression must have a `;` to "
"separate it from the next statement. Remove the `;` before `println!` to see "
"the compiler error."
msgstr ""
"如果在表达式中使用 `if`，则表达式中必须包含 `;` 来将其与下一个语句分隔开。移"
"除 `println!` 前面的 `;` 即可查看编译器错误。"

#: src/control-flow-basics/loops.md
msgid "There are three looping keywords in Rust: `while`, `loop`, and `for`:"
msgstr "Rust 中有三个循环关键字：`while`、`loop` 和 `for`："

#: src/control-flow-basics/loops.md
#, fuzzy
msgid "`while`"
msgstr "`while` 循环"

#: src/control-flow-basics/loops.md
#, fuzzy
msgid ""
"The [`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-"
"expr.html#predicate-loops) works much like in other languages, executing the "
"loop body as long as the condition is true."
msgstr ""
"[`while` 关键字](https://doc.rust-lang.org/reference/expressions/loop-expr."
"html#predicate-loops) 的工作方式与其他语言非常相似："

#: src/control-flow-basics/loops.md
msgid "\"Final x: {x}\""
msgstr "\"Final x: {x}\""

#: src/control-flow-basics/loops.md
#, fuzzy
msgid "`for`"
msgstr "`for` 循环"

#: src/control-flow-basics/loops.md
#, fuzzy
msgid ""
"The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates "
"over ranges of values:"
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 用于定义析构函"
"数。"

#: src/control-flow-basics/loops.md
msgid "`loop`"
msgstr "`loop`"

#: src/control-flow-basics/loops.md
#, fuzzy
msgid ""
"The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just "
"loops forever, until a `break`."
msgstr ""
"[`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 用于定义析构函"
"数。"

#: src/control-flow-basics/loops.md
msgid "\"{i}\""
msgstr "\"{i}\""

#: src/control-flow-basics/loops.md
msgid ""
"We will discuss iteration later; for now, just stick to range expressions."
msgstr "我们稍后会讨论迭代；暂时只使用范围表达式。"

#: src/control-flow-basics/loops.md
msgid ""
"Note that the `for` loop only iterates to `4`. Show the `1..=5` syntax for "
"an inclusive range."
msgstr ""
"请注意，`for` 循环只迭代到 `4`。现在展示使用 `1..=5` 语法表示一个包含边界的范"
"围。"

#: src/control-flow-basics/break-continue.md
#, fuzzy
msgid ""
"If you want to exit any kind of loop early, use [`break`](https://doc.rust-"
"lang.org/reference/expressions/loop-expr.html#break-expressions). For "
"`loop`, this can take an optional expression that becomes the value of the "
"`loop` expression."
msgstr ""
"如果你想提前退出循环，请使用 [`break`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#break-expressions)，"

#: src/control-flow-basics/break-continue.md
msgid ""
"If you want to immediately start the next iteration use [`continue`](https://"
"doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)."
msgstr ""
"如果需要立即启动 下一次迭代，请使用 [`continue`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#continue-expressions)。"

#: src/control-flow-basics/break-continue.md
msgid "\"{result}\""
msgstr "\"{result}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"Both `continue` and `break` can optionally take a label argument which is "
"used to break out of nested loops:"
msgstr "`continue` 和 `break` 都可以选择接受一个标签参数，用来 终止嵌套循环："

#: src/control-flow-basics/break-continue.md
msgid "\"x: {x}, i: {i}\""
msgstr "\"x: {x}, i: {i}\""

#: src/control-flow-basics/break-continue.md
msgid ""
"In this case we break the outer loop after 3 iterations of the inner loop."
msgstr "在本示例中，我们会在内循环 3 次迭代后终止外循环。"

#: src/control-flow-basics/break-continue.md
msgid ""
"Note that `loop` is the only looping construct which returns a non-trivial "
"value. This is because it's guaranteed to be entered at least once (unlike "
"`while` and `for` loops)."
msgstr ""
"请注意，`loop` 是唯一返回有意义的值的循环结构。 这是因为它保证至少被输入一次"
"（与 `while` 和 `for` 循环不同）。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Blocks"
msgstr "块"

#: src/control-flow-basics/blocks-and-scopes.md
#, fuzzy
msgid ""
"A block in Rust contains a sequence of expressions, enclosed by braces `{}`. "
"Each block has a value and a type, which are those of the last expression of "
"the block:"
msgstr "Rust 中的块包含值和类型：值是 块的最后一个表达式："

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"y: {y}\""
msgstr "\"y: {y}\""

#: src/control-flow-basics/blocks-and-scopes.md
#, fuzzy
msgid ""
"If the last expression ends with `;`, then the resulting value and type is "
"`()`."
msgstr "不过，如果最后一个表达式以 `;` 结尾，那么生成的值和类型为 `()`。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "Scopes and Shadowing"
msgstr "作用域和遮蔽（Shadowing）"

#: src/control-flow-basics/blocks-and-scopes.md
msgid "A variable's scope is limited to the enclosing block."
msgstr "变量的作用域仅限于封闭代码块内。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can shadow variables, both those from outer scopes and variables from "
"the same scope:"
msgstr "你可以隐藏变量，位于外部作用域的变量和 相同作用域的变量都可以："

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"before: {a}\""
msgstr "\"before: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md src/std-traits/from-and-into.md
#: src/slices-and-lifetimes/solution.md
#, fuzzy
msgid "\"hello\""
msgstr "\"hello\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"inner scope: {a}\""
msgstr "\"inner scope: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"shadowed in inner scope: {a}\""
msgstr "\"shadowed in inner scope: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid "\"after: {a}\""
msgstr "\"after: {a}\""

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"You can show how the value of the block changes by changing the last line in "
"the block. For instance, adding/removing a semicolon or using a `return`."
msgstr ""
"你可以通过更改块的最后一行，来展示块值的变化情况。例如，添加/移除分号或使用 "
"`return`。"

#: src/control-flow-basics/blocks-and-scopes.md
#, fuzzy
msgid ""
"Show that a variable's scope is limited by adding a `b` in the inner block "
"in the last example, and then trying to access it outside that block."
msgstr ""
"通过在上一个示例的内部代码块中添加 `b`，并尝试在该代码块之外访问它，表明变量"
"的作用域是受限的。"

#: src/control-flow-basics/blocks-and-scopes.md
#, fuzzy
msgid ""
"Shadowing is different from mutation, because after shadowing both "
"variable's memory locations exist at the same time. Both are available under "
"the same name, depending where you use it in the code."
msgstr ""
"定义: 遮蔽和变更（mutation）不同，因为在遮蔽之后，两个变量都会同时存在于内存"
"的不同位置中。在同一个名字下的两个变量都是可以被使用的，但是你在代码的哪里使"
"用会最终决定你使用哪一个变量。"

#: src/control-flow-basics/blocks-and-scopes.md
#, fuzzy
msgid "A shadowing variable can have a different type."
msgstr "一个遮蔽变量可以具有不同的类型。"

#: src/control-flow-basics/blocks-and-scopes.md
msgid ""
"Shadowing looks obscure at first, but is convenient for holding on to values "
"after `.unwrap()`."
msgstr "隐藏起初看起来会有些晦涩，但是它很便于存 `.unwrap()` 之后的得到的值。"

#: src/control-flow-basics/functions.md
msgid ""
"Declaration parameters are followed by a type (the reverse of some "
"programming languages), then a return type."
msgstr "类型跟随在声明的参数后（与某些编程语言相反），然后是返回类型。"

#: src/control-flow-basics/functions.md
#, fuzzy
msgid ""
"The last expression in a function body (or any block) becomes the return "
"value. Simply omit the `;` at the end of the expression. The `return` "
"keyword can be used for early return, but the \"bare value\" form is "
"idiomatic at the end of a function (refactor `gcd` to use a `return`)."
msgstr ""
"函数体（或任何块）中的最后一个表达式将成为返回值。只需省略表达式末尾的 `;` 即"
"可。"

#: src/control-flow-basics/functions.md
msgid ""
"Some functions have no return value, and return the 'unit type', `()`. The "
"compiler will infer this if the `-> ()` return type is omitted."
msgstr ""
"有些函数没有返回值，会返回“单元类型（unit type）”`()`。如果省略了`-> ()`的返"
"回类型，编译器将会自动推断。"

#: src/control-flow-basics/functions.md
#, fuzzy
msgid ""
"Overloading is not supported -- each function has a single implementation."
msgstr "每一个函数都只有一种实现："

#: src/control-flow-basics/functions.md
msgid ""
"Always takes a fixed number of parameters. Default arguments are not "
"supported. Macros can be used to support variadic functions."
msgstr "始终采用固定数量的参数。不支持默认参数。宏可用于支持可变函数。"

#: src/control-flow-basics/functions.md
#, fuzzy
msgid ""
"Always takes a single set of parameter types. These types can be generic, "
"which will be covered later."
msgstr "始终接受一组形参类型。"

#: src/control-flow-basics/macros.md
msgid ""
"Macros are expanded into Rust code during compilation, and can take a "
"variable number of arguments. They are distinguished by a `!` at the end. "
"The Rust standard library includes an assortment of useful macros."
msgstr ""
"宏在编译过程中会扩展为 Rust 代码，并且可以接受可变数量的参数。它们以 `!` 结尾"
"来进行区分。Rust 标准库包含各种有用的宏。"

#: src/control-flow-basics/macros.md
#, fuzzy
msgid ""
"`println!(format, ..)` prints a line to standard output, applying formatting "
"described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html)."
msgstr ""
"运算符重载是通过 [`std::ops`](https://doc.rust-lang.org/std/ops/index.html) "
"中的特征实现的："

#: src/control-flow-basics/macros.md
msgid ""
"`format!(format, ..)` works just like `println!` but returns the result as a "
"string."
msgstr ""
"`format!(format, ..)` 的用法与 `println!` 类似，但它以字符串形式返回结果。"

#: src/control-flow-basics/macros.md
msgid "`dbg!(expression)` logs the value of the expression and returns it."
msgstr "`dbg!(expression)` 会记录表达式的值并返回该值。"

#: src/control-flow-basics/macros.md
msgid ""
"`todo!()` marks a bit of code as not-yet-implemented. If executed, it will "
"panic."
msgstr "`todo!()` 用于标记尚未实现的代码段。如果执行该代码段，则会触发 panic。"

#: src/control-flow-basics/macros.md
msgid ""
"`unreachable!()` marks a bit of code as unreachable. If executed, it will "
"panic."
msgstr ""
"`unreachable!()` 用于标记无法访问的代码段。如果执行该代码段，则会触发 panic。"

#: src/control-flow-basics/macros.md
msgid "\"{n}! = {}\""
msgstr "\"{n}! = {}\""

#: src/control-flow-basics/macros.md
msgid ""
"The takeaway from this section is that these common conveniences exist, and "
"how to use them. Why they are defined as macros, and what they expand to, is "
"not especially critical."
msgstr ""
"这一节的要点是介绍这些常见的便捷功能以及如何使用它们。而为何将它们定义为宏以"
"及它们可以扩展为什么内容，并不是特别关键。"

#: src/control-flow-basics/macros.md
msgid ""
"The course does not cover defining macros, but a later section will describe "
"use of derive macros."
msgstr "本课程不会介绍如何定义宏，但在后续部分会介绍派生宏的用法。"

#: src/control-flow-basics/exercise.md
msgid ""
"The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is "
"defined as follows, for an arbitrary n"
msgstr ""
"[考拉兹序列](https://en.wikipedia.org/wiki/Collatz_conjecture) 的定义如下，其"
"中任意 n"

#: src/control-flow-basics/exercise.md
msgid "1"
msgstr "1"

#: src/control-flow-basics/exercise.md
msgid " greater than zero:"
msgstr " 大于零："

#: src/control-flow-basics/exercise.md
msgid "If _n"
msgstr "如果 _n"

#: src/control-flow-basics/exercise.md
msgid "i"
msgstr "i"

#: src/control-flow-basics/exercise.md
msgid "_ is 1, then the sequence terminates at _n"
msgstr "_ 为 1，则序列在 _n 处终止"

#: src/control-flow-basics/exercise.md
msgid "_."
msgstr "_."

#: src/control-flow-basics/exercise.md
msgid "_ is even, then _n"
msgstr "_ 为偶数，则 _n"

#: src/control-flow-basics/exercise.md
msgid "i+1"
msgstr "i+1"

#: src/control-flow-basics/exercise.md
msgid " = n"
msgstr " = n"

#: src/control-flow-basics/exercise.md
msgid " / 2_."
msgstr " / 2_。"

#: src/control-flow-basics/exercise.md
msgid "_ is odd, then _n"
msgstr "_ 为奇数，则 _n"

#: src/control-flow-basics/exercise.md
msgid " = 3 * n"
msgstr " = 3 * n"

#: src/control-flow-basics/exercise.md
msgid " + 1_."
msgstr " + 1_。"

#: src/control-flow-basics/exercise.md
msgid "For example, beginning with _n"
msgstr "例如，以 _n"

#: src/control-flow-basics/exercise.md
msgid "_ = 3:"
msgstr "_ = 3 开头："

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "3 is odd, so _n"
msgstr "3 是奇数，因此 _n"

#: src/control-flow-basics/exercise.md
msgid "2"
msgstr "2"

#: src/control-flow-basics/exercise.md
msgid "_ = 3 * 3 + 1 = 10;"
msgstr "_ = 3 * 3 + 1 = 10；"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "10 is even, so _n"
msgstr "10 是偶数，因此 _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "3"
msgstr "3"

#: src/control-flow-basics/exercise.md
msgid "_ = 10 / 2 = 5;"
msgstr "_ = 10 / 2 = 5；"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "5 is odd, so _n"
msgstr "5 是奇数，因此 _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "4"
msgstr "4"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "_ = 3 * 5 + 1 = 16;"
msgstr "_ = 3 * 15 + 1 = 16；"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "16 is even, so _n"
msgstr "16 是偶数，因此 _n"

#: src/control-flow-basics/exercise.md
msgid "5"
msgstr "5"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "_ = 16 / 2 = 8;"
msgstr "_ = 16 / 2  = 8；"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "8 is even, so _n"
msgstr "8 是偶数，因此 _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "6"
msgstr "6"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "_ = 8 / 2 = 4;"
msgstr "_ = 8 / 2  = 4；"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "4 is even, so _n"
msgstr "4 是偶数，因此 _n"

#: src/control-flow-basics/exercise.md
msgid "7"
msgstr "7"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "_ = 4 / 2 = 2;"
msgstr "_ = 4 / 2  = 2；"

#: src/control-flow-basics/exercise.md
#, fuzzy
msgid "2 is even, so _n"
msgstr "2 是偶数，因此 _n"

#: src/control-flow-basics/exercise.md src/bare-metal/aps/better-uart.md
msgid "8"
msgstr "8"

#: src/control-flow-basics/exercise.md
msgid "_ = 1; and"
msgstr "_ = 1；并且"

#: src/control-flow-basics/exercise.md
msgid "the sequence terminates."
msgstr "序列终止。"

#: src/control-flow-basics/exercise.md
msgid ""
"Write a function to calculate the length of the collatz sequence for a given "
"initial `n`."
msgstr "编写一个函数，用于计算给定初始 `n` 的考拉兹序列的长度。"

#: src/control-flow-basics/exercise.md src/control-flow-basics/solution.md
msgid "/// Determine the length of the collatz sequence beginning at `n`.\n"
msgstr "/// Determine the length of the collatz sequence beginning at `n`.\n"

#: src/control-flow-basics/solution.md src/concurrency/scoped-threads.md
msgid "\"Length: {}\""
msgstr "\"Length: {}\""

#: src/welcome-day-1-afternoon.md src/welcome-day-2-afternoon.md
#: src/welcome-day-3-afternoon.md src/welcome-day-4-afternoon.md
#, fuzzy
msgid "Welcome Back"
msgstr "欢迎"

#: src/welcome-day-1-afternoon.md
msgid "[Tuples and Arrays](./tuples-and-arrays.md) (1 hour)"
msgstr ""

#: src/welcome-day-1-afternoon.md
msgid "[References](./references.md) (50 minutes)"
msgstr ""

#: src/welcome-day-1-afternoon.md
msgid "[User-Defined Types](./user-defined-types.md) (50 minutes)"
msgstr ""

#: src/welcome-day-1-afternoon.md src/welcome-day-2.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 55 "
"minutes"
msgstr ""

#: src/tuples-and-arrays.md
msgid ""
"[Tuples and Arrays](./tuples-and-arrays/tuples-and-arrays.md) (10 minutes)"
msgstr ""

#: src/tuples-and-arrays.md
msgid "[Array Iteration](./tuples-and-arrays/iteration.md) (3 minutes)"
msgstr ""

#: src/tuples-and-arrays.md
msgid "[Pattern Matching](./tuples-and-arrays/match.md) (10 minutes)"
msgstr ""

#: src/tuples-and-arrays.md
msgid "[Destructuring](./tuples-and-arrays/destructuring.md) (5 minutes)"
msgstr ""

#: src/tuples-and-arrays.md
msgid "[Exercise: Nested Arrays](./tuples-and-arrays/exercise.md) (30 minutes)"
msgstr ""

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Tuples and arrays are the first \"compound\" types we have seen. All "
"elements of an array have the same type, while tuples can accommodate "
"different types. Both types have a size fixed at compile time."
msgstr ""
"元组和数组是我们见过的第一个 “复合”类型。数组的所有元素具有相同的类型，而元组"
"可以适应不同的类型。这两种类型的大小在编译时是固定的。"

#: src/tuples-and-arrays/tuples-and-arrays.md
#: src/tuples-and-arrays/destructuring.md
msgid "Arrays"
msgstr "数组（Arrays）"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`[T; N]`"
msgstr "`[T; N]`"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`[20, 30, 40]`, `[0; 3]`"
msgstr "`[20, 30, 40]`, `[0; 3]`"

#: src/tuples-and-arrays/tuples-and-arrays.md
#: src/tuples-and-arrays/destructuring.md
msgid "Tuples"
msgstr "元组（Tuples）"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`()`, `(T,)`, `(T1, T2)`, ..."
msgstr "`()`, `(T,)`, `(T1, T2)`, ..."

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "`()`, `('x',)`, `('x', 1.2)`, ..."
msgstr "`()`, `('x',)`, `('x', 1.2)`, ..."

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Array assignment and access:"
msgstr "数组的赋值和访问操作："

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuple assignment and access:"
msgstr "元组的赋值和访问操作："

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Arrays:"
msgstr "数组："

#: src/tuples-and-arrays/tuples-and-arrays.md
#, fuzzy
msgid ""
"A value of the array type `[T; N]` holds `N` (a compile-time constant) "
"elements of the same type `T`. Note that the length of the array is _part of "
"its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two "
"different types. Slices, which have a size determined at runtime, are "
"covered later."
msgstr ""
"数组中的元素具有相同的类型 `T`，数组的长度为 `N`，`N` 是一个编译期常量。 需要"
"注意的是数组的长度是它_类型的一部分\\_, 这意味着 `[u8; 3]` 和 `[u8; 4]` 在 "
"Rust 中被认为是不同的类型。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Try accessing an out-of-bounds array element. Array accesses are checked at "
"runtime. Rust can usually optimize these checks away, and they can be "
"avoided using unsafe Rust."
msgstr ""
"请尝试访问出界数组元素。系统会在运行时检查数组访问。Rust 通常会通过优化消除这"
"些检查，以及使用不安全的 Rust 来避免这些检查。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "We can use literals to assign values to arrays."
msgstr "我们可以使用字面量来为数组赋值。"

#: src/tuples-and-arrays/tuples-and-arrays.md
#, fuzzy
msgid ""
"The `println!` macro asks for the debug implementation with the `?` format "
"parameter: `{}` gives the default output, `{:?}` gives the debug output. "
"Types such as integers and strings implement the default output, but arrays "
"only implement the debug output. This means that we must use debug output "
"here."
msgstr ""
"在主函数中，打印（print）语句使用 `?` 格式请求调试实现。 使用参数 `{}` 打印默"
"认输出，`{:?}` 表示以调试格式输出。 我们也可以不在格式化字符串后面指定变量"
"值，直接使用 `{a}` 和 `{a:?}` 进行输出。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Adding `#`, eg `{a:#?}`, invokes a \"pretty printing\" format, which can be "
"easier to read."
msgstr ""
"添加 `#`，比如 `{a:#?}`，会输出“美观打印（pretty printing）” 格式，这种格式可"
"能会更加易读。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuples:"
msgstr "元组："

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Like arrays, tuples have a fixed length."
msgstr "和数组一样，元组也具有固定的长度。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid "Tuples group together values of different types into a compound type."
msgstr "元组将不同类型的值组成一个复合类型。"

#: src/tuples-and-arrays/tuples-and-arrays.md
msgid ""
"Fields of a tuple can be accessed by the period and the index of the value, "
"e.g. `t.0`, `t.1`."
msgstr "元组中的字段可以通过英文句号加上值的下标进行访问比如：`t.0`, `t.1`。"

#: src/tuples-and-arrays/tuples-and-arrays.md
#, fuzzy
msgid ""
"The empty tuple `()` is also known as the \"unit type\". It is both a type, "
"and the only valid value of that type --- that is to say both the type and "
"its value are expressed as `()`. It is used to indicate, for example, that a "
"function or expression has no return value, as we'll see in a future slide."
msgstr ""
"空元组 `()` 也被称作 “单元（unit）类型”. 它既是一个类型， 也是这种类型的唯一"
"值——也就是说它的类型和它的值都被表示为 `()`。它通常用于表示，比如，一个函数或"
"表达式没有返回值，我们会在后续的幻灯片种见到这种用法。"

#: src/tuples-and-arrays/tuples-and-arrays.md
#, fuzzy
msgid ""
"You can think of it as `void` that can be familiar to you from other "
"programming languages."
msgstr "你可以将其理解为你可能在其他编程语言中比较熟悉的 `void` 类型。"

#: src/tuples-and-arrays/iteration.md
msgid "The `for` statement supports iterating over arrays (but not tuples)."
msgstr "`for` 语句支持对数组进行迭代（但不支持元组）。"

#: src/tuples-and-arrays/iteration.md
msgid ""
"This functionality uses the `IntoIterator` trait, but we haven't covered "
"that yet."
msgstr "此功能使用了 `IntoIterator` trait，但我们还没有讲到它。"

#: src/tuples-and-arrays/iteration.md
msgid ""
"The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!"
"` macros. These are always checked while, debug-only variants like "
"`debug_assert!` compile to nothing in release builds."
msgstr ""
"这里新增了 `assert_ne!` 宏。此外，还有 `assert_eq!` 和 `assert!` 宏。系统始终"
"会对这些宏进行检查，而像 `debug_assert!` 这样的仅调试变体在发布 build 中不会"
"编译成任何代码。"

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid ""
"The `match` keyword lets you match a value against one or more _patterns_. "
"The comparisons are done from top to bottom and the first match wins."
msgstr ""
"使用关键词 `match` 对一个值进行模式匹配。进行匹配时，会从上至下依次进行比较，"
"并选定第一个匹配成功的结果。"

#: src/tuples-and-arrays/match.md
msgid "The patterns can be simple values, similarly to `switch` in C and C++:"
msgstr "模式（pattern）可以是简单的值，其用法类似于 C 与 C++ 中的 `switch` 。"

#: src/tuples-and-arrays/match.md
msgid "'x'"
msgstr "'x'"

#: src/tuples-and-arrays/match.md
msgid "'q'"
msgstr "'q'"

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid "\"Quitting\""
msgstr "\"Quitting\""

#: src/tuples-and-arrays/match.md src/std-traits/solution.md
#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'a'"
msgstr "'a'"

#: src/tuples-and-arrays/match.md
msgid "'s'"
msgstr "'s'"

#: src/tuples-and-arrays/match.md
msgid "'w'"
msgstr "'w'"

#: src/tuples-and-arrays/match.md
msgid "'d'"
msgstr "'d'"

#: src/tuples-and-arrays/match.md
msgid "\"Moving around\""
msgstr "\"Moving around\""

#: src/tuples-and-arrays/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'0'"
msgstr "'0'"

#: src/tuples-and-arrays/match.md src/error-handling/exercise.md
#: src/error-handling/solution.md
msgid "'9'"
msgstr "'9'"

#: src/tuples-and-arrays/match.md
msgid "\"Number input\""
msgstr "\"Number input\""

#: src/tuples-and-arrays/match.md
msgid "\"Lowercase: {key}\""
msgstr "\"Lowercase: {key}\""

#: src/tuples-and-arrays/match.md
msgid "\"Something else\""
msgstr "\"Something else\""

#: src/tuples-and-arrays/match.md
msgid ""
"The `_` pattern is a wildcard pattern which matches any value. The "
"expressions _must_ be irrefutable, meaning that it covers every possibility, "
"so `_` is often used as the final catch-all case."
msgstr ""
"`_` 模式是与任何值匹配的通配符模式。表达式 _必须_ 不可反驳，即其涵盖了所有可"
"能性，因此通常将 `_` 用作最终的万能符。"

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid ""
"Match can be used as an expression. Just like `if`, each match arm must have "
"the same type. The type is the last expression of the block, if any. In the "
"example above, the type is `()`."
msgstr ""
"与 `if let` 类似，每个匹配分支必须有相同的类型。该类型是块的最后一个 表达式"
"（如有）。在上例中，类型是 `()`。"

#: src/tuples-and-arrays/match.md
msgid ""
"A variable in the pattern (`key` in this example) will create a binding that "
"can be used within the match arm."
msgstr "模式中的变量（本例中为 `key`）将创建一个可在匹配分支内使用的绑定。"

#: src/tuples-and-arrays/match.md
msgid "A match guard causes the arm to match only if the condition is true."
msgstr "只有当条件为真时，保护语句才能使分支匹配成功。"

#: src/tuples-and-arrays/match.md src/user-defined-types/named-structs.md
#: src/user-defined-types/enums.md src/methods-and-traits/methods.md
msgid "Key Points:"
msgstr "关键点："

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid ""
"You might point out how some specific characters are being used when in a "
"pattern"
msgstr ""
"你可以解释一些用于表达模式的特殊字符的用法 \\*`|` 表示或 (or) \\*`..` 可以展"
"开为任意一个或多个值 \\*`1..=5` 代表了一个闭区间范围"

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid "`|` as an `or`"
msgstr ""
"解释模式匹配中的绑定的原理可能会很有帮助。比如可以用一个变量替代外卡，或者去"
"除 `q` 外面的引号。"

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid "`..` can expand as much as it needs to be"
msgstr "你可以展示如何匹配一个引用。"

#: src/tuples-and-arrays/match.md
#, fuzzy
msgid "`1..=5` represents an inclusive range"
msgstr ""
"现在是一个讲解不可反驳 (irrefutable) 模式的好时机。因为这个术语可能会出现在错"
"误信息中。"

#: src/tuples-and-arrays/match.md
msgid "`_` is a wild card"
msgstr "“\\_”是通配符"

#: src/tuples-and-arrays/match.md
msgid ""
"Match guards as a separate syntax feature are important and necessary when "
"we wish to concisely express more complex ideas than patterns alone would "
"allow."
msgstr ""
"有些想法比模式本身所允许的程度更加复杂，如果我们希望简要地表达这些想法，就必"
"须把匹配守卫视为独立的语法功能。"

#: src/tuples-and-arrays/match.md
msgid ""
"They are not the same as separate `if` expression inside of the match arm. "
"An `if` expression inside of the branch block (after `=>`) happens after the "
"match arm is selected. Failing the `if` condition inside of that block won't "
"result in other arms of the original `match` expression being considered."
msgstr ""
"它们与匹配分支中的单独“if”表达式不同。选择匹配分支后，分支块内（在“=>”之后）"
"会出现“if”表达式。如果该分支块内的“if”条件失败，系统不会考虑原始“match”表达式"
"的其他分支。"

#: src/tuples-and-arrays/match.md
msgid ""
"The condition defined in the guard applies to every expression in a pattern "
"with an `|`."
msgstr "只要表达式在包含“|”的模式中，就会适用守卫定义的条件。"

#: src/tuples-and-arrays/destructuring.md
msgid ""
"Destructuring is a way of extracting data from a data structure by writing a "
"pattern that is matched up to the data structure, binding variables to "
"subcomponents of the data structure."
msgstr ""
"解构是一种从数据结构中提取数据的方法，具体方法是编写与数据结构匹配的模式，将"
"变量绑定到数据结构的子组件。"

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid "You can destructure tuples and arrays by matching on their elements:"
msgstr "你可以通过元素匹配来解构数组、元组和切片："

#: src/tuples-and-arrays/destructuring.md
msgid "\"on Y axis\""
msgstr "\"on Y axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"on X axis\""
msgstr "\"on X axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"left of Y axis\""
msgstr "\"left of Y axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"below X axis\""
msgstr "\"below X axis\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"first quadrant\""
msgstr "\"first quadrant\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"Tell me about {triple:?}\""
msgstr "\"Tell me about {triple:?}\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"First is 0, y = {y}, and z = {z}\""
msgstr "\"First is 0, y = {y}, and z = {z}\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"First is 1 and the rest were ignored\""
msgstr "\"First is 1 and the rest were ignored\""

#: src/tuples-and-arrays/destructuring.md
msgid "\"All elements were ignored\""
msgstr "\"All elements were ignored\""

#: src/tuples-and-arrays/destructuring.md
#, fuzzy
msgid "Create a new array pattern using `_` to represent an element."
msgstr "使用 `_` 创建一个新的模式来代表一个元素。"

#: src/tuples-and-arrays/destructuring.md
msgid "Add more values to the array."
msgstr "向数组中添加更多的值。"

#: src/tuples-and-arrays/destructuring.md
msgid ""
"Point out that how `..` will expand to account for different number of "
"elements."
msgstr "指出 `..` 是如何扩展以适应不同数量的元素的。"

#: src/tuples-and-arrays/destructuring.md
msgid "Show matching against the tail with patterns `[.., b]` and `[a@..,b]`"
msgstr "展示使用模式 `[.., b]` 和 `[a@..,b]` 来匹配切片的尾部。"

#: src/tuples-and-arrays/exercise.md
msgid "Arrays can contain other arrays:"
msgstr "数组可以包含其他数组："

#: src/tuples-and-arrays/exercise.md
#, fuzzy
msgid "What is the type of this variable?"
msgstr "每个循环中的“word”是什么类型？"

#: src/tuples-and-arrays/exercise.md
#, fuzzy
msgid ""
"Use an array such as the above to write a function `transpose` which will "
"transpose a matrix (turn rows into columns):"
msgstr ""
"使用以上知识，写一个用易读的格式输出矩阵的 `pretty_print` 函数，以及一个对矩"
"阵进行转置（将行和列互换）的 `transpose` 函数："

#: src/tuples-and-arrays/exercise.md
msgid "Hard-code both functions to operate on 3 × 3 matrices."
msgstr "硬编码这两个函数，让它们处理 3 × 3 的矩阵。"

#: src/tuples-and-arrays/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and implement the "
"functions:"
msgstr "将下面的代码复制到 <https://play.rust-lang.org/> 并实现上述函数："

#: src/tuples-and-arrays/exercise.md src/borrowing/exercise.md
#: src/unsafe-rust/exercise.md
msgid "// TODO: remove this when you're done with your implementation.\n"
msgstr "// TODO: remove this when you're done with your implementation.\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "// <-- the comment makes rustfmt add a newline\n"
msgstr "// <-- the comment makes rustfmt add a newline\n"

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"matrix: {:#?}\""
msgstr "\"matrix: {:#?}\""

#: src/tuples-and-arrays/exercise.md src/tuples-and-arrays/solution.md
msgid "\"transposed: {:#?}\""
msgstr "\"transposed: {:#?}\""

#: src/tuples-and-arrays/solution.md
msgid "//\n"
msgstr "//\n"

#: src/references.md
msgid "[Shared References](./references/shared.md) (10 minutes)"
msgstr ""

#: src/references.md
msgid "[Exclusive References](./references/exclusive.md) (10 minutes)"
msgstr ""

#: src/references.md
msgid "[Exercise: Geometry](./references/exercise.md) (30 minutes)"
msgstr ""

#: src/references.md src/user-defined-types.md src/pattern-matching.md
msgid "This segment should take about 50 minutes"
msgstr ""

#: src/references/shared.md
msgid ""
"A reference provides a way to access another value without taking "
"responsibility for the value, and is also called \"borrowing\". Shared "
"references are read-only, and the referenced data cannot change."
msgstr ""
"引用提供了一种可以访问另一个值但无需对该值负责的方式，也被称为 “借用”。共享引"
"用处于只读状态，且引用的数据无法更改。"

#: src/references/shared.md
msgid ""
"A shared reference to a type `T` has type `&T`. A reference value is made "
"with the `&` operator. The `*` operator \"dereferences\" a reference, "
"yielding its value."
msgstr ""
"对类型 `T` 的共享引用表示为 `&T`。可以使用 `&` 运算符创建引用值。`*` 运算符"
"会 “解引用”某个引用，并得到该引用值。"

#: src/references/shared.md
msgid "Rust will statically forbid dangling references:"
msgstr "Rust 会静态禁止悬垂引用："

#: src/references/shared.md
msgid ""
"A reference is said to \"borrow\" the value it refers to, and this is a good "
"model for students not familiar with pointers: code can use the reference to "
"access the value, but is still \"owned\" by the original variable. The "
"course will get into more detail on ownership in day 3."
msgstr ""
"引用被称为 “借用”了其所引用的值，这对于不熟悉指针的学生来说是一个很好的模型："
"代码可以通过引用来访问值，但原始变量仍然保有对该值的 “所有权”。本课程会在第 "
"3 天详细介绍所有权。"

#: src/references/shared.md
msgid ""
"References are implemented as pointers, and a key advantage is that they can "
"be much smaller than the thing they point to. Students familiar with C or C+"
"+ will recognize references as pointers. Later parts of the course will "
"cover how Rust prevents the memory-safety bugs that come from using raw "
"pointers."
msgstr ""
"引用是以指针的形式实现的，其关键优势在于它们可以比其所指的内容小得多。熟悉 C "
"或 C++ 的学生会将引用视为指针。本课程的后续部分将介绍 Rust 如何防止因使用原始"
"指针而导致的内存安全 bug。"

#: src/references/shared.md
msgid ""
"Rust does not automatically create references for you - the `&` is always "
"required."
msgstr "Rust 不会自动为您创建引用，必须始终使用 `&` 符号。"

#: src/references/shared.md
#, fuzzy
msgid ""
"Rust will auto-dereference in some cases, in particular when invoking "
"methods (try `r.count_ones()`). There is no need for an `->` operator like "
"in C++."
msgstr ""
"Rust 有时会进行自动解引用。比如调用方法 `ref_x.count_ones()` 时，ref_x 会被解"
"引用。"

#: src/references/shared.md
msgid ""
"In this example, `r` is mutable so that it can be reassigned (`r = &b`). "
"Note that this re-binds `r`, so that it refers to something else. This is "
"different from C++, where assignment to a reference changes the referenced "
"value."
msgstr ""
"在本例中，`r` 是可变的，因此可以为其重新赋值 (`r = &b`)。请注意，这会重新绑"
"定 `r`，使其引用其他内容。这与 C++ 不同，在 C++ 中为引用赋值会更改引用的值。"

#: src/references/shared.md
msgid ""
"A shared reference does not allow modifying the value it refers to, even if "
"that value was mutable. Try `*r = 'X'`."
msgstr "共享引用不允许修改其所引用的值，即使该值是可变的。请尝试 `*r = 'X'`。"

#: src/references/shared.md
msgid ""
"Rust is tracking the lifetimes of all references to ensure they live long "
"enough. Dangling references cannot occur in safe Rust. `x_axis` would return "
"a reference to `point`, but `point` will be deallocated when the function "
"returns, so this will not compile."
msgstr ""
"Rust 会跟踪所有引用的生命周期，以确保它们存在足够长的时间。在安全的 Rust 中不"
"会出现悬空引用。`x_axis` 会返回对 `point` 的引用，但 `point` 会在该函数返回时"
"取消分配，因此不会进行编译。"

#: src/references/shared.md
msgid "We will talk more about borrowing when we get to ownership."
msgstr "我们会在讲到所有权（ownership）时详细讨论借用（borrow）。"

#: src/references/exclusive.md
msgid ""
"Exclusive references, also known as mutable references, allow changing the "
"value they refer to. They have type `&mut T`."
msgstr ""
"独占引用（也称为可变引用）允许更改其所引用的值。它们的类型为 `&mut T`。"

#: src/references/exclusive.md
msgid ""
"\"Exclusive\" means that only this reference can be used to access the "
"value. No other references (shared or exclusive) can exist at the same time, "
"and the referenced value cannot be accessed while the exclusive reference "
"exists. Try making an `&point.0` or changing `point.0` while `x_coord` is "
"alive."
msgstr ""
"“独占模式”表示只有此引用可用于访问该值。在独占引用存在期间，不允许同时存在其"
"他引用（无论是共享引用还是独占引用），并且无法访问引用的值。请尝试在 "
"`x_coord` 处于活动状态时创建 `&point.0` 或更改 `point.0`。"

#: src/references/exclusive.md
#, fuzzy
msgid ""
"Be sure to note the difference between `let mut x_coord: &i32` and `let "
"x_coord: &mut i32`. The first one represents a shared reference which can be "
"bound to different values, while the second represents an exclusive "
"reference to a mutable value."
msgstr ""
"注意 `let mut ref_x: &i32` 与 `let ref_x: &mut i32` 之间的区别。第一条语句声"
"明了一个可变引用，所以我们可以修改这个引用所绑定的值；第二条语句声明了一个指"
"向可变变量的引用。"

#: src/references/exercise.md
msgid ""
"We will create a few utility functions for 3-dimensional geometry, "
"representing a point as `[f64;3]`. It is up to you to determine the function "
"signatures."
msgstr ""
"我们将为三维几何图形创建几个实用函数，将点表示为 `[f64;3]`。函数签名由您自行"
"确定。"

#: src/references/exercise.md
msgid ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"
msgstr ""
"// Calculate the magnitude of a vector by summing the squares of its "
"coordinates\n"
"// and taking the square root. Use the `sqrt()` method to calculate the "
"square\n"
"// root, like `v.sqrt()`.\n"

#: src/references/exercise.md
msgid ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"
msgstr ""
"// Normalize a vector by calculating its magnitude and dividing all of its\n"
"// coordinates by that magnitude.\n"

#: src/references/exercise.md
msgid "// Use the following `main` to test your work.\n"
msgstr "// Use the following `main` to test your work.\n"

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of a unit vector: {}\""
msgstr "\"Magnitude of a unit vector: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?}: {}\""
msgstr "\"Magnitude of {v:?}: {}\""

#: src/references/exercise.md src/references/solution.md
msgid "\"Magnitude of {v:?} after normalization: {}\""
msgstr "\"Magnitude of {v:?} after normalization: {}\""

#: src/references/solution.md
msgid "/// Calculate the magnitude of the given vector.\n"
msgstr "/// Calculate the magnitude of the given vector.\n"

#: src/references/solution.md
msgid ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"
msgstr ""
"/// Change the magnitude of the vector to 1.0 without changing its "
"direction.\n"

#: src/user-defined-types.md
msgid "[Named Structs](./user-defined-types/named-structs.md) (10 minutes)"
msgstr ""

#: src/user-defined-types.md
msgid "[Tuple Structs](./user-defined-types/tuple-structs.md) (10 minutes)"
msgstr ""

#: src/user-defined-types.md
msgid "[Enums](./user-defined-types/enums.md) (5 minutes)"
msgstr ""

#: src/user-defined-types.md
msgid ""
"[Static and Const](./user-defined-types/static-and-const.md) (5 minutes)"
msgstr ""

#: src/user-defined-types.md
msgid "[Type Aliases](./user-defined-types/aliases.md) (2 minutes)"
msgstr ""

#: src/user-defined-types.md
msgid ""
"[Exercise: Elevator Events](./user-defined-types/exercise.md) (15 minutes)"
msgstr ""

#: src/user-defined-types/named-structs.md
msgid "Like C and C++, Rust has support for custom structs:"
msgstr "与 C 和 C++ 一样，Rust 支持自定义结构体："

#: src/user-defined-types/named-structs.md
msgid "\"{} is {} years old\""
msgstr "\"{} is {} years old\""

#: src/user-defined-types/named-structs.md
#: src/android/interoperability/with-c/bindgen.md
msgid "\"Peter\""
msgstr "\"Peter\""

#: src/user-defined-types/named-structs.md
msgid "\"Avery\""
msgstr "\"Avery\""

#: src/user-defined-types/named-structs.md
msgid "\"Jackie\""
msgstr "\"Jackie\""

#: src/user-defined-types/named-structs.md
msgid "Structs work like in C or C++."
msgstr "结构体的运作方式与使用 C 或 C++ 时类似。"

#: src/user-defined-types/named-structs.md
msgid "Like in C++, and unlike in C, no typedef is needed to define a type."
msgstr "不需要 typedef 即可定义类型，这与使用 C++ 类似，但与使用 C 不同。"

#: src/user-defined-types/named-structs.md
msgid "Unlike in C++, there is no inheritance between structs."
msgstr "与使用 C++ 不同的是，结构体之间没有继承关系。"

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"This may be a good time to let people know there are different types of "
"structs."
msgstr "这时可能很适合告诉学员存在不同类型的结构体。"

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a "
"trait on some type but don’t have any data that you want to store in the "
"value itself."
msgstr ""
"针对某类型实现 trait 时，可能会使用大小为零的结构体 `e.g., struct Foo;`，但其"
"中没有任何您要储存在值本身中的数据。"

#: src/user-defined-types/named-structs.md
msgid ""
"The next slide will introduce Tuple structs, used when the field names are "
"not important."
msgstr "下一张幻灯片将介绍元组结构体，当字段名称不重要时使用。"

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"If you already have variables with the right names, then you can create the "
"struct using a shorthand."
msgstr "如果您已有名称正确的变量，则可以使用简写形式创建结构体："

#: src/user-defined-types/named-structs.md
#, fuzzy
msgid ""
"The syntax `..avery` allows us to copy the majority of the fields from the "
"old struct without having to explicitly type it all out. It must always be "
"the last element."
msgstr ""
"通过语法“..peter”，我们可以从旧结构体复制大部分字段，而无需明确地输入所有字"
"段。它必须始终是最后一个元素。"

#: src/user-defined-types/tuple-structs.md
msgid "If the field names are unimportant, you can use a tuple struct:"
msgstr "如果字段名称不重要，您可以使用元组结构体："

#: src/user-defined-types/tuple-structs.md
msgid "\"({}, {})\""
msgstr "\"({}, {})\""

#: src/user-defined-types/tuple-structs.md
msgid "This is often used for single-field wrappers (called newtypes):"
msgstr "这通常用于单字段封装容器（称为 newtype）："

#: src/user-defined-types/tuple-structs.md
msgid "\"Ask a rocket scientist at NASA\""
msgstr "\"Ask a rocket scientist at NASA\""

#: src/user-defined-types/tuple-structs.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/bare-metal/microcontrollers/type-state.md
#: src/async/pitfalls/cancellation.md
msgid "// ...\n"
msgstr "// ...\n"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Newtypes are a great way to encode additional information about the value in "
"a primitive type, for example:"
msgstr ""
"如需对基元类型中的值的额外信息进行编码，使用 newtype 是一种非常好的方式，例"
"如："

#: src/user-defined-types/tuple-structs.md
msgid "The number is measured in some units: `Newtons` in the example above."
msgstr "数字会以某些单位来衡量：上方示例中为 `Newtons`。"

#: src/user-defined-types/tuple-structs.md
#, fuzzy
msgid ""
"The value passed some validation when it was created, so you no longer have "
"to validate it again at every use: `PhoneNumber(String)` or `OddNumber(u32)`."
msgstr ""
"值在创建时已通过一些验证，因此您不再需要在每次使用时都再次验证它："
"`PhoneNumber(String)` 或 `OddNumber(u32)`。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Demonstrate how to add a `f64` value to a `Newtons` type by accessing the "
"single field in the newtype."
msgstr ""
"展示如何通过访问 newtype 中的单个字段，将 `f64` 值添加到 `Newtons` 类型。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"Rust generally doesn’t like inexplicit things, like automatic unwrapping or "
"for instance using booleans as integers."
msgstr "Rust 通常不喜欢不明确的内容，例如自动解封或将布尔值用作整数。"

#: src/user-defined-types/tuple-structs.md
msgid "Operator overloading is discussed on Day 3 (generics)."
msgstr "运算符过载在第 3 天（泛型）讨论。"

#: src/user-defined-types/tuple-structs.md
msgid ""
"The example is a subtle reference to the [Mars Climate Orbiter](https://en."
"wikipedia.org/wiki/Mars_Climate_Orbiter) failure."
msgstr ""
"此示例巧妙地引用了[火星气候探测者号](https://zh.wikipedia.org/wiki/"
"%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F) 的"
"失败事故。"

#: src/user-defined-types/enums.md
msgid ""
"The `enum` keyword allows the creation of a type which has a few different "
"variants:"
msgstr "`enum` 关键字允许创建具有几个 不同变体的类型："

#: src/user-defined-types/enums.md
msgid "// Simple variant\n"
msgstr "// Simple variant\n"

#: src/user-defined-types/enums.md
msgid "// Tuple variant\n"
msgstr "// Tuple variant\n"

#: src/user-defined-types/enums.md
msgid "// Struct variant\n"
msgstr "// Struct variant\n"

#: src/user-defined-types/enums.md
msgid "\"On this turn: {:?}\""
msgstr "\"On this turn: {:?}\""

#: src/user-defined-types/enums.md
#, fuzzy
msgid "Enumerations allow you to collect a set of values under one type."
msgstr "枚举允许你从一种类型下收集一组值"

#: src/user-defined-types/enums.md
msgid ""
"`Direction` is a type with variants. There are two values of `Direction`: "
"`Direction::Left` and `Direction::Right`."
msgstr ""

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"`PlayerMove` is a type with three variants. In addition to the payloads, "
"Rust will store a discriminant so that it knows at runtime which variant is "
"in a `PlayerMove` value."
msgstr ""
"PlayerMove 会显示三种类型的变体。Rust 还会存储判别标识，以便在运行时确定值中"
"包含哪个变体。"

#: src/user-defined-types/enums.md
#, fuzzy
msgid "This might be a good time to compare structs and enums:"
msgstr "这可能是比较结构体和枚举的好时机："

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"In both, you can have a simple version without fields (unit struct) or one "
"with different types of fields (variant payloads)."
msgstr ""
"在这两者中，你可以获得一个不含字段的简单版本（单位结构体），或一个包含不同类"
"型字段的版本（变体载荷）。"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"You could even implement the different variants of an enum with separate "
"structs but then they wouldn’t be the same type as they would if they were "
"all defined in an enum."
msgstr ""
"你甚至可以使用单独的结构体实现枚举的不同变体，但这样一来，如果它们都已在枚举"
"中定义，类型与之前也不一样。"

#: src/user-defined-types/enums.md
msgid "Rust uses minimal space to store the discriminant."
msgstr "Rust 使用最小的空间来存储判标识。"

#: src/user-defined-types/enums.md
msgid "If necessary, it stores an integer of the smallest required size"
msgstr "如有必要，它会存储所需最小大小的整数"

#: src/user-defined-types/enums.md
msgid ""
"If the allowed variant values do not cover all bit patterns, it will use "
"invalid bit patterns to encode the discriminant (the \"niche "
"optimization\"). For example, `Option<&u8>` stores either a pointer to an "
"integer or `NULL` for the `None` variant."
msgstr ""
"如果允许的变体值未涵盖所有位模式，则它将使用无效的位模式对判别标识进行编码"
"（“小众优化”）。例如，`Option<&u8>` 存储的要么是指向整数的指针，要么是 "
"`None` 变体的 `NULL` 值。"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"You can control the discriminant if needed (e.g., for compatibility with C):"
msgstr "你可以根据需要控制判别（例如，与 C 的兼容性）："

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2 "
"bytes."
msgstr ""
"如果不使用 `repr`，判别类型会占用 2 个字节，因为 10001 是一个 2 个字节的数"
"值。"

#: src/user-defined-types/enums.md src/user-defined-types/static-and-const.md
#: src/memory-management/review.md src/memory-management/move.md
#: src/smart-pointers/box.md src/borrowing/shared.md
msgid "More to Explore"
msgstr "探索更多"

#: src/user-defined-types/enums.md
msgid ""
"Rust has several optimizations it can employ to make enums take up less "
"space."
msgstr "Rust 具有多种优化措施，可以减少枚举占用的空间。"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"Null pointer optimization: For [some types](https://doc.rust-lang.org/std/"
"option/#representation), Rust guarantees that `size_of::<T>()` equals "
"`size_of::<Option<T>>()`."
msgstr ""
"Null 指针优化：对于[某些 类型](https://doc.rust-lang.org/std/option/"
"#representation)，Rust 保证 `size_of::<T>()` 等效于 `size_of::"
"<Option<T>>()`。"

#: src/user-defined-types/enums.md
#, fuzzy
msgid ""
"Example code if you want to show how the bitwise representation _may_ look "
"like in practice. It's important to note that the compiler provides no "
"guarantees regarding this representation, therefore this is totally unsafe."
msgstr ""
"如果你想展示位表示方式在实践中“可能”会是什么样子，请参考示例代码。 请务必注"
"意，编译器对此表示法不提供任何保证，因此这是完全不安全的。"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid ""
"Static and constant variables are two different ways to create globally-"
"scoped values that cannot be moved or reallocated during the execution of "
"the program."
msgstr ""
"静态变量和常量是创建全局范围值的两种不同方法，这类值在程序执行期间无法移动或"
"重新分配。"

#: src/user-defined-types/static-and-const.md
msgid "`const`"
msgstr "`const`"

#: src/user-defined-types/static-and-const.md
msgid ""
"Constant variables are evaluated at compile time and their values are "
"inlined wherever they are used:"
msgstr "系统会在编译时对常量变量进行求值；无论在何处使用，其值都会被内嵌："

#: src/user-defined-types/static-and-const.md
msgid ""
"According to the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html) these are inlined upon use."
msgstr ""
"根据 [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static."
"html) 这些变量在使用时是内联 (inlined) 的。"

#: src/user-defined-types/static-and-const.md
msgid ""
"Only functions marked `const` can be called at compile time to generate "
"`const` values. `const` functions can however be called at runtime."
msgstr ""
"在编译时只能调用标记为“const”的函数以生成“const”值。不过，可在运行时调"
"用“const”函数。"

#: src/user-defined-types/static-and-const.md
msgid "`static`"
msgstr "`static`"

#: src/user-defined-types/static-and-const.md
msgid ""
"Static variables will live during the whole execution of the program, and "
"therefore will not move:"
msgstr "静态变量在程序的整个执行过程中始终有效，因此不会移动："

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid "\"Welcome to RustOS 3.14\""
msgstr "欢迎来到第一天"

#: src/user-defined-types/static-and-const.md
msgid "\"{BANNER}\""
msgstr "\"{BANNER}\""

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid ""
"As noted in the [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-"
"vs-static.html), these are not inlined upon use and have an actual "
"associated memory location. This is useful for unsafe and embedded code, and "
"the variable lives through the entirety of the program execution. When a "
"globally-scoped value does not have a reason to need object identity, "
"`const` is generally preferred."
msgstr ""
"正如 [Rust RFC Book](https://rust-lang.github.io/rfcs/0246-const-vs-static."
"html) 中所述，这些变量在使用时并不是内联的，而且还具有实际相关联的内存位置。"
"这对于不安全的嵌入式代码是有用的，并且这些变量存在于整个程序的执行过程之中。"

#: src/user-defined-types/static-and-const.md
msgid "Mention that `const` behaves semantically similar to C++'s `constexpr`."
msgstr "值得一提的是，`const` 在语义上与C++的 `constexpr` 类似。"

#: src/user-defined-types/static-and-const.md
msgid ""
"`static`, on the other hand, is much more similar to a `const` or mutable "
"global variable in C++."
msgstr "另一方面，`static` 远远更类似于C++中的 `const` 或可改变的全局变量。"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid ""
"`static` provides object identity: an address in memory and state as "
"required by types with interior mutability such as `Mutex<T>`."
msgstr ""
"“static”提供对象标识：内存中的一个地址及具有内部可变性的类型（如“Mutex\n"
"\n"
"”）所需的状态。"

#: src/user-defined-types/static-and-const.md
msgid ""
"It isn't super common that one would need a runtime evaluated constant, but "
"it is helpful and safer than using a static."
msgstr ""
"虽然需要使用在运行中求值的常量的情况并不是很常见，但是它是有帮助的，而且比使"
"用静态变量更安全。"

#: src/user-defined-types/static-and-const.md
msgid "Properties table:"
msgstr "属性表："

#: src/user-defined-types/static-and-const.md
#: src/chromium/adding-third-party-crates.md
msgid "Property"
msgstr "属性"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid "Static"
msgstr "`static`"

#: src/user-defined-types/static-and-const.md
msgid "Constant"
msgstr "常量"

#: src/user-defined-types/static-and-const.md
msgid "Has an address in memory"
msgstr "在内存中有地址"

#: src/user-defined-types/static-and-const.md
#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes"
msgstr "是"

#: src/user-defined-types/static-and-const.md
msgid "No (inlined)"
msgstr "否（内嵌）"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid "Lives for the entire duration of the program"
msgstr "`main` 函数是程序的入口。"

#: src/user-defined-types/static-and-const.md
#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "No"
msgstr "否"

#: src/user-defined-types/static-and-const.md
msgid "Can be mutable"
msgstr "可变"

#: src/user-defined-types/static-and-const.md
msgid "Yes (unsafe)"
msgstr "是（不安全）"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid "Evaluated at compile time"
msgstr "值在编译时具有已知的固定大小。"

#: src/user-defined-types/static-and-const.md
msgid "Yes (initialised at compile time)"
msgstr "是（在编译时被初始化）"

#: src/user-defined-types/static-and-const.md
msgid "Inlined wherever it is used"
msgstr "内嵌在使用它的任何位置"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid ""
"Because `static` variables are accessible from any thread, they must be "
"`Sync`. Interior mutability is possible through a [`Mutex`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html), atomic or similar."
msgstr ""
"由于“static”变量可从任何线程访问，因此它们必须是“Sync”。内部可变性可通过[“互"
"斥量”](https://doc.rust-lang.org/std/sync/struct.Mutex.html)、原子性或类似对"
"象实现。也可能具有可变静态项，但它们需要手动同步，因此对它们的任何访问都需"
"要“unsafe”代码。我们将在“不安全 Rust”章节中探讨[可变静态项](../unsafe/"
"mutable-static-variables.md)。"

#: src/user-defined-types/static-and-const.md
#, fuzzy
msgid "Thread-local data can be created with the macro `std::thread_local`."
msgstr "可以使用宏“std::thread_local”创建“thread_local”数据。"

#: src/user-defined-types/aliases.md
msgid ""
"A type alias creates a name for another type. The two types can be used "
"interchangeably."
msgstr "类型别名为另一种类型创建名称。这两种类型可以互换使用。"

#: src/user-defined-types/aliases.md
msgid "// Aliases are more useful with long, complex types:\n"
msgstr "// Aliases are more useful with long, complex types:\n"

#: src/user-defined-types/aliases.md
msgid "C programmers will recognize this as similar to a `typedef`."
msgstr "C 语言程序员会认为这类似于 `typedef`。"

#: src/user-defined-types/exercise.md
msgid ""
"We will create a data structure to represent an event in an elevator control "
"system. It is up to you to define the types and functions to construct "
"various events. Use `#[derive(Debug)]` to allow the types to be formatted "
"with `{:?}`."
msgstr ""
"我们将创建一个数据结构来表示电梯控制系统中的事件。您可以自行定义用于构造各种"
"事件的类型和函数。使用 `#[derive(Debug)]` 以允许通过 `{:?}` 设置类型格式。"

#: src/user-defined-types/exercise.md
#, fuzzy
msgid ""
"This exercise only requires creating and populating data structures so that "
"`main` runs without errors. The next part of the course will cover getting "
"data out of these structures."
msgstr ""
"此次练习只需创建数据结构。本课程的下一部分将介绍如何从这些结构中获取数据。"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid ""
"/// An event in the elevator system that the controller must react to.\n"
msgstr ""
"/// An event in the elevator system that the controller must react to.\n"

#: src/user-defined-types/exercise.md
#, fuzzy
msgid "// TODO: add required variants\n"
msgstr "// Tuple variant\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// A direction of travel.\n"
msgstr "/// A direction of travel.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// The car has arrived on the given floor.\n"
msgstr "/// The car has arrived on the given floor.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// The car doors have opened.\n"
msgstr "/// The car doors have opened.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// The car doors have closed.\n"
msgstr "/// The car doors have closed.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"
msgstr ""
"/// A directional button was pressed in an elevator lobby on the given "
"floor.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "/// A floor button was pressed in the elevator car.\n"
msgstr "/// A floor button was pressed in the elevator car.\n"

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"A ground floor passenger has pressed the up button: {:?}\""
msgstr "\"A ground floor passenger has pressed the up button: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car has arrived on the ground floor: {:?}\""
msgstr "\"The car has arrived on the ground floor: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car door opened: {:?}\""
msgstr "\"The car door opened: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"A passenger has pressed the 3rd floor button: {:?}\""
msgstr "\"A passenger has pressed the 3rd floor button: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car door closed: {:?}\""
msgstr "\"The car door closed: {:?}\""

#: src/user-defined-types/exercise.md src/user-defined-types/solution.md
msgid "\"The car has arrived on the 3rd floor: {:?}\""
msgstr "\"The car has arrived on the 3rd floor: {:?}\""

#: src/user-defined-types/solution.md
msgid "/// A button was pressed.\n"
msgstr "/// A button was pressed.\n"

#: src/user-defined-types/solution.md
msgid "/// The car has arrived at the given floor.\n"
msgstr "/// The car has arrived at the given floor.\n"

#: src/user-defined-types/solution.md
msgid "/// The car's doors have opened.\n"
msgstr "/// The car's doors have opened.\n"

#: src/user-defined-types/solution.md
msgid "/// The car's doors have closed.\n"
msgstr "/// The car's doors have closed.\n"

#: src/user-defined-types/solution.md
msgid "/// A floor is represented as an integer.\n"
msgstr "/// A floor is represented as an integer.\n"

#: src/user-defined-types/solution.md
msgid "/// A user-accessible button.\n"
msgstr "/// A user-accessible button.\n"

#: src/user-defined-types/solution.md
msgid "/// A button in the elevator lobby on the given floor.\n"
msgstr "/// A button in the elevator lobby on the given floor.\n"

#: src/user-defined-types/solution.md
msgid "/// A floor button within the car.\n"
msgstr "/// A floor button within the car.\n"

#: src/welcome-day-2.md
msgid "Welcome to Day 2"
msgstr "欢迎来到第二天"

#: src/welcome-day-2.md
#, fuzzy
msgid ""
"Now that we have seen a fair amount of Rust, today will focus on Rust's type "
"system:"
msgstr "现在我们已经了解了相当多的Rust，接下来我们将学习："

#: src/welcome-day-2.md
#, fuzzy
msgid "Pattern matching: extracting data from structures."
msgstr "模式匹配：解构枚举、结构体和数组（array）。"

#: src/welcome-day-2.md
msgid "Methods: associating functions with types."
msgstr "方法：将函数与类型相关联。"

#: src/welcome-day-2.md
msgid "Traits: behaviors shared by multiple types."
msgstr "特征：多个类型所共有的行为。"

#: src/welcome-day-2.md
msgid "Generics: parameterizing types on other types."
msgstr "泛型：对其他类型进行类型参数化。"

#: src/welcome-day-2.md
msgid ""
"Standard library types and traits: a tour of Rust's rich standard library."
msgstr "标准库类型和特征：探索 Rust 丰富的标准库。"

#: src/welcome-day-2.md
msgid "[Welcome](./welcome-day-2.md) (3 minutes)"
msgstr ""

#: src/welcome-day-2.md
#, fuzzy
msgid "[Pattern Matching](./pattern-matching.md) (50 minutes)"
msgstr ""
"如需详细了解 Rust 中 的模式，请参阅[模式匹配](../pattern-matching.md)。"

#: src/welcome-day-2.md
msgid "[Methods and Traits](./methods-and-traits.md) (45 minutes)"
msgstr ""

#: src/welcome-day-2.md
msgid "[Generics](./generics.md) (45 minutes)"
msgstr ""

#: src/pattern-matching.md
msgid "[Destructuring](./pattern-matching/destructuring.md) (10 minutes)"
msgstr ""

#: src/pattern-matching.md
msgid "[Let Control Flow](./pattern-matching/let-control-flow.md) (10 minutes)"
msgstr ""

#: src/pattern-matching.md
msgid ""
"[Exercise: Expression Evaluation](./pattern-matching/exercise.md) (30 "
"minutes)"
msgstr ""

#: src/pattern-matching/destructuring.md
msgid "Like tuples, structs and enums can also be destructured by matching:"
msgstr "与元组一样，结构体和枚举也可以通过匹配方式进行解构："

#: src/pattern-matching/destructuring.md
msgid "Structs"
msgstr "结构体"

#: src/pattern-matching/destructuring.md
msgid "\"x.0 = 1, b = {b}, y = {y}\""
msgstr "\"x.0 = 1, b = {b}, y = {y}\""

#: src/pattern-matching/destructuring.md
msgid "\"y = 2, x = {i:?}\""
msgstr "\"y = 2, x = {i:?}\""

#: src/pattern-matching/destructuring.md
msgid "\"y = {y}, other fields were ignored\""
msgstr "\"y = {y}, other fields were ignored\""

#: src/pattern-matching/destructuring.md
msgid ""
"Patterns can also be used to bind variables to parts of your values. This is "
"how you inspect the structure of your types. Let us start with a simple "
"`enum` type:"
msgstr ""
"模式还可用于将变量绑定到值的某些部分。这是您检查类型结构的方式。我们先从简单"
"的“enum”类型开始："

#: src/pattern-matching/destructuring.md
msgid "\"cannot divide {n} into two equal parts\""
msgstr "\"cannot divide {n} into two equal parts\""

#: src/pattern-matching/destructuring.md
msgid "\"{n} divided in two is {half}\""
msgstr "\"{n} divided in two is {half}\""

#: src/pattern-matching/destructuring.md
msgid "\"sorry, an error happened: {msg}\""
msgstr "\"sorry, an error happened: {msg}\""

#: src/pattern-matching/destructuring.md
msgid ""
"Here we have used the arms to _destructure_ the `Result` value. In the first "
"arm, `half` is bound to the value inside the `Ok` variant. In the second "
"arm, `msg` is bound to the error message."
msgstr ""
"在这里，我们使用了分支来解构“Result”值。在第一个分支中，“half”被绑定到“Ok”变"
"体中的值。在第二个分支中，“msg”被绑定到错误消息。"

#: src/pattern-matching/destructuring.md
msgid "Change the literal values in `foo` to match with the other patterns."
msgstr "更改“foo”中的字面量值以与其他模式相匹配。"

#: src/pattern-matching/destructuring.md
msgid "Add a new field to `Foo` and make changes to the pattern as needed."
msgstr "向“Foo”添加一个新字段，并根据需要更改模式。"

#: src/pattern-matching/destructuring.md
msgid ""
"The distinction between a capture and a constant expression can be hard to "
"spot. Try changing the `2` in the second arm to a variable, and see that it "
"subtly doesn't work. Change it to a `const` and see it working again."
msgstr ""
"捕获和常量表达式之间的区别可能很难发现。尝试将第二个分支中的“2”更改为一个变"
"量，可以看到它几乎无法运作了。将它更改为“const”，可以看到它又正常运作了。"

#: src/pattern-matching/destructuring.md
msgid ""
"The `if`/`else` expression is returning an enum that is later unpacked with "
"a `match`."
msgstr "“if”/“else”表达式将返回一个枚举，该枚举之后会使用“match”进行解封装。"

#: src/pattern-matching/destructuring.md
msgid ""
"You can try adding a third variant to the enum definition and displaying the "
"errors when running the code. Point out the places where your code is now "
"inexhaustive and how the compiler tries to give you hints."
msgstr ""
"您可以尝试在枚举定义中添加第三个变体，并在运行代码时显示错误。指出代码现在有"
"哪些地方还不详尽，并说明编译器会如何尝试给予提示。"

#: src/pattern-matching/destructuring.md
#, fuzzy
msgid ""
"The values in the enum variants can only be accessed after being pattern "
"matched."
msgstr ""
"枚举变体中的值只有在被模式匹配后，才可访问。模式将引用绑定到 `=>` 之后"
"的“match 分支”中的字段。"

#: src/pattern-matching/destructuring.md
#, fuzzy
msgid ""
"Demonstrate what happens when the search is inexhaustive. Note the advantage "
"the Rust compiler provides by confirming when all cases are handled."
msgstr ""
"展示搜索不详尽时会发生的情况。请注意 Rust 编译器的优势，即确认所有情况何时都"
"得到了处理。"

#: src/pattern-matching/destructuring.md
msgid ""
"Save the result of `divide_in_two` in the `result` variable and `match` it "
"in a loop. That won't compile because `msg` is consumed when matched. To fix "
"it, match `&result` instead of `result`. That will make `msg` a reference so "
"it won't be consumed. This [\"match ergonomics\"](https://rust-lang.github."
"io/rfcs/2005-match-ergonomics.html) appeared in Rust 2018. If you want to "
"support older Rust, replace `msg` with `ref msg` in the pattern."
msgstr ""

#: src/pattern-matching/let-control-flow.md
msgid ""
"Rust has a few control flow constructs which differ from other languages. "
"They are used for pattern matching:"
msgstr "Rust 有几个与其他语言不同的控制流结构。它们用于模式匹配："

#: src/pattern-matching/let-control-flow.md
msgid "`if let` expressions"
msgstr "`if let` 表达式"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`while let` expressions"
msgstr "while let 表达式"

#: src/pattern-matching/let-control-flow.md
msgid "`match` expressions"
msgstr "`match` 表达式"

#: src/pattern-matching/let-control-flow.md
msgid ""
"The [`if let` expression](https://doc.rust-lang.org/reference/expressions/if-"
"expr.html#if-let-expressions) lets you execute different code depending on "
"whether a value matches a pattern:"
msgstr ""
"[`if let` 表达式](https://doc.rust-lang.org/reference/expressions/if-expr."
"html#if-let-expressions) 能让你根据某个值是否与模式相匹配来执行不同的代码："

#: src/pattern-matching/let-control-flow.md
msgid "\"slept for {:?}\""
msgstr "\"slept for {:?}\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "`let else` expressions"
msgstr "while let 表达式"

#: src/pattern-matching/let-control-flow.md
msgid ""
"For the common case of matching a pattern and returning from the function, "
"use [`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/"
"let_else.html). The \"else\" case must diverge (`return`, `break`, or panic "
"- anything but falling off the end of the block)."
msgstr ""
"如需了解匹配模式并从函数返回的常见情况，请使用 [`let else`](https://doc.rust-"
"lang.org/rust-by-example/flow_control/let_else.html)。\"else\" 分支必须执行不"
"同的结束方式（例如，`return`、`break` 或 `panic`，但不能直接执行到代码块的末"
"尾）。"

#: src/pattern-matching/let-control-flow.md
msgid "\"got None\""
msgstr "\"got None\""

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "\"got empty string\""
msgstr "\"got empty string\""

#: src/pattern-matching/let-control-flow.md
msgid "\"not a hex digit\""
msgstr "\"not a hex digit\""

#: src/pattern-matching/let-control-flow.md src/pattern-matching/solution.md
msgid "\"result: {:?}\""
msgstr "\"result: {:?}\""

#: src/pattern-matching/let-control-flow.md src/generics/trait-bounds.md
#: src/smart-pointers/solution.md src/testing/googletest.md
#: src/testing/solution.md
msgid "\"foo\""
msgstr "\"foo\""

#: src/pattern-matching/let-control-flow.md
msgid ""
"Like with `if let`, there is a [`while let`](https://doc.rust-lang.org/"
"reference/expressions/loop-expr.html#predicate-pattern-loops) variant which "
"repeatedly tests a value against a pattern:"
msgstr ""
"与 `if let` 一样，[`while let`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#predicate-pattern-loops) 变体会针对一个模式重复测"
"试一个值："

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"Here [`String::pop`](https://doc.rust-lang.org/stable/std/string/struct."
"String.html#method.pop) returns `Some(c)` until the string is empty, after "
"which it will return `None`. The `while let` lets us keep iterating through "
"all items."
msgstr ""
"在这里，每次 调用 `next()` 时，`v.iter()` 返回的迭代器都会返回一个 "
"`Option<i32>`。它将一直返回 `Some(x)`，直到完成。 之后它将返回 `None`。"
"`while let`能让我们持续迭代所有项。"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "if-let"
msgstr "if-let"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"Unlike `match`, `if let` does not have to cover all branches. This can make "
"it more concise than `match`."
msgstr "与 `match` 不同的是，`if let` 不支持模式匹配的 guard 子句。"

#: src/pattern-matching/let-control-flow.md
msgid "A common usage is handling `Some` values when working with `Option`."
msgstr "使用 `Option` 时，常见的做法是处理 `Some` 值。"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Unlike `match`, `if let` does not support guard clauses for pattern matching."
msgstr "与 `match` 不同的是，`if let` 不支持模式匹配的 guard 子句。"

#: src/pattern-matching/let-control-flow.md
msgid "let-else"
msgstr "let-else"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"`if-let`s can pile up, as shown. The `let-else` construct supports "
"flattening this nested code. Rewrite the awkward version for students, so "
"they can see the transformation."
msgstr ""
"`if-let` 可以堆叠使用，如下所示。`let-else` 结构支持展平此嵌套代码。将不通顺"
"的版本重写，以便学生们能够理解其中的变化。"

#: src/pattern-matching/let-control-flow.md
msgid "The rewritten version is:"
msgstr "重写后的版本为："

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid "while-let"
msgstr "while-let"

#: src/pattern-matching/let-control-flow.md
msgid ""
"Point out that the `while let` loop will keep going as long as the value "
"matches the pattern."
msgstr "指出只要值与模式匹配，`while let` 循环就会一直进行下去。"

#: src/pattern-matching/let-control-flow.md
#, fuzzy
msgid ""
"You could rewrite the `while let` loop as an infinite loop with an if "
"statement that breaks when there is no value to unwrap for `name.pop()`. The "
"`while let` provides syntactic sugar for the above scenario."
msgstr ""
"你可以使用 if 语句将 `while let` 循环重写为无限循环，当 `iter.next()` 没有值"
"可以解封时中断。`while let` 为上述情况提供了语法糖。"

#: src/pattern-matching/exercise.md
#, fuzzy
msgid "Let's write a simple recursive evaluator for arithmetic expressions."
msgstr "为算术表达式编写一个简单的递归评估器。先从定义二进制操作的枚举开始："

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"The `Box` type here is a smart pointer, and will be covered in detail later "
"in the course. An expression can be \"boxed\" with `Box::new` as seen in the "
"tests. To evaluate a boxed expression, use the deref operator (`*`) to "
"\"unbox\" it: `eval(*boxed_expr)`."
msgstr ""
"这里的 `Box` 类型是智能指针，本课程稍后会详细介绍。可以使用 `Box::new` 对表达"
"式进行 “封装”操作，如测试中所示。如需对已封装的表达式求值，请使用 deref 运算"
"符将其 “解封装”：`eval(*boxed_expr)`。"

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"Some expressions cannot be evaluated and will return an error. The standard "
"[`Result<Value, String>`](https://doc.rust-lang.org/std/result/enum.Result."
"html) type is an enum that represents either a successful value "
"(`Ok(Value)`) or an error (`Err(String)`). We will cover this type in detail "
"later."
msgstr ""
"部分表达式无法求值，将返回错误。`Res` 类型表示有效值或错误消息。这与我们后面"
"将看到的标准库的“Result”非常类似。"

#: src/pattern-matching/exercise.md
msgid ""
"Copy and paste the code into the Rust playground, and begin implementing "
"`eval`. The final product should pass the tests. It may be helpful to use "
"`todo!()` and get the tests to pass one-by-one. You can also skip a test "
"temporarily with `#[ignore]`:"
msgstr ""
"将代码复制粘贴到 Rust Playground，然后开始实现 `eval`。最终结果应能通过测试。"
"使用 `todo!()` 并使测试逐个通过可能会很有帮助。您还可以使用 `#[ignore]` 暂时"
"跳过测试："

#: src/pattern-matching/exercise.md
#, fuzzy
msgid ""
"If you finish early, try writing a test that results in division by zero or "
"integer overflow. How could you handle this with `Result` instead of a panic?"
msgstr ""
"如果提前完成测试，请尝试编写一项可导致被零除或整数溢出的测试。如何使用 `Res::"
"Err` 而非 panic 来应对这种情况？"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// An operation to perform on two subexpressions.\n"
msgstr "/// An operation to perform on two subexpressions.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// An expression, in tree form.\n"
msgstr "/// An expression, in tree form.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// An operation on two subexpressions.\n"
msgstr "/// An operation on two subexpressions.\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "/// A literal value\n"
msgstr "/// A literal value\n"

#: src/pattern-matching/exercise.md src/pattern-matching/solution.md
msgid "\"division by zero\""
msgstr "\"division by zero\""

#: src/pattern-matching/solution.md
msgid "\"expr: {:?}\""
msgstr "\"expr: {:?}\""

#: src/methods-and-traits.md
msgid "[Methods](./methods-and-traits/methods.md) (10 minutes)"
msgstr ""

#: src/methods-and-traits.md
msgid "[Traits](./methods-and-traits/traits.md) (10 minutes)"
msgstr ""

#: src/methods-and-traits.md
msgid "[Deriving](./methods-and-traits/deriving.md) (5 minutes)"
msgstr ""

#: src/methods-and-traits.md
msgid ""
"[Exercise: Generic Logger](./methods-and-traits/exercise.md) (20 minutes)"
msgstr ""

#: src/methods-and-traits.md src/generics.md src/iterators.md
#: src/error-handling.md
msgid "This segment should take about 45 minutes"
msgstr ""

#: src/methods-and-traits/methods.md
msgid ""
"Rust allows you to associate functions with your new types. You do this with "
"an `impl` block:"
msgstr "Rust 允许您将函数与新类型相关联。您可以使用“impl”块来执行此操作："

#: src/methods-and-traits/methods.md
msgid "// No receiver, a static method\n"
msgstr "// No receiver, a static method\n"

#: src/methods-and-traits/methods.md
msgid "// Exclusive borrowed read-write access to self\n"
msgstr "// Exclusive borrowed read-write access to self\n"

#: src/methods-and-traits/methods.md
msgid "// Shared and read-only borrowed access to self\n"
msgstr "// Shared and read-only borrowed access to self\n"

#: src/methods-and-traits/methods.md
msgid "\"Recorded {} laps for {}:\""
msgstr "\"Recorded {} laps for {}:\""

#: src/methods-and-traits/methods.md
msgid "\"Lap {idx}: {lap} sec\""
msgstr "\"Lap {idx}: {lap} sec\""

#: src/methods-and-traits/methods.md
msgid "// Exclusive ownership of self\n"
msgstr "// Exclusive ownership of self\n"

#: src/methods-and-traits/methods.md
msgid "\"Race {} is finished, total lap time: {}\""
msgstr "\"Race {} is finished, total lap time: {}\""

#: src/methods-and-traits/methods.md
msgid "\"Monaco Grand Prix\""
msgstr "\"Monaco Grand Prix\""

#: src/methods-and-traits/methods.md
msgid "// race.add_lap(42);\n"
msgstr "// race.add_lap(42);\n"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"The `self` arguments specify the \"receiver\" - the object the method acts "
"on. There are several common receivers for a method:"
msgstr ""
"上面的“&self”表明该方法以不可变的方式借用了对象。还有其他可能的方法接收器："

#: src/methods-and-traits/methods.md
msgid ""
"`&self`: borrows the object from the caller using a shared and immutable "
"reference. The object can be used again afterwards."
msgstr ""
"“&self”：使用不可变的共享引用从调用方借用对象。之后可以再次使用该对象。"

#: src/methods-and-traits/methods.md
msgid ""
"`&mut self`: borrows the object from the caller using a unique and mutable "
"reference. The object can be used again afterwards."
msgstr ""
"“&mut self”：使用唯一的可变引用从调用方借用对象。之后可以再次使用该对象。"

#: src/methods-and-traits/methods.md
msgid ""
"`self`: takes ownership of the object and moves it away from the caller. The "
"method becomes the owner of the object. The object will be dropped "
"(deallocated) when the method returns, unless its ownership is explicitly "
"transmitted. Complete ownership does not automatically mean mutability."
msgstr ""
"“self”：获取对象的所有权并将其从调用方移出。该方法会成为对象的所有者。除非明"
"确转移对象的所有权，否则在该方法返回时，对象将被丢弃（取消分配）。具备完全所"
"有权，不自动等同于具备可变性。"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid "`mut self`: same as above, but the method can mutate the object."
msgstr "`mut self`：同上，但该方法可以改变对象。"

#: src/methods-and-traits/methods.md
msgid ""
"No receiver: this becomes a static method on the struct. Typically used to "
"create constructors which are called `new` by convention."
msgstr ""
"无接收器：这将变为结构体上的静态方法。通常用于创建构造函数，按惯例被称"
"为“new”。"

#: src/methods-and-traits/methods.md
msgid "It can be helpful to introduce methods by comparing them to functions."
msgstr "引入方法时，将方法与函数进行比较会很有帮助。"

#: src/methods-and-traits/methods.md
msgid ""
"Methods are called on an instance of a type (such as a struct or enum), the "
"first parameter represents the instance as `self`."
msgstr ""
"在某种类型（例如结构体或枚举）的实例上调用方法，第一个参数将该实例表示"
"为“self”。"

#: src/methods-and-traits/methods.md
msgid ""
"Developers may choose to use methods to take advantage of method receiver "
"syntax and to help keep them more organized. By using methods we can keep "
"all the implementation code in one predictable place."
msgstr ""
"开发者可能会选择使用方法，以便利用方法接收器语法并让方法更有条理。通过使用方"
"法，我们可以将所有实现代码保存在一个可预测的位置。"

#: src/methods-and-traits/methods.md
msgid "Point out the use of the keyword `self`, a method receiver."
msgstr "指出关键字“self”的用法，它是一种方法接收器。"

#: src/methods-and-traits/methods.md
msgid ""
"Show that it is an abbreviated term for `self: Self` and perhaps show how "
"the struct name could also be used."
msgstr "显示它是“self: Self”的缩写术语，或许要显示结构体名称的可能用法。"

#: src/methods-and-traits/methods.md
msgid ""
"Explain that `Self` is a type alias for the type the `impl` block is in and "
"can be used elsewhere in the block."
msgstr "说明“Self”是“impl”块所属类型的类型别名，可以在块中的其他位置使用。"

#: src/methods-and-traits/methods.md
msgid ""
"Note how `self` is used like other structs and dot notation can be used to "
"refer to individual fields."
msgstr ""
"指出“self”的使用方式与其他结构体一样，并且可以使用点表示法来指代各个字段。"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"This might be a good time to demonstrate how the `&self` differs from `self` "
"by trying to run `finish` twice."
msgstr ""
"这可能是演示“&self”和“self”差别的好时机，您只要修改代码并尝试执行 say_hello "
"两次即可。"

#: src/methods-and-traits/methods.md
#, fuzzy
msgid ""
"Beyond variants on `self`, there are also [special wrapper types](https://"
"doc.rust-lang.org/reference/special-types-and-traits.html) allowed to be "
"receiver types, such as `Box<Self>`."
msgstr ""
"除“self”的变体外，还可以将[特殊封装容器类型](https://doc.rust-lang.org/"
"reference/special-types-and-traits.html)作为接收器类型，例如“Box\n"
"\n"
"”。"

#: src/methods-and-traits/traits.md
msgid ""
"Rust lets you abstract over types with traits. They're similar to interfaces:"
msgstr "Rust 让您可以依据特征对类型进行抽象化处理。特征与接口类似："

#: src/methods-and-traits/traits.md
msgid "\"Oh you're a cutie! What's your name? {}\""
msgstr "\"Oh you're a cutie! What's your name? {}\""

#: src/methods-and-traits/traits.md src/smart-pointers/trait-objects.md
msgid "\"Woof, my name is {}!\""
msgstr "\"Woof, my name is {}!\""

#: src/methods-and-traits/traits.md src/smart-pointers/trait-objects.md
msgid "\"Miau!\""
msgstr "\"Miau!\""

#: src/methods-and-traits/traits.md src/smart-pointers/trait-objects.md
msgid "\"Fido\""
msgstr "\"Fido\""

#: src/methods-and-traits/traits.md
msgid ""
"A trait defines a number of methods that types must have in order to "
"implement the trait."
msgstr "trait 定义了类型实现该 trait 所必须具备的一些方法。"

#: src/methods-and-traits/traits.md
msgid "Traits are implemented in an `impl <trait> for <type> { .. }` block."
msgstr "trait 在 `<type> { .. } 的 impl <trait>` 代码块中实现。"

#: src/methods-and-traits/traits.md
#, fuzzy
msgid ""
"Traits may specify pre-implemented (provided) methods and methods that users "
"are required to implement themselves. Provided methods can rely on required "
"methods. In this case, `greet` is provided, and relies on `talk`."
msgstr ""
"trait 或许可指定预实现（默认）方法，以及用户需要自行实现的方法。具有默认实现"
"的方法可以依赖于必需的方法。"

#: src/methods-and-traits/deriving.md
msgid ""
"Supported traits can be automatically implemented for your custom types, as "
"follows:"
msgstr "系统可以自动为您的自定义类型实现支持的 trait，如下所示："

#: src/methods-and-traits/deriving.md
msgid "// Default trait adds `default` constructor.\n"
msgstr "// Default trait adds `default` constructor.\n"

#: src/methods-and-traits/deriving.md
msgid "// Clone trait adds `clone` method.\n"
msgstr "// Clone trait adds `clone` method.\n"

#: src/methods-and-traits/deriving.md
msgid "\"EldurScrollz\""
msgstr "\"EldurScrollz\""

#: src/methods-and-traits/deriving.md
msgid "// Debug trait adds support for printing with `{:?}`.\n"
msgstr "// Debug trait adds support for printing with `{:?}`.\n"

#: src/methods-and-traits/deriving.md
msgid "\"{:?} vs. {:?}\""
msgstr "\"{:?} vs. {:?}\""

#: src/methods-and-traits/deriving.md
msgid ""
"Derivation is implemented with macros, and many crates provide useful derive "
"macros to add useful functionality. For example, `serde` can derive "
"serialization support for a struct using `#[derive(Serialize)]`."
msgstr ""
"派生功能是通过宏实现的，并且许多 crate 提供有用的派生宏，以添加实用功能。例"
"如，`serde` 可以使用 `#[derive(Serialize)]` 为结构体派生序列化支持。"

#: src/methods-and-traits/exercise.md
msgid ""
"Let's design a simple logging utility, using a trait `Logger` with a `log` "
"method. Code which might log its progress can then take an `&impl Logger`. "
"In testing, this might put messages in the test logfile, while in a "
"production build it would send messages to a log server."
msgstr ""

#: src/methods-and-traits/exercise.md
msgid ""
"However, the `StderrLogger` given below logs all messages, regardless of "
"verbosity. Your task is to write a `VerbosityFilter` type that will ignore "
"messages above a maximum verbosity."
msgstr ""

#: src/methods-and-traits/exercise.md
msgid ""
"This is a common pattern: a struct wrapping a trait implementation and "
"implementing that same trait, adding behavior in the process. What other "
"kinds of wrappers might be useful in a logging utility?"
msgstr ""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "/// Log a message at the given verbosity level.\n"
msgstr ""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"verbosity={verbosity}: {message}\""
msgstr ""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
msgid "\"FYI\""
msgstr ""

#: src/methods-and-traits/exercise.md src/methods-and-traits/solution.md
#, fuzzy
msgid "\"Uhoh\""
msgstr "\"uhoh\""

#: src/methods-and-traits/exercise.md
msgid "// TODO: Define and implement `VerbosityFilter`.\n"
msgstr ""

#: src/methods-and-traits/solution.md
msgid "/// Only log messages up to the given verbosity level.\n"
msgstr ""

#: src/generics.md
msgid "[Generic Functions](./generics/generic-functions.md) (5 minutes)"
msgstr ""

#: src/generics.md
msgid "[Generic Data Types](./generics/generic-data.md) (15 minutes)"
msgstr ""

#: src/generics.md
msgid "[Trait Bounds](./generics/trait-bounds.md) (10 minutes)"
msgstr ""

#: src/generics.md
msgid "[impl Trait](./generics/impl-trait.md) (5 minutes)"
msgstr ""

#: src/generics.md
msgid "[Exercise: Generic min](./generics/exercise.md) (10 minutes)"
msgstr ""

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Rust supports generics, which lets you abstract algorithms or data "
"structures (such as sorting or a binary tree) over the types used or stored."
msgstr ""
"Rust 支持泛型，允许您根据算法（例如排序）中使用的类型对算法进行抽象化处理。"

#: src/generics/generic-functions.md
msgid "/// Pick `even` or `odd` depending on the value of `n`.\n"
msgstr "/// Pick `even` or `odd` depending on the value of `n`.\n"

#: src/generics/generic-functions.md
msgid "\"picked a number: {:?}\""
msgstr "\"picked a number: {:?}\""

#: src/generics/generic-functions.md
msgid "\"picked a tuple: {:?}\""
msgstr "\"picked a tuple: {:?}\""

#: src/generics/generic-functions.md
msgid "\"dog\""
msgstr "\"dog\""

#: src/generics/generic-functions.md
msgid "\"cat\""
msgstr "\"cat\""

#: src/generics/generic-functions.md
msgid ""
"Rust infers a type for T based on the types of the arguments and return "
"value."
msgstr "Rust 会根据参数类型和返回值推理出 T 的类型。"

#: src/generics/generic-functions.md
msgid ""
"This is similar to C++ templates, but Rust partially compiles the generic "
"function immediately, so that function must be valid for all types matching "
"the constraints. For example, try modifying `pick` to return `even + odd` if "
"`n == 0`. Even if only the `pick` instantiation with integers is used, Rust "
"still considers it invalid. C++ would let you do this."
msgstr ""
"这与 C++ 模板类似，但 Rust 会立即编译部分通用函数，因此该函数必须对所有符合约"
"束条件的类型都有效。例如，请尝试修改 `pick` 函数，如果 `n == 0`，则返回 "
"`even + odd`。即使仅使用带有整数的“pick”实例化，Rust 仍会将其视为无效。C++ 可"
"让您做到这一点。"

#: src/generics/generic-functions.md
#, fuzzy
msgid ""
"Generic code is turned into non-generic code based on the call sites. This "
"is a zero-cost abstraction: you get exactly the same result as if you had "
"hand-coded the data structures without the abstraction."
msgstr ""
"这是零成本的抽象化处理：您得到的结果不会受到影响，也就是说，与在没有进行抽象"
"化处理的情况下，对数据结构进行手动编码时的结果一样。"

#: src/generics/generic-data.md
msgid "You can use generics to abstract over the concrete field type:"
msgstr "您可以使用泛型对具体字段类型进行抽象化处理："

#: src/generics/generic-data.md
msgid "// fn set_x(&mut self, x: T)\n"
msgstr "// fn set_x(&mut self, x: T)\n"

#: src/generics/generic-data.md
msgid "\"{integer:?} and {float:?}\""
msgstr "\"{integer:?} and {float:?}\""

#: src/generics/generic-data.md
msgid "\"coords: {:?}\""
msgstr "\"coords: {:?}\""

#: src/generics/generic-data.md
msgid ""
"_Q:_ Why `T` is specified twice in `impl<T> Point<T> {}`? Isn't that "
"redundant?"
msgstr ""
"\\*问：\\*为什么 `T` 在 `impl<T> Point<T> {}` 中指定了两次？这不是多余的吗？"

#: src/generics/generic-data.md
msgid ""
"This is because it is a generic implementation section for generic type. "
"They are independently generic."
msgstr "这是因为它是泛型类型的泛型实现部分。它们是独立的泛型内容。"

#: src/generics/generic-data.md
msgid "It means these methods are defined for any `T`."
msgstr "这意味着这些方法是针对所有 `T` 定义的。"

#: src/generics/generic-data.md
#, fuzzy
msgid "It is possible to write `impl Point<u32> { .. }`."
msgstr "可以编写 `impl Point<u32> { .. }`。"

#: src/generics/generic-data.md
msgid ""
"`Point` is still generic and you can use `Point<f64>`, but methods in this "
"block will only be available for `Point<u32>`."
msgstr ""
"`Point` 依然是一个泛型，并且您可以使用 `Point<f64>`，但此块中的方法将仅适用"
"于 `Point<u32>`。"

#: src/generics/generic-data.md
msgid ""
"Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`. Update the "
"code to allow points that have elements of different types, by using two "
"type variables, e.g., `T` and `U`."
msgstr ""
"请尝试声明一个新变量 `let p = Point { x: 5, y: 10.0 };`。通过使用两种类型变量"
"（例如 `T` 和 `U`），更新代码以允许具有不同类型元素的点。"

#: src/generics/trait-bounds.md
msgid ""
"When working with generics, you often want to require the types to implement "
"some trait, so that you can call this trait's methods."
msgstr ""
"使用泛型时，您通常会想要利用类型来实现某些特性， 这样才能调用此特征的方法。"

#: src/generics/trait-bounds.md
msgid "You can do this with `T: Trait` or `impl Trait`:"
msgstr "您可以使用 `T: Trait` 或 `impl Trait` 执行此操作："

#: src/generics/trait-bounds.md
msgid "// struct NotClonable;\n"
msgstr "// struct NotClonable;\n"

#: src/generics/trait-bounds.md
msgid "\"{pair:?}\""
msgstr "\"{pair:?}\""

#: src/generics/trait-bounds.md
msgid "Try making a `NonClonable` and passing it to `duplicate`."
msgstr "请尝试创建一个 `NonClonable` 对象，并将其传递给 `duplicate` 函数。"

#: src/generics/trait-bounds.md
msgid "When multiple traits are necessary, use `+` to join them."
msgstr "当需要多个 trait 时，请使用 `+` 将它们连接起来。"

#: src/generics/trait-bounds.md
msgid "Show a `where` clause, students will encounter it when reading code."
msgstr "显示 `where` 子句，学员在阅读代码时会看到它。"

#: src/generics/trait-bounds.md
msgid "It declutters the function signature if you have many parameters."
msgstr "它会在您有多个形参的情况下整理函数签名。"

#: src/generics/trait-bounds.md
msgid "It has additional features making it more powerful."
msgstr "它具有额外功能，因此也更强大。"

#: src/generics/trait-bounds.md
msgid ""
"If someone asks, the extra feature is that the type on the left of \":\" can "
"be arbitrary, like `Option<T>`."
msgstr ""
"如果有人提问，便阐明额外功能是指“:”左侧的类别可为任意值，例如 `Option<T>`。"

#: src/generics/trait-bounds.md
msgid ""
"Note that Rust does not (yet) support specialization. For example, given the "
"original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`."
msgstr ""
"请注意，Rust 尚不支持专精领域认证。例如，根据原始 `duplicate` 函数，添加专精"
"领域认证的 `Duplicate(a: u32)` 是无效的。"

#: src/generics/impl-trait.md
msgid ""
"Similar to trait bounds, an `impl Trait` syntax can be used in function "
"arguments and return values:"
msgstr "与特征边界类似，`impl Trait` 语法可以在函数形参 和返回值中使用："

#: src/generics/impl-trait.md
msgid ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"
msgstr ""
"// Syntactic sugar for:\n"
"//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\n"

#: src/generics/impl-trait.md
msgid "\"{many}\""
msgstr "\"{many}\""

#: src/generics/impl-trait.md
msgid "\"{many_more}\""
msgstr "\"{many_more}\""

#: src/generics/impl-trait.md
msgid "\"debuggable: {debuggable:?}\""
msgstr "\"debuggable: {debuggable:?}\""

#: src/generics/impl-trait.md
#, fuzzy
msgid ""
"`impl Trait` allows you to work with types which you cannot name. The "
"meaning of `impl Trait` is a bit different in the different positions."
msgstr "`impl Trait` 的意义因使用位置而略有不同。"

#: src/generics/impl-trait.md
msgid ""
"For a parameter, `impl Trait` is like an anonymous generic parameter with a "
"trait bound."
msgstr "对形参来说，`impl Trait` 就像是具有特征边界的匿名泛型形参。"

#: src/generics/impl-trait.md
msgid ""
"For a return type, it means that the return type is some concrete type that "
"implements the trait, without naming the type. This can be useful when you "
"don't want to expose the concrete type in a public API."
msgstr ""
"对返回值类型来说，它则意味着返回值类型就是实现该特征的某具体类型， 无需为该类"
"型命名。如果您不想在公共 API 中公开该具体类型，便可 使用此方法。"

#: src/generics/impl-trait.md
msgid ""
"Inference is hard in return position. A function returning `impl Foo` picks "
"the concrete type it returns, without writing it out in the source. A "
"function returning a generic type like `collect<B>() -> B` can return any "
"type satisfying `B`, and the caller may need to choose one, such as with "
"`let x: Vec<_> = foo.collect()` or with the turbofish, `foo.collect::"
"<Vec<_>>()`."
msgstr ""
"在返回位置处进行推断有一定难度。会返回 `impl Foo` 的函数会挑选 自身返回的具体"
"类型，而不必在来源中写出此信息。会返回 泛型类型（例如 `collect<B>() -> B`）的"
"函数则可返回符合 `B` 的任何类型，而调用方可能需要选择一个类型，例如使用 `let "
"x: Vec<_> = foo.collect()` 或使用以下 Turbofish：`foo.collect::<Vec<_>>()`。"

#: src/generics/impl-trait.md
msgid ""
"What is the type of `debuggable`? Try `let debuggable: () = ..` to see what "
"the error message shows."
msgstr ""
"`debuggable` 是什么类型？尝试输入 `let debuggable: () = ..`，查看会显示什么错"
"误消息。"

#: src/generics/exercise.md
msgid ""
"In this short exercise, you will implement a generic `min` function that "
"determines the minimum of two values, using a `LessThan` trait."
msgstr ""
"在这个简短的练习中，您将使用 `LessThan` trait，实现一个通用 `min` 函数，用于"
"确定两个值中的最小值。"

#: src/generics/exercise.md src/generics/solution.md
msgid "/// Return true if self is less than other.\n"
msgstr "/// Return true if self is less than other.\n"

#: src/generics/exercise.md
msgid "// TODO: implement the `min` function used in `main`.\n"
msgstr "// TODO: implement the `min` function used in `main`.\n"

#: src/generics/exercise.md src/generics/solution.md
msgid "\"Shapiro\""
msgstr "\"Shapiro\""

#: src/generics/exercise.md src/generics/solution.md
msgid "\"Baumann\""
msgstr "\"Baumann\""

#: src/welcome-day-2-afternoon.md
msgid "[Standard Library Types](./std-types.md) (1 hour and 10 minutes)"
msgstr ""

#: src/welcome-day-2-afternoon.md
msgid "[Standard Library Traits](./std-traits.md) (1 hour and 40 minutes)"
msgstr ""

#: src/std-types.md
msgid "[Standard Library](./std-types/std.md) (3 minutes)"
msgstr ""

#: src/std-types.md
msgid "[Documentation](./std-types/docs.md) (5 minutes)"
msgstr ""

#: src/std-types.md
msgid "[Option](./std-types/option.md) (10 minutes)"
msgstr ""

#: src/std-types.md
msgid "[Result](./std-types/result.md) (10 minutes)"
msgstr ""

#: src/std-types.md
msgid "[String](./std-types/string.md) (10 minutes)"
msgstr ""

#: src/std-types.md
msgid "[Vec](./std-types/vec.md) (10 minutes)"
msgstr ""

#: src/std-types.md
msgid "[HashMap](./std-types/hashmap.md) (10 minutes)"
msgstr ""

#: src/std-types.md
msgid "[Exercise: Counter](./std-types/exercise.md) (10 minutes)"
msgstr ""

#: src/std-types.md src/memory-management.md src/slices-and-lifetimes.md
msgid "This segment should take about 1 hour and 10 minutes"
msgstr ""

#: src/std-types.md
msgid ""
"For each of the slides in this section, spend some time reviewing the "
"documentation pages, highlighting some of the more common methods."
msgstr ""
"对于本部分的每张幻灯片，请花些时间仔细阅读文档页面，重点了解一些较为常用的方"
"法。"

#: src/std-types/std.md
#, fuzzy
msgid ""
"Rust comes with a standard library which helps establish a set of common "
"types used by Rust libraries and programs. This way, two libraries can work "
"together smoothly because they both use the same `String` type."
msgstr ""
"Rust 附带一个标准库，此库有助于建立一个供 Rust 库和程序 使用的常用类型集。这"
"样一来，两个库便可顺畅地搭配运作， 因为它们使用相同的 `String` 类型。"

#: src/std-types/std.md
#, fuzzy
msgid ""
"In fact, Rust contains several layers of the Standard Library: `core`, "
"`alloc` and `std`."
msgstr "Rust 实际上含有多个层级的标准库，分别是 `core`、`alloc` 和 `std`。"

#: src/std-types/std.md
#, fuzzy
msgid ""
"`core` includes the most basic types and functions that don't depend on "
"`libc`, allocator or even the presence of an operating system."
msgstr ""
"`core` 包括最基本的类型与函数，这些类型与函数不依赖于 `libc`、分配器 或是否存"
"在操作系统。"

#: src/std-types/std.md
msgid ""
"`alloc` includes types which require a global heap allocator, such as `Vec`, "
"`Box` and `Arc`."
msgstr "`alloc` 包括需要全局堆分配器的类型，例如 `Vec`、`Box` 和 `Arc`。"

#: src/std-types/std.md
msgid ""
"Embedded Rust applications often only use `core`, and sometimes `alloc`."
msgstr "嵌入式 Rust 应用通常只使用 `core`，偶尔会使用 `alloc`。"

#: src/std-types/docs.md
#, fuzzy
msgid "Rust comes with extensive documentation. For example:"
msgstr "Rust 附带有大量关于该语言和标准库的文档。"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"All of the details about [loops](https://doc.rust-lang.org/stable/reference/"
"expressions/loop-expr.html)."
msgstr ""
"如果你想提前退出循环，请使用 [`break`](https://doc.rust-lang.org/reference/"
"expressions/loop-expr.html#break-expressions)，"

#: src/std-types/docs.md
msgid ""
"Primitive types like [`u8`](https://doc.rust-lang.org/stable/std/primitive."
"u8.html)."
msgstr ""
"['u8'](https://doc.rust-lang.org/stable/std/primitive.u8.html) 等基元类型。"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Standard library types like [`Option`](https://doc.rust-lang.org/stable/std/"
"option/enum.Option.html) or [`BinaryHeap`](https://doc.rust-lang.org/stable/"
"std/collections/struct.BinaryHeap.html)."
msgstr ""
"[“str”](https://doc.rust-lang.org/std/primitive.str.html)和[“String”]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/std-types/docs.md
msgid "In fact, you can document your own code:"
msgstr "事实上，您可以为自己的代码编写文档："

#: src/std-types/docs.md
msgid ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"
msgstr ""
"/// Determine whether the first argument is divisible by the second "
"argument.\n"
"///\n"
"/// If the second argument is zero, the result is false.\n"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"The contents are treated as Markdown. All published Rust library crates are "
"automatically documented at [`docs.rs`](https://docs.rs) using the [rustdoc]"
"(https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is "
"idiomatic to document all public items in an API using this pattern."
msgstr ""
"文档的内容会被当做 Markdown 处理。所有已发布 Rust 库 crate 都会自动被"
"[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) 工具在 "
"[`docs.rs`](https://docs.rs)存档。 按照这种方式来为 API 中的所有公开项编写文"
"档是 Rust 中惯用的做法。"

#: src/std-types/docs.md
msgid ""
"To document an item from inside the item (such as inside a module), use `//!"
"` or `/*! .. */`, called \"inner doc comments\":"
msgstr ""
"如需从项内（例如在模块内）为项编写文档，请使用 `//!` 或 `/*! .. */`，这称"
"为“内部文档注释”："

#: src/std-types/docs.md
msgid ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"
msgstr ""
"//! This module contains functionality relating to divisibility of "
"integers.\n"

#: src/std-types/docs.md
#, fuzzy
msgid ""
"Show students the generated docs for the `rand` crate at <https://docs.rs/"
"rand>."
msgstr ""
"向学生展示在 [`docs.rs/rand`](https://docs.rs/rand) 中为 `rand` crate 生成的"
"文档。"

#: src/std-types/option.md
#, fuzzy
msgid "Option"
msgstr "异常"

#: src/std-types/option.md
msgid ""
"We have already seen some use of `Option<T>`. It stores either a value of "
"type `T` or nothing. For example, [`String::find`](https://doc.rust-lang.org/"
"stable/std/string/struct.String.html#method.find) returns an `Option<usize>`."
msgstr ""
"我们已经了解了 `Option<T>` 的一些用法。它可以存储“T”类型的值，或者不存储任何"
"值。例如，['String::find'](https://doc.rust-lang.org/stable/std/string/"
"struct.String.html#method.find) 会返回 `Option<usize>`。"

#: src/std-types/option.md
msgid "\"Löwe 老虎 Léopard Gepardi\""
msgstr "\"Löwe 老虎 Léopard Gepardi\""

#: src/std-types/option.md
msgid "'é'"
msgstr "'é'"

#: src/std-types/option.md
msgid "\"find returned {position:?}\""
msgstr "\"find returned {position:?}\""

#: src/std-types/option.md
msgid "'Z'"
msgstr "'Z'"

#: src/std-types/option.md
msgid "\"Character not found\""
msgstr "\"Character not found\""

#: src/std-types/option.md
#, fuzzy
msgid "`Option` is widely used, not just in the standard library."
msgstr "`Option` 和 `Result` 的使用范围很广，不局限于标准库。"

#: src/std-types/option.md
msgid ""
"`unwrap` will return the value in an `Option`, or panic. `expect` is similar "
"but takes an error message."
msgstr ""
"`unwrap` 会返回 `Option` 或 panic 中的值。`expect` 方法与此类似，但其使用错误"
"消息。"

#: src/std-types/option.md
msgid ""
"You can panic on None, but you can't \"accidentally\" forget to check for "
"None."
msgstr "出现 None 时您或许会恐慌，但不能 “无意中”忘记检查是否为 None 的情况。"

#: src/std-types/option.md
msgid ""
"It's common to `unwrap`/`expect` all over the place when hacking something "
"together, but production code typically handles `None` in a nicer fashion."
msgstr ""
"在草拟阶段的编程中，频繁使用 `unwrap`/`expect` 进行处理十分常见，但在正式版代"
"码时，通常以更为妥当的方式处理 `None` 的情况。"

#: src/std-types/option.md
msgid ""
"The niche optimization means that `Option<T>` often has the same size in "
"memory as `T`."
msgstr "小众优化意味着 `Option<T>` 在内存中的大小通常与 `T` 相同。"

#: src/std-types/result.md
msgid "Result"
msgstr "Result"

#: src/std-types/result.md
msgid ""
"`Result` is similar to `Option`, but indicates the success or failure of an "
"operation, each with a different type. This is similar to the `Res` defined "
"in the expression exercise, but generic: `Result<T, E>` where `T` is used in "
"the `Ok` variant and `E` appears in the `Err` variant."
msgstr ""
"`Result` 与 `Option` 相似，但表示操作成功或失败，且每个操作的类型不同。这类似"
"于表达式练习中定义的 `Res`，但是一个泛型：`Result<T, E>`，其中 `T` 用于 `Ok` "
"变体，`E` 出现在 `Err` 变体中。"

#: src/std-types/result.md
msgid "\"diary.txt\""
msgstr "\"diary.txt\""

#: src/std-types/result.md
msgid "\"Dear diary: {contents} ({bytes} bytes)\""
msgstr "\"Dear diary: {contents} ({bytes} bytes)\""

#: src/std-types/result.md
msgid "\"Could not read file content\""
msgstr "\"Could not read file content\""

#: src/std-types/result.md
msgid "\"The diary could not be opened: {err}\""
msgstr "\"The diary could not be opened: {err}\""

#: src/std-types/result.md
msgid ""
"As with `Option`, the successful value sits inside of `Result`, forcing the "
"developer to explicitly extract it. This encourages error checking. In the "
"case where an error should never happen, `unwrap()` or `expect()` can be "
"called, and this is a signal of the developer intent too."
msgstr ""
"与 `Option` 方法相同，成功值位于 `Result` 方法内部， 开发者必须显示提取成功"
"值。因此，建议进行错误检查。在绝不应出现错误的情况下， 可以调用 `unwrap()` "
"或 `expect()` 方法，这也是一种开发者意向信号。"

#: src/std-types/result.md
#, fuzzy
msgid ""
"`Result` documentation is a recommended read. Not during the course, but it "
"is worth mentioning. It contains a lot of convenience methods and functions "
"that help functional-style programming."
msgstr ""
"我们建议阅读 `Result` 文档。虽然课程中不会涉及该文档，但是有必要提到它。 该文"
"档中包含许多便捷的方法和函数，对于函数式编程很有帮助。"

#: src/std-types/result.md
msgid ""
"`Result` is the standard type to implement error handling as we will see on "
"Day 3."
msgstr "`Result` 是用于实现错误处理的标准类型，我们将在第 3 天的课程中介绍。"

#: src/std-types/string.md
msgid "String"
msgstr "String"

#: src/std-types/string.md
msgid ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) is the "
"standard heap-allocated growable UTF-8 string buffer:"
msgstr ""
"[`String`](https://doc.rust-lang.org/std/string/struct.String.html) 是标准堆"
"分配的可扩容 UTF-8 字符串缓冲区："

#: src/std-types/string.md src/std-traits/read-and-write.md
#: src/memory-management/review.md src/testing/unit-tests.md
#: src/concurrency/scoped-threads.md
#, fuzzy
msgid "\"Hello\""
msgstr "\"Hello\""

#: src/std-types/string.md
msgid "\"s1: len = {}, capacity = {}\""
msgstr "\"s1: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "'!'"
msgstr "'!'"

#: src/std-types/string.md
msgid "\"s2: len = {}, capacity = {}\""
msgstr "\"s2: len = {}, capacity = {}\""

#: src/std-types/string.md
msgid "\"🇨🇭\""
msgstr "\"🇨🇭\""

#: src/std-types/string.md
msgid "\"s3: len = {}, number of chars = {}\""
msgstr "\"s3: len = {}, number of chars = {}\""

#: src/std-types/string.md
msgid ""
"`String` implements [`Deref<Target = str>`](https://doc.rust-lang.org/std/"
"string/struct.String.html#deref-methods-str), which means that you can call "
"all `str` methods on a `String`."
msgstr ""
"`String` 会实现 [`Deref<Target = str>`](https://doc.rust-lang.org/std/string/"
"struct.String.html#deref-methods-str)，这意味着您可以 对 `String` 调用所有 "
"`str` 方法。"

#: src/std-types/string.md
msgid ""
"`String::new` returns a new empty string, use `String::with_capacity` when "
"you know how much data you want to push to the string."
msgstr ""
"“String::new”会返回一个新的空字符串，如果您知道自己想要推送到字符串的数据量，"
"请使用“String::with_capacity”。"

#: src/std-types/string.md
msgid ""
"`String::len` returns the size of the `String` in bytes (which can be "
"different from its length in characters)."
msgstr ""
"“String::len”会返回“String”的大小（以字节为单位，可能不同于以字符为单位的长"
"度）。"

#: src/std-types/string.md
msgid ""
"`String::chars` returns an iterator over the actual characters. Note that a "
"`char` can be different from what a human will consider a \"character\" due "
"to [grapheme clusters](https://docs.rs/unicode-segmentation/latest/"
"unicode_segmentation/struct.Graphemes.html)."
msgstr ""
"“String::chars”会针对实际字符返回一个迭代器。请注意，由于[字素簇](https://"
"docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes."
"html)，“char”可能与人们所认为的“字符”有所不同。"

#: src/std-types/string.md
msgid ""
"When people refer to strings they could either be talking about `&str` or "
"`String`."
msgstr "当人们提到字符串时，可能是指“&str”或“String”。"

#: src/std-types/string.md
msgid ""
"When a type implements `Deref<Target = T>`, the compiler will let you "
"transparently call methods from `T`."
msgstr ""
"当某个类型实现“Deref\\<Target = T>”时，编译器会让您以公开透明方式从“T”调用方"
"法。"

#: src/std-types/string.md
msgid ""
"We haven't discussed the `Deref` trait yet, so at this point this mostly "
"explains the structure of the sidebar in the documentation."
msgstr "我们尚未讨论过 `Deref` trait，所以本部分目前主要介绍文档中边栏的结构。"

#: src/std-types/string.md
msgid ""
"`String` implements `Deref<Target = str>` which transparently gives it "
"access to `str`'s methods."
msgstr ""
"“String”会实现“Deref\\<Target = str>”，后者可公开透明地授予其访问“str”方法的"
"权限。"

#: src/std-types/string.md
#, fuzzy
msgid "Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`."
msgstr "写下并比较“let s3 = s1.deref();”和“let s3 = &\\*s1;”。"

#: src/std-types/string.md
msgid ""
"`String` is implemented as a wrapper around a vector of bytes, many of the "
"operations you see supported on vectors are also supported on `String`, but "
"with some extra guarantees."
msgstr ""
"“String”是作为字节矢量的封装容器实现的，矢量上支持的许多操作在“String”上也受"
"支持，但有一些额外保证。"

#: src/std-types/string.md
msgid "Compare the different ways to index a `String`:"
msgstr "比较将“String”编入索引的不同方式："

#: src/std-types/string.md
msgid ""
"To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound, "
"out-of-bounds."
msgstr "使用“s3.chars().nth(i).unwrap()”转换为字符，其中“i”代表是否出界。"

#: src/std-types/string.md
msgid ""
"To a substring by using `s3[0..4]`, where that slice is on character "
"boundaries or not."
msgstr ""
"通过使用“s3\\[0..4\\]”转换为子字符串，其中该 Slice 在或不在字符边界上。"

#: src/std-types/vec.md
msgid ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) is the standard "
"resizable heap-allocated buffer:"
msgstr ""
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) 是标准的可调整大小"
"堆分配缓冲区："

#: src/std-types/vec.md
msgid "\"v1: len = {}, capacity = {}\""
msgstr "\"v1: len = {}, capacity = {}\""

#: src/std-types/vec.md
msgid "\"v2: len = {}, capacity = {}\""
msgstr "\"v2: len = {}, capacity = {}\""

#: src/std-types/vec.md
msgid "// Canonical macro to initialize a vector with elements.\n"
msgstr "// Canonical macro to initialize a vector with elements.\n"

#: src/std-types/vec.md
msgid "// Retain only the even elements.\n"
msgstr "// Retain only the even elements.\n"

#: src/std-types/vec.md
msgid "\"{v3:?}\""
msgstr "\"{v3:?}\""

#: src/std-types/vec.md
msgid "// Remove consecutive duplicates.\n"
msgstr "// Remove consecutive duplicates.\n"

#: src/std-types/vec.md
msgid ""
"`Vec` implements [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D), which means that you can call slice "
"methods on a `Vec`."
msgstr ""
"`Vec` 会实现 [`Deref<Target = [T]>`](https://doc.rust-lang.org/std/vec/"
"struct.Vec.html#deref-methods-%5BT%5D)，这意味着您可以对 `Vec` 调用 slice 方"
"法。"

#: src/std-types/vec.md
#, fuzzy
msgid ""
"`Vec` is a type of collection, along with `String` and `HashMap`. The data "
"it contains is stored on the heap. This means the amount of data doesn't "
"need to be known at compile time. It can grow or shrink at runtime."
msgstr ""
"“Vec”以及“String”和“HashMap”都是一种集合。它包含的数据会存储在堆上。这意味着"
"在编译时不需要知道数据量。它可以在运行时增大或缩小。"

#: src/std-types/vec.md
#, fuzzy
msgid ""
"Notice how `Vec<T>` is a generic type too, but you don't have to specify `T` "
"explicitly. As always with Rust type inference, the `T` was established "
"during the first `push` call."
msgstr ""
"请注意，“Vec\n"
"\n"
"”也是一种泛型，但您不必明确指定“T”。和往常的 Rust 类别推断一样，系统会在第一"
"次“push”调用期间建立“T”。"

#: src/std-types/vec.md
msgid ""
"`vec![...]` is a canonical macro to use instead of `Vec::new()` and it "
"supports adding initial elements to the vector."
msgstr ""
"“vec![...\\]”是用来代替“Vec::new()”的规范化宏，它支持向矢量添加初始元素。"

#: src/std-types/vec.md
msgid ""
"To index the vector you use `[` `]`, but they will panic if out of bounds. "
"Alternatively, using `get` will return an `Option`. The `pop` function will "
"remove the last element."
msgstr ""
"如需将矢量编入索引，您可以使用“\\[’ ‘\\]”方法，但如果超出边界，矢量将会 "
"panic。此外，使用“get”将返回“Option”。“pop”函数会移除最后一个元素。"

#: src/std-types/vec.md
#, fuzzy
msgid ""
"Slices are covered on day 3. For now, students only need to know that a "
"value of type `Vec` gives access to all of the documented slice methods, too."
msgstr ""
"第 3 天会介绍 slice。目前，学生只需知道使用 `Vec` 类型的值也可访问所有已载明"
"的只读 slice 方法。"

#: src/std-types/hashmap.md
msgid "Standard hash map with protection against HashDoS attacks:"
msgstr "标准的哈希映射，内含针对 HashDoS 攻击的保护措施："

#: src/std-types/hashmap.md
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"Adventures of Huckleberry Finn\""

#: src/std-types/hashmap.md
msgid "\"Grimms' Fairy Tales\""
msgstr "\"Grimms' Fairy Tales\""

#: src/std-types/hashmap.md
msgid "\"Pride and Prejudice\""
msgstr "\"Pride and Prejudice\""

#: src/std-types/hashmap.md
msgid "\"Les Misérables\""
msgstr "\"Les Misérables\""

#: src/std-types/hashmap.md
msgid "\"We know about {} books, but not Les Misérables.\""
msgstr "\"We know about {} books, but not Les Misérables.\""

#: src/std-types/hashmap.md
msgid "\"Alice's Adventure in Wonderland\""
msgstr "\"Alice's Adventure in Wonderland\""

#: src/std-types/hashmap.md
msgid "\"{book}: {count} pages\""
msgstr "\"{book}: {count} pages\""

#: src/std-types/hashmap.md
msgid "\"{book} is unknown.\""
msgstr "\"{book} is unknown.\""

#: src/std-types/hashmap.md
msgid "// Use the .entry() method to insert a value if nothing is found.\n"
msgstr "// Use the .entry() method to insert a value if nothing is found.\n"

#: src/std-types/hashmap.md
msgid "\"{page_counts:#?}\""
msgstr "\"{page_counts:#?}\""

#: src/std-types/hashmap.md
msgid ""
"`HashMap` is not defined in the prelude and needs to be brought into scope."
msgstr "“HashMap”未在序言中定义，因此需要纳入范围中。"

#: src/std-types/hashmap.md
msgid ""
"Try the following lines of code. The first line will see if a book is in the "
"hashmap and if not return an alternative value. The second line will insert "
"the alternative value in the hashmap if the book is not found."
msgstr ""
"请尝试使用以下代码行。第一行将查看图书是否在 hashmap 中；如果不在，则返回替代"
"值。如果未找到图书，第二行会在 hashmap 中插入替代值。"

#: src/std-types/hashmap.md
msgid "\"Harry Potter and the Sorcerer's Stone\""
msgstr "\"Harry Potter and the Sorcerer's Stone\""

#: src/std-types/hashmap.md
msgid "\"The Hunger Games\""
msgstr "\"The Hunger Games\""

#: src/std-types/hashmap.md
msgid "Unlike `vec!`, there is unfortunately no standard `hashmap!` macro."
msgstr "遗憾的是，与“vec!”不同，不存在标准的“hashmap!”宏。"

#: src/std-types/hashmap.md
msgid ""
"Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E), which allows "
"us to easily initialize a hash map from a literal array:"
msgstr ""
"不过，从 Rust 1.56 开始，HashMap 实现了[“From\\<\\[(K, V); N\\]\\>”](https://"
"doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-"
"From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E)，让我们能够轻松"
"地从字面量数组初始化哈希映射："

#: src/std-types/hashmap.md
msgid ""
"Alternatively HashMap can be built from any `Iterator` which yields key-"
"value tuples."
msgstr "或者，HashMap 也可以基于任何可生成键-值元组的“Iterator”进行构建。"

#: src/std-types/hashmap.md
msgid ""
"We are showing `HashMap<String, i32>`, and avoid using `&str` as key to make "
"examples easier. Using references in collections can, of course, be done, "
"but it can lead into complications with the borrow checker."
msgstr ""
"我们要展示“HashMap\\<String, i32>”，避免将“&str”用作键，以便简化示例。当然，"
"可以在集合中使用引用，但可能会导致借用检查器出现复杂问题。"

#: src/std-types/hashmap.md
msgid ""
"Try removing `to_string()` from the example above and see if it still "
"compiles. Where do you think we might run into issues?"
msgstr ""
"尝试从上述示例中移除“to_string()”，看看它是否仍可编译。您认为我们可能会在哪些"
"方面遇到问题？"

#: src/std-types/hashmap.md
msgid ""
"This type has several \"method-specific\" return types, such as `std::"
"collections::hash_map::Keys`. These types often appear in searches of the "
"Rust docs. Show students the docs for this type, and the helpful link back "
"to the `keys` method."
msgstr ""
"此类型具有几种特定于方法的返回值类型，例如“std::collections::hash_map::"
"Keys”。这些类型通常会出现在 Rust 文档的搜索结果中。向学员展示此类型的文档，以"
"及指向“keys”方法的实用链接。"

#: src/std-types/exercise.md
msgid ""
"In this exercise you will take a very simple data structure and make it "
"generic. It uses a [`std::collections::HashMap`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html) to keep track of which values "
"have been seen and how many times each one has appeared."
msgstr ""
"在本练习中，您将学习一个非常简单的数据结构，并将其变成泛型的。该结构使用 "
"[`std::collections::HashMap`](https://doc.rust-lang.org/stable/std/"
"collections/struct.HashMap.html) 来跟踪已经出现过的值以及每个值出现的次数。"

#: src/std-types/exercise.md
msgid ""
"The initial version of `Counter` is hard coded to only work for `u32` "
"values. Make the struct and its methods generic over the type of value being "
"tracked, that way `Counter` can track any type of value."
msgstr ""
"`Counter` 的初始版本经过硬编码，仅适用于 `u32` 值。使结构体及其方法可用于所跟"
"踪的值类型，以便 `Counter` 能够跟踪任何类型的值。"

#: src/std-types/exercise.md
msgid ""
"If you finish early, try using the [`entry`](https://doc.rust-lang.org/"
"stable/std/collections/struct.HashMap.html#method.entry) method to halve the "
"number of hash lookups required to implement the `count` method."
msgstr ""
"如果提前完成操作，请尝试使用 [`entry`](https://doc.rust-lang.org/stable/std/"
"collections/struct.HashMap.html#method.entry) 方法将哈希查找次数减半，从而实"
"现 `count` 方法。"

#: src/std-types/exercise.md src/std-types/solution.md
msgid ""
"/// Counter counts the number of times each value of type T has been seen.\n"
msgstr ""
"/// Counter counts the number of times each value of type T has been seen.\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "/// Create a new Counter.\n"
msgstr "/// Create a new Counter.\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "/// Count an occurrence of the given value.\n"
msgstr "/// Count an occurrence of the given value.\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "/// Return the number of times the given value has been seen.\n"
msgstr "/// Return the number of times the given value has been seen.\n"

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"saw {} values equal to {}\""
msgstr "\"saw {} values equal to {}\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"apple\""
msgstr "\"apple\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"orange\""
msgstr "\"orange\""

#: src/std-types/exercise.md src/std-types/solution.md
msgid "\"got {} apples\""
msgstr "\"got {} apples\""

#: src/std-traits.md
msgid "[Comparisons](./std-traits/comparisons.md) (10 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[Operators](./std-traits/operators.md) (10 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[From and Into](./std-traits/from-and-into.md) (10 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[Casting](./std-traits/casting.md) (5 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[Read and Write](./std-traits/read-and-write.md) (10 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[Default, struct update syntax](./std-traits/default.md) (5 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[Closures](./std-traits/closures.md) (20 minutes)"
msgstr ""

#: src/std-traits.md
msgid "[Exercise: ROT13](./std-traits/exercise.md) (30 minutes)"
msgstr ""

#: src/std-traits.md
msgid "This segment should take about 1 hour and 40 minutes"
msgstr ""

#: src/std-traits.md
msgid ""
"As with the standard-library types, spend time reviewing the documentation "
"for each trait."
msgstr "与标准库类型一样，请花些时间仔细阅读每个 trait 的文档。"

#: src/std-traits.md
msgid "This section is long. Take a break midway through."
msgstr "此部分内容较长。中途可休息一下。"

#: src/std-traits/comparisons.md
msgid ""
"These traits support comparisons between values. All traits can be derived "
"for types containing fields that implement these traits."
msgstr ""
"这些 trait 支持在值之间进行比较。对于包含实现这些 trait 的字段，可以派生所有"
"这些 trait。"

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`PartialEq` and `Eq`"
msgstr "`PartialEq` 和 `Eq`"

#: src/std-traits/comparisons.md
msgid ""
"`PartialEq` is a partial equivalence relation, with required method `eq` and "
"provided method `ne`. The `==` and `!=` operators will call these methods."
msgstr ""
"`PartialEq` 指部分等价关系，其中包含必需的方法 `eq` 和提供的方法 `ne`。`==` "
"和 `!=` 运算符会调用这些方法。"

#: src/std-traits/comparisons.md
#, fuzzy
msgid ""
"`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) "
"and implies `PartialEq`. Functions that require full equivalence will use "
"`Eq` as a trait bound."
msgstr ""
"`Eq` 指完全等价关系（具有自反性、对称性和传递性），并且隐含了 `PartialEq`。需"
"要完全等价的函数将使用 `Eq` 作为特征边界。"

#: src/std-traits/comparisons.md
#, fuzzy
msgid "`PartialOrd` and `Ord`"
msgstr "`PartialOrd` 和 `Ord`"

#: src/std-traits/comparisons.md
msgid ""
"`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is "
"used to implement the `<`, `<=`, `>=`, and `>` operators."
msgstr ""
"`PartialOrd` 定义了使用 `partial_cmp` 方法的部分排序。它用于实现 `<`、`<=`、"
"`>=` 和 `>` 运算符。"

#: src/std-traits/comparisons.md
msgid "`Ord` is a total ordering, with `cmp` returning `Ordering`."
msgstr "`Ord` 是总排序，其中 `cmp` 返回 `Ordering`。"

#: src/std-traits/comparisons.md
msgid ""
"`PartialEq` can be implemented between different types, but `Eq` cannot, "
"because it is reflexive:"
msgstr "`PartialEq` 可以在不同类型之间实现，但 `Eq` 不能，因为它具有自反性："

#: src/std-traits/comparisons.md
msgid ""
"In practice, it's common to derive these traits, but uncommon to implement "
"them."
msgstr "在实践中，派生这些 trait 很常见，但很少会实现它们。"

#: src/std-traits/operators.md
msgid ""
"Operator overloading is implemented via traits in [`std::ops`](https://doc."
"rust-lang.org/std/ops/index.html):"
msgstr ""
"运算符重载是通过 [`std::ops`](https://doc.rust-lang.org/std/ops/index.html) "
"中的特征实现的："

#: src/std-traits/operators.md
msgid "\"{:?} + {:?} = {:?}\""
msgstr "\"{:?} + {:?} = {:?}\""

#: src/std-traits/operators.md src/memory-management/drop.md
msgid "Discussion points:"
msgstr "讨论点："

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"You could implement `Add` for `&Point`. In which situations is that useful?"
msgstr "您可以针对 `&Point` 实现 `Add`。此做法在哪些情况下可派上用场？"

#: src/std-traits/operators.md
msgid ""
"Answer: `Add:add` consumes `self`. If type `T` for which you are overloading "
"the operator is not `Copy`, you should consider overloading the operator for "
"`&T` as well. This avoids unnecessary cloning on the call site."
msgstr ""
"回答：`Add:add` 会耗用 `self`。如果您的运算符重载对象 （即类型 `T`）不是 "
"`Copy`，建议您也为 `&T` 重载运算符。这可避免调用点上存在不必要的 克隆任务。"

#: src/std-traits/operators.md
msgid ""
"Why is `Output` an associated type? Could it be made a type parameter of the "
"method?"
msgstr "为什么 `Output` 是关联类型？可将它用作该方法的类型形参吗？"

#: src/std-traits/operators.md
#, fuzzy
msgid ""
"Short answer: Function type parameters are controlled by the caller, but "
"associated types (like `Output`) are controlled by the implementer of a "
"trait."
msgstr ""
"简答：函数类型形参是由调用方控管，但 `Output` 这类关联类型则由特征实现人员 控"
"管。"

#: src/std-traits/operators.md
msgid ""
"You could implement `Add` for two different types, e.g. `impl Add<(i32, "
"i32)> for Point` would add a tuple to a `Point`."
msgstr ""
"您可以针对两种不同类型实现 `Add`，例如， `impl Add<(i32, i32)> for Point` 会"
"向 `Point` 中添加元组。"

#: src/std-traits/from-and-into.md
msgid ""
"Types implement [`From`](https://doc.rust-lang.org/std/convert/trait.From."
"html) and [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) to "
"facilitate type conversions:"
msgstr ""
"类型会实现 [`From`](https://doc.rust-lang.org/std/convert/trait.From.html) "
"和 [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) 以加快类型"
"转换："

#: src/std-traits/from-and-into.md
msgid "\"{s}, {addr}, {one}, {bigger}\""
msgstr "\"{s}, {addr}, {one}, {bigger}\""

#: src/std-traits/from-and-into.md
msgid ""
"[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) is "
"automatically implemented when [`From`](https://doc.rust-lang.org/std/"
"convert/trait.From.html) is implemented:"
msgstr ""
"实现 [`From`](https://doc.rust-lang.org/std/convert/trait.From.html) 后，系统"
"会自动实现 [`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html)："

#: src/std-traits/from-and-into.md
msgid ""
"That's why it is common to only implement `From`, as your type will get "
"`Into` implementation too."
msgstr "这就是为什么通常只需实现 `From`，因为您的类型也会实现 `Into`。"

#: src/std-traits/from-and-into.md
msgid ""
"When declaring a function argument input type like \"anything that can be "
"converted into a `String`\", the rule is opposite, you should use `Into`. "
"Your function will accept types that implement `From` and those that _only_ "
"implement `Into`."
msgstr ""
"若要声明某个函数实参输入类型（例如“任何可转换成 `String` 的类型”），规则便会"
"相反，此时应使用 `Into`。 您的函数会接受可实现 `From` 的类型，以及那些仅实现 "
"`Into` 的类型。"

#: src/std-traits/casting.md
msgid ""
"Rust has no _implicit_ type conversions, but does support explicit casts "
"with `as`. These generally follow C semantics where those are defined."
msgstr ""
"Rust 不支持 _implicit_ 类型转换，但支持使用 `as` 进行显式转换。这些转换通常遵"
"循定义它们的 C 语义。"

#: src/std-traits/casting.md
msgid "\"as u16: {}\""
msgstr "\"as u16: {}\""

#: src/std-traits/casting.md
msgid "\"as i16: {}\""
msgstr "\"as i16: {}\""

#: src/std-traits/casting.md
msgid "\"as u8: {}\""
msgstr "\"as u8: {}\""

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"The results of `as` are _always_ defined in Rust and consistent across "
"platforms. This might not match your intuition for changing sign or casting "
"to a smaller type -- check the docs, and comment for clarity."
msgstr ""
"使用 `as` 的结果在 Rust 中 _始终_ 定义明确，并且在不同平台上保持一致。这可能"
"不符合您对于更改符号或转换为更小类型的直观理解。为清晰起见，请查看文档和注"
"释。"

#: src/std-traits/casting.md
msgid ""
"Casting with `as` is a relatively sharp tool that is easy to use "
"incorrectly, and can be a source of subtle bugs as future maintenance work "
"changes the types that are used or the ranges of values in types. Casts are "
"best used only when the intent is to indicate unconditional truncation (e.g. "
"selecting the bottom 32 bits of a `u64` with `as u32`, regardless of what "
"was in the high bits)."
msgstr ""

#: src/std-traits/casting.md
msgid ""
"For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` "
"over `as` to confirm that the cast is in fact infallible. For fallible "
"casts, `TryFrom` and `TryInto` are available when you want to handle casts "
"that fit differently from those that don't."
msgstr ""

#: src/std-traits/casting.md
msgid "Consider taking a break after this slide."
msgstr "请在这张幻灯片之后休息一下。"

#: src/std-traits/casting.md
#, fuzzy
msgid ""
"`as` is similar to a C++ static cast. Use of `as` in cases where data might "
"be lost is generally discouraged, or at least deserves an explanatory "
"comment."
msgstr ""
"`as` 类似于 C++ 静态类型转换。通常不建议在可能丢失数据的情况下使用 `as`，或者"
"至少应该添加说明性注释。"

#: src/std-traits/casting.md
msgid "This is common in casting integers to `usize` for use as an index."
msgstr "在将整数类型转换为 `usize` 以用作索引时，这很常见。"

#: src/std-traits/read-and-write.md
msgid ""
"Using [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html), you can "
"abstract over `u8` sources:"
msgstr ""
"您可以使用 [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) 和 "
"[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html) 对 `u8` 来源"
"进行抽象化处理："

#: src/std-traits/read-and-write.md
msgid "b\"foo\\nbar\\nbaz\\n\""
msgstr "b\"foo\\nbar\\nbaz\\n\""

#: src/std-traits/read-and-write.md
msgid "\"lines in slice: {}\""
msgstr "\"lines in slice: {}\""

#: src/std-traits/read-and-write.md
msgid "\"lines in file: {}\""
msgstr "\"lines in file: {}\""

#: src/std-traits/read-and-write.md
msgid ""
"Similarly, [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) lets "
"you abstract over `u8` sinks:"
msgstr ""
"您同样可使用 [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) 对 "
"`u8` 接收器进行抽象化处理："

#: src/std-traits/read-and-write.md
msgid "\"\\n\""
msgstr "\"\\n\""

#: src/std-traits/read-and-write.md src/slices-and-lifetimes/str.md
#, fuzzy
msgid "\"World\""
msgstr "\"World\""

#: src/std-traits/read-and-write.md
msgid "\"Logged: {:?}\""
msgstr "\"Logged: {:?}\""

#: src/std-traits/default.md
msgid "The `Default` Trait"
msgstr "`Default` 特征"

#: src/std-traits/default.md
msgid ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait "
"produces a default value for a type."
msgstr ""
"[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) 特征会"
"为类型生成默认值。"

#: src/std-traits/default.md
msgid "\"John Smith\""
msgstr "\"John Smith\""

#: src/std-traits/default.md
msgid "\"{default_struct:#?}\""
msgstr "\"{default_struct:#?}\""

#: src/std-traits/default.md
msgid "\"Y is set!\""
msgstr "\"Y is set!\""

#: src/std-traits/default.md
msgid "\"{almost_default_struct:#?}\""
msgstr "\"{almost_default_struct:#?}\""

#: src/std-traits/default.md src/slices-and-lifetimes/exercise.md
#: src/slices-and-lifetimes/solution.md
msgid "\"{:#?}\""
msgstr "\"{:#?}\""

#: src/std-traits/default.md
msgid ""
"It can be implemented directly or it can be derived via `#[derive(Default)]`."
msgstr "系统可以直接实现它，也可以通过 `#[derive(Default)]` 派生出它。"

#: src/std-traits/default.md
#, fuzzy
msgid ""
"A derived implementation will produce a value where all fields are set to "
"their default values."
msgstr "派生的实现会生成一个实例，其中字段全都设为其默认值。"

#: src/std-traits/default.md
msgid "This means all types in the struct must implement `Default` too."
msgstr "这意味着，该结构体中的所有类型也都必须实现 `Default`。"

#: src/std-traits/default.md
msgid ""
"Standard Rust types often implement `Default` with reasonable values (e.g. "
"`0`, `\"\"`, etc)."
msgstr ""
"标准的 Rust 类型通常会以合理的值（例如 ` 0`\"\" \\``等）实现`Default\\`。"

#: src/std-traits/default.md
#, fuzzy
msgid "The partial struct initialization works nicely with default."
msgstr "部分结构体副本可与默认值完美搭配运作。"

#: src/std-traits/default.md
#, fuzzy
msgid ""
"The Rust standard library is aware that types can implement `Default` and "
"provides convenience methods that use it."
msgstr "Rust 标准库了解类型可能会实现 `Default`，因此提供了便利的使用方式。"

#: src/std-traits/default.md
#, fuzzy
msgid ""
"The `..` syntax is called [struct update syntax](https://doc.rust-lang.org/"
"book/ch05-01-defining-structs.html#creating-instances-from-other-instances-"
"with-struct-update-syntax)."
msgstr ""
"“..”语法被称为[结构体更新语法](https://doc.rust-lang.org/book/ch05-01-"
"defining-structs.html#creating-instances-from-other-instances-with-struct-"
"update-syntax)"

#: src/std-traits/closures.md
msgid ""
"Closures or lambda expressions have types which cannot be named. However, "
"they implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn."
"html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and "
"[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:"
msgstr ""
"闭包或 lambda 表达式具有无法命名的类型。不过，它们会 实现特殊的 [`Fn`]"
"(https://doc.rust-lang.org/std/ops/trait.Fn.html)， [`FnMut`](https://doc."
"rust-lang.org/std/ops/trait.FnMut.html) 和 [`FnOnce`](https://doc.rust-lang."
"org/std/ops/trait.FnOnce.html) 特征："

#: src/std-traits/closures.md
#, fuzzy
msgid "\"Calling function on {input}\""
msgstr "调用 Unsafe 函数"

#: src/std-traits/closures.md
msgid "\"add_3: {}\""
msgstr "\"add_3: {}\""

#: src/std-traits/closures.md
msgid "\"accumulate: {}\""
msgstr "\"accumulate: {}\""

#: src/std-traits/closures.md
msgid "\"multiply_sum: {}\""
msgstr "\"multiply_sum: {}\""

#: src/std-traits/closures.md
msgid ""
"An `Fn` (e.g. `add_3`) neither consumes nor mutates captured values, or "
"perhaps captures nothing at all. It can be called multiple times "
"concurrently."
msgstr ""
"`Fn`（例如 `add_3`）既不会耗用也不会修改捕获的值，或许 也不会捕获任何值。它可"
"被并发调用多次。"

#: src/std-traits/closures.md
msgid ""
"An `FnMut` (e.g. `accumulate`) might mutate captured values. You can call it "
"multiple times, but not concurrently."
msgstr ""
"`FnMut`（例如 `accumulate`）可能会改变捕获的值。您可以多次调用它， 但不能并发"
"调用它。"

#: src/std-traits/closures.md
msgid ""
"If you have an `FnOnce` (e.g. `multiply_sum`), you may only call it once. It "
"might consume captured values."
msgstr ""
"如果您使用 `FnOnce`（例如 `multiply_sum`），或许只能调用它一次。它可能会耗用 "
"所捕获的值。"

#: src/std-traits/closures.md
msgid ""
"`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`. "
"I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can "
"use an `Fn` wherever an `FnMut` or `FnOnce` is called for."
msgstr ""
"`FnMut` 是 `FnOnce` 的子类型。`Fn` 是 `FnMut` 和 `FnOnce` 的子类型。也就是"
"说，您可以在任何 需要调用 `FnOnce` 的地方使用 `FnMut`，还可在任何需要调用 "
"`FnMut` 或 `FnOnce` 的地方 使用 `Fn`。"

#: src/std-traits/closures.md
msgid ""
"When you define a function that takes a closure, you should take `FnOnce` if "
"you can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows "
"the most flexibility for the caller."
msgstr ""

#: src/std-traits/closures.md
msgid ""
"In contrast, when you have a closure, the most flexible you can have is `Fn` "
"(it can be passed everywhere), then `FnMut`, and lastly `FnOnce`."
msgstr ""

#: src/std-traits/closures.md
msgid ""
"The compiler also infers `Copy` (e.g. for `add_3`) and `Clone` (e.g. "
"`multiply_sum`), depending on what the closure captures."
msgstr ""
"编译器也会推断 `Copy`（例如针对 `add_3`）和 `Clone`（例如 `multiply_sum`）， "
"具体取决于闭包捕获的数据。"

#: src/std-traits/closures.md
msgid ""
"By default, closures will capture by reference if they can. The `move` "
"keyword makes them capture by value."
msgstr ""
"默认情况下，闭包会依据引用来捕获数据（如果可以的话）。`move` 关键字则可让闭包"
"依据值 来捕获数据。"

#: src/std-traits/closures.md src/smart-pointers/trait-objects.md
msgid "\"{} {}\""
msgstr "\"{} {}\""

#: src/std-traits/closures.md
msgid "\"Hi\""
msgstr "\"Hi\""

#: src/std-traits/closures.md
msgid "\"there\""
msgstr "\"there\""

#: src/std-traits/exercise.md
msgid ""
"In this example, you will implement the classic [\"ROT13\" cipher](https://"
"en.wikipedia.org/wiki/ROT13). Copy this code to the playground, and "
"implement the missing bits. Only rotate ASCII alphabetic characters, to "
"ensure the result is still valid UTF-8."
msgstr ""
"在此示例中，您将实现经典的 [“ROT13”加密](https://en.wikipedia.org/wiki/"
"ROT13)。将此代码复制到 Playground，并实现缺失的位。请仅旋转 ASCII 字母字符，"
"以确保结果仍为有效的 UTF-8 编码字符。"

#: src/std-traits/exercise.md
msgid "// Implement the `Read` trait for `RotDecoder`.\n"
msgstr "// Implement the `Read` trait for `RotDecoder`.\n"

#: src/std-traits/exercise.md src/std-traits/solution.md
msgid "\"Gb trg gb gur bgure fvqr!\""
msgstr "\"Gb trg gb gur bgure fvqr!\""

#: src/std-traits/exercise.md src/std-traits/solution.md
#: src/smart-pointers/trait-objects.md src/modules/exercise.md
#: src/modules/solution.md src/android/build-rules/library.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/async/pitfalls/cancellation.md
msgid "\"{}\""
msgstr "\"{}\""

#: src/std-traits/exercise.md src/std-traits/solution.md
msgid "\"To get to the other side!\""
msgstr "\"To get to the other side!\""

#: src/std-traits/exercise.md
msgid ""
"What happens if you chain two `RotDecoder` instances together, each rotating "
"by 13 characters?"
msgstr ""
"如果将两个 `RotDecoder` 实例链接在一起，每个实例旋转 13 个字符，会发生什么情"
"况？"

#: src/std-traits/solution.md
msgid "'A'"
msgstr "'A'"

#: src/welcome-day-3.md
msgid "Welcome to Day 3"
msgstr "欢迎参加第 3 天的课程"

#: src/welcome-day-3.md
msgid "Today, we will cover:"
msgstr "今日内容："

#: src/welcome-day-3.md
msgid ""
"Memory management, lifetimes, and the borrow checker: how Rust ensures "
"memory safety."
msgstr "内存管理、生命周期和借用检查器：Rust 如何确保内存安全。"

#: src/welcome-day-3.md
msgid "Smart pointers: standard library pointer types."
msgstr "智能指针：标准库指针类型。"

#: src/welcome-day-3.md
msgid "[Welcome](./welcome-day-3.md) (3 minutes)"
msgstr ""

#: src/welcome-day-3.md
msgid "[Memory Management](./memory-management.md) (1 hour and 10 minutes)"
msgstr ""

#: src/welcome-day-3.md
msgid "[Smart Pointers](./smart-pointers.md) (55 minutes)"
msgstr ""

#: src/welcome-day-3.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 25 "
"minutes"
msgstr ""

#: src/memory-management.md
msgid "[Review of Program Memory](./memory-management/review.md) (5 minutes)"
msgstr ""

#: src/memory-management.md
msgid ""
"[Approaches to Memory Management](./memory-management/approaches.md) (10 "
"minutes)"
msgstr ""

#: src/memory-management.md
msgid "[Ownership](./memory-management/ownership.md) (5 minutes)"
msgstr ""

#: src/memory-management.md
msgid "[Move Semantics](./memory-management/move.md) (10 minutes)"
msgstr ""

#: src/memory-management.md
msgid "[Clone](./memory-management/clone.md) (2 minutes)"
msgstr ""

#: src/memory-management.md
msgid "[Copy Types](./memory-management/copy-types.md) (5 minutes)"
msgstr ""

#: src/memory-management.md
msgid "[Drop](./memory-management/drop.md) (10 minutes)"
msgstr ""

#: src/memory-management.md
msgid "[Exercise: Builder Type](./memory-management/exercise.md) (20 minutes)"
msgstr ""

#: src/memory-management/review.md
msgid "Programs allocate memory in two ways:"
msgstr "程序通过以下两种方式分配内存："

#: src/memory-management/review.md
msgid "Stack: Continuous area of memory for local variables."
msgstr "栈：局部变量的连续内存区域。"

#: src/memory-management/review.md
msgid "Values have fixed sizes known at compile time."
msgstr "值在编译时具有已知的固定大小。"

#: src/memory-management/review.md
msgid "Extremely fast: just move a stack pointer."
msgstr "速度极快：只需移动一个栈指针。"

#: src/memory-management/review.md
msgid "Easy to manage: follows function calls."
msgstr "易于管理：遵循函数调用规则。"

#: src/memory-management/review.md
msgid "Great memory locality."
msgstr "优秀的内存局部性。"

#: src/memory-management/review.md
msgid "Heap: Storage of values outside of function calls."
msgstr "堆：函数调用之外的值的存储。"

#: src/memory-management/review.md
msgid "Values have dynamic sizes determined at runtime."
msgstr "值具有动态大小，具体大小需在运行时确定。"

#: src/memory-management/review.md
msgid "Slightly slower than the stack: some book-keeping needed."
msgstr "比栈稍慢：需要向系统申请空间。"

#: src/memory-management/review.md
msgid "No guarantee of memory locality."
msgstr "不保证内存局部性。"

#: src/memory-management/review.md
#, fuzzy
msgid ""
"Creating a `String` puts fixed-sized metadata on the stack and dynamically "
"sized data, the actual string, on the heap:"
msgstr ""
"创建 `String` 时将固定大小的数据存储在栈上， 并将动态大小的数据存储在堆上："

#: src/memory-management/review.md
msgid ""
"Mention that a `String` is backed by a `Vec`, so it has a capacity and "
"length and can grow if mutable via reallocation on the heap."
msgstr ""
"指出 `String` 底层由 `Vec` 实现，因此它具有容量和长度，如果值可变，则可以通过"
"在堆上重新分配存储空间进行增长。"

#: src/memory-management/review.md
msgid ""
"If students ask about it, you can mention that the underlying memory is heap "
"allocated using the [System Allocator](https://doc.rust-lang.org/std/alloc/"
"struct.System.html) and custom allocators can be implemented using the "
"[Allocator API](https://doc.rust-lang.org/std/alloc/index.html)"
msgstr ""
"如果学员提出相关问题，你可以提及我们不仅能使用\\[系统分配器\\]在堆上分配底层"
"内存，还能使用 [Allocator API](https://doc.rust-lang.org/std/alloc/index."
"html) 实现自定义分配器"

#: src/memory-management/review.md
#, fuzzy
msgid ""
"We can inspect the memory layout with `unsafe` Rust. However, you should "
"point out that this is rightfully unsafe!"
msgstr ""
"我们可以使用 `unsafe` 代码检查内存布局。不过，你应该指出，这种做法不安全！"

#: src/memory-management/review.md src/testing/unit-tests.md
msgid "' '"
msgstr "' '"

#: src/memory-management/review.md
#, fuzzy
msgid "\"world\""
msgstr "\"world\""

#: src/memory-management/review.md
msgid ""
"// DON'T DO THIS AT HOME! For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"
msgstr ""
"// DON'T DO THIS AT HOME!For educational purposes only.\n"
"    // String provides no guarantees about its layout, so this could lead "
"to\n"
"    // undefined behavior.\n"

#: src/memory-management/review.md
msgid "\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\""
msgstr "\"ptr = {ptr:#x}, len = {len}, capacity = {capacity}\""

#: src/memory-management/approaches.md
msgid "Traditionally, languages have fallen into two broad categories:"
msgstr "传统上，语言分为两大类："

#: src/memory-management/approaches.md
msgid "Full control via manual memory management: C, C++, Pascal, ..."
msgstr "通过手动内存管理实现完全控制：C、C++、Pascal…"

#: src/memory-management/approaches.md
msgid "Programmer decides when to allocate or free heap memory."
msgstr "程序员决定何时分配或释放堆内存。"

#: src/memory-management/approaches.md
msgid ""
"Programmer must determine whether a pointer still points to valid memory."
msgstr "程序员必须确定指针是否仍指向有效内存。"

#: src/memory-management/approaches.md
msgid "Studies show, programmers make mistakes."
msgstr "研究表明，程序员难免会犯错。"

#: src/memory-management/approaches.md
msgid ""
"Full safety via automatic memory management at runtime: Java, Python, Go, "
"Haskell, ..."
msgstr "运行时通过自动内存管理实现完全安全：Java、Python、Go、Haskell…"

#: src/memory-management/approaches.md
msgid ""
"A runtime system ensures that memory is not freed until it can no longer be "
"referenced."
msgstr "运行时系统可确保在内存无法被引用之前，不会释放该内存。"

#: src/memory-management/approaches.md
msgid ""
"Typically implemented with reference counting, garbage collection, or RAII."
msgstr "通常通过引用计数、垃圾回收或 RAII 实现。"

#: src/memory-management/approaches.md
msgid "Rust offers a new mix:"
msgstr "Rust 提供了一个全新的组合："

#: src/memory-management/approaches.md
msgid ""
"Full control _and_ safety via compile time enforcement of correct memory "
"management."
msgstr "通过编译时强制执行正确的内存>管理来实现完全控制与安全。"

#: src/memory-management/approaches.md
msgid "It does this with an explicit ownership concept."
msgstr "它通过一个明确的所有权（ownership）概念来实现此目的。"

#: src/memory-management/approaches.md
msgid ""
"This slide is intended to help students coming from other languages to put "
"Rust in context."
msgstr "本幻灯片旨在帮助学习其他语言的学生更好地了解 Rust。"

#: src/memory-management/approaches.md
msgid ""
"C must manage heap manually with `malloc` and `free`. Common errors include "
"forgetting to call `free`, calling it multiple times for the same pointer, "
"or dereferencing a pointer after the memory it points to has been freed."
msgstr ""
"C 语言必须使用 `malloc` 和 `free` 函数手动管理堆。常见错误包括忘记调用 "
"`free`、针对同一指针多次调用它，或在释放某指针所指向的内存后解引用它。"

#: src/memory-management/approaches.md
msgid ""
"C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take "
"advantage of language guarantees about calling destructors to ensure memory "
"is freed when a function returns. It is still quite easy to mis-use these "
"tools and create similar bugs to C."
msgstr ""
"C++ 具有智能指针（`unique_ptr`、`shared_ptr`）等工具，可以利用与调用析构函数"
"相关的语言保证来确保在函数返回时释放内存。这些工具仍然很容易被滥用并导致与 C "
"语言类似的 bug。"

#: src/memory-management/approaches.md
msgid ""
"Java, Go, and Python rely on the garbage collector to identify memory that "
"is no longer reachable and discard it. This guarantees that any pointer can "
"be dereferenced, eliminating use-after-free and other classes of bugs. But, "
"GC has a runtime cost and is difficult to tune properly."
msgstr ""
"Java、Go 和 Python 依赖垃圾回收器来识别无法再访问的内存并将其舍弃。这保证可对"
"所有指针进行解引用操作，从而消除了释放后使用等各类 bug。但是，垃圾回收 (GC) "
"会产生运行时成本，并且很难进行适当调优。"

#: src/memory-management/approaches.md
msgid ""
"Rust's ownership and borrowing model can, in many cases, get the performance "
"of C, with alloc and free operations precisely where they are required -- "
"zero cost. It also provides tools similar to C++'s smart pointers. When "
"required, other options such as reference counting are available, and there "
"are even third-party crates available to support runtime garbage collection "
"(not covered in this class)."
msgstr ""
"在许多情况下，Rust 的所有权和借用模型可以实现 C 语言的性能，能够精确地在所需"
"位置执行分配和释放操作，且为零成本。它还提供类似于 C++ 智能指针的工具。必要"
"时，它还提供引用计数等其他选项，甚至还有第三方 crate 可以支持运行时垃圾回收"
"（本课程中不作介绍）。"

#: src/memory-management/ownership.md
msgid ""
"All variable bindings have a _scope_ where they are valid and it is an error "
"to use a variable outside its scope:"
msgstr "所有变量绑定都有一个有效的“作用域”，使用 超出其作用域的变量是错误的："

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"We say that the variable _owns_ the value. Every Rust value has precisely "
"one owner at all times."
msgstr "指出变量“拥有”值。"

#: src/memory-management/ownership.md
#, fuzzy
msgid ""
"At the end of the scope, the variable is _dropped_ and the data is freed. A "
"destructor can run here to free up resources."
msgstr "作用域结束时，变量会“被丢弃”，数据会被释放。"

#: src/memory-management/ownership.md
msgid ""
"Students familiar with garbage-collection implementations will know that a "
"garbage collector starts with a set of \"roots\" to find all reachable "
"memory. Rust's \"single owner\" principle is a similar idea."
msgstr ""
"熟悉垃圾回收实现的学生知道，垃圾回收器从一组 “根”开始查找所有可访问内存。"
"Rust 的 “单一所有者”原则与此类似。"

#: src/memory-management/move.md
#, fuzzy
msgid "An assignment will transfer _ownership_ between variables:"
msgstr "赋值操作将在变量之间转移所有权："

#: src/memory-management/move.md
#, fuzzy
msgid "\"Hello!\""
msgstr "b\"Hello!\""

#: src/memory-management/move.md src/slices-and-lifetimes/str.md
msgid "\"s2: {s2}\""
msgstr "\"s2: {s2}\""

#: src/memory-management/move.md
msgid "// println!(\"s1: {s1}\");\n"
msgstr "// println!(\"s1: {s1}\");\n"

#: src/memory-management/move.md
msgid "The assignment of `s1` to `s2` transfers ownership."
msgstr "将 `s1` 赋值给 `s2`，即转移了所有权。"

#: src/memory-management/move.md
#, fuzzy
msgid "When `s1` goes out of scope, nothing happens: it does not own anything."
msgstr "当 `s1` 离开作用域时，什么都不会发生：它没有所有权。"

#: src/memory-management/move.md
msgid "When `s2` goes out of scope, the string data is freed."
msgstr "当 `s2` 离开作用域时，字符串数据被释放。"

#: src/memory-management/move.md
msgid "Before move to `s2`:"
msgstr "移动到 `s2` 中之前："

#: src/memory-management/move.md
msgid "After move to `s2`:"
msgstr "移动到 `s2` 中之后："

#: src/memory-management/move.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"(inaccessible)\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" 栈                           堆\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                         :     :                                             :\n"
":    "
"list                 :     :                                             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":   | 1  | o--+-----------+-----+--->| 2  | o--+--->| // | null "
"|             :\n"
":   +----+----+           :     :    +----+----+    +----+------"
"+             :\n"
":                         :     :                                             :\n"
":                         :     :                                             :\n"
"`- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"

#: src/memory-management/move.md
msgid ""
"When you pass a value to a function, the value is assigned to the function "
"parameter. This transfers ownership:"
msgstr "你将值传递给函数时，该值会被赋给函数 参数。这就转移了所有权："

#: src/memory-management/move.md
#, fuzzy
msgid "\"Hello {name}\""
msgstr "\"Hello {name}\""

#: src/memory-management/move.md src/android/interoperability/java.md
#, fuzzy
msgid "\"Alice\""
msgstr "切片"

#: src/memory-management/move.md
msgid "// say_hello(name);\n"
msgstr "// say_hello(name);\n"

#: src/memory-management/move.md
msgid ""
"Mention that this is the opposite of the defaults in C++, which copies by "
"value unless you use `std::move` (and the move constructor is defined!)."
msgstr ""
"指出这与 C++ 中的默认值相反。除非你使用 `std::move`（并已定义 move 构造函"
"数！），否则 C++ 中的默认值是按值复制的。"

#: src/memory-management/move.md
msgid ""
"It is only the ownership that moves. Whether any machine code is generated "
"to manipulate the data itself is a matter of optimization, and such copies "
"are aggressively optimized away."
msgstr ""
"只有所有权发生了转移。是否会生成任何机器码来操控数据本身是一个优化方面的问"
"题，系统会主动优化此类副本。"

#: src/memory-management/move.md
msgid ""
"Simple values (such as integers) can be marked `Copy` (see later slides)."
msgstr "简单的值（例如整数）可以标记为“Copy”（请看后续幻灯片）。"

#: src/memory-management/move.md
msgid "In Rust, clones are explicit (by using `clone`)."
msgstr "在 Rust 中，克隆是显式的（通过使用 `clone`）。"

#: src/memory-management/move.md
msgid "In the `say_hello` example:"
msgstr "在 `say_hello` 示例中："

#: src/memory-management/move.md
msgid ""
"With the first call to `say_hello`, `main` gives up ownership of `name`. "
"Afterwards, `name` cannot be used anymore within `main`."
msgstr ""
"首次调用 `say_hello` 时，`main` 便放弃了 `name` 的所有权。此后，`main` 中不能"
"再使用 `name`。"

#: src/memory-management/move.md
msgid ""
"The heap memory allocated for `name` will be freed at the end of the "
"`say_hello` function."
msgstr "在 `say_hello` 函数结束时，系统会释放为 `name` 分配的堆内存。"

#: src/memory-management/move.md
msgid ""
"`main` can retain ownership if it passes `name` as a reference (`&name`) and "
"if `say_hello` accepts a reference as a parameter."
msgstr ""
"如果 `main` 将 `name` 作为引用 (`&name`) 传递过去，且 `say_hello` 接受作为参"
"数的引用，则可保留所有权。"

#: src/memory-management/move.md
msgid ""
"Alternatively, `main` can pass a clone of `name` in the first call (`name."
"clone()`)."
msgstr "此外，`main` 也可以在首次调用时传递 `name` 的克隆 (`name.clone()`)。"

#: src/memory-management/move.md
msgid ""
"Rust makes it harder than C++ to inadvertently create copies by making move "
"semantics the default, and by forcing programmers to make clones explicit."
msgstr ""
"相较于 C++，Rust 通过将移动语义设为默认值，并强制程序员进行显式克隆，更难以无"
"意中创建副本。"

#: src/memory-management/move.md
#, fuzzy
msgid "Defensive Copies in Modern C++"
msgstr "现代 C++ 中的双重释放"

#: src/memory-management/move.md
msgid "Modern C++ solves this differently:"
msgstr "现代 C++ 以不同的方式解决此问题："

#: src/memory-management/move.md
msgid "\"Cpp\""
msgstr "\"Cpp\""

#: src/memory-management/move.md
msgid "// Duplicate the data in s1.\n"
msgstr "// Duplicate the data in s1.\n"

#: src/memory-management/move.md
msgid ""
"The heap data from `s1` is duplicated and `s2` gets its own independent copy."
msgstr "`s1` 中的堆数据被复制，`s2` 获得自己的独立副本。"

#: src/memory-management/move.md
msgid "When `s1` and `s2` go out of scope, they each free their own memory."
msgstr "当 `s1` 和 `s2` 离开作用域时，它们会各自释放自己的内存。"

#: src/memory-management/move.md
msgid "Before copy-assignment:"
msgstr "复制-赋值之前："

#: src/memory-management/move.md
msgid "After copy-assignment:"
msgstr "复制-赋值之后："

#: src/memory-management/move.md
msgid ""
"C++ has made a slightly different choice than Rust. Because `=` copies data, "
"the string data has to be cloned. Otherwise we would get a double-free when "
"either string goes out of scope."
msgstr ""
"C++ 做出了与 Rust 略有不同的选择。由于“=”会复制数据，因此必须克隆字符串数据。"
"否则，当任一字符串超出范围时，便会出现二次释放。"

#: src/memory-management/move.md
msgid ""
"C++ also has [`std::move`](https://en.cppreference.com/w/cpp/utility/move), "
"which is used to indicate when a value may be moved from. If the example had "
"been `s2 = std::move(s1)`, no heap allocation would take place. After the "
"move, `s1` would be in a valid but unspecified state. Unlike Rust, the "
"programmer is allowed to keep using `s1`."
msgstr ""
"C++ 还包含[“std::move”](https://en.cppreference.com/w/cpp/utility/move)，它用"
"于指示何时可以移动某个值。如果示例为“s2 = std::move(s1)”，则不会发生堆分配。"
"移动后，“s1”将处于有效但未指定的状态。与 Rust 不同，程序员可以继续使用“s1”。"

#: src/memory-management/move.md
msgid ""
"Unlike Rust, `=` in C++ can run arbitrary code as determined by the type "
"which is being copied or moved."
msgstr ""
"与 Rust 不同，使用 C++ 时，“=”可以运行任意代码，具体取决于要复制或移动的类"
"型。"

#: src/memory-management/clone.md
msgid "Clone"
msgstr "克隆"

#: src/memory-management/clone.md
msgid ""
"Sometimes you _want_ to make a copy of a value. The `Clone` trait "
"accomplishes this."
msgstr "有时，_如需_ 复制某个值。`Clone` 特征 可以完成此操作。"

#: src/memory-management/clone.md
msgid ""
"The idea of `Clone` is to make it easy to spot where heap allocations are "
"occurring. Look for `.clone()` and a few others like `Vec::new` or `Box::"
"new`."
msgstr ""
"`Clone` 的设计理念是让您轻松发现堆分配的位置。查找 `.clone()` 和其他一些内"
"容，例如 `Vec::new` 或 `Box::new`。"

#: src/memory-management/clone.md
msgid ""
"It's common to \"clone your way out\" of problems with the borrow checker, "
"and return later to try to optimize those clones away."
msgstr ""
"通常的做法是，先使用 “克隆操作”解决借用检查器问题，在后续通过优化消除这些克隆"
"操作。"

#: src/memory-management/copy-types.md
msgid ""
"While move semantics are the default, certain types are copied by default:"
msgstr "虽然移动语义是默认的，但默认情况下会复制某些类型："

#: src/memory-management/copy-types.md
msgid "These types implement the `Copy` trait."
msgstr "这些类型实现了 `Copy` trait。"

#: src/memory-management/copy-types.md
msgid "You can opt-in your own types to use copy semantics:"
msgstr "你可以选择自己的类型来使用复制语义："

#: src/memory-management/copy-types.md
msgid "After the assignment, both `p1` and `p2` own their own data."
msgstr "赋值之后，`p1` 和 `p2` 都拥有自己的数据。"

#: src/memory-management/copy-types.md
msgid "We can also use `p1.clone()` to explicitly copy the data."
msgstr "我们还可以使用 `p1.clone()` 显式复制数据。"

#: src/memory-management/copy-types.md
msgid "Copying and cloning are not the same thing:"
msgstr "复制和克隆是两码事："

#: src/memory-management/copy-types.md
msgid ""
"Copying refers to bitwise copies of memory regions and does not work on "
"arbitrary objects."
msgstr "复制是指内存区域的按位复制，不适用于任意对象。"

#: src/memory-management/copy-types.md
msgid ""
"Copying does not allow for custom logic (unlike copy constructors in C++)."
msgstr "复制不允许自定义逻辑（不同于 C++ 中的复制构造函数）。"

#: src/memory-management/copy-types.md
msgid ""
"Cloning is a more general operation and also allows for custom behavior by "
"implementing the `Clone` trait."
msgstr "克隆是一种更通用的操作，也允许通过实现 `Clone` trait 来自定义行为。"

#: src/memory-management/copy-types.md
msgid "Copying does not work on types that implement the `Drop` trait."
msgstr "复制不适用于实现 `Drop` trait 的类型。"

#: src/memory-management/copy-types.md
msgid "In the above example, try the following:"
msgstr "在上述示例中，请尝试以下操作："

#: src/memory-management/copy-types.md
msgid ""
"Add a `String` field to `struct Point`. It will not compile because `String` "
"is not a `Copy` type."
msgstr ""
"在 `struct Point` 中添加 `String` 字段。由于 `String` 不属于 `Copy` 类型，因"
"此无法编译。"

#: src/memory-management/copy-types.md
#, fuzzy
msgid ""
"Remove `Copy` from the `derive` attribute. The compiler error is now in the "
"`println!` for `p1`."
msgstr ""
"从 `derive` 属性中移除 `Copy`。现在，编译器错误位于 `p1`的 `println!` 中。"

#: src/memory-management/copy-types.md
msgid "Show that it works if you clone `p1` instead."
msgstr "指出如果你改为克隆 `p1`，则可按预期运行。"

#: src/memory-management/drop.md
msgid "The `Drop` Trait"
msgstr "`Drop` 特征"

#: src/memory-management/drop.md
msgid ""
"Values which implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop."
"html) can specify code to run when they go out of scope:"
msgstr ""
"用于实现 [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) 的值可以"
"指定在超出范围时运行的代码："

#: src/memory-management/drop.md
msgid "\"Dropping {}\""
msgstr "\"Dropping {}\""

#: src/memory-management/drop.md src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"a\""
msgstr "\"a\""

#: src/memory-management/drop.md src/testing/googletest.md
msgid "\"b\""
msgstr "\"b\""

#: src/memory-management/drop.md
#, fuzzy
msgid "\"c\""
msgstr "\"c\""

#: src/memory-management/drop.md
msgid "\"d\""
msgstr "\"d\""

#: src/memory-management/drop.md
msgid "\"Exiting block B\""
msgstr "\"Exiting block B\""

#: src/memory-management/drop.md
msgid "\"Exiting block A\""
msgstr "\"Exiting block A\""

#: src/memory-management/drop.md
msgid "\"Exiting main\""
msgstr "\"Exiting main\""

#: src/memory-management/drop.md
msgid "Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`."
msgstr "请注意，`std::mem::drop` 与 `std::ops::Drop::drop` 不同。"

#: src/memory-management/drop.md
msgid "Values are automatically dropped when they go out of scope."
msgstr "当值超出范围时，系统会自动将其删除。"

#: src/memory-management/drop.md
msgid ""
"When a value is dropped, if it implements `std::ops::Drop` then its `Drop::"
"drop` implementation will be called."
msgstr ""
"丢弃某个值时，如果该值实现了 `std::ops::Drop`，则会调用其 `Drop::drop` 实现。"

#: src/memory-management/drop.md
msgid ""
"All its fields will then be dropped too, whether or not it implements `Drop`."
msgstr "然后，该值所有字段也会被丢弃，无论其是否实现了 `Drop`。"

#: src/memory-management/drop.md
msgid ""
"`std::mem::drop` is just an empty function that takes any value. The "
"significance is that it takes ownership of the value, so at the end of its "
"scope it gets dropped. This makes it a convenient way to explicitly drop "
"values earlier than they would otherwise go out of scope."
msgstr ""
"`std::mem::drop` 只是一个采用任何值的空函数。重要的是它获得了值的所有权，因此"
"在其作用域结束时便会被丢弃。如此您可以轻松提前明确地丢弃值，而不必等到值超过"
"范围的时候。"

#: src/memory-management/drop.md
msgid ""
"This can be useful for objects that do some work on `drop`: releasing locks, "
"closing files, etc."
msgstr "这对于通过 `drop` 执行任务的对象来说非常有用，例如释放锁、关闭文件等。"

#: src/memory-management/drop.md
msgid "Why doesn't `Drop::drop` take `self`?"
msgstr "为什么 `Drop::drop` 不使用 `self`？"

#: src/memory-management/drop.md
msgid ""
"Short-answer: If it did, `std::mem::drop` would be called at the end of the "
"block, resulting in another call to `Drop::drop`, and a stack overflow!"
msgstr ""
"简答：如果这样的话，系统会在代码块结尾 调用 `std::mem::drop`，进而引发再一次"
"调用 `Drop::drop`，并引发堆栈 溢出！"

#: src/memory-management/drop.md
msgid "Try replacing `drop(a)` with `a.drop()`."
msgstr "尝试用 `a.drop()` 替换 `drop(a)`。"

#: src/memory-management/exercise.md
msgid ""
"In this example, we will implement a complex data type that owns all of its "
"data. We will use the \"builder pattern\" to support building a new value "
"piece-by-piece, using convenience functions."
msgstr ""
"在此示例中，我们将实现一个拥有全部数据所有权的复杂数据类型。我们将使用 “构建"
"器模式”来支持逐步构建新值，通过便捷函数来实现。"

#: src/memory-management/exercise.md
msgid "Fill in the missing pieces."
msgstr "填补缺失的内容。"

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// A representation of a software package.\n"
msgstr "/// A representation of a software package.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid ""
"/// Return a representation of this package as a dependency, for use in\n"
"    /// building other packages.\n"
msgstr ""

#: src/memory-management/exercise.md
msgid "\"1\""
msgstr "\"1\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"
msgstr ""
"/// A builder for a Package. Use `build()` to create the `Package` itself.\n"

#: src/memory-management/exercise.md
msgid "\"2\""
msgstr "\"2\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Set the package version.\n"
msgstr "/// Set the package version.\n"

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Set the package authors.\n"
msgstr "/// Set the package authors.\n"

#: src/memory-management/exercise.md
msgid "\"3\""
msgstr "\"3\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Add an additional dependency.\n"
msgstr "/// Add an additional dependency.\n"

#: src/memory-management/exercise.md
msgid "\"4\""
msgstr "\"4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "/// Set the language. If not set, language defaults to None.\n"
msgstr "/// Set the language. If not set, language defaults to None.\n"

#: src/memory-management/exercise.md
msgid "\"5\""
msgstr "\"5\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"base64\""
msgstr "\"base64\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"0.13\""
msgstr "\"0.13\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"base64: {base64:?}\""
msgstr "\"base64: {base64:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"log\""
msgstr ""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"0.4\""
msgstr "\"0.4\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"log: {log:?}\""
msgstr "\"log: {log:?}\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"serde\""
msgstr ""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"djmitche\""
msgstr "\"djmitche\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"4.0\""
msgstr "\"4.0\""

#: src/memory-management/exercise.md src/memory-management/solution.md
msgid "\"serde: {serde:?}\""
msgstr "\"serde: {serde:?}\""

#: src/memory-management/solution.md
msgid "\"0.1\""
msgstr "\"0.1\""

#: src/smart-pointers.md
msgid "[Box"
msgstr ""

#: src/smart-pointers.md
msgid "](./smart-pointers/box.md) (10 minutes)"
msgstr ""

#: src/smart-pointers.md
msgid "[Rc](./smart-pointers/rc.md) (5 minutes)"
msgstr ""

#: src/smart-pointers.md
msgid "[Trait Objects](./smart-pointers/trait-objects.md) (10 minutes)"
msgstr ""

#: src/smart-pointers.md
msgid "[Exercise: Binary Tree](./smart-pointers/exercise.md) (30 minutes)"
msgstr ""

#: src/smart-pointers.md
msgid "This segment should take about 55 minutes"
msgstr ""

#: src/smart-pointers/box.md
msgid ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned "
"pointer to data on the heap:"
msgstr ""
"[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) 是指向堆上数据的"
"自有指针："

#: src/smart-pointers/box.md
msgid "\"five: {}\""
msgstr "\"five: {}\""

#: src/smart-pointers/box.md
msgid ""
"`Box<T>` implements `Deref<Target = T>`, which means that you can [call "
"methods from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/"
"trait.Deref.html#more-on-deref-coercion)."
msgstr ""
"`Box<T>` 会实现 `Deref<Target = T>`，这意味着您可以[直接在 `Box<T>` 上通过 "
"`T` 调用相应方法](https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-"
"deref-coercion)。"

#: src/smart-pointers/box.md
msgid ""
"Recursive data types or data types with dynamic sizes need to use a `Box`:"
msgstr "递归数据类型或具有动态大小的数据类型需要使用 `Box`："

#: src/smart-pointers/box.md
msgid "/// A non-empty list: first element and the rest of the list.\n"
msgstr ""

#: src/smart-pointers/box.md
msgid "/// An empty list.\n"
msgstr ""

#: src/smart-pointers/box.md
msgid "\"{list:?}\""
msgstr "\"{list:?}\""

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - "
"- - - - -.\n"
":                            :     :                                                 :\n"
":    "
"list                    :     :                                                 :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // "
"| // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+    +------+----"
"+----+  :\n"
":                            :     :                                                 :\n"
":                            :     :                                                 :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - "
"- - - - -'\n"
"```"
msgstr ""
"```bob\n"
" 栈                           堆\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"`Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be "
"not null."
msgstr ""
"在 C++ 中，`Box` 与 `std::unique_ptr` 类似，除了它一定会不为 null 以外。"

#: src/smart-pointers/box.md
msgid "A `Box` can be useful when you:"
msgstr "在以下情况下，`Box` 可能会很实用："

#: src/smart-pointers/box.md
msgid ""
"have a type whose size that can't be known at compile time, but the Rust "
"compiler wants to know an exact size."
msgstr "在编译时间遇到无法知晓大小的类型，但 Rust 编译器需要知道确切大小。"

#: src/smart-pointers/box.md
msgid ""
"want to transfer ownership of a large amount of data. To avoid copying large "
"amounts of data on the stack, instead store the data on the heap in a `Box` "
"so only the pointer is moved."
msgstr ""
"想要转让大量数据的所有权。为避免在堆栈上复制大量数据，请改为将数据存储在 "
"`Box` 中的堆上，以便仅移动指针。"

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"If `Box` was not used and we attempted to embed a `List` directly into the "
"`List`, the compiler would not compute a fixed size of the struct in memory "
"(`List` would be of infinite size)."
msgstr ""
"如果这里未使用 `Box`，且我们曾尝试将一个 `List` 直接嵌入 `List`， 编译器就不"
"会计算内存中结构体的固定大小，结构体看起来会像是无限大。"

#: src/smart-pointers/box.md
msgid ""
"`Box` solves this problem as it has the same size as a regular pointer and "
"just points at the next element of the `List` in the heap."
msgstr ""
"`Box` 大小与一般指针相同，并且只会指向堆中的下一个 `List` 元素， 因此可以解决"
"这个问题。"

#: src/smart-pointers/box.md
msgid ""
"Remove the `Box` in the List definition and show the compiler error. "
"\"Recursive with indirection\" is a hint you might want to use a Box or "
"reference of some kind, instead of storing a value directly."
msgstr ""
"将 `Box` 从 List 定义中移除后，画面上会显示编译器错误。如果您看到“Recursive "
"with indirection”错误消息，这是在提示您使用 Box 或其他类型的引用，而不是直接"
"储存值。"

#: src/smart-pointers/box.md
msgid "Niche Optimization"
msgstr "小众优化"

#: src/smart-pointers/box.md
msgid ""
"A `Box` cannot be empty, so the pointer is always valid and non-`null`. This "
"allows the compiler to optimize the memory layout:"
msgstr ""
"`Box` 不得为空，因此指针始终有效且非 `null`。这样， 编译器就可以优化内存布"
"局："

#: src/smart-pointers/box.md
#, fuzzy
msgid ""
"```bob\n"
" Stack                           Heap\n"
".- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - -.\n"
":                            :     :                           :\n"
":    list                    :     :                           :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":   | Element | 1  | o--+----+-----+--->| Element | 2  | // |  :\n"
":   +---------+----+----+    :     :    +---------+----+----+  :\n"
":                            :     :                           :\n"
":                            :     :                           :\n"
"'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - -'\n"
"```"
msgstr ""
"```bob\n"
" 栈                           堆\n"
".- - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                         :     :                                               :\n"
":    "
"list                 :     :                                               :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":   | Cons | 1  | o--+----+-----+--->| Cons | 2  | o--+--->| Nil  | // | // "
"|   :\n"
":   +------+----+----+    :     :    +------+----+----+    +------+----+----"
"+   :\n"
":                         :     :                                               :\n"
":                         :     :                                               :\n"
"'- - - - - - - - - - - - -'     '- - - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/rc.md
msgid ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) is a reference-"
"counted shared pointer. Use this when you need to refer to the same data "
"from multiple places:"
msgstr ""
"[`Rc`](https://doc.rust-lang.org/std/rc/struct.Rc.html) 是引用计数的共享指"
"针。如果您需要从多个位置 引用相同的数据，请使用此指针："

#: src/smart-pointers/rc.md
msgid "\"a: {a}\""
msgstr "\"a: {a}\""

#: src/smart-pointers/rc.md
msgid "\"b: {b}\""
msgstr "\"b: {b}\""

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"See [`Arc`](../concurrency/shared_state/arc.md) and [`Mutex`](https://doc."
"rust-lang.org/std/sync/struct.Mutex.html) if you are in a multi-threaded "
"context."
msgstr ""
"如果您在多线程情境中，请参阅 [`Arc`](https://doc.rust-lang.org/std/sync/"
"struct.Mutex.html)。"

#: src/smart-pointers/rc.md
msgid ""
"You can _downgrade_ a shared pointer into a [`Weak`](https://doc.rust-lang."
"org/std/rc/struct.Weak.html) pointer to create cycles that will get dropped."
msgstr ""
"您可以将共享指针_降级_为 [`Weak`](https://doc.rust-lang.org/std/rc/struct."
"Weak.html) 指针， 以便创建之后会被舍弃的循环引用。"

#: src/smart-pointers/rc.md
msgid ""
"`Rc`'s count ensures that its contained value is valid for as long as there "
"are references."
msgstr "`Rc` 的计数可确保只要有引用，内含的值就会保持有效。"

#: src/smart-pointers/rc.md
msgid "`Rc` in Rust is like `std::shared_ptr` in C++."
msgstr "Rust 中的“Rc”与 C++ 中的“std::shared_ptr”类似。"

#: src/smart-pointers/rc.md
msgid ""
"`Rc::clone` is cheap: it creates a pointer to the same allocation and "
"increases the reference count. Does not make a deep clone and can generally "
"be ignored when looking for performance issues in code."
msgstr ""
"`Rc::clone` 的成本很低：这个做法会创建指向相同分配的指针，并增加引用计数，而"
"不会产生深层的克隆，排查代码性能问题时通常可以忽略。"

#: src/smart-pointers/rc.md
msgid ""
"`make_mut` actually clones the inner value if necessary (\"clone-on-write\") "
"and returns a mutable reference."
msgstr ""
"`make_mut` 实际上会在必要时克隆内部值（“clone-on-write”），并返回可变的引用。"

#: src/smart-pointers/rc.md
msgid "Use `Rc::strong_count` to check the reference count."
msgstr "使用 `Rc::strong_count` 可查看引用计数。"

#: src/smart-pointers/rc.md
#, fuzzy
msgid ""
"`Rc::downgrade` gives you a _weakly reference-counted_ object to create "
"cycles that will be dropped properly (likely in combination with `RefCell`)."
msgstr ""
"`Rc::downgrade` 会向您提供 _弱引用计数_ 对象， 以便创建之后会被适当舍弃的周期"
"（可能会与 `RefCell` 组合）。"

#: src/smart-pointers/trait-objects.md
msgid ""
"Trait objects allow for values of different types, for instance in a "
"collection:"
msgstr "特征（Trait）对象可接受不同类型的值，举例来说，在集合中会是这样："

#: src/smart-pointers/trait-objects.md
#, fuzzy
msgid "\"Hello, who are you? {}\""
msgstr "\"Hello, who are you? {}\""

#: src/smart-pointers/trait-objects.md
msgid "Memory layout after allocating `pets`:"
msgstr "以下是分配 `pets` 后的内存布局："

#: src/smart-pointers/trait-objects.md
msgid ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"
msgstr ""
"```bob\n"
" Stack                             Heap\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - "
"- -.\n"
":                           :     :                                             :\n"
":    pets                   :     :                     +----+----+----+----"
"+   :\n"
":   +-----------+-------+   :     :   +-----+-----+  .->| F  | i  | d  | o  "
"|   :\n"
":   | ptr       |   o---+---+-----+-->| o o | o o |  |  +----+----+----+----"
"+   :\n"
":   | len       |     2 |   :     :   +-|-|-+-|-|-+  "
"`---------.                :\n"
":   | capacity  |     2 |   :     :     | |   | |    data      "
"|                :\n"
":   +-----------+-------+   :     :     | |   | |   +-------+--|-------"
"+        :\n"
":                           :     :     | |   | '-->| name  |  o, 4, 4 "
"|        :\n"
":                           :     :     | |   |     | age   |        5 "
"|        :\n"
"`- - - - - - - - - - - - - -'     :     | |   |     +-------+----------"
"+        :\n"
"                                  :     | |   "
"|                                 :\n"
"                                  :     | |   |      "
"vtable                     :\n"
"                                  :     | |   |     +----------------------"
"+    :\n"
"                                  :     | |   '---->| \"<Dog as Pet>::talk\" "
"|    :\n"
"                                  :     | |         +----------------------"
"+    :\n"
"                                  :     | "
"|                                     :\n"
"                                  :     | |    "
"data                             :\n"
"                                  :     | |   +-------+-------"
"+                 :\n"
"                                  :     | '-->| lives |     9 "
"|                 :\n"
"                                  :     |     +-------+-------"
"+                 :\n"
"                                  :     "
"|                                       :\n"
"                                  :     |      "
"vtable                           :\n"
"                                  :     |     +----------------------"
"+          :\n"
"                                  :     '---->| \"<Cat as Pet>::talk\" "
"|          :\n"
"                                  :           +----------------------"
"+          :\n"
"                                  :                                             :\n"
"                                  '- - - - - - - - - - - - - - - - - - - - - "
"- -'\n"
"```"

#: src/smart-pointers/trait-objects.md
msgid ""
"Types that implement a given trait may be of different sizes. This makes it "
"impossible to have things like `Vec<dyn Pet>` in the example above."
msgstr ""
"实现给定 trait 的类型可能大小不同。因此，上例中不可能具有像 `Vec<dyn Pet>` 这"
"样的项。"

#: src/smart-pointers/trait-objects.md
msgid ""
"`dyn Pet` is a way to tell the compiler about a dynamically sized type that "
"implements `Pet`."
msgstr "可通过“dyn Pet”这个方法向编译器告知实现“Pet”的动态大小类型。"

#: src/smart-pointers/trait-objects.md
msgid ""
"In the example, `pets` is allocated on the stack and the vector data is on "
"the heap. The two vector elements are _fat pointers_:"
msgstr ""
"在本例中，`pets` 在栈上分配内存，矢量数据存储在堆上。这两个矢量元素是 _胖指针"
"_："

#: src/smart-pointers/trait-objects.md
msgid ""
"A fat pointer is a double-width pointer. It has two components: a pointer to "
"the actual object and a pointer to the [virtual method table](https://en."
"wikipedia.org/wiki/Virtual_method_table) (vtable) for the `Pet` "
"implementation of that particular object."
msgstr ""
"胖指针属于全角指针。它包含两个部分：指向实际对象的指针，以及指向该特定对象的 "
"`Pet` 实现的 [虚拟方法表](https://en.wikipedia.org/wiki/"
"Virtual_method_table) (vtable) 的指针。"

#: src/smart-pointers/trait-objects.md
msgid ""
"The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat` "
"has a `lives` field."
msgstr ""
"`Dog`（名为 Fido）类型的数据是 `name` 和 `age` 字段。`Cat` 类型包含一个 "
"`lives` 字段。"

#: src/smart-pointers/trait-objects.md
msgid "Compare these outputs in the above example:"
msgstr "比较上述示例中的这些输出："

#: src/smart-pointers/exercise.md
msgid ""
"A binary tree is a tree-type data structure where every node has two "
"children (left and right). We will create a tree where each node stores a "
"value. For a given node N, all nodes in a N's left subtree contain smaller "
"values, and all nodes in N's right subtree will contain larger values."
msgstr ""
"二元树是一种树型数据结构，其中每个节点都有两个子节点（左侧和右侧）。我们将创"
"建一个树状结构，其中每个节点存储一个值。对于给定的节点 N，N 的左侧子树中的所"
"有节点都包含较小的值，而 N 的右侧子树中的所有节点都将包含较大的值。"

#: src/smart-pointers/exercise.md
msgid "Implement the following types, so that the given tests pass."
msgstr "实现以下类型，以便通过指定的测试。"

#: src/smart-pointers/exercise.md
msgid ""
"Extra Credit: implement an iterator over a binary tree that returns the "
"values in order."
msgstr "额外提示：对按顺序返回值的二元树实现迭代器。"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid "/// A node in the binary tree.\n"
msgstr ""

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid "/// A possibly-empty subtree.\n"
msgstr ""

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"
msgstr ""
"/// A container storing a set of values, using a binary tree.\n"
"///\n"
"/// If the same value is added multiple times, it is only stored once.\n"

#: src/smart-pointers/exercise.md
#, fuzzy
msgid "// Implement `new`, `insert`, `len`, and `has`.\n"
msgstr "// Implement `new`, `insert`, and `has`.\n"

#: src/smart-pointers/exercise.md src/smart-pointers/solution.md
msgid "// not a unique item\n"
msgstr "// not a unique item\n"

#: src/smart-pointers/solution.md src/testing/googletest.md
msgid "\"bar\""
msgstr "\"bar\""

#: src/welcome-day-3-afternoon.md
#, fuzzy
msgid "[Borrowing](./borrowing.md) (1 hour)"
msgstr ""
"借用：\n"
"请参阅 [借用](ownership/borrowing.md)。"

#: src/welcome-day-3-afternoon.md
msgid ""
"[Slices and Lifetimes](./slices-and-lifetimes.md) (1 hour and 10 minutes)"
msgstr ""

#: src/welcome-day-3-afternoon.md
msgid ""
"Including 10 minute breaks, this session should take about 2 hours and 20 "
"minutes"
msgstr ""

#: src/borrowing.md
msgid "[Borrowing a Value](./borrowing/shared.md) (10 minutes)"
msgstr ""

#: src/borrowing.md
msgid "[Borrow Checking](./borrowing/borrowck.md) (10 minutes)"
msgstr ""

#: src/borrowing.md
msgid "[Interior Mutability](./borrowing/interior-mutability.md) (10 minutes)"
msgstr ""

#: src/borrowing.md
msgid "[Exercise: Health Statistics](./borrowing/exercise.md) (30 minutes)"
msgstr ""

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"As we saw before, instead of transferring ownership when calling a function, "
"you can let a function _borrow_ the value:"
msgstr "调用函数时，你可以让 函数“借用”值，而不是转移所有权："

#: src/borrowing/shared.md
msgid "The `add` function _borrows_ two points and returns a new point."
msgstr "`add` 函数“借用”两个点并返回一个新点。"

#: src/borrowing/shared.md
msgid "The caller retains ownership of the inputs."
msgstr "调用方会保留输入的所有权。"

#: src/borrowing/shared.md
msgid ""
"This slide is a review of the material on references from day 1, expanding "
"slightly to include function arguments and return values."
msgstr ""
"此幻灯片是对第 1 天引用材料的回顾，并稍作了扩展，添加了函数参数和返回值。"

#: src/borrowing/shared.md
msgid "Notes on stack returns:"
msgstr "关于栈返回的说明："

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"Demonstrate that the return from `add` is cheap because the compiler can "
"eliminate the copy operation. Change the above code to print stack addresses "
"and run it on the [Playground](https://play.rust-lang.org/?"
"version=stable&mode=release&edition=2021&gist=0cb13be1c05d7e3446686ad9947c4671) "
"or look at the assembly in [Godbolt](https://rust.godbolt.org/). In the "
"\"DEBUG\" optimization level, the addresses should change, while they stay "
"the same when changing to the \"RELEASE\" setting:"
msgstr ""
"证明从 `add` 返回的开销很低，因为编译器可以消除复制操作。更改上述代码以输出栈"
"地址，并在 [Playground](https://play.rust-lang.org/) 上运行它。在“调试”优化级"
"别中，地址应发生变化，而在改成“发布”设置时保持不变："

#: src/borrowing/shared.md
msgid "The Rust compiler can do return value optimization (RVO)."
msgstr "Rust 编译器能够执行返回值优化 (RVO)。"

#: src/borrowing/shared.md
#, fuzzy
msgid ""
"In C++, copy elision has to be defined in the language specification because "
"constructors can have side effects. In Rust, this is not an issue at all. If "
"RVO did not happen, Rust will always perform a simple and efficient `memcpy` "
"copy."
msgstr ""
"在 C++ 中，必须在语言规范中定义复制省略，因为构造函数可能会有附带效应。在 "
"Rust 中，这完全不是问题。如果 RVO 未发生，Rust 将始终执行简单且高效的 "
"`memcpy` 复制。"

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"Rust's _borrow checker_ puts constraints on the ways you can borrow values. "
"For a given value, at any time:"
msgstr "Rust 限制了借用值的方式："

#: src/borrowing/borrowck.md
#, fuzzy
msgid "You can have one or more shared references to the value, _or_"
msgstr "在任何给定时间，你都可以有一个或多个 `&T` 值，或者"

#: src/borrowing/borrowck.md
#, fuzzy
msgid "You can have exactly one exclusive reference to the value."
msgstr "你可以有且只有一个 `&mut T` 值。"

#: src/borrowing/borrowck.md
msgid ""
"Note that the requirement is that conflicting references not _exist_ at the "
"same point. It does not matter where the reference is dereferenced."
msgstr ""
"请注意，要求是相冲突的引用不能 _同时存在_。而引用的解引用位置无关紧要。"

#: src/borrowing/borrowck.md
msgid ""
"The above code does not compile because `a` is borrowed as mutable (through "
"`c`) and as immutable (through `b`) at the same time."
msgstr ""
"上述代码无法编译，因为 `a` 同时作为可变值（通过 `c`）和不可变值（通过 `b`）被"
"借用。"

#: src/borrowing/borrowck.md
msgid ""
"Move the `println!` statement for `b` before the scope that introduces `c` "
"to make the code compile."
msgstr ""
"将`b` 的 `println!` 语句移到引入 `c` 的作用域之前，这段代码就可以编译。"

#: src/borrowing/borrowck.md
msgid ""
"After that change, the compiler realizes that `b` is only ever used before "
"the new mutable borrow of `a` through `c`. This is a feature of the borrow "
"checker called \"non-lexical lifetimes\"."
msgstr ""
"这样更改后，编译器会发现 `b` 只在通过 `c` 对 `a` 进行新可变借用之前使用过。这"
"是借用检查器的一个功能，名为“非词法作用域生命周期”。"

#: src/borrowing/borrowck.md
#, fuzzy
msgid ""
"The exclusive reference constraint is quite strong. Rust uses it to ensure "
"that data races do not occur. Rust also _relies_ on this constraint to "
"optimize code. For example, a value behind a shared reference can be safely "
"cached in a register for the lifetime of that reference."
msgstr ""
"独占引用的约束条件非常严格。Rust 使用它来确保不会发生数据争用。Rust 还会 _依"
"赖_ 此约束条件来优化代码。例如，共享引用背后的值可以安全地缓存在寄存器中，并"
"在该引用的生命周期内保持有效。"

#: src/borrowing/borrowck.md
msgid ""
"The borrow checker is designed to accommodate many common patterns, such as "
"taking exclusive references to different fields in a struct at the same "
"time. But, there are some situations where it doesn't quite \"get it\" and "
"this often results in \"fighting with the borrow checker.\""
msgstr ""
"借用检查器专用于处理许多常见模式，例如同时对结构体中的不同字段进行独占引用。"
"但在某些情况下，它并不能完全 “领会”您的意图，这往往会导致 “与借用检查器进行一"
"番斗争”。"

#: src/borrowing/interior-mutability.md
msgid ""
"In some situations, it's necessary to modify data behind a shared (read-"
"only) reference. For example, a shared data structure might have an internal "
"cache, and wish to update that cache from read-only methods."
msgstr ""

#: src/borrowing/interior-mutability.md
msgid ""
"The \"interior mutability\" pattern allows exclusive (mutable) access behind "
"a shared reference. The standard library provides several ways to do this, "
"all while still ensuring safety, typically by performing a runtime check."
msgstr ""

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "`RefCell`"
msgstr "`RefCell<T>`"

#: src/borrowing/interior-mutability.md
msgid "\"graph: {root:#?}\""
msgstr "\"graph: {root:#?}\""

#: src/borrowing/interior-mutability.md
msgid "\"graph sum: {}\""
msgstr "\"graph sum: {}\""

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid "`Cell`"
msgstr "`Cell<T>`"

#: src/borrowing/interior-mutability.md
msgid ""
"`Cell` wraps a value and allows getting or setting the value, even with a "
"shared reference to the `Cell`. However, it does not allow any references to "
"the value. Since there are no references, borrowing rules cannot be broken."
msgstr ""

#: src/borrowing/interior-mutability.md
msgid ""
"The main thing to take away from this slide is that Rust provides _safe_ "
"ways to modify data behind a shared reference. There are a variety of ways "
"to ensure that safety, and `RefCell` and `Cell` are two of them."
msgstr ""

#: src/borrowing/interior-mutability.md
msgid ""
"`RefCell` enforces Rust's usual borrowing rules (either multiple shared "
"references or a single exclusive reference) with a runtime check. In this "
"case, all borrows are very short and never overlap, so the checks always "
"succeed."
msgstr ""

#: src/borrowing/interior-mutability.md
msgid ""
"`Rc` only allows shared (read-only) access to its contents, since its "
"purpose is to allow (and count) many references. But we want to modify the "
"value, so we need interior mutability."
msgstr ""

#: src/borrowing/interior-mutability.md
msgid ""
"`Cell` is a simpler means to ensure safety: it has a `set` method that takes "
"`&self`. This needs no runtime check, but requires moving values, which can "
"have its own cost."
msgstr ""

#: src/borrowing/interior-mutability.md
#, fuzzy
msgid ""
"Demonstrate that reference loops can be created by adding `root` to `subtree."
"children`."
msgstr ""
"演示可以通过向“subtree.children”添加“root”来创建引用循环（不要尝试输出"
"它！）。"

#: src/borrowing/interior-mutability.md
msgid ""
"To demonstrate a runtime panic, add a `fn inc(&mut self)` that increments "
"`self.value` and calls the same method on its children. This will panic in "
"the presence of the reference loop, with `thread 'main' panicked at 'already "
"borrowed: BorrowMutError'`."
msgstr ""
"为了演示运行时 panic，请添加一个会递增“self.value”并以相同方法调用其子项"
"的“fn inc(&mut self)”。如果存在引用循环，就会 panic，并且“thread”“main”会"
"因“already borrowed: BorrowMutError”而 panic。"

#: src/borrowing/exercise.md
msgid ""
"You're working on implementing a health-monitoring system. As part of that, "
"you need to keep track of users' health statistics."
msgstr ""
"你正在实现一个健康监控系统。作为其中的一部分，你需要对用户的健康统计数据进行"
"追踪。"

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"You'll start with a stubbed function in an `impl` block as well as a `User` "
"struct definition. Your goal is to implement the stubbed out method on the "
"`User` `struct` defined in the `impl` block."
msgstr ""
"`User` 结构体的定义和 `impl` 块中一些函数的框架已经给出。你的目标是实现在 "
"`impl` 块中定义的 `User` `struct` 的方法。"

#: src/borrowing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"method:"
msgstr "将以下代码复制到 <https://play.rust-lang.org/>，并填充缺失的方法："

#: src/borrowing/exercise.md
msgid ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""
msgstr ""
"\"Update a user's statistics based on measurements from a visit to the "
"doctor\""

#: src/borrowing/exercise.md src/borrowing/solution.md
#: src/android/build-rules/library.md src/android/aidl/client.md
msgid "\"Bob\""
msgstr "\"Bob\""

#: src/borrowing/exercise.md src/borrowing/solution.md
msgid "\"I'm {} and my age is {}\""
msgstr "\"I'm {} and my age is {}\""

#: src/slices-and-lifetimes.md
msgid "[Slices: &\\[T\\]](./slices-and-lifetimes/slices.md) (10 minutes)"
msgstr ""

#: src/slices-and-lifetimes.md
msgid "[String References](./slices-and-lifetimes/str.md) (10 minutes)"
msgstr ""

#: src/slices-and-lifetimes.md
msgid ""
"[Lifetime Annotations](./slices-and-lifetimes/lifetime-annotations.md) (10 "
"minutes)"
msgstr ""

#: src/slices-and-lifetimes.md
msgid ""
"[Lifetime Elision](./slices-and-lifetimes/lifetime-elision.md) (5 minutes)"
msgstr ""

#: src/slices-and-lifetimes.md
msgid ""
"[Struct Lifetimes](./slices-and-lifetimes/struct-lifetimes.md) (5 minutes)"
msgstr ""

#: src/slices-and-lifetimes.md
msgid ""
"[Exercise: Protobuf Parsing](./slices-and-lifetimes/exercise.md) (30 minutes)"
msgstr ""

#: src/slices-and-lifetimes/slices.md
msgid "Slices"
msgstr "切片"

#: src/slices-and-lifetimes/slices.md
msgid "A slice gives you a view into a larger collection:"
msgstr "切片 (slice) 的作用是提供对集合 (collection) 的视图 (view):"

#: src/slices-and-lifetimes/slices.md
msgid "Slices borrow data from the sliced type."
msgstr "切片从被切片的类型中借用 (borrow) 数据。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid "Question: What happens if you modify `a[3]` right before printing `s`?"
msgstr "请思考：如果我们改变 `a[3]`，将会产生怎样的后果？"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"We create a slice by borrowing `a` and specifying the starting and ending "
"indexes in brackets."
msgstr "创建切片时，我们借用了 `a` ，并在方括号中标明了起始和结尾下标。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"If the slice starts at index 0, Rust’s range syntax allows us to drop the "
"starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are "
"identical."
msgstr ""
"如果切片的起始下标为 0， Rust 语法允许我们省略起始下标。比如说 `&a[0..a."
"len()]` 与 `&a[..a.len()]` 是等价的。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are "
"identical."
msgstr ""
"结尾下标也可以用相同方式省略。比如说 `&a[2..a.len()]` 和 `&a[2..]` 是等价的。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"To easily create a slice of the full array, we can therefore use `&a[..]`."
msgstr "因此，我们可以用 `&a[..]` 来创建包含整个数组的切片。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"`s` is a reference to a slice of `i32`s. Notice that the type of `s` "
"(`&[i32]`) no longer mentions the array length. This allows us to perform "
"computation on slices of different sizes."
msgstr ""
"切片会从另外一个对象中借用数据。在这个例子中， `a` 必须在其切片存活时保持存活"
"（处于作用域中）。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"Slices always borrow from another object. In this example, `a` has to remain "
"'alive' (in scope) for at least as long as our slice."
msgstr ""
"关于修改 `a[3]` 的问题可能会引发精彩的讨论。正确答案是：为了保证内存安全，在"
"创建切片后，我们不能通过 `a` 来修改数据。不过我们可以通过 `a` 或者 `s` 来读取"
"数据。我们将会在“借用”章节着重介绍这个内容。"

#: src/slices-and-lifetimes/slices.md
#, fuzzy
msgid ""
"The question about modifying `a[3]` can spark an interesting discussion, but "
"the answer is that for memory safety reasons you cannot do it through `a` at "
"this point in the execution, but you can read the data from both `a` and `s` "
"safely. It works before you created the slice, and again after the "
"`println`, when the slice is no longer used."
msgstr ""
"关于修改“a\\[3\\]”的问题可能会引发一些有趣的讨论，但正解是，出于内存安全方面"
"的原因，您无法在执行作业的这个时间点通过“a”来进行此修改，但可以从“a”和“s”安全"
"地读取数据。它会在您创建 Slice 之前运作，在“println”之后（不再使用 Slice 时）"
"再次运作。更多详情会在“借用检查器”部分中加以说明。"

#: src/slices-and-lifetimes/str.md
msgid ""
"We can now understand the two string types in Rust: `&str` is almost like "
"`&[char]`, but with its data stored in a variable-length encoding (UTF-8)."
msgstr ""
"现在，我们能够理解 Rust 中的两种字符串类型：`&str` 几乎与 `&[char]` 一样，只"
"不过其数据存储在可变长度编码 (UTF-8) 中。"

#: src/slices-and-lifetimes/str.md
msgid "\"s1: {s1}\""
msgstr "\"s1: {s1}\""

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid "\"Hello \""
msgstr "b\"hello\""

#: src/slices-and-lifetimes/str.md
msgid "\"s3: {s3}\""
msgstr "\"s3: {s3}\""

#: src/slices-and-lifetimes/str.md
msgid "Rust terminology:"
msgstr "Rust 术语："

#: src/slices-and-lifetimes/str.md
msgid "`&str` an immutable reference to a string slice."
msgstr "`&str` 是一个指向字符串片段的不可变引用。"

#: src/slices-and-lifetimes/str.md
msgid "`String` a mutable string buffer."
msgstr "`String` 是一个可变字符串缓冲区。"

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid ""
"`&str` introduces a string slice, which is an immutable reference to UTF-8 "
"encoded string data stored in a block of memory. String literals "
"(`”Hello”`), are stored in the program’s binary."
msgstr ""
"`&str` 引入了一个字符串切片，它是一个指向保存在内存块中的 UTF-8 编码字符串数"
"据的不可变引用。   字符串字面量（`”Hello”`）会保存在程序的二进制文件中。"

#: src/slices-and-lifetimes/str.md
msgid ""
"Rust’s `String` type is a wrapper around a vector of bytes. As with a "
"`Vec<T>`, it is owned."
msgstr ""
"Rust 的 `String` 类型是一个字节 vector 的封装。和 `Vec<T>` 一样，它是拥有所有"
"权的。"

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid ""
"As with many other types `String::from()` creates a string from a string "
"literal; `String::new()` creates a new empty string, to which string data "
"can be added using the `push()` and `push_str()` methods."
msgstr ""
"和其他类型一样，`String::from()` 会从字符串字面量创建一个字符串；`String::"
"new()` 会创建一个新的空字符串，   之后可以使用 `push()` 和 `push_str()` 方法"
"向其中添加字符串数据。"

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid ""
"The `format!()` macro is a convenient way to generate an owned string from "
"dynamic values. It accepts the same format specification as `println!()`."
msgstr ""
"`format!()` 宏可以方便地动态生成拥有所有权的字符串。它接受和 `println!()` 相"
"同的格式规范。"

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid ""
"You can borrow `&str` slices from `String` via `&` and optionally range "
"selection. If you select a byte range that is not aligned to character "
"boundaries, the expression will panic. The `chars` iterator iterates over "
"characters and is preferred over trying to get character boundaries right."
msgstr ""
"您可以通过 `&` 和范围选择（可选）来从 `String` 借用 `&str` slice。如果选择的"
"字节范围未与字符边界对齐，则表达式会 panic。`chars` 迭代器会迭代字符，比尝试"
"正确获取字符边界更为推荐。"

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid ""
"For C++ programmers: think of `&str` as `std::string_view` from C++, but the "
"one that always points to a valid string in memory. Rust `String` is a rough "
"equivalent of `std::string` from C++ (main difference: it can only contain "
"UTF-8 encoded bytes and will never use a small-string optimization)."
msgstr ""
"对于 C++ 程序员：可以把 `&str` 当作 C++ 中的 `const char*`，但是它总是指向内"
"存中的一个有效字符串。   Rust 的 `String` 大致相当于 C++ 中 `std::string` "
"（主要区别：它只能包含 UTF-8 编码的字节，   并且永远不会使用小字符串优化"
"（small-string optimization））。"

#: src/slices-and-lifetimes/str.md
#, fuzzy
msgid "Byte strings literals allow you to create a `&[u8]` value directly:"
msgstr "字节串可以用于直接创建 `&[u8]` 类型的值："

#: src/slices-and-lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"A reference has a _lifetime_, which must not \"outlive\" the value it refers "
"to. This is verified by the borrow checker."
msgstr ""
"引用具有 _生命周期_，该生命周期必须比其所引用的值 “存在得更久”。这由借用检查"
"器进行验证。"

#: src/slices-and-lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"The lifetime can be implicit - this is what we have seen so far. Lifetimes "
"can also be explicit: `&'a Point`, `&'document str`. Lifetimes start with "
"`'` and `'a` is a typical default name. Read `&'a Point` as \"a borrowed "
"`Point` which is valid for at least the lifetime `a`\"."
msgstr ""
"生命周期可以是隐式的，我们目前所看到的便是如此。生命周期也可以是显式的：`&'a "
"Point` 和 `&'document str`。生命周期以 `'` 开头，`'a` 是典型的默认名称。将 "
"`&'a Point` 读取为 “一个借用的 `Point`，至少在生命周期 `a` 内有效”。"

#: src/slices-and-lifetimes/lifetime-annotations.md
#, fuzzy
msgid ""
"Lifetimes are always inferred by the compiler: you cannot assign a lifetime "
"yourself. Explicit lifetime annotations create constraints where there is "
"ambiguity; the compiler verifies that there is a valid solution."
msgstr "生命周期注释会创建约束条件；编译器会验证 是否存在有效的解决方案。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"Lifetimes become more complicated when considering passing values to and "
"returning values from functions."
msgstr "当考虑向函数传递值和从函数返回值时，生命周期会变得更加复杂。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid "// What is the lifetime of p3?\n"
msgstr "// What is the lifetime of p3?\n"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid "\"p3: {p3:?}\""
msgstr "\"p3: {p3:?}\""

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"In this example, the the compiler does not know what lifetime to infer for "
"`p3`. Looking inside the function body shows that it can only safely assume "
"that `p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, "
"Rust requires explicit annotations of lifetimes on function arguments and "
"return values."
msgstr ""
"在此示例中，编译器无法推理出 `p3` 的生命周期。查看函数体内部后则可放心地假"
"定，`p3` 的生命周期是 `p1` 和 `p2` 中的较短者。但与类型一样，Rust 需要对函数"
"参数和返回值进行明确的生命周期注解。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid "Add `'a` appropriately to `left_most`:"
msgstr "将 `'a` 适当添加到 `left_most` 中："

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"This says, \"given p1 and p2 which both outlive `'a`, the return value lives "
"for at least `'a`."
msgstr ""
"这表示.，“假设 p1 和 p2 的存在时间都比 `'a` 更长，则返回值至少在 `'a` 内有"
"效”。"

#: src/slices-and-lifetimes/lifetime-annotations.md
msgid ""
"In common cases, lifetimes can be elided, as described on the next slide."
msgstr "在一般情况下，可以省略生命周期，如下一张幻灯片中所述。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "Lifetimes in Function Calls"
msgstr "函数调用中的生命周期"

#: src/slices-and-lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"Lifetimes for function arguments and return values must be fully specified, "
"but Rust allows lifetimes to be elided in most cases with [a few simple "
"rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html). This is not "
"inference -- it is just a syntactic shorthand."
msgstr ""
"必须完全指定函数参数和返回值的生命周期， 但 Rust 允许在大多数情况下通过\\[一"
"些简单的 规则\\](https://doc.rust-lang.org/nomicon/lifetime-elision.html）来"
"省略此操作。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "Each argument which does not have a lifetime annotation is given one."
msgstr "每个没有生命周期注解的参数都会添加一个生命周期注解。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"If there is only one argument lifetime, it is given to all un-annotated "
"return values."
msgstr "如果只有一个参数生命周期，则将其赋予所有未加注解的返回值。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"If there are multiple argument lifetimes, but the first one is for `self`, "
"that lifetime is given to all un-annotated return values."
msgstr ""
"如果有多个参数生命周期，但第一个是用于 `self` 的，则将该生命周期赋予所有未加"
"注解的返回值。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "In this example, `cab_distance` is trivially elided."
msgstr "在此示例中，`cab_distance` 被轻易省略掉了。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"The `nearest` function provides another example of a function with multiple "
"references in its arguments that requires explicit annotation."
msgstr ""
"`nearest` 函数提供了另一个函数示例，该函数的参数中包含多个引用，需要显式注"
"解。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid "Try adjusting the signature to \"lie\" about the lifetimes returned:"
msgstr "请尝试将签名调整为 “谎报”了返回的生命周期："

#: src/slices-and-lifetimes/lifetime-elision.md
#, fuzzy
msgid ""
"This won't compile, demonstrating that the annotations are checked for "
"validity by the compiler. Note that this is not the case for raw pointers "
"(unsafe), and this is a common source of errors with unsafe Rust."
msgstr ""
"这将无法编译，表面编译器会检查注解是否有效。请注意，原始指针并非如此（不安"
"全），这是不安全 Rust 中导致错误的常见原因。"

#: src/slices-and-lifetimes/lifetime-elision.md
msgid ""
"Students may ask when to use lifetimes. Rust borrows _always_ have "
"lifetimes. Most of the time, elision and type inference mean these don't "
"need to be written out. In more complicated cases, lifetime annotations can "
"help resolve ambiguity. Often, especially when prototyping, it's easier to "
"just work with owned data by cloning values where necessary."
msgstr ""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "Lifetimes in Data Structures"
msgstr "数据结构中的生命周期"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"If a data type stores borrowed data, it must be annotated with a lifetime:"
msgstr "如果数据类型存储了借用的数据，则必须对其添加生命周期注释："

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"Bye {text}!\""
msgstr "\"Bye {text}!\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"The quick brown fox jumps over the lazy dog.\""
msgstr "\"The quick brown fox jumps over the lazy dog.\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "// erase(text);\n"
msgstr "// erase(text);\n"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"{fox:?}\""
msgstr "\"{fox:?}\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "\"{dog:?}\""
msgstr "\"{dog:?}\""

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"In the above example, the annotation on `Highlight` enforces that the data "
"underlying the contained `&str` lives at least as long as any instance of "
"`Highlight` that uses that data."
msgstr ""
"在上述示例中，`Highlight` 注释会强制包含 `&str` 的底层数据的生命周期至少与使"
"用该数据的任何 `Highlight` 实例一样长。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"If `text` is consumed before the end of the lifetime of `fox` (or `dog`), "
"the borrow checker throws an error."
msgstr ""
"如果 `text` 在 `fox`（或 `dog`）的生命周期结束前被消耗，借用检查器将抛出一个"
"错误。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"Types with borrowed data force users to hold on to the original data. This "
"can be useful for creating lightweight views, but it generally makes them "
"somewhat harder to use."
msgstr ""
"借用数据的类型会迫使用户保留原始数据。这对于创建轻量级视图很有用，但通常会使"
"它们更难使用。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid "When possible, make data structures own their data directly."
msgstr "如有可能，让数据结构直接拥有自己的数据。"

#: src/slices-and-lifetimes/struct-lifetimes.md
msgid ""
"Some structs with multiple references inside can have more than one lifetime "
"annotation. This can be necessary if there is a need to describe lifetime "
"relationships between the references themselves, in addition to the lifetime "
"of the struct itself. Those are very advanced use cases."
msgstr ""
"一些包含多个引用的结构可以有多个生命周期注释。除了结构体本身的生命周期之外，"
"如果需要描述引用之间的生命周期关系，则可能需要这样做。这些都是非常高级的用"
"例。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"In this exercise, you will build a parser for the [protobuf binary encoding]"
"(https://protobuf.dev/programming-guides/encoding/). Don't worry, it's "
"simpler than it seems! This illustrates a common parsing pattern, passing "
"slices of data. The underlying data itself is never copied."
msgstr ""
"在本练习中，您将为 [protobuf 二进制编码](https://protobuf.dev/programming-"
"guides/encoding/) 构建一个解析器。别担心，其实非常简单！这展示了一种常见的解"
"析模式，即传递数据 slice。底层数据本身永远不会被复制。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"Fully parsing a protobuf message requires knowing the types of the fields, "
"indexed by their field numbers. That is typically provided in a `proto` "
"file. In this exercise, we'll encode that information into `match` "
"statements in functions that get called for each field."
msgstr ""
"如要完整解析 protobuf 消息，需要知道字段的类型（按字段编号编入索引）。这通常"
"会在 `proto` 文件中提供。在本练习中，我们将把这些信息编码成处理每个字段所调用"
"的函数中的 `match` 语句。"

#: src/slices-and-lifetimes/exercise.md
msgid "We'll use the following proto:"
msgstr "我们将使用以下 proto："

#: src/slices-and-lifetimes/exercise.md
msgid ""
"A proto message is encoded as a series of fields, one after the next. Each "
"is implemented as a \"tag\" followed by the value. The tag contains a field "
"number (e.g., `2` for the `id` field of a `Person` message) and a wire type "
"defining how the payload should be determined from the byte stream."
msgstr ""
"proto 消息被编码为连续的一系列字段。每个字段都通过 “标签”后面紧跟值的形式来实"
"现。标签包含一个字段编号（例如`Person` 消息的 `id` 字段的值为 `2`）和线型（用"
"于定义应如何从字节流确定载荷）。"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"Integers, including the tag, are represented with a variable-length encoding "
"called VARINT. Luckily, `parse_varint` is defined for you below. The given "
"code also defines callbacks to handle `Person` and `PhoneNumber` fields, and "
"to parse a message into a series of calls to those callbacks."
msgstr ""
"整数（包括标签）使用名为 VARINT 的可变长度编码表示。幸运的是，下面为您提供了 "
"`parse_varint` 的定义。该指定代码还定义了一些回调，用于处理 `Person` 和 "
"`PhoneNumber` 字段，并将消息解析为对这些回调的一系列调用。"

#: src/slices-and-lifetimes/exercise.md
#, fuzzy
msgid ""
"What remains for you is to implement the `parse_field` function and the "
"`ProtoMessage` trait for `Person` and `PhoneNumber`."
msgstr ""
"您要做的是实现 `parse_field` 函数，以及`Person` 和 `PhoneNumber`的特征"
"`ProtoMessage`。"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid varint\""
msgstr "\"Invalid varint\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid wire-type\""
msgstr "\"Invalid wire-type\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Unexpected EOF\""
msgstr "\"Unexpected EOF\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid length\""
msgstr "\"Invalid length\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Unexpected wire-type)\""
msgstr "\"Unexpected wire-type)\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "\"Invalid string (not UTF-8)\""
msgstr "\"Invalid string (not UTF-8)\""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// A wire type as seen on the wire.\n"
msgstr "/// A wire type as seen on the wire.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// The Varint WireType indicates the value is a single VARINT.\n"
msgstr "/// Varint WireType 表明该值为单个 VARINT。\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
#, fuzzy
msgid ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a\n"
"    /// VARINT followed by exactly that number of bytes.\n"
msgstr ""
"//I64,  -- not needed for this exercise\n"
"    /// The Len WireType indicates that the value is a length represented as "
"a VARINT\n"
"    /// followed by exactly that number of bytes.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
#, fuzzy
msgid ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in\n"
"    /// little-endian order containing a 32-bit signed integer.\n"
msgstr ""
"/// The I32 WireType indicates that the value is precisely 4 bytes in little-"
"endian order\n"
"    /// containing a 32-bit signed integer.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// A field's value, typed based on the wire type.\n"
msgstr "/// A field's value, typed based on the wire type.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "//I64(i64),  -- not needed for this exercise\n"
msgstr "//I64(i64),  -- not needed for this exercise\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// A field, containing the field number and its value.\n"
msgstr "/// A field, containing the field number and its value.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "//1 => WireType::I64,  -- not needed for this exercise\n"
msgstr "//1 => WireType::I64,  -- not needed for this exercise\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"
msgstr ""
"/// Parse a VARINT, returning the parsed value and the remaining bytes.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"
msgstr ""
"// This is the last byte of the VARINT, so convert it to\n"
"            // a u64 and return it.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "// More than 7 bytes is invalid.\n"
msgstr "// More than 7 bytes is invalid.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// Convert a tag into a field number and a WireType.\n"
msgstr "/// Convert a tag into a field number and a WireType.\n"

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
msgid "/// Parse a field, returning the remaining bytes\n"
msgstr "/// Parse a field, returning the remaining bytes\n"

#: src/slices-and-lifetimes/exercise.md
msgid ""
"\"Based on the wire type, build a Field, consuming as many bytes as "
"necessary.\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md
msgid "\"Return the field, and any un-consumed bytes.\""
msgstr ""

#: src/slices-and-lifetimes/exercise.md src/slices-and-lifetimes/solution.md
#, fuzzy
msgid ""
"/// Parse a message in the given data, calling `T::add_field` for each field "
"in\n"
"/// the message.\n"
"///\n"
"/// The entire input is consumed.\n"
msgstr ""
"/// Parse a message in the given data, calling `field_callback` for each "
"field in the message.\n"
"///\n"
"/// The entire input is consumed.\n"

#: src/slices-and-lifetimes/exercise.md
msgid "// TODO: Implement ProtoMessage for Person and PhoneNumber.\n"
msgstr ""

#: src/slices-and-lifetimes/solution.md
msgid "// Unwrap error because `value` is definitely 4 bytes long.\n"
msgstr "// Unwrap error because `value` is definitely 4 bytes long.\n"

#: src/slices-and-lifetimes/solution.md
msgid "// skip everything else\n"
msgstr "// skip everything else\n"

#: src/slices-and-lifetimes/solution.md
msgid "b\"hello\""
msgstr ""

#: src/welcome-day-4.md
#, fuzzy
msgid "Welcome to Day 4"
msgstr "欢迎来到第一天"

#: src/welcome-day-4.md
#, fuzzy
msgid ""
"Today we will cover topics relating to building large-scale software in Rust:"
msgstr "今天，我们将介绍一些更高级的 Rust 主题："

#: src/welcome-day-4.md
msgid "Iterators: a deep dive on the `Iterator` trait."
msgstr "迭代器：深入了解 `Iterator` 特征。"

#: src/welcome-day-4.md
msgid "Modules and visibility."
msgstr "模块和可见性。"

#: src/welcome-day-4.md
#, fuzzy
msgid "Testing."
msgstr "测试"

#: src/welcome-day-4.md
msgid "Error handling: panics, `Result`, and the try operator `?`."
msgstr "错误处理：panic、“Result”和 try 运算符“?”。"

#: src/welcome-day-4.md
msgid ""
"Unsafe Rust: the escape hatch when you can't express yourself in safe Rust."
msgstr "不安全 Rust：当无法用安全 Rust 表达您的意图时，则可将其作为应急方法。"

#: src/welcome-day-4.md
msgid "[Welcome](./welcome-day-4.md) (3 minutes)"
msgstr ""

#: src/welcome-day-4.md
msgid "[Iterators](./iterators.md) (45 minutes)"
msgstr ""

#: src/welcome-day-4.md
msgid "[Modules](./modules.md) (40 minutes)"
msgstr ""

#: src/welcome-day-4.md
msgid "[Testing](./testing.md) (1 hour and 5 minutes)"
msgstr ""

#: src/welcome-day-4.md
msgid ""
"Including 10 minute breaks, this session should take about 3 hours and 5 "
"minutes"
msgstr ""

#: src/iterators.md
msgid "[Iterator](./iterators/iterator.md) (5 minutes)"
msgstr ""

#: src/iterators.md
msgid "[IntoIterator](./iterators/intoiterator.md) (5 minutes)"
msgstr ""

#: src/iterators.md
msgid "[FromIterator](./iterators/fromiterator.md) (5 minutes)"
msgstr ""

#: src/iterators.md
#, fuzzy
msgid ""
"[Exercise: Iterator Method Chaining](./iterators/exercise.md) (30 minutes)"
msgstr "练习：迭代器方法链接"

#: src/iterators/iterator.md
msgid ""
"The [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait supports iterating over values in a collection. It requires a `next` "
"method and provides lots of methods. Many standard library types implement "
"`Iterator`, and you can implement it yourself, too:"
msgstr ""
"['Iterator'](https://doc.rust-lang.org/std/iter/trait.Iterator.html) trait 支"
"持迭代集合中的值。它需要用到 `next` 方法，并提供很多方法。许多标准库类型均能"
"实现 `Iterator`，您也可以自行实现："

#: src/iterators/iterator.md
msgid "\"fib({i}): {n}\""
msgstr "\"fib({i}): {n}\""

#: src/iterators/iterator.md
#, fuzzy
msgid ""
"The `Iterator` trait implements many common functional programming "
"operations over collections (e.g. `map`, `filter`, `reduce`, etc). This is "
"the trait where you can find all the documentation about them. In Rust these "
"functions should produce the code as efficient as equivalent imperative "
"implementations."
msgstr ""
"`Iterator` 特征会对集合实现许多常见的函数程序操作， 例如 ` map`filter \\``和"
"`reduce\\` 等。您可以通过此特征找到有关它们的所有 文档。在 Rust 中，这些函数"
"应生成代码，且生成的代码应与等效命令式实现一样 高效。"

#: src/iterators/iterator.md
msgid ""
"`IntoIterator` is the trait that makes for loops work. It is implemented by "
"collection types such as `Vec<T>` and references to them such as `&Vec<T>` "
"and `&[T]`. Ranges also implement it. This is why you can iterate over a "
"vector with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist."
msgstr ""
"`IntoIterator` 是迫使 for 循环运作的特征。此特征由集合类型 （例如 `Vec<T>`）"
"和相关引用（例如 `&Vec<T>` 和 `&[T]`）而实现。此外，范围也会实现这项特征。因"
"此， 您可以使用 `for i in some_vec { .. }` 来遍历某矢量，但 `some_vec."
"next()` 不存在。"

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"The `Iterator` trait tells you how to _iterate_ once you have created an "
"iterator. The related trait [`IntoIterator`](https://doc.rust-lang.org/std/"
"iter/trait.IntoIterator.html) defines how to create an iterator for a type. "
"It is used automatically by the `for` loop."
msgstr ""
"“Iterator”trait会告知您在创建迭代器后如何进行迭代。相关 trait“IntoIterator”会"
"告知您如何创建迭代器："

#: src/iterators/intoiterator.md
msgid "\"point = {x}, {y}\""
msgstr "\"point = {x}, {y}\""

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Click through to the docs for `IntoIterator`. Every implementation of "
"`IntoIterator` must declare two types:"
msgstr "这里的语法表示，“IntoIterator”的每个实现都必须声明两种类型："

#: src/iterators/intoiterator.md
#, fuzzy
msgid "`Item`: the type to iterate over, such as `i8`,"
msgstr "`Item`：我们迭代的类型，例如 `i8`，"

#: src/iterators/intoiterator.md
msgid "`IntoIter`: the `Iterator` type returned by the `into_iter` method."
msgstr "“IntoIter”：“into_iter”方法返回的“Iterator”类型。"

#: src/iterators/intoiterator.md
#, fuzzy
msgid ""
"Note that `IntoIter` and `Item` are linked: the iterator must have the same "
"`Item` type, which means that it returns `Option<Item>`"
msgstr ""
"请注意，“IntoIter”和“Item”已关联：迭代器必须具有相同的“Item”类型，这意味着它"
"会返回“Option\n"
"\n"
"”"

#: src/iterators/intoiterator.md
msgid "The example iterates over all combinations of x and y coordinates."
msgstr "此示例对 x 坐标和 y 坐标的所有组合进行了迭代。"

#: src/iterators/intoiterator.md
msgid ""
"Try iterating over the grid twice in `main`. Why does this fail? Note that "
"`IntoIterator::into_iter` takes ownership of `self`."
msgstr ""
"请尝试在 `main` 中对网格进行两次迭代。为什么会失败？请注意，`IntoIterator::"
"into_iter` 获得了 `self` 的所有权。"

#: src/iterators/intoiterator.md
msgid ""
"Fix this issue by implementing `IntoIterator` for `&Grid` and storing a "
"reference to the `Grid` in `GridIter`."
msgstr ""
"如要解决此问题，请为 `&Grid` 实现 `IntoIterator`，并在 `GridIter` 中存储对 "
"`Grid` 的引用。"

#: src/iterators/intoiterator.md
msgid ""
"The same problem can occur for standard library types: `for e in "
"some_vector` will take ownership of `some_vector` and iterate over owned "
"elements from that vector. Use `for e in &some_vector` instead, to iterate "
"over references to elements of `some_vector`."
msgstr ""
"对于标准库类型，可能会出现同样的问题：`for e in some_vector` 将获得` "
"some_vector` 的所有权，并迭代该矢量中的自有元素。请改用 `for e in "
"&some_vector` 来迭代 `some_vector` 的元素的引用。"

#: src/iterators/fromiterator.md
msgid "FromIterator"
msgstr "FromIterator"

#: src/iterators/fromiterator.md
msgid ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"lets you build a collection from an [`Iterator`](https://doc.rust-lang.org/"
"std/iter/trait.Iterator.html)."
msgstr ""
"[`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html) "
"让您可通过 [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html) 构建一个集合。"

#: src/iterators/fromiterator.md
msgid "\"prime_squares: {prime_squares:?}\""
msgstr "\"prime_squares: {prime_squares:?}\""

#: src/iterators/fromiterator.md
#, fuzzy
msgid "`Iterator` implements"
msgstr "“Iterator”"

#: src/iterators/fromiterator.md
msgid "There are two ways to specify `B` for this method:"
msgstr "可以通过两种方式为此方法指定 `B`："

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"With the \"turbofish\": `some_iterator.collect::<COLLECTION_TYPE>()`, as "
"shown. The `_` shorthand used here lets Rust infer the type of the `Vec` "
"elements."
msgstr ""
"使用 `turbofish` 时：`some_iterator.collect::<COLLECTION_TYPE>()`，如下所示。"
"通过此处所用的 `_` 简写形式，Rust 能够推理 `Vec` 元素的类型。"

#: src/iterators/fromiterator.md
msgid ""
"With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`. "
"Rewrite the example to use this form."
msgstr ""
"使用类型推理功能时：`let prime_squares: Vec<_> = some_iterator.collect()`。将"
"示例重写成使用这种形式。"

#: src/iterators/fromiterator.md
#, fuzzy
msgid ""
"There are basic implementations of `FromIterator` for `Vec`, `HashMap`, etc. "
"There are also more specialized implementations which let you do cool things "
"like convert an `Iterator<Item = Result<V, E>>` into a `Result<Vec<V>, E>`."
msgstr ""
"还有一些实现，让您可执行一些很酷的操作，比如 将 `Iterator<Item = Result<V, "
"E>>` 转换成 `Result<Vec<V>, E>`。"

#: src/iterators/exercise.md
#, fuzzy
msgid ""
"In this exercise, you will need to find and use some of the provided methods "
"in the [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) "
"trait to implement a complex calculation."
msgstr ""
"您可以自行实现 [`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) 特征："

#: src/iterators/exercise.md
#, fuzzy
msgid ""
"Copy the following code to <https://play.rust-lang.org/> and make the tests "
"pass. Use an iterator expression and `collect` the result to construct the "
"return value."
msgstr ""
"将以下代码复制到 <https://play.rust-lang.org/>，然后设法通过测试。请尽量避免"
"为中间结果分配“Vec”："

#: src/iterators/exercise.md src/iterators/solution.md
#, fuzzy
msgid ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`,\n"
"/// wrapping around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"
msgstr ""
"/// Calculate the differences between elements of `values` offset by "
"`offset`, wrapping\n"
"/// around from the end of `values` to the beginning.\n"
"///\n"
"/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.\n"

#: src/modules.md
msgid "[Modules](./modules/modules.md) (5 minutes)"
msgstr ""

#: src/modules.md
msgid "[Filesystem Hierarchy](./modules/filesystem.md) (5 minutes)"
msgstr ""

#: src/modules.md
msgid "[Visibility](./modules/visibility.md) (5 minutes)"
msgstr ""

#: src/modules.md
msgid "[use, super, self](./modules/paths.md) (10 minutes)"
msgstr ""

#: src/modules.md
#, fuzzy
msgid ""
"[Exercise: Modules for a GUI Library](./modules/exercise.md) (15 minutes)"
msgstr "练习：面向 GUI 库的模块"

#: src/modules.md
msgid "This segment should take about 40 minutes"
msgstr ""

#: src/modules/modules.md
msgid "We have seen how `impl` blocks let us namespace functions to a type."
msgstr "我们已看了“impl”块如何让我们将函数的命名空间建为一种类型。"

#: src/modules/modules.md
msgid "Similarly, `mod` lets us namespace types and functions:"
msgstr "同样，“mod”让我们可为类型和函数建立命名空间："

#: src/modules/modules.md
msgid "\"In the foo module\""
msgstr "\"In the foo module\""

#: src/modules/modules.md
msgid "\"In the bar module\""
msgstr "\"In the bar module\""

#: src/modules/modules.md
msgid ""
"Packages provide functionality and include a `Cargo.toml` file that "
"describes how to build a bundle of 1+ crates."
msgstr ""
"包提供功能，并包含一个描述如何构建包含 1 个以上 crate 的捆绑包的“Cargo."
"toml”文件。"

#: src/modules/modules.md
msgid ""
"Crates are a tree of modules, where a binary crate creates an executable and "
"a library crate compiles to a library."
msgstr ""
"crate 是一种模块树，其中的二进制 crate 会创建一个可执行文件，而库 crate 会编"
"译为库。"

#: src/modules/modules.md
msgid "Modules define organization, scope, and are the focus of this section."
msgstr "模块定义了组织和范围，并且是本部分的重点。"

#: src/modules/filesystem.md
msgid ""
"Omitting the module content will tell Rust to look for it in another file:"
msgstr "如果省略模块内容，则会指示 Rust 在另一个文件中查找："

#: src/modules/filesystem.md
msgid ""
"This tells rust that the `garden` module content is found at `src/garden."
"rs`. Similarly, a `garden::vegetables` module can be found at `src/garden/"
"vegetables.rs`."
msgstr ""
"这会告知 Rust 可以在“src/garden.rs”中找到“garden”模块内容。同样，您可以"
"在“src/garden/vegetables.rs”中找到“garden::vegetables”模块。"

#: src/modules/filesystem.md
msgid "The `crate` root is in:"
msgstr "“crate”根目录位于："

#: src/modules/filesystem.md
msgid "`src/lib.rs` (for a library crate)"
msgstr "“src/lib.rs”（对于库 crate）"

#: src/modules/filesystem.md
msgid "`src/main.rs` (for a binary crate)"
msgstr "“src/main.rs”（对于二进制文件 crate）"

#: src/modules/filesystem.md
msgid ""
"Modules defined in files can be documented, too, using \"inner doc "
"comments\". These document the item that contains them -- in this case, a "
"module."
msgstr ""
"也可以使用“内部文档注释”对文件中定义的模块进行记录。这些用于记录包含它们的项"
"（在本例中为模块）。"

#: src/modules/filesystem.md
msgid ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"
msgstr ""
"//! This module implements the garden, including a highly performant "
"germination\n"
"//! implementation.\n"

#: src/modules/filesystem.md
msgid "// Re-export types from this module.\n"
msgstr "// Re-export types from this module.\n"

#: src/modules/filesystem.md
msgid "/// Sow the given seed packets.\n"
msgstr "/// Sow the given seed packets.\n"

#: src/modules/filesystem.md
msgid "/// Harvest the produce in the garden that is ready.\n"
msgstr "/// Harvest the produce in the garden that is ready.\n"

#: src/modules/filesystem.md
msgid ""
"Before Rust 2018, modules needed to be located at `module/mod.rs` instead of "
"`module.rs`, and this is still a working alternative for editions after 2018."
msgstr ""
"在 Rust 2018 之前的版本中，模块需要位于“module/mod.rs”而非“module.rs”中，对"
"于 2018 年之后的版本而言，这仍是有效的替代方案。"

#: src/modules/filesystem.md
msgid ""
"The main reason to introduce `filename.rs` as alternative to `filename/mod."
"rs` was because many files named `mod.rs` can be hard to distinguish in IDEs."
msgstr ""
"引入“filename.rs”来替代“filename/mod.rs”的主要原因是，许多名为“mod.rs”的文件"
"在 IDE 中可能难以区分。"

#: src/modules/filesystem.md
msgid "Deeper nesting can use folders, even if the main module is a file:"
msgstr "即使主模块是文件，更深层的嵌套也可以使用文件夹："

#: src/modules/filesystem.md
msgid ""
"The place rust will look for modules can be changed with a compiler "
"directive:"
msgstr "Rust 寻找模块的位置可通过编译器指令更改："

#: src/modules/filesystem.md
#, fuzzy
msgid "\"some/path.rs\""
msgstr "\"some/path.rs\""

#: src/modules/filesystem.md
msgid ""
"This is useful, for example, if you would like to place tests for a module "
"in a file named `some_module_test.rs`, similar to the convention in Go."
msgstr ""
"例如，如果您想将某个模块的测试放在名为“some_module_test.rs”的文件中（类似于 "
"Go 中的惯例），这样做很有用。"

#: src/modules/visibility.md
msgid "Modules are a privacy boundary:"
msgstr "模块是一种隐私边界："

#: src/modules/visibility.md
msgid "Module items are private by default (hides implementation details)."
msgstr "默认情况下，模块项是私有的（隐藏实现详情）。"

#: src/modules/visibility.md
msgid "Parent and sibling items are always visible."
msgstr "父项和同级子项始终可见。"

#: src/modules/visibility.md
msgid ""
"In other words, if an item is visible in module `foo`, it's visible in all "
"the descendants of `foo`."
msgstr ""
"换言之，如果某个项在模块“foo”中可见，那么该项在“foo”的所有后代中均可见。"

#: src/modules/visibility.md
msgid "\"outer::private\""
msgstr "\"outer::private\""

#: src/modules/visibility.md
msgid "\"outer::public\""
msgstr "\"outer::public\""

#: src/modules/visibility.md
msgid "\"outer::inner::private\""
msgstr "\"outer::inner::private\""

#: src/modules/visibility.md
msgid "\"outer::inner::public\""
msgstr "\"outer::inner::public\""

#: src/modules/visibility.md
msgid "Use the `pub` keyword to make modules public."
msgstr "使用“pub”关键字将模块设为公开。"

#: src/modules/visibility.md
msgid ""
"Additionally, there are advanced `pub(...)` specifiers to restrict the scope "
"of public visibility."
msgstr "此外，您还可以使用高级“pub(...)”说明符来限制公开可见的范围。"

#: src/modules/visibility.md
msgid ""
"See the [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)."
msgstr ""
"请参阅 [Rust 参考](https://doc.rust-lang.org/reference/visibility-and-"
"privacy.html#pubin-path-pubcrate-pubsuper-and-pubself)。"

#: src/modules/visibility.md
msgid "Configuring `pub(crate)` visibility is a common pattern."
msgstr "配置“pub(crate)”可见性是一种常见模式。"

#: src/modules/visibility.md
msgid "Less commonly, you can give visibility to a specific path."
msgstr "您可以为特定路径授予可见性，这种情况不太常见。"

#: src/modules/visibility.md
msgid ""
"In any case, visibility must be granted to an ancestor module (and all of "
"its descendants)."
msgstr "在任何情况下，都必须向祖先模块（及其所有后代）授予可见性。"

#: src/modules/paths.md
msgid "use, super, self"
msgstr "use、super、self"

#: src/modules/paths.md
msgid ""
"A module can bring symbols from another module into scope with `use`. You "
"will typically see something like this at the top of each module:"
msgstr ""
"一个模块可以使用“use”将另一个模块的符号全部纳入。您通常在每个模块的顶部会看到"
"如下内容："

#: src/modules/paths.md
msgid "Paths"
msgstr "路径"

#: src/modules/paths.md
msgid "Paths are resolved as follows:"
msgstr "路径解析如下："

#: src/modules/paths.md
msgid "As a relative path:"
msgstr "作为相对路径："

#: src/modules/paths.md
msgid "`foo` or `self::foo` refers to `foo` in the current module,"
msgstr "`foo` 或 `self::foo` 是指当前模块中的 `foo`，"

#: src/modules/paths.md
msgid "`super::foo` refers to `foo` in the parent module."
msgstr "“super::foo”是指父模块中的“foo”。"

#: src/modules/paths.md
msgid "As an absolute path:"
msgstr "作为绝对路径："

#: src/modules/paths.md
msgid "`crate::foo` refers to `foo` in the root of the current crate,"
msgstr "`crate::foo` 是指当前 crate 的根中的 `foo`，"

#: src/modules/paths.md
msgid "`bar::foo` refers to `foo` in the `bar` crate."
msgstr "“bar::foo”是指“bar”crate 中的“foo”。"

#: src/modules/paths.md
msgid ""
"It is common to \"re-export\" symbols at a shorter path. For example, the "
"top-level `lib.rs` in a crate might have"
msgstr ""
"通常使用较短的路径来 “重新导出”符号。例如，crate 中的顶层 `lib.rs` 文件可能会"

#: src/modules/paths.md
msgid ""
"making `DiskStorage` and `NetworkStorage` available to other crates with a "
"convenient, short path."
msgstr ""
"通过便捷的短路径，使得 `DiskStorage` 和 `NetworkStorage` 可供其他 crate 使"
"用。"

#: src/modules/paths.md
msgid ""
"For the most part, only items that appear in a module need to be `use`'d. "
"However, a trait must be in scope to call any methods on that trait, even if "
"a type implementing that trait is already in scope. For example, to use the "
"`read_to_string` method on a type implementing the `Read` trait, you need to "
"`use std::io::Read`."
msgstr ""
"在大多数情况下，只有模块中显示的项才需通过 `use` 引入。不过，即使实现该 "
"trait 的类型已处于作用域内，如要调用该 trait 的任何方法，仍需将该 trait 引入"
"到作用域内。例如，如需对实现 `Read` trait 的类型使用 `read_to_string` 方法，"
"您需要使用 `use std::io::Read` 引入。"

#: src/modules/paths.md
msgid ""
"The `use` statement can have a wildcard: `use std::io::*`. This is "
"discouraged because it is not clear which items are imported, and those "
"might change over time."
msgstr ""
"`use` 语句可以包含通配符：`use std::io::*`。但不推荐这种做法，因为不清楚导入"
"了哪些项，并且这些内容可能会随时间而变化。"

#: src/modules/exercise.md
msgid ""
"In this exercise, you will reorganize a small GUI Library implementation. "
"This library defines a `Widget` trait and a few implementations of that "
"trait, as well as a `main` function."
msgstr ""

#: src/modules/exercise.md
#, fuzzy
msgid ""
"It is typical to put each type or set of closely-related types into its own "
"module, so each widget type should get its own module."
msgstr ""
"在本练习中，您需要将课程 “方法和特征”部分的 GUI 库练习重新整理为一组模块。通"
"常情况下，将每种类型或一组密切相关的类型放入各自的模块中，因此每种 widget 类"
"型都应拥有自己的模块。"

#: src/modules/exercise.md
#, fuzzy
msgid "Cargo Setup"
msgstr "设置"

#: src/modules/exercise.md
msgid ""
"The Rust playground only supports one file, so you will need to make a Cargo "
"project on your local filesystem:"
msgstr ""
"Rust Playground 仅支持一个文件，因此您需要在本地文件系统上创建一个 Cargo 项"
"目："

#: src/modules/exercise.md
#, fuzzy
msgid ""
"Edit the resulting `src/main.rs` to add `mod` statements, and add additional "
"files in the `src` directory."
msgstr "修改 `src/main.rs` 以添加 `mod` 语句，并在 `src` 目录中添加其他文件。"

#: src/modules/exercise.md
msgid "Source"
msgstr ""

#: src/modules/exercise.md
msgid "Here's the single-module implementation of the GUI library:"
msgstr ""

#: src/modules/exercise.md src/modules/solution.md
msgid "/// Natural width of `self`.\n"
msgstr "/// Natural width of `self`.\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "/// Draw the widget into a buffer.\n"
msgstr "/// Draw the widget into a buffer.\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "/// Draw the widget on standard output.\n"
msgstr "/// Draw the widget on standard output.\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"{buffer}\""
msgstr "\"{buffer}\""

#: src/modules/exercise.md
msgid "// Add 4 paddings for borders\n"
msgstr "// Add 4 paddings for borders\n"

#: src/modules/exercise.md
#, fuzzy
msgid ""
"// TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use "
"the\n"
"        // ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+-{:-<inner_width$}-+\""
msgstr "\"+-{:-<inner_width$}-+\""

#: src/modules/exercise.md src/modules/solution.md src/testing/unit-tests.md
#: src/testing/solution.md
msgid "\"\""
msgstr "\"\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"| {:^inner_width$} |\""
msgstr "\"| {:^inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+={:=<inner_width$}=+\""
msgstr "\"+={:=<inner_width$}=+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"| {:inner_width$} |\""
msgstr "\"| {:inner_width$} |\""

#: src/modules/exercise.md src/modules/solution.md
msgid "// add a bit of padding\n"
msgstr "// add a bit of padding\n"

#: src/modules/exercise.md src/modules/solution.md
msgid "\"+{:-<width$}+\""
msgstr "\"+{:-<width$}+\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"|{:^width$}|\""
msgstr "\"|{:^width$}|\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"Rust GUI Demo 1.23\""
msgstr "\"Rust GUI Demo 1.23\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"This is a small text GUI demo.\""
msgstr "\"This is a small text GUI demo.\""

#: src/modules/exercise.md src/modules/solution.md
msgid "\"Click me!\""
msgstr "\"Click me!\""

#: src/modules/exercise.md
msgid ""
"Encourage students to divide the code in a way that feels natural for them, "
"and get accustomed to the required `mod`, `use`, and `pub` declarations. "
"Afterward, discuss what organizations are most idiomatic."
msgstr ""
"鼓励学生按照自己认为合适的方式划分代码，并熟悉必需的 `mod`、`use` 和 `pub` 声"
"明。之后，讨论哪些组织方式最符合惯例。"

#: src/modules/solution.md
msgid "// ---- src/widgets.rs ----\n"
msgstr "// ---- src/widgets.rs ----\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/label.rs ----\n"
msgstr "// ---- src/widgets/label.rs ----\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Label-width\n"
msgstr "// ANCHOR_END: Label-width\n"

#: src/modules/solution.md
msgid "// ANCHOR: Label-draw_into\n"
msgstr "// ANCHOR：Label-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Label-draw_into\n"
msgstr "// ANCHOR_END：Label-draw_into\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/button.rs ----\n"
msgstr "// ---- src/widgets/button.rs ----\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Button-width\n"
msgstr "// ANCHOR_END: Button-width\n"

#: src/modules/solution.md
msgid "// ANCHOR: Button-draw_into\n"
msgstr "// ANCHOR：Button-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Button-draw_into\n"
msgstr "// ANCHOR_END：Button-draw_into\n"

#: src/modules/solution.md
msgid "// ---- src/widgets/window.rs ----\n"
msgstr "// ---- src/widgets/window.rs ----\n"

#: src/modules/solution.md
msgid ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"
msgstr ""
"// ANCHOR_END: Window-width\n"
"        // Add 4 paddings for borders\n"

#: src/modules/solution.md
msgid "// ANCHOR: Window-draw_into\n"
msgstr "// ANCHOR：Window-draw_into\n"

#: src/modules/solution.md
msgid "// ANCHOR_END: Window-draw_into\n"
msgstr "// ANCHOR_END：Window-draw_into\n"

#: src/modules/solution.md
msgid ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"
msgstr ""
"// TODO: after learning about error handling, you can change\n"
"        // draw_into to return Result<(), std::fmt::Error>. Then use\n"
"        // the ?-operator here instead of .unwrap().\n"

#: src/modules/solution.md
msgid "// ---- src/main.rs ----\n"
msgstr "// ---- src/main.rs ----\n"

#: src/testing.md
msgid "[Test Modules](./testing/unit-tests.md) (5 minutes)"
msgstr ""

#: src/testing.md
msgid "[Other Types of Tests](./testing/other.md) (10 minutes)"
msgstr ""

#: src/testing.md
msgid "[Useful Crates](./testing/useful-crates.md) (3 minutes)"
msgstr ""

#: src/testing.md
msgid "[GoogleTest](./testing/googletest.md) (5 minutes)"
msgstr ""

#: src/testing.md
msgid "[Mocking](./testing/mocking.md) (5 minutes)"
msgstr ""

#: src/testing.md
msgid "[Compiler Lints and Clippy](./testing/lints.md) (5 minutes)"
msgstr ""

#: src/testing.md
msgid "[Exercise: Luhn Algorithm](./testing/exercise.md) (30 minutes)"
msgstr ""

#: src/testing/unit-tests.md
msgid "Unit Tests"
msgstr "单元测试"

#: src/testing/unit-tests.md
msgid "Rust and Cargo come with a simple unit test framework:"
msgstr "Rust 和 Cargo 随附了一个简单的单元测试框架："

#: src/testing/unit-tests.md
msgid "Unit tests are supported throughout your code."
msgstr "单元测试在您的整个代码中都受支持。"

#: src/testing/unit-tests.md
msgid "Integration tests are supported via the `tests/` directory."
msgstr "您可以通过 `tests/` 目录来支持集成测试。"

#: src/testing/unit-tests.md
#, fuzzy
msgid ""
"Tests are marked with `#[test]`. Unit tests are often put in a nested "
"`tests` module, using `#[cfg(test)]` to conditionally compile them only when "
"building tests."
msgstr ""
"测试标有 `#[test]`。单元测试通常会放在嵌套的 `tests` 模块中，仅在构建测试时使"
"用 `#[cfg(test)]` 对它们进行有条件地编译。"

#: src/testing/unit-tests.md
#, fuzzy
msgid "\"Hello World\""
msgstr "Hello World!"

#: src/testing/unit-tests.md
msgid "This lets you unit test private helpers."
msgstr "这样一来，您可以对专用帮助程序进行单元测试。"

#: src/testing/unit-tests.md
msgid "The `#[cfg(test)]` attribute is only active when you run `cargo test`."
msgstr "仅当您运行 `cargo test` 时，`#[cfg(test)]` 属性才有效。"

#: src/testing/unit-tests.md
msgid "Run the tests in the playground in order to show their results."
msgstr "在 Playground 中运行测试显示测试结果。"

#: src/testing/other.md
msgid "Integration Tests"
msgstr "集成测试"

#: src/testing/other.md
msgid "If you want to test your library as a client, use an integration test."
msgstr "如果您想要以客户的身份测试您的库，请使用集成测试。"

#: src/testing/other.md
msgid "Create a `.rs` file under `tests/`:"
msgstr "在 `tests/` 下方创建一个 `.rs` 文件："

#: src/testing/other.md
msgid "// tests/my_library.rs\n"
msgstr "// tests/my_library.rs\n"

#: src/testing/other.md
msgid "These tests only have access to the public API of your crate."
msgstr "这些测试只能使用您的 crate 的公共 API。"

#: src/testing/other.md
msgid "Documentation Tests"
msgstr "文档测试"

#: src/testing/other.md
msgid "Rust has built-in support for documentation tests:"
msgstr "Rust 本身就支持文档测试："

#: src/testing/other.md
msgid ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"
msgstr ""
"/// Shortens a string to the given length.\n"
"///\n"
"/// ```\n"
"/// # use playground::shorten_string;\n"
"/// assert_eq!(shorten_string(\"Hello World\", 5), \"Hello\");\n"
"/// assert_eq!(shorten_string(\"Hello World\", 20), \"Hello World\");\n"
"/// ```\n"

#: src/testing/other.md
msgid "Code blocks in `///` comments are automatically seen as Rust code."
msgstr "`///` 注释中的代码块会自动被视为 Rust 代码。"

#: src/testing/other.md
msgid "The code will be compiled and executed as part of `cargo test`."
msgstr "代码会作为 `cargo test` 的一部分进行编译和执行。"

#: src/testing/other.md
#, fuzzy
msgid ""
"Adding `#` in the code will hide it from the docs, but will still compile/"
"run it."
msgstr "在代码中添加 `#` 可以将其隐藏在文档中，但系统仍会编译/运行它。"

#: src/testing/other.md
msgid ""
"Test the above code on the [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0)."
msgstr ""
"在 [Rust Playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=3ce2ad13ea1302f6572cb15cd96becf0) "
"上测试上述代码。"

#: src/testing/useful-crates.md
msgid "Rust comes with only basic support for writing tests."
msgstr "Rust 仅为编写测试提供基本支持。"

#: src/testing/useful-crates.md
msgid "Here are some additional crates which we recommend for writing tests:"
msgstr "下面列出了我们建议在编写测试时使用的一些其他 crate："

#: src/testing/useful-crates.md
msgid ""
"[googletest](https://docs.rs/googletest): Comprehensive test assertion "
"library in the tradition of GoogleTest for C++."
msgstr ""
"[googletest](https://docs.rs/googletest)：遵从 GoogleTest for C++ 传统的综合"
"测试断言库。"

#: src/testing/useful-crates.md
msgid "[proptest](https://docs.rs/proptest): Property-based testing for Rust."
msgstr "[proptest](https://docs.rs/proptest)：基于属性的测试，适用于 Rust。"

#: src/testing/useful-crates.md
msgid ""
"[rstest](https://docs.rs/rstest): Support for fixtures and parameterised "
"tests."
msgstr "[rstest](https://docs.rs/rstest)：支持固件和参数化测试。"

#: src/testing/googletest.md
#, fuzzy
msgid ""
"The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test "
"assertions using _matchers_:"
msgstr ""
"[googletest](https://docs.rs/googletest)：遵从 GoogleTest for C++ 传统的综合"
"测试断言库。"

#: src/testing/googletest.md
msgid "\"baz\""
msgstr "\"baz\""

#: src/testing/googletest.md
msgid "\"xyz\""
msgstr "\"xyz\""

#: src/testing/googletest.md
msgid ""
"If we change the last element to `\"!\"`, the test fails with a structured "
"error message pin-pointing the error:"
msgstr ""
"如果我们将最后一个元素更改为 `\"!\"`，测试将失败，并会提供详细的错误消息来指"
"出错误的位置："

#: src/testing/googletest.md
msgid ""
"GoogleTest is not part of the Rust Playground, so you need to run this "
"example in a local environment. Use `cargo add googletest` to quickly add it "
"to an existing Cargo project."
msgstr ""
"GoogleTest 不是 Rust Playground 的一部分，因此您需要在本地环境中运行此示例。"
"使用 `cargo add googletest` 快速将其添加到现有 Cargo 项目中。"

#: src/testing/googletest.md
msgid ""
"The `use googletest::prelude::*;` line imports a number of [commonly used "
"macros and types](https://docs.rs/googletest/latest/googletest/prelude/index."
"html)."
msgstr ""
"`use googletest::prelude::*;` 行会导入一些 [常用的宏和类型](https://docs.rs/"
"googletest/latest/googletest/prelude/index.html)。"

#: src/testing/googletest.md
msgid "This just scratches the surface, there are many builtin matchers."
msgstr "这只是冰山一角，还有很多内置匹配器。"

#: src/testing/googletest.md
msgid ""
"A particularly nice feature is that mismatches in multi-line strings strings "
"are shown as a diff:"
msgstr ""
"有一个特别实用的功能是，多行字符串中的不匹配问题会以差异的形式显示出来："

#: src/testing/googletest.md
msgid ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"                 Rust's strong typing guides the way,\\n\\\n"
"                 Secure code you'll write.\""

#: src/testing/googletest.md
msgid ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""
msgstr ""
"\"Memory safety found,\\n\\\n"
"            Rust's silly humor guides the way,\\n\\\n"
"            Secure code you'll write.\""

#: src/testing/googletest.md
msgid "shows a color-coded diff (colors not shown here):"
msgstr "显示用颜色标识的差异（此处未显示颜色）："

#: src/testing/googletest.md
msgid ""
"The crate is a Rust port of [GoogleTest for C++](https://google.github.io/"
"googletest/)."
msgstr ""
"crate 是 [适用于 C++ 的 GoogleTest](https://google.github.io/googletest/) 的 "
"Rust 移植版。"

#: src/testing/googletest.md
msgid "GoogleTest is available for use in AOSP."
msgstr "GoogleTest 可以在 AOSP 中使用。"

#: src/testing/mocking.md
msgid ""
"For mocking, [Mockall](https://docs.rs/mockall/) is a widely used library. "
"You need to refactor your code to use traits, which you can then quickly "
"mock:"
msgstr ""
"对于模拟，[Mockall](https://docs.rs/mockall/) 是一个广泛使用的库。您需要重构"
"代码才能使用 trait，然后便可很快地对其进行模拟："

#: src/testing/mocking.md
msgid ""
"The advice here is for Android (AOSP) where Mockall is the recommended "
"mocking library. There are other [mocking libraries available on crates.io]"
"(https://crates.io/keywords/mock), in particular in the area of mocking HTTP "
"services. The other mocking libraries work in a similar fashion as Mockall, "
"meaning that they make it easy to get a mock implementation of a given trait."
msgstr ""
"此处的建议适用于 Android (AOSP)，其中推荐使用 Mockall 模拟库。[crates.io 上还"
"有其他模拟库可用](https://crates.io/keywords/mock)，尤其是在模拟 HTTP 服务方"
"面。其他模拟库的工作方式与 Mockall 类似，这意味着通过它们您可轻松实现对指定 "
"trait 的模拟。"

#: src/testing/mocking.md
msgid ""
"Note that mocking is somewhat _controversial_: mocks allow you to completely "
"isolate a test from its dependencies. The immediate result is faster and "
"more stable test execution. On the other hand, the mocks can be configured "
"wrongly and return output different from what the real dependencies would do."
msgstr ""
"请注意，模拟在某种程度上具有 _争议性_：借助模拟，您可以将测试与其依赖项完全隔"
"离。最立竿见影的是，测试作业会更快且更稳定。另一方面，模拟对象的配置可能出现"
"错误，并返回与真实依赖项不同的输出。"

#: src/testing/mocking.md
msgid ""
"If at all possible, it is recommended that you use the real dependencies. As "
"an example, many databases allow you to configure an in-memory backend. This "
"means that you get the correct behavior in your tests, plus they are fast "
"and will automatically clean up after themselves."
msgstr ""
"建议您尽可能使用真实依赖项。例如，许多数据库都支持您配置内存后端。这意味着，"
"您可以在测试中获得正确的功能行为，而且测试速度会很快并会自动清理。"

#: src/testing/mocking.md
msgid ""
"Similarly, many web frameworks allow you to start an in-process server which "
"binds to a random port on `localhost`. Always prefer this over mocking away "
"the framework since it helps you test your code in the real environment."
msgstr ""
"同样，许多 Web 框架都支持您启动进程内服务器，该服务器会绑定到 `localhost` 上"
"的随机端口。相比模拟框架，请始终优先选择这种方式，因为这有助于您在真实环境中"
"测试代码。"

#: src/testing/mocking.md
msgid ""
"Mockall is not part of the Rust Playground, so you need to run this example "
"in a local environment. Use `cargo add mockall` to quickly add Mockall to an "
"existing Cargo project."
msgstr ""
"Mockall 不是 Rust Playground 的一部分，因此您需要在本地环境中运行此示例。使"
"用 `cargo add mockall` 快速将 Mockall 添加到现有 Cargo 项目中。"

#: src/testing/mocking.md
msgid ""
"Mockall has a lot more functionality. In particular, you can set up "
"expectations which depend on the arguments passed. Here we use this to mock "
"a cat which becomes hungry 3 hours after the last time it was fed:"
msgstr ""
"Mockall 具有更多功能。具体而言，您可以设置基于传递参数的预期值。在这里，我们"
"使用该功能来模拟一只猫，它在上次被喂食的 3 小时后会感到饥饿："

#: src/testing/mocking.md
msgid ""
"You can use `.times(n)` to limit the number of times a mock method can be "
"called to `n` --- the mock will automatically panic when dropped if this "
"isn't satisfied."
msgstr ""
"您可以使用 `.times(n)` 将调用模拟方法的次数限制为 `n`，如果不满足此条件，模拟"
"对象被释放时会自动 panic。"

#: src/testing/lints.md
msgid ""
"The Rust compiler produces fantastic error messages, as well as helpful "
"built-in lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even "
"more lints, organized into groups that can be enabled per-project."
msgstr ""
"Rust 编译器会生成出色的错误消息，并提供实用的内置 lint 功能。[Clippy]"
"(https://doc.rust-lang.org/clippy/) 提供了更多 lint 功能，采用按组分类方式，"
"并可按项目灵活启用。"

#: src/testing/lints.md
msgid "\"X probably fits in a u16, right? {}\""
msgstr "\"X probably fits in a u16, right? {}\""

#: src/testing/lints.md
msgid ""
"Run the code sample and examine the error message. There are also lints "
"visible here, but those will not be shown once the code compiles. Switch to "
"the Playground site to show those lints."
msgstr ""
"运行代码示例并检查错误消息。此处还会显示一些 lint，但是一旦完成代码编译，就不"
"会再显示这些 lint。切换到 Playground 网站以显示这些 lint。"

#: src/testing/lints.md
msgid ""
"After resolving the lints, run `clippy` on the playground site to show "
"clippy warnings. Clippy has extensive documentation of its lints, and adds "
"new lints (including default-deny lints) all the time."
msgstr ""
"解析完 lint 之后，请在 Playground 网站上运行 `clippy`，以显示 clippy 警告。"
"Clippy 提供了大量的 lint 文档，并且在不断添加新的 lint（包括默认拒绝 lint）。"

#: src/testing/lints.md
msgid ""
"Note that errors or warnings with `help: ...` can be fixed with `cargo fix` "
"or via your editor."
msgstr ""
"请注意，带有 `help: ...` 的错误或警告可以通过 `cargo Fix` 或编辑器进行修复。"

#: src/testing/exercise.md
msgid "Luhn Algorithm"
msgstr "卢恩算法"

#: src/testing/exercise.md
msgid ""
"The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used "
"to validate credit card numbers. The algorithm takes a string as input and "
"does the following to validate the credit card number:"
msgstr ""
"[卢恩算法](https://zh.wikipedia.org/wiki/卢恩算法)用于验证信用卡号。该算法将"
"字符串作为输入内容，并执行以下操作来验证信用卡号："

#: src/testing/exercise.md
msgid "Ignore all spaces. Reject number with less than two digits."
msgstr "忽略所有空格。拒绝少于两位的号码。"

#: src/testing/exercise.md
msgid ""
"Moving from **right to left**, double every second digit: for the number "
"`1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`."
msgstr ""
"从**右到左**，将偶数位的数字乘二。对于数字“1234”，我们将“3”和“1”乘二；对于数"
"字“98765”，将“6”和“8”乘二。"

#: src/testing/exercise.md
msgid ""
"After doubling a digit, sum the digits if the result is greater than 9. So "
"doubling `7` becomes `14` which becomes `1 + 4 = 5`."
msgstr ""
"将一个数字乘二后，如果结果大于 9，则将每位数字相加。因此，将“7”乘二得“14”，然"
"后“1 + 4 = 5”。"

#: src/testing/exercise.md
msgid "Sum all the undoubled and doubled digits."
msgstr "将所有未乘二和已乘二的数字相加。"

#: src/testing/exercise.md
msgid "The credit card number is valid if the sum ends with `0`."
msgstr "如果总和以“0”结尾，则信用卡号有效。"

#: src/testing/exercise.md
msgid ""
"The provided code provides a buggy implementation of the luhn algorithm, "
"along with two basic unit tests that confirm that most the algorithm is "
"implemented correctly."
msgstr ""
"提供的代码提供了一个有缺陷的 Luhn 算法实现，附带两个基本单元测试，用于验证大"
"部分算法是否正确实现。"

#: src/testing/exercise.md
#, fuzzy
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and write additional "
"tests to uncover bugs in the provided implementation, fixing any bugs you "
"find."
msgstr ""
"将以下代码复制到 <https://play.rust-lang.org/>，并填入缺少的函数和方法："

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4263 9826 4026 9299\""
msgstr "\"4263 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4539 3195 0343 6467\""
msgstr "\"4539 3195 0343 6467\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"7992 7398 713\""
msgstr "\"7992 7398 713\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4223 9826 4026 9299\""
msgstr "\"4223 9826 4026 9299\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"4539 3195 0343 6476\""
msgstr "\"4539 3195 0343 6476\""

#: src/testing/exercise.md src/testing/solution.md
msgid "\"8273 1232 7352 0569\""
msgstr "\"8273 1232 7352 0569\""

#: src/testing/solution.md
msgid "// This is the buggy version that appears in the problem.\n"
msgstr "// This is the buggy version that appears in the problem.\n"

#: src/testing/solution.md
msgid "// This is the solution and passes all of the tests below.\n"
msgstr "// This is the solution and passes all of the tests below.\n"

#: src/testing/solution.md
msgid "\"1234 5678 1234 5670\""
msgstr "\"1234 5678 1234 5670\""

#: src/testing/solution.md
msgid "\"Is {cc_number} a valid credit card number? {}\""
msgstr "\"Is {cc_number} a valid credit card number? {}\""

#: src/testing/solution.md
msgid "\"yes\""
msgstr "\"yes\""

#: src/testing/solution.md
msgid "\"no\""
msgstr "\"no\""

#: src/testing/solution.md
msgid "\"foo 0 0\""
msgstr "\"foo 0 0\""

#: src/testing/solution.md
msgid "\" \""
msgstr "\" \""

#: src/testing/solution.md
msgid "\"  \""
msgstr "\"  \""

#: src/testing/solution.md
msgid "\"    \""
msgstr "\"    \""

#: src/testing/solution.md
msgid "\"0\""
msgstr "\"0\""

#: src/testing/solution.md
msgid "\" 0 0 \""
msgstr "\" 0 0 \""

#: src/welcome-day-4-afternoon.md
msgid "[Error Handling](./error-handling.md) (45 minutes)"
msgstr ""

#: src/welcome-day-4-afternoon.md
msgid "[Unsafe Rust](./unsafe-rust.md) (1 hour and 5 minutes)"
msgstr ""

#: src/welcome-day-4-afternoon.md
msgid "Including 10 minute breaks, this session should take about 2 hours"
msgstr ""

#: src/error-handling.md
msgid "[Panics](./error-handling/panics.md) (3 minutes)"
msgstr ""

#: src/error-handling.md
msgid "[Try Operator](./error-handling/try.md) (5 minutes)"
msgstr ""

#: src/error-handling.md
msgid "[Try Conversions](./error-handling/try-conversions.md) (5 minutes)"
msgstr ""

#: src/error-handling.md
msgid "[Error Trait](./error-handling/error.md) (5 minutes)"
msgstr ""

#: src/error-handling.md
msgid ""
"[thiserror and anyhow](./error-handling/thiserror-and-anyhow.md) (5 minutes)"
msgstr ""

#: src/error-handling.md
msgid ""
"[Exercise: Rewriting with Result](./error-handling/exercise.md) (20 minutes)"
msgstr ""

#: src/error-handling/panics.md
msgid "Rust handles fatal errors with a \"panic\"."
msgstr "Rust 通过 “panic”机制处理严重错误。"

#: src/error-handling/panics.md
msgid "Rust will trigger a panic if a fatal error happens at runtime:"
msgstr "如果运行时发生严重错误，Rust 会触发 panic："

#: src/error-handling/panics.md
msgid "\"v[100]: {}\""
msgstr "\"v[100]: {}\""

#: src/error-handling/panics.md
msgid "Panics are for unrecoverable and unexpected errors."
msgstr "Panic 用于指示不可恢复的意外错误。"

#: src/error-handling/panics.md
msgid "Panics are symptoms of bugs in the program."
msgstr "Panic反映了程序中的 bug 问题。"

#: src/error-handling/panics.md
msgid "Runtime failures like failed bounds checks can panic"
msgstr "运行时失败（例如边界检查失败）可能会触发 panic"

#: src/error-handling/panics.md
msgid "Assertions (such as `assert!`) panic on failure"
msgstr "断言（例如 `assert!`）在失败时会触发 panic"

#: src/error-handling/panics.md
msgid "Purpose-specific panics can use the `panic!` macro."
msgstr "针对特定用途的 panic 可以使用 `panic!` 宏。"

#: src/error-handling/panics.md
msgid ""
"A panic will \"unwind\" the stack, dropping values just as if the functions "
"had returned."
msgstr "使用 panic 会 “展开”堆栈，并丢弃对应的值，就像函数已经返回一样。"

#: src/error-handling/panics.md
msgid ""
"Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable."
msgstr "如果崩溃不可接受，请使用不会触发 panic 的 API（例如 `Vec::get`）。"

#: src/error-handling/panics.md
msgid ""
"By default, a panic will cause the stack to unwind. The unwinding can be "
"caught:"
msgstr "默认情况下，panic 会导致堆栈展开。您可以捕获展开信息："

#: src/error-handling/panics.md
msgid "\"No problem here!\""
msgstr "\"No problem here!\""

#: src/error-handling/panics.md
msgid "\"{result:?}\""
msgstr "\"{result:?}\""

#: src/error-handling/panics.md
msgid "\"oh no!\""
msgstr "\"oh no!\""

#: src/error-handling/panics.md
msgid ""
"Catching is unusual; do not attempt to implement exceptions with "
"`catch_unwind`!"
msgstr "捕获异常；请勿尝试使用 `catch_unwind` 实现异常！"

#: src/error-handling/panics.md
msgid ""
"This can be useful in servers which should keep running even if a single "
"request crashes."
msgstr ""
"如果服务器需要持续运行（即使是在请求发生崩溃的情况下）， 此方法十分有用。"

#: src/error-handling/panics.md
msgid "This does not work if `panic = 'abort'` is set in your `Cargo.toml`."
msgstr "如果您在 `Cargo.toml` 中设置了 `panic = 'abort'`，此方法不会生效。"

#: src/error-handling/try.md
#, fuzzy
msgid ""
"Runtime errors like connection-refused or file-not-found are handled with "
"the `Result` type, but matching this type on every call can be cumbersome. "
"The try-operator `?` is used to return errors to the caller. It lets you "
"turn the common"
msgstr ""
"运行时错误（如连接遭拒或未找到文件）使用 `Result` 类型进行处理，但在每次调用"
"中匹配此类型会很繁琐。try 运算符 `?` 用于将错误返回给调用方。它能将常用命令"

#: src/error-handling/try.md
msgid "into the much simpler"
msgstr "转换成更简单的命令"

#: src/error-handling/try.md
#, fuzzy
msgid "We can use this to simplify our error handling code:"
msgstr "我们可以用它来简化错误处理代码："

#: src/error-handling/try.md
msgid "//fs::write(\"config.dat\", \"alice\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"alice\").unwrap();\n"

#: src/error-handling/try.md src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
msgid "\"config.dat\""
msgstr "\"config.dat\""

#: src/error-handling/try.md src/error-handling/try-conversions.md
msgid "\"username or error: {username:?}\""
msgstr "\"username or error: {username:?}\""

#: src/error-handling/try.md
msgid "Simplify the `read_username` function to use `?`."
msgstr "简化 `read_username` 函数以使用 `?`。"

#: src/error-handling/try.md
msgid "The `username` variable can be either `Ok(string)` or `Err(error)`."
msgstr "`username` 变量可以是 `Ok(string)` 或 `Err(error)`。"

#: src/error-handling/try.md
msgid ""
"Use the `fs::write` call to test out the different scenarios: no file, empty "
"file, file with username."
msgstr ""
"可以使用 `fs::write` 调用来测试不同的场景：没有文件、空文件、包含用户名的文"
"件。"

#: src/error-handling/try.md
msgid ""
"Note that `main` can return a `Result<(), E>` as long as it implements `std::"
"process:Termination`. In practice, this means that `E` implements `Debug`. "
"The executable will print the `Err` variant and return a nonzero exit status "
"on error."
msgstr ""
"请注意，`main` 函数只要实现 `std::process:Terality`，就可以返回 `Result<(), "
"E>`。在实践中，这意味着 `E` 会实现 `Debug`。可执行文件将输出 `Err` 变体，并在"
"出现错误时返回非零退出状态。"

#: src/error-handling/try-conversions.md
msgid ""
"The effective expansion of `?` is a little more complicated than previously "
"indicated:"
msgstr "`?` 的有效展开比前面介绍的内容略微复杂一些："

#: src/error-handling/try-conversions.md
msgid "works the same as"
msgstr "效果等同于"

#: src/error-handling/try-conversions.md
#, fuzzy
msgid ""
"The `From::from` call here means we attempt to convert the error type to the "
"type returned by the function. This makes it easy to encapsulate errors into "
"higher-level errors."
msgstr ""
"此处的 `From::from` 调用表示，我们尝试将错误类型转换为 函数返回的类型："

#: src/error-handling/try-conversions.md
msgid "\"IO error: {e}\""
msgstr "\"IO error: {e}\""

#: src/error-handling/try-conversions.md
#, fuzzy
msgid "\"Found no username in {path}\""
msgstr "\"Found no username in {0}\""

#: src/error-handling/try-conversions.md
#: src/error-handling/thiserror-and-anyhow.md
msgid "//fs::write(\"config.dat\", \"\").unwrap();\n"
msgstr "//fs::write(\"config.dat\", \"\").unwrap();\n"

#: src/error-handling/try-conversions.md
msgid ""
"The `?` operator must return a value compatible with the return type of the "
"function. For `Result`, it means that the error types have to be compatible. "
"A function that returns `Result<T, ErrorOuter>` can only use `?` on a value "
"of type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the "
"same type or if `ErrorOuter` implements `From<ErrorInner>`."
msgstr ""

#: src/error-handling/try-conversions.md
msgid ""
"A common alternative to a `From` implementation is `Result::map_err`, "
"especially when the conversion only happens in one place."
msgstr ""
"`From` 实现的常见替代方案是 `Result::map_err`，尤其是只在一个位置进行转换时。"

#: src/error-handling/try-conversions.md
msgid ""
"There is no compatibility requirement for `Option`. A function returning "
"`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and "
"`U` types."
msgstr ""

#: src/error-handling/try-conversions.md
msgid ""
"A function that returns `Result` cannot use `?` on `Option` and vice versa. "
"However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok` "
"turns `Result` into `Option`."
msgstr ""

#: src/error-handling/error.md
msgid "Dynamic Error Types"
msgstr "动态错误类型"

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Sometimes we want to allow any type of error to be returned without writing "
"our own enum covering all the different possibilities. The `std::error::"
"Error` trait makes it easy to create a trait object that can contain any "
"error."
msgstr ""
"有时，我们需要允许返回任意类型的错误，但又不想自己手动编写枚举来涵盖所有不同"
"的可能性。 `std::error::Error` 可以让我们轻松做到这一点。"

#: src/error-handling/error.md
msgid "\"count.dat\""
msgstr "\"count.dat\""

#: src/error-handling/error.md
msgid "\"1i3\""
msgstr "\"1i3\""

#: src/error-handling/error.md
msgid "\"Count: {count}\""
msgstr "\"Count: {count}\""

#: src/error-handling/error.md
msgid "\"Error: {err}\""
msgstr "\"Error: {err}\""

#: src/error-handling/error.md
msgid ""
"The `read_count` function can return `std::io::Error` (from file operations) "
"or `std::num::ParseIntError` (from `String::parse`)."
msgstr ""
"`read_count` 函数可以返回 `std::io::Error`（通过文件操作）或 `std::num::"
"ParseIntError`（通过 `String::parse`）。"

#: src/error-handling/error.md
#, fuzzy
msgid ""
"Boxing errors saves on code, but gives up the ability to cleanly handle "
"different error cases differently in the program. As such it's generally not "
"a good idea to use `Box<dyn Error>` in the public API of a library, but it "
"can be a good option in a program where you just want to display the error "
"message somewhere."
msgstr ""
"虽然这可以省却编写代码的麻烦，但也会导致我们无法在程序中以不同的方式正常处理"
"不同的 错误情况。因此，在库的公共 API 中使用 `Box<dyn Error>` 通常不是一个好"
"主意。 但是对于您只需要在某处显示错误消息的程序来说，这不失为一个 很好的选"
"择。"

#: src/error-handling/error.md
msgid ""
"Make sure to implement the `std::error::Error` trait when defining a custom "
"error type so it can be boxed. But if you need to support the `no_std` "
"attribute, keep in mind that the `std::error::Error` trait is currently "
"compatible with `no_std` in [nightly](https://github.com/rust-lang/rust/"
"issues/103765) only."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"The [`thiserror`](https://docs.rs/thiserror/) and [`anyhow`](https://docs.rs/"
"anyhow/) crates are widely used to simplify error handling."
msgstr ""
"[`thiserror`](https://docs.rs/thiserror/) 和 [`anyhow`](https://docs.rs/"
"anyhow/) crate 用于简化错误处理。`thiserror` 有助于创建实现 `From<T>` 的自定"
"义错误类型。`anyhow` 有助于处理函数中的错误，包括为错误添加上下文信息。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`thiserror` is often used in libraries to create custom error types that "
"implement `From<T>`."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow` is often used by applications to help with error handling in "
"functions, including adding contextual information to your errors."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Found no username in {0}\""
msgstr "\"Found no username in {0}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Failed to open {path}\""
msgstr "\"Failed to open {path}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Failed to read\""
msgstr "\"Failed to read\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Username: {username}\""
msgstr "\"Username: {username}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "\"Error: {err:?}\""
msgstr "\"Error: {err:?}\""

#: src/error-handling/thiserror-and-anyhow.md
msgid "`thiserror`"
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"The `Error` derive macro is provided by `thiserror`, and has lots of useful "
"attributes to help define error types in a compact way."
msgstr ""
"`Error` 派生宏由 `thiserror` 提供，并且具有许多有用的属性（例如 "
"`#[error]`），有助于定义有用的错误类型。"

#: src/error-handling/thiserror-and-anyhow.md
msgid "The `std::error::Error` trait is derived automatically."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
msgid "The message from `#[error]` is used to derive the `Display` trait."
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
msgid "`anyhow`"
msgstr ""

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"`anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such "
"it's again generally not a good choice for the public API of a library, but "
"is widely used in applications."
msgstr "”是“Result\\<V, anyhow::Error>”的类型别名。"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid "`anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`."
msgstr "“anyhow::Result"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"Actual error type inside of it can be extracted for examination if necessary."
msgstr "“anyhow::Error”本质上是“Box"

#: src/error-handling/thiserror-and-anyhow.md
#, fuzzy
msgid ""
"Functionality provided by `anyhow::Result<T>` may be familiar to Go "
"developers, as it provides similar usage patterns and ergonomics to `(T, "
"error)` from Go."
msgstr ""
"”的封装容器。因此，就像前面提到的那样，在库的公共 API 中 使用它通常不是一个好"
"主意。但是它广泛用于应用中。\n"
"\n"
"如果需要，可以提取其内部的实际错误类型进行检查。\n"
"\n"
"Go 开发者可能会十分熟悉 `anyhow::Result<T>` 提供的功能， 因为它的使用模式和工"
"效学设计与 Go 的 `(T, error)` 方法十分相似。"

#: src/error-handling/thiserror-and-anyhow.md
msgid ""
"`anyhow::Context` is a trait implemented for the standard `Result` and "
"`Option` types. `use anyhow::Context` is necessary to enable `.context()` "
"and `.with_context()` on those types."
msgstr ""

#: src/error-handling/exercise.md
#, fuzzy
msgid "Exercise: Rewriting with Result"
msgstr "练习：使用 Result 进行重写"

#: src/error-handling/exercise.md
msgid ""
"The following implements a very simple parser for an expression language. "
"However, it handles errors by panicking. Rewrite it to instead use idiomatic "
"error handling and propagate errors to a return from `main`. Feel free to "
"use `thiserror` and `anyhow`."
msgstr ""
"以下代码实现了一个非常简单的表达式语言解析器。不过，它通过 panic 机制来处理错"
"误。请重写该代码，改用惯用的错误处理方式，并将错误传播到 `main` 函数的返回"
"值。您可以随意使用 `thiserror` 和 `anyhow`。"

#: src/error-handling/exercise.md
msgid ""
"HINT: start by fixing error handling in the `parse` function. Once that is "
"working correctly, update `Tokenizer` to implement "
"`Iterator<Item=Result<Token, TokenizerError>>` and handle that in the parser."
msgstr ""
"提示：请先修复 `parse` 函数中的错误处理问题。该部分正常运行后，请更新 "
"`Tokenizer` 以实现 `Iterator<Item=Result<Token, TokenizerError>>`，并在解析器"
"中进行相应处理。"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// An arithmetic operator.\n"
msgstr "/// An arithmetic operator.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A token in the expression language.\n"
msgstr "/// A token in the expression language.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// An expression in the expression language.\n"
msgstr "/// An expression in the expression language.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A reference to a variable.\n"
msgstr "/// A reference to a variable.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A literal number.\n"
msgstr "/// A literal number.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "/// A binary operation.\n"
msgstr "/// A binary operation.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'z'"
msgstr "'z'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'_'"
msgstr "'_'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'+'"
msgstr "'+'"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "'-'"
msgstr "'-'"

#: src/error-handling/exercise.md
msgid "\"Unexpected character {c}\""
msgstr "\"Unexpected character {c}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"Unexpected end of input\""
msgstr "\"Unexpected end of input\""

#: src/error-handling/exercise.md
msgid "\"Invalid 32-bit integer'\""
msgstr "\"Invalid 32-bit integer'\""

#: src/error-handling/exercise.md
msgid "\"Unexpected token {tok:?}\""
msgstr "\"Unexpected token {tok:?}\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "// Look ahead to parse a binary operation if present.\n"
msgstr "// Look ahead to parse a binary operation if present.\n"

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"10+foo+20-30\""
msgstr "\"10+foo+20-30\""

#: src/error-handling/exercise.md src/error-handling/solution.md
msgid "\"{expr:?}\""
msgstr "\"{expr:?}\""

#: src/error-handling/solution.md
msgid "\"Unexpected character '{0}' in input\""
msgstr "\"Unexpected character '{0}' in input\""

#: src/error-handling/solution.md
msgid "\"Tokenizer error: {0}\""
msgstr "\"Tokenizer error: {0}\""

#: src/error-handling/solution.md
msgid "\"Unexpected token {0:?}\""
msgstr "\"Unexpected token {0:?}\""

#: src/error-handling/solution.md
msgid "\"Invalid number\""
msgstr "\"Invalid number\""

#: src/unsafe-rust.md
msgid "[Unsafe](./unsafe-rust/unsafe.md) (5 minutes)"
msgstr ""

#: src/unsafe-rust.md
msgid ""
"[Dereferencing Raw Pointers](./unsafe-rust/dereferencing.md) (10 minutes)"
msgstr ""

#: src/unsafe-rust.md
msgid "[Mutable Static Variables](./unsafe-rust/mutable-static.md) (5 minutes)"
msgstr ""

#: src/unsafe-rust.md
msgid "[Unions](./unsafe-rust/unions.md) (5 minutes)"
msgstr ""

#: src/unsafe-rust.md
msgid "[Unsafe Functions](./unsafe-rust/unsafe-functions.md) (5 minutes)"
msgstr ""

#: src/unsafe-rust.md
msgid "[Unsafe Traits](./unsafe-rust/unsafe-traits.md) (5 minutes)"
msgstr ""

#: src/unsafe-rust.md
msgid "[Exercise: FFI Wrapper](./unsafe-rust/exercise.md) (30 minutes)"
msgstr ""

#: src/unsafe-rust/unsafe.md
msgid "The Rust language has two parts:"
msgstr "Rust 语言包含两个部分："

#: src/unsafe-rust/unsafe.md
msgid "**Safe Rust:** memory safe, no undefined behavior possible."
msgstr "\\*\\*安全 Rust：\\*\\*内存安全，没有潜在的未定义行为。"

#: src/unsafe-rust/unsafe.md
msgid ""
"**Unsafe Rust:** can trigger undefined behavior if preconditions are "
"violated."
msgstr "\\*\\*不安全 Rust：\\*\\*如果违反了前提条件，可能会触发未定义的行为。"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"We saw mostly safe Rust in this course, but it's important to know what "
"Unsafe Rust is."
msgstr ""
"本课程中出现的大多为“安全 Rust”，但是了解“不安全 Rust”的定义 非常重要。"

#: src/unsafe-rust/unsafe.md
msgid ""
"Unsafe code is usually small and isolated, and its correctness should be "
"carefully documented. It is usually wrapped in a safe abstraction layer."
msgstr ""
"不安全的代码通常内容很少而且与其他代码隔离， 其正确性也应得到仔细记录。这类代"
"码通常封装在安全的抽象层中。"

#: src/unsafe-rust/unsafe.md
msgid "Unsafe Rust gives you access to five new capabilities:"
msgstr "不安全 Rust 提供了五种新功能："

#: src/unsafe-rust/unsafe.md
msgid "Dereference raw pointers."
msgstr "解引用原始指针。"

#: src/unsafe-rust/unsafe.md
msgid "Access or modify mutable static variables."
msgstr "访问或修改可变的静态变量。"

#: src/unsafe-rust/unsafe.md
msgid "Access `union` fields."
msgstr "访问 `union` 字段。"

#: src/unsafe-rust/unsafe.md
msgid "Call `unsafe` functions, including `extern` functions."
msgstr "调用 `unsafe` 函数，包括 `extern` 函数。"

#: src/unsafe-rust/unsafe.md
msgid "Implement `unsafe` traits."
msgstr "实现 `unsafe` trait。"

#: src/unsafe-rust/unsafe.md
msgid ""
"We will briefly cover unsafe capabilities next. For full details, please see "
"[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html) and the [Rustonomicon](https://doc.rust-lang.org/nomicon/)."
msgstr ""
"下面，我们将简要介绍这些不安全功能。如需了解完整详情，请参阅 [《Rust 手册》"
"第 19.1 章](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) 和 "
"[Rustonomicon](https://doc.rust-lang.org/nomicon/)。"

#: src/unsafe-rust/unsafe.md
#, fuzzy
msgid ""
"Unsafe Rust does not mean the code is incorrect. It means that developers "
"have turned off some compiler safety features and have to write correct code "
"by themselves. It means the compiler no longer enforces Rust's memory-safety "
"rules."
msgstr ""
"不安全 Rust 并不意味着代码不正确，而是这意味着开发者已停用 编译器的安全功能，"
"必须自行编写正确的 代码。也就是说，编译器不再强制执行 Rust 的内存安全规则。"

#: src/unsafe-rust/dereferencing.md
msgid "Creating pointers is safe, but dereferencing them requires `unsafe`:"
msgstr "创建指针是安全的操作，但解引用指针需要使用 `unsafe` 方法："

#: src/unsafe-rust/dereferencing.md
msgid "\"careful!\""
msgstr "\"careful!\""

#: src/unsafe-rust/dereferencing.md
msgid ""
"// Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"
msgstr ""
"// Safe because r1 and r2 were obtained from references and so are\n"
"    // guaranteed to be non-null and properly aligned, the objects "
"underlying\n"
"    // the references from which they were obtained are live throughout the\n"
"    // whole unsafe block, and they are not accessed either through the\n"
"    // references or concurrently through any other pointers.\n"

#: src/unsafe-rust/dereferencing.md
msgid "\"r1 is: {}\""
msgstr "\"r1 is: {}\""

#: src/unsafe-rust/dereferencing.md
msgid "\"uhoh\""
msgstr "\"uhoh\""

#: src/unsafe-rust/dereferencing.md
msgid "\"r2 is: {}\""
msgstr "\"r2 is: {}\""

#: src/unsafe-rust/dereferencing.md
msgid ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"
msgstr ""
"// NOT SAFE. DO NOT DO THIS.\n"
"    /*\n"
"    let r3: &String = unsafe { &*r1 };\n"
"    drop(s);\n"
"    println!(\"r3 is: {}\", *r3);\n"
"    */"

#: src/unsafe-rust/dereferencing.md
msgid ""
"It is good practice (and required by the Android Rust style guide) to write "
"a comment for each `unsafe` block explaining how the code inside it "
"satisfies the safety requirements of the unsafe operations it is doing."
msgstr ""
"我们建议（而且 Android Rust 样式指南要求）为每个 `unsafe` 代码块编写一条注"
"释， 说明该代码块中的代码如何满足其所执行的不安全操作的 安全要求。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"In the case of pointer dereferences, this means that the pointers must be "
"[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:"
msgstr ""
"对于指针解除引用，这意味着指针必须为 [_valid_](https://doc.rust-lang.org/std/"
"ptr/index.html#safety)，即："

#: src/unsafe-rust/dereferencing.md
msgid "The pointer must be non-null."
msgstr "指针必须为非 null。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"The pointer must be _dereferenceable_ (within the bounds of a single "
"allocated object)."
msgstr "指针必须是 _dereferenceable_（在单个已分配对象的边界内）。"

#: src/unsafe-rust/dereferencing.md
msgid "The object must not have been deallocated."
msgstr "对象不得已取消分配。"

#: src/unsafe-rust/dereferencing.md
msgid "There must not be concurrent accesses to the same location."
msgstr "不得并发访问相同位置。"

#: src/unsafe-rust/dereferencing.md
msgid ""
"If the pointer was obtained by casting a reference, the underlying object "
"must be live and no reference may be used to access the memory."
msgstr ""
"如果通过转换引用类型来获取指针，则底层对象必须处于活跃状态， 而且不得使用任何"
"引用来访问内存。"

#: src/unsafe-rust/dereferencing.md
msgid "In most cases the pointer must also be properly aligned."
msgstr "在大多数情况下，指针还必须正确对齐。"

#: src/unsafe-rust/dereferencing.md
#, fuzzy
msgid ""
"The \"NOT SAFE\" section gives an example of a common kind of UB bug: `*r1` "
"has the `'static` lifetime, so `r3` has type `&'static String`, and thus "
"outlives `s`. Creating a reference from a pointer requires _great care_."
msgstr ""
"“不安全”部分给出了一个常见 UB bug 的示例：`*r1` 的生命周期为 `'static`，因此 "
"`r3` 为 `&'static String` 类型，存在时间比 `s` 更长。从指针创建引用需要 _特别"
"注意_。"

#: src/unsafe-rust/mutable-static.md
msgid "It is safe to read an immutable static variable:"
msgstr "读取不可变的静态变量是安全的操作："

#: src/unsafe-rust/mutable-static.md
#, fuzzy
msgid "\"Hello, world!\""
msgstr "Hello World!"

#: src/unsafe-rust/mutable-static.md
msgid "\"HELLO_WORLD: {HELLO_WORLD}\""
msgstr "\"HELLO_WORLD: {HELLO_WORLD}\""

#: src/unsafe-rust/mutable-static.md
msgid ""
"However, since data races can occur, it is unsafe to read and write mutable "
"static variables:"
msgstr "但是，读取和写入可变的静态变量是不安全的，因为这可能会 造成数据争用："

#: src/unsafe-rust/mutable-static.md
msgid "\"COUNTER: {COUNTER}\""
msgstr "\"COUNTER: {COUNTER}\""

#: src/unsafe-rust/mutable-static.md
msgid ""
"The program here is safe because it is single-threaded. However, the Rust "
"compiler is conservative and will assume the worst. Try removing the "
"`unsafe` and see how the compiler explains that it is undefined behavior to "
"mutate a static from multiple threads."
msgstr ""
"此处的程序是安全的，因为它是单线程的。不过，Rust 编译器比较保守，会做出最坏的"
"假设。请尝试移除 `unsafe`，看看编译器如何解释从多个线程中修改静态变量是一种未"
"定义的行为。"

#: src/unsafe-rust/mutable-static.md
msgid ""
"Using a mutable static is generally a bad idea, but there are some cases "
"where it might make sense in low-level `no_std` code, such as implementing a "
"heap allocator or working with some C APIs."
msgstr ""
"通常，我们不建议使用可变的静态变量，但在某些情况下，在低层级 `no_std` 代码中"
"可能需要这样做， 例如实现堆分配器或使用某些 C API。"

#: src/unsafe-rust/unions.md
msgid "Unions are like enums, but you need to track the active field yourself:"
msgstr "联合体与枚举类似，但您需要自行跟踪活跃字段："

#: src/unsafe-rust/unions.md
msgid "\"int: {}\""
msgstr "\"int: {}\""

#: src/unsafe-rust/unions.md
msgid "\"bool: {}\""
msgstr "\"bool: {}\""

#: src/unsafe-rust/unions.md
#, fuzzy
msgid "// Undefined behavior!\n"
msgstr "Rust 没有运行时未定义行为："

#: src/unsafe-rust/unions.md
msgid ""
"Unions are very rarely needed in Rust as you can usually use an enum. They "
"are occasionally needed for interacting with C library APIs."
msgstr ""
"在 Rust 中很少需要用到联合体，因为您通常可以使用枚举。联合体只是偶尔用于 与 "
"C 库 API 进行交互。"

#: src/unsafe-rust/unions.md
msgid ""
"If you just want to reinterpret bytes as a different type, you probably want "
"[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn."
"transmute.html) or a safe wrapper such as the [`zerocopy`](https://crates.io/"
"crates/zerocopy) crate."
msgstr ""
"如果您只是想将字节重新解释为其他类型，则可能需要使用 [`std::mem::transmute`]"
"(https://doc.rust-lang.org/stable/std/mem/fn.transmute.html) 或 安全的封装容"
"器，例如 [`zerocopy`](https://crates.io/crates/zerocopy) crate。"

#: src/unsafe-rust/unsafe-functions.md
msgid "Calling Unsafe Functions"
msgstr "调用 Unsafe 函数"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"A function or method can be marked `unsafe` if it has extra preconditions "
"you must uphold to avoid undefined behaviour:"
msgstr ""
"如果函数或方法具有额外的前提条件，您必须遵守这些前提条件来避免未定义的行为， "
"则可以将该函数或方法标记为 `unsafe`："

#: src/unsafe-rust/unsafe-functions.md src/unsafe-rust/exercise.md
#: src/unsafe-rust/solution.md src/android/interoperability/with-c.md
#: src/android/interoperability/with-c/rust.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/exercises/chromium/build-rules.md src/bare-metal/aps/inline-assembly.md
#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"C\""
msgstr "\"C\""

#: src/unsafe-rust/unsafe-functions.md
msgid "\"🗻∈🌏\""
msgstr "\"🗻∈🌏\""

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"// Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"
msgstr ""
"// Safe because the indices are in the correct order, within the bounds of\n"
"    // the string slice, and lie on UTF-8 sequence boundaries.\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"emoji: {}\""
msgstr "\"emoji: {}\""

#: src/unsafe-rust/unsafe-functions.md
msgid "\"char count: {}\""
msgstr "\"char count: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid "// Undefined behavior if abs misbehaves.\n"
msgstr "Rust 没有运行时未定义行为："

#: src/unsafe-rust/unsafe-functions.md
msgid "\"Absolute value of -3 according to C: {}\""
msgstr "\"Absolute value of -3 according to C: {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe {\n"
"    // emojis.get_unchecked(0..3) }));\n"
msgstr ""
"// Not upholding the UTF-8 encoding requirement breaks memory safety!\n"
"    // println!(\"emoji: {}\", unsafe { emojis.get_unchecked(0..3) });\n"
"    // println!(\"char count: {}\", count_chars(unsafe { emojis."
"get_unchecked(0..3) }));\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "Writing Unsafe Functions"
msgstr "编写 Unsafe 函数"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"You can mark your own functions as `unsafe` if they require particular "
"conditions to avoid undefined behaviour."
msgstr ""
"如果您自己编写的函数需要满足特定条件以避免未定义的行为， 您可以将这些函数标记"
"为 `unsafe`。"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"
msgstr ""
"/// Swaps the values pointed to by the given pointers.\n"
"///\n"
"/// # Safety\n"
"///\n"
"/// The pointers must be valid and properly aligned.\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "// Safe because ...\n"
msgstr "// Safe because ...\n"

#: src/unsafe-rust/unsafe-functions.md
msgid "\"a = {}, b = {}\""
msgstr "\"a = {}, b = {}\""

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"`get_unchecked`, like most `_unchecked` functions, is unsafe, because it can "
"create UB if the range is incorrect. `abs` is incorrect for a different "
"reason: it is an external function (FFI). Calling external functions is "
"usually only a problem when those functions do things with pointers which "
"might violate Rust's memory model, but in general any C function might have "
"undefined behaviour under any arbitrary circumstances."
msgstr ""
"这个问题通常仅存在于使用指针执行违反 Rust 内存模型的操作的外部函数中。 但一般"
"而言，任何 C 函数都有可能在任意情况下出现未定义行为。"

#: src/unsafe-rust/unsafe-functions.md
msgid ""
"The `\"C\"` in this example is the ABI; [other ABIs are available too]"
"(https://doc.rust-lang.org/reference/items/external-blocks.html)."
msgstr ""
"本例中的“C”是 ABI；[也可以使用其他 ABI](https://doc.rust-lang.org/reference/"
"items/external-blocks.html)。"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"We wouldn't actually use pointers for a `swap` function - it can be done "
"safely with references."
msgstr "实际上，我们不会这样使用指针，因为使用引用可以安全地达到相同的目的。"

#: src/unsafe-rust/unsafe-functions.md
#, fuzzy
msgid ""
"Note that unsafe code is allowed within an unsafe function without an "
"`unsafe` block. We can prohibit this with `#[deny(unsafe_op_in_unsafe_fn)]`. "
"Try adding it and see what happens. This will likely change in a future Rust "
"edition."
msgstr ""
"请注意，在不安全函数中，可以在没有 `unsafe` 代码块的情况下使用不安全代码。我"
"们可以 使用 `#[deny(unsafe_op_in_unsafe_fn)]` 来禁止此行为。请尝试添加该命"
"令，看看会出现什么情况。"

#: src/unsafe-rust/unsafe-traits.md
msgid "Implementing Unsafe Traits"
msgstr "实现 Unsafe Trait"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"Like with functions, you can mark a trait as `unsafe` if the implementation "
"must guarantee particular conditions to avoid undefined behaviour."
msgstr ""
"与函数一样，如果您在实现某个 trait 时必须保证特定条件来避免未定义的行为， 您"
"也可以将该 trait 标记为 `unsafe`。"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"For example, the `zerocopy` crate has an unsafe trait that looks [something "
"like this](https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html):"
msgstr ""
"例如，`zerocopy` crate 包含一个不安全的 trait， [大致内容是这样的](https://"
"docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html)："

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"
msgstr ""
"/// ...\n"
"/// # Safety\n"
"/// The type must have a defined representation and no padding.\n"

#: src/unsafe-rust/unsafe-traits.md
msgid "// Safe because u32 has a defined representation and no padding.\n"
msgstr "// Safe because u32 has a defined representation and no padding.\n"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"There should be a `# Safety` section on the Rustdoc for the trait explaining "
"the requirements for the trait to be safely implemented."
msgstr ""
"在 Rustdoc 中有关 trait 的章节下，有一个标题为 `# 安全` 的部分介绍了 安全实"
"现 trait 的要求。"

#: src/unsafe-rust/unsafe-traits.md
msgid ""
"The actual safety section for `AsBytes` is rather longer and more "
"complicated."
msgstr "实际上，与 `AsBytes` 相关的安全说明远比这里展示的更详尽、更复杂。"

#: src/unsafe-rust/unsafe-traits.md
msgid "The built-in `Send` and `Sync` traits are unsafe."
msgstr "内置的 `Send` 和 `Sync` trait 都是不安全的。"

#: src/unsafe-rust/exercise.md
msgid "Safe FFI Wrapper"
msgstr "安全 FFI 封装容器"

#: src/unsafe-rust/exercise.md
msgid ""
"Rust has great support for calling functions through a _foreign function "
"interface_ (FFI). We will use this to build a safe wrapper for the `libc` "
"functions you would use from C to read the names of files in a directory."
msgstr ""
"Rust 为通过 _外部函数接口_ (FFI) 调用函数提供了出色的支持。我们将使用它为 "
"`libc` 函数构建一个安全封装容器，用于从 C 代码中读取目录中的文件名称。"

#: src/unsafe-rust/exercise.md
msgid "You will want to consult the manual pages:"
msgstr "建议您参考以下手册页面："

#: src/unsafe-rust/exercise.md
msgid "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"
msgstr "[`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)"

#: src/unsafe-rust/exercise.md
msgid "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"
msgstr "[`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)"

#: src/unsafe-rust/exercise.md
msgid "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"
msgstr "[`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)"

#: src/unsafe-rust/exercise.md
msgid ""
"You will also want to browse the [`std::ffi`](https://doc.rust-lang.org/std/"
"ffi/) module. There you find a number of string types which you need for the "
"exercise:"
msgstr ""
"您还需要浏览[“std::ffi”](https://doc.rust-lang.org/std/ffi/)模块。在下方，您"
"会发现完成这个练习所需的多种字符串类型："

#: src/unsafe-rust/exercise.md
msgid "Encoding"
msgstr "编码"

#: src/unsafe-rust/exercise.md
msgid "Use"
msgstr "使用"

#: src/unsafe-rust/exercise.md
msgid ""
"[`str`](https://doc.rust-lang.org/std/primitive.str.html) and [`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"
msgstr ""
"[“str”](https://doc.rust-lang.org/std/primitive.str.html)和[“String”]"
"(https://doc.rust-lang.org/std/string/struct.String.html)"

#: src/unsafe-rust/exercise.md
msgid "UTF-8"
msgstr "UTF-8"

#: src/unsafe-rust/exercise.md
msgid "Text processing in Rust"
msgstr "用 Rust 进行文本处理"

#: src/unsafe-rust/exercise.md
msgid ""
"[`CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`CString`]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"
msgstr ""
"[“CStr”](https://doc.rust-lang.org/std/ffi/struct.CStr.html)和[“CString”]"
"(https://doc.rust-lang.org/std/ffi/struct.CString.html)"

#: src/unsafe-rust/exercise.md
msgid "NUL-terminated"
msgstr "以空字符结尾"

#: src/unsafe-rust/exercise.md
msgid "Communicating with C functions"
msgstr "与 C 函数通信"

#: src/unsafe-rust/exercise.md
msgid ""
"[`OsStr`](https://doc.rust-lang.org/std/ffi/struct.OsStr.html) and "
"[`OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)"
msgstr ""
"[“OsStr”](https://doc.rust-lang.org/std/ffi/struct.OsStr.html)和[“OsString”]"
"(https://doc.rust-lang.org/std/ffi/struct.OsString.html)"

#: src/unsafe-rust/exercise.md
msgid "OS-specific"
msgstr "特定于操作系统"

#: src/unsafe-rust/exercise.md
msgid "Communicating with the OS"
msgstr "与操作系统通信"

#: src/unsafe-rust/exercise.md
msgid "You will convert between all these types:"
msgstr "您将在以下所有类型之间进行转换："

#: src/unsafe-rust/exercise.md
msgid ""
"`&str` to `CString`: you need to allocate space for a trailing `\\0` "
"character,"
msgstr "将 `&str` 转换为 `CString`：您需要为尾随 `\\0` 字符分配空格，"

#: src/unsafe-rust/exercise.md
msgid "`CString` to `*const i8`: you need a pointer to call C functions,"
msgstr "将 `CString` 转换为 `\\*const i8` ：您需要一个指针来调用 C 函数，"

#: src/unsafe-rust/exercise.md
msgid ""
"`*const i8` to `&CStr`: you need something which can find the trailing `\\0` "
"character,"
msgstr ""
"将 `\\*const i8` 转换为 `&CStr` ：您需要一些能够找到尾随 `\\0` 字符的内容，"

#: src/unsafe-rust/exercise.md
#, fuzzy
msgid ""
"`&CStr` to `&[u8]`: a slice of bytes is the universal interface for \"some "
"unknown data\","
msgstr ""
"将 `&CStr` 转换为 `&\\[u8\\]` ：一个字节 Slice 是“一些未知数据”的通用接口，"

#: src/unsafe-rust/exercise.md
msgid ""
"`&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use [`OsStrExt`]"
"(https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to create it,"
msgstr ""
"将 `&\\[u8\\]` 转换为 `&OsStr` ：`&OsStr` 是向 `OsString` 迈进的一步，请使用"
"[`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html)来"
"创建它，"

#: src/unsafe-rust/exercise.md
msgid ""
"`&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to "
"return it and call `readdir` again."
msgstr ""
"将“&OsStr”转换为“OsString”：您需要克隆“&OsStr”中的数据，以便能够返回它并再次"
"调用“readdir”。"

#: src/unsafe-rust/exercise.md
msgid ""
"The [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html) also has a very "
"useful chapter about FFI."
msgstr ""
"[秘典](https://doc.rust-lang.org/nomicon/ffi.html) 中也有一个关于 FFI 的非常"
"实用的章节。"

#: src/unsafe-rust/exercise.md
msgid ""
"Copy the code below to <https://play.rust-lang.org/> and fill in the missing "
"functions and methods:"
msgstr ""
"将以下代码复制到 <https://play.rust-lang.org/>，并填入缺少的函数和方法："

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"macos\""
msgstr "\"macos\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"
msgstr "// Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"
msgstr ""
"// Layout according to the Linux man page for readdir(3), where ino_t and\n"
"    // off_t are resolved according to the definitions in\n"
"    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "// Layout according to the macOS man page for dir(5).\n"
msgstr "// Layout according to the macOS man page for dir(5).\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"x86_64\""
msgstr "\"x86_64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"
msgstr ""
"// See https://github.com/rust-lang/libc/issues/414 and the section on\n"
"        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).\n"
"        //\n"
"        // \"Platforms that existed before these updates were available\" "
"refers\n"
"        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and "
"PowerPC.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"readdir$INODE64\""
msgstr "\"readdir$INODE64\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"
msgstr ""
"// Call opendir and return a Ok value if that worked,\n"
"        // otherwise return Err with a message.\n"

#: src/unsafe-rust/exercise.md
msgid "// Keep calling readdir until we get a NULL pointer back.\n"
msgstr "// Keep calling readdir until we get a NULL pointer back.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "// Call closedir as needed.\n"
msgstr "// Call closedir as needed.\n"

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
#: src/android/interoperability/with-c/rust.md
msgid "\".\""
msgstr "\".\""

#: src/unsafe-rust/exercise.md src/unsafe-rust/solution.md
msgid "\"files: {:#?}\""
msgstr "\"files: {:#?}\""

#: src/unsafe-rust/solution.md
msgid "\"Invalid path: {err}\""
msgstr "\"Invalid path: {err}\""

#: src/unsafe-rust/solution.md
msgid "// SAFETY: path.as_ptr() cannot be NULL.\n"
msgstr "// SAFETY: path.as_ptr() cannot be NULL.\n"

#: src/unsafe-rust/solution.md
msgid "\"Could not open {:?}\""
msgstr "\"Could not open {:?}\""

#: src/unsafe-rust/solution.md
msgid ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"
msgstr ""
"// Keep calling readdir until we get a NULL pointer back.\n"
"        // SAFETY: self.dir is never NULL.\n"

#: src/unsafe-rust/solution.md
msgid "// We have reached the end of the directory.\n"
msgstr "// We have reached the end of the directory.\n"

#: src/unsafe-rust/solution.md
msgid ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"
msgstr ""
"// SAFETY: dirent is not NULL and dirent.d_name is NUL\n"
"        // terminated.\n"

#: src/unsafe-rust/solution.md
msgid "// SAFETY: self.dir is not NULL.\n"
msgstr "// SAFETY: self.dir is not NULL.\n"

#: src/unsafe-rust/solution.md
msgid "\"Could not close {:?}\""
msgstr "\"Could not close {:?}\""

#: src/unsafe-rust/solution.md
msgid "\"no-such-directory\""
msgstr "\"no-such-directory\""

#: src/unsafe-rust/solution.md
msgid "\"Non UTF-8 character in path\""
msgstr "\"Non UTF-8 character in path\""

#: src/unsafe-rust/solution.md
msgid "\"..\""
msgstr "\"..\""

#: src/unsafe-rust/solution.md
msgid "\"foo.txt\""
msgstr "\"foo.txt\""

#: src/unsafe-rust/solution.md
msgid "\"The Foo Diaries\\n\""
msgstr "\"The Foo Diaries\\n\""

#: src/unsafe-rust/solution.md
msgid "\"bar.png\""
msgstr "\"bar.png\""

#: src/unsafe-rust/solution.md
msgid "\"<PNG>\\n\""
msgstr "\"<PNG>\\n\""

#: src/unsafe-rust/solution.md
#, fuzzy
msgid "\"crab.rs\""
msgstr "\"crab.rs\""

#: src/unsafe-rust/solution.md
msgid "\"//! Crab\\n\""
msgstr "\"//! Crab\\n\""

#: src/android.md
msgid "Welcome to Rust in Android"
msgstr "欢迎来到Android 中的Rust"

#: src/android.md
#, fuzzy
msgid ""
"Rust is supported for system software on Android. This means that you can "
"write new services, libraries, drivers or even firmware in Rust (or improve "
"existing code as needed)."
msgstr ""
"Rust 支持Android 的原生平台开发。这意味着您可以在Rust 中编写新的操作系统服"
"务，以及扩展现有服务。"

#: src/android.md
msgid ""
"We will attempt to call Rust from one of your own projects today. So try to "
"find a little corner of your code base where we can move some lines of code "
"to Rust. The fewer dependencies and \"exotic\" types the better. Something "
"that parses some raw bytes would be ideal."
msgstr ""
"今天我们会尝试在你自己的项目中调用Rust。 所以试着在你的代码中找一小段来改成"
"Rust。 代码中越少依赖(dependencies)，越少“独特”的类型，越好。比如 一段解析原"
"始字符的代码就很理想。"

#: src/android.md
msgid ""
"The speaker may mention any of the following given the increased use of Rust "
"in Android:"
msgstr "鉴于 Android 中越来越多地使用 Rust，演讲者可能会提到以下任何一项："

#: src/android.md
msgid ""
"Service example: [DNS over HTTP](https://security.googleblog.com/2022/07/dns-"
"over-http3-in-android.html)"
msgstr ""
"服务示例：[DNS-over-HTTP](https://security.googleblog.com/2022/07/dns-over-"
"http3-in-android.html)"

#: src/android.md
msgid ""
"Libraries: [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/"
"appendix/rutabaga_gfx.html)"
msgstr ""
"库：[Rutabaga 虚拟图形接口](https://crosvm.dev/book/appendix/rutabaga_gfx."
"html)"

#: src/android.md
msgid ""
"Kernel Drivers: [Binder](https://lore.kernel.org/rust-for-linux/20231101-"
"rust-binder-v1-0-08ba9197f637@google.com/)"
msgstr ""
"内核驱动程序：[Binder](https://lore.kernel.org/rust-for-linux/20231101-rust-"
"binder-v1-0-08ba9197f637@google.com/)"

#: src/android.md
msgid ""
"Firmware: [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-"
"rust-in-android.html)"
msgstr ""
"固件：[pKVM 固件](https://security.googleblog.com/2023/10/bare-metal-rust-in-"
"android.html)"

#: src/android/setup.md
#, fuzzy
msgid ""
"We will be using a Cuttlefish Android Virtual Device to test our code. Make "
"sure you have access to one or create a new one with:"
msgstr ""
"我们将会使用Android 虚拟设备（Android Virtual Device）来测试我们的代码。 确保"
"你有权限访问一个，或者用以下命令创建一个新的："

#: src/android/setup.md
msgid ""
"Please see the [Android Developer Codelab](https://source.android.com/docs/"
"setup/start) for details."
msgstr ""
"更多细节请参考 [Android Developer Codelab](https://source.android.com/docs/"
"setup/start)."

#: src/android/setup.md
#, fuzzy
msgid ""
"Cuttlefish is a reference Android device designed to work on generic Linux "
"desktops. MacOS support is also planned."
msgstr ""
"Cuttlefish 是一款 Android 引用设备，专用于通用 Linux 桌面设备。此外，我们还计"
"划支持 MacOS。"

#: src/android/setup.md
msgid ""
"The Cuttlefish system image maintains high fidelity to real devices, and is "
"the ideal emulator to run many Rust use cases."
msgstr ""
"Cuttlefish 系统映像会保持媲美真实设备的高保真度，是运行许多 Rust 用例的理想模"
"拟器。"

#: src/android/build-rules.md
msgid "The Android build system (Soong) supports Rust via a number of modules:"
msgstr "Android 构建系统（Soong）通过一系列模块来支持Rust："

#: src/android/build-rules.md
#, fuzzy
msgid "Module Type"
msgstr ""
"\\| 模块类型      | 描"
"述                                                                                        "
"| \\|—————————|——————————————————————————————————————————————————| \\| "
"`rust_binary`     | Rust 二进制文"
"件。                                                                           "
"| \\| `rust_library`    | 生成Rust 库，并且提供 `rlib` 和 `dylib` 变"
"体。                       | \\| `rust_ffi`        | 生成可由 cc 模块使用的 "
"Rust C 库，并提供静态和共享变体。    | \\| `rust_proc_macro` | 生成 proc-"
"macro Rust 库。 这些宏与编译器插件类似。                     | \\| "
"`rust_test`       | 生成使用标准 Rust 自动化测试框架的 Rust 测试二进制文"
"件。                             | \\| `rust_fuzz`       | 生成使用 "
"libfuzzer 的 Rust 模糊测试二进制文"
"件。                                         | \\| `rust_protobuf`   | 生成源"
"代码，并生成为特定 protobuf 提供接口的 Rust 库。| \\| `rust_bindgen`    | 生"
"成源代码，并生成包含与 C 库的 Rust 绑定的 Rust 库。｜"

#: src/android/build-rules.md
msgid "Description"
msgstr "描述"

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_binary`"
msgstr "`rust_binary`"

#: src/android/build-rules.md
#, fuzzy
msgid "Produces a Rust binary."
msgstr "生成一个Rust二进制文件。"

#: src/android/build-rules.md
msgid "`rust_library`"
msgstr "`rust_library`"

#: src/android/build-rules.md
msgid "Produces a Rust library, and provides both `rlib` and `dylib` variants."
msgstr "生成一个 Rust 库，并提供 `rlib` 和 `dylib` 两种变体。"

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_ffi`"
msgstr "`rust_ffi `"

#: src/android/build-rules.md
msgid ""
"Produces a Rust C library usable by `cc` modules, and provides both static "
"and shared variants."
msgstr "生成一个可由 `cc` 模块使用的 Rust C 库，并提供静态和共享两种变体。"

#: src/android/build-rules.md
msgid "`rust_proc_macro`"
msgstr "`rust_proc_macro`"

#: src/android/build-rules.md
msgid ""
"Produces a `proc-macro` Rust library. These are analogous to compiler "
"plugins."
msgstr "生成“proc-macro”Rust 库。这些宏与编译器插件类似。"

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_test`"
msgstr "`rust_test `"

#: src/android/build-rules.md
msgid "Produces a Rust test binary that uses the standard Rust test harness."
msgstr "生成使用标准 Rust 测试框架的 Rust 测试二进制文件。"

#: src/android/build-rules.md
msgid "`rust_fuzz`"
msgstr "`rust_fuzz`"

#: src/android/build-rules.md
msgid "Produces a Rust fuzz binary leveraging `libfuzzer`."
msgstr "生成使用 `libfuzzer` 的 Rust 模糊测试二进制文件。"

#: src/android/build-rules.md
msgid "`rust_protobuf`"
msgstr "`rust_protobuf`"

#: src/android/build-rules.md
msgid ""
"Generates source and produces a Rust library that provides an interface for "
"a particular protobuf."
msgstr "生成源代码并生成为特定 protobuf 提供接口的 Rust 库。"

#: src/android/build-rules.md
#, fuzzy
msgid "`rust_bindgen`"
msgstr "`rust_bindgen`"

#: src/android/build-rules.md
msgid ""
"Generates source and produces a Rust library containing Rust bindings to C "
"libraries."
msgstr "生成源代码并生成包含 Rust 绑定到 C 库的 Rust 库。"

#: src/android/build-rules.md
msgid "We will look at `rust_binary` and `rust_library` next."
msgstr "下面我们来看看 `rust_binary` 和 `rust_library`。"

#: src/android/build-rules.md
msgid "Additional items speaker may mention:"
msgstr "演讲者可能会提及其他内容："

#: src/android/build-rules.md
msgid ""
"Cargo is not optimized for multi-language repos, and also downloads packages "
"from the internet."
msgstr "Cargo 未针对多语言代码库进行优化，并且从互联网下载软件包。"

#: src/android/build-rules.md
#, fuzzy
msgid ""
"For compliance and performance, Android must have crates in-tree. It must "
"also interop with C/C++/Java code. Soong fills that gap."
msgstr ""
"为了确保合规性和性能，Android 必须具有树内 crate。它还必须与 C/C++/Java 代码"
"进行互操作。Soong 填补了这一空白。"

#: src/android/build-rules.md
msgid ""
"Soong has many similarities to Bazel, which is the open-source variant of "
"Blaze (used in google3)."
msgstr ""
"Soong 与 Bazel 有许多相似之处，后者是 Blaze 的开源变体（在 google3 中使用）。"

#: src/android/build-rules.md
msgid ""
"There is a plan to transition [Android](https://source.android.com/docs/"
"setup/build/bazel/introduction), [ChromeOS](https://chromium.googlesource."
"com/chromiumos/bazel/), and [Fuchsia](https://source.android.com/docs/setup/"
"build/bazel/introduction) to Bazel."
msgstr ""
"我们计划逐渐在 [Android](https://source.android.com/docs/setup/build/bazel/"
"introduction)，[ChromeOS](https://chromium.googlesource.com/chromiumos/"
"bazel/) 和 [Fuchsia](https://source.android.com/docs/setup/build/bazel/"
"introduction) 中采用 Bazel 进行开发。"

#: src/android/build-rules.md
msgid "Learning Bazel-like build rules is useful for all Rust OS developers."
msgstr "对所有 Rust 操作系统开发者而言，了解类似 Bazel 的构建规都很有用。"

#: src/android/build-rules.md
msgid "Fun fact: Data from Star Trek is a Soong-type Android."
msgstr "趣味小知识：《星际迷航》中的数据是 Soong 类型的 Android。"

#: src/android/build-rules/binary.md
msgid "Rust Binaries"
msgstr "Rust 二进制文件"

#: src/android/build-rules/binary.md
msgid ""
"Let us start with a simple application. At the root of an AOSP checkout, "
"create the following files:"
msgstr "让我们从一个简单的应用程序开始。在 AOSP 签出的根目录下，创建以下文件："

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "_hello_rust/Android.bp_:"
msgstr "_hello_rust/Android.bp_:"

#: src/android/build-rules/binary.md
#, fuzzy
msgid "\"hello_rust\""
msgstr "\"hello_rust\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
#: src/android/logging.md
#, fuzzy
msgid "\"src/main.rs\""
msgstr "\"main.c\""

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "_hello_rust/src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "//! Rust demo.\n"
msgstr "//! Rust demo.\n"

#: src/android/build-rules/binary.md src/android/build-rules/library.md
msgid "/// Prints a greeting to standard output.\n"
msgstr "/// Prints a greeting to standard output.\n"

#: src/android/build-rules/binary.md src/exercises/chromium/build-rules.md
#, fuzzy
msgid "\"Hello from Rust!\""
msgstr "\"Hello from Rust!\""

#: src/android/build-rules/binary.md
msgid "You can now build, push, and run the binary:"
msgstr "你现在可以构建、推送和运行二进制文件："

#: src/android/build-rules/binary.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust\" /data/local/tmp\n"
"adb shell /data/local/tmp/hello_rust\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/build-rules/library.md
msgid "Rust Libraries"
msgstr "Rust 库"

#: src/android/build-rules/library.md
msgid "You use `rust_library` to create a new Rust library for Android."
msgstr "您可以使用 `rust_library` 为 Android 创建一个新的 Rust 库。"

#: src/android/build-rules/library.md
msgid "Here we declare a dependency on two libraries:"
msgstr "在这里，我们声明了对两个库的依赖："

#: src/android/build-rules/library.md
msgid "`libgreeting`, which we define below,"
msgstr "`libgreeting`, 我们在下面进行了定义，"

#: src/android/build-rules/library.md
msgid ""
"`libtextwrap`, which is a crate already vendored in [`external/rust/crates/`]"
"(https://cs.android.com/android/platform/superproject/+/master:external/rust/"
"crates/)."
msgstr ""
"`libtextwrap`, 一个已经在 [`external/rust/crates/`](https://cs.android.com/"
"android/platform/superproject/+/master:external/rust/crates/) 中提供的 "
"crate。"

#: src/android/build-rules/library.md
#, fuzzy
msgid "\"hello_rust_with_dep\""
msgstr "\"hello_rust_with_dep\""

#: src/android/build-rules/library.md
msgid "\"libgreetings\""
msgstr "\"libgreetings\""

#: src/android/build-rules/library.md
msgid "\"libtextwrap\""
msgstr "\"libtextwrap\""

#: src/android/build-rules/library.md
msgid "// Need this to avoid dynamic link error.\n"
msgstr ""

#: src/android/build-rules/library.md
msgid "\"greetings\""
msgstr "\"greetings\""

#: src/android/build-rules/library.md src/android/aidl/implementation.md
#: src/android/interoperability/java.md
#, fuzzy
msgid "\"src/lib.rs\""
msgstr "\"lib.rs\""

#: src/android/build-rules/library.md
msgid "_hello_rust/src/lib.rs_:"
msgstr "_hello_rust/src/lib.rs_:"

#: src/android/build-rules/library.md
msgid "//! Greeting library.\n"
msgstr "//! Greeting library.\n"

#: src/android/build-rules/library.md
msgid "/// Greet `name`.\n"
msgstr "/// Greet `name`.\n"

#: src/android/build-rules/library.md
msgid "\"Hello {name}, it is very nice to meet you!\""
msgstr "\"Hello {name}, it is very nice to meet you!\""

#: src/android/build-rules/library.md
msgid "You build, push, and run the binary like before:"
msgstr "您可以像之前一样构建、推送和运行二进制文件："

#: src/android/build-rules/library.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_with_dep\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_with_dep\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/aidl.md
msgid ""
"The [Android Interface Definition Language (AIDL)](https://developer.android."
"com/guide/components/aidl) is supported in Rust:"
msgstr ""
"Rust 支持 [Android 接口定义语言 (AIDL)](https://developer.android.com/guide/"
"components/aidl)："

#: src/android/aidl.md
msgid "Rust code can call existing AIDL servers,"
msgstr "Rust 代码可以调用现有的 AIDL 服务器，"

#: src/android/aidl.md
msgid "You can create new AIDL servers in Rust."
msgstr "您可以在 Rust 中创建新的 AIDL 服务器。"

#: src/android/aidl/interface.md
msgid "AIDL Interfaces"
msgstr "AIDL 接口"

#: src/android/aidl/interface.md
msgid "You declare the API of your service using an AIDL interface:"
msgstr "您可以使用 AIDL 接口声明您的服务的 API："

#: src/android/aidl/interface.md
msgid ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"
msgstr ""
"_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:"

#: src/android/aidl/interface.md src/android/aidl/changing.md
msgid "/** Birthday service interface. */"
msgstr "/** Birthday service interface. */"

#: src/android/aidl/interface.md src/android/aidl/changing.md
msgid "/** Generate a Happy Birthday message. */"
msgstr "/** Generate a Happy Birthday message. */"

#: src/android/aidl/interface.md
msgid "_birthday_service/aidl/Android.bp_:"
msgstr "_birthday_service/aidl/Android.bp_:"

#: src/android/aidl/interface.md
#, fuzzy
msgid "\"com.example.birthdayservice\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/interface.md
#, fuzzy
msgid "\"com/example/birthdayservice/*.aidl\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/interface.md
msgid "// Rust is not enabled by default\n"
msgstr "// Rust is not enabled by default\n"

#: src/android/aidl/interface.md
msgid ""
"Add `vendor_available: true` if your AIDL file is used by a binary in the "
"vendor partition."
msgstr ""
"如果供应商分区中的二进制文件使用了您的 AIDL 文件，请添加 `vendor_available: "
"true`。"

#: src/android/aidl/implementation.md
msgid "Service Implementation"
msgstr "服务实现"

#: src/android/aidl/implementation.md
msgid "We can now implement the AIDL service:"
msgstr "我们现在可以实现AIDL服务："

#: src/android/aidl/implementation.md
msgid "_birthday_service/src/lib.rs_:"
msgstr "_birthday_service/src/lib.rs_:"

#: src/android/aidl/implementation.md
msgid "//! Implementation of the `IBirthdayService` AIDL interface.\n"
msgstr "//! Implementation of the `IBirthdayService` AIDL interface.\n"

#: src/android/aidl/implementation.md
#, fuzzy
msgid "/// The `IBirthdayService` implementation.\n"
msgstr "`IBirthdayService`实现 "

#: src/android/aidl/implementation.md
msgid "\"Happy Birthday {name}, congratulations with the {years} years!\""
msgstr "\"Happy Birthday {name}, congratulations with the {years} years!\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
msgid "_birthday_service/Android.bp_:"
msgstr "_birthday_service/Android.bp_:"

#: src/android/aidl/implementation.md src/android/aidl/server.md
#, fuzzy
msgid "\"libbirthdayservice\""
msgstr "\"libbirthday.c\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
#, fuzzy
msgid "\"birthdayservice\""
msgstr "\"com.example.birthdayservice\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
#, fuzzy
msgid "\"com.example.birthdayservice-rust\""
msgstr "\"com.example.birthdayservice-rust\""

#: src/android/aidl/implementation.md src/android/aidl/server.md
#: src/android/aidl/client.md
msgid "\"libbinder_rs\""
msgstr "\"libbinder_rs\""

#: src/android/aidl/server.md
msgid "AIDL Server"
msgstr "AIDL 服务器"

#: src/android/aidl/server.md
msgid "Finally, we can create a server which exposes the service:"
msgstr "最后，我们可以创建一个暴露服务的服务器："

#: src/android/aidl/server.md
msgid "_birthday_service/src/server.rs_:"
msgstr "_birthday_service/src/server.rs_:"

#: src/android/aidl/server.md src/android/aidl/client.md
#, fuzzy
msgid "//! Birthday service.\n"
msgstr "//! Birthday service.\n"

#: src/android/aidl/server.md
msgid "/// Entry point for birthday service.\n"
msgstr "/// Entry point for birthday service.\n"

#: src/android/aidl/server.md
msgid "\"Failed to register service\""
msgstr "\"Failed to register service\""

#: src/android/aidl/server.md
#, fuzzy
msgid "\"birthday_server\""
msgstr "\"libbirthday_wrapper.h\""

#: src/android/aidl/server.md
#, fuzzy
msgid "\"src/server.rs\""
msgstr "`src/bin/server.rs`:"

#: src/android/aidl/server.md src/android/aidl/client.md
msgid "// To avoid dynamic link error.\n"
msgstr ""

#: src/android/aidl/deploy.md
msgid "We can now build, push, and start the service:"
msgstr "我们现在可以构建、推送和启动服务："

#: src/android/aidl/deploy.md
#, fuzzy
msgid ""
"```shell\n"
"m birthday_server\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_server\" /data/local/"
"tmp\n"
"adb root\n"
"adb shell /data/local/tmp/birthday_server\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/aidl/deploy.md
msgid "In another terminal, check that the service runs:"
msgstr "在另一个终端中，检查该服务是否正在运行："

#: src/android/aidl/deploy.md
msgid "You can also call the service with `service call`:"
msgstr "您还可以使用 `service call` 命令调用该服务："

#: src/android/aidl/client.md
msgid "AIDL Client"
msgstr "AIDL 客户端"

#: src/android/aidl/client.md
msgid "Finally, we can create a Rust client for our new service."
msgstr "最后，我们可以为我们的新服务创建一个 Rust 客户端。"

#: src/android/aidl/client.md
msgid "_birthday_service/src/client.rs_:"
msgstr "_birthday_service/src/client.rs_:"

#: src/android/aidl/client.md
#, fuzzy
msgid "/// Connect to the BirthdayService.\n"
msgstr "/// Connect to the BirthdayService.\n"

#: src/android/aidl/client.md
#, fuzzy
msgid "/// Call the birthday service.\n"
msgstr "/// Call the birthday service.\n"

#: src/android/aidl/client.md
msgid "\"Failed to connect to BirthdayService\""
msgstr "\"Failed to connect to BirthdayService\""

#: src/android/aidl/client.md
msgid "\"{msg}\""
msgstr "\"{msg}\""

#: src/android/aidl/client.md
#, fuzzy
msgid "\"birthday_client\""
msgstr "\"birthday_bindgen\""

#: src/android/aidl/client.md
#, fuzzy
msgid "\"src/client.rs\""
msgstr "\"lib.rs\""

#: src/android/aidl/client.md
msgid "Notice that the client does not depend on `libbirthdayservice`."
msgstr "请注意，客户端不依赖于 `libbirthdayservice`。"

#: src/android/aidl/client.md
msgid "Build, push, and run the client on your device:"
msgstr "在您的设备上构建、推送并运行客户端："

#: src/android/aidl/client.md
#, fuzzy
msgid ""
"```shell\n"
"m birthday_client\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/birthday_client\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/birthday_client Charlie 60\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/aidl/changing.md
msgid ""
"Let us extend the API with more functionality: we want to let clients "
"specify a list of lines for the birthday card:"
msgstr "让我们扩展API以提供更多功能：我们希望允许客户端指定生日贺卡的行列表："

#: src/android/logging.md
msgid ""
"You should use the `log` crate to automatically log to `logcat` (on-device) "
"or `stdout` (on-host):"
msgstr ""
"你应该使用 `log` crate 来自动记录日志到 `logcat` （设备上）或 `stdout`（主机"
"上）："

#: src/android/logging.md
msgid "_hello_rust_logs/Android.bp_:"
msgstr "_hello_rust_logs/Android.bp_:"

#: src/android/logging.md
#, fuzzy
msgid "\"hello_rust_logs\""
msgstr "\"hello_rust\""

#: src/android/logging.md
#, fuzzy
msgid "\"liblog_rust\""
msgstr "\"liblog_rust\""

#: src/android/logging.md
msgid "\"liblogger\""
msgstr "\"liblogger\""

#: src/android/logging.md
msgid "_hello_rust_logs/src/main.rs_:"
msgstr "_hello_rust_logs/src/main.rs_:"

#: src/android/logging.md
msgid "//! Rust logging demo.\n"
msgstr "//! Rust logging demo.\n"

#: src/android/logging.md
msgid "/// Logs a greeting.\n"
msgstr "/// Logs a greeting.\n"

#: src/android/logging.md
#, fuzzy
msgid "\"rust\""
msgstr "\"rust\""

#: src/android/logging.md
msgid "\"Starting program.\""
msgstr "\"Starting program.\""

#: src/android/logging.md
msgid "\"Things are going fine.\""
msgstr "\"Things are going fine.\""

#: src/android/logging.md
#, fuzzy
msgid "\"Something went wrong!\""
msgstr "\"Something went wrong!\""

#: src/android/logging.md src/android/interoperability/with-c/bindgen.md
#: src/android/interoperability/with-c/rust.md
msgid "Build, push, and run the binary on your device:"
msgstr "在你的设备上构建，推送，并运行二进制文件 ："

#: src/android/logging.md
#, fuzzy
msgid ""
"```shell\n"
"m hello_rust_logs\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/hello_rust_logs\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/logging.md
msgid "The logs show up in `adb logcat`:"
msgstr "日志将会在 `adb logcat` 中显示："

#: src/android/interoperability.md
msgid ""
"Rust has excellent support for interoperability with other languages. This "
"means that you can:"
msgstr "Rust 对于与其他编程语言的互操作性有着出色的支持。这意味着您可以："

#: src/android/interoperability.md
msgid "Call Rust functions from other languages."
msgstr "从其他语言调用 Rust 函数。"

#: src/android/interoperability.md
msgid "Call functions written in other languages from Rust."
msgstr "从 Rust 调用用其他语言编写的函数。"

#: src/android/interoperability.md
msgid ""
"When you call functions in a foreign language we say that you're using a "
"_foreign function interface_, also known as FFI."
msgstr ""
"当您从外部语言调用函数时，我们称之为使用 **外部函数接口**（*Foreign Function "
"Interface*， FFI）。"

#: src/android/interoperability/with-c.md
msgid "Interoperability with C"
msgstr "与 C 的互操作性"

#: src/android/interoperability/with-c.md
msgid ""
"Rust has full support for linking object files with a C calling convention. "
"Similarly, you can export Rust functions and call them from C."
msgstr ""
"Rust 对使用 C 调用约定链接目标文件提供了完整的支持。同样地，你可以导出 Rust "
"函数并从 C 中调用它们。"

#: src/android/interoperability/with-c.md
msgid "You can do it by hand if you want:"
msgstr "如果你愿意的话，你可以手工完成它："

#: src/android/interoperability/with-c.md
msgid "\"{x}, {abs_x}\""
msgstr "\"{x}, {abs_x}\""

#: src/android/interoperability/with-c.md
msgid ""
"We already saw this in the [Safe FFI Wrapper exercise](../../exercises/day-3/"
"safe-ffi-wrapper.md)."
msgstr ""
"我们已经在[安全 FFI 封装容器](../../exercises/day-3/safe-ffi-wrapper.md)练习"
"中看到了这个例子。"

#: src/android/interoperability/with-c.md
msgid ""
"This assumes full knowledge of the target platform. Not recommended for "
"production."
msgstr "这假设对目标平台拥有充分的了解，不建议用于生产环境。"

#: src/android/interoperability/with-c.md
msgid "We will look at better options next."
msgstr "接下来我们将探讨更好的选择。"

#: src/android/interoperability/with-c/bindgen.md
msgid "Using Bindgen"
msgstr "使用 Bindgen"

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) "
"tool can auto-generate bindings from a C header file."
msgstr ""
"[bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) 工具可"
"以自动生成 C 头文件的绑定代码。"

#: src/android/interoperability/with-c/bindgen.md
msgid "First create a small C library:"
msgstr "首先创建一个小型的 C 语言库："

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday.h_:"
msgstr "interoperability/bindgen/libbirthday.h:"

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday.c_:"
msgstr "_interoperability/bindgen/libbirthday.c_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "<stdio.h>"
msgstr "<stdio.h>"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday.h\""
msgstr "\"libbirthday.c\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"+--------------\\n\""
msgstr "\"+--------------\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"| Happy Birthday %s!\\n\""
msgstr "\"| Happy Birthday %s!\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"| Congratulations with the %i years!\\n\""
msgstr "\"| Congratulations with the %i years!\\n\""

#: src/android/interoperability/with-c/bindgen.md
msgid "Add this to your `Android.bp` file:"
msgstr "将该库添加到你的 `Android.bp` 文件中："

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/Android.bp_:"
msgstr "_interoperability/bindgen/Android.bp_:"

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday\""
msgstr "\"libbirthday\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday.c\""
msgstr "\"libbirthday.c\""

#: src/android/interoperability/with-c/bindgen.md
msgid ""
"Create a wrapper header file for the library (not strictly needed in this "
"example):"
msgstr "为该库创建一个包装头文件（在此示例中不是必需的）："

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/libbirthday_wrapper.h_:"
msgstr "_interoperability/bindgen/libbirthday_wrapper.h_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "You can now auto-generate the bindings:"
msgstr "您现在可以自动生成绑定代码："

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_bindgen\""
msgstr "\"libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"birthday_bindgen\""
msgstr "\"birthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_wrapper.h\""
msgstr "\"libbirthday_wrapper.h\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"bindings\""
msgstr "\"bindings\""

#: src/android/interoperability/with-c/bindgen.md
msgid "Finally, we can use the bindings in our Rust program:"
msgstr "最后，我们可以在 Rust 程序中使用这些绑定："

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"print_birthday_card\""
msgstr "\"print_birthday_card\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"main.rs\""
msgstr "\"main.c\""

#: src/android/interoperability/with-c/bindgen.md
msgid "_interoperability/bindgen/main.rs_:"
msgstr "_interoperability/bindgen/main.rs_:"

#: src/android/interoperability/with-c/bindgen.md
msgid "//! Bindgen demo.\n"
msgstr "//! Bindgen demo.\n"

#: src/android/interoperability/with-c/bindgen.md
msgid "// SAFETY: `print_card` is safe to call with a valid `card` pointer.\n"
msgstr ""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"
msgstr ""
"```shell\n"
"m print_birthday_card\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/print_birthday_card\n"
"```"

#: src/android/interoperability/with-c/bindgen.md
msgid "Finally, we can run auto-generated tests to ensure the bindings work:"
msgstr "最后，我们可以运行自动生成的测试来确保绑定代码正常工作："

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"libbirthday_bindgen_test\""
msgstr "\"libbirthday_bindgen_test\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\":libbirthday_bindgen\""
msgstr "\":libbirthday_bindgen\""

#: src/android/interoperability/with-c/bindgen.md
#, fuzzy
msgid "\"general-tests\""
msgstr "\"general-tests\""

#: src/android/interoperability/with-c/bindgen.md
msgid "\"none\""
msgstr "\"none\""

#: src/android/interoperability/with-c/bindgen.md
msgid "// Generated file, skip linting\n"
msgstr "// Generated file, skip linting\n"

#: src/android/interoperability/with-c/rust.md
msgid "Calling Rust"
msgstr "调用 Rust"

#: src/android/interoperability/with-c/rust.md
msgid "Exporting Rust functions and types to C is easy:"
msgstr "将 Rust 函数和类型导出到 C 很简单："

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/analyze.rs_"
msgstr "_interoperability/rust/libanalyze/analyze.rs_"

#: src/android/interoperability/with-c/rust.md
msgid "//! Rust FFI demo.\n"
msgstr "//! Rust FFI demo.\n"

#: src/android/interoperability/with-c/rust.md
msgid "/// Analyze the numbers.\n"
msgstr "/// Analyze the numbers.\n"

#: src/android/interoperability/with-c/rust.md
msgid "\"x ({x}) is smallest!\""
msgstr "\"x ({x}) is smallest!\""

#: src/android/interoperability/with-c/rust.md
msgid "\"y ({y}) is probably larger than x ({x})\""
msgstr "\"y ({y}) is probably larger than x ({x})\""

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/analyze.h_"
msgstr "_interoperability/rust/libanalyze/analyze.h_"

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/libanalyze/Android.bp_"
msgstr "_interoperability/rust/libanalyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"libanalyze_ffi\""
msgstr "\"libanalyze_ffi\""

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze_ffi\""
msgstr "\"analyze_ffi\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"analyze.rs\""
msgstr "\"analyze.rs\""

#: src/android/interoperability/with-c/rust.md
msgid "We can now call this from a C binary:"
msgstr "我们现在可以从一个 C 二进制文件中调用它："

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/analyze/main.c_"
msgstr "_interoperability/rust/analyze/main.c_"

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze.h\""
msgstr "\"analyze.h\""

#: src/android/interoperability/with-c/rust.md
msgid "_interoperability/rust/analyze/Android.bp_"
msgstr "_interoperability/rust/analyze/Android.bp_"

#: src/android/interoperability/with-c/rust.md
msgid "\"analyze_numbers\""
msgstr "\"analyze_numbers\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid "\"main.c\""
msgstr "\"main.c\""

#: src/android/interoperability/with-c/rust.md
#, fuzzy
msgid ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers\" /data/local/"
"tmp\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"
msgstr ""
"```shell\n"
"m analyze_numbers\n"
"adb push \"$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/"
"tmp\"\n"
"adb shell /data/local/tmp/analyze_numbers\n"
"```"

#: src/android/interoperability/with-c/rust.md
msgid ""
"`#[no_mangle]` disables Rust's usual name mangling, so the exported symbol "
"will just be the name of the function. You can also use `#[export_name = "
"\"some_name\"]` to specify whatever name you want."
msgstr ""
"`#[no_mangle]` 禁用了 Rust 通常的名称重整，因此导出的符号将仅为函数的名称。你"
"还可以使用 `#[export_name = \"some_name\"]` 来指定任意你想要的名称。"

#: src/android/interoperability/cpp.md
msgid ""
"The [CXX crate](https://cxx.rs/) makes it possible to do safe "
"interoperability between Rust and C++."
msgstr ""
"[CXX crate](https://cxx.rs/) 使得在 Rust 和 C++ 之间进行安全的互操作成为可"
"能。"

#: src/android/interoperability/cpp.md
msgid "The overall approach looks like this:"
msgstr "整体的方法如下："

#: src/android/interoperability/cpp/bridge.md
msgid ""
"CXX relies on a description of the function signatures that will be exposed "
"from each language to the other. You provide this description using extern "
"blocks in a Rust module annotated with the `#[cxx::bridge]` attribute macro."
msgstr ""
"CXX依赖于提供的函数签名说明，这些签名会在不用语言之间进行交互使用。您可以在带"
"有 `#[cxx::bridge]` 属性宏注解的 Rust 模块中使用 extern 代码块提供此说明。"

#: src/android/interoperability/cpp/bridge.md
msgid "\"org::blobstore\""
msgstr "\"org::blobstore\""

#: src/android/interoperability/cpp/bridge.md
msgid "// Shared structs with fields visible to both languages.\n"
msgstr "// Shared structs with fields visible to both languages.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
msgid "// Rust types and signatures exposed to C++.\n"
msgstr "// Rust types and signatures exposed to C++.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/rust-bridge.md
#: src/android/interoperability/cpp/generated-cpp.md
#: src/android/interoperability/cpp/rust-result.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "\"Rust\""
msgstr "\"Rust\""

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
msgid "// C++ types and signatures exposed to Rust.\n"
msgstr "// C++ types and signatures exposed to Rust.\n"

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
#: src/android/interoperability/cpp/cpp-exception.md
#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "\"C++\""
msgstr "\"C++\""

#: src/android/interoperability/cpp/bridge.md
#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"include/blobstore.h\""
msgstr "\"include/blobstore.h\""

#: src/android/interoperability/cpp/bridge.md
msgid "The bridge is generally declared in an `ffi` module within your crate."
msgstr "桥接通常在您的 crate 内的 `ffi` 模块中声明。"

#: src/android/interoperability/cpp/bridge.md
msgid ""
"From the declarations made in the bridge module, CXX will generate matching "
"Rust and C++ type/function definitions in order to expose those items to "
"both languages."
msgstr ""
"根据在桥接模块中进行的声明，CXX 将生成匹配的 Rust 和 C++ 类型/函数定义，以便"
"将这些内容公开给这两种语言。"

#: src/android/interoperability/cpp/bridge.md
msgid ""
"To view the generated Rust code, use [cargo-expand](https://github.com/"
"dtolnay/cargo-expand) to view the expanded proc macro. For most of the "
"examples you would use `cargo expand ::ffi` to expand just the `ffi` module "
"(though this doesn't apply for Android projects)."
msgstr ""
"如需查看生成的 Rust 代码，请使用 [cargo-expand](https://github.com/dtolnay/"
"cargo-expand) 查看展开后的 proc 宏。对于大多数示例，您可以使用 `cargo "
"expand ::ffi` 来仅展开 `ffi` 模块（但这不适用于 Android 项目）。"

#: src/android/interoperability/cpp/bridge.md
msgid "To view the generated C++ code, look in `target/cxxbridge`."
msgstr "如需查看生成的 C++ 代码，请在 `target/cxxbridge` 中查找。"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "Rust Bridge Declarations"
msgstr "Rust 桥接声明"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "// Opaque type\n"
msgstr "// Opaque type\n"

#: src/android/interoperability/cpp/rust-bridge.md
msgid "// Method on `MyType`\n"
msgstr "// Method on `MyType`\n"

#: src/android/interoperability/cpp/rust-bridge.md
#, fuzzy
msgid "// Free function\n"
msgstr "函数"

#: src/android/interoperability/cpp/rust-bridge.md
msgid ""
"Items declared in the `extern \"Rust\"` reference items that are in scope in "
"the parent module."
msgstr "`extern \"Rust\"` 中声明的内容引用了父级模块中作用域内的内容。"

#: src/android/interoperability/cpp/rust-bridge.md
msgid ""
"The CXX code generator uses your `extern \"Rust\"` section(s) to produce a C+"
"+ header file containing the corresponding C++ declarations. The generated "
"header has the same path as the Rust source file containing the bridge, "
"except with a .rs.h file extension."
msgstr ""
"CXX 代码生成器使用 `extern \"Rust\"` 部分生成包含相应 C++ 声明的 C++ 头文件。"
"生成的头文件与包含桥接的 Rust 源文件的路径相同，但文件扩展名为 .rs.h。"

#: src/android/interoperability/cpp/generated-cpp.md
msgid "Results in (roughly) the following C++:"
msgstr "大致生成以下 C++："

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "C++ Bridge Declarations"
msgstr "C++ 桥接声明"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "Results in (roughly) the following Rust:"
msgstr "大致生成以下 Rust："

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"org$blobstore$cxxbridge1$new_blobstore_client\""
msgstr "\"org$blobstore$cxxbridge1$new_blobstore_client\""

#: src/android/interoperability/cpp/cpp-bridge.md
msgid "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""
msgstr "\"org$blobstore$cxxbridge1$BlobstoreClient$put\""

#: src/android/interoperability/cpp/cpp-bridge.md
msgid ""
"The programmer does not need to promise that the signatures they have typed "
"in are accurate. CXX performs static assertions that the signatures exactly "
"correspond with what is declared in C++."
msgstr ""
"程序员无需承诺他们输入的签名准确无误。CXX 会执行静态断言，确认签名与 C++ 中声"
"明的内容完全一致。"

#: src/android/interoperability/cpp/cpp-bridge.md
msgid ""
"`unsafe extern` blocks allow you to declare C++ functions that are safe to "
"call from Rust."
msgstr "借助 `unsafe extern` 代码块，您可以声明可从 Rust 安全调用的 C++ 函数。"

#: src/android/interoperability/cpp/shared-types.md
msgid "// A=1, J=11, Q=12, K=13\n"
msgstr "// A=1, J=11, Q=12, K=13\n"

#: src/android/interoperability/cpp/shared-types.md
msgid "Only C-like (unit) enums are supported."
msgstr "仅支持类似 C 函数（单元）的枚举。"

#: src/android/interoperability/cpp/shared-types.md
msgid ""
"A limited number of traits are supported for `#[derive()]` on shared types. "
"Corresponding functionality is also generated for the C++ code, e.g. if you "
"derive `Hash` also generates an implementation of `std::hash` for the "
"corresponding C++ type."
msgstr ""
"共享类型的 `#[derive()]` 支持有限数量的 trait。系统还会针对 C++ 代码生成相应"
"的功能，例如，如果您派生了 `Hash`，还会为相应的 C++ 类型生成 `std::hash` 实"
"现。"

#: src/android/interoperability/cpp/shared-enums.md
#, fuzzy
msgid "Generated Rust:"
msgstr "生成的 Rust："

#: src/android/interoperability/cpp/shared-enums.md
#, fuzzy
msgid "Generated C++:"
msgstr "生成的 C++："

#: src/android/interoperability/cpp/shared-enums.md
msgid ""
"On the Rust side, the code generated for shared enums is actually a struct "
"wrapping a numeric value. This is because it is not UB in C++ for an enum "
"class to hold a value different from all of the listed variants, and our "
"Rust representation needs to have the same behavior."
msgstr ""
"在 Rust 端，为共享枚举生成的代码实际上是封装数值的结构体。这是因为在 C++ 中，"
"枚举类存储与所有已列变体不同的值不属于 UB，而 Rust 表示法需要具有相同的行为。"

#: src/android/interoperability/cpp/rust-result.md
msgid "\"fallible1 requires depth > 0\""
msgstr "\"fallible1 requires depth > 0\""

#: src/android/interoperability/cpp/rust-result.md
msgid "\"Success!\""
msgstr "\"Success!\""

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"Rust functions that return `Result` are translated to exceptions on the C++ "
"side."
msgstr "在 C++ 方面，返回 `Result` 的 Rust 函数会被翻译为异常。"

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"The exception thrown will always be of type `rust::Error`, which primarily "
"exposes a way to get the error message string. The error message will come "
"from the error type's `Display` impl."
msgstr ""
"抛出的异常始终是 `rust::Error` 类型，该类型主要用于提供获取错误消息字符串的方"
"法。错误消息将由错误类型的 `Display` impl 提供。"

#: src/android/interoperability/cpp/rust-result.md
msgid ""
"A panic unwinding from Rust to C++ will always cause the process to "
"immediately terminate."
msgstr "当 panic 从 Rust 展开到 C++ 时，会始终导致进程立即终止。"

#: src/android/interoperability/cpp/cpp-exception.md
msgid "\"example/include/example.h\""
msgstr "\"example/include/example.h\""

#: src/android/interoperability/cpp/cpp-exception.md
msgid "\"Error: {}\""
msgstr "\"Error: {}\""

#: src/android/interoperability/cpp/cpp-exception.md
msgid ""
"C++ functions declared to return a `Result` will catch any thrown exception "
"on the C++ side and return it as an `Err` value to the calling Rust function."
msgstr ""
"声明用于返回 `Result` 的 C++ 函数将捕获 C++ 端抛出的任何异常，并将其作为 "
"`Err` 值返回给调用 Rust 函数。"

#: src/android/interoperability/cpp/cpp-exception.md
msgid ""
"If an exception is thrown from an extern \"C++\" function that is not "
"declared by the CXX bridge to return `Result`, the program calls C++'s `std::"
"terminate`. The behavior is equivalent to the same exception being thrown "
"through a `noexcept` C++ function."
msgstr ""
"如果外部 “C++”函数抛出l了异常，但 CXX 桥接中未声明该函数用于返回 `Result`，则"
"程序会调用 C++ 的 `std::terminate`。此行为等同于通过 C++ 函数 `nowithout` 抛"
"出了相同的异常。"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "Rust Type"
msgstr "Rust 示例"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "C++ Type"
msgstr "C++ 示例"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::String`"
msgstr "`rust::String`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&str`"
msgstr "`&str`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Str`"
msgstr "`rust::Str`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxString`"
msgstr "String"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::string`"
msgstr "String"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`&[T]`/`&mut [T]`"
msgstr "`&[T]`/`&mut [T]`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Slice`"
msgstr "`rust_ffi`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Box<T>`"
msgstr "`rust::Box<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid "`UniquePtr<T>`"
msgstr "`UniquePtr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::unique_ptr<T>`"
msgstr "`std::unique_ptr<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`Vec<T>`"
msgstr "`Vec`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`rust::Vec<T>`"
msgstr "`rust::Vec<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`CxxVector<T>`"
msgstr "`Cell<T>`"

#: src/android/interoperability/cpp/type-mapping.md
#, fuzzy
msgid "`std::vector<T>`"
msgstr "`std::vector<T>`"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"These types can be used in the fields of shared structs and the arguments "
"and returns of extern functions."
msgstr "这些类型可用于共享结构体的字段以及外部函数的参数和返回结果。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"Note that Rust's `String` does not map directly to `std::string`. There are "
"a few reasons for this:"
msgstr ""
"请注意，Rust 的 `String` 不会直接映射到 `std::string`。导致这种情况的原因有以"
"下几种："

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"`std::string` does not uphold the UTF-8 invariant that `String` requires."
msgstr "`std::string` 不遵循 `String` 所需的 UTF-8 不变性。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"The two types have different layouts in memory and so can't be passed "
"directly between languages."
msgstr "这两种类型的内存布局不同，因此无法直接在语言之间进行传递。"

#: src/android/interoperability/cpp/type-mapping.md
msgid ""
"`std::string` requires move constructors that don't match Rust's move "
"semantics, so a `std::string` can't be passed by value to Rust."
msgstr ""
"`std::string` 需要与 Rust 的移动语义不匹配的 move 构造函数，因此 `std::"
"string` 无法按值传递给 Rust。"

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "Building in Android"
msgstr "Android 中的 Rust"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Create a `cc_library_static` to build the C++ library, including the CXX "
"generated header and source file."
msgstr ""
"创建 `cc_library_static` 以构建 C++ 库，包括 CXX 生成的头文件和源文件。"

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"libcxx_test_cpp\""
msgstr "\"libcxx_test_cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid "\"cxx_test.cpp\""
msgstr "\"cxx_test.cpp\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid "\"cxx-bridge-header\""
msgstr "\"cxx-bridge-header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"libcxx_test_bridge_header\""
msgstr "\"libcxx_test_bridge_header\""

#: src/android/interoperability/cpp/android-build-cpp.md
#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"libcxx_test_bridge_code\""
msgstr "\"libcxx_test_bridge_code\""

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are "
"the dependencies for the CXX-generated C++ bindings. We'll show how these "
"are setup on the next slide."
msgstr ""
"指出 `libcxx_test_bridge_header` 和 `libcxx_test_bridge_code` 是 CXX 生成的 "
"C++ 绑定的依赖项。我们将在下一张幻灯片中介绍具体的设置方法。"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Note that you also need to depend on the `cxx-bridge-header` library in "
"order to pull in common CXX definitions."
msgstr "请注意，您还需要依靠 `cxx-bridge-header` 库才能提取常见的 CXX 定义。"

#: src/android/interoperability/cpp/android-build-cpp.md
msgid ""
"Full docs for using CXX in Android can be found in [the Android docs]"
"(https://source.android.com/docs/setup/build/rust/building-rust-modules/"
"android-rust-patterns#rust-cpp-interop-using-cxx). You may want to share "
"that link with the class so that students know where they can find these "
"instructions again in the future."
msgstr ""
"如需了解如何在 Android 中使用 CXX 的完整文档，请参阅 [Android 文档](https://"
"source.android.com/docs/setup/build/rust/building-rust-modules/android-rust-"
"patterns#rust-cpp-interop-using-cxx)。建议您与全班同学分享该链接，以便学生知"
"道日后可以在哪里找到这些说明。"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"Create two genrules: One to generate the CXX header, and one to generate the "
"CXX source file. These are then used as inputs to the `cc_library_static`."
msgstr ""
"创建两个 genrule：一个用于生成 CXX 头文件，另一个用于生成 CXX 源文件。然后，"
"这些内容会被用作 `cc_library_static` 的输入。"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"
msgstr ""
"// Generate a C++ header containing the C++ bindings\n"
"// to the Rust exported functions in lib.rs.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"cxxbridge\""
msgstr "\"cxxbridge\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"$(location cxxbridge) $(in) --header > $(out)\""
msgstr "\"$(location cxxbridge) $(in) --header > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#: src/android/interoperability/cpp/android-build-rust.md
#, fuzzy
msgid "\"lib.rs\""
msgstr "\"lib.rs\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"lib.rs.h\""
msgstr "\"lib.rs.h\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "// Generate the C++ code that Rust calls into.\n"
msgstr "// Generate the C++ code that Rust calls into.\n"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid "\"$(location cxxbridge) $(in) > $(out)\""
msgstr "\"$(location cxxbridge) $(in) > $(out)\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
#, fuzzy
msgid "\"lib.rs.cc\""
msgstr "\"lib.rs.cc\""

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"The `cxxbridge` tool is a standalone tool that generates the C++ side of the "
"bridge module. It is included in Android and available as a Soong tool."
msgstr ""
"`cxxbridge` 工具是一款独立工具，用于生成桥接模块的 C++ 端。它包含在 Android "
"中，并作为 Soong 工具提供。"

#: src/android/interoperability/cpp/android-cpp-genrules.md
msgid ""
"By convention, if your Rust source file is `lib.rs` your header file will be "
"named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming "
"convention isn't enforced, though."
msgstr ""
"按照惯例，如果您的 Rust 源文件是 `lib.rs`，则头文件将命名为 `lib.rs.h`，源文"
"件将命名为 `lib.rs.cc`。不过，系统并不强制执行此命名惯例。"

#: src/android/interoperability/cpp/android-build-rust.md
msgid ""
"Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`."
msgstr "创建一个依赖于 `libcxx` 和 `cc_library_static` 的 `rust_binary`。"

#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"cxx_test\""
msgstr "\"cxx_test\""

#: src/android/interoperability/cpp/android-build-rust.md
msgid "\"libcxx\""
msgstr "\"libcxx\""

#: src/android/interoperability/java.md
msgid "Interoperability with Java"
msgstr "与 Java 的互操作性"

#: src/android/interoperability/java.md
msgid ""
"Java can load shared objects via [Java Native Interface (JNI)](https://en."
"wikipedia.org/wiki/Java_Native_Interface). The [`jni` crate](https://docs.rs/"
"jni/) allows you to create a compatible library."
msgstr ""
"Java可以通过 [ Java 本地接口 (JNI)](https://en.wikipedia.org/wiki/"
"Java_Native_Interface) 加载共享对象。[`jni` crate](https://docs.rs/jni/) 允许"
"您创建一个兼容的库。"

#: src/android/interoperability/java.md
msgid "First, we create a Rust function to export to Java:"
msgstr "首先，我们创建一个可以导出到 Java 的 Rust 函数："

#: src/android/interoperability/java.md
msgid "_interoperability/java/src/lib.rs_:"
msgstr "_interoperability/java/src/lib.rs_:"

#: src/android/interoperability/java.md
msgid "//! Rust <-> Java FFI demo.\n"
msgstr "//! Rust <-> Java FFI demo.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "/// HelloWorld::hello method implementation.\n"
msgstr "/// HelloWorld::hello method implementation.\n"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"system\""
msgstr "\"system\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"Hello, {input}!\""
msgstr "\"Hello, {input}!\""

#: src/android/interoperability/java.md
msgid "_interoperability/java/Android.bp_:"
msgstr "_interoperability/java/Android.bp_:"

#: src/android/interoperability/java.md
msgid "\"libhello_jni\""
msgstr "\"libhello_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"hello_jni\""
msgstr "\"hello_jni\""

#: src/android/interoperability/java.md
msgid "\"libjni\""
msgstr "\"libjni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "We then call this function from Java:"
msgstr "最后，我们可以从 Java 中调用这个函数："

#: src/android/interoperability/java.md
msgid "_interoperability/java/HelloWorld.java_:"
msgstr "_interoperability/java/HelloWorld.java_:"

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"helloworld_jni\""
msgstr "\"helloworld_jni\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"HelloWorld.java\""
msgstr "\"HelloWorld.java\""

#: src/android/interoperability/java.md
#, fuzzy
msgid "\"HelloWorld\""
msgstr "Hello World!"

#: src/android/interoperability/java.md
msgid "Finally, you can build, sync, and run the binary:"
msgstr "最后，您可以构建、同步和运行二进制文件："

#: src/exercises/android/morning.md
msgid ""
"This is a group exercise: We will look at one of the projects you work with "
"and try to integrate some Rust into it. Some suggestions:"
msgstr ""
"这是一个小组练习：我们将查看你们正在处理的项目之一，并尝试将一些 Rust 代码集"
"成进去。以下是一些建议："

#: src/exercises/android/morning.md
msgid "Call your AIDL service with a client written in Rust."
msgstr "使用 Rust 编写的客户端调用你的 AIDL 服务。"

#: src/exercises/android/morning.md
msgid "Move a function from your project to Rust and call it."
msgstr "将你项目中的某个函数迁移到 Rust 中并调用它。"

#: src/exercises/android/morning.md
msgid ""
"No solution is provided here since this is open-ended: it relies on someone "
"in the class having a piece of code which you can turn in to Rust on the fly."
msgstr ""
"此处没有提供解决方案，因为这是开放式的：它依赖于班级中是否有人有一段您可以即"
"时转换成 Rust 的代码。"

#: src/chromium.md
#, fuzzy
msgid "Welcome to Rust in Chromium"
msgstr "欢迎来到Android 中的Rust"

#: src/chromium.md
msgid ""
"Rust is supported for third-party libraries in Chromium, with first-party "
"glue code to connect between Rust and existing Chromium C++ code."
msgstr ""
"Chromium 中的第三方库支持 Rust，并使用第一方粘合代码连接 Rust 和现有 "
"Chromium C++ 代码。"

#: src/chromium.md
msgid ""
"Today, we'll call into Rust to do something silly with strings. If you've "
"got a corner of the code where you're displaying a UTF8 string to the user, "
"feel free to follow this recipe in your part of the codebase instead of the "
"exact part we talk about."
msgstr ""
"今天，我们将调用 Rust 对字符串进行一些有趣的操作。如果您的代码中某个部分是用"
"于向用户展示 UTF8 字符串，那么可以在代码库中的对应部分按照这个步骤来操作，而"
"不一定要在我们所讨论的确切部分。"

#: src/chromium/setup.md
msgid ""
"Make sure you can build and run Chromium. Any platform and set of build "
"flags is OK, so long as your code is relatively recent (commit position "
"1223636 onwards, corresponding to November 2023):"
msgstr ""
"请确保您可以构建并运行 Chromium。只要您的代码较新（提交位置始于 1223636，对应"
"于 2023 年 11 月），则可在任何平台和任何一组 build 标志下运行。"

#: src/chromium/setup.md
msgid ""
"(A component, debug build is recommended for quickest iteration time. This "
"is the default!)"
msgstr "（建议使用调试 build 组件，以缩短迭代时间。这是默认值！）"

#: src/chromium/setup.md
msgid ""
"See [How to build Chromium](https://www.chromium.org/developers/how-tos/get-"
"the-code/) if you aren't already at that point. Be warned: setting up to "
"build Chromium takes time."
msgstr ""
"如果您不具备这点，请参阅 [如何构建 Chromium](https://www.chromium.org/"
"developers/how-tos/get-the-code/)。注意：设置 build Chromium 需要花些时间。"

#: src/chromium/setup.md
msgid "It's also recommended that you have Visual Studio code installed."
msgstr "此外，我们还建议您安装 Visual Studio 代码。"

#: src/chromium/setup.md
#, fuzzy
msgid "About the exercises"
msgstr "练习简介"

#: src/chromium/setup.md
msgid ""
"This part of the course has a series of exercises which build on each other. "
"We'll be doing them spread throughout the course instead of just at the end. "
"If you don't have time to complete a certain part, don't worry: you can "
"catch up in the next slot."
msgstr ""
"本课程的这一部分包含一系列练习，它们之间是相辅相成的。我们将在整个课程中进行"
"这些练习，而不仅仅是在最后阶段完成。如果您没有时间完成某个部分，也无需担心："
"可以在下一阶段赶上进度。"

#: src/chromium/cargo.md
msgid ""
"Rust community typically uses `cargo` and libraries from [crates.io](https://"
"crates.io/). Chromium is built using `gn` and `ninja` and a curated set of "
"dependencies."
msgstr ""
"Rust 社区通常使用 `cargo` 和 [crates.io](https://crates.io/) 中的库。"
"Chromium 是使用 `gn` 和 `ninja` 以及一组精选依赖项而构建。"

#: src/chromium/cargo.md
msgid "When writing code in Rust, your choices are:"
msgstr "使用 Rust 编写代码时，您可以选择："

#: src/chromium/cargo.md
msgid ""
"Use `gn` and `ninja` with the help of the templates from `//build/rust/*."
"gni` (e.g. `rust_static_library` that we'll meet later). This uses "
"Chromium's audited toolchain and crates."
msgstr ""
"借助 `//build/rust/*.gni` 模板（例如 `rust_static_library`，我们稍后会介绍）"
"使用 `gn` 和 `ninja`。该操作会使用经过审核的 Chromium 工具链和 crate。"

#: src/chromium/cargo.md
msgid ""
"Use `cargo`, but [restrict yourself to Chromium's audited toolchain and "
"crates](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/"
"docs/rust.md#Using-cargo)"
msgstr ""
"使用 `cargo`，但 [仅限于经过审核的 Chromium 工具链和 crate](https://chromium."
"googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Using-cargo)"

#: src/chromium/cargo.md
msgid ""
"Use `cargo`, trusting a [toolchain](https://rustup.rs/) and/or [crates "
"downloaded from the internet](https://crates.io/)"
msgstr ""
"使用 `cargo`，信任 [工具链](https://rustup.rs/) 和/或 [从互联网下载的 crate]"
"(https://crates.io/)"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"From here on we'll be focusing on `gn` and `ninja`, because this is how Rust "
"code can be built into the Chromium browser. At the same time, Cargo is an "
"important part of the Rust ecosystem and you should keep it in your toolbox."
msgstr ""
"从现在开始，我们将重点介绍 `gn` 和 `ninja`，因为这是在 Chromium 浏览器构建 "
"Rust 代码时必会用到的两种方式。同时，Cargo 是 Rust 生态系统的重要组成部分，您"
"应将其视为必备工具。"

#: src/chromium/cargo.md
#, fuzzy
msgid "Mini exercise"
msgstr "习题"

#: src/chromium/cargo.md
msgid "Split into small groups and:"
msgstr "分成各个小组开展以下活动："

#: src/chromium/cargo.md
msgid ""
"Brainstorm scenarios where `cargo` may offer an advantage and assess the "
"risk profile of these scenarios."
msgstr "思考 `cargo` 在哪些场景下具有优势，并评估这些场景的风险状况。"

#: src/chromium/cargo.md
msgid ""
"Discuss which tools, libraries, and groups of people need to be trusted when "
"using `gn` and `ninja`, offline `cargo`, etc."
msgstr ""
"讨论在使用 `gn` 和 `ninja` 以及离线 `cargo` 等时，需要信任哪些工具、库和人"
"群。"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Ask students to avoid peeking at the speaker notes before completing the "
"exercise. Assuming folks taking the course are physically together, ask them "
"to discuss in small groups of 3-4 people."
msgstr ""
"请要求学生在完成练习前先不要看演讲者备注。假设参加课程的学员们同处一室，请让"
"他们以 3-4 人的小组进行讨论。"

#: src/chromium/cargo.md
msgid ""
"Notes/hints related to the first part of the exercise (\"scenarios where "
"Cargo may offer an advantage\"):"
msgstr "与第一部分练习相关的备注/提示（“Cargo 可能具有优势的场景”）："

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"It's fantastic that when writing a tool, or prototyping a part of Chromium, "
"one has access to the rich ecosystem of crates.io libraries. There is a "
"crate for almost anything and they are usually quite pleasant to use. "
"(`clap` for command-line parsing, `serde` for serializing/deserializing to/"
"from various formats, `itertools` for working with iterators, etc.)."
msgstr ""
"很棒的是，当我们在编写工具或对 Chromium 的某个部分进行原型设计时，可以轻松访"
"问丰富的 crate.io 库生态系统。几乎可以找到适用于任何需求的 crate，而且非常简"
"单易用。（例如，`clap` 用于命令行解析，`serde 用于序列化/反序列化各种格式，"
"`itertools` 用于和迭代器搭配使用等）。"

#: src/chromium/cargo.md
msgid ""
"`cargo` makes it easy to try a library (just add a single line to `Cargo."
"toml` and start writing code)"
msgstr ""
"借助 `cargo`，您便可以轻松试用库（只需向 `Cargo.toml`` 添加一行代码然后开始编"
"写即可）"

#: src/chromium/cargo.md
msgid ""
"It may be worth comparing how CPAN helped make `perl` a popular choice. Or "
"comparing with `python` + `pip`."
msgstr ""
"不妨比较下 CPAN 是如何帮助 `perl` 成为热门之选的。或者与 `python` + `pip` 进"
"行比较。"

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Development experience is made really nice not only by core Rust tools (e.g. "
"using `rustup` to switch to a different `rustc` version when testing a crate "
"that needs to work on nightly, current stable, and older stable) but also by "
"an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for "
"streamlining and sharing security audits; `criterion` crate gives a "
"streamlined way to run benchmarks)."
msgstr ""
"良好的开发体验不仅得益于核心 Rust 工具（例如，在测试需要在夜间版、当前稳定版"
"和较旧稳定版上运行的 crate 时，使用 `rustup` 切换到不同的 `rustc` 版本），还"
"得益于第三方工具生态系统（例如，Mozilla 提供的 `cargo vet` 用于简化和共享安全"
"审核流程；`criterion` crate 为运行基准审核提供了便捷方式）。"

#: src/chromium/cargo.md
msgid ""
"`cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`."
msgstr ""
"借助 `cargo`，您可通过 `cargo install --locked cargo-vet` 轻松添加工具。"

#: src/chromium/cargo.md
msgid "It may be worth comparing with Chrome Extensions or VScode extensions."
msgstr "不妨与 Chrome 扩展程序或 VScode 扩展程序进行比较。"

#: src/chromium/cargo.md
msgid ""
"Broad, generic examples of projects where `cargo` may be the right choice:"
msgstr "以下是一些适合选用 `cargo`，较为宽泛的通用项目示例："

#: src/chromium/cargo.md
#, fuzzy
msgid ""
"Perhaps surprisingly, Rust is becoming increasingly popular in the industry "
"for writing command line tools. The breadth and ergonomics of libraries is "
"comparable to Python, while being more robust (thanks to the rich "
"typesystem) and running faster (as a compiled, rather than interpreted "
"language)."
msgstr ""
"可能令人惊讶的是，Rust 在编写命令行工具方面越来越受到业界的欢迎。库在广度和工"
"效学设计方面与 Python 相当，同时更稳健（得益于丰富的类型系统）且运行速度更快"
"（作为编译语言而不是解释型语言）。"

#: src/chromium/cargo.md
msgid ""
"Participating in the Rust ecosystem requires using standard Rust tools like "
"Cargo. Libraries that want to get external contributions, and want to be "
"used outside of Chromium (e.g. in Bazel or Android/Soong build environments) "
"should probably use Cargo."
msgstr ""
"如要加入 Rust 生态系统，必须使用 Cargo 等标准 Rust 工具。如果希望库获得外部贡"
"献，并且能够用于除 Chromium 之外（例如用于 Bazel 或 Android/Soong 构建环境）"
"的项目，则应该使用 Cargo。"

#: src/chromium/cargo.md
msgid "Examples of Chromium-related projects that are `cargo`\\-based:"
msgstr "基于 `cargo`\\ 的 Chromium 相关项目示例："

#: src/chromium/cargo.md
msgid ""
"`serde_json_lenient` (experimented with in other parts of Google which "
"resulted in PRs with performance improvements)"
msgstr ""
"`serde_json_lenient`（已在 Google 的其他部分进行了实验，结果是能使 PR 性能得"
"到提升）"

#: src/chromium/cargo.md
msgid "Fontations libraries like `font-types`"
msgstr "字体库（例如 `font-types`）"

#: src/chromium/cargo.md
msgid ""
"`gnrt` tool (we will meet it later in the course) which depends on `clap` "
"for command-line parsing and on `toml` for configuration files."
msgstr ""
"`gnrt` 工具（我们将在本课程稍后的部分中加以介绍）使用 `clap` 进行命令行解析，"
"使用 `toml` 处理配置文件。"

#: src/chromium/cargo.md
msgid ""
"Disclaimer: a unique reason for using `cargo` was unavailability of `gn` "
"when building and bootstrapping Rust standard library when building Rust "
"toolchain.)"
msgstr ""
"免责声明：必须使用 `cargo` 的一个原因是在构建 Rust 工具链时，无法使用 `gn` 来"
"构建和引导 Rust 标准库。）"

#: src/chromium/cargo.md
msgid ""
"`run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends on "
"third-party libraries downloaded from the internet, by `run_gnrt.py` asks "
"`cargo` that only `--locked` content is allowed via `Cargo.lock`.)"
msgstr ""
"`run_gnrt.py` 使用 Chromium 的 `cargo` 和 `rustc` 副本。虽然 `gnrt` 依赖于从"
"互联网下载的第三方库，但 `run_gnrt.py` 规定 `cargo` 仅允许使用 `Cargo.lock` "
"中以 `--locked` 标记的内容。"

#: src/chromium/cargo.md
msgid ""
"Students may identify the following items as being implicitly or explicitly "
"trusted:"
msgstr "学生可将以下内容认定为隐式信任或明确信任："

#: src/chromium/cargo.md
msgid ""
"`rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the "
"Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust "
"compiler team), binary Rust compiler downloaded for bootstrapping"
msgstr ""
"`rustc`（Rust 编译器）则依赖于 LLVM 库、Clang 编译器、“rustc”源代码（从 "
"GitHub 获取，并由 Rust 编译器团队审核）、为引导而下载的二进制 Rust 编译器"

#: src/chromium/cargo.md
msgid ""
"`rustup` (it may be worth pointing out that `rustup` is developed under the "
"umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)"
msgstr ""
"`rustup`（值得注意的是，`rustup` 是在 https://github.com/rust-lang/ 保护下组"
"织开发的，与 `rustc` 相同。）"

#: src/chromium/cargo.md
msgid "`cargo`, `rustfmt`, etc."
msgstr "`cargo`、`rustfmt` 等"

#: src/chromium/cargo.md
msgid ""
"Various internal infrastructure (bots that build `rustc`, system for "
"distributing the prebuilt toolchain to Chromium engineers, etc.)"
msgstr ""
"各种内部基础架构（用于构建 `rustc` 的聊天机器人、用于将预构建工具链分发给 "
"Chromium 工程师的系统等。）"

#: src/chromium/cargo.md
msgid "Cargo tools like `cargo audit`, `cargo vet`, etc."
msgstr "`cargo Audit`、`cargo vet` 等 Cargo 工具"

#: src/chromium/cargo.md
msgid ""
"Rust libraries vendored into `//third_party/rust` (audited by "
"security@chromium.org)"
msgstr ""
"包含到 `//third_party/rust` 的 Rust 库（由 security@chromium.org 进行审核）"

#: src/chromium/cargo.md
msgid "Other Rust libraries (some niche, some quite popular and commonly used)"
msgstr "其他 Rust 库（一些小众但很受欢迎又常用的库）"

#: src/chromium/policy.md
msgid "Chromium Rust policy"
msgstr "Chromium Rust 政策"

#: src/chromium/policy.md
msgid ""
"Chromium does not yet allow first-party Rust except in rare cases as "
"approved by Chromium's [Area Tech Leads](https://source.chromium.org/"
"chromium/chromium/src/+/main:ATL_OWNERS)."
msgstr ""
"Chromium 尚不支持使用第一方 Rust，除非是经过 [区域技术主管](https://source."
"chromium.org/chromium/chromium/src/+/main:ATL_OWNERS) 批准的特殊情况。"

#: src/chromium/policy.md
msgid ""
"Chromium's policy on third party libraries is outlined [here](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party."
"md#rust) - Rust is allowed for third party libraries under various "
"circumstances, including if they're the best option for performance or for "
"security."
msgstr ""
"有关 Chromium 的第三方库政策，请参阅 [此处](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#rust)。根据该这些政策，"
"在很多情况下允许将 Rust 作为第三方库使用，包括无论是在性能还是安全方面，它们"
"都是理想之选。"

#: src/chromium/policy.md
msgid ""
"Very few Rust libraries directly expose a C/C++ API, so that means that "
"nearly all such libraries will require a small amount of first-party glue "
"code."
msgstr ""
"鲜少有 Rust 库会直接公开 C/C++ API，这意味着几乎所有此类库都需要使用少量的第"
"一方粘合代码。"

#: src/chromium/policy.md
#, fuzzy
msgid ""
"```bob\n"
"\"C++\"                           Rust\n"
".- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - "
"-.\n"
":                   :           :                                             :\n"
": Existing Chromium :           :  Chromium Rust              Existing "
"Rust   :\n"
": \"C++\"             :           :  \"wrapper\"                  "
"crate           :\n"
": +---------------+ :           : +----------------+          +-------------"
"+ :\n"
": |               | :           : |                |          |             "
"| :\n"
": |         o-----+-+-----------+-+->            o-+----------+-->          "
"| :\n"
": |               | : Language  : |                | Crate    |             "
"| :\n"
": +---------------+ : boundary  : +----------------+ API      +-------------"
"+ :\n"
":                   :           :                                             :\n"
"`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - "
"-'\n"
"```"
msgstr ""
"```bob\n"
" 栈                             堆\n"
".- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - -.\n"
":                           :     :                           :\n"
":    s1 \"（无法访问）\"    :     :                           :\n"
":   +-----------+-------+   :     :   +----+----+----+----+   :\n"
":   | ptr       |   o---+---+--+--+-->| R  | u  | s  | t  |   :\n"
":   | len       |     4 |   :  |  :   +----+----+----+----+   :\n"
":   | capacity  |     4 |   :  |  :                           :\n"
":   +-----------+-------+   :  |  :                           :\n"
":                           :  |  `- - - - - - - - - - - - - -'\n"
":    s2                     :  |\n"
":   +-----------+-------+   :  |\n"
":   | ptr       |   o---+---+--'\n"
":   | len       |     4 |   :\n"
":   | capacity  |     4 |   :\n"
":   +-----------+-------+   :\n"
":                           :\n"
"`- - - - - - - - - - - - - -'\n"
"```"

#: src/chromium/policy.md
msgid ""
"First-party Rust glue code for a particular third-party crate should "
"normally be kept in `third_party/rust/<crate>/<version>/wrapper`."
msgstr ""
"特定第三方 crate 的第一方 Rust 粘合代码通常应放在 `third_party/rust/<crate>/"
"<version>/wrapper` 目录中。"

#: src/chromium/policy.md
msgid "Because of this, today's course will be heavily focused on:"
msgstr "因此，今天的课程将重点介绍以下内容："

#: src/chromium/policy.md
msgid "Bringing in third-party Rust libraries (\"crates\")"
msgstr "引入第三方 Rust 库 (\"crates\")"

#: src/chromium/policy.md
msgid "Writing glue code to be able to use those crates from Chromium C++."
msgstr "编写粘合代码，以便能够从 Chromium C++ 中使用这些 crate。"

#: src/chromium/policy.md
msgid "If this policy changes over time, the course will evolve to keep up."
msgstr "如果此政策随时间而发生变化，则本课程也会随之更新。"

#: src/chromium/build-rules.md
#, fuzzy
msgid "Build rules"
msgstr "构建规则"

#: src/chromium/build-rules.md
msgid ""
"Rust code is usually built using `cargo`. Chromium builds with `gn` and "
"`ninja` for efficiency --- its static rules allow maximum parallelism. Rust "
"is no exception."
msgstr ""
"Rust 代码通常使用 `cargo` 构建而成。为提高效率，Chromium 使用 `gn` 和 "
"`ninja` 进行构建，其静态规则支持实现最大程度的并行处理。Rust 也不例外。"

#: src/chromium/build-rules.md
#, fuzzy
msgid "Adding Rust code to Chromium"
msgstr "在 Chromium 中添加 Rust 代码"

#: src/chromium/build-rules.md
msgid ""
"In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:"
msgstr "在一些现有的 Chromium `BUILD.gn` 文件中，声明 `rust_static_library`："

#: src/chromium/build-rules.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules.md
msgid ""
"You can also add `deps` on other Rust targets. Later we'll use this to "
"depend upon third party code."
msgstr ""
"您还可以在其他 Rust 目标上添加 `deps`。稍后，我们通过该操作来使用第三方代码。"

#: src/chromium/build-rules.md
msgid ""
"You must specify _both_ the crate root, _and_ a full list of sources. The "
"`crate_root` is the file given to the Rust compiler representing the root "
"file of the compilation unit --- typically `lib.rs`. `sources` is a complete "
"list of all source files which `ninja` needs in order to determine when "
"rebuilds are necessary."
msgstr ""
"您必须 _同时_ 指定 crate 根目录 _和_ 完整的源代码列表。`crate_root` 是供 "
"Rust 编译器使用的文件，表示编译单元的根文件，通常为 `lib.rs`。`sources` 是所"
"有源文件的完整列表，`ninja` 需要用它来确定何时该进行重新构建。"

#: src/chromium/build-rules.md
msgid ""
"(There's no such thing as a Rust `source_set`, because in Rust, an entire "
"crate is a compilation unit. A `static_library` is the smallest unit.)"
msgstr ""
"（在 Rust 中，并不存在所谓的 Rust `source_set`，因为整个 crate 就是一个编译单"
"元。`static_library` 是最小的单元。）"

#: src/chromium/build-rules.md
msgid ""
"Students might be wondering why we need a gn template, rather than using "
"[gn's built-in support for Rust static libraries](https://gn.googlesource."
"com/gn/+/main/docs/reference.md#func_static_library). The answer is that "
"this template provides support for CXX interop, Rust features, and unit "
"tests, some of which we'll use later."
msgstr ""
"学生可能会疑惑为何我们需要 gn 模板，而不使用 [gn 内置的 Rust 静态库支持]"
"(https://gn.googlesource.com/gn/+/main/docs/reference."
"md#func_static_library) 进行操作。原因是此模板支持 CXX 互操作性、各项 Rust 功"
"能以及单元测试，我们稍后便会用到其中的一些功能。"

#: src/chromium/build-rules/unsafe.md
#, fuzzy
msgid "Including `unsafe` Rust Code"
msgstr "添加 `unsafe` Rust 代码"

#: src/chromium/build-rules/unsafe.md
msgid ""
"Unsafe Rust code is forbidden in `rust_static_library` by default --- it "
"won't compile. If you need unsafe Rust code, add `allow_unsafe = true` to "
"the gn target. (Later in the course we'll see circumstances where this is "
"necessary.)"
msgstr ""
"默认情况下，禁止在 `rust_static_library` 中使用不安全的 Rust 代码，因为此类代"
"码无法编译。如需使用不安全的 Rust 代码，请将 `allow_unsafe = true` 添加到 gn "
"目标中。（在本课程的稍后部分，我们将介绍在哪些情形下必须这样做。）"

#: src/chromium/build-rules/unsafe.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [\n"
"    \"lib.rs\",\n"
"    \"hippopotamus.rs\"\n"
"  ]\n"
"  allow_unsafe = true\n"
"}\n"
"```"

#: src/chromium/build-rules/depending.md
msgid "Simply add the above target to the `deps` of some Chromium C++ target."
msgstr "只需将上述目标添加到某些 Chromium C++ 目标的 `deps` 中即可。"

#: src/chromium/build-rules/depending.md
msgid ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"import(\"//build/rust/rust_static_library.gni\")\n"
"\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"}\n"
"\n"
"# or source_set, static_library etc.\n"
"component(\"preexisting_cpp\") {\n"
"  deps = [ \":my_rust_lib\" ]\n"
"}\n"
"```"

#: src/chromium/build-rules/vscode.md
msgid ""
"Types are elided in Rust code, which makes a good IDE even more useful than "
"for C++. Visual Studio code works well for Rust in Chromium. To use it,"
msgstr ""
"在 Rust 代码中，通常会省略类型，这使得拥有强大的 IDE 甚至比 C++ 更为有用。"
"Visual Studio Code 非常适用于在 Chromium 中处理 Rust 代码。如需使用此功能，"

#: src/chromium/build-rules/vscode.md
msgid ""
"Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of "
"Rust support"
msgstr ""
"请确保您的 VSCode 安装了 `rust-analyzer` 扩展程序，而不是较早版本的 Rust 支持"
"插件。"

#: src/chromium/build-rules/vscode.md
msgid ""
"`gn gen out/Debug --export-rust-project` (or equivalent for your output "
"directory)"
msgstr "`gn gen out/Debug --export-rust-project`（或输出目录的等效项）"

#: src/chromium/build-rules/vscode.md
msgid "`ln -s out/Debug/rust-project.json rust-project.json`"
msgstr "`In -s out/Debug/rust-project.json rust-project.json`"

#: src/chromium/build-rules/vscode.md
msgid ""
"A demo of some of the code annotation and exploration features of rust-"
"analyzer might be beneficial if the audience are naturally skeptical of IDEs."
msgstr ""
"如果受众群体对 IDE 持有怀疑态度，不妨演示下 rust-analyzer 的部分代码注解和探"
"索功能，或许能让他们改观。"

#: src/chromium/build-rules/vscode.md
msgid ""
"The following steps may help with the demo (but feel free to instead use a "
"piece of Chromium-related Rust that you are most familiar with):"
msgstr ""
"以下步骤可能会对演示有所帮助（但您也可以选用一段最为熟悉的 Chromium 相关 "
"Rust 代码）："

#: src/chromium/build-rules/vscode.md
msgid "Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"
msgstr "打开 `components/qr_code_generator/qr_code_generator_ffi_glue.rs`"

#: src/chromium/build-rules/vscode.md
msgid ""
"Place the cursor over the `QrCode::new` call (around line 26) in "
"\\`qr_code_generator_ffi_glue.rs"
msgstr ""
"将光标置于 \\`qr_code_generator_ffi_glue.rs 中的 `QrCode::new` 调用（大约第 "
"26 行）上"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC = "
"K)."
msgstr ""
"演示 **show documentation**（典型绑定：vscode = ctrl ki；vim/CoC = K）。"

#: src/chromium/build-rules/vscode.md
#, fuzzy
msgid ""
"Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d). "
"(This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)"
msgstr ""
"演示 **go to definition**（典型绑定：vscode = F12；vim/CoC = gd）。（然后您会"
"前往 `//third_party/rust/.../qr_code-.../src/lib.rs`。）"

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **outline** and navigate to the `QrCode::with_bits` method (around line "
"164; the outline is in the file explorer pane in vscode; typical vim/CoC "
"bindings = space o)"
msgstr ""
"演示 **outline** 并前往 `QrCode::with_bits` 方法（大约第 164 行；大纲位于 "
"vscode 中的文件资源管理器窗格中；典型绑定：vim/CoC = space o）"

#: src/chromium/build-rules/vscode.md
msgid ""
"Demo **type annotations** (there are quote a few nice examples in the "
"`QrCode::with_bits` method)"
msgstr ""
"演示 **type annotations**（`QrCode::with_bits` 方法中提供了一些很好的示例）"

#: src/chromium/build-rules/vscode.md
msgid ""
"It may be worth pointing out that `gn gen ... --export-rust-project` will "
"need to be rerun after editing `BUILD.gn` files (which we will do a few "
"times throughout the exercises in this session)."
msgstr ""
"值得注意的是，修改 `BUILD.gn` 文件后，需要重新运行 `gn gen ... --export-rust-"
"project`（我们将在本课程的练习中多次执行该操作）。"

#: src/exercises/chromium/build-rules.md
#, fuzzy
msgid "Build rules exercise"
msgstr "构建规则练习"

#: src/exercises/chromium/build-rules.md
msgid ""
"In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn` "
"containing:"
msgstr ""
"在 Chromium build 中，向 `//ui/base/BUILD.gn` 添加新的 Rust 目标，其中包含："

#: src/exercises/chromium/build-rules.md
msgid ""
"**Important**: note that `no_mangle` here is considered a type of unsafety "
"by the Rust compiler, so you'll need to to allow unsafe code in your `gn` "
"target."
msgstr ""
"**重要提示**：请注意，在此处使用 `no_mangle` 会被Rust 编译器视为一种不安全行"
"为，因此需要允许在“gn”目标中使用不安全的代码。"

#: src/exercises/chromium/build-rules.md
msgid ""
"Add this new Rust target as a dependency of `//ui/base:base`. Declare this "
"function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll "
"see how this can be automated by bindings generation tools):"
msgstr ""
"将这个新的 Rust 目标添加为 `//ui/base:base` 的依赖项。在 `ui/base/resource/"
"resource_bundle.cc` 顶部声明此函数（稍后，我们将介绍如何通过绑定生成工具来自"
"动执行此操作）："

#: src/exercises/chromium/build-rules.md
msgid ""
"Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - "
"we suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build "
"and run Chromium, and ensure that \"Hello from Rust!\" is printed lots of "
"times."
msgstr ""
"从 `ui/base/resource/resource_bundle.cc` 中的某个位置调用此函数，我们建议在"
"从 `ResourceBundle::MaybeMangleLocalizedString` 的顶部调用此函数。构建并运行 "
"Chromium，并确保多次显示 \"Hello from Rust!\"。"

#: src/exercises/chromium/build-rules.md
msgid ""
"If you use VSCode, now set up Rust to work well in VSCode. It will be useful "
"in subsequent exercises. If you've succeeded, you will be able to use right-"
"click \"Go to definition\" on `println!`."
msgstr ""
"如果您使用 VSCode，现在就请设置 Rust，以便其能在 VSCode 中正常运行。这对后续"
"练习会很有帮助。如果操作成功，则可使用右键点击 `println!` 上的 \"Go to "
"definition\"。"

#: src/exercises/chromium/build-rules.md
#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Where to find help"
msgstr "如何获取帮助"

#: src/exercises/chromium/build-rules.md
msgid ""
"The options available to the [`rust_static_library` gn template](https://"
"source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_static_library.gni;l=16)"
msgstr ""
"适用于 [`rust_static_library` gn 模板] 的选项 (https://source.chromium.org/"
"chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about [`#[no_mangle]`](https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"
msgstr ""
"关于 [`#[no_mangle]`] 的详细信息 (https://doc.rust-lang.org/beta/reference/"
"abi.html#the-no_mangle-attribute)"

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about [`extern \"C\"`](https://doc.rust-lang.org/std/keyword."
"extern.html)"
msgstr ""
"关于 [`extern \"C\"`] 的详细信息 (https://doc.rust-lang.org/std/keyword."
"extern.html)"

#: src/exercises/chromium/build-rules.md
msgid ""
"Information about gn's [`--export-rust-project`](https://gn.googlesource.com/"
"gn/+/main/docs/reference.md#compilation-database) switch"
msgstr ""
"关于 gn 的 [`--export-rust-project`] 开关的详细信息 (https://gn.googlesource."
"com/gn/+/main/docs/reference.md#compilation-database) "

#: src/exercises/chromium/build-rules.md
msgid ""
"[How to install rust-analyzer in VSCode](https://code.visualstudio.com/docs/"
"languages/rust)"
msgstr ""
"[如何在 VSCode 中安装 rust-analyzer](https://code.visualstudio.com/docs/"
"languages/rust)"

#: src/exercises/chromium/build-rules.md
msgid ""
"This example is unusual because it boils down to the lowest-common-"
"denominator interop language, C. Both C++ and Rust can natively declare and "
"call C ABI functions. Later in the course, we'll connect C++ directly to "
"Rust."
msgstr ""
"此示例很独特，因为其归根结底是最通用的互操作语言，即 C 语言。C++ 和 Rust 本身"
"都可以声明和调用 C ABI 函数。在本课程的稍后部分，我们会直接将 C++ 和 Rust 关"
"联起来。"

#: src/exercises/chromium/build-rules.md
msgid ""
"`allow_unsafe = true` is required here because `#[no_mangle]` might allow "
"Rust to generate two functions with the same name, and Rust can no longer "
"guarantee that the right one is called."
msgstr ""
"此处需要使用 `allow_unsafe = true`，因为 `#[no_mangle]` 可能会支持 Rust 生成"
"两个同名函数，而 Rust 无法保证会调用正确的函数。"

#: src/exercises/chromium/build-rules.md
msgid ""
"If you need a pure Rust executable, you can also do that using the "
"`rust_executable` gn template."
msgstr ""
"如果需要纯 Rust 可执行文件，也可以使用 `rust_executable` gn 模板执行此操作。"

#: src/chromium/testing.md
msgid ""
"Rust community typically authors unit tests in a module placed in the same "
"source file as the code being tested. This was covered [earlier](../testing."
"md) in the course and looks like this:"
msgstr ""

#: src/chromium/testing.md
msgid ""
"In Chromium we place unit tests in a separate source file and we continue to "
"follow this practice for Rust --- this makes tests consistently discoverable "
"and helps to avoid rebuilding `.rs` files a second time (in the `test` "
"configuration)."
msgstr ""

#: src/chromium/testing.md
msgid ""
"This results in the following options for testing Rust code in Chromium:"
msgstr ""

#: src/chromium/testing.md
msgid ""
"Native Rust tests (i.e. `#[test]`). Discouraged outside of `//third_party/"
"rust`."
msgstr ""

#: src/chromium/testing.md
msgid ""
"`gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient "
"when Rust code is just a thin FFI layer and the existing unit tests provide "
"sufficient coverage for the feature."
msgstr ""

#: src/chromium/testing.md
msgid ""
"`gtest` tests authored in Rust and using the crate under test through its "
"public API (using `pub mod for_testing { ... }` if needed). This is the "
"subject of the next few slides."
msgstr ""

#: src/chromium/testing.md
msgid ""
"Mention that native Rust tests of third-party crates should eventually be "
"exercised by Chromium bots. (Such testing is needed rarely --- only after "
"adding or updating third-party crates.)"
msgstr ""

#: src/chromium/testing.md
msgid ""
"Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be "
"used:"
msgstr ""

#: src/chromium/testing.md
msgid ""
"QR has very little functionality in the first-party Rust layer (it's just a "
"thin FFI glue) and therefore uses the existing C++ unit tests for testing "
"both the C++ and the Rust implementation (parameterizing the tests so they "
"enable or disable Rust using a `ScopedFeatureList`)."
msgstr ""

#: src/chromium/testing.md
msgid ""
"Hypothetical/WIP PNG integration may need to implement memory-safe "
"implementation of pixel transformations that are provided by `libpng` but "
"missing in the `png` crate - e.g. RGBA => BGRA, or gamma correction. Such "
"functionality may benefit from separate tests authored in Rust."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"The [`rust_gtest_interop`](https://chromium.googlesource.com/chromium/src/+/"
"main/testing/rust_gtest_interop/README.md) library provides a way to:"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]` "
"attribute)"
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
msgid ""
"Use `expect_eq!` and similar macros (similar to `assert_eq!` but not "
"panicking and not terminating the test when the assertion fails)."
msgstr ""

#: src/chromium/testing/rust-gtest-interop.md
#, fuzzy
msgid "Example:"
msgstr "示例"

#: src/chromium/testing/build-gn.md
msgid ""
"The simplest way to build Rust `gtest` tests is to add them to an existing "
"test binary that already contains tests authored in C++. For example:"
msgstr ""

#: src/chromium/testing/build-gn.md
msgid ""
"```gn\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  sources += [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps += [ \":my_rust_lib\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/build-gn.md
msgid ""
"Authoring Rust tests in a separate `static_library` also works, but requires "
"manually declaring the dependency on the support libraries:"
msgstr ""

#: src/chromium/testing/build-gn.md
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib_unittests\") {\n"
"  testonly = true\n"
"  is_gtest_unittests = true\n"
"  crate_root = \"my_rust_lib_unittest.rs\"\n"
"  sources = [ \"my_rust_lib_unittest.rs\" ]\n"
"  deps = [\n"
"    \":my_rust_lib\",\n"
"    \"//testing/rust_gtest_interop\",\n"
"  ]\n"
"}\n"
"\n"
"test(\"ui_base_unittests\") {\n"
"  ...\n"
"  deps += [ \":my_rust_lib_unittests\" ]\n"
"}\n"
"```"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"After adding `:my_rust_lib` to GN `deps`, we still need to learn how to "
"import and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't "
"provided an explicit `crate_name` for `my_rust_lib` so its crate name is "
"computed based on the full target path and name. Fortunately we can avoid "
"working with such an unwieldy name by using the `chromium::import!` macro "
"from the automatically-imported `chromium` crate:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
#, fuzzy
msgid "\"//ui/base:my_rust_lib\""
msgstr "\"ui/base/my_rust_file.rs.h\""

#: src/chromium/testing/chromium-import-macro.md
msgid "Under the covers the macro expands to something similar to:"
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"More information can be found in [the doc comment](https://source.chromium."
"org/chromium/chromium/src/+/main:build/rust/chromium_prelude/"
"chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:"
"third_party&ss=chromium%2Fchromium%2Fsrc) of the `chromium::import` macro."
msgstr ""

#: src/chromium/testing/chromium-import-macro.md
msgid ""
"`rust_static_library` supports specifying an explicit name via `crate_name` "
"property, but doing this is discouraged. And it is discouraged because the "
"crate name has to be globally unique. crates.io guarantees uniqueness of its "
"crate names so `cargo_crate` GN targets (generated by the `gnrt` tool "
"covered in a later section) use short crate names."
msgstr ""

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Testing exercise"
msgstr "习题"

#: src/exercises/chromium/testing.md
#, fuzzy
msgid "Time for another exercise!"
msgstr "是时候进行下一个练习了！"

#: src/exercises/chromium/testing.md
msgid "In your Chromium build:"
msgstr ""

#: src/exercises/chromium/testing.md
msgid ""
"Add a testable function next to `hello_from_rust`. Some suggestions: adding "
"two integers received as arguments, computing the nth Fibonacci number, "
"summing integers in a slice, etc."
msgstr ""

#: src/exercises/chromium/testing.md
msgid "Add a separate `..._unittest.rs` file with a test for the new function."
msgstr ""

#: src/exercises/chromium/testing.md
msgid "Add the new tests to `BUILD.gn`."
msgstr ""

#: src/exercises/chromium/testing.md
msgid "Build the tests, run them, and verify that the new test works."
msgstr ""

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The Rust community offers multiple options for C++/Rust interop, with new "
"tools being developed all the time. At the moment, Chromium uses a tool "
"called CXX."
msgstr ""
"Rust 社区提供了多种 C++/Rust 互操作选项，并且一直在不断开发新工具。目前，"
"Chromium 使用一种名为 CXX 的工具。"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"You describe your whole language boundary in an interface definition "
"language (which looks a lot like Rust) and then CXX tools generate "
"declarations for functions and types in both Rust and C++."
msgstr ""
"您可以使用接口定义语言（与 Rust 极为相似）描述整个语言边界，然后 CXX 工具会据"
"此生成 Rust 和 C++ 函数及类型的声明。"

#: src/chromium/interoperability-with-cpp.md
#, fuzzy
msgid ""
"See the [CXX tutorial](https://cxx.rs/tutorial.html) for a full example of "
"using this."
msgstr ""
"请参阅 [CXX tutorial](https://cxx.rs/tutorial.html) ，了解有关使用的完整示"
"例。"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"Talk through the diagram. Explain that behind the scenes, this is doing just "
"the same as you previously did. Point out that automating the process has "
"the following benefits:"
msgstr ""
"请仔细研究这个图表。解释背后的原理和您之前所做的完全相同。说明自动执行这一流"
"程具有以下好处："

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The tool guarantees that the C++ and Rust sides match (e.g. you get compile "
"errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust "
"definitions, but with out-of-sync manual bindings you'd get Undefined "
"Behavior)"
msgstr ""
"使用该工具可保证 C++ 端和 Rust 端相匹配（例如，如果 `#[cxx::bridge]` 与实际"
"的 C++ 或 Rust 定义不匹配，则会出现编译错误。但使用不同步的手动绑定，可能会导"
"致未定义行为）"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"The tool automates generation of FFI thunks (small, C-ABI-compatible, free "
"functions) for non-C features (e.g. enabling FFI calls into Rust or C++ "
"methods; manual bindings would require authoring such top-level, free "
"functions manually)"
msgstr ""
"该工具还可自动生成 FFI thunk（即小型但可兼容 C-ABI 的自由函数），以便适应非 "
"C 语言特性（例如，启用对 Rust 或 C++ 方法的 FFI 调用；而手动实现绑定一般需要"
"自行编写这种顶级的自由函数）"

#: src/chromium/interoperability-with-cpp.md
msgid "The tool and the library can handle a set of core types - for example:"
msgstr "该工具和库可以处理一系列核心类型，例如："

#: src/chromium/interoperability-with-cpp.md
msgid ""
"`&[T]` can be passed across the FFI boundary, even though it doesn't "
"guarantee any particular ABI or memory layout. With manual bindings `std::"
"span<T>` / `&[T]` have to be manually destructured and rebuilt out of a "
"pointer and length - this is error-prone given that each language represents "
"empty slices slightly differently)"
msgstr ""
"`&[T]` 可以跨 FFI 边界进行传递，即使它无法保证任何特定的 ABI 或内存布局一致无"
"误。进行手动绑定时，必须手动解构 `std::span<T>` / `&[T]`，并根据指针和长度进"
"行重新构建，但这很容易出错，因为每种语言对于空 slice 的表示方式略有不同"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box` "
"are natively supported. With manual bindings, one would have to pass C-ABI-"
"compatible raw pointers, which would increase lifetime and memory-safety "
"risks."
msgstr ""
"系统对 `std::unique_ptr<T>`、`std::shared_ptr<T>` 和/或 `Box` 等智能指针提供"
"原生支持。如果使用手动绑定，则必须传递可兼容 C-ABI 的原始指针，这会增加生命周"
"期和内存安全风险。"

#: src/chromium/interoperability-with-cpp.md
msgid ""
"`rust::String` and `CxxString` types understand and maintain differences in "
"string representation across the languages (e.g. `rust::String::lossy` can "
"build a Rust string from non-UTF8 input and `rust::String::c_str` can NUL-"
"terminate a string)."
msgstr ""
"`rust::String` 和 `CxxString` 类型能够识别并处理不同语言之间在字符串表示方面"
"的差异（例如，`rust::String::lossy` 可以通过非 UTF8 输入构建 Rust 字符串；"
"`rust::String::c_str` 可以为字符串加上 NUL 终止符）。"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid ""
"CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge` "
"modules inside `.rs` source code."
msgstr ""
"根据 CXX 要求，在 `.rs` 源代码内的 `cxx::bridge` “模块”中声明整个 C++/Rust 边"
"界。"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "\"example/include/blobstore.h\""
msgstr "\"example/include/blobstore.h\""

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "// Definitions of Rust types and functions go here\n"
msgstr "// Definitions of Rust types and functions go here\n"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Point out:"
msgstr "指出："

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` "
"procedural macro does complex things to it. The generated code is quite a "
"bit more sophisticated - though this does still result in a `mod` called "
"`ffi` in your code."
msgstr ""

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for C++'s `std::unique_ptr` in Rust"
msgstr "RRust 对 C++ 的 `std::unique_ptr` 提供原生支持"

#: src/chromium/interoperability-with-cpp/example-bindings.md
#, fuzzy
msgid "Native support for Rust slices in C++"
msgstr "RRust 对 C++ 的 `std::unique_ptr` 提供原生支持"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Calls from C++ to Rust, and Rust types (in the top part)"
msgstr "从 C++ 调用 Rust，并使用 Rust 类型（顶部位置）"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid "Calls from Rust to C++, and C++ types (in the bottom part)"
msgstr "从 Rust 调用 C++，并使用 C++ 类型（底部位置）"

#: src/chromium/interoperability-with-cpp/example-bindings.md
msgid ""
"**Common misconception**: It _looks_ like a C++ header is being parsed by "
"Rust, but this is misleading. This header is never interpreted by Rust, but "
"simply `#include`d in the generated C++ code for the benefit of C++ "
"compilers."
msgstr ""
"**常见误解**：这 _看似_ Rust 在解析 C++ 头文件，其实具有误导性。Rust 不会对此"
"头文件进行解释，只是在生成的 C++ 代码中添加 `#include`，以便于 C++ 编译器 使"
"用。"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
#, fuzzy
msgid ""
"By far the most useful page when using CXX is the [type reference](https://"
"cxx.rs/bindings.html)."
msgstr "展示 [Rust 和 C++类型](https://cxx.rs/bindings.html) 之间的对应关系："

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "CXX fundamentally suits cases where:"
msgstr "CXX 基本适用于以下情况："

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"Your Rust-C++ interface is sufficiently simple that you can declare all of "
"it."
msgstr "您的 Rust-C++ 接口非常简单，可以声明其中的全部内容。"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"You're using only the types natively supported by CXX already, for example "
"`std::unique_ptr`, `std::string`, `&[u8]` etc."
msgstr ""
"目前，您只使用了 CXX 提供原生支持的类型，例如 `std::unique_ptr`、`std::"
"string`、`&[u8]` 等。"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"It has many limitations --- for example lack of support for Rust's `Option` "
"type."
msgstr "这样具有很多局限性，例如缺少对 Rust 的 `Option` 类型的支持。"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"These limitations constrain us to using Rust in Chromium only for well "
"isolated \"leaf nodes\" rather than for arbitrary Rust-C++ interop. When "
"considering a use-case for Rust in Chromium, a good starting point is to "
"draft the CXX bindings for the language boundary to see if it appears simple "
"enough."
msgstr ""
"由于这些局限，我们在 Chromium 中只能将 Rust 用于隔离紧密的 “叶节点”，而无法用"
"于任意的 Rust-C++ 互操作。当您打算在 Chromium 中探索 Rust 的应用场景时，推荐"
"先从拟定针对语言边界的 CXX 绑定入手，以查看该语言边界是否足够简单明了。"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"You should also discuss some of the other sticky points with CXX, for "
"example:"
msgstr "此外，还应讨论使用 CXX 时的其他一些困难之处，例如："

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid ""
"Its error handling is based around C++ exceptions (given on the next slide)"
msgstr "其根据 C++ 异常来进行错误处理（下一张幻灯片中将加以介绍）"

#: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
msgid "Function pointers are awkward to use."
msgstr "函数指针使用起来很不方便。"

#: src/chromium/interoperability-with-cpp/error-handling.md
#, fuzzy
msgid ""
"CXX's [support for `Result<T,E>`](https://cxx.rs/binding/result.html) relies "
"on C++ exceptions, so we can't use that in Chromium. Alternatives:"
msgstr ""
"CXX 对于 `Result<T,E>` 类型的支持取决于 C++ 异常机制，因此无法在 Chromium 中"
"使用该功能。替代选项："

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "The `T` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Returned via out parameters (e.g. via `&mut T`). This requires that `T` can "
"be passed across the FFI boundary - for example `T` has to be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "A primitive type (like `u32` or `usize`)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"A type natively supported by `cxx` (like `UniquePtr<T>`) that has a suitable "
"default value to use in a failure case (_unlike_ `Box<T>`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Retained on the Rust side, and exposed via reference. This may be needed "
"when `T` is a Rust type, which cannot be passed across the FFI boundary, and "
"cannot be stored in `UniquePtr<T>`."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid "The `E` part of `Result<T, E>` can be:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Returned as a boolean (e.g. `true` representing success, and `false` "
"representing failure)"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling.md
msgid ""
"Preserving error details is in theory possible, but so far hasn't been "
"needed in practice."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid "CXX Error Handling: QR Example"
msgstr "错误处理"

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
#, fuzzy
msgid ""
"The QR code generator is [an example](https://source.chromium.org/chromium/"
"chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue."
"rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca) where a boolean is "
"used to communicate success vs failure, and where the successful result can "
"be passed across the FFI boundary:"
msgstr ""
"如果操作成功，则可用简单的布尔值进行表示，如 [二维码生成器](https://source."
"chromium.org/chromium/chromium/src/+/main:components/qr_code_generator/"
"qr_code_generator_ffi_glue.rs;l=10) 中的原理一样：返回表示操作成功的布尔值，"
"并使用输出参数记录结果："

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid "\"qr_code_generator\""
msgstr "\"qr_code_generator\""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"Students may be curious about the semantics of the `out_qr_size` output. "
"This is not the size of the vector, but the size of the QR code (and "
"admittedly it is a bit redundant - this is the square root of the size of "
"the vector)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"It may be worth pointing out the importance of initializing `out_qr_size` "
"before calling into the Rust function. Creation of a Rust reference that "
"points to uninitialized memory results in Undefined Behavior (unlike in C++, "
"when only the act of dereferencing such memory results in UB)."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-qr.md
msgid ""
"If students ask about `Pin`, then explain why CXX needs it for mutable "
"references to C++ data: the answer is that C++ data can’t be moved around "
"like Rust data, because it may contain self-referential pointers."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
#, fuzzy
msgid "CXX Error Handling: PNG Example"
msgstr "错误处理"

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"A prototype of a PNG decoder illustrates what can be done when the "
"successful result cannot be passed across the FFI boundary:"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "\"gfx::rust_bindings\""
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"/// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,\n"
"        /// ()>`.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "/// C++ bindings for the `crate::png::ResultOfPngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid "/// C++ bindings for the `crate::png::PngReader` type.\n"
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"`PngReader` and `ResultOfPngReader` are Rust types --- objects of these "
"types cannot cross the FFI boundary without indirection of a `Box<T>`. We "
"can't have an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ "
"to store Rust objects by value."
msgstr ""

#: src/chromium/interoperability-with-cpp/error-handling-png.md
msgid ""
"This example illustrates that even though CXX doesn't support arbitrary "
"generics nor templates, we can still pass them across the FFI boundary by "
"manually specializing / monomorphizing them into a non-generic type. In the "
"example `ResultOfPngReader` is a non-generic type that forwards into "
"appropriate methods of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or "
"`as_mut`)."
msgstr ""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid "Using cxx in Chromium"
msgstr "在 Chromium 中使用 cxx"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-"
"node where we want to use Rust. You'd typically have one for each "
"`rust_static_library`. Just add"
msgstr ""
"在 Chromium 中，针对每个需要使用 Rust 的叶节点，我们定义独立的 `#[cxx::"
"bridge] mod`。通常，每个 `rust_static_library` 都有对应的定义。只需将"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"
msgstr ""
"```gn\n"
"cxx_bindings = [ \"my_rust_file.rs\" ]\n"
"   # list of files containing #[cxx::bridge], not all source files\n"
"allow_unsafe = true\n"
"```"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"to your existing `rust_static_library` target alongside `crate_root` and "
"`sources`."
msgstr ""
"添加到您现有的 `rust_static_library` 以及 `crate_root` 和 `sources` 的目标"
"中。"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "C++ headers will be generated at a sensible location, so you can just"
msgstr "C++ 头文件会在合理的位置生成，因此您只需"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "\"ui/base/my_rust_file.rs.h\""
msgstr "\"ui/base/my_rust_file.rs.h\""

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"You will find some utility functions in `//base` to convert to/from Chromium "
"C++ types to CXX Rust types --- for example [`SpanToRustSlice`](https://"
"source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;"
"l=21)."
msgstr ""
"您会发现，`//base` 中提供了一些实用函数，可将 Chromium C++ 类型与 CXX Rust 类"
"型相互转换，例如 [`SpanToRustSlice`](https://source.chromium.org/chromium/"
"chromium/src/+/main:base/containers/span_rust.h;l=21)。"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid "Students may ask --- why do we still need `allow_unsafe = true`?"
msgstr "学生可能会问：为什么我们仍然需要 `allow_unsafe = true`？"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
msgid ""
"The broad answer is that no C/C++ code is \"safe\" by the normal Rust "
"standards. Calling back and forth to C/C++ from Rust may do arbitrary things "
"to memory, and compromise the safety of Rust's own data layouts. Presence of "
"_too many_ `unsafe` keywords in C/C++ interop can harm the signal-to-noise "
"ratio of such a keyword, and is [controversial](https://steveklabnik.com/"
"writing/the-cxx-debate), but strictly, bringing any foreign code into a Rust "
"binary can cause unexpected behavior from Rust's perspective."
msgstr ""
"总的来说，按照常规 Rust 标准，没有任何 C/C++ 代码是 “安全”的。在 Rust 中来回"
"调用 C/C++ 可能会对内存执行任意操作，并危及 Rust 自身数据布局的安全性。如果 "
"C/C++ 互操作性中出现 _过多_ 的 `unsafe` 关键字，可能会损害此类关键字的信噪"
"比，并且 [存在争议](https://steveklabnik.com/writing/the-cxx-debate)。但严格"
"地说，将任何外部代码引入 Rust 二进制文件可能会导致 Rust 中出现意外行为。"

#: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
#, fuzzy
msgid ""
"The narrow answer lies in the diagram at the top of [this page](../"
"interoperability-with-cpp.md) --- behind the scenes, CXX generates Rust "
"`unsafe` and `extern \"C\"` functions just like we did manually in the "
"previous section."
msgstr ""
"具体答案可在本页顶部的图表中找到：CXX 会在后台生成 Rust `unsafe` 和 `extern "
"\"C\"` 函数，与我们在上一部分手动生成的函数类似。"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Exercise: Interoperability with C++"
msgstr "与 C 的互操作性"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part one"
msgstr "第一部分"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"In the Rust file you previously created, add a `#[cxx::bridge]` which "
"specifies a single function, to be called from C++, called "
"`hello_from_rust`, taking no parameters and returning no value."
msgstr ""
"在您之前创建的 Rust 文件中，添加 `#[cxx::bridge]` 来指定一个将从 C++ 调用的函"
"数（名为 `hello_from_rust`），该函数不接受任何参数也不返回任何值。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Modify your previous `hello_from_rust` function to remove `extern \"C\"` and "
"`#[no_mangle]`. This is now just a standard Rust function."
msgstr ""
"修改之前的 `hello_from_rust` 函数，移除 `extern \"C\"` 和 `#[no_mangle]`。现"
"在，这只是一个标准的 Rust 函数。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Modify your `gn` target to build these bindings."
msgstr "请修改 `gn` 目标以构建这些绑定。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"In your C++ code, remove the forward-declaration of `hello_from_rust`. "
"Instead, include the generated header file."
msgstr ""
"在 C++ 代码中，移除 `hello_from_rust` 的正向声明，然后添加生成的头文件。"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Build and run!"
msgstr "构建并运行！"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part two"
msgstr "第二部分"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"It's a good idea to play with CXX a little. It helps you think about how "
"flexible Rust in Chromium actually is."
msgstr ""
"建议尝试操作一下 CXX。这有助于您更好地理解 Rust 在Chromium 中的灵活性。"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "Some things to try:"
msgstr "一些注意事项："

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Call back into C++ from Rust. You will need:"
msgstr "从 Rust 回调到 C++。您需要执行以下操作："

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"An additional header file which you can `include!` from your `cxx::bridge`. "
"You'll need to declare your C++ function in that new header file."
msgstr ""
"创建一个附加头文件，且您可以从 `cxx::bridge` 对其进行 `include!` 操作。您需要"
"在这个新的头文件中声明要调用的 C++ 函数。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"An `unsafe` block to call such a function, or alternatively specify the "
"`unsafe` keyword in your `#[cxx::bridge]` [as described here](https://cxx.rs/"
"extern-c++.html#functions-and-member-functions)."
msgstr ""
"创建一个 `unsafe` 代码块，用于调用此类函数，也可以在 `#[cxx::bridge]` 中指定 "
"`unsafe` 关键字，[如此处所述](https://cxx.rs/extern-c++.html#functions-and-"
"member-functions)。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"You may also need to `#include \"third_party/rust/cxx/v1/crate/include/cxx."
"h\"`"
msgstr ""
"您可能还需要添加 `#include \"third_party/rust/cxx/v1/crate/include/cxx.h\"`"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Pass a C++ string from C++ into Rust."
msgstr "将 C++ 字符串从 C++ 传递到 Rust。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Pass a reference to a C++ object into Rust."
msgstr "将对 C++ 对象的引用传递到 Rust。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Intentionally get the Rust function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr ""
"刻意让 Rust 函数签名与 `#[cxx::bridge]` 不匹配，并逐渐熟悉所看到的错误信息。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Intentionally get the C++ function signatures mismatched from the `#[cxx::"
"bridge]`, and get used to the errors you see."
msgstr "刻意让 C++ 函数签名与 `#[cxx::bridge]` 不匹配，并适应您看到的错误。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can "
"own some C++ object."
msgstr ""
"将某个类型的 `std::unique_ptr` 从 C++ 传递到 Rust，以便 Rust 拥有某个 C++ 对"
"象的所有权。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you "
"need a `Box`)."
msgstr ""
"创建一个 Rust 对象并将其传递到 C++，以便 C++ 拥有它的所有权。（提示：您需要使"
"用 `Box`）。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Declare some methods on a C++ type. Call them from Rust."
msgstr "声明调用某个 C++ 类型的方法。从 Rust 调用它们。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Declare some methods on a Rust type. Call them from C++."
msgstr "声明调用某个 Rust 类型的方法。从 C++ 调用它们。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Part three"
msgstr "第三部分"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"Now you understand the strengths and limitations of CXX interop, think of a "
"couple of use-cases for Rust in Chromium where the interface would be "
"sufficiently simple. Sketch how you might define that interface."
msgstr ""
"现在，您已经了解了 CXX 互操作性的优势和局限，请思考几个 Rust 在 Chromium 中的"
"应用场景，其中接口要足够简单构思该如何定义该接口。"

#: src/exercises/chromium/interoperability-with-cpp.md
#, fuzzy
msgid "The [`cxx` binding reference](https://cxx.rs/bindings.html)"
msgstr "展示 [Rust 和 C++类型](https://cxx.rs/bindings.html) 之间的对应关系："

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"The [`rust_static_library` gn template](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"
msgstr ""
"[`rust_static_library` gn 模板](https://source.chromium.org/chromium/"
"chromium/src/+/main:build/rust/rust_static_library.gni;l=16)"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid "Some of the questions you may encounter:"
msgstr "您可能会遇到以下问题："

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"I'm seeing a problem initializing a variable of type X with type Y, where X "
"and Y are both function types. This is because your C++ function doesn't "
"quite match the declaration in your `cxx::bridge`."
msgstr ""
"当我用类型 Y 初始化类型 X 的变量时，出现了初始化问题，其中 X 和 Y 都是函数类"
"型。这是因为您的 C++ 函数实现与 `cxx::bridge` 中的声明并不完全一致。"

#: src/exercises/chromium/interoperability-with-cpp.md
msgid ""
"I seem to be able to freely convert C++ references into Rust references. "
"Doesn't that risk UB? For CXX's _opaque_ types, no, because they are zero-"
"sized. For CXX trivial types yes, it's _possible_ to cause UB, although "
"CXX's design makes it quite difficult to craft such an example."
msgstr ""
"我好像能随意将 C++ 引用转换为 Rust 引用。这样不会导致 UB 风险吗？对于 CXX 的_"
"不透明_类型，答案为否，因为它们的大小为零。对于 CXX 的基本类型，确实_有可能_"
"导致 UB，但鉴于 CXX 的设计策略，要构建能导致这种情况的示例颇为困难。"

#: src/chromium/adding-third-party-crates.md
msgid ""
"Rust libraries are called \"crates\" and are found at [crates.io](https://"
"crates.io). It's _very easy_ for Rust crates to depend upon one another. So "
"they do!"
msgstr ""
"Rust 库被称为 `crate`，可在 [crates.io](https://crates.io) 中找到。Rust 的 "
"crate 之间非常容易相互依赖。事实证明，他们确实如此！"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "C++ library"
msgstr "库"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Rust crate"
msgstr "Rust 生态系统"

#: src/chromium/adding-third-party-crates.md
#, fuzzy
msgid "Build system"
msgstr "Rust 生态系统"

#: src/chromium/adding-third-party-crates.md
msgid "Lots"
msgstr "很多"

#: src/chromium/adding-third-party-crates.md
msgid "Consistent: `Cargo.toml`"
msgstr "保持一致：`Cargo.toml`"

#: src/chromium/adding-third-party-crates.md
msgid "Typical library size"
msgstr "典型库的大小"

#: src/chromium/adding-third-party-crates.md
msgid "Large-ish"
msgstr "大"

#: src/chromium/adding-third-party-crates.md
msgid "Small"
msgstr "小"

#: src/chromium/adding-third-party-crates.md
msgid "Transitive dependencies"
msgstr "传递依赖项"

#: src/chromium/adding-third-party-crates.md
msgid "Few"
msgstr "很少"

#: src/chromium/adding-third-party-crates.md
msgid "For a Chromium engineer, this has pros and cons:"
msgstr "对于 Chromium 工程师来说，这种依赖关系具有以下利弊："

#: src/chromium/adding-third-party-crates.md
msgid ""
"All crates use a common build system so we can automate their inclusion into "
"Chromium..."
msgstr ""
"所有 crate 都使用共同的构建系统，这样我们就可以自动将其收录到 Chromium 中..."

#: src/chromium/adding-third-party-crates.md
msgid ""
"... but, crates typically have transitive dependencies, so you will likely "
"have to bring in multiple libraries."
msgstr "...但是，crate 通常具有传递依赖项，因此可能需要引入多个库。"

#: src/chromium/adding-third-party-crates.md
msgid "We'll discuss:"
msgstr "我们将讨论以下内容："

#: src/chromium/adding-third-party-crates.md
msgid "How to put a crate in the Chromium source code tree"
msgstr "如何将 crate 添加到 Chromium 源代码树中"

#: src/chromium/adding-third-party-crates.md
msgid "How to make `gn` build rules for it"
msgstr "如何为其制定 `gn` 构建规则"

#: src/chromium/adding-third-party-crates.md
msgid "How to audit its source code for sufficient safety."
msgstr "如何审核其源代码以确保足够的安全性。"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid "Configuring the `Cargo.toml` file to add crates"
msgstr "配置 `Cargo.tom` 文件以添加 crate"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"Chromium has a single set of centrally-managed direct crate dependencies. "
"These are managed through a single [`Cargo.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo."
"toml):"
msgstr ""
"Chromium 具有一组集中管理的直接 crate 依赖项。这些依赖项通过单独的 [`Cargo."
"toml`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/"
"rust/chromium_crates_io/Cargo.toml) 文件进行管理："

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1\"\n"
"cfg-if = \"1\"\n"
"cxx = \"1\"\n"
"# lots more...\n"
"```"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"As with any other `Cargo.toml`, you can specify [more details about the "
"dependencies](https://doc.rust-lang.org/cargo/reference/specifying-"
"dependencies.html) --- most commonly, you'll want to specify the `features` "
"that you wish to enable in the crate."
msgstr ""
"与任何其他 `Cargo.toml` 一样，您可以指定 [有关依赖项的更多详细信息](https://"
"doc.rust-lang.org/cargo/reference/specifying-dependencies.html)。最常见的是，"
"您需要指定要在 crate 中启用的 `features`。"

#: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
msgid ""
"When adding a crate to Chromium, you'll often need to provide some extra "
"information in an additional file, `gnrt_config.toml`, which we'll meet next."
msgstr ""
"向 Chromium 中添加 crate 时，通常需要在附加文件 `gnrt_config.toml` 中提供一些"
"额外的信息，我们将在下文中加以介绍。"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Alongside `Cargo.toml` is [`gnrt_config.toml`](https://source.chromium.org/"
"chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config."
"toml). This contains Chromium-specific extensions to crate handling."
msgstr ""
"与 `Cargo.toml` 一起使用的是 [`gnrt_config.toml`](https://source.chromium."
"org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/"
"gnrt_config.toml)。此文件包含 Chromium 专用扩展程序，可用于处理 crate。"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"If you add a new crate, you should specify at least the `group`. This is one "
"of:"
msgstr "如果添加新的 crate，至少要明确指定 `group`。可以为以下选项之一："

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid "For instance,"
msgstr "例如："

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Depending on the crate source code layout, you may also need to use this "
"file to specify where its `LICENSE` file(s) can be found."
msgstr ""
"根据 crate 源代码布局，您可能还需要使用此文件指定其 `LICENSE` 文件的所在位"
"置。"

#: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
msgid ""
"Later, we'll see some other things you will need to configure in this file "
"to resolve problems."
msgstr "稍后，我们将介绍需要在此文件中配置的其他内容，以便能够解决问题。"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"A tool called `gnrt` knows how to download crates and how to generate `BUILD."
"gn` rules."
msgstr ""
"有一款名为 `gnrt` 的工具，具有下载 crate 以及生成 `BUILD.gn` 规则的功能。"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "To start, download the crate you want like this:"
msgstr "首先，按如下所示下载所需的 crate："

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"Although the `gnrt` tool is part of the Chromium source code, by running "
"this command you will be downloading and running its dependencies from "
"`crates.io`. See [the earlier section](../cargo.md) discussing this security "
"decision."
msgstr ""
"虽然 `gnrt` 工具是 Chromium 源代码的一部分，但通过运行此命令，您可以从 "
"`crates.io` 下载并运行其依赖项。有关该安全决策的讨论，请参阅 [前面的部分](../"
"cargo.md)。"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "This `vendor` command may download:"
msgstr "运行此 `vendor` 命令可能会下载以下内容："

#: src/chromium/adding-third-party-crates/downloading-crates.md
#, fuzzy
msgid "Your crate"
msgstr "实用 crate"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid "Direct and transitive dependencies"
msgstr "直接依赖项和传递依赖项"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"New versions of other crates, as required by `cargo` to resolve the complete "
"set of crates required by Chromium."
msgstr ""
"`cargo` 要求的其他 crate 的新版本，用于解析 Chromium 所需的全部 crate。"

#: src/chromium/adding-third-party-crates/downloading-crates.md
msgid ""
"Chromium maintains patches for some crates, kept in `//third_party/rust/"
"chromium_crates_io/patches`. These will be reapplied automatically, but if "
"patching fails you may need to take manual action."
msgstr ""
"Chromium 会修复一些 crate 的补丁，并将其保存在 `//third_party/rust/"
"chromium_crates_io/patches` 中。系统会自动重新应用这些补丁，但如果补丁应用失"
"败，您可能需要进行手动操作。"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Once you've downloaded the crate, generate the `BUILD.gn` files like this:"
msgstr "下载 crate 后，按如下方式生成 `BUILD.gn` 文件："

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "Now run `git status`. You should find:"
msgstr "现在，运行 `git status`。您应该会看到："

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"At least one new crate source code in `third_party/rust/chromium_crates_io/"
"vendor`"
msgstr ""
"`third_party/rust/chromium_crates_io/vendor` 中至少包含一个新的 crate 源代码"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"At least one new `BUILD.gn` in `third_party/rust/<crate name>/v<major semver "
"version>`"
msgstr ""
"`third_party/rust/<crate name>/v<major semver version>` 中至少包含一个新的 "
"`BUILD.gn`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid "An appropriate `README.chromium`"
msgstr "相应的 `README.chromium`"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
#, fuzzy
msgid ""
"The \"major semver version\" is a [Rust \"semver\" version number](https://"
"doc.rust-lang.org/cargo/reference/semver.html)."
msgstr ""
"请参阅 [Rust 引用](https://doc.rust-lang.org/reference/type-layout.html)。"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Take a close look, especially at the things generated in `third_party/rust`."
msgstr "请仔细观察，尤其是 `third_party/rust` 中生成的内容。"

#: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
msgid ""
"Talk a little about semver --- and specifically the way that in Chromium "
"it's to allow multiple incompatible versions of a crate, which is "
"discouraged but sometimes necessary in the Cargo ecosystem."
msgstr ""
"浅谈下 semver，特别是在 Chromium 中，它支持使用多个不兼容的 crate 版本。虽然"
"在 Cargo 生态系统中不鼓励这种方式，但在某些情况下却是必要的。"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"If your build fails, it may be because of a `build.rs`: programs which do "
"arbitrary things at build time. This is fundamentally at odds with the "
"design of `gn` and `ninja` which aim for static, deterministic, build rules "
"to maximize parallelism and repeatability of builds."
msgstr ""
"如果构建失败，可能是 `build.rs` 文件所致：这些程序在构建过程中执行了任意操"
"作。这与 `gn` 和 `ninja` 的设计完全不相符，它们旨在实现静态、确定性的构建规"
"则，以最大限度地提高构建的并行性和可重复性。"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"Some `build.rs` actions are automatically supported; others require action:"
msgstr "系统支持自动进行某些 `build.rs` 操作；而有些需要进行额外的处理："

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "build script effect"
msgstr "构建脚本效果"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Supported by our gn templates"
msgstr "我们的 gn 模板均支持"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Work required by you"
msgstr "您需要完成的工作"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Checking rustc version to configure features on and off"
msgstr "检查 rustc 版本以配置启用和停用功能"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "None"
msgstr "无"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Checking platform or CPU to configure features on and off"
msgstr "检查平台或 CPU 以配置启用和停用功能"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Generating code"
msgstr "生成 代码"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Yes - specify in `gnrt_config.toml`"
msgstr "是的，在 `gnrt_config.toml` 中指定"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Building C/C++"
msgstr "构建 C/C++"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid "Patch around it"
msgstr "进行补丁修复"

#: src/chromium/adding-third-party-crates/resolving-problems.md
#, fuzzy
msgid "Arbitrary other actions"
msgstr "任意其他操作"

#: src/chromium/adding-third-party-crates/resolving-problems.md
msgid ""
"Fortunately, most crates don't contain a build script, and fortunately, most "
"build scripts only do the top two actions."
msgstr ""
"幸运的是，大多数 crate 不包含构建脚本，而且大多数的构建脚本只执行前两项操作。"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"If `ninja` complains about missing files, check the `build.rs` to see if it "
"writes source code files."
msgstr ""
"如果 `ninja` 提示有文件缺失，请检查 `build.rs`，确认其是否写入了源代码文件。"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"If so, modify [`gnrt_config.toml`](../configuring-gnrt-config-toml.md) to "
"add `build-script-outputs` to the crate. If this is a transitive dependency, "
"that is, one on which Chromium code should not directly depend, also add "
"`allow-first-party-usage=false`. There are several examples already in that "
"file:"
msgstr ""
"如果是，请修改 [`gnrt_config.toml`](../configuration-gnrt-config-toml.md)，"
"将 `build-script-outputs` 添加到 crate。如果这是一个传递依赖项（即 Chromium "
"代码不应直接依赖的依赖项），还要添加 `allow-first-party-usage=false`。该文件"
"中已经提供了若干示例："

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
#, fuzzy
msgid ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [\"tables.rs\"]\n"
"```"
msgstr ""
"```toml\n"
"[crate.unicode-linebreak]\n"
"allow-first-party-usage = false\n"
"build-script-outputs = [ \"tables.rs\" ]\n"
"```"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
msgid ""
"Now rerun [`gnrt.py -- gen`](../generating-gn-build-rules.md) to regenerate "
"`BUILD.gn` files to inform ninja that this particular output file is input "
"to subsequent build steps."
msgstr ""
"现在，请重新运行 [`gnrt.py -- gen`](../generating-gn-build-rules.md)，重新生"
"成 `BUILD.gn` 文件，以通知 ninja 此特定输出文件将被用作后续构建步骤的输入。"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid ""
"Some crates use the [`cc`](https://crates.io/crates/cc) crate to build and "
"link C/C++ libraries. Other crates parse C/C++ using [`bindgen`](https://"
"crates.io/crates/bindgen) within their build scripts. These actions can't be "
"supported in a Chromium context --- our gn, ninja and LLVM build system is "
"very specific in expressing relationships between build actions."
msgstr ""
"有些 crate 使用 [`cc`](https://crates.io/crates/cc) crate 来构建和关联 C/C++ "
"库。其他 crate 会在其构建脚本中使用 [`bindgen`](https://crates.io/crates/"
"bindgen) 解析 C/C++。Chromium 环境中不支持进行这些操作，因为我们的 gn、ninja "
"和 LLVM 构建系统在表达构建操作之间的关系方面具有非常严格具体的要求。"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "So, your options are:"
msgstr "因此，您可以选择："

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Avoid these crates"
msgstr "避开这些 crate"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid "Apply a patch to the crate."
msgstr "对 crate 应用补丁。"

#: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
msgid ""
"Patches should be kept in `third_party/rust/chromium_crates_io/patches/"
"<crate>` - see for example the [patches against the `cxx` crate](https://"
"source.chromium.org/chromium/chromium/src/+/main:third_party/rust/"
"chromium_crates_io/patches/cxx/) - and will be applied automatically by "
"`gnrt` each time it upgrades the crate."
msgstr ""
"补丁应保存在 `third_party/rust/chromium_crates_io/patches/<crate>` 中，请参"
"阅 [面向 `cxx` crate 的补丁](https://source.chromium.org/chromium/chromium/"
"src/+/main:third_party/rust/chromium_crates_io/patches/cxx/) 中的示例。每当 "
"`gnrt` 升级该 crate 时，将会自动应用补丁文件。"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"Once you've added a third-party crate and generated build rules, depending "
"on a crate is simple. Find your `rust_static_library` target, and add a "
"`dep` on the `:lib` target within your crate."
msgstr ""
"添加第三方 crate 并生成构建规则后，就可轻松使用该 crate。请找到 "
"`rust_static_library` 目标，并在 crate 中的 `:lib` 目标上添加 `dep`。"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid "Specifically,"
msgstr "特定于操作系统"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
#, fuzzy
msgid ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \":"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"
msgstr ""
"```bob\n"
"                     +------------+      +----------------------+\n"
"\"//third_party/rust\" | crate name | \"/v\" | major semver version | \"/:"
"lib\"\n"
"                     +------------+      +----------------------+\n"
"```"

#: src/chromium/adding-third-party-crates/depending-on-a-crate.md
msgid ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"
msgstr ""
"```gn\n"
"rust_static_library(\"my_rust_lib\") {\n"
"  crate_root = \"lib.rs\"\n"
"  sources = [ \"lib.rs\" ]\n"
"  deps = [ \"//third_party/rust/example_rust_crate/v1:lib\" ]\n"
"}\n"
"```"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
#, fuzzy
msgid "Auditing Third Party Crates"
msgstr "审核第三方 crate"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Adding new libraries is subject to Chromium's standard [policies](https://"
"chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust."
"md#Third_party-review), but of course also subject to security review. As "
"you may be bringing in not just a single crate but also transitive "
"dependencies, there may be a lot of code to review. On the other hand, safe "
"Rust code can have limited negative side effects. How should you review it?"
msgstr ""
"添加新库须遵守 Chromium 的标准 [政策](https://chromium.googlesource.com/"
"chromium/src/+/refs/heads/main/docs/rust.md#Third_party-review)，当然也要遵守"
"安全审核标准。您可能不仅要引入单个 crate，而且还要引入传递依赖项，因此可能需"
"要审核大量代码。另一方面，安全的 Rust 代码可能产生的副作用有限。应如何对其进"
"行审核？"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Over time Chromium aims to move to a process based around [cargo vet]"
"(https://mozilla.github.io/cargo-vet/)."
msgstr ""
"随着时间的推移，Chromium 计划逐步采用以 [cargo vet](https://mozilla.github."
"io/cargo-vet/) 为核心的处理流程。"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Meanwhile, for each new crate addition, we are checking for the following:"
msgstr "与此同时，每当添加新的 crate 时，我们都会检查以下内容："

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Understand why each crate is used. What's the relationship between crates? "
"If the build system for each crate contains a `build.rs` or procedural "
"macros, work out what they're for. Are they compatible with the way Chromium "
"is normally built?"
msgstr ""
"了解每个 crate 的用途。crate 之间存在什么关系？如果每个 crate 的构建系统都包"
"含 `build.rs` 或过程宏，请确定它们的用途。它们能否与 Chromium 的正常构建方式"
"相兼容。"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Check each crate seems to be reasonably well maintained"
msgstr "检查每个 crate 是否得到合理维护。"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known "
"vulnerabilities (first you'll need to `cargo install cargo-audit`, which "
"ironically involves downloading lots of dependencies from the internet[2](../"
"cargo.md))"
msgstr ""
"使用 `cd third-party/rust/chromium_crates_io; cargo review` 检查已知漏洞（首"
"先需要运行 `cargo install cargo-audit`，令人意外的是，这个过程中需要从互联网"
"下载大量的依赖项 [2](../cargo.md)）"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Ensure any `unsafe` code is good enough for the [Rule of Two](https://"
"chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2."
"md#unsafe-code-in-safe-languages)"
msgstr ""
"确保所有 `unsafe` 代码都符合 [两大规则](https://chromium.googlesource.com/"
"chromium/src/+/main/docs/security/rule-of-2.md#unsafe-code-in-safe-"
"languages) 的要求"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid "Check for any use of `fs` or `net` APIs"
msgstr "检查是否使用了 `fs` 或 `net` API"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"Read all the code at a sufficient level to look for anything out of place "
"that might have been maliciously inserted. (You can't realistically aim for "
"100% perfection here: there's often just too much code.)"
msgstr ""
"尽可能地仔细阅读所有代码，查找任何可能属于恶意插入，稍显异常的地方。（但现实"
"中，您不可能做到百无遗漏，因为代码量通常太庞大了。）"

#: src/chromium/adding-third-party-crates/reviews-and-audits.md
msgid ""
"These are just guidelines --- work with reviewers from `security@chromium."
"org` to work out the right way to become confident of the crate."
msgstr ""
"以下只是一些指导建议，请与 `security@chromium.org` 的审核者合租，共同找出能够"
"确保 crate 安全的正确方法。"

#: src/chromium/adding-third-party-crates/checking-in.md
#, fuzzy
msgid "Checking Crates into Chromium Source Code"
msgstr "将 crate 签入 Chromium 源代码"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "`git status` should reveal:"
msgstr "`git status` 应显示以下内容："

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Crate code in `//third_party/rust/chromium_crates_io`"
msgstr "`//third_party/rust/chromium_crates_io` 中的 crate 代码"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"Metadata (`BUILD.gn` and `README.chromium`) in `//third_party/rust/<crate>/"
"<version>`"
msgstr ""
"`//third_party/rust/<crate>/<version>` 中的元数据（`BUILD.gn` 和 `README."
"chromium`）"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid "Please also add an `OWNERS` file in the latter location."
msgstr "此外，请在后面的位置添加 `OWNERS` 文件。"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"You should land all this, along with your `Cargo.toml` and `gnrt_config."
"toml` changes, into the Chromium repo."
msgstr ""
"您应将所有这些内容，以及对 `Cargo.toml` 和 `gnrt_config.toml` 的更改一起提交"
"到 Chromium 仓库中。"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"**Important**: you need to use `git add -f` because otherwise `.gitignore` "
"files may result in some files being skipped."
msgstr ""
"**重要提示**：您需要使用 `git add -f` 命令，否则 `.gitignore` 文件可能会导致"
"某些文件被跳过。"

#: src/chromium/adding-third-party-crates/checking-in.md
msgid ""
"As you do so, you might find presubmit checks fail because of non-inclusive "
"language. This is because Rust crate data tends to include names of git "
"branches, and many projects still use non-inclusive terminology there. So "
"you may need to run:"
msgstr ""
"在此过程中，您可能会发现由于使用了非包容性语言，导致提交前检查失败。这是因为 "
"Rust crate 数据往往包含 git 分支的名称，而许多项目仍然在使用非包容性术语。因"
"此，您需要运行以下命令："

#: src/chromium/adding-third-party-crates/keeping-up-to-date.md
msgid ""
"As the OWNER of any third party Chromium dependency, you are [expected to "
"keep it up to date with any security fixes](https://chromium.googlesource."
"com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners). It is "
"hoped that we will soon automate this for Rust crates, but for now, it's "
"still your responsibility just as it is for any other third party dependency."
msgstr ""
"作为任何第三方 Chromium 依赖项的所有者，您 [应使用任何安全修复程序，确保该依"
"赖项处于最新状态](https://chromium.googlesource.com/chromium/src/+/main/docs/"
"adding_to_third_party.md#add-owners)。我们希望能够尽快实现对 Rust crate 自动"
"执行此操作，但目前仍由您负责执行，就像对待任何其他第三方依赖项一样。"

#: src/exercises/chromium/third-party.md
msgid ""
"Add [uwuify](https://crates.io/crates/uwuify) to Chromium, turning off the "
"crate's [default features](https://doc.rust-lang.org/cargo/reference/"
"features.html#the-default-feature). Assume that the crate will be used in "
"shipping Chromium, but won't be used to handle untrustworthy input."
msgstr ""
"将 [uwuify](https://crates.io/crates/uwuify) 添加到 Chromium，以停用 crate "
"的 [默认功能](https://doc.rust-lang.org/cargo/reference/features.html#the-"
"default-feature)。假设该 crate 会交付 Chromium 时被使用，但不会用于处理不可信"
"的输入内容。"

#: src/exercises/chromium/third-party.md
msgid ""
"(In the next exercise we'll use uwuify from Chromium, but feel free to skip "
"ahead and do that now if you like. Or, you could create a new "
"[`rust_executable` target](https://source.chromium.org/chromium/chromium/src/"
"+/main:build/rust/rust_executable.gni) which uses `uwuify`)."
msgstr ""
"（在下一个练习中，我们将使用 Chromium 中的 uwuify；但您也可以跳过这一步，现在"
"就开始此操作。或者，您可以创建一个使用 `uwuify` 的新 [`rust_executable` 目标]"
"(https://source.chromium.org/chromium/chromium/src/+/main:build/rust/"
"rust_executable.gni)。"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "Students will need to download lots of transitive dependencies."
msgstr "学生们需要下载很多传递依赖项"

#: src/exercises/chromium/third-party.md
msgid "The total crates needed are:"
msgstr ""

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid "`instant`,"
msgstr "例如："

#: src/exercises/chromium/third-party.md
msgid "`lock_api`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`parking_lot`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`parking_lot_core`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`redox_syscall`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`scopeguard`,"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`smallvec`, and"
msgstr ""

#: src/exercises/chromium/third-party.md
msgid "`uwuify`."
msgstr ""

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"If students are downloading even more than that, they probably forgot to "
"turn off the default features."
msgstr ""
"所需的全部 crate 包括：uwuify、smallvec、scopeguard、parking_lot、"
"park_lot_core、lock_api 和 Instant。如果学生下载的 crate 数目比这还多，则他们"
"可能忘了停用默认功能。"

#: src/exercises/chromium/third-party.md
#, fuzzy
msgid ""
"Thanks to [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) for this crate!"
msgstr ""
"感谢 [Daniel Liu](https://github.com/Daniel-Liu-c0deb0t) 提供此 crate！"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid "Bringing It Together --- Exercise"
msgstr "综合应用练习"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"In this exercise, you're going to add a whole new Chromium feature, bringing "
"together everything you already learned."
msgstr "在本练习中，您将运用之前所学的全部知识，添加一项全新的 Chromium 功能。"

#: src/exercises/chromium/bringing-it-together.md
#, fuzzy
msgid "The Brief from Product Management"
msgstr "“产品管理”简介"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"A community of pixies has been discovered living in a remote rainforest. "
"It's important that we get Chromium for Pixies delivered to them as soon as "
"possible."
msgstr ""
"在偏僻的热带雨林中，发现住着一群小精灵。我们务必尽快创建一款精灵版 Chromium，"
"交付给他们。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The requirement is to translate all Chromium's UI strings into Pixie "
"language."
msgstr "要求是将 Chromium 的所有界面字符串翻译为精灵语。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"There's not time to wait for proper translations, but fortunately pixie "
"language is very close to English, and it turns out there's a Rust crate "
"which does the translation."
msgstr ""
"由于时间紧迫，无法等待准确的翻译。但幸运的是，精灵语与英语非常接近，然后我们"
"发现有一个 Rust crate 可以执行此翻译任务。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"In fact, you already [imported that crate in the previous exercise](https://"
"crates.io/crates/uwuify)."
msgstr ""
"事实上，您已经 [在上一个练习中导入了该 crate](https://crates.io/crates/"
"uwuify)。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"(Obviously, real translations of Chrome require incredible care and "
"diligence. Don't ship this!)"
msgstr ""
"（显然，对 Chrome 进行准确恰当的翻译，需要做到极度细致和全力以赴。请勿交付此"
"产品！）"

#: src/exercises/chromium/bringing-it-together.md
msgid "Steps"
msgstr "步骤"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all "
"strings before display. In this special build of Chromium, it should always "
"do this irrespective of the setting of `mangle_localized_strings_`."
msgstr ""
"修改 `ResourceBundle::MaybeMangleLocalizedString`，在显示之前对所有字符串进"
"行 uwu 处理。在这个特殊的 Chromium 版本中，无论 `mangle_localized_strings_` "
"的设置如何，都应该始终执行此操作。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"If you've done everything right across all these exercises, congratulations, "
"you should have created Chrome for pixies!"
msgstr ""
"如果您正确完成了这些练习中的所有操作，那么恭喜您已经成功创建了一款精灵版 "
"Chrome！"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, "
"and will probably decide that it's better to do the conversion on the C++ "
"side using `base::UTF16ToUTF8` and back again."
msgstr ""
"UTF16 与 UTF8。学生应注意，Rust 字符串始终采用 UTF8 编码，它们可能会决定在 C+"
"+ 端使用 `base::UTF16ToUTF8` 进行转换，然后再进行反向转换。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"If students decide to do the conversion on the Rust side, they'll need to "
"consider [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct."
"String.html#method.from_utf16), consider error handling, and consider which "
"[CXX supported types can transfer a lot of u16s](https://cxx.rs/binding/"
"slice.html)."
msgstr ""
"如果学生决定在 Rust 端进行转换，则需要考虑使用 [`String::from_utf16`]"
"(https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16) "
"方法，同时注意错误处理，并确定哪些 [CXX 支持的类型可以传输大量 u16s](https://"
"cxx.rs/binding/slice.html)。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"Students may design the C++/Rust boundary in several different ways, e.g. "
"taking and returning strings by value, or taking a mutable reference to a "
"string. If a mutable reference is used, CXX will likely tell the student "
"that they need to use [`Pin`](https://doc.rust-lang.org/std/pin/). You may "
"need to explain what `Pin` does, and then explain why CXX needs it for "
"mutable references to C++ data: the answer is that C++ data can't be moved "
"around like Rust data, because it may contain self-referential pointers."
msgstr ""
"学生可以通过多种方式设计 C++/Rust 边界，例如按值传递和返回字符串，或对字符串"
"采取可变引用。如果使用可变引用，CXX 可能会提示学生需要使用 [`Pin`](https://"
"doc.rust-lang.org/std/pin/) 方法。您可能需要解释“Pin”的用途，以及为何 CXX 需"
"要它来对 C++ 数据进行可变引用：原因是 C++ 数据无法像 Rust 数据那样自由移动，"
"它可能包含自引用指针。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will "
"need to depend on a `rust_static_library` target. The student probably "
"already did this."
msgstr ""
"对于包含 `ResourceBundle::MaybeMangleLocalizedString` 的 C++ 目标，需要依赖"
"于 `rust_static_library` 目标。学生可能已经执行了此操作。"

#: src/exercises/chromium/bringing-it-together.md
msgid ""
"The `rust_static_library` target will need to depend on `//third_party/rust/"
"uwuify/v0_2:lib`."
msgstr ""
"`rust_static_library` 目标需要依赖于 `//third_party/rust/uwuify/v0_2:lib`。"

#: src/exercises/chromium/solutions.md
msgid ""
"Solutions to the Chromium exercises can be found in [this series of CLs]"
"(https://chromium-review.googlesource.com/c/chromium/src/+/5096560)."
msgstr ""

#: src/bare-metal.md
#, fuzzy
msgid "Welcome to Bare Metal Rust"
msgstr "欢迎来学习裸机 Rust"

#: src/bare-metal.md
msgid ""
"This is a standalone one-day course about bare-metal Rust, aimed at people "
"who are familiar with the basics of Rust (perhaps from completing the "
"Comprehensive Rust course), and ideally also have some experience with bare-"
"metal programming in some other language such as C."
msgstr ""
"这是单独为裸机 Rust 开设的课程，为期一天，主要面向熟悉 Rust 基础知识的人员"
"（例如已学完 Comprehensive Rust），最好也有一些使用其他语言（例如 C）进行裸机"
"编程的经验。"

#: src/bare-metal.md
msgid ""
"Today we will talk about 'bare-metal' Rust: running Rust code without an OS "
"underneath us. This will be divided into several parts:"
msgstr ""
"今天，我们将探讨 `bare-metal` Rust：即在没有操作系统支持的情况下运行 Rust 代"
"码。该部分主要分为以下内容："

#: src/bare-metal.md
msgid "What is `no_std` Rust?"
msgstr "什么是 `no_std` Rust？"

#: src/bare-metal.md
msgid "Writing firmware for microcontrollers."
msgstr "编写微控制器固件。"

#: src/bare-metal.md
msgid "Writing bootloader / kernel code for application processors."
msgstr "为应用处理器编写引导加载程序 / 内核代码。"

#: src/bare-metal.md
msgid "Some useful crates for bare-metal Rust development."
msgstr "有助于裸机 Rust 开发的一些实用 crate。"

#: src/bare-metal.md
msgid ""
"For the microcontroller part of the course we will use the [BBC micro:bit]"
"(https://microbit.org/) v2 as an example. It's a [development board](https://"
"tech.microbit.org/hardware/) based on the Nordic nRF51822 microcontroller "
"with some LEDs and buttons, an I2C-connected accelerometer and compass, and "
"an on-board SWD debugger."
msgstr ""
"在本课程的微控制器部分，我们将使用 [BBC micro:bit](https://microbit.org/) v2 "
"作为示例。这是一款基于 Nordic nRF51822 微控制器的 [开发板](https://tech."
"microbit.org/hardware/)，配有一些 LED 和按钮、连接 I2C 的加速度计和罗盘，以及"
"板载 SWD 调试程序。"

#: src/bare-metal.md
msgid ""
"To get started, install some tools we'll need later. On gLinux or Debian:"
msgstr "首先，请安装我们稍后需要用到的一些工具。在 gLinux 或 Debian 上："

#: src/bare-metal.md
msgid ""
"And give users in the `plugdev` group access to the micro:bit programmer:"
msgstr "然后，向 `plugdev` 组中的用户授予 micro:bit 编程器的访问权限："

#: src/bare-metal.md src/bare-metal/microcontrollers/debugging.md
msgid "On MacOS:"
msgstr "在 MacOS 上："

#: src/bare-metal/no_std.md
msgid "`core`"
msgstr "`core`"

#: src/bare-metal/no_std.md
msgid "`std`"
msgstr "`std`"

#: src/bare-metal/no_std.md
msgid "Slices, `&str`, `CStr`"
msgstr "Slice、`&str`、`CStr`"

#: src/bare-metal/no_std.md
msgid "`NonZeroU8`..."
msgstr "`NonZeroU8`..."

#: src/bare-metal/no_std.md
msgid "`Option`, `Result`"
msgstr "`Option`、`Result`"

#: src/bare-metal/no_std.md
msgid "`Display`, `Debug`, `write!`..."
msgstr "`Display`、`Debug`、`write!`..."

#: src/bare-metal/no_std.md
msgid "`panic!`, `assert_eq!`..."
msgstr "`panic!`、`assert_eq!`..."

#: src/bare-metal/no_std.md
msgid "`NonNull` and all the usual pointer-related functions"
msgstr "`NonNull` 和所有常见的指针相关函数"

#: src/bare-metal/no_std.md
msgid "`Future` and `async`/`await`"
msgstr "`Future` 和 `async`/`await`"

#: src/bare-metal/no_std.md
msgid "`fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`..."
msgstr "`fence`、`AtomicBool`、`AtomicPtr`、`AtomicU32`..."

#: src/bare-metal/no_std.md
msgid "`Duration`"
msgstr "`Duration`"

#: src/bare-metal/no_std.md
msgid "`Box`, `Cow`, `Arc`, `Rc`"
msgstr "`Box`、`Cow`、`Arc`、`Rc`"

#: src/bare-metal/no_std.md
msgid "`Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`"
msgstr "`Vec`、`BinaryHeap`、`BtreeMap`、`LinkedList`、`VecDeque`"

#: src/bare-metal/no_std.md
msgid "`String`, `CString`, `format!`"
msgstr "`String`、`CString`、`format!`"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Error`"
msgstr "`Error`"

#: src/bare-metal/no_std.md
msgid "`Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`"
msgstr "`Mutex`、`Condvar`、`Barrier`、`Once`、`RwLock`、`mpsc`"

#: src/bare-metal/no_std.md
msgid "`File` and the rest of `fs`"
msgstr "`File` 和 `fs` 的其余部分"

#: src/bare-metal/no_std.md
msgid "`println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`"
msgstr "`println!`、`Read`、`Write`、`Stdin`、`Stdout` 以及 `io` 的其余部分"

#: src/bare-metal/no_std.md
#, fuzzy
msgid "`Path`, `OsString`"
msgstr "`Path`、`OsString`"

#: src/bare-metal/no_std.md
msgid "`net`"
msgstr "`net`"

#: src/bare-metal/no_std.md
msgid "`Command`, `Child`, `ExitCode`"
msgstr "`Command`、`Child`、`ExitCode`"

#: src/bare-metal/no_std.md
msgid "`spawn`, `sleep` and the rest of `thread`"
msgstr "`spawn`、`sleep` 和 `thread` 的其余部分"

#: src/bare-metal/no_std.md
msgid "`SystemTime`, `Instant`"
msgstr "`SystemTime`、`Instant`"

#: src/bare-metal/no_std.md
msgid "`HashMap` depends on RNG."
msgstr "`HashMap` 依赖于 RNG。"

#: src/bare-metal/no_std.md
msgid "`std` re-exports the contents of both `core` and `alloc`."
msgstr "`std` 会重新导出 `core` 和 `alloc` 的内容。"

#: src/bare-metal/minimal.md
msgid "A minimal `no_std` program"
msgstr "极小的 `no_std` 程序"

#: src/bare-metal/minimal.md
msgid "This will compile to an empty binary."
msgstr "这将编译为空二进制文件。"

#: src/bare-metal/minimal.md
msgid "`std` provides a panic handler; without it we must provide our own."
msgstr "`std` 提供了一个 panic 处理程序；如果没有它，我们就必须自行提供。"

#: src/bare-metal/minimal.md
msgid "It can also be provided by another crate, such as `panic-halt`."
msgstr "其他 crate（例如 `panic-halt`）也可以提供该处理程序。"

#: src/bare-metal/minimal.md
msgid ""
"Depending on the target, you may need to compile with `panic = \"abort\"` to "
"avoid an error about `eh_personality`."
msgstr ""
"根据目标不同，可能需要使用 `panic = \"abort\"` 进行编译，以避免出现与 "
"`eh_personality` 相关的错误。"

#: src/bare-metal/minimal.md
msgid ""
"Note that there is no `main` or any other entry point; it's up to you to "
"define your own entry point. This will typically involve a linker script and "
"some assembly code to set things up ready for Rust code to run."
msgstr ""
"请注意，未提供 `main` 函数或任何其他入口点；您可以自行定义入口点。通常需要使"
"用链接器脚本和一些汇编代码进行设置工作，以便 Rust 代码能够顺利运行。"

#: src/bare-metal/alloc.md
msgid ""
"To use `alloc` you must implement a [global (heap) allocator](https://doc."
"rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)."
msgstr ""
"如需使用 `alloc`，您必须实现 [全局（堆）分配器](https://doc.rust-lang.org/"
"stable/std/alloc/trait.GlobalAlloc.html)。"

#: src/bare-metal/alloc.md
msgid ""
"// Safe because `HEAP` is only used here and `entry` is only called once.\n"
msgstr ""
"// Safe because `HEAP` is only used here and `entry` is only called once.\n"

#: src/bare-metal/alloc.md
msgid "// Give the allocator some memory to allocate.\n"
msgstr "// Give the allocator some memory to allocate.\n"

#: src/bare-metal/alloc.md
msgid "// Now we can do things that require heap allocation.\n"
msgstr "// Now we can do things that require heap allocation.\n"

#: src/bare-metal/alloc.md
#, fuzzy
msgid "\"A string\""
msgstr "String"

#: src/bare-metal/alloc.md
msgid ""
"`buddy_system_allocator` is a third-party crate implementing a basic buddy "
"system allocator. Other crates are available, or you can write your own or "
"hook into your existing allocator."
msgstr ""
"`buddy_system_allocator` 是第三方 crate，用于实现基本伙伴系统分配器。还可以使"
"用其他 crate，或者自行编写 crate，或者接入现有分配器。"

#: src/bare-metal/alloc.md
msgid ""
"The const parameter of `LockedHeap` is the max order of the allocator; i.e. "
"in this case it can allocate regions of up to 2\\*\\*32 bytes."
msgstr ""
"`LockedHeap` 的常量参数是分配器的最大阶数；即在本例中，它可以最多分配 "
"2\\*\\*32 字节大小的区域。"

#: src/bare-metal/alloc.md
msgid ""
"If any crate in your dependency tree depends on `alloc` then you must have "
"exactly one global allocator defined in your binary. Usually this is done in "
"the top-level binary crate."
msgstr ""
"如果依赖项树中的所有 crate 都依赖于 `alloc`，则您必须在二进制文件中明确定义一"
"个全局分配器。通常，在顶级二进制 crate 中完成此操作。"

#: src/bare-metal/alloc.md
msgid ""
"`extern crate panic_halt as _` is necessary to ensure that the `panic_halt` "
"crate is linked in so we get its panic handler."
msgstr ""
"为了确保能够成功关联 `panic_halt` crate，以便我们获取其 panic 处理程序，必须"
"使用 `extern crate panic_halt as _` 方法。"

#: src/bare-metal/alloc.md
msgid "This example will build but not run, as it doesn't have an entry point."
msgstr "我们可以构建该示例，但由于没有入口点，无法运行。"

#: src/bare-metal/microcontrollers.md
msgid ""
"The `cortex_m_rt` crate provides (among other things) a reset handler for "
"Cortex M microcontrollers."
msgstr ""
"`cortex_m_rt` crate 提供针对 Cortex M 微控制器的重置处理程序（以及其他内"
"容）。"

#: src/bare-metal/microcontrollers.md
msgid ""
"Next we'll look at how to access peripherals, with increasing levels of "
"abstraction."
msgstr "接下来，我们看看随着抽象层级的不断提升，该如何访问外围设备。"

#: src/bare-metal/microcontrollers.md
msgid ""
"The `cortex_m_rt::entry` macro requires that the function have type `fn() -"
"> !`, because returning to the reset handler doesn't make sense."
msgstr ""
"`cortex_m_rt::entry` 宏要求函数的类型为 `fn() -> !`，因为返回重置处理程序会毫"
"无意义。"

#: src/bare-metal/microcontrollers.md
msgid "Run the example with `cargo embed --bin minimal`"
msgstr "使用 `cargo embed --bin minimum` 运行该示例"

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"Most microcontrollers access peripherals via memory-mapped IO. Let's try "
"turning on an LED on our micro:bit:"
msgstr ""
"大多数微控制器通过内存映射 IO 访问外围设备。现在试着开启 micro:bit 上的 LED "
"指示灯："

#: src/bare-metal/microcontrollers/mmio.md
msgid "/// GPIO port 0 peripheral address\n"
msgstr "/// GPIO port 0 peripheral address\n"

#: src/bare-metal/microcontrollers/mmio.md
msgid "// GPIO peripheral offsets\n"
msgstr "// GPIO peripheral offsets\n"

#: src/bare-metal/microcontrollers/mmio.md
msgid "// PIN_CNF fields\n"
msgstr "// PIN_CNF fields\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
msgid "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"
msgstr "// Configure GPIO 0 pins 21 and 28 as push-pull outputs.\n"

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"// Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"
msgstr ""
"// Safe because the pointers are to valid peripheral control registers, and\n"
"    // no aliases exist.\n"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
msgid "// Set pin 28 low and pin 21 high to turn the LED on.\n"
msgstr "// Set pin 28 low and pin 21 high to turn the LED on.\n"

#: src/bare-metal/microcontrollers/mmio.md
msgid ""
"GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 "
"to the first row."
msgstr "将 GPIO 0 的引脚 21 连接到 LED 矩阵的第一列，将引脚 28 连接到第一行。"

#: src/bare-metal/microcontrollers/mmio.md
#: src/bare-metal/microcontrollers/pacs.md
#: src/bare-metal/microcontrollers/hals.md
#: src/bare-metal/microcontrollers/board-support.md
msgid "Run the example with:"
msgstr "使用以下命令运行该示例："

#: src/bare-metal/microcontrollers/pacs.md
msgid "Peripheral Access Crates"
msgstr "外围设备访问 crate"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust "
"wrappers for memory-mapped peripherals from [CMSIS-SVD](https://www.keil.com/"
"pack/doc/CMSIS/SVD/html/index.html) files."
msgstr ""
"[`svd2rust`](https://crates.io/crates/svd2rust) 使用 [CMSIS-SVD](https://www."
"keil.com/pack/doc/CMSIS/SVD/html/index.html) 文件为内存映射外围设备生成了大部"
"分安全的 Rust 封装容器。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"SVD (System View Description) files are XML files typically provided by "
"silicon vendors which describe the memory map of the device."
msgstr ""
"SVD（系统视图描述）文件通常是由芯片供应商提供的 XML 文件，用于描述设备的内存"
"映射。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"They are organised by peripheral, register, field and value, with names, "
"descriptions, addresses and so on."
msgstr ""
"这些文件按照外围设备、寄存器、字段和值进行组织分类，其中包含名称、内容描述、"
"地址等信息。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"SVD files are often buggy and incomplete, so there are various projects "
"which patch the mistakes, add missing details, and publish the generated "
"crates."
msgstr ""
"由于 SVD 文件常常存在错误和不完整的情况，因此有许多项目会修复这些错误，补充缺"
"失的相关信息，并发布生成的 crate。"

#: src/bare-metal/microcontrollers/pacs.md
msgid "`cortex-m-rt` provides the vector table, among other things."
msgstr "`cortex-m-rt` 提供矢量表以及其他功能。"

#: src/bare-metal/microcontrollers/pacs.md
msgid ""
"If you `cargo install cargo-binutils` then you can run `cargo objdump --bin "
"pac -- -d --no-show-raw-insn` to see the resulting binary."
msgstr ""
"如果您使用 `cargo install cargo-binutils`，则可以运行 `cargo objdump --bin "
"pac -- -d --no-show-raw-insn`，查看生成的二进制文件。"

#: src/bare-metal/microcontrollers/hals.md
#, fuzzy
msgid "HAL crates"
msgstr "HAL crate"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-"
"implementation-crates) for many microcontrollers provide wrappers around "
"various peripherals. These generally implement traits from [`embedded-hal`]"
"(https://crates.io/crates/embedded-hal)."
msgstr ""
"许多微控制器的 [HAL crate](https://github.com/rust-embedded/awesome-embedded-"
"rust#hal-implementation-crates) 为各种外围设备提供了封装容器。通常，这些封装"
"容器可以实现 [`embedded-hal`](https://crates.io/crates/embedded-hal) 中的各"
"种 trait。"

#: src/bare-metal/microcontrollers/hals.md
msgid "// Create HAL wrapper for GPIO port 0.\n"
msgstr "// Create HAL wrapper for GPIO port 0.\n"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"`set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait."
msgstr "`set_low` 和 `set_high` 是 `embedded_hal` `OutputPin` trait 上的方法。"

#: src/bare-metal/microcontrollers/hals.md
msgid ""
"HAL crates exist for many Cortex-M and RISC-V devices, including various "
"STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers."
msgstr ""
"HAL crate 被广泛用于许多 Cortex-M 和 RISC-V 设备，包括各种 STM32、GD32、nRF、"
"NXP、MSP430、AVR 和 PIC 微控制器。"

#: src/bare-metal/microcontrollers/board-support.md
#, fuzzy
msgid "Board support crates"
msgstr "板级支持 crate"

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"Board support crates provide a further level of wrapping for a specific "
"board for convenience."
msgstr "为了方便使用，板级支持 crate 为特定开发板提供了更高级别的封装功能。"

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"In this case the board support crate is just providing more useful names, "
"and a bit of initialisation."
msgstr "在本例中，该板级支持 crate 仅提供了一些实用的名称和初始化功能。"

#: src/bare-metal/microcontrollers/board-support.md
msgid ""
"The crate may also include drivers for some on-board devices outside of the "
"microcontroller itself."
msgstr "除微控制器以外，该 crate 还包含一些可用于板载设备的驱动程序。"

#: src/bare-metal/microcontrollers/board-support.md
msgid "`microbit-v2` includes a simple driver for the LED matrix."
msgstr "`microbit-v2` 包含一个可用于 LED 矩阵的简单驱动程序。"

#: src/bare-metal/microcontrollers/type-state.md
msgid "The type state pattern"
msgstr "类型状态模式"

#: src/bare-metal/microcontrollers/type-state.md
msgid "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"
msgstr "// let gpio0_01_again = gpio0.p0_01; // Error, moved.\n"

#: src/bare-metal/microcontrollers/type-state.md
msgid "// pin_input.is_high(); // Error, moved.\n"
msgstr "// pin_input.is_high(); // Error, moved.\n"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"Pins don't implement `Copy` or `Clone`, so only one instance of each can "
"exist. Once a pin is moved out of the port struct nobody else can take it."
msgstr ""
"引脚无法实现 `Copy` 或 `Clone`，因此，每个引脚只能存在一个实例。一旦某个引脚"
"从端口结构体移出，任何人都无法再使用它。"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"Changing the configuration of a pin consumes the old pin instance, so you "
"can’t keep use the old instance afterwards."
msgstr "更改引脚的配置会使旧的引脚实例失效，因此您无法再继续使用旧实例。"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"The type of a value indicates the state that it is in: e.g. in this case, "
"the configuration state of a GPIO pin. This encodes the state machine into "
"the type system, and ensures that you don't try to use a pin in a certain "
"way without properly configuring it first. Illegal state transitions are "
"caught at compile time."
msgstr ""
"值的类型表示其所处状态：例如，在本例中，表示 GPIO 引脚的配置状态。通过这种方"
"式，可将状态机编码成类型系统，并确保在未正确完成引脚配置之前，不会尝试以某种"
"方式使用引脚。编译时捕获了非法状态转换。"

#: src/bare-metal/microcontrollers/type-state.md
msgid ""
"You can call `is_high` on an input pin and `set_high` on an output pin, but "
"not vice-versa."
msgstr ""
"您可以在输入引脚上调用 `is_high`，在输出引脚上调用 `set_high`，反之则不行。"

#: src/bare-metal/microcontrollers/type-state.md
msgid "Many HAL crates follow this pattern."
msgstr "许多 HAL crate 都遵循此模式。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"The [`embedded-hal`](https://crates.io/crates/embedded-hal) crate provides a "
"number of traits covering common microcontroller peripherals."
msgstr ""
"[`embedded-hal`](https://crates.io/crates/embedded-hal) crate 提供许多适用于"
"常见微控制器外围设备的 trait。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "GPIO"
msgstr "GPIO"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "ADC"
msgstr "ADC"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "I2C, SPI, UART, CAN"
msgstr "I2C、SPI、UART、CAN"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "RNG"
msgstr "RNG"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "Timers"
msgstr "定时器"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid "Watchdogs"
msgstr "监控定时器"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"Other crates then implement [drivers](https://github.com/rust-embedded/"
"awesome-embedded-rust#driver-crates) in terms of these traits, e.g. an "
"accelerometer driver might need an I2C or SPI bus implementation."
msgstr ""
"然后，其他 crate 可以根据这些 trait 实现 [驱动程序](https://github.com/rust-"
"embedded/awesome-embedded-rust#driver-crates)，例如加速度计驱动程序可能需要通"
"过 I2C 或 SPI 总线实现。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"There are implementations for many microcontrollers, as well as other "
"platforms such as Linux on Raspberry Pi."
msgstr ""
"还有适用于许多微控制器以及其他平台（例如 Raspberry Pi 上的 Linux）的实现。"

#: src/bare-metal/microcontrollers/embedded-hal.md
msgid ""
"There is work in progress on an `async` version of `embedded-hal`, but it "
"isn't stable yet."
msgstr "我们正在开发 `async` 版本的 `embedded-hal`，但目前还欠缺稳定性。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, "
"like OpenOCD but better integrated."
msgstr ""
"[probe-rs](https://probe.rs/) 是一个方便的嵌入式调试工具集，跟 OpenOCD 较为相"
"似，但集成度更高。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes"
msgstr "通过 CMSIS-DAP、ST-Link 和 J-Link 探针实现 SWD（串行调试）和 JTAG"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "GDB stub and Microsoft DAP (Debug Adapter Protocol) server"
msgstr "GDB 桩和 Microsoft DAP（调试适配器协议）服务器"

#: src/bare-metal/microcontrollers/probe-rs.md
#, fuzzy
msgid "Cargo integration"
msgstr "Cargo 集成"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT "
"(Real Time Transfers) output and connect GDB. It's configured by an `Embed."
"toml` file in your project directory."
msgstr ""
"`cargo-embed` 是一个 cargo 子命令，用于构建和刷写二进制文件、记录 RTT（实时传"
"输）输出以及连接 GDB。您可通过项目目录中的 `Embed.toml` 文件对其进行配置。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is "
"an Arm standard protocol over USB for an in-circuit debugger to access the "
"CoreSight Debug Access Port of various Arm Cortex processors. It's what the "
"on-board debugger on the BBC micro:bit uses."
msgstr ""
"[CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) 是一"
"项基于 USB 的 Arm 标准协议，使得电路内调试程序能够接入各种 Arm Cortex 处理器"
"的 CoreSight 调试访问端口。BBC micro:bit 的板载调试程序所使用的便是此协议。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link "
"is a range from SEGGER."
msgstr "ST-Link 属于 ST Microelectronics 产品系列，J-Link 是 SEGGER 系列。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin "
"Serial Wire Debug."
msgstr "调试访问端口通常为 5 针 JTAG 接口或 2 针串行线调试接口。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"probe-rs is a library which you can integrate into your own tools if you "
"want to."
msgstr "probe-rs 是一个库，如有需要，可以将其集成到您的工具中。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"The [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-"
"adapter-protocol/) lets VSCode and other IDEs debug code running on any "
"supported microcontroller."
msgstr ""
"借助 [Microsoft 调试适配器协议](https://microsoft.github.io/debug-adapter-"
"protocol/)，VSCode 和其他 IDE 可以调试任何受支持的微控制器上运行的代码。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid "cargo-embed is a binary built using the probe-rs library."
msgstr "cargo-embed 是使用 probe-rs 库构建的二进制文件。"

#: src/bare-metal/microcontrollers/probe-rs.md
msgid ""
"RTT (Real Time Transfers) is a mechanism to transfer data between the debug "
"host and the target through a number of ringbuffers."
msgstr ""
"RTT（实时传输）是一种通过多个环形缓冲区，在调试主机和目标之间进行数据传输的机"
"制。"

#: src/bare-metal/microcontrollers/debugging.md
#, fuzzy
msgid "_Embed.toml_:"
msgstr "_Embed.toml_:"

#: src/bare-metal/microcontrollers/debugging.md
msgid "In one terminal under `src/bare-metal/microcontrollers/examples/`:"
msgstr "在 `src/bare-metal/microcontrollers/examples/` 目录下某个终端中："

#: src/bare-metal/microcontrollers/debugging.md
msgid "In another terminal in the same directory:"
msgstr "在同一目录下的另一个终端中："

#: src/bare-metal/microcontrollers/debugging.md
msgid "On gLinux or Debian:"
msgstr "在 gLinux 或 Debian 上："

#: src/bare-metal/microcontrollers/debugging.md
msgid "In GDB, try running:"
msgstr "在 GDB 中，请尝试运行以下命令："

#: src/bare-metal/microcontrollers/other-projects.md
#: src/bare-metal/aps/other-projects.md
#, fuzzy
msgid "Other projects"
msgstr "其他项目"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[RTIC](https://rtic.rs/)"
msgstr "[RTIC](https://rtic.rs/)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "\"Real-Time Interrupt-driven Concurrency\""
msgstr "\"Real-Time Interrupt-driven Concurrency\""

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Shared resource management, message passing, task scheduling, timer queue"
msgstr "共享资源管理、消息传递、任务调度、定时器队列"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Embassy](https://embassy.dev/)"
msgstr "[Embassy](https://embassy.dev/)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "`async` executors with priorities, timers, networking, USB"
msgstr "具有优先级、计时器、网络和 USB 功能的 `async` 执行器"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[TockOS](https://www.tockos.org/documentation/getting-started)"
msgstr "[TockOS](https://www.tockos.org/documentation/getting-started)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Security-focused RTOS with preemptive scheduling and Memory Protection Unit "
"support"
msgstr "以安全为中心的 RTOS，具有抢占式调度功能和提供内存保护单元支持"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Hubris](https://hubris.oxide.computer/)"
msgstr "[Hubris](https://hubris.oxide.computer/)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Microkernel RTOS from Oxide Computer Company with memory protection, "
"unprivileged drivers, IPC"
msgstr ""
"Oxide Computer Company 开发的微内核 RTOS，提供内存保护、非特权驱动程序和 IPC "
"功能"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "[Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust)"
msgstr "[FreeRTOS 的绑定](https://github.com/lobaro/FreeRTOS-rust)"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Some platforms have `std` implementations, e.g. [esp-idf](https://esp-rs."
"github.io/book/overview/using-the-standard-library.html)."
msgstr ""
"有些平台可以实现 `std`，例如 [esp-idf](https://esp-rs.github.io/book/"
"overview/using-the-standard-library.html)。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "RTIC can be considered either an RTOS or a concurrency framework."
msgstr "RTIC 可被视为 RTOS 或并发框架，"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "It doesn't include any HALs."
msgstr "但不包含任何 HAL。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for "
"scheduling rather than a proper kernel."
msgstr ""
"它使用 Cortex-M NVIC（嵌套虚拟中断控制器）进行调度，而不是选用适合的内核。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid "Cortex-M only."
msgstr "仅限 Cortex-M。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"Google uses TockOS on the Haven microcontroller for Titan security keys."
msgstr "Google 在 Haven 微控制器上使用 TockOS 作为 Titan 安全密钥的操作系统。"

#: src/bare-metal/microcontrollers/other-projects.md
msgid ""
"FreeRTOS is mostly written in C, but there are Rust bindings for writing "
"applications."
msgstr "FreeRTOS 主要使用 C 语言编写，但也提供了专用于编写应用的 Rust 绑定。"

#: src/exercises/bare-metal/morning.md
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port."
msgstr "我们将从 I2C 罗盘读取方向，并将读数记录到串行端口。"

#: src/exercises/bare-metal/morning.md src/exercises/concurrency/morning.md
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"morning.md) provided."
msgstr "读完习题后，可以阅读本书提供的 \\[题解\\]。"

#: src/exercises/bare-metal/compass.md
msgid ""
"We will read the direction from an I2C compass, and log the readings to a "
"serial port. If you have time, try displaying it on the LEDs somehow too, or "
"use the buttons somehow."
msgstr ""
"我们将从 I2C 罗盘读取方向，并将读数记录到串行端口。如有时间，请尝试通过 LED "
"灯亮起的方式，或者使用按钮来显示方向。"

#: src/exercises/bare-metal/compass.md
msgid "Hints:"
msgstr "提示："

#: src/exercises/bare-metal/compass.md
msgid ""
"Check the documentation for the [`lsm303agr`](https://docs.rs/lsm303agr/"
"latest/lsm303agr/) and [`microbit-v2`](https://docs.rs/microbit-v2/latest/"
"microbit/) crates, as well as the [micro:bit hardware](https://tech.microbit."
"org/hardware/)."
msgstr ""
"请参阅 [`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) 和 "
"[`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) crate，以及 "
"[micro:bit 硬件](https://tech.microbit.org/hardware/) 相关文档。"

#: src/exercises/bare-metal/compass.md
msgid ""
"The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus."
msgstr "LSM303AGR 惯性测量装置与内部 I2C 总线相连接。"

#: src/exercises/bare-metal/compass.md
msgid ""
"TWI is another name for I2C, so the I2C master peripheral is called TWIM."
msgstr "TWI 是 I2C 的别称，因此 I2C 主外围设备称为 TWIM。"

#: src/exercises/bare-metal/compass.md
msgid ""
"The LSM303AGR driver needs something implementing the `embedded_hal::"
"blocking::i2c::WriteRead` trait. The [`microbit::hal::Twim`](https://docs.rs/"
"microbit-v2/latest/microbit/hal/struct.Twim.html) struct implements this."
msgstr ""
"LSM303AGR 驱动程序需要使用某种方法来实现 `embedded_hal::blocking::i2c::"
"WriteRead` trait。[`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/"
"microbit/hal/struct.Twim.html) 结构体便可以做到这一点。"

#: src/exercises/bare-metal/compass.md
msgid ""
"You have a [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) struct with fields for the various pins and peripherals."
msgstr ""
"您拥有一个 [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/"
"struct.Board.html) 结构体，其中包含各种引脚和外围设备的字段。"

#: src/exercises/bare-metal/compass.md
msgid ""
"You can also look at the [nRF52833 datasheet](https://infocenter.nordicsemi."
"com/pdf/nRF52833_PS_v1.5.pdf) if you want, but it shouldn't be necessary for "
"this exercise."
msgstr ""
"如有需要，您还可以查看 [nRF52833 数据表](https://infocenter.nordicsemi.com/"
"pdf/nRF52833_PS_v1.5.pdf)，但对本练习来说这不是必需的。"

#: src/exercises/bare-metal/compass.md
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `compass` directory for the following files."
msgstr ""
"下载 [练习模板](../../comprehensive-rust-exercises.zip) 并在 `compass` 目录中"
"查找以下文件。"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "_src/main.rs_:"
msgstr "_hello_rust/src/main.rs_:"

#: src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "// Configure serial port.\n"
msgstr "// Configure serial port.\n"

#: src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "// Use the system timer as a delay provider.\n"
msgstr ""

#: src/exercises/bare-metal/compass.md
msgid ""
"// Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"
msgstr ""
"// Set up the I2C controller and Inertial Measurement Unit.\n"
"    // TODO\n"

#: src/exercises/bare-metal/compass.md
#: src/exercises/bare-metal/solutions-morning.md
msgid "\"Ready.\""
msgstr "\"Ready.\""

#: src/exercises/bare-metal/compass.md
msgid ""
"// Read compass data and log it to the serial port.\n"
"        // TODO\n"
msgstr ""
"// Read compass data and log it to the serial port.\n"
"        // TODO\n"

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_Cargo.toml_ (you shouldn't need to change this):"
msgstr "_Cargo.toml_（无需对此进行更改）："

#: src/exercises/bare-metal/compass.md
msgid "_Embed.toml_ (you shouldn't need to change this):"
msgstr "_Embed.toml_（无需对此进行更改）："

#: src/exercises/bare-metal/compass.md src/exercises/bare-metal/rtc.md
msgid "_.cargo/config.toml_ (you shouldn't need to change this):"
msgstr "_.cargo/config.toml_（无需对此进行更改）："

#: src/exercises/bare-metal/compass.md
msgid "See the serial output on Linux with:"
msgstr "运行以下命令查看 Linux 上的串行输出："

#: src/exercises/bare-metal/compass.md
msgid ""
"Or on Mac OS something like (the device name may be slightly different):"
msgstr "或者在 Mac OS 上，如下所示（设备名称可能略有不同）："

#: src/exercises/bare-metal/compass.md
msgid "Use Ctrl+A Ctrl+Q to quit picocom."
msgstr "使用 Ctrl+A Ctrl+Q 退出 picocom。"

#: src/exercises/bare-metal/solutions-morning.md
msgid "Bare Metal Rust Morning Exercise"
msgstr "裸机 Rust 上午练习"

#: src/exercises/bare-metal/solutions-morning.md
msgid "([back to exercise](compass.md))"
msgstr "([返回练习](compass.md))"

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Set up the I2C controller and Inertial Measurement Unit.\n"
msgstr "// Set up the I2C controller and Inertial Measurement Unit.\n"

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"Setting up IMU...\""
msgstr "\"Setting up IMU...\""

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Set up display and timer.\n"
msgstr "// Set up display and timer.\n"

#: src/exercises/bare-metal/solutions-morning.md
msgid "// Read compass data and log it to the serial port.\n"
msgstr "// Read compass data and log it to the serial port.\n"

#: src/exercises/bare-metal/solutions-morning.md
msgid "\"{},{},{}\\t{},{},{}\""
msgstr "\"{},{},{}\\t{},{},{}\""

#: src/exercises/bare-metal/solutions-morning.md
#, fuzzy
msgid ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs\n"
"        // on.\n"
msgstr ""
"// If button A is pressed, switch to the next mode and briefly blink all "
"LEDs on.\n"

#: src/bare-metal/aps.md
msgid "Application processors"
msgstr "应用处理器"

#: src/bare-metal/aps.md
msgid ""
"So far we've talked about microcontrollers, such as the Arm Cortex-M series. "
"Now let's try writing something for Cortex-A. For simplicity we'll just work "
"with QEMU's aarch64 ['virt'](https://qemu-project.gitlab.io/qemu/system/arm/"
"virt.html) board."
msgstr ""
"到目前为止，我们已经讨论了微控制器，例如 Arm Cortex-M 系列。现在，尝试为 "
"Cortex-A 编写一些代码。为简单起见，我们只使用 QEMU 的 aarch64 [`virt`]"
"(https://qemu-project.gitlab.io/qemu/system/arm/virt.html) 开发板 进行编写。"

#: src/bare-metal/aps.md
msgid ""
"Broadly speaking, microcontrollers don't have an MMU or multiple levels of "
"privilege (exception levels on Arm CPUs, rings on x86), while application "
"processors do."
msgstr ""
"一般来说，微控制器不具备 MMU 或多级特权（例如，Arm CPU 中的异常级别，x86 中的"
"铃声级别）的功能，而应用处理器则具备这些功能。"

#: src/bare-metal/aps.md
msgid ""
"QEMU supports emulating various different machines or board models for each "
"architecture. The 'virt' board doesn't correspond to any particular real "
"hardware, but is designed purely for virtual machines."
msgstr ""
"QEMU 支持针对每种架构模拟不同的机器或板级模型。“虚拟”开发板并不适用于任何特定"
"的真实硬件，而是专为虚拟机设计的。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"Before we can start running Rust code, we need to do some initialisation."
msgstr "在开始运行 Rust 代码之前，我们需要进行一些初始化设置。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS. */\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1. */\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section. */\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack. */\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector. */\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code. */\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts. */\n"
"2:  wfi\n"
"    b 2b\n"
"```"
msgstr ""
"```armasm\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"    /*\n"
"     * Load and apply the memory management configuration, ready to enable "
"MMU and\n"
"     * caches.\n"
"     */\n"
"    adrp x30, idmap\n"
"    msr ttbr0_el1, x30\n"
"\n"
"    mov_i x30, .Lmairval\n"
"    msr mair_el1, x30\n"
"\n"
"    mov_i x30, .Ltcrval\n"
"    /* Copy the supported PA range into TCR_EL1.IPS.*/\n"
"    mrs x29, id_aa64mmfr0_el1\n"
"    bfi x30, x29, #32, #4\n"
"\n"
"    msr tcr_el1, x30\n"
"\n"
"    mov_i x30, .Lsctlrval\n"
"\n"
"    /*\n"
"     * Ensure everything before this point has completed, then invalidate "
"any\n"
"     * potentially stale local TLB entries before they start being used.\n"
"     */\n"
"    isb\n"
"    tlbi vmalle1\n"
"    ic iallu\n"
"    dsb nsh\n"
"    isb\n"
"\n"
"    /*\n"
"     * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this\n"
"     * has completed.\n"
"     */\n"
"    msr sctlr_el1, x30\n"
"    isb\n"
"\n"
"    /* Disable trapping floating point access in EL1.*/\n"
"    mrs x30, cpacr_el1\n"
"    orr x30, x30, #(0x3 << 20)\n"
"    msr cpacr_el1, x30\n"
"    isb\n"
"\n"
"    /* Zero out the bss section.*/\n"
"    adr_l x29, bss_begin\n"
"    adr_l x30, bss_end\n"
"0:  cmp x29, x30\n"
"    b.hs 1f\n"
"    stp xzr, xzr, [x29], #16\n"
"    b 0b\n"
"\n"
"1:  /* Prepare the stack.*/\n"
"    adr_l x30, boot_stack_end\n"
"    mov sp, x30\n"
"\n"
"    /* Set up exception vector.*/\n"
"    adr x30, vector_table_el1\n"
"    msr vbar_el1, x30\n"
"\n"
"    /* Call into Rust code.*/\n"
"    bl main\n"
"\n"
"    /* Loop forever waiting for interrupts.*/\n"
"2:  wfi\n"
"    b 2b\n"
"```"

#: src/bare-metal/aps/entry-point.md
msgid ""
"This is the same as it would be for C: initialising the processor state, "
"zeroing the BSS, and setting up the stack pointer."
msgstr ""
"这与 C 语言的情况相同：初始化处理器状态，将 BSS 清零，然后设置堆栈指针。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"The BSS (block starting symbol, for historical reasons) is the part of the "
"object file which containing statically allocated variables which are "
"initialised to zero. They are omitted from the image, to avoid wasting space "
"on zeroes. The compiler assumes that the loader will take care of zeroing "
"them."
msgstr ""
"BSS（由于历史原因，称为代码块起始符）属于对象文件的一部分，其中包含静态分配的"
"变量，这些变量被初始化为零。图像中省略了这些符号，以避免因存储零值而占用过多"
"空间。编译器假定加载器会负责将它们清零。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"The BSS may already be zeroed, depending on how memory is initialised and "
"the image is loaded, but we zero it to be sure."
msgstr ""
"BSS 可能已经被清零，具体取决于内存的初始化方式以及图像的加载方式，但为了确保"
"起见，我们会将其手动清零。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"We need to enable the MMU and cache before reading or writing any memory. If "
"we don't:"
msgstr "我们需要先启用 MMU 和缓存功能，然后才能读取或写入任何内存。否则："

#: src/bare-metal/aps/entry-point.md
msgid ""
"Unaligned accesses will fault. We build the Rust code for the `aarch64-"
"unknown-none` target which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses, so it should be fine in this case, but this "
"is not necessarily the case in general."
msgstr ""
"非对齐访问将会出错。我们为 `aarch64-unknown-none` 目标构建 Rust 代码，该目标"
"会设置 `+Strict-align` 以防止编译器生成非对齐访问，因此在本例中应该没有问题，"
"但一般情况下并不一定如此。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost when the cache "
"is cleaned or the VM enables the cache. (Cache is keyed by physical address, "
"not VA or IPA.)"
msgstr ""
"如果是在虚拟机中运行该命令，可能会导致缓存一致性问题。问题在于，虚拟机是在禁"
"用缓存的情况下直接访问内存，而主机具有同一内存的缓存别名。即使主机并没有明确"
"访问该内存，推测性访问仍然会导致缓存被填充，然后在清除缓存或虚拟机启用缓存"
"时，任何一方对于该内存进行的更改就会丢失。（使用物理地址来键控缓存，而 VA 或 "
"IPA。）"

#: src/bare-metal/aps/entry-point.md
msgid ""
"For simplicity, we just use a hardcoded pagetable (see `idmap.S`) which "
"identity maps the first 1 GiB of address space for devices, the next 1 GiB "
"for DRAM, and another 1 GiB higher up for more devices. This matches the "
"memory layout that QEMU uses."
msgstr ""
"为简单起见，我们只使用硬编码的分页表（请参阅 `dmap.S`），其通过身份映射将前一"
"个 1 GiB 的地址空间用于设备，紧接着的 1 GiB 用于 DRAM，然后在更高位置预留了 "
"1 GiB 给其他设备。这与 QEMU 使用的内存布局一致。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"We also set up the exception vector (`vbar_el1`), which we'll see more about "
"later."
msgstr "我们还设置了异常矢量 (`vbar_el1`)，稍后会对此进行详细介绍。"

#: src/bare-metal/aps/entry-point.md
msgid ""
"All examples this afternoon assume we will be running at exception level 1 "
"(EL1). If you need to run at a different exception level you'll need to "
"modify `entry.S` accordingly."
msgstr ""
"今天下午的所有示例都假定我们将在异常级别 1 (EL1) 下运行。如果您需要在其他异常"
"级别下运行，则需要修改相应的 `entry.S`。"

#: src/bare-metal/aps/inline-assembly.md
msgid "Inline assembly"
msgstr "内嵌汇编"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"Sometimes we need to use assembly to do things that aren't possible with "
"Rust code. For example, to make an HVC (hypervisor call) to tell the "
"firmware to power off the system:"
msgstr ""
"有时，如果无法通过 Rust 代码实现某些操作，我们就需要使用汇编来解决。例如，如"
"需发出 HVC（Hypervisor 调用）来指示固件关闭系统，请使用以下命令："

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"// Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"
msgstr ""
"// Safe because this only uses the declared registers and doesn't do\n"
"    // anything with memory.\n"

#: src/bare-metal/aps/inline-assembly.md
msgid "\"hvc #0\""
msgstr "\"hvc #0\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w0\""
msgstr "\"w0\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w1\""
msgstr "\"w1\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w2\""
msgstr "\"w2\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w3\""
msgstr "\"w3\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w4\""
msgstr "\"w4\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w5\""
msgstr "\"w5\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w6\""
msgstr "\"w6\""

#: src/bare-metal/aps/inline-assembly.md
msgid "\"w7\""
msgstr "\"w7\""

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"(If you actually want to do this, use the [`smccc`](https://crates.io/crates/"
"smccc) crate which has wrappers for all these functions.)"
msgstr ""
"（如果确实想要这样做，请使用 [`smccc`](https://crates.io/crates/smccc) "
"crate，其中包含适用于所有这些函数的封装容器。）"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"PSCI is the Arm Power State Coordination Interface, a standard set of "
"functions to manage system and CPU power states, among other things. It is "
"implemented by EL3 firmware and hypervisors on many systems."
msgstr ""
"PSCI 是 Arm 电源状态协调接口，为一组标准函数，用于管理系统和 CPU 电源状态等。"
"在许多系统中，通过 EL3 固件和 Hypervisor 来实现该函数。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"The `0 => _` syntax means initialise the register to 0 before running the "
"inline assembly code, and ignore its contents afterwards. We need to use "
"`inout` rather than `in` because the call could potentially clobber the "
"contents of the registers."
msgstr ""
"`0 => _` 语法表示在运行内嵌汇编代码之前将寄存器初始化为 0，并在之后忽略寄存器"
"中的内容。我们需要使用 `inout` 而非 `in`，因为该调用操作可能会破坏寄存器中的"
"内容。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"This `main` function needs to be `#[no_mangle]` and `extern \"C\"` because "
"it is called from our entry point in `entry.S`."
msgstr ""
"所用 `main` 函数必须是 `#[no_mangle]` 和 `extern \"C\"`，因为是从 `entry.S` "
"中的入口点调用该函数。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"`_x0`–`_x3` are the values of registers `x0`–`x3`, which are conventionally "
"used by the bootloader to pass things like a pointer to the device tree. "
"According to the standard aarch64 calling convention (which is what `extern "
"\"C\"` specifies to use), registers `x0`–`x7` are used for the first 8 "
"arguments passed to a function, so `entry.S` doesn't need to do anything "
"special except make sure it doesn't change these registers."
msgstr ""
"`_x0`–`_x3` 表示寄存器 `x0`-`x3` 的值，引导加载程序通常使用这些值来传递各种内"
"容（例如将指针传递到设备树）。根据标准的 aarch64 调用规范（`extern \"C\"`指定"
"使用此规范），需要使用寄存器 `x0`-`x7` 将前 8 个参数传递给函数，因此 `entry."
"S` 无需执行任何特殊操作，只要确保不会更改这些寄存器。"

#: src/bare-metal/aps/inline-assembly.md
msgid ""
"Run the example in QEMU with `make qemu_psci` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"在 QEMU 中，使用 `src/bare-metal/aps/examples` 目录下的 `make qemu_psci` 运行"
"该示例。"

#: src/bare-metal/aps/mmio.md
msgid "Volatile memory access for MMIO"
msgstr "MMIO 的易失性内存访问"

#: src/bare-metal/aps/mmio.md
msgid "Use `pointer::read_volatile` and `pointer::write_volatile`."
msgstr "使用 `pointer::read_volatile` 和 `pointer::write_volatile`。"

#: src/bare-metal/aps/mmio.md
msgid "Never hold a reference."
msgstr "切勿提及引用。"

#: src/bare-metal/aps/mmio.md
msgid ""
"`addr_of!` lets you get fields of structs without creating an intermediate "
"reference."
msgstr "借助 `addr_of!`，您无需创建中间引用即可获取结构体字段。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Volatile access: read or write operations may have side-effects, so prevent "
"the compiler or hardware from reordering, duplicating or eliding them."
msgstr ""
"易失性访问：执行读取或写入操作可能会产生副作用，因此应阻止编译器或硬件对这些"
"操作进行重新排序、复制或省略。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Usually if you write and then read, e.g. via a mutable reference, the "
"compiler may assume that the value read is the same as the value just "
"written, and not bother actually reading memory."
msgstr ""
"通常情况下，如果您先写入操作，紧接着进行读取操作（例如通过可变引用），则编译"
"器可能会认为读取的值是最新写入的值，就不再执行实际的内存读取过程。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Some existing crates for volatile access to hardware do hold references, but "
"this is unsound. Whenever a reference exist, the compiler may choose to "
"dereference it."
msgstr ""
"虽然在对硬件进行易失性访问时，一些 crate 确实会提及引用，但这很不安全。只要存"
"在引用，编译器就会选择对其进行解引用操作。"

#: src/bare-metal/aps/mmio.md
msgid ""
"Use the `addr_of!` macro to get struct field pointers from a pointer to the "
"struct."
msgstr "使用 `addr_of!` 宏可以从结构体指针中获取结构体字段的指针。"

#: src/bare-metal/aps/uart.md
msgid "Let's write a UART driver"
msgstr "编写 UART 驱动程序"

#: src/bare-metal/aps/uart.md
msgid ""
"The QEMU 'virt' machine has a [PL011](https://developer.arm.com/"
"documentation/ddi0183/g) UART, so let's write a driver for that."
msgstr ""
"QEMU “虚拟机”具有 [PL011](https://developer.arm.com/documentation/ddi0183/g) "
"UART，现在为其编写驱动程序。"

#: src/bare-metal/aps/uart.md
msgid "/// Minimal driver for a PL011 UART.\n"
msgstr "/// Minimal driver for a PL011 UART.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the 8 MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "/// Writes a single byte to the UART.\n"
msgstr "/// Writes a single byte to the UART.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "// Wait until there is room in the TX buffer.\n"
msgstr "// Wait until there is room in the TX buffer.\n"

#: src/bare-metal/aps/uart.md
msgid ""
"// Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Safe because we know that the base address points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "// Write to the TX buffer.\n"
msgstr "// Write to the TX buffer.\n"

#: src/bare-metal/aps/uart.md src/bare-metal/aps/better-uart/driver.md
#: src/exercises/bare-metal/rtc.md
msgid "// Wait until the UART is no longer busy.\n"
msgstr "// Wait until the UART is no longer busy.\n"

#: src/bare-metal/aps/uart.md
msgid ""
"Note that `Uart::new` is unsafe while the other methods are safe. This is "
"because as long as the caller of `Uart::new` guarantees that its safety "
"requirements are met (i.e. that there is only ever one instance of the "
"driver for a given UART, and nothing else aliasing its address space), then "
"it is always safe to call `write_byte` later because we can assume the "
"necessary preconditions."
msgstr ""
"请注意，使用 `Uart::new` 方法不安全，而其他方法则安全。原因在于，只要 `Uart::"
"new` 的调用方保证满足其安全要求（即所指定的 UART 只有一个驱动程序实例，且没有"
"其他内容与其地址空间存在重叠），那么后续调用 `write_byte` 始终是安全的，因为"
"我们假定需要满足的前提条件。"

#: src/bare-metal/aps/uart.md
msgid ""
"We could have done it the other way around (making `new` safe but "
"`write_byte` unsafe), but that would be much less convenient to use as every "
"place that calls `write_byte` would need to reason about the safety"
msgstr ""
"我们也可以采用相反的方式（即确保 `new` 安全，但 `write_byte` 不安全），不过这"
"样会很不方便，因为每当调用 `write_byte` 时都需要推断是否安全。"

#: src/bare-metal/aps/uart.md
msgid ""
"This is a common pattern for writing safe wrappers of unsafe code: moving "
"the burden of proof for soundness from a large number of places to a smaller "
"number of places."
msgstr ""
"这是安全地封装不安全代码时常见的策略：即在少数调用代码的地方进行安全验证，而"
"不是在很多地方进行。"

#: src/bare-metal/aps/uart/traits.md
msgid "More traits"
msgstr "更多 trait"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"We derived the `Debug` trait. It would be useful to implement a few more "
"traits too."
msgstr "已经派生了 `Debug` trait。如果再实现更多 trait，会大有帮助。"

#: src/bare-metal/aps/uart/traits.md src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"
msgstr ""
"// Safe because it just contains a pointer to device memory, which can be\n"
"// accessed from any context.\n"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"Implementing `Write` lets us use the `write!` and `writeln!` macros with our "
"`Uart` type."
msgstr ""
"通过实现 `Write`，我们可以将 `write!` 和 `writeln!` 宏与 `Uart` 类型搭配使"
"用。"

#: src/bare-metal/aps/uart/traits.md
msgid ""
"Run the example in QEMU with `make qemu_minimal` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"在 QEMU 中，使用 `src/bare-metal/aps/examples` 目录下的 `make qemu_minimal` "
"运行该示例。"

#: src/bare-metal/aps/better-uart.md
msgid "A better UART driver"
msgstr "更好的 UART 驱动程序"

#: src/bare-metal/aps/better-uart.md
msgid ""
"The PL011 actually has [a bunch more registers](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers), and adding "
"offsets to construct pointers to access them is error-prone and hard to "
"read. Plus, some of them are bit fields which would be nice to access in a "
"structured way."
msgstr ""
"事实上，PL011 具有 [很多额外的寄存器](https://developer.arm.com/"
"documentation/ddi0183/g/programmers-model/summary-of-registers)，但通过添加偏"
"移量构建指针的方式来访问这些寄存器，既容易出错又难以读取。此外，其中有些寄存"
"器是位字段，非常便于以结构化方式访问。"

#: src/bare-metal/aps/better-uart.md
msgid "Offset"
msgstr "偏移"

#: src/bare-metal/aps/better-uart.md
msgid "Register name"
msgstr "寄存器名称"

#: src/bare-metal/aps/better-uart.md
msgid "Width"
msgstr "宽度"

#: src/bare-metal/aps/better-uart.md
msgid "0x00"
msgstr "0x00"

#: src/bare-metal/aps/better-uart.md
msgid "DR"
msgstr "DR"

#: src/bare-metal/aps/better-uart.md
msgid "12"
msgstr "12"

#: src/bare-metal/aps/better-uart.md
msgid "0x04"
msgstr "0x04"

#: src/bare-metal/aps/better-uart.md
msgid "RSR"
msgstr "RSR"

#: src/bare-metal/aps/better-uart.md
msgid "0x18"
msgstr "0x18"

#: src/bare-metal/aps/better-uart.md
msgid "FR"
msgstr "FR"

#: src/bare-metal/aps/better-uart.md
msgid "9"
msgstr "9"

#: src/bare-metal/aps/better-uart.md
msgid "0x20"
msgstr "0x20"

#: src/bare-metal/aps/better-uart.md
msgid "ILPR"
msgstr "ILPR"

#: src/bare-metal/aps/better-uart.md
msgid "0x24"
msgstr "0x24"

#: src/bare-metal/aps/better-uart.md
msgid "IBRD"
msgstr "IBRD"

#: src/bare-metal/aps/better-uart.md
msgid "16"
msgstr "16"

#: src/bare-metal/aps/better-uart.md
msgid "0x28"
msgstr "0x28"

#: src/bare-metal/aps/better-uart.md
msgid "FBRD"
msgstr "FBRD"

#: src/bare-metal/aps/better-uart.md
msgid "0x2c"
msgstr "0x2c"

#: src/bare-metal/aps/better-uart.md
msgid "LCR_H"
msgstr "LCR_H"

#: src/bare-metal/aps/better-uart.md
msgid "0x30"
msgstr "0x30"

#: src/bare-metal/aps/better-uart.md
msgid "CR"
msgstr "CR"

#: src/bare-metal/aps/better-uart.md
msgid "0x34"
msgstr "0x34"

#: src/bare-metal/aps/better-uart.md
msgid "IFLS"
msgstr "IFLS"

#: src/bare-metal/aps/better-uart.md
msgid "0x38"
msgstr "0x38"

#: src/bare-metal/aps/better-uart.md
msgid "IMSC"
msgstr "IMSC"

#: src/bare-metal/aps/better-uart.md
msgid "11"
msgstr "11"

#: src/bare-metal/aps/better-uart.md
msgid "0x3c"
msgstr "0x3c"

#: src/bare-metal/aps/better-uart.md
msgid "RIS"
msgstr "RIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x40"
msgstr "0x40"

#: src/bare-metal/aps/better-uart.md
msgid "MIS"
msgstr "MIS"

#: src/bare-metal/aps/better-uart.md
msgid "0x44"
msgstr "0x44"

#: src/bare-metal/aps/better-uart.md
msgid "ICR"
msgstr "ICR"

#: src/bare-metal/aps/better-uart.md
msgid "0x48"
msgstr "0x48"

#: src/bare-metal/aps/better-uart.md
msgid "DMACR"
msgstr "DMACR"

#: src/bare-metal/aps/better-uart.md
msgid "There are also some ID registers which have been omitted for brevity."
msgstr "为简洁起见，我们省略了一些 ID 寄存器。"

#: src/bare-metal/aps/better-uart/bitflags.md
msgid ""
"The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for "
"working with bitflags."
msgstr ""
"[`bitflags`](https://crates.io/crates/bitflags) crate 非常适用于处理 "
"bitflag。"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Flags from the UART flag register.\n"
msgstr "/// Flags from the UART flag register.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Clear to send.\n"
msgstr "/// Clear to send.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Data set ready.\n"
msgstr "/// Data set ready.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Data carrier detect.\n"
msgstr "/// Data carrier detect.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// UART busy transmitting data.\n"
msgstr "/// UART busy transmitting data.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Receive FIFO is empty.\n"
msgstr "/// Receive FIFO is empty.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Transmit FIFO is full.\n"
msgstr "/// Transmit FIFO is full.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Receive FIFO is full.\n"
msgstr "/// Receive FIFO is full.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Transmit FIFO is empty.\n"
msgstr "/// Transmit FIFO is empty.\n"

#: src/bare-metal/aps/better-uart/bitflags.md src/exercises/bare-metal/rtc.md
msgid "/// Ring indicator.\n"
msgstr "/// Ring indicator.\n"

#: src/bare-metal/aps/better-uart/bitflags.md
msgid ""
"The `bitflags!` macro creates a newtype something like `Flags(u16)`, along "
"with a bunch of method implementations to get and set flags."
msgstr ""
"`bitflags!` 宏会创建类似于 `Flags(u16)` 的新类型，以及一系列用于获取和设置标"
"记的方法实现。"

#: src/bare-metal/aps/better-uart/registers.md
msgid "Multiple registers"
msgstr "多个寄存器"

#: src/bare-metal/aps/better-uart/registers.md
msgid ""
"We can use a struct to represent the memory layout of the UART's registers."
msgstr "我们可以使用结构体来表示 UART 寄存器的内存布局。"

#: src/bare-metal/aps/better-uart/registers.md
msgid ""
"[`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-"
"representation) tells the compiler to lay the struct fields out in order, "
"following the same rules as C. This is necessary for our struct to have a "
"predictable layout, as default Rust representation allows the compiler to "
"(among other things) reorder fields however it sees fit."
msgstr ""
"通过运行 [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout."
"html#the-c-representation) 命令，指示编译器按顺序布置结构体字段，遵循与 C 语"
"言相同的规则。这是确保结构体具有可预测布局的必要条件，因为默认的 Rust 表示法"
"允许编译器（以及其他内容）按照其认为合适的方式重新排列字段。"

#: src/bare-metal/aps/better-uart/driver.md
msgid "Now let's use the new `Registers` struct in our driver."
msgstr "现在将新的 `Registers` 结构体用于我们的驱动程序。"

#: src/bare-metal/aps/better-uart/driver.md
msgid "/// Driver for a PL011 UART.\n"
msgstr "/// Driver for a PL011 UART.\n"

#: src/bare-metal/aps/better-uart/driver.md src/exercises/bare-metal/rtc.md
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"
msgstr ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL011 device which is appropriately mapped.\n"

#: src/bare-metal/aps/better-uart/driver.md src/exercises/bare-metal/rtc.md
#, fuzzy
msgid ""
"/// Reads and returns a pending byte, or `None` if nothing has been\n"
"    /// received.\n"
msgstr ""
"/// Reads and returns a pending byte, or `None` if nothing has been "
"received.\n"

#: src/bare-metal/aps/better-uart/driver.md src/exercises/bare-metal/rtc.md
msgid "// TODO: Check for error conditions in bits 8-11.\n"
msgstr "// TODO: Check for error conditions in bits 8-11.\n"

#: src/bare-metal/aps/better-uart/driver.md
msgid ""
"Note the use of `addr_of!` / `addr_of_mut!` to get pointers to individual "
"fields without creating an intermediate reference, which would be unsound."
msgstr ""
"请注意，只使用 `addr_of!` / `addr_of_mut!` 获取指向各个字段的指针，而不创建中"
"间引用，这样很不安全。"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
msgid "Using it"
msgstr "开始使用"

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"Let's write a small program using our driver to write to the serial console, "
"and echo incoming bytes."
msgstr "使用驱动程序编写一个小程序，将数据写入串行控制台，并回显传入的字节。"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Base address of the primary PL011 UART.\n"
msgstr "/// Base address of the primary PL011 UART.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""
"// Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,\n"
"    // and nothing else accesses that address range.\n"

#: src/bare-metal/aps/better-uart/using.md src/bare-metal/aps/logging/using.md
msgid "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""
msgstr "\"main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})\""

#: src/bare-metal/aps/better-uart/using.md
msgid "b'\\r'"
msgstr "b'\\r'"

#: src/bare-metal/aps/better-uart/using.md src/async/pitfalls/cancellation.md
msgid "b'\\n'"
msgstr "b'\\n'"

#: src/bare-metal/aps/better-uart/using.md
msgid "b'q'"
msgstr "b'q'"

#: src/bare-metal/aps/better-uart/using.md
msgid "\"Bye!\""
msgstr "\"Bye!\""

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"As in the [inline assembly](../inline-assembly.md) example, this `main` "
"function is called from our entry point code in `entry.S`. See the speaker "
"notes there for details."
msgstr ""
"与 [内嵌汇编](../inline-assembly.md) 示例一样，从 `entry.S` 中的入口点代码调"
"用此 `main` 函数。如需了解详情，请参阅演讲者备注。"

#: src/bare-metal/aps/better-uart/using.md
msgid ""
"Run the example in QEMU with `make qemu` under `src/bare-metal/aps/examples`."
msgstr ""
"在 QEMU 中，使用 `src/bare-metal/aps/examples` 目录下的 `make qemu` 运行该示"
"例。"

#: src/bare-metal/aps/logging.md
msgid ""
"It would be nice to be able to use the logging macros from the [`log`]"
"(https://crates.io/crates/log) crate. We can do this by implementing the "
"`Log` trait."
msgstr ""
"最好能够使用 [`log`](https://crates.io/crates/log) crate 中的日志记录宏。可以"
"通过实现“Log”trait 来做到这一点。"

#: src/bare-metal/aps/logging.md src/exercises/bare-metal/rtc.md
msgid "\"[{}] {}\""
msgstr "\"[{}] {}\""

#: src/bare-metal/aps/logging.md src/exercises/bare-metal/rtc.md
msgid "/// Initialises UART logger.\n"
msgstr "/// Initialises UART logger.\n"

#: src/bare-metal/aps/logging.md
msgid ""
"The unwrap in `log` is safe because we initialise `LOGGER` before calling "
"`set_logger`."
msgstr ""
"使用 `log` 进行解封装是安全的，因为我们会在调用 `set_logger` 之前初始化 "
"`LOGGER`。"

#: src/bare-metal/aps/logging/using.md
msgid "We need to initialise the logger before we use it."
msgstr "需要先初始化日志记录器，然后才能使用它。"

#: src/bare-metal/aps/logging/using.md src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"{info}\""
msgstr "\"{info}\""

#: src/bare-metal/aps/logging/using.md
msgid "Note that our panic handler can now log details of panics."
msgstr "请注意，panic 紧急处理程序现在可以记录各类 panic 详细信息。"

#: src/bare-metal/aps/logging/using.md
msgid ""
"Run the example in QEMU with `make qemu_logger` under `src/bare-metal/aps/"
"examples`."
msgstr ""
"在 QEMU 中，使用 `src/bare-metal/aps/examples` 目录下的 `make qemu_logger` 运"
"行该示例。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"AArch64 defines an exception vector table with 16 entries, for 4 types of "
"exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with "
"SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). "
"We implement this in assembly to save volatile registers to the stack before "
"calling into Rust code:"
msgstr ""
"AArch64 定义了一个包含 16 个条目的异常矢量表，适用于处理 4 种状态（当前 EL 使"
"用 SP0，当前 EL 使用 SPx，较低 EL 使用 AArch64，较低 EL 使用 AArch32）下的 4 "
"种异常（同步、IRQ、FIQ、SError）。可以通过汇编方式实现这一操作，以便在调用 "
"Rust 代码之前将易失性寄存器保存到堆栈："

#: src/bare-metal/aps/exceptions.md
msgid "EL is exception level; all our examples this afternoon run in EL1."
msgstr "EL 指异常级别；我们今天下午的所有示例都在 EL1 级别下运行。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"For simplicity we aren't distinguishing between SP0 and SPx for the current "
"EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions."
msgstr ""
"为简单起见，我们没有区分当前 EL 异常中的 SP0 和 SPx，也没有区分较低 EL 异常中"
"的 AArch32 和 AArch64。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"For this example we just log the exception and power down, as we don't "
"expect any of them to actually happen."
msgstr "在本示例中，只需记录异常并进行关机操作，因为预计不会发生任何此类异常。"

#: src/bare-metal/aps/exceptions.md
msgid ""
"We can think of exception handlers and our main execution context more or "
"less like different threads. [`Send` and `Sync`](../../concurrency/send-sync."
"md) will control what we can share between them, just like with threads. For "
"example, if we want to share some value between exception handlers and the "
"rest of the program, and it's `Send` but not `Sync`, then we'll need to wrap "
"it in something like a `Mutex` and put it in a static."
msgstr ""
"我们可以将异常处理程序和主执行上下文视为不同的线程。通过 [`Send` 和 `Sync`]"
"(../../concurrency/send-sync.md) 控制它们之间可以共享的内容，就像使用线程进行"
"共享一样。例如，如果想在异常处理程序和程序的其余部分之间共享某个值，并且使用 "
"`Send` 而非 `Sync`，则需要将该值封装在诸如 `Mutex` 之类的内容中，并放入静态变"
"量。"

#: src/bare-metal/aps/other-projects.md
msgid "[oreboot](https://github.com/oreboot/oreboot)"
msgstr "[oreboot](https://github.com/oreboot/oreboot)"

#: src/bare-metal/aps/other-projects.md
msgid "\"coreboot without the C\""
msgstr "\"coreboot without the C\""

#: src/bare-metal/aps/other-projects.md
msgid "Supports x86, aarch64 and RISC-V."
msgstr "支持 x86、aarch64 和 RISC-V。"

#: src/bare-metal/aps/other-projects.md
msgid "Relies on LinuxBoot rather than having many drivers itself."
msgstr "依赖于 LinuxBoot，而不是许多驱动程序本身。"

#: src/bare-metal/aps/other-projects.md
msgid ""
"[Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"
msgstr ""
"[Rust RaspberryPi 操作系统教程](https://github.com/rust-embedded/rust-"
"raspberrypi-OS-tutorials)"

#: src/bare-metal/aps/other-projects.md
msgid ""
"Initialisation, UART driver, simple bootloader, JTAG, exception levels, "
"exception handling, page tables"
msgstr ""
"初始化、UART 驱动程序、简单引导加载程序、JTAG、异常级别、异常处理、分页表"

#: src/bare-metal/aps/other-projects.md
msgid ""
"Some dodginess around cache maintenance and initialisation in Rust, not "
"necessarily a good example to copy for production code."
msgstr ""
"在 Rust 中，有些用于处理缓存维护和初始化的方法并不安全，不适宜照搬到正式版代"
"码中。"

#: src/bare-metal/aps/other-projects.md
msgid "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"
msgstr "[`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)"

#: src/bare-metal/aps/other-projects.md
msgid "Static analysis to determine maximum stack usage."
msgstr "使用静态分析来确定堆栈用量上限。"

#: src/bare-metal/aps/other-projects.md
msgid ""
"The RaspberryPi OS tutorial runs Rust code before the MMU and caches are "
"enabled. This will read and write memory (e.g. the stack). However:"
msgstr ""
"在 RaspberryPi 操作系统教程中，先运行 Rust 代码然后启用 MMU 和缓存。此操作会"
"读取和写入内存（例如堆栈）。不过："

#: src/bare-metal/aps/other-projects.md
msgid ""
"Without the MMU and cache, unaligned accesses will fault. It builds with "
"`aarch64-unknown-none` which sets `+strict-align` to prevent the compiler "
"generating unaligned accesses so it should be alright, but this is not "
"necessarily the case in general."
msgstr ""
"如果不启用 MMU 和缓存，非对齐访问将会出错。它使用 `aarch64-unknown-none` 进行"
"构建，后者会设置 `+strict-align` 以防止编译器生成非对齐访问，因此应该没有问"
"题，但一般情况下并不一定如此。"

#: src/bare-metal/aps/other-projects.md
msgid ""
"If it were running in a VM, this can lead to cache coherency issues. The "
"problem is that the VM is accessing memory directly with the cache disabled, "
"while the host has cacheable aliases to the same memory. Even if the host "
"doesn't explicitly access the memory, speculative accesses can lead to cache "
"fills, and then changes from one or the other will get lost. Again this is "
"alright in this particular case (running directly on the hardware with no "
"hypervisor), but isn't a good pattern in general."
msgstr ""
"如果是在虚拟机中运行该命令，可能会导致缓存一致性问题。问题在于，虚拟机是在禁"
"用缓存的情况下直接访问内存，而主机具有同一内存的缓存别名。即使主机并没有明确"
"访问该内存，推测性访问仍然会导致缓存被填充，然后任何一方对于该内存进行的更改"
"就会丢失。再次强调，尽管在此特定示例中（即在硬件上直接运行且无 Hypervisor）这"
"种做法是可行的，但总的来说，这并非一种良好策略。"

#: src/bare-metal/useful-crates.md
#, fuzzy
msgid "Useful crates"
msgstr "有用的 crate"

#: src/bare-metal/useful-crates.md
msgid ""
"We'll go over a few crates which solve some common problems in bare-metal "
"programming."
msgstr "接下来介绍几个 crate，用于解决裸机编程中的一些常见问题。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"The [`zerocopy`](https://docs.rs/zerocopy/) crate (from Fuchsia) provides "
"traits and macros for safely converting between byte sequences and other "
"types."
msgstr ""
"[`zerocopy`](https://docs.rs/zerocopy/) crate（源自 Fuchsia）提供了 trait 和"
"宏，用于确保在字节序列和其他类型之间进行安全转换。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"This is not suitable for MMIO (as it doesn't use volatile reads and writes), "
"but can be useful for working with structures shared with hardware e.g. by "
"DMA, or sent over some external interface."
msgstr ""
"这不适用于 MMIO（因为它不使用易失性读取和写入），但在与硬件共享的结构（例如通"
"过 DMA 传输或发送到外部接口）中进行操作时会很有用。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"`FromBytes` can be implemented for types for which any byte pattern is "
"valid, and so can safely be converted from an untrusted sequence of bytes."
msgstr ""
"对于可以接受任何字节模式的类型，都可以实现 `FromBytes`方法，因此可以对不受信"
"任的字节序列进行安全转换。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"Attempting to derive `FromBytes` for these types would fail, because "
"`RequestType` doesn't use all possible u32 values as discriminants, so not "
"all byte patterns are valid."
msgstr ""
"如果尝试为这些类型派生 `FromBytes`，都将会失败，因为 `RequestType` 不会将所有"
"可能的 u32 值用作判别标识，所以并非所有的字节模式都有效。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"`zerocopy::byteorder` has types for byte-order aware numeric primitives."
msgstr "`zerocopy::byteorder` 提供了适用于字节顺序感知的数字基元类型。"

#: src/bare-metal/useful-crates/zerocopy.md
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"zerocopy-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"使用 `src/bare-metal/useful-crates/zerocopy-example/` 目录下的 `cargo run` 运"
"行该示例。（由于存在 crate 依赖项，无法在 Playground 中运行该示例。）"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"The [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate lets "
"you create page tables according to the AArch64 Virtual Memory System "
"Architecture."
msgstr ""
"借助 [`aarch64-paging`](https://crates.io/crates/aarch64-paging) crate，您可"
"根据 AArch64 虚拟内存系统架构创建分页表。"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid "// Create a new page table with identity mapping.\n"
msgstr "// Create a new page table with identity mapping.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid "// Map a 2 MiB region of memory as read-only.\n"
msgstr "// Map a 2 MiB region of memory as read-only.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid "// Set `TTBR0_EL1` to activate the page table.\n"
msgstr "// Set `TTBR0_EL1` to activate the page table.\n"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"For now it only supports EL1, but support for other exception levels should "
"be straightforward to add."
msgstr "目前，该方法仅支持 EL1 级别，但也可以直接添加对其他异常级别的支持。"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"This is used in Android for the [Protected VM Firmware](https://cs.android."
"com/android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)."
msgstr ""
"在 Android 中，该方法适用于 [受保护的虚拟机固件](https://cs.android.com/"
"android/platform/superproject/+/master:packages/modules/Virtualization/"
"pvmfw/)。"

#: src/bare-metal/useful-crates/aarch64-paging.md
msgid ""
"There's no easy way to run this example, as it needs to run on real hardware "
"or under QEMU."
msgstr ""
"由于此示例需要在真实硬件上或在 QEMU 中运行，因此没有简单的运行方法可用。"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"is a third-party crate implementing a basic buddy system allocator. It can "
"be used both for [`LockedHeap`](https://docs.rs/buddy_system_allocator/0.9.0/"
"buddy_system_allocator/struct.LockedHeap.html) implementing [`GlobalAlloc`]"
"(https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) so you can use "
"the standard `alloc` crate (as we saw [before](../alloc.md)), or for "
"allocating other address space. For example, we might want to allocate MMIO "
"space for PCI BARs:"
msgstr ""
"[`buddy_system_allocator`](https://crates.io/crates/buddy_system_allocator) "
"是第三方 crate，用于实现基本伙伴系统分配器。同时，也可将其用于 [`LockedHeap`]"
"(https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct."
"LockedHeap.html) 以实现 [`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/"
"trait.GlobalAlloc.html)，这样便可以使用标准的 `alloc` crate（正如在 [之前部"
"分](../alloc.md) 中所示），或者用于分配其他地址空间。例如，我们可能需要为 "
"PCI BAR 分配 MMIO 空间："

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid "PCI BARs always have alignment equal to their size."
msgstr "PCI BAR 的对齐方式始终与其大小相等。"

#: src/bare-metal/useful-crates/buddy_system_allocator.md
msgid ""
"Run the example with `cargo run` under `src/bare-metal/useful-crates/"
"allocator-example/`. (It won't run in the Playground because of the crate "
"dependency.)"
msgstr ""
"使用 `src/bare-metal/useful-crates/allocator-example/` 目录下的 `cargo run` "
"运行该示例。（由于存在 crate 依赖项，无法在 Playground 中运行该示例。）"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"Sometimes you want something which can be resized like a `Vec`, but without "
"heap allocation. [`tinyvec`](https://crates.io/crates/tinyvec) provides "
"this: a vector backed by an array or slice, which could be statically "
"allocated or on the stack, which keeps track of how many elements are used "
"and panics if you try to use more than are allocated."
msgstr ""
"有时，需要一些像 `Vec` 一样能够调整大小的特性，但无需进行堆分配。[`tinyvec`]"
"(https://crates.io/crates/tinyvec) 提供了以下特性：由数组或 slice 支持的矢"
"量，该矢量支持进行静态分配或堆分配；用于跟踪使用的元素数量，如果元素使用量超"
"过了分配额度，则会出现 panic。"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"`tinyvec` requires that the element type implement `Default` for "
"initialisation."
msgstr "根据 `tinyvec`要求，元素类型需实现初始化 `Default`。"

#: src/bare-metal/useful-crates/tinyvec.md
msgid ""
"The Rust Playground includes `tinyvec`, so this example will run fine inline."
msgstr "Rust Playground 中包含 `tinyvec`，因此本示例将以内嵌方式正常运行。"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"`std::sync::Mutex` and the other synchronisation primitives from `std::sync` "
"are not available in `core` or `alloc`. How can we manage synchronisation or "
"interior mutability, such as for sharing state between different CPUs?"
msgstr ""
"在 `core` 或 `alloc` 中无法使用 `std::sync::Mutex` 和 `std::sync` 中的其他同"
"步基元。那么该如何管理同步或内部可变性，例如在不同 CPU 之间共享状态？"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The [`spin`](https://crates.io/crates/spin) crate provides spinlock-based "
"equivalents of many of these primitives."
msgstr ""
"[`spin`](https://crates.io/crates/spin) crate 为许多基元提供了基于自旋锁的等"
"效方法。"

#: src/bare-metal/useful-crates/spin.md
msgid "Be careful to avoid deadlock if you take locks in interrupt handlers."
msgstr "在中断处理程序中进行锁定操作时，请注意避免出现死锁的情况。"

#: src/bare-metal/useful-crates/spin.md
#, fuzzy
msgid ""
"`spin` also has a ticket lock mutex implementation; equivalents of `RwLock`, "
"`Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialisation."
msgstr ""
"`spin` 还提供了一种票卡锁互斥实现，等同于 `std::sync` 中的 `RwLock`、"
"`Barrier` 和 `Once`，以及用于用于延迟初始化的 `Lazy`。"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The [`once_cell`](https://crates.io/crates/once_cell) crate also has some "
"useful types for late initialisation with a slightly different approach to "
"`spin::once::Once`."
msgstr ""
"[`once_cell`](https://crates.io/crates/once_cell) crate 也提供了一些适用于延"
"迟初始化的实用类型，它们与 `spin::once::Once` 所用方法略有不同。"

#: src/bare-metal/useful-crates/spin.md
msgid ""
"The Rust Playground includes `spin`, so this example will run fine inline."
msgstr "Rust Playground 中包含 `spin`，因此本示例将以内嵌方式正常运行。"

#: src/bare-metal/android.md
msgid ""
"To build a bare-metal Rust binary in AOSP, you need to use a "
"`rust_ffi_static` Soong rule to build your Rust code, then a `cc_binary` "
"with a linker script to produce the binary itself, and then a `raw_binary` "
"to convert the ELF to a raw binary ready to be run."
msgstr ""
"如需在 AOSP 中构建裸机 Rust 二进制文件，应使用 `rust_ffi_static` Soong 规则来"
"构建 Rust 代码，然后通过 `cc_binary` 和链接器脚本生成二进制文件本身，再使用 "
"`raw_binary` 将 ELF 转换为可以正常运行的原始二进制文件。"

#: src/bare-metal/android/vmbase.md
msgid "vmbase"
msgstr "vmbase"

#: src/bare-metal/android/vmbase.md
msgid ""
"For VMs running under crosvm on aarch64, the [vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) library provides a linker script and useful defaults for the "
"build rules, along with an entry point, UART console logging and more."
msgstr ""
"对于在 aarch64 上使用 crosvm 运行的虚拟机，[vmbase](https://android."
"googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/"
"master/vmbase/) 库提供了链接器脚本和实用的默认构建规则，以及入口点、UART 控制"
"台日志记录等功能。"

#: src/bare-metal/android/vmbase.md
msgid ""
"The `main!` macro marks your main function, to be called from the `vmbase` "
"entry point."
msgstr "`main!` 宏用于标记需从 `vmbase` 入口点调用的 main 函数。"

#: src/bare-metal/android/vmbase.md
msgid ""
"The `vmbase` entry point handles console initialisation, and issues a "
"PSCI_SYSTEM_OFF to shutdown the VM if your main function returns."
msgstr ""
"`vmbase` 入口点用于处理控制台初始化，并在 main 函数返回时发送 "
"PSCI_SYSTEM_OFF 命令以关闭虚拟机。"

#: src/exercises/bare-metal/afternoon.md
msgid "We will write a driver for the PL031 real-time clock device."
msgstr "我们将为 PL031 实时时钟设备编写驱动程序。"

#: src/exercises/bare-metal/afternoon.md src/exercises/concurrency/afternoon.md
#, fuzzy
msgid ""
"After looking at the exercises, you can look at the [solutions](solutions-"
"afternoon.md) provided."
msgstr "读完习题后，可以阅读本书提供的 \\[题解\\]。"

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "RTC driver"
msgstr "RTC 驱动程序"

#: src/exercises/bare-metal/rtc.md
msgid ""
"The QEMU aarch64 virt machine has a [PL031](https://developer.arm.com/"
"documentation/ddi0224/c) real-time clock at 0x9010000. For this exercise, "
"you should write a driver for it."
msgstr ""
"QEMU aarch64 虚拟机在 0x9010000 地址处 配备了 [PL031](https://developer.arm."
"com/documentation/ddi0224/c) 实时时钟。对于本练习，应该为其编写驱动程序。"

#: src/exercises/bare-metal/rtc.md
msgid ""
"Use it to print the current time to the serial console. You can use the "
"[`chrono`](https://crates.io/crates/chrono) crate for date/time formatting."
msgstr ""
"使用该时钟可将当前时间输出到串行控制台。您可以使用 [`chrono`](https://crates."
"io/crates/chrono) crate 设置日期/时间格式。"

#: src/exercises/bare-metal/rtc.md
msgid ""
"Use the match register and raw interrupt status to busy-wait until a given "
"time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`](https://"
"doc.rust-lang.org/core/hint/fn.spin_loop.html) inside the loop.)"
msgstr ""
"通过匹配寄存器和原始中断状态，使得系统在某段指定的时间内一直进行繁忙等待（例"
"如 3 秒后）。（在循环操作中调用 [`core::hint::spin_loop`](https://doc.rust-"
"lang.org/core/hint/fn.spin_loop.html)。）"

#: src/exercises/bare-metal/rtc.md
msgid ""
"_Extension if you have time:_ Enable and handle the interrupt generated by "
"the RTC match. You can use the driver provided in the [`arm-gic`](https://"
"docs.rs/arm-gic/) crate to configure the Arm Generic Interrupt Controller."
msgstr ""
"_进行扩展（如有时间）：_启用并处理由 RTC 匹配产生的中断。可以使用 [`arm-gic`]"
"(https://docs.rs/arm-gic/) crate 中提供的驱动程序来配置 Arm 通用中断控制器。"

#: src/exercises/bare-metal/rtc.md
msgid "Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`."
msgstr "请使用 RTC 中断，将其作为 `IntId::spi(2)` 连接到 GIC。"

#: src/exercises/bare-metal/rtc.md
msgid ""
"Once the interrupt is enabled, you can put the core to sleep via `arm_gic::"
"wfi()`, which will cause the core to sleep until it receives an interrupt."
msgstr ""
"启用中断后，可以通过 `arm_gic::wfi()` 让核心进入休眠状态，直到它收到中断信"
"号。"

#: src/exercises/bare-metal/rtc.md
msgid ""
"Download the [exercise template](../../comprehensive-rust-exercises.zip) and "
"look in the `rtc` directory for the following files."
msgstr ""
"下载 [练习模板](../../comprehensive-rust-exercises.zip) 并在 `rtc` 目录中查找"
"以下文件。"

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Base addresses of the GICv3.\n"
msgstr "/// Base addresses of the GICv3.\n"

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"main({:#x}, {:#x}, {:#x}, {:#x})\""
msgstr "\"main({:#x}, {:#x}, {:#x}, {:#x})\""

#: src/exercises/bare-metal/rtc.md
#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"
msgstr ""
"// Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base\n"
"    // addresses of a GICv3 distributor and redistributor respectively, and\n"
"    // nothing else accesses those address ranges.\n"

#: src/exercises/bare-metal/rtc.md
msgid "// TODO: Create instance of RTC driver and print current time.\n"
msgstr "// TODO: Create instance of RTC driver and print current time.\n"

#: src/exercises/bare-metal/rtc.md
msgid "// TODO: Wait for 3 seconds.\n"
msgstr "// TODO: Wait for 3 seconds.\n"

#: src/exercises/bare-metal/rtc.md
msgid ""
"_src/exceptions.rs_ (you should only need to change this for the 3rd part of "
"the exercise):"
msgstr "_src/exceptions.rs_（只需在本练习的第 3 部分更改此项）："

#: src/exercises/bare-metal/rtc.md
msgid ""
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"
msgstr ""
"// Copyright 2023 Google LLC\n"
"//\n"
"// Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"// you may not use this file except in compliance with the License.\n"
"// You may obtain a copy of the License at\n"
"//\n"
"//      http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"// Unless required by applicable law or agreed to in writing, software\n"
"// distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"// See the License for the specific language governing permissions and\n"
"// limitations under the License.\n"

#: src/exercises/bare-metal/rtc.md
msgid "\"sync_exception_current\""
msgstr "\"sync_exception_current\""

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "\"irq_current\""
msgstr "\"irq_current\""

#: src/exercises/bare-metal/rtc.md
msgid "\"No pending interrupt\""
msgstr "\"No pending interrupt\""

#: src/exercises/bare-metal/rtc.md
msgid "\"IRQ {intid:?}\""
msgstr "\"IRQ {intid:?}\""

#: src/exercises/bare-metal/rtc.md
msgid "\"fiq_current\""
msgstr "\"fiq_current\""

#: src/exercises/bare-metal/rtc.md
msgid "\"serr_current\""
msgstr "\"serr_current\""

#: src/exercises/bare-metal/rtc.md
msgid "\"sync_lower\""
msgstr "\"sync_lower\""

#: src/exercises/bare-metal/rtc.md
msgid "\"irq_lower\""
msgstr "\"irq_lower\""

#: src/exercises/bare-metal/rtc.md
msgid "\"fiq_lower\""
msgstr "\"fiq_lower\""

#: src/exercises/bare-metal/rtc.md
msgid "\"serr_lower\""
msgstr "\"serr_lower\""

#: src/exercises/bare-metal/rtc.md
msgid "_src/logger.rs_ (you shouldn't need to change this):"
msgstr "_src/logger.rs_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR: main\n"
msgstr "// ANCHOR: main\n"

#: src/exercises/bare-metal/rtc.md
msgid "_src/pl011.rs_ (you shouldn't need to change this):"
msgstr "_src/pl011.rs_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR: Flags\n"
msgstr "// ANCHOR: Flags\n"

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR_END: Flags\n"
msgstr "// ANCHOR_END: Flags\n"

#: src/exercises/bare-metal/rtc.md
msgid ""
"/// Flags from the UART Receive Status Register / Error Clear Register.\n"
msgstr ""
"/// Flags from the UART Receive Status Register / Error Clear Register.\n"

#: src/exercises/bare-metal/rtc.md
msgid "/// Framing error.\n"
msgstr "/// Framing error.\n"

#: src/exercises/bare-metal/rtc.md
msgid "/// Parity error.\n"
msgstr "/// Parity error.\n"

#: src/exercises/bare-metal/rtc.md
msgid "/// Break error.\n"
msgstr "/// Break error.\n"

#: src/exercises/bare-metal/rtc.md
msgid "/// Overrun error.\n"
msgstr "/// Overrun error.\n"

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR: Registers\n"
msgstr "// ANCHOR: Registers\n"

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR_END: Registers\n"
msgstr "// ANCHOR_END: Registers\n"

#: src/exercises/bare-metal/rtc.md
msgid ""
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"
msgstr ""
"// ANCHOR: Uart\n"
"/// Driver for a PL011 UART.\n"

#: src/exercises/bare-metal/rtc.md
msgid ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Constructs a new instance of the UART driver for a PL011 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL011 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"

#: src/exercises/bare-metal/rtc.md
msgid "// ANCHOR_END: Uart\n"
msgstr "// ANCHOR_END: Uart\n"

#: src/exercises/bare-metal/rtc.md
msgid "_build.rs_ (you shouldn't need to change this):"
msgstr "_build.rs_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid "\"linux\""
msgstr "\"linux\""

#: src/exercises/bare-metal/rtc.md
msgid "\"CROSS_COMPILE\""
msgstr "\"CROSS_COMPILE\""

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "\"aarch64-linux-gnu\""
msgstr "\"aarch64-none-elf\""

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "\"aarch64-none-elf\""
msgstr "\"aarch64-none-elf\""

#: src/exercises/bare-metal/rtc.md
msgid "\"entry.S\""
msgstr "\"entry.S\""

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "\"exceptions.S\""
msgstr "异常"

#: src/exercises/bare-metal/rtc.md
msgid "\"idmap.S\""
msgstr "\"idmap.S\""

#: src/exercises/bare-metal/rtc.md
msgid "\"empty\""
msgstr "\"empty\""

#: src/exercises/bare-metal/rtc.md
msgid "_entry.S_ (you shouldn't need to change this):"
msgstr "_entry.S_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"
msgstr ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".macro adr_l, reg:req, sym:req\n"
"\tadrp \\reg, \\sym\n"
"\tadd \\reg, \\reg, :lo12:\\sym\n"
".endm\n"
"\n"
".macro mov_i, reg:req, imm:req\n"
"\tmovz \\reg, :abs_g3:\\imm\n"
"\tmovk \\reg, :abs_g2_nc:\\imm\n"
"\tmovk \\reg, :abs_g1_nc:\\imm\n"
"\tmovk \\reg, :abs_g0_nc:\\imm\n"
".endm\n"
"\n"
".set .L_MAIR_DEV_nGnRE,\t0x04\n"
".set .L_MAIR_MEM_WBWA,\t0xff\n"
".set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)\n"
"\n"
"/* 4 KiB granule size for TTBR0_EL1. */\n"
".set .L_TCR_TG0_4KB, 0x0 << 14\n"
"/* 4 KiB granule size for TTBR1_EL1. */\n"
".set .L_TCR_TG1_4KB, 0x2 << 30\n"
"/* Disable translation table walk for TTBR1_EL1, generating a translation "
"fault instead. */\n"
".set .L_TCR_EPD1, 0x1 << 23\n"
"/* Translation table walks for TTBR0_EL1 are inner sharable. */\n"
".set .L_TCR_SH_INNER, 0x3 << 12\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are outer write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_OWB, 0x1 << 10\n"
"/*\n"
" * Translation table walks for TTBR0_EL1 are inner write-back read-allocate "
"write-allocate\n"
" * cacheable.\n"
" */\n"
".set .L_TCR_RGN_IWB, 0x1 << 8\n"
"/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */\n"
".set .L_TCR_T0SZ_512, 64 - 39\n"
".set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | ."
"L_TCR_RGN_OWB\n"
".set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | ."
"L_TCR_T0SZ_512\n"
"\n"
"/* Stage 1 instruction access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_I, 0x1 << 12\n"
"/* SP alignment fault if SP is not aligned to a 16 byte boundary. */\n"
".set .L_SCTLR_ELx_SA, 0x1 << 3\n"
"/* Stage 1 data access cacheability is unaffected. */\n"
".set .L_SCTLR_ELx_C, 0x1 << 2\n"
"/* EL0 and EL1 stage 1 MMU enabled. */\n"
".set .L_SCTLR_ELx_M, 0x1 << 0\n"
"/* Privileged Access Never is unchanged on taking an exception to EL1. */\n"
".set .L_SCTLR_EL1_SPAN, 0x1 << 23\n"
"/* SETEND instruction disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_SED, 0x1 << 8\n"
"/* Various IT instructions are disabled at EL0 in aarch32 mode. */\n"
".set .L_SCTLR_EL1_ITD, 0x1 << 7\n"
".set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << "
"28) | (0x1 << 29)\n"
".set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | ."
"L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED\n"
".set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | ."
"L_SCTLR_EL1_RES1\n"
"\n"
"/**\n"
" * This is a generic entry point for an image. It carries out the operations "
"required to prepare the\n"
" * loaded image to be run. Specifically, it zeroes the bss section using "
"registers x25 and above,\n"
" * prepares the stack, enables floating point, and sets up the exception "
"vector. It preserves x0-x3\n"
" * for the Rust entry point, as these may contain boot parameters.\n"
" */\n"
".section .init.entry, \"ax\"\n"
".global entry\n"
"entry:\n"
"\t/* Load and apply the memory management configuration, ready to enable MMU "
"and caches. */\n"
"\tadrp x30, idmap\n"
"\tmsr ttbr0_el1, x30\n"
"\n"
"\tmov_i x30, .Lmairval\n"
"\tmsr mair_el1, x30\n"
"\n"
"\tmov_i x30, .Ltcrval\n"
"\t/* Copy the supported PA range into TCR_EL1.IPS. */\n"
"\tmrs x29, id_aa64mmfr0_el1\n"
"\tbfi x30, x29, #32, #4\n"
"\n"
"\tmsr tcr_el1, x30\n"
"\n"
"\tmov_i x30, .Lsctlrval\n"
"\n"
"\t/*\n"
"\t * Ensure everything before this point has completed, then invalidate any "
"potentially stale\n"
"\t * local TLB entries before they start being used.\n"
"\t */\n"
"\tisb\n"
"\ttlbi vmalle1\n"
"\tic iallu\n"
"\tdsb nsh\n"
"\tisb\n"
"\n"
"\t/*\n"
"\t * Configure sctlr_el1 to enable MMU and cache and don't proceed until "
"this has completed.\n"
"\t */\n"
"\tmsr sctlr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Disable trapping floating point access in EL1. */\n"
"\tmrs x30, cpacr_el1\n"
"\torr x30, x30, #(0x3 << 20)\n"
"\tmsr cpacr_el1, x30\n"
"\tisb\n"
"\n"
"\t/* Zero out the bss section. */\n"
"\tadr_l x29, bss_begin\n"
"\tadr_l x30, bss_end\n"
"0:\tcmp x29, x30\n"
"\tb.hs 1f\n"
"\tstp xzr, xzr, [x29], #16\n"
"\tb 0b\n"
"\n"
"1:\t/* Prepare the stack. */\n"
"\tadr_l x30, boot_stack_end\n"
"\tmov sp, x30\n"
"\n"
"\t/* Set up exception vector. */\n"
"\tadr x30, vector_table_el1\n"
"\tmsr vbar_el1, x30\n"
"\n"
"\t/* Call into Rust code. */\n"
"\tbl main\n"
"\n"
"\t/* Loop forever waiting for interrupts. */\n"
"2:\twfi\n"
"\tb 2b\n"
"```"

#: src/exercises/bare-metal/rtc.md
msgid "_exceptions.S_ (you shouldn't need to change this):"
msgstr "_exceptions.S_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"
msgstr ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/**\n"
" * Saves the volatile registers onto the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers with 18 "
"instructions\n"
" * left.\n"
" *\n"
" * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 "
"respectively,\n"
" * which can be used as the first and second arguments of a subsequent "
"call.\n"
" */\n"
".macro save_volatile_to_stack\n"
"\t/* Reserve stack space and save registers x0-x18, x29 & x30. */\n"
"\tstp x0, x1, [sp, #-(8 * 24)]!\n"
"\tstp x2, x3, [sp, #8 * 2]\n"
"\tstp x4, x5, [sp, #8 * 4]\n"
"\tstp x6, x7, [sp, #8 * 6]\n"
"\tstp x8, x9, [sp, #8 * 8]\n"
"\tstp x10, x11, [sp, #8 * 10]\n"
"\tstp x12, x13, [sp, #8 * 12]\n"
"\tstp x14, x15, [sp, #8 * 14]\n"
"\tstp x16, x17, [sp, #8 * 16]\n"
"\tstr x18, [sp, #8 * 18]\n"
"\tstp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/*\n"
"\t * Save elr_el1 & spsr_el1. This such that we can take nested exception\n"
"\t * and still be able to unwind.\n"
"\t */\n"
"\tmrs x0, elr_el1\n"
"\tmrs x1, spsr_el1\n"
"\tstp x0, x1, [sp, #8 * 22]\n"
".endm\n"
"\n"
"/**\n"
" * Restores the volatile registers from the stack. This currently takes 14\n"
" * instructions, so it can be used in exception handlers while still leaving "
"18\n"
" * instructions left; if paired with save_volatile_to_stack, there are 4\n"
" * instructions to spare.\n"
" */\n"
".macro restore_volatile_from_stack\n"
"\t/* Restore registers x2-x18, x29 & x30. */\n"
"\tldp x2, x3, [sp, #8 * 2]\n"
"\tldp x4, x5, [sp, #8 * 4]\n"
"\tldp x6, x7, [sp, #8 * 6]\n"
"\tldp x8, x9, [sp, #8 * 8]\n"
"\tldp x10, x11, [sp, #8 * 10]\n"
"\tldp x12, x13, [sp, #8 * 12]\n"
"\tldp x14, x15, [sp, #8 * 14]\n"
"\tldp x16, x17, [sp, #8 * 16]\n"
"\tldr x18, [sp, #8 * 18]\n"
"\tldp x29, x30, [sp, #8 * 20]\n"
"\n"
"\t/* Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch. */\n"
"\tldp x0, x1, [sp, #8 * 22]\n"
"\tmsr elr_el1, x0\n"
"\tmsr spsr_el1, x1\n"
"\n"
"\t/* Restore x0 & x1, and release stack space. */\n"
"\tldp x0, x1, [sp], #8 * 24\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SP0. It behaves similarly to the SPx case by first switching to SPx, "
"doing\n"
" * the work, then switching back to SP0 before returning.\n"
" *\n"
" * Switching to SPx and calling the Rust handler takes 16 instructions. To\n"
" * restore and return we need an additional 16 instructions, so we can "
"implement\n"
" * the whole handler within the allotted 32 instructions.\n"
" */\n"
".macro current_exception_sp0 handler:req\n"
"\tmsr spsel, #1\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\tmsr spsel, #0\n"
"\teret\n"
".endm\n"
"\n"
"/**\n"
" * This is a generic handler for exceptions taken at the current EL while "
"using\n"
" * SPx. It saves volatile registers, calls the Rust handler, restores "
"volatile\n"
" * registers, then returns.\n"
" *\n"
" * This also works for exceptions taken from EL0, if we don't care about\n"
" * non-volatile registers.\n"
" *\n"
" * Saving state and jumping to the Rust handler takes 15 instructions, and\n"
" * restoring and returning also takes 15 instructions, so we can fit the "
"whole\n"
" * handler in 30 instructions, under the limit of 32.\n"
" */\n"
".macro current_exception_spx handler:req\n"
"\tsave_volatile_to_stack\n"
"\tbl \\handler\n"
"\trestore_volatile_from_stack\n"
"\teret\n"
".endm\n"
"\n"
".section .text.vector_table_el1, \"ax\"\n"
".global vector_table_el1\n"
".balign 0x800\n"
"vector_table_el1:\n"
"sync_cur_sp0:\n"
"\tcurrent_exception_sp0 sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_sp0:\n"
"\tcurrent_exception_sp0 irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_sp0:\n"
"\tcurrent_exception_sp0 fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_sp0:\n"
"\tcurrent_exception_sp0 serr_current\n"
"\n"
".balign 0x80\n"
"sync_cur_spx:\n"
"\tcurrent_exception_spx sync_exception_current\n"
"\n"
".balign 0x80\n"
"irq_cur_spx:\n"
"\tcurrent_exception_spx irq_current\n"
"\n"
".balign 0x80\n"
"fiq_cur_spx:\n"
"\tcurrent_exception_spx fiq_current\n"
"\n"
".balign 0x80\n"
"serr_cur_spx:\n"
"\tcurrent_exception_spx serr_current\n"
"\n"
".balign 0x80\n"
"sync_lower_64:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_64:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_64:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_64:\n"
"\tcurrent_exception_spx serr_lower\n"
"\n"
".balign 0x80\n"
"sync_lower_32:\n"
"\tcurrent_exception_spx sync_lower\n"
"\n"
".balign 0x80\n"
"irq_lower_32:\n"
"\tcurrent_exception_spx irq_lower\n"
"\n"
".balign 0x80\n"
"fiq_lower_32:\n"
"\tcurrent_exception_spx fiq_lower\n"
"\n"
".balign 0x80\n"
"serr_lower_32:\n"
"\tcurrent_exception_spx serr_lower\n"
"```"

#: src/exercises/bare-metal/rtc.md
msgid "_idmap.S_ (you shouldn't need to change this):"
msgstr "_idmap.S_（无需对此进行更改）"

#: src/exercises/bare-metal/rtc.md
msgid ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"
msgstr ""
"```armasm\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
".set .L_TT_TYPE_BLOCK, 0x1\n"
".set .L_TT_TYPE_PAGE,  0x3\n"
".set .L_TT_TYPE_TABLE, 0x3\n"
"\n"
"/* Access flag. */\n"
".set .L_TT_AF, 0x1 << 10\n"
"/* Not global. */\n"
".set .L_TT_NG, 0x1 << 11\n"
".set .L_TT_XN, 0x3 << 53\n"
"\n"
".set .L_TT_MT_DEV, 0x0 << 2\t\t\t// MAIR #0 (DEV_nGnRE)\n"
".set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)\t// MAIR #1 (MEM_WBWA), inner "
"shareable\n"
"\n"
".set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN\n"
".set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG\n"
"\n"
".section \".rodata.idmap\", \"a\", %progbits\n"
".global idmap\n"
".align 12\n"
"idmap:\n"
"\t/* level 1 */\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x0\t\t    // 1 GiB of device mappings\n"
"\t.quad\t\t.L_BLOCK_MEM | 0x40000000\t// 1 GiB of DRAM\n"
"\t.fill\t\t254, 8, 0x0\t\t\t// 254 GiB of unmapped VA space\n"
"\t.quad\t\t.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings\n"
"\t.fill\t\t255, 8, 0x0\t\t\t// 255 GiB of remaining VA space\n"
"```"

#: src/exercises/bare-metal/rtc.md
msgid "_image.ld_ (you shouldn't need to change this):"
msgstr "_image.ld_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"
msgstr ""
"```ld\n"
"/*\n"
" * Copyright 2023 Google LLC\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     https://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"/*\n"
" * Code will start running at this symbol which is placed at the start of "
"the\n"
" * image.\n"
" */\n"
"ENTRY(entry)\n"
"\n"
"MEMORY\n"
"{\n"
"\timage : ORIGIN = 0x40080000, LENGTH = 2M\n"
"}\n"
"\n"
"SECTIONS\n"
"{\n"
"\t/*\n"
"\t * Collect together the code.\n"
"\t */\n"
"\t.init : ALIGN(4096) {\n"
"\t\ttext_begin = .;\n"
"\t\t*(.init.entry)\n"
"\t\t*(.init.*)\n"
"\t} >image\n"
"\t.text : {\n"
"\t\t*(.text.*)\n"
"\t} >image\n"
"\ttext_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together read-only data.\n"
"\t */\n"
"\t.rodata : ALIGN(4096) {\n"
"\t\trodata_begin = .;\n"
"\t\t*(.rodata.*)\n"
"\t} >image\n"
"\t.got : {\n"
"\t\t*(.got)\n"
"\t} >image\n"
"\trodata_end = .;\n"
"\n"
"\t/*\n"
"\t * Collect together the read-write data including .bss at the end which\n"
"\t * will be zero'd by the entry code.\n"
"\t */\n"
"\t.data : ALIGN(4096) {\n"
"\t\tdata_begin = .;\n"
"\t\t*(.data.*)\n"
"\t\t/*\n"
"\t\t * The entry point code assumes that .data is a multiple of 32\n"
"\t\t * bytes long.\n"
"\t\t */\n"
"\t\t. = ALIGN(32);\n"
"\t\tdata_end = .;\n"
"\t} >image\n"
"\n"
"\t/* Everything beyond this point will not be included in the binary. */\n"
"\tbin_end = .;\n"
"\n"
"\t/* The entry point code assumes that .bss is 16-byte aligned. */\n"
"\t.bss : ALIGN(16)  {\n"
"\t\tbss_begin = .;\n"
"\t\t*(.bss.*)\n"
"\t\t*(COMMON)\n"
"\t\t. = ALIGN(16);\n"
"\t\tbss_end = .;\n"
"\t} >image\n"
"\n"
"\t.stack (NOLOAD) : ALIGN(4096) {\n"
"\t\tboot_stack_begin = .;\n"
"\t\t. += 40 * 4096;\n"
"\t\t. = ALIGN(4096);\n"
"\t\tboot_stack_end = .;\n"
"\t} >image\n"
"\n"
"\t. = ALIGN(4K);\n"
"\tPROVIDE(dma_region = .);\n"
"\n"
"\t/*\n"
"\t * Remove unused sections from the image.\n"
"\t */\n"
"\t/DISCARD/ : {\n"
"\t\t/* The image loads itself so doesn't need these sections. */\n"
"\t\t*(.gnu.hash)\n"
"\t\t*(.hash)\n"
"\t\t*(.interp)\n"
"\t\t*(.eh_frame_hdr)\n"
"\t\t*(.eh_frame)\n"
"\t\t*(.note.gnu.build-id)\n"
"\t}\n"
"}\n"
"```"

#: src/exercises/bare-metal/rtc.md
msgid "_Makefile_ (you shouldn't need to change this):"
msgstr "_Makefile_（无需对此进行更改）："

#: src/exercises/bare-metal/rtc.md
msgid "# Copyright 2023 Google LLC"
msgstr "# 版权所有 2023 Google LLC。"

#: src/exercises/bare-metal/rtc.md
msgid "$(shell uname -s)"
msgstr "$(shell uname -s)"

#: src/exercises/bare-metal/rtc.md
#, fuzzy
msgid "aarch64-linux-gnu"
msgstr "aarch64-paging"

#: src/exercises/bare-metal/rtc.md
msgid "stdio -display none -kernel $< -s"
msgstr "stdio -display none -kernel $< -s"

#: src/exercises/bare-metal/rtc.md
msgid "cargo clean"
msgstr "cargo 清理"

#: src/exercises/bare-metal/rtc.md
msgid "Run the code in QEMU with `make qemu`."
msgstr "使用 `make qemu` 在 QEMU 中运行代码。"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "Bare Metal Rust Afternoon"
msgstr "嵌入式 Rust：进阶篇"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "([back to exercise](rtc.md))"
msgstr "([返回练习](rtc.md))"

#: src/exercises/bare-metal/solutions-afternoon.md
#, fuzzy
msgid "_main.rs_:"
msgstr "`main.rs`:"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Base address of the PL031 RTC.\n"
msgstr "/// Base address of the PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// The IRQ used by the PL031 RTC.\n"
msgstr "/// The IRQ used by the PL031 RTC.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"
msgstr ""
"// Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,\n"
"    // and nothing else accesses that address range.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"RTC: {time}\""
msgstr "\"RTC: {time}\""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "// Wait for 3 seconds, without interrupts.\n"
msgstr "// Wait for 3 seconds, without interrupts.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"Waiting for {}\""
msgstr "\"Waiting for {}\""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"matched={}, interrupt_pending={}\""
msgstr "\"matched={}, interrupt_pending={}\""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "\"Finished waiting\""
msgstr "\"Finished waiting\""

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "// Wait another 3 seconds for an interrupt.\n"
msgstr "// Wait another 3 seconds for an interrupt.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "_pl031.rs_:"
msgstr "_pl031.rs_："

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Data register\n"
msgstr "/// Data register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Match register\n"
msgstr "/// Match register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Load register\n"
msgstr "/// Load register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Control register\n"
msgstr "/// Control register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Interrupt Mask Set or Clear register\n"
msgstr "/// Interrupt Mask Set or Clear register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Raw Interrupt Status\n"
msgstr "/// Raw Interrupt Status\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Masked Interrupt Status\n"
msgstr "/// Masked Interrupt Status\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Interrupt Clear Register\n"
msgstr "/// Interrupt Clear Register\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Driver for a PL031 real-time clock.\n"
msgstr "/// Driver for a PL031 real-time clock.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"
msgstr ""
"/// Constructs a new instance of the RTC driver for a PL031 device at the\n"
"    /// given base address.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The given base address must point to the MMIO control registers of "
"a\n"
"    /// PL031 device, which must be mapped into the address space of the "
"process\n"
"    /// as device memory and not have any other aliases.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Reads the current RTC value.\n"
msgstr "/// Reads the current RTC value.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"
msgstr ""
"// Safe because we know that self.registers points to the control\n"
"        // registers of a PL031 device which is appropriately mapped.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"
msgstr ""
"/// Writes a match value. When the RTC value matches this then an interrupt\n"
"    /// will be generated (if it is enabled).\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"
msgstr ""
"/// Returns whether the match register matches the RTC value, whether or "
"not\n"
"    /// the interrupt is enabled.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"
msgstr ""
"/// Returns whether there is currently an interrupt pending.\n"
"    ///\n"
"    /// This should be true if and only if `matched` returns true and the\n"
"    /// interrupt is masked.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"
msgstr ""
"/// Sets or clears the interrupt mask.\n"
"    ///\n"
"    /// When the mask is true the interrupt is enabled; when it is false "
"the\n"
"    /// interrupt is disabled.\n"

#: src/exercises/bare-metal/solutions-afternoon.md
msgid "/// Clears a pending interrupt, if any.\n"
msgstr "/// Clears a pending interrupt, if any.\n"

#: src/concurrency.md
msgid "Welcome to Concurrency in Rust"
msgstr "欢迎了解 Rust 中的并发"

#: src/concurrency.md
msgid ""
"Rust has full support for concurrency using OS threads with mutexes and "
"channels."
msgstr "Rust 完全支持使用带有互斥锁和通道的操作系统线程进行并发。"

#: src/concurrency.md
msgid ""
"The Rust type system plays an important role in making many concurrency bugs "
"compile time bugs. This is often referred to as _fearless concurrency_ since "
"you can rely on the compiler to ensure correctness at runtime."
msgstr ""
"Rust 类型系统能帮助我们把许多并发bug转换为编译期bug 发挥着重要作用。这通常称"
"为“无畏并发”，因为你可以依靠编译器来确保 运行时的正确性。"

#: src/concurrency/threads.md
msgid "Rust threads work similarly to threads in other languages:"
msgstr "Rust 线程的运作方式与其他语言中的线程类似："

#: src/concurrency/threads.md
msgid "\"Count in thread: {i}!\""
msgstr "\"Count in thread: {i}!\""

#: src/concurrency/threads.md
msgid "\"Main thread: {i}\""
msgstr "\"Main thread: {i}\""

#: src/concurrency/threads.md
msgid "Threads are all daemon threads, the main thread does not wait for them."
msgstr "线程均为守护程序线程，主线程不会等待这些线程。"

#: src/concurrency/threads.md
msgid "Thread panics are independent of each other."
msgstr "线程紧急警报 (panic) 是彼此独立的。"

#: src/concurrency/threads.md
msgid "Panics can carry a payload, which can be unpacked with `downcast_ref`."
msgstr "紧急警报可以携带载荷，并可以使用 `downcast_ref` 对载荷进行解压缩。"

#: src/concurrency/threads.md
#, fuzzy
msgid ""
"Notice that the thread is stopped before it reaches 10 --- the main thread "
"is not waiting."
msgstr "请注意，线程在达到 10 之前就停止了，而主线程并 没有等待。"

#: src/concurrency/threads.md
msgid ""
"Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for "
"the thread to finish."
msgstr ""
"使用 `let handle = thread::spawn(...)` 和后面的 `handle.join()` 等待 线程完"
"成。"

#: src/concurrency/threads.md
msgid "Trigger a panic in the thread, notice how this doesn't affect `main`."
msgstr "在线程中触发紧急警报，并注意这为何不会影响到 `main`。"

#: src/concurrency/threads.md
msgid ""
"Use the `Result` return value from `handle.join()` to get access to the "
"panic payload. This is a good time to talk about [`Any`](https://doc.rust-"
"lang.org/std/any/index.html)."
msgstr ""
"使用 `handle.join()` 的 `Result` 返回值来获取对紧急警报 载荷的访问权限。现在"
"有必要介绍一下 [`Any`](https://doc.rust-lang.org/std/any/index.html) 了。"

#: src/concurrency/scoped-threads.md
msgid "Normal threads cannot borrow from their environment:"
msgstr "常规线程不能从它们所处的环境中借用："

#: src/concurrency/scoped-threads.md
msgid ""
"However, you can use a [scoped thread](https://doc.rust-lang.org/std/thread/"
"fn.scope.html) for this:"
msgstr ""
"不过，你可以使用[范围线程](https://doc.rust-lang.org/std/thread/fn.scope."
"html)来实现此目的："

#: src/concurrency/scoped-threads.md
msgid ""
"The reason for that is that when the `thread::scope` function completes, all "
"the threads are guaranteed to be joined, so they can return borrowed data."
msgstr ""
"其原因在于，在 `thread::scope` 函数完成后，可保证所有线程都已联结在一起，使得"
"线程能够返回借用的数据。"

#: src/concurrency/scoped-threads.md
msgid ""
"Normal Rust borrowing rules apply: you can either borrow mutably by one "
"thread, or immutably by any number of threads."
msgstr ""
"此时须遵守常规 Rust 借用规则：你可以通过一个线程以可变的方式借用，也可以通过"
"任意数量的线程以不可变的方式借用。"

#: src/concurrency/channels.md
msgid ""
"Rust channels have two parts: a `Sender<T>` and a `Receiver<T>`. The two "
"parts are connected via the channel, but you only see the end-points."
msgstr ""
"Rust 通道（Channel）包含两个部分：`Sender<T>` 和 `Receiver<T>`。这两个部分 通"
"过通道进行连接，但你只能看到端点。"

#: src/concurrency/channels.md
msgid "\"Received: {:?}\""
msgstr "\"Received: {:?}\""

#: src/concurrency/channels.md
msgid ""
"`mpsc` stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender` "
"implement `Clone` (so you can make multiple producers) but `Receiver` does "
"not."
msgstr ""
"`mpsc` 代表多个生产方，单个使用方。`Sender` 和 `SyncSender` 会实现 `Clone`"
"（因此， 你可以设置多个生产方），但 `Receiver` 不会实现。"

#: src/concurrency/channels.md
msgid ""
"`send()` and `recv()` return `Result`. If they return `Err`, it means the "
"counterpart `Sender` or `Receiver` is dropped and the channel is closed."
msgstr ""
"`send()` 和 `recv()` 会返回 `Result`。如果它们返回 `Err`，则表示对应的 "
"`Sender` 或 `Receiver` 已被丢弃，且通道已关闭。"

#: src/concurrency/channels/unbounded.md
msgid "You get an unbounded and asynchronous channel with `mpsc::channel()`:"
msgstr "你可以使用 `mpsc::channel()` 获得无边界的异步通道："

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"Message {i}\""
msgstr "\"Message {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"{thread_id:?}: sent Message {i}\""
msgstr "\"{thread_id:?}: sent Message {i}\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"{thread_id:?}: done\""
msgstr "\"{thread_id:?}: done\""

#: src/concurrency/channels/unbounded.md src/concurrency/channels/bounded.md
msgid "\"Main: got {msg}\""
msgstr "\"Main: got {msg}\""

#: src/concurrency/channels/bounded.md
#, fuzzy
msgid ""
"With bounded (synchronous) channels, `send` can block the current thread:"
msgstr "有边界的同步通道会使 `send` 阻塞当前线程："

#: src/concurrency/channels/bounded.md
msgid ""
"Calling `send` will block the current thread until there is space in the "
"channel for the new message. The thread can be blocked indefinitely if there "
"is nobody who reads from the channel."
msgstr ""
"调用 `send` 将阻塞当前线程，直到通道中有足够的空间放置新消息。如果无人从通道"
"读取数据，线程会被无限期地阻塞。"

#: src/concurrency/channels/bounded.md
msgid ""
"A call to `send` will abort with an error (that is why it returns `Result`) "
"if the channel is closed. A channel is closed when the receiver is dropped."
msgstr ""
"如果通道关闭，调用 `send` 将中止并返回错误（这就是它会返回 `Result` 的原"
"因）。当接收器被丢弃时，通道将关闭。"

#: src/concurrency/channels/bounded.md
msgid ""
"A bounded channel with a size of zero is called a \"rendezvous channel\". "
"Every send will block the current thread until another thread calls `read`."
msgstr ""
"大小为零的有界通道称为 “集合通道”。每次调用 send 都会阻塞当前线程，直到另一个"
"线程调用 `read`。"

#: src/concurrency/send-sync.md
#, fuzzy
msgid ""
"How does Rust know to forbid shared access across threads? The answer is in "
"two traits:"
msgstr "Rust 如何知道要禁止跨线程共享访问？答案在于 Rust 的两个特征："

#: src/concurrency/send-sync.md
msgid ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html): a type `T` "
"is `Send` if it is safe to move a `T` across a thread boundary."
msgstr ""
"[`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html)：如果跨线程边"
"界移动 `T` 是安全的，则类型 `T` 为 `Send`。"

#: src/concurrency/send-sync.md
msgid ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html): a type `T` "
"is `Sync` if it is safe to move a `&T` across a thread boundary."
msgstr ""
"[`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html)：如果跨线程边"
"界移动 `&T` 是安全的，则类型 `T` 为 `Sync`。"

#: src/concurrency/send-sync.md
msgid ""
"`Send` and `Sync` are [unsafe traits](../unsafe/unsafe-traits.md). The "
"compiler will automatically derive them for your types as long as they only "
"contain `Send` and `Sync` types. You can also implement them manually when "
"you know it is valid."
msgstr ""
"`Send` 和 `Sync` 均为[不安全特征](../unsafe/unsafe-traits.md)。只要类型仅包"
"含 `Send` 和 `Sync` 类型，编译器就会自动为类型派生 这两种特征。你也可以手动实"
"现它们（如果你确定这样 有效的话）。"

#: src/concurrency/send-sync.md
msgid ""
"One can think of these traits as markers that the type has certain thread-"
"safety properties."
msgstr "不妨将这些特征视为类型包含某些线程安全属性的标记。"

#: src/concurrency/send-sync.md
msgid "They can be used in the generic constraints as normal traits."
msgstr "它们可以在泛型约束中作为常规特征使用。"

#: src/concurrency/send-sync/send.md
msgid ""
"A type `T` is [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) "
"if it is safe to move a `T` value to another thread."
msgstr ""
"如果将 `T` 值移动到另一个线程是安全的，则类型 `T` 为 [`Send`](https://doc."
"rust-lang.org/std/marker/trait.Send.html)。"

#: src/concurrency/send-sync/send.md
msgid ""
"The effect of moving ownership to another thread is that _destructors_ will "
"run in that thread. So the question is when you can allocate a value in one "
"thread and deallocate it in another."
msgstr ""
"将所有权转移到另一个线程的影响是，“析构函数”将在相应线程中 运行。因此，问题在"
"于你何时可以在一个线程中分配某个值，然后在 另一个线程中取消分配该值。"

#: src/concurrency/send-sync/send.md
msgid ""
"As an example, a connection to the SQLite library must only be accessed from "
"a single thread."
msgstr "例如，与 SQLite 库的连接只能通过 单个线程访问。"

#: src/concurrency/send-sync/sync.md
msgid ""
"A type `T` is [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) "
"if it is safe to access a `T` value from multiple threads at the same time."
msgstr ""
"如果同时从多个线程访问 `T` 值是安全的，则类型 `T` 为 [`Sync`](https://doc."
"rust-lang.org/std/marker/trait.Sync.html)。"

#: src/concurrency/send-sync/sync.md
msgid "More precisely, the definition is:"
msgstr "更准确地说，定义是："

#: src/concurrency/send-sync/sync.md
msgid "`T` is `Sync` if and only if `&T` is `Send`"
msgstr "当且仅当 `&T` 为 `Send` 时，`T` 为 `Sync`"

#: src/concurrency/send-sync/sync.md
msgid ""
"This statement is essentially a shorthand way of saying that if a type is "
"thread-safe for shared use, it is also thread-safe to pass references of it "
"across threads."
msgstr ""
"该语句实质上是一种简写形式，表示如果某个类型对于共享使用是线程安全的，那么跨"
"线程传递对该类型的引用也是线程安全的。"

#: src/concurrency/send-sync/sync.md
msgid ""
"This is because if a type is Sync it means that it can be shared across "
"multiple threads without the risk of data races or other synchronization "
"issues, so it is safe to move it to another thread. A reference to the type "
"is also safe to move to another thread, because the data it references can "
"be accessed from any thread safely."
msgstr ""
"这是因为如果某个类型为 Sync，则意味着它可以在多个线程之间共享，而不存在数据争"
"用或其他同步问题的风险，因此将其移动到另一个线程是安全的。对该类型的引用同样"
"可以安全地移动到另一个线程，因为它引用的数据可以从任何线程安全地访问。"

#: src/concurrency/send-sync/examples.md
msgid "`Send + Sync`"
msgstr "`Send + Sync`"

#: src/concurrency/send-sync/examples.md
msgid "Most types you come across are `Send + Sync`:"
msgstr "你遇到的类型大都属于 `Send + Sync`："

#: src/concurrency/send-sync/examples.md
msgid "`i8`, `f32`, `bool`, `char`, `&str`, ..."
msgstr "`i8`、`f32`、`bool`、`char`、`&str`…"

#: src/concurrency/send-sync/examples.md
msgid "`(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ..."
msgstr "`(T1, T2)`、`[T; N]`、`&[T]`、`struct { x: T }`…"

#: src/concurrency/send-sync/examples.md
msgid "`String`, `Option<T>`, `Vec<T>`, `Box<T>`, ..."
msgstr "`String`、`Option<T>`、`Vec<T>`、`Box<T>`…"

#: src/concurrency/send-sync/examples.md
msgid "`Arc<T>`: Explicitly thread-safe via atomic reference count."
msgstr "`Arc<T>`：明确通过原子引用计数实现线程安全。"

#: src/concurrency/send-sync/examples.md
msgid "`Mutex<T>`: Explicitly thread-safe via internal locking."
msgstr "`Mutex<T>`：明确通过内部锁定实现线程安全。"

#: src/concurrency/send-sync/examples.md
msgid "`AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions."
msgstr "`AtomicBool`、`AtomicU8`…：使用特殊的原子指令。"

#: src/concurrency/send-sync/examples.md
msgid ""
"The generic types are typically `Send + Sync` when the type parameters are "
"`Send + Sync`."
msgstr "当类型参数为 `Send + Sync` 时，泛型类型通常 为 `Send + Sync`。"

#: src/concurrency/send-sync/examples.md
msgid "`Send + !Sync`"
msgstr "`Send + !Sync`"

#: src/concurrency/send-sync/examples.md
msgid ""
"These types can be moved to other threads, but they're not thread-safe. "
"Typically because of interior mutability:"
msgstr ""
"这些类型可以移动到其他线程，但它们不是线程安全的。 这通常是由内部可变性造成"
"的："

#: src/concurrency/send-sync/examples.md
msgid "`mpsc::Sender<T>`"
msgstr "`mpsc::Sender<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`mpsc::Receiver<T>`"
msgstr "`mpsc::Receiver<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`Cell<T>`"
msgstr "`Cell<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`RefCell<T>`"
msgstr "`RefCell<T>`"

#: src/concurrency/send-sync/examples.md
msgid "`!Send + Sync`"
msgstr "`!Send + Sync`"

#: src/concurrency/send-sync/examples.md
msgid ""
"These types are thread-safe, but they cannot be moved to another thread:"
msgstr "这些类型是线程安全的，但它们不能移动到另一个线程："

#: src/concurrency/send-sync/examples.md
#, fuzzy
msgid ""
"`MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on "
"the thread which created them."
msgstr ""
"`MutexGuard<T>`：使用操作系统级别的原语（必须在创建这些原语的线程上 取消分"
"配）。"

#: src/concurrency/send-sync/examples.md
msgid "`!Send + !Sync`"
msgstr "`!Send + !Sync`"

#: src/concurrency/send-sync/examples.md
msgid "These types are not thread-safe and cannot be moved to other threads:"
msgstr "这些类型不是线程安全的，不能移动到其他线程："

#: src/concurrency/send-sync/examples.md
msgid ""
"`Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a non-"
"atomic reference count."
msgstr ""
"`Rc<T>`：每个 `Rc<T>` 都具有对 `RcBox<T>` 的引用，其中包含 非原子引用计数。"

#: src/concurrency/send-sync/examples.md
msgid ""
"`*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency "
"considerations."
msgstr ""
"`*const T`、`*mut T`：Rust 会假定原始指针可能 在并发方面有特殊的注意事项。"

#: src/concurrency/shared_state.md
msgid ""
"Rust uses the type system to enforce synchronization of shared data. This is "
"primarily done via two types:"
msgstr "Rust 使用类型系统来强制同步共享数据。这主要 通过两种类型实现："

#: src/concurrency/shared_state.md
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html), atomic "
"reference counted `T`: handles sharing between threads and takes care to "
"deallocate `T` when the last reference is dropped,"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html)，对 `T` 进行原"
"子计数：用于处理线程之间的共享，并负责 在最后一个引用被丢弃时取消分配 `T`。"

#: src/concurrency/shared_state.md
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html): ensures "
"mutually exclusive access to the `T` value."
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)：确保对 "
"`T` 值的互斥访问。"

#: src/concurrency/shared_state/arc.md
msgid ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) allows shared "
"read-only access via `Arc::clone`:"
msgstr ""
"[`Arc<T>`](https://doc.rust-lang.org/std/sync/struct.Arc.html) 允许通过 "
"`Arc::clone` 实现共享只读权限："

#: src/concurrency/shared_state/arc.md
msgid "\"{thread_id:?}: {v:?}\""
msgstr "\"{thread_id:?}: {v:?}\""

#: src/concurrency/shared_state/arc.md src/concurrency/shared_state/example.md
msgid "\"v: {v:?}\""
msgstr "\"v: {v:?}\""

#: src/concurrency/shared_state/arc.md
msgid ""
"`Arc` stands for \"Atomic Reference Counted\", a thread safe version of `Rc` "
"that uses atomic operations."
msgstr "`Arc` 代表“原子引用计数”，它是使用原子操作的 `Rc` 的 线程安全版本。"

#: src/concurrency/shared_state/arc.md
#, fuzzy
msgid ""
"`Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` "
"and `Sync` if and only if `T` implements them both."
msgstr ""
"无论 `T` 是否实现 `Clone`，`Arc<T>` 都会实现 `Clone`。如果 `T` 实现了 `Send` "
"和 `Sync`，`Arc<T>` 便会 实现二者。"

#: src/concurrency/shared_state/arc.md
msgid ""
"`Arc::clone()` has the cost of atomic operations that get executed, but "
"after that the use of the `T` is free."
msgstr ""
"`Arc::clone()` 在执行原子操作方面有开销，但在此之后，`T` 便可 随意使用，而没"
"有任何开销。"

#: src/concurrency/shared_state/arc.md
msgid ""
"Beware of reference cycles, `Arc` does not use a garbage collector to detect "
"them."
msgstr "请警惕引用循环，`Arc` 不会使用垃圾回收器检测引用循环。"

#: src/concurrency/shared_state/arc.md
msgid "`std::sync::Weak` can help."
msgstr "`std::sync::Weak` 对此有所帮助。"

#: src/concurrency/shared_state/mutex.md
#, fuzzy
msgid ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) ensures "
"mutual exclusion _and_ allows mutable access to `T` behind a read-only "
"interface (another form of [interior mutability](../../borrowing/interior-"
"mutability)):"
msgstr ""
"[`Mutex<T>`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) 能够确保互"
"斥，并允许对只读接口 后面的 `T` 进行可变访问："

#: src/concurrency/shared_state/mutex.md
msgid "\"v: {:?}\""
msgstr "\"v: {:?}\""

#: src/concurrency/shared_state/mutex.md
msgid ""
"Notice how we have a [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-"
"lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) blanket "
"implementation."
msgstr ""
"请注意我们如何设置 [`impl<T: Send> Sync for Mutex<T>`](https://doc.rust-lang."
"org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E) 通用 实现。"

#: src/concurrency/shared_state/mutex.md
#, fuzzy
msgid ""
"`Mutex` in Rust looks like a collection with just one element --- the "
"protected data."
msgstr ""
"Rust 中的互斥器看起来就像只包含一个元素的集合，其中的元素就是受保护的数据。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"It is not possible to forget to acquire the mutex before accessing the "
"protected data."
msgstr "在访问受保护的数据之前不可能忘记获取互斥量。"

#: src/concurrency/shared_state/mutex.md
msgid ""
"You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The "
"`MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held."
msgstr ""
"你可以通过获取锁，从 `&Mutex<T>` 中获取 `&mut T`。`MutexGuard` 能够确保 "
"`&mut T` 存在的时间不会比持有锁的时间更长。"

#: src/concurrency/shared_state/mutex.md
#, fuzzy
msgid ""
"`Mutex<T>` implements both `Send` and `Sync` iff (if and only if) `T` "
"implements `Send`."
msgstr "如果 `T` 实现了 `Send`，`Mutex<T>` 便会实现 `Send` 和 `Sync`。"

#: src/concurrency/shared_state/mutex.md
#, fuzzy
msgid "A read-write lock counterpart: `RwLock`."
msgstr "读写锁版本 - `RwLock`。"

#: src/concurrency/shared_state/mutex.md
#, fuzzy
msgid "Why does `lock()` return a `Result`?"
msgstr "为什么 `lock()` 会返回 `Result`？"

#: src/concurrency/shared_state/mutex.md
msgid ""
"If the thread that held the `Mutex` panicked, the `Mutex` becomes "
"\"poisoned\" to signal that the data it protected might be in an "
"inconsistent state. Calling `lock()` on a poisoned mutex fails with a "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html). "
"You can call `into_inner()` on the error to recover the data regardless."
msgstr ""
"如果持有 `Mutex` 的线程发生panic，`Mutex` 便会“中毒”并发出信号， 表明其所保护"
"的数据可能处于不一致状态。对中毒的互斥量调用 `lock()` 将会失败， 并将显示 "
"[`PoisonError`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html)。"
"无论如何，你可以对该错误调用 `into_inner()` 来 恢复数据。"

#: src/concurrency/shared_state/example.md
msgid "Let us see `Arc` and `Mutex` in action:"
msgstr "让我们看看 `Arc` 和 `Mutex` 的实际效果："

#: src/concurrency/shared_state/example.md
msgid "// use std::sync::{Arc, Mutex};\n"
msgstr "// use std::sync::{Arc, Mutex};\n"

#: src/concurrency/shared_state/example.md
msgid "Possible solution:"
msgstr "可能有用的解决方案："

#: src/concurrency/shared_state/example.md
msgid "Notable parts:"
msgstr "值得注意的部分："

#: src/concurrency/shared_state/example.md
msgid ""
"`v` is wrapped in both `Arc` and `Mutex`, because their concerns are "
"orthogonal."
msgstr "`Arc` 和 `Mutex` 中都封装了 `v`，因为它们的关注点是正交的。"

#: src/concurrency/shared_state/example.md
msgid ""
"Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state "
"between threads."
msgstr "将 `Mutex` 封装在 `Arc` 中是一种在线程之间共享可变状态的常见模式。"

#: src/concurrency/shared_state/example.md
msgid ""
"`v: Arc<_>` needs to be cloned as `v2` before it can be moved into another "
"thread. Note `move` was added to the lambda signature."
msgstr ""
"`v: Arc<_>` 必须先克隆为 `v2`，然后才能移动到另一个线程中。请注意，lambda 签"
"名中添加了 `move`。"

#: src/concurrency/shared_state/example.md
msgid ""
"Blocks are introduced to narrow the scope of the `LockGuard` as much as "
"possible."
msgstr "我们引入了块，以尽可能缩小 `LockGuard` 的作用域。"

#: src/exercises/concurrency/morning.md
msgid "Let us practice our new concurrency skills with"
msgstr "现在通过"

#: src/exercises/concurrency/morning.md
msgid "Dining philosophers: a classic problem in concurrency."
msgstr "哲学家用餐示例来练习我们新学习到的并发技巧：该示例是典型的并发问题。"

#: src/exercises/concurrency/morning.md
msgid ""
"Multi-threaded link checker: a larger project where you'll use Cargo to "
"download dependencies and then check links in parallel."
msgstr ""
"多线程链接检查器：对于大型项目，需要使用 Cargo 下载依赖项，然后并行检查链接。"

#: src/exercises/concurrency/dining-philosophers.md
msgid "The dining philosophers problem is a classic problem in concurrency:"
msgstr "哲学家用餐示例是一个典型的并发问题："

#: src/exercises/concurrency/dining-philosophers.md
msgid ""
"Five philosophers dine together at the same table. Each philosopher has "
"their own place at the table. There is a fork between each plate. The dish "
"served is a kind of spaghetti which has to be eaten with two forks. Each "
"philosopher can only alternately think and eat. Moreover, a philosopher can "
"only eat their spaghetti when they have both a left and right fork. Thus two "
"forks will only be available when their two nearest neighbors are thinking, "
"not eating. After an individual philosopher finishes eating, they will put "
"down both forks."
msgstr ""
"五位哲学家在同一桌子上用餐。每位哲学家在桌前都有自己的座位。每个盘子之间都有"
"一把叉子。上的菜品是一种意大利面，需要用两把叉子才能吃。每位哲学家只能交替进"
"行思考和用餐。此外，只有当哲学家们同时拿到左边和右边的叉子才能吃这个意大利"
"面。因此，只有当两旁坐着的人在思考，而非在吃面时，他们才能使用两把叉子。每位"
"哲学家吃完饭后，就会放下手中的两把叉子。"

#: src/exercises/concurrency/dining-philosophers.md
msgid ""
"You will need a local [Cargo installation](../../cargo/running-locally.md) "
"for this exercise. Copy the code below to a file called `src/main.rs`, fill "
"out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"在本练习中，需要使用本地 [Cargo 安装](../../cargo/running-locally.md)。将以下"
"代码复制到名为 `src/main.rs` 的文件中，并填写空白的地方，然后测试 `cargo "
"run` 不会死锁："

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"
msgstr ""
"// left_fork: ...\n"
"    // right_fork: ...\n"
"    // thoughts: ...\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Eureka! {} has a new idea!\""
msgstr "\"Eureka! {} has a new idea!\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Pick up forks...\n"
msgstr "// Pick up forks...\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"{} is eating...\""
msgstr "\"{} is eating...\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
#, fuzzy
msgid "\"Socrates\""
msgstr "\"Socrates\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Hypatia\""
msgstr "\"Hypatia\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Plato\""
msgstr "\"Plato\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Aristotle\""
msgstr "\"Aristotle\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/solutions-morning.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Pythagoras\""
msgstr "\"Pythagoras\""

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Create forks\n"
msgstr "// Create forks\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Create philosophers\n"
msgstr "// Create philosophers\n"

#: src/exercises/concurrency/dining-philosophers.md
msgid "// Make each of them think and eat 100 times\n"
msgstr "// Make each of them think and eat 100 times\n"

#: src/exercises/concurrency/dining-philosophers.md
#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Output their thoughts\n"
msgstr "// Output their thoughts\n"

#: src/exercises/concurrency/dining-philosophers.md
msgid "You can use the following `Cargo.toml`:"
msgstr "您可以使用以下 `Cargo.toml`："

#: src/exercises/concurrency/dining-philosophers.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"```"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Let us use our new knowledge to create a multi-threaded link checker. It "
"should start at a webpage and check that links on the page are valid. It "
"should recursively check other pages on the same domain and keep doing this "
"until all pages have been validated."
msgstr ""
"运用掌握的新知识创建一个多线程链接检查工具。应先从网页入手，并检查网页上的链"
"接是否有效。该工具应以递归方式检查同一网域中的其他网页，并且一直执行此操作，"
"直到所有网页都通过验证。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"For this, you will need an HTTP client such as [`reqwest`](https://docs.rs/"
"reqwest/). Create a new Cargo project and `reqwest` it as a dependency with:"
msgstr ""
"为此，需要创建一个 HTTP 客户端，例如 [`reqwest`](https://docs.rs/reqwest/)。"
"创建新的 Cargo 项目，并使用以下命令通过 `reqwest` 将其作为依赖项："

#: src/exercises/concurrency/link-checker.md
msgid ""
"If `cargo add` fails with `error: no such subcommand`, then please edit the "
"`Cargo.toml` file by hand. Add the dependencies listed below."
msgstr ""
"如果 `cargo add` 操作失败并显示 `error: no such subcommand`，请手动修改 "
"`Cargo.toml` 文件。添加下面列出的依赖项。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"You will also need a way to find links. We can use [`scraper`](https://docs."
"rs/scraper/) for that:"
msgstr ""
"您还需要一种查找链接的方法。为此，我们可以使用 [`scraper`](https://docs.rs/"
"scraper/)："

#: src/exercises/concurrency/link-checker.md
msgid ""
"Finally, we'll need some way of handling errors. We use [`thiserror`]"
"(https://docs.rs/thiserror/) for that:"
msgstr ""
"最后，我们需要某种处理错误的方法。为此，可以使用 [`thiserror`](https://docs."
"rs/thiserror/)："

#: src/exercises/concurrency/link-checker.md
msgid ""
"The `cargo add` calls will update the `Cargo.toml` file to look like this:"
msgstr "`cargo add` 调用会将 `Cargo.toml` 文件更新为如下所示："

#: src/exercises/concurrency/link-checker.md
msgid ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"link-checker\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"publish = false\n"
"\n"
"[dependencies]\n"
"reqwest = { version = \"0.11.12\", features = [\"blocking\", \"rustls-"
"tls\"] }\n"
"scraper = \"0.13.0\"\n"
"thiserror = \"1.0.37\"\n"
"```"

#: src/exercises/concurrency/link-checker.md
msgid ""
"You can now download the start page. Try with a small site such as `https://"
"www.google.org/`."
msgstr ""
"您现在可以下载初始页了。请尝试使用一个小网站，例如 `https://www.google.org/"
"`。"

#: src/exercises/concurrency/link-checker.md
msgid "Your `src/main.rs` file should look something like this:"
msgstr "您的 `src/main.rs` 文件应如下所示："

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"request error: {0}\""
msgstr "\"request error: {0}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"bad http response: {0}\""
msgstr "\"bad http response: {0}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"Checking {:#}\""
msgstr "\"Checking {:#}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"href\""
msgstr "\"href\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""
msgstr "\"On {base_url:#}: ignored unparsable {href:?}: {err}\""

#: src/exercises/concurrency/link-checker.md
#: src/exercises/concurrency/solutions-morning.md
msgid "\"https://www.google.org\""
msgstr "\"https://www.google.org\""

#: src/exercises/concurrency/link-checker.md
msgid "\"Links: {links:#?}\""
msgstr "\"Links: {links:#?}\""

#: src/exercises/concurrency/link-checker.md
msgid "\"Could not extract links: {err:#}\""
msgstr "\"Could not extract links: {err:#}\""

#: src/exercises/concurrency/link-checker.md
msgid "Run the code in `src/main.rs` with"
msgstr "使用以下命令运行 `src/main.rs` 中的代码"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Use threads to check the links in parallel: send the URLs to be checked to a "
"channel and let a few threads check the URLs in parallel."
msgstr ""
"通过线程并行检查链接：将要检查的网址发送到某个通道，然后使用多个线程并行检查"
"这些网址。"

#: src/exercises/concurrency/link-checker.md
msgid ""
"Extend this to recursively extract links from all pages on the `www.google."
"org` domain. Put an upper limit of 100 pages or so so that you don't end up "
"being blocked by the site."
msgstr ""
"您可以对此进行扩展，以递归方式从 `www.google.org` 网域的所有网页中提取链接。"
"设置网页上限（例如 100 个），以免被网站屏蔽。"

#: src/exercises/concurrency/solutions-morning.md
msgid "Concurrency Morning Exercise"
msgstr "并发编程：上午练习"

#: src/exercises/concurrency/solutions-morning.md
msgid "([back to exercise](dining-philosophers.md))"
msgstr "([返回练习](dining-philosophers.md))"

#: src/exercises/concurrency/solutions-morning.md
msgid "\"{} is trying to eat\""
msgstr "\"{} is trying to eat\""

#: src/exercises/concurrency/solutions-morning.md
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"
msgstr ""
"// To avoid a deadlock, we have to break the symmetry\n"
"        // somewhere. This will swap the forks without deinitializing\n"
"        // either of them.\n"

#: src/exercises/concurrency/solutions-morning.md
msgid "\"{thought}\""
msgstr "\"{thought}\""

#: src/exercises/concurrency/solutions-morning.md
#, fuzzy
msgid "Link Checker"
msgstr "多线程链接检查器"

#: src/exercises/concurrency/solutions-morning.md
#, fuzzy
msgid "([back to exercise](link-checker.md))"
msgstr "([返回练习](luhn.md))"

#: src/exercises/concurrency/solutions-morning.md
msgid ""
"/// Determine whether links within the given page should be extracted.\n"
msgstr ""
"/// Determine whether links within the given page should be extracted.\n"

#: src/exercises/concurrency/solutions-morning.md
msgid ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"
msgstr ""
"/// Mark the given page as visited, returning false if it had already\n"
"    /// been visited.\n"

#: src/exercises/concurrency/solutions-morning.md
msgid "// The sender got dropped. No more commands coming in.\n"
msgstr "// The sender got dropped. No more commands coming in.\n"

#: src/exercises/concurrency/solutions-morning.md
msgid "\"Got crawling error: {:#}\""
msgstr "\"Got crawling error: {:#}\""

#: src/exercises/concurrency/solutions-morning.md
msgid "\"Bad URLs: {:#?}\""
msgstr "\"Bad URLs: {:#?}\""

#: src/async.md
msgid "Async Rust"
msgstr "异步 Rust"

#: src/async.md
msgid ""
"\"Async\" is a concurrency model where multiple tasks are executed "
"concurrently by executing each task until it would block, then switching to "
"another task that is ready to make progress. The model allows running a "
"larger number of tasks on a limited number of threads. This is because the "
"per-task overhead is typically very low and operating systems provide "
"primitives for efficiently identifying I/O that is able to proceed."
msgstr ""
"“异步”是一种并发模型，可以同时执行多个任务。具体做法是逐个执行任务直至阻塞，"
"然后切换到另一项可以继续进行的任务。该模型支持在有限数量的线程上运行更多任"
"务。原因在于，每个任务的开销通常很低，并且操作系统提供了基元来高效识别能够执"
"行的 I/O 任务。"

#: src/async.md
msgid ""
"Rust's asynchronous operation is based on \"futures\", which represent work "
"that may be completed in the future. Futures are \"polled\" until they "
"signal that they are complete."
msgstr ""
"Rust 的异步操作基于 \"Futures\" 来实现，即表示未来可能完成的工作。系统会对这"
"些 Future 进行 “轮询”，直到显示全部已完成。"

#: src/async.md
msgid ""
"Futures are polled by an async runtime, and several different runtimes are "
"available."
msgstr "由异步运行时对这些 Future 进行轮询，并且有多种不同的运行时可供选择。"

#: src/async.md
msgid ""
"Python has a similar model in its `asyncio`. However, its `Future` type is "
"callback-based, and not polled. Async Python programs require a \"loop\", "
"similar to a runtime in Rust."
msgstr ""
"Python 的 `asyncio` 中也有类似的模型。不过，其 `Future` 类型基于回调的实现方"
"式，而非通过轮询。使用异步 Python 程序需要类似于 Rust 中运行时的 “循环” 进行"
"管理。"

#: src/async.md
msgid ""
"JavaScript's `Promise` is similar, but again callback-based. The language "
"runtime implements the event loop, so many of the details of Promise "
"resolution are hidden."
msgstr ""
"JavaScript 的 `Promise` 与之类似，但同样基于回调的实现方式。语言运行时实现了"
"事件循环，因此许多与 Promise 解析相关的细节被隐藏起来。"

#: src/async/async-await.md
msgid ""
"At a high level, async Rust code looks very much like \"normal\" sequential "
"code:"
msgstr "从高层次上看，异步 Rust 代码与“正常”的顺序代码非常类似："

#: src/async/async-await.md
msgid "\"Count is: {i}!\""
msgstr "\"Count is: {i}!\""

#: src/async/async-await.md
msgid ""
"Note that this is a simplified example to show the syntax. There is no long "
"running operation or any real concurrency in it!"
msgstr ""
"请注意，这只是一个简单的示例，用于展示语法。其中没有长时间运行的操作或任何真"
"正的并发！"

#: src/async/async-await.md
msgid "What is the return type of an async call?"
msgstr "异步调用的返回类型是什么？"

#: src/async/async-await.md
msgid "Use `let future: () = async_main(10);` in `main` to see the type."
msgstr "在 `main` 中使用 `let future: () = async_main(10);` 来查看类型。"

#: src/async/async-await.md
#, fuzzy
msgid ""
"The \"async\" keyword is syntactic sugar. The compiler replaces the return "
"type with a future."
msgstr "\"async\" 关键字是语法糖。编译器会将返回类型替换为 future。"

#: src/async/async-await.md
msgid ""
"You cannot make `main` async, without additional instructions to the "
"compiler on how to use the returned future."
msgstr ""
"你不能将 `main` 声明为异步函数，除非在编译器中加入额外的指令来告诉它如何使用"
"返回的 future。"

#: src/async/async-await.md
#, fuzzy
msgid ""
"You need an executor to run async code. `block_on` blocks the current thread "
"until the provided future has run to completion."
msgstr ""
"你需要一个执行器来运行异步代码。`block_on`会阻塞当前线程，直到提供的future完"
"成为止。 "

#: src/async/async-await.md
msgid ""
"`.await` asynchronously waits for the completion of another operation. "
"Unlike `block_on`, `.await` doesn't block the current thread."
msgstr ""
"`.await` 会异步地等待另一个操作的完成。与 `block_on` 不同，`.await` 不会阻塞"
"当前线程。"

#: src/async/async-await.md
#, fuzzy
msgid ""
"`.await` can only be used inside an `async` function (or block; these are "
"introduced later)."
msgstr "`.await` 只能在 `async` 函数（或块，这些稍后会介绍）中使用。 "

#: src/async/futures.md
msgid ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a "
"trait, implemented by objects that represent an operation that may not be "
"complete yet. A future can be polled, and `poll` returns a [`Poll`](https://"
"doc.rust-lang.org/std/task/enum.Poll.html)."
msgstr ""
"[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) 是一种 "
"trait，由表示尚未完成的操作的对象所实现。可以轮询 Future，并且 `poll` 会返回 "
"一个 [`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html) 对象。"

#: src/async/futures.md
msgid ""
"An async function returns an `impl Future`. It's also possible (but "
"uncommon) to implement `Future` for your own types. For example, the "
"`JoinHandle` returned from `tokio::spawn` implements `Future` to allow "
"joining to it."
msgstr ""
"异步函数会返回 `impl Future`。对于自定义的类型，也可以实现 `Future`（但不常"
"见）。例如，从 `tokio::spawn` 返回的 `JoinHandle` 会实现 `Future`，以允许加入"
"该任务。"

#: src/async/futures.md
msgid ""
"The `.await` keyword, applied to a Future, causes the current async function "
"to pause until that Future is ready, and then evaluates to its output."
msgstr ""
"在 Future 中使用 `.await` 关键字会导致当前异步函数暂停，直到该 Future 准备就"
"绪，然后计算其输出。"

#: src/async/futures.md
msgid ""
"The `Future` and `Poll` types are implemented exactly as shown; click the "
"links to show the implementations in the docs."
msgstr ""
"`Future` 和 `Poll` 类型的实现完全如下所示：请点击链接查看文档中的实现。"

#: src/async/futures.md
msgid ""
"We will not get to `Pin` and `Context`, as we will focus on writing async "
"code, rather than building new async primitives. Briefly:"
msgstr ""
"我们的重点在于编写异步代码，而不是构建新的异步基元，因此不会涉及 `Pin` 和 "
"`Context`。简言之："

#: src/async/futures.md
msgid ""
"`Context` allows a Future to schedule itself to be polled again when an "
"event occurs."
msgstr "通过 `Context`，Future 在事件发生时可自行安排重新进行轮询。"

#: src/async/futures.md
msgid ""
"`Pin` ensures that the Future isn't moved in memory, so that pointers into "
"that future remain valid. This is required to allow references to remain "
"valid after an `.await`."
msgstr ""
"`Pin` 确保 Future 不会移到内存中，以便指向该 Future 的指针仍然有效。为了确保"
"使用 `.await` 之后引用依然有效，必须执行此操作。"

#: src/async/runtimes.md
msgid ""
"A _runtime_ provides support for performing operations asynchronously (a "
"_reactor_) and is responsible for executing futures (an _executor_). Rust "
"does not have a \"built-in\" runtime, but several options are available:"
msgstr ""
"_运行时_ 支持异步执行操作（即 _反应器），并负责执行 Future （即 _执行器）。"
"Rust 没有 “内置”运行时，但有以下几个选项可供选择："

#: src/async/runtimes.md
msgid ""
"[Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of "
"functionality like [Hyper](https://hyper.rs/) for HTTP or [Tonic](https://"
"github.com/hyperium/tonic) for gRPC."
msgstr ""
"[Tokio](https://tokio.rs/)：性能出色，拥有成熟的功能生态系统，例如适用于 "
"HTTP 的 [Hyper](https://hyper.rs/) 或 适用于 gRPC 的 [Tonic](https://github."
"com/hyperium/tonic)。"

#: src/async/runtimes.md
msgid ""
"[async-std](https://async.rs/): aims to be a \"std for async\", and includes "
"a basic runtime in `async::task`."
msgstr ""
"[async-std](https://async.rs/)：旨在成为 “异步编程的标准库”，并在 `async::"
"task` 中包含基本运行时。"

#: src/async/runtimes.md
msgid "[smol](https://docs.rs/smol/latest/smol/): simple and lightweight"
msgstr "[smol](https://docs.rs/smol/latest/smol/)：简单且轻量"

#: src/async/runtimes.md
msgid ""
"Several larger applications have their own runtimes. For example, [Fuchsia]"
"(https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-"
"async/src/lib.rs) already has one."
msgstr ""
"有些大型应用具有自己的运行时。例如，[Fuchsia](https://fuchsia.googlesource."
"com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs) 已有一个运行"
"时。"

#: src/async/runtimes.md
msgid ""
"Note that of the listed runtimes, only Tokio is supported in the Rust "
"playground. The playground also does not permit any I/O, so most interesting "
"async things can't run in the playground."
msgstr ""
"请注意，在列出的运行时中，Rust Playground 仅支持 Tokio。该 Playground 也不支"
"持任何 I/O 操作，因此大多数有趣的异步操作无法在该平台上运行。"

#: src/async/runtimes.md
msgid ""
"Futures are \"inert\" in that they do not do anything (not even start an I/O "
"operation) unless there is an executor polling them. This differs from JS "
"Promises, for example, which will run to completion even if they are never "
"used."
msgstr ""
"Future 是 “惯性”的，除非有执行程序对其进行轮询，否则它们不会执行任何操作（甚"
"至不会启动 I/O 操作）。这与 JS promise 不同，例如，后者即使从未使用也会完成运"
"行过程。"

#: src/async/runtimes/tokio.md
#, fuzzy
msgid "Tokio provides:"
msgstr "Tokio 提供："

#: src/async/runtimes/tokio.md
msgid "A multi-threaded runtime for executing asynchronous code."
msgstr "用于执行异步代码的多线程运行时。"

#: src/async/runtimes/tokio.md
#, fuzzy
msgid "An asynchronous version of the standard library."
msgstr "异步版本的标准库。"

#: src/async/runtimes/tokio.md
msgid "A large ecosystem of libraries."
msgstr "庞大的库生态系统。"

#: src/async/runtimes/tokio.md
msgid "\"Count in task: {i}!\""
msgstr "\"Count in task: {i}!\""

#: src/async/runtimes/tokio.md
msgid "\"Main task: {i}\""
msgstr "\"Main task: {i}\""

#: src/async/runtimes/tokio.md
msgid "With the `tokio::main` macro we can now make `main` async."
msgstr "借助 `tokio::main` 宏，我们现在可以将 `main` 设为异步函数。"

#: src/async/runtimes/tokio.md
msgid "The `spawn` function creates a new, concurrent \"task\"."
msgstr "`spawn` 函数会创建新的并发 “任务”。"

#: src/async/runtimes/tokio.md
msgid "Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`."
msgstr ""
"注意：`spawn` 使用 `Future` 方法实现，而不是对 `count_to` 调用 `.await`。"

#: src/async/runtimes/tokio.md
msgid "**Further exploration:**"
msgstr "**深入探索**："

#: src/async/runtimes/tokio.md
msgid ""
"Why does `count_to` not (usually) get to 10? This is an example of async "
"cancellation. `tokio::spawn` returns a handle which can be awaited to wait "
"until it finishes."
msgstr ""
"为何 `count_to` 通常无法计数到 10？这是一个异步取消的示例。`tokio::spawn` 会"
"返回一个句柄，可以等待该句柄直至其代表的任务执行完毕。"

#: src/async/runtimes/tokio.md
msgid "Try `count_to(10).await` instead of spawning."
msgstr "尝试使用 `count_to(10).await`，而不是派生方法。"

#: src/async/runtimes/tokio.md
msgid "Try awaiting the task returned from `tokio::spawn`."
msgstr "尝试等待 `tokio::spawn` 返回的任务执行完毕。"

#: src/async/tasks.md
msgid "Rust has a task system, which is a form of lightweight threading."
msgstr "Rust 有一个任务系统，这是一种轻量级线程处理形式。"

#: src/async/tasks.md
msgid ""
"A task has a single top-level future which the executor polls to make "
"progress. That future may have one or more nested futures that its `poll` "
"method polls, corresponding loosely to a call stack. Concurrency within a "
"task is possible by polling multiple child futures, such as racing a timer "
"and an I/O operation."
msgstr ""
"每个任务只有一个顶级 Future，执行器会对此进行轮询来推进任务进度。该 Future 可"
"能包含一个或多个嵌套的 Future，可以通过其 `poll` 方法对它们进行轮询，类似于调"
"用堆栈。可以通过轮询多个子 Future（例如争用定时器和 I/O 操作）在任务内部实现"
"并发操作。"

#: src/async/tasks.md
#, fuzzy
msgid "\"127.0.0.1:0\""
msgstr "\"127.0.0.1:2000\""

#: src/async/tasks.md
#, fuzzy
msgid "\"listening on port {}\""
msgstr "\"listening on port 6142\""

#: src/async/tasks.md
msgid "\"connection from {addr:?}\""
msgstr "\"connection from {addr:?}\""

#: src/async/tasks.md
msgid "b\"Who are you?\\n\""
msgstr "b\"Who are you?\\n\""

#: src/async/tasks.md
#, fuzzy
msgid "\"socket error\""
msgstr "\"socket error: {e:?}\""

#: src/async/tasks.md
msgid "\"Thanks for dialing in, {name}!\\n\""
msgstr "\"Thanks for dialing in, {name}!\\n\""

#: src/async/tasks.md src/async/control-flow/join.md
msgid ""
"Copy this example into your prepared `src/main.rs` and run it from there."
msgstr "将此示例复制到准备好的 `src/main.rs` 文件中，并从该文件运行它。"

#: src/async/tasks.md
msgid ""
"Try connecting to it with a TCP connection tool like [nc](https://www.unix."
"com/man-page/linux/1/nc/) or [telnet](https://www.unix.com/man-page/linux/1/"
"telnet/)."
msgstr ""
"请尝试使用像 [nc](https://www.unix.com/man-page/linux/1/nc/) 或 [telnet]"
"(https://www.unix.com/man-page/linux/1/telnet/) 这样的 TCP 连接工具进行连接。"

#: src/async/tasks.md
msgid ""
"Ask students to visualize what the state of the example server would be with "
"a few connected clients. What tasks exist? What are their Futures?"
msgstr ""
"让学生想象一下，当连接多个客户端时，示例服务器会达到怎样的状态。存在哪些任"
"务？具有哪些 Future？"

#: src/async/tasks.md
#, fuzzy
msgid ""
"This is the first time we've seen an `async` block. This is similar to a "
"closure, but does not take any arguments. Its return value is a Future, "
"similar to an `async fn`."
msgstr ""
"这是我们首次看到 `async` 代码块。这与闭包类似，但不采用任何参数。该代码块的返"
"回值是 Future，类似于 `async fn`。"

#: src/async/tasks.md
#, fuzzy
msgid ""
"Refactor the async block into a function, and improve the error handling "
"using `?`."
msgstr "将 async 代码块重构为一个函数，并使用 `?` 优化错误处理。"

#: src/async/channels.md
msgid ""
"Several crates have support for asynchronous channels. For instance `tokio`:"
msgstr "有些 crate 支持使用异步通道。例如 `tokio`："

#: src/async/channels.md
msgid "\"Received {count} pings so far.\""
msgstr "\"Received {count} pings so far.\""

#: src/async/channels.md
msgid "\"ping_handler complete\""
msgstr "\"ping_handler complete\""

#: src/async/channels.md
msgid "\"Failed to send ping.\""
msgstr "\"Failed to send ping.\""

#: src/async/channels.md
msgid "\"Sent {} pings so far.\""
msgstr "\"Sent {} pings so far.\""

#: src/async/channels.md
msgid "\"Something went wrong in ping handler task.\""
msgstr "\"Something went wrong in ping handler task.\""

#: src/async/channels.md
msgid "Change the channel size to `3` and see how it affects the execution."
msgstr "将通道大小更改为 `3`，然后看看对操作执行会有什么影响。"

#: src/async/channels.md
msgid ""
"Overall, the interface is similar to the `sync` channels as seen in the "
"[morning class](concurrency/channels.md)."
msgstr ""
"总体而言，该接口类似于 [上午课程](concurrency/channels.md) 中所讲的 `sync` 通"
"道。"

#: src/async/channels.md
msgid "Try removing the `std::mem::drop` call. What happens? Why?"
msgstr "尝试移除 `std::mem::drop` 调用。会出现什么情况？这是为什么？"

#: src/async/channels.md
msgid ""
"The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that "
"implement both `sync` and `async` `send` and `recv`. This can be convenient "
"for complex applications with both IO and heavy CPU processing tasks."
msgstr ""
"[Flume](https://docs.rs/flume/latest/flume/) crate 包含可以同时实现 `sync`、"
"`async` `send` 和 `recv` 的渠道，为涉及 IO 和大量 CPU 处理任务的复杂应用提供"
"了极大便利。"

#: src/async/channels.md
msgid ""
"What makes working with `async` channels preferable is the ability to "
"combine them with other `future`s to combine them and create complex control "
"flow."
msgstr ""
"使用 `async` 通道的优势在于，我们能够将它们与其他 `future` 结合起来，从而创建"
"复杂的控制流。"

#: src/async/control-flow.md
#, fuzzy
msgid "Futures Control Flow"
msgstr "Future 控制流"

#: src/async/control-flow.md
msgid ""
"Futures can be combined together to produce concurrent compute flow graphs. "
"We have already seen tasks, that function as independent threads of "
"execution."
msgstr ""
"可以将很多 Future 组合在一起生成并发计算流图。我们已经介绍过用作独立线程的任"
"务类型。"

#: src/async/control-flow.md
msgid "[Join](control-flow/join.md)"
msgstr "[联接](control-flow/join.md)"

#: src/async/control-flow.md
msgid "[Select](control-flow/select.md)"
msgstr "[选择](control-flow/select.md)"

#: src/async/control-flow/join.md
msgid ""
"A join operation waits until all of a set of futures are ready, and returns "
"a collection of their results. This is similar to `Promise.all` in "
"JavaScript or `asyncio.gather` in Python."
msgstr ""
"联接操作会等待一组 Future 全部就绪，然后返回它们的结果集合。这类似于 "
"JavaScript 中的 `Promise.al` 或 Python 中的 `asyncio.gather`。"

#: src/async/control-flow/join.md
msgid "\"https://google.com\""
msgstr "\"https://google.com\""

#: src/async/control-flow/join.md
msgid "\"https://httpbin.org/ip\""
msgstr "\"https://httpbin.org/ip\""

#: src/async/control-flow/join.md
msgid "\"https://play.rust-lang.org/\""
msgstr "\"https://play.rust-lang.org/\""

#: src/async/control-flow/join.md
msgid "\"BAD_URL\""
msgstr "\"BAD_URL\""

#: src/async/control-flow/join.md
msgid ""
"For multiple futures of disjoint types, you can use `std::future::join!` but "
"you must know how many futures you will have at compile time. This is "
"currently in the `futures` crate, soon to be stabilised in `std::future`."
msgstr ""
"对于多个类型不相交的 Future，可以使用 `std::future::join!` 进行处理，但必须要"
"确定在编译时 Future 的数量。目前，可在 `futures` crate 中使用该功能，但很快也"
"会在 `std::future` 中正式发布。"

#: src/async/control-flow/join.md
#, fuzzy
msgid ""
"The risk of `join` is that one of the futures may never resolve, this would "
"cause your program to stall."
msgstr ""
"使用 `join` 的风险在于，可能永远无法解析其中某个 Future，这会导致程序停滞不"
"前。"

#: src/async/control-flow/join.md
msgid ""
"You can also combine `join_all` with `join!` for instance to join all "
"requests to an http service as well as a database query. Try adding a "
"`tokio::time::sleep` to the future, using `futures::join!`. This is not a "
"timeout (that requires `select!`, explained in the next chapter), but "
"demonstrates `join!`."
msgstr ""
"还可以将 `join_all` 与 `join!` 结合使用，并行处理所有对 http 服务的请求和数据"
"库查询。尝试使用 `futures::join!` 将 `tokio::time::sleep` 添加到 Future 中。"
"这不是一个超时操作（其需要使用 `select!`，下一章会详细介绍），而是展示了 "
"`join!` 的使用方式。"

#: src/async/control-flow/select.md
msgid ""
"A select operation waits until any of a set of futures is ready, and "
"responds to that future's result. In JavaScript, this is similar to `Promise."
"race`. In Python, it compares to `asyncio.wait(task_set, return_when=asyncio."
"FIRST_COMPLETED)`."
msgstr ""
"选择操作会等待一组 Future 中的任意一个就绪，并对 Future 产生的结果进行响应。"
"在 JavaScript 中，该操作类似于 `Promise.race`。在 Python 中，它相当于 "
"`asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)`。"

#: src/async/control-flow/select.md
#, fuzzy
msgid ""
"Similar to a match statement, the body of `select!` has a number of arms, "
"each of the form `pattern = future => statement`. When a `future` is ready, "
"its return value is destructured by the `pattern`. The `statement` is then "
"run with the resulting variables. The `statement` result becomes the result "
"of the `select!` macro."
msgstr ""
"与 match 语句类似，`select!` 的正文也包含多个分支，每个分支的形式为 `pattern "
"= future => statement`。当 `future` 就绪时，系统会执行 `statement`，并将 "
"`pattern` 中的变量绑定到 `future` 所产生的结果。"

#: src/async/control-flow/select.md
msgid "\"Felix\""
msgstr "\"Felix\""

#: src/async/control-flow/select.md
msgid "\"Failed to send cat.\""
msgstr "\"Failed to send cat.\""

#: src/async/control-flow/select.md
msgid "\"Rex\""
msgstr "\"Rex\""

#: src/async/control-flow/select.md
msgid "\"Failed to send dog.\""
msgstr "\"Failed to send dog.\""

#: src/async/control-flow/select.md
msgid "\"Failed to receive winner\""
msgstr "\"Failed to receive winner\""

#: src/async/control-flow/select.md
msgid "\"Winner is {winner:?}\""
msgstr "\"Winner is {winner:?}\""

#: src/async/control-flow/select.md
msgid ""
"In this example, we have a race between a cat and a dog. "
"`first_animal_to_finish_race` listens to both channels and will pick "
"whichever arrives first. Since the dog takes 50ms, it wins against the cat "
"that take 500ms."
msgstr ""
"在本示例中，猫和狗之间进行了一场比赛。`first_animal_to_finish_race` 会同时监"
"听这两个通道，并选择最先到达终点的作为胜者。由于狗用时 50 毫秒，而猫用时 500 "
"毫秒，前者在此比赛中大获全胜。"

#: src/async/control-flow/select.md
msgid ""
"You can use `oneshot` channels in this example as the channels are supposed "
"to receive only one `send`."
msgstr ""
"在本示例中，可以使用 `oneshot` 通道，因为这些通道只能接收一次 `send` 信号。"

#: src/async/control-flow/select.md
msgid ""
"Try adding a deadline to the race, demonstrating selecting different sorts "
"of futures."
msgstr "尝试为比赛添加截至时间，演示如何选择不同类型的 Future。"

#: src/async/control-flow/select.md
msgid ""
"Note that `select!` drops unmatched branches, which cancels their futures. "
"It is easiest to use when every execution of `select!` creates new futures."
msgstr ""
"请注意，`select!` 会丢弃不匹配的分支，相对应的 Future 也会随之取消。最简单的"
"方法是，每次执行 `select!` 时创建新的 Future。"

#: src/async/control-flow/select.md
msgid ""
"An alternative is to pass `&mut future` instead of the future itself, but "
"this can lead to issues, further discussed in the pinning slide."
msgstr ""
"另一种方法是传递 `&mut future` 而不是 future 本身，但这可能会导致问题，在本幻"
"灯片的 “固定” 部分进行了详细介绍。"

#: src/async/pitfalls.md
msgid "Pitfalls of async/await"
msgstr "关于 async/await 的误区"

#: src/async/pitfalls.md
msgid ""
"Async / await provides convenient and efficient abstraction for concurrent "
"asynchronous programming. However, the async/await model in Rust also comes "
"with its share of pitfalls and footguns. We illustrate some of them in this "
"chapter:"
msgstr ""
"async / await 为处理并发异步编程提供了一种方便高效的抽象方法。然而，Rust 中"
"的 async/await 模型也存在一些误区和隐患。本章将展示其中的部分内容："

#: src/async/pitfalls.md
msgid "[Blocking the Executor](pitfalls/blocking-executor.md)"
msgstr "[阻塞执行器](pitfalls/blocking-executor.md)"

#: src/async/pitfalls.md
msgid "[Pin](pitfalls/pin.md)"
msgstr "[固定](pitfalls/pin.md)"

#: src/async/pitfalls.md
msgid "[Async Traits](pitfalls/async-traits.md)"
msgstr "[异步 trait](pitfalls/async-traits.md)"

#: src/async/pitfalls.md
msgid "[Cancellation](pitfalls/cancellation.md)"
msgstr "[取消](pitfalls/cancellation.md)"

#: src/async/pitfalls/blocking-executor.md
msgid "Blocking the executor"
msgstr "阻塞执行器"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Most async runtimes only allow IO tasks to run concurrently. This means that "
"CPU blocking tasks will block the executor and prevent other tasks from "
"being executed. An easy workaround is to use async equivalent methods where "
"possible."
msgstr ""
"大多数异步运行时支持并发运行 IO 任务。这意味着 CPU 的阻塞性任务会阻塞执行器，"
"并阻止执行其他任务。最简单的方法是，尽可能使用异步等效方法。"

#: src/async/pitfalls/blocking-executor.md
msgid "\"future {id} slept for {duration_ms}ms, finished after {}ms\""
msgstr "\"future {id} slept for {duration_ms}ms, finished after {}ms\""

#: src/async/pitfalls/blocking-executor.md
msgid "\"current_thread\""
msgstr "\"current_thread\""

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Run the code and see that the sleeps happen consecutively rather than "
"concurrently."
msgstr "运行该代码，您会发现休眠操作是连续发生的，而不是并发进行的。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"The `\"current_thread\"` flavor puts all tasks on a single thread. This "
"makes the effect more obvious, but the bug is still present in the multi-"
"threaded flavor."
msgstr ""
"`\"current_thread\"` 变种将所有任务放在单个线程上。这样做效果会更明显，但 "
"bug 仍然存在于多线程变种中。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result."
msgstr "将 `std::thread::sleep` 切换为 `tokio::time::sleep`，并等待结果。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Another fix would be to `tokio::task::spawn_blocking` which spawns an actual "
"thread and transforms its handle into a future without blocking the executor."
msgstr ""
"另一个修复方案是 `tokio::task::spawn_blocking`，其会生成实际线程并将句柄转换"
"为 Future，且不会阻塞执行器。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"You should not think of tasks as OS threads. They do not map 1 to 1 and most "
"executors will allow many tasks to run on a single OS thread. This is "
"particularly problematic when interacting with other libraries via FFI, "
"where that library might depend on thread-local storage or map to specific "
"OS threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such "
"situations."
msgstr ""
"不应将任务视为操作系统线程。它们之间并非一对一的映射关系，并且大多数执行器都"
"支持在单个操作系统线程上运行多个任务。尤其是通过 FFI 与其他库交互时，会更容易"
"出现问题，因为在 FFI 中，因为该库可能依赖于线程本地存储或映射到特定的操作系统"
"线程（例如，CUDA）。在这些情况下，首选 `tokio::task::spawn_blocking`。"

#: src/async/pitfalls/blocking-executor.md
msgid ""
"Use sync mutexes with care. Holding a mutex over an `.await` may cause "
"another task to block, and that task may be running on the same thread."
msgstr ""
"请谨慎使用同步互斥操作。对 `.await` 一直执行互斥操作能会导致另一个任务阻塞，"
"并且该任务可能与其在同一线程上运行。"

#: src/async/pitfalls/pin.md
msgid ""
"Async blocks and functions return types implementing the `Future` trait. The "
"type returned is the result of a compiler transformation which turns local "
"variables into data stored inside the future."
msgstr ""

#: src/async/pitfalls/pin.md
msgid ""
"Some of those variables can hold pointers to other local variables. Because "
"of that, the future should never be moved to a different memory location, as "
"it would invalidate those pointers."
msgstr ""

#: src/async/pitfalls/pin.md
msgid ""
"To prevent moving the future type in memory, it can only be polled through a "
"pinned pointer. `Pin` is a wrapper around a reference that disallows all "
"operations that would move the instance it points to into a different memory "
"location."
msgstr ""

#: src/async/pitfalls/pin.md
msgid ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"
msgstr ""
"// A work item. In this case, just sleep for the given time and respond\n"
"// with a message on the `respond_on` channel.\n"

#: src/async/pitfalls/pin.md
msgid "// A worker which listens for work on a queue and performs it.\n"
msgstr "// A worker which listens for work on a queue and performs it.\n"

#: src/async/pitfalls/pin.md
msgid "// Pretend to work.\n"
msgstr "// Pretend to work.\n"

#: src/async/pitfalls/pin.md
msgid "\"failed to send response\""
msgstr "\"failed to send response\""

#: src/async/pitfalls/pin.md
msgid "// TODO: report number of iterations every 100ms\n"
msgstr "// TODO: report number of iterations every 100ms\n"

#: src/async/pitfalls/pin.md
msgid "// A requester which requests work and waits for it to complete.\n"
msgstr "// A requester which requests work and waits for it to complete.\n"

#: src/async/pitfalls/pin.md
msgid "\"failed to send on work queue\""
msgstr "\"failed to send on work queue\""

#: src/async/pitfalls/pin.md
msgid "\"failed waiting for response\""
msgstr "\"failed waiting for response\""

#: src/async/pitfalls/pin.md
msgid "\"work result for iteration {i}: {resp}\""
msgstr "\"work result for iteration {i}: {resp}\""

#: src/async/pitfalls/pin.md
msgid ""
"You may recognize this as an example of the actor pattern. Actors typically "
"call `select!` in a loop."
msgstr "您可能认为这是执行器模式的一个示例。执行器通常会循环调用 `select!`。"

#: src/async/pitfalls/pin.md
msgid ""
"This serves as a summation of a few of the previous lessons, so take your "
"time with it."
msgstr "本部分是对前面几节课的总结，因此请多花时间用心学习。"

#: src/async/pitfalls/pin.md
msgid ""
"Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to "
"the `select!`. This will never execute. Why?"
msgstr ""
"只是单纯地在 `select!` 中添加 `_ = sleep(Duration::from_millis(100)) => "
"{ println!(..) }`，该行代码将不会执行任何操作。这是为什么？"

#: src/async/pitfalls/pin.md
msgid ""
"Instead, add a `timeout_fut` containing that future outside of the `loop`:"
msgstr "请改为在 `loop` 外部添加包含该 Future 的 `timeout_fut`："

#: src/async/pitfalls/pin.md
msgid ""
"This still doesn't work. Follow the compiler errors, adding `&mut` to the "
"`timeout_fut` in the `select!` to work around the move, then using `Box::"
"pin`:"
msgstr ""
"这仍然不起作用。根据编译器提示的错误，通过向 `select!` 中的 `timeout_fut` 添"
"加 `&mut` 解决移动问题，然后使用 `Box::pin`："

#: src/async/pitfalls/pin.md
msgid ""
"This compiles, but once the timeout expires it is `Poll::Ready` on every "
"iteration (a fused future would help with this). Update to reset "
"`timeout_fut` every time it expires."
msgstr ""
"可以编译这段代码了，但超时过期后，每次迭代都会变为 `Poll::Ready`（使用混合 "
"Future 有助于解决此问题）。每次超时过期后，通过更新重置 `timeout_fut`。"

#: src/async/pitfalls/pin.md
msgid ""
"Box allocates on the heap. In some cases, `std::pin::pin!` (only recently "
"stabilized, with older code often using `tokio::pin!`) is also an option, "
"but that is difficult to use for a future that is reassigned."
msgstr ""
"Box 在堆上进行分配。在某些情况下，也可以选择使用 `std::pin::pin!`（最近才正式"
"发布，较旧的代码通常使用 `tokio::pin!`），但对于重新分配的 Future，使用此功能"
"较为困难。"

#: src/async/pitfalls/pin.md
msgid ""
"Another alternative is to not use `pin` at all but spawn another task that "
"will send to a `oneshot` channel every 100ms."
msgstr ""
"另一种替代方案是完全不使用 `pin`，而是生成另一个任务，该任务每隔 100 毫秒就会"
"发送到 `oneshot` 通道。"

#: src/async/pitfalls/pin.md
msgid ""
"Data that contains pointers to itself is called self-referential. Normally, "
"the Rust borrow checker would prevent self-referential data from being "
"moved, as the references cannot outlive the data they point to. However, the "
"code transformation for async blocks and functions is not verified by the "
"borrow checker."
msgstr ""

#: src/async/pitfalls/pin.md
msgid ""
"`Pin` is a wrapper around a reference. An object cannot be moved from its "
"place using a pinned pointer. However, it can still be moved through an "
"unpinned pointer."
msgstr ""

#: src/async/pitfalls/pin.md
msgid ""
"The `poll` method of the `Future` trait uses `Pin<&mut Self>` instead of "
"`&mut Self` to refer to the instance. That's why it can only be called on a "
"pinned pointer."
msgstr ""

#: src/async/pitfalls/async-traits.md
msgid ""
"Async methods in traits are not yet supported in the stable channel ([An "
"experimental feature exists in nightly and should be stabilized in the mid "
"term.](https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-"
"nightly.html))"
msgstr ""
"稳定版尚不支持在 trait 中使用异步方法（[夜间版提供此项功能，但正处于试验阶"
"段，预计在中期正式发布。](https://blog.rust-lang.org/inside-rust/2022/11/17/"
"async-fn-in-trait-nightly.html)）"

#: src/async/pitfalls/async-traits.md
msgid ""
"The crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) "
"provides a workaround through a macro:"
msgstr ""
"crate [async_trait](https://docs.rs/async-trait/latest/async_trait/) 通过宏提"
"供了一种解决方法："

#: src/async/pitfalls/async-traits.md
msgid "\"running all sleepers..\""
msgstr "\"running all sleepers..\""

#: src/async/pitfalls/async-traits.md
msgid "\"slept for {}ms\""
msgstr "\"slept for {}ms\""

#: src/async/pitfalls/async-traits.md
msgid ""
"`async_trait` is easy to use, but note that it's using heap allocations to "
"achieve this. This heap allocation has performance overhead."
msgstr ""
"`async_trait` 易于使用，但请注意，它通过堆分配来实现这一点。这种堆分配会产生"
"性能开销。"

#: src/async/pitfalls/async-traits.md
msgid ""
"The challenges in language support for `async trait` are deep Rust and "
"probably not worth describing in-depth. Niko Matsakis did a good job of "
"explaining them in [this post](https://smallcultfollowing.com/babysteps/"
"blog/2019/10/26/async-fn-in-traits-are-hard/) if you are interested in "
"digging deeper."
msgstr ""
"对于 `async trait` 的语言支持中的挑战是深入  Rust的，并且可能不值得深入描述。"
"如果您对深入了解感兴趣，Niko Matsakis 在[这篇文章](https://"
"smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-"
"hard/)中对它们做了很好的解释。"

#: src/async/pitfalls/async-traits.md
msgid ""
"Try creating a new sleeper struct that will sleep for a random amount of "
"time and adding it to the Vec."
msgstr ""
"尝试创建一个新的 sleeper 结构，使其随机休眠一段时间，并将其添加到 Vec 中。"

#: src/async/pitfalls/cancellation.md
msgid ""
"Dropping a future implies it can never be polled again. This is called "
"_cancellation_ and it can occur at any `await` point. Care is needed to "
"ensure the system works correctly even when futures are cancelled. For "
"example, it shouldn't deadlock or lose data."
msgstr ""
"丢弃 Future 意味着无法再对其进行轮询。这称为 _取消_，在任何 `await` 点都可能"
"发生。请务必小心谨慎，确保即使 Future 任务被取消，系统也能正常运行。例如，系"
"统不应死锁或丢失数据。"

#: src/async/pitfalls/cancellation.md
#, fuzzy
msgid "\"not UTF-8\""
msgstr "UTF-8"

#: src/async/pitfalls/cancellation.md
msgid "\"hi\\nthere\\n\""
msgstr "\"hi\\nthere\\n\""

#: src/async/pitfalls/cancellation.md
msgid "\"tick!\""
msgstr "\"tick!\""

#: src/async/pitfalls/cancellation.md
msgid ""
"The compiler doesn't help with cancellation-safety. You need to read API "
"documentation and consider what state your `async fn` holds."
msgstr ""
"编译器无法确保取消操作的安全性。您需要阅读 API 文档，并考虑 `async fn` 所持状"
"态。"

#: src/async/pitfalls/cancellation.md
msgid ""
"Unlike `panic` and `?`, cancellation is part of normal control flow (vs "
"error-handling)."
msgstr "与 `panic` 和 `?` 不同，取消属于正常控制流的一部分（而非错误处理）。"

#: src/async/pitfalls/cancellation.md
msgid "The example loses parts of the string."
msgstr "该示例丢失了字符串的某些部分。"

#: src/async/pitfalls/cancellation.md
msgid ""
"Whenever the `tick()` branch finishes first, `next()` and its `buf` are "
"dropped."
msgstr "每当 `tick()` 分支先完成操作时，`next() 及其 `buf` 均会被丢弃。"

#: src/async/pitfalls/cancellation.md
msgid ""
"`LinesReader` can be made cancellation-safe by making `buf` part of the "
"struct:"
msgstr "通过将 `buf` 整合到结构体中，`LinesReader 可以确保取消操作的安全性："

#: src/async/pitfalls/cancellation.md
msgid "// prefix buf and bytes with self.\n"
msgstr "// prefix buf and bytes with self.\n"

#: src/async/pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval."
"html#method.tick) is cancellation-safe because it keeps track of whether a "
"tick has been 'delivered'."
msgstr ""
"[BufReader::read_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line)：用于从标准输入异步读取用户消息。"

#: src/async/pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncReadExt.html#method.read) is cancellation-safe because it either "
"returns or doesn't read data."
msgstr ""
"[BufReader::read_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line)：用于从标准输入异步读取用户消息。"

#: src/async/pitfalls/cancellation.md
#, fuzzy
msgid ""
"[`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait."
"AsyncBufReadExt.html#method.read_line) is similar to the example and _isn't_ "
"cancellation-safe. See its documentation for details and alternatives."
msgstr ""
"[BufReader::read_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line)：用于从标准输入异步读取用户消息。"

#: src/exercises/concurrency/afternoon.md
msgid ""
"To practice your Async Rust skills, we have again two exercises for you:"
msgstr "为了练习您的异步 Rust 技能，我们再次为您提供了两个练习："

#: src/exercises/concurrency/afternoon.md
msgid ""
"Dining philosophers: we already saw this problem in the morning. This time "
"you are going to implement it with Async Rust."
msgstr ""
"哲学家进餐：我们已经在上午看到了这个问题。这次你将使用异步 Rust 来实现它。"

#: src/exercises/concurrency/afternoon.md
msgid ""
"A Broadcast Chat Application: this is a larger project that allows you "
"experiment with more advanced Async Rust features."
msgstr "广播聊天应用：这是一个更大的项目，允许您尝试更高级的异步Rust功能。"

#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
#, fuzzy
msgid "Dining Philosophers --- Async"
msgstr "哲学家进餐 - 异步"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"See [dining philosophers](dining-philosophers.md) for a description of the "
"problem."
msgstr "查看[哲学家进餐](dining-philosophers.md)以获取问题的描述。"

#: src/exercises/concurrency/dining-philosophers-async.md
#, fuzzy
msgid ""
"As before, you will need a local [Cargo installation](../../cargo/running-"
"locally.md) for this exercise. Copy the code below to a file called `src/"
"main.rs`, fill out the blanks, and test that `cargo run` does not deadlock:"
msgstr ""
"在本练习中，需要使用本地 [Cargo 安装](../../cargo/running-locally.md)。将以下"
"代码复制到名为 `src/main.rs` 的文件中，并填写空白的地方，然后测试 `cargo "
"run` 不会死锁："

#: src/exercises/concurrency/dining-philosophers-async.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Make them think and eat\n"
msgstr "// Make them think and eat\n"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"Since this time you are using Async Rust, you'll need a `tokio` dependency. "
"You can use the following `Cargo.toml`:"
msgstr ""
"因为这次您正在使用异步Rust，您将需要一个 `tokio` 依赖。您可以使用以下的 "
"`Cargo.toml`："

#: src/exercises/concurrency/dining-philosophers-async.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = { version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"dining-philosophers-async-dine\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"tokio = {version = \"1.26.0\", features = [\"sync\", \"time\", \"macros\", "
"\"rt-multi-thread\"]}\n"
"```"

#: src/exercises/concurrency/dining-philosophers-async.md
msgid ""
"Also note that this time you have to use the `Mutex` and the `mpsc` module "
"from the `tokio` crate."
msgstr "另外，请注意，这次您必须使用来自 `tokio` 包的 `Mutex` 和 `mpsc` 模块。"

#: src/exercises/concurrency/dining-philosophers-async.md
#, fuzzy
msgid "Can you make your implementation single-threaded?"
msgstr "您可以单线程化您的实现吗？"

#: src/exercises/concurrency/chat-app.md
msgid ""
"In this exercise, we want to use our new knowledge to implement a broadcast "
"chat application. We have a chat server that the clients connect to and "
"publish their messages. The client reads user messages from the standard "
"input, and sends them to the server. The chat server broadcasts each message "
"that it receives to all the clients."
msgstr ""
"在本练习中，我们想要使用我们的新知识来实现一个广播聊天应用。我们有一个聊天服"
"务器，客户端连接到该服务器并发布他们的消息。客户端从标准输入读取用户消息，并"
"将其发送到服务器。聊天服务器将收到的每条消息广播给所有客户端。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"For this, we use [a broadcast channel](https://docs.rs/tokio/latest/tokio/"
"sync/broadcast/fn.channel.html) on the server, and [`tokio_websockets`]"
"(https://docs.rs/tokio-websockets/) for the communication between the client "
"and the server."
msgstr ""
"为此，我们在服务器上使用一个[广播 channel](https://docs.rs/tokio/latest/"
"tokio/sync/broadcast/fn.channel.html)，并使用[`tokio_websockets`](https://"
"docs.rs/tokio-websockets/0.3.2/tokio_websockets/) 来进行客户端与服务器之间的"
"通信。"

#: src/exercises/concurrency/chat-app.md
msgid "Create a new Cargo project and add the following dependencies:"
msgstr "创建一个新的 Cargo 项目并添加以下依赖："

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid "_Cargo.toml_:"
msgstr "`Cargo.toml`："

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.30\", features = [\"sink\"] }\n"
"http = \"1.0.0\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.5.1\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"chat-async\"\n"
"version = \"0.1.0\"\n"
"edition = \"2021\"\n"
"\n"
"[dependencies]\n"
"futures-util = { version = \"0.3.28\", features = [\"sink\"] }\n"
"http = \"0.2.9\"\n"
"tokio = { version = \"1.28.1\", features = [\"full\"] }\n"
"tokio-websockets = { version = \"0.4.0\", features = [\"client\", "
"\"fastrand\", \"server\", \"sha1_smol\"] }\n"
"```"

#: src/exercises/concurrency/chat-app.md
msgid "The required APIs"
msgstr "所需的API"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"You are going to need the following functions from `tokio` and "
"[`tokio_websockets`](https://docs.rs/tokio-websockets/). Spend a few minutes "
"to familiarize yourself with the API."
msgstr ""
"您将需要来自 `tokio` 和 [`tokio_websockets`](https://docs.rs/tokio-"
"websockets/0.3.2/tokio_websockets/) 的以下函数。请花几分钟时间熟悉这些 API。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"[StreamExt::next()](https://docs.rs/futures-util/0.3.28/futures_util/stream/"
"trait.StreamExt.html#method.next) implemented by `WebSocketStream`: for "
"asynchronously reading messages from a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) 由`WebsocketStream`实现：用于在Websocket流上"
"异步发送消息。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) implemented by `WebSocketStream`: for "
"asynchronously sending messages on a Websocket Stream."
msgstr ""
"[SinkExt::send()](https://docs.rs/futures-util/0.3.28/futures_util/sink/"
"trait.SinkExt.html#method.send) 由`WebsocketStream`实现：用于在Websocket流上"
"异步发送消息。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"[Lines::next_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line): for asynchronously reading user messages from the "
"standard input."
msgstr ""
"[BufReader::read_line()](https://docs.rs/tokio/latest/tokio/io/struct.Lines."
"html#method.next_line)：用于从标准输入异步读取用户消息。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe): for subscribing to a broadcast channel."
msgstr ""
"[Sender::subscribe()](https://docs.rs/tokio/latest/tokio/sync/broadcast/"
"struct.Sender.html#method.subscribe)：用于订阅广播频道。"

#: src/exercises/concurrency/chat-app.md
msgid "Two binaries"
msgstr "两个可执行文件"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"Normally in a Cargo project, you can have only one binary, and one `src/main."
"rs` file. In this project, we need two binaries. One for the client, and one "
"for the server. You could potentially make them two separate Cargo projects, "
"but we are going to put them in a single Cargo project with two binaries. "
"For this to work, the client and the server code should go under `src/bin` "
"(see the [documentation](https://doc.rust-lang.org/cargo/reference/cargo-"
"targets.html#binaries))."
msgstr ""
"通常在一个 Cargo 项目中，你只能有一个二进制文件，和一个 `src/main.rs` 文件。"
"在这个项目中，我们需要两个二进制文件。一个用于客户端，另一个用于服务器。你可"
"能会考虑将它们制作成两个单独的 Cargo 项目，但我们将它们放在一个包含两个二进制"
"文件的 Cargo 项目中。为了使其工作，客户端和服务器的代码应该放在 `src/bin` 下"
"（参见[文档](https://doc.rust-lang.org/cargo/reference/cargo-targets."
"html#binaries)）。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"Copy the following server and client code into `src/bin/server.rs` and `src/"
"bin/client.rs`, respectively. Your task is to complete these files as "
"described below."
msgstr ""
"将以下服务器和客户端代码分别复制到 `src/bin/server.rs` 和 `src/bin/client."
"rs` 中。您的任务是按照下面的描述完成这些文件。"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
#, fuzzy
msgid "_src/bin/server.rs_:"
msgstr "`src/bin/server.rs`:"

#: src/exercises/concurrency/chat-app.md
msgid "// TODO: For a hint, see the description of the task below.\n"
msgstr "// TODO: For a hint, see the description of the task below.\n"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"127.0.0.1:2000\""
msgstr "\"127.0.0.1:2000\""

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"listening on port 2000\""
msgstr "\"listening on port 2000\""

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"New connection from {addr:?}\""
msgstr "\"New connection from {addr:?}\""

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Wrap the raw TCP stream into a websocket.\n"
msgstr "// Wrap the raw TCP stream into a websocket.\n"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
#, fuzzy
msgid "_src/bin/client.rs_:"
msgstr "`src/bin/client.rs`:"

#: src/exercises/concurrency/chat-app.md
#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"ws://127.0.0.1:2000\""
msgstr "\"ws://127.0.0.1:2000\""

#: src/exercises/concurrency/chat-app.md
msgid "Running the binaries"
msgstr "运行可执行文件"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid "Run the server with:"
msgstr "and the client with:"

#: src/exercises/concurrency/chat-app.md
msgid "and the client with:"
msgstr "and the client with:"

#: src/exercises/concurrency/chat-app.md
msgid "Implement the `handle_connection` function in `src/bin/server.rs`."
msgstr "在 `src/bin/server.rs` 中实现 `handle_connection` 函数。"

#: src/exercises/concurrency/chat-app.md
msgid ""
"Hint: Use `tokio::select!` for concurrently performing two tasks in a "
"continuous loop. One task receives messages from the client and broadcasts "
"them. The other sends messages received by the server to the client."
msgstr ""
"提示：使用 `tokio::select!` 在一个连续的循环中并发执行两个任务。一个任务从客"
"户端接收消息并广播它们。另一个任务将服务器接收到的消息发送给客户端。"

#: src/exercises/concurrency/chat-app.md
msgid "Complete the main function in `src/bin/client.rs`."
msgstr "完成 `src/bin/client.rs` 中的 `main` 函数。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"Hint: As before, use `tokio::select!` in a continuous loop for concurrently "
"performing two tasks: (1) reading user messages from standard input and "
"sending them to the server, and (2) receiving messages from the server, and "
"displaying them for the user."
msgstr ""
"提示：与之前一样，使用 `tokio::select!` 在一个连续的循环中并发执行两个任务："
"(1) 从标准输入读取用户消息并发送给服务器，以及 (2) 从服务器接收消息并显示给用"
"户。"

#: src/exercises/concurrency/chat-app.md
#, fuzzy
msgid ""
"Optional: Once you are done, change the code to broadcast messages to all "
"clients, but the sender of the message."
msgstr "可选：完成后，将代码更改为将消息广播给除消息发送者以外的所有客户端。"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "Concurrency Afternoon Exercise"
msgstr "并发编程：下午练习"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "([back to exercise](dining-philosophers-async.md))"
msgstr "([返回练习](dining-philosophers-async.md))"

#: src/exercises/concurrency/solutions-afternoon.md
msgid ""
"// Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"
msgstr ""
"// Add a delay before picking the second fork to allow the execution\n"
"        // to transfer to another task\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "// The locks are dropped here\n"
msgstr "// The locks are dropped here\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid ""
"// To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"
msgstr ""
"// To avoid a deadlock, we have to break the symmetry\n"
"            // somewhere. This will swap the forks without deinitializing\n"
"            // either of them.\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "// tx is dropped here, so we don't need to explicitly drop it later\n"
msgstr "// tx is dropped here, so we don't need to explicitly drop it later\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Here is a thought: {thought}\""
msgstr "\"Here is a thought: {thought}\""

#: src/exercises/concurrency/solutions-afternoon.md
msgid "([back to exercise](chat-app.md))"
msgstr "([返回练习](chat-app.md))"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"Welcome to chat! Type a message\""
msgstr "\"Welcome to chat! Type a message\""

#: src/exercises/concurrency/solutions-afternoon.md
#, fuzzy
msgid ""
"// A continuous loop for concurrently performing two tasks: (1) receiving\n"
"    // messages from `ws_stream` and broadcasting them, and (2) receiving\n"
"    // messages on `bcast_rx` and sending them to the client.\n"
msgstr ""
"提示：与之前一样，使用 `tokio::select!` 在一个连续的循环中并发执行两个任务："
"(1) 从标准输入读取用户消息并发送给服务器，以及 (2) 从服务器接收消息并显示给用"
"户。"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"From client {addr:?} {text:?}\""
msgstr "\"From client {addr:?} {text:?}\""

#: src/exercises/concurrency/solutions-afternoon.md
msgid "// Continuous loop for concurrently sending and receiving messages.\n"
msgstr "// Continuous loop for concurrently sending and receiving messages.\n"

#: src/exercises/concurrency/solutions-afternoon.md
msgid "\"From server: {}\""
msgstr "\"From server: {}\""

#: src/thanks.md
#, fuzzy
msgid ""
"_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and "
"that it was useful."
msgstr "_感谢您参与学习 Comprehensive Rust 🦀！_ 希望您喜欢并且觉得它有用。"

#: src/thanks.md
msgid ""
"We've had a lot of fun putting the course together. The course is not "
"perfect, so if you spotted any mistakes or have ideas for improvements, "
"please get in [contact with us on GitHub](https://github.com/google/"
"comprehensive-rust/discussions). We would love to hear from you."
msgstr ""
"组织这门课程让我们收获了很多乐趣。本课程并非完美无缺，因此，如果您发现任何错"
"误或有任何改进建议，请[在 GitHub 上与我们联系](https://github.com/google/"
"comprehensive-rust/discussions)。我们期待收到您的宝贵意见。"

#: src/glossary.md
msgid ""
"The following is a glossary which aims to give a short definition of many "
"Rust terms. For translations, this also serves to connect the term back to "
"the English original."
msgstr ""
"以下为术语表，旨在提供针对许多 Rust 术语的简要定义。此外，翻译过程中也可结合"
"该术语定义来理解英语原文。"

#: src/glossary.md
msgid ""
"allocate:  \n"
"Dynamic memory allocation on [the heap](memory-management/stack-vs-heap.md)."
msgstr ""
"分配：\n"
"指在 [堆](memory-management/stack-vs-heap.md) 上进行动态内存分配。"

#: src/glossary.md
msgid ""
"argument:  \n"
"Information that is passed into a function or method."
msgstr ""
"参数：\n"
"指传入某个函数或方法中的信息。"

#: src/glossary.md
msgid ""
"Bare-metal Rust:  \n"
"Low-level Rust development, often deployed to a system without an operating "
"system. See [Bare-metal Rust](bare-metal.md)."
msgstr ""
"裸机 Rust：\n"
"一种低级别的 Rust 开发方式，通常部署于没有操作系统的系统。请参阅 [裸机 Rust]"
"(bare-metal.md)。"

#: src/glossary.md
msgid ""
"block:  \n"
"See [Blocks](control-flow/blocks.md) and _scope_."
msgstr ""
"代码块：\n"
"请参阅 [代码块](control-flow/blocks.md) 和 _作用域_。"

#: src/glossary.md
msgid ""
"borrow:  \n"
"See [Borrowing](ownership/borrowing.md)."
msgstr ""
"借用：\n"
"请参阅 [借用](ownership/borrowing.md)。"

#: src/glossary.md
msgid ""
"borrow checker:  \n"
"The part of the Rust compiler which checks that all borrows are valid."
msgstr ""
"借用检查器：\n"
"Rust 编译器的一部分，用于检查所有借用操作是否有效。"

#: src/glossary.md
msgid ""
"brace:  \n"
"`{` and `}`. Also called _curly brace_, they delimit _blocks_."
msgstr ""
"括号：\n"
"`{` and `}`。也称为 _大括号_，用于分隔 _代码块_。"

#: src/glossary.md
msgid ""
"build:  \n"
"The process of converting source code into executable code or a usable "
"program."
msgstr ""
"build：\n"
" 将源代码转换为可执行代码或可用程序的过程。"

#: src/glossary.md
msgid ""
"call:  \n"
"To invoke or execute a function or method."
msgstr ""
"调用：\n"
"调用或执行某个函数或方法。"

#: src/glossary.md
msgid ""
"channel:  \n"
"Used to safely pass messages [between threads](concurrency/channels.md)."
msgstr ""
"通道：\n"
"用于安全地 [在线程之间](concurrency/channels.md) 传递消息。"

#: src/glossary.md
#, fuzzy
msgid ""
"Comprehensive Rust 🦀:  \n"
"The courses here are jointly called Comprehensive Rust 🦀."
msgstr "欢迎来到 Comprehensive Rust 🦀"

#: src/glossary.md
msgid ""
"concurrency:  \n"
"The execution of multiple tasks or processes at the same time."
msgstr ""
"并发：\n"
"同时执行多个任务或进程。"

#: src/glossary.md
#, fuzzy
msgid ""
"Concurrency in Rust:  \n"
"See [Concurrency in Rust](concurrency.md)."
msgstr "欢迎了解 Rust 中的并发"

#: src/glossary.md
msgid ""
"constant:  \n"
"A value that does not change during the execution of a program."
msgstr ""
"常量：\n"
"在程序执行期间不会发生的值。"

#: src/glossary.md
msgid ""
"control flow:  \n"
"The order in which the individual statements or instructions are executed in "
"a program."
msgstr ""
"控制流：\n"
"程序中各个语句或指令的执行顺序。"

#: src/glossary.md
msgid ""
"crash:  \n"
"An unexpected and unhandled failure or termination of a program."
msgstr ""
"崩溃：\n"
"未处理的意外故障或程序终止。"

#: src/glossary.md
#, fuzzy
msgid ""
"enumeration:  \n"
"A data type that holds one of several named constants, possibly with an "
"associated tuple or struct."
msgstr ""
"枚举：\n"
"一种由命名常量值组成的数据类型。"

#: src/glossary.md
msgid ""
"error:  \n"
"An unexpected condition or result that deviates from the expected behavior."
msgstr ""
"错误：\n"
"与预期行为存在偏差的意外情况或结果。"

#: src/glossary.md
msgid ""
"error handling:  \n"
"The process of managing and responding to errors that occur during program "
"execution."
msgstr ""
"错误处理：\n"
"对程序执行期间发生的错误进行管理和响应的过程。"

#: src/glossary.md
msgid ""
"exercise:  \n"
"A task or problem designed to practice and test programming skills."
msgstr ""
"练习：\n"
"专为练习和测试编程技能而设计的任务或问题。"

#: src/glossary.md
msgid ""
"function:  \n"
"A reusable block of code that performs a specific task."
msgstr ""
"函数：\n"
"用于执行特定任务且可重复使用的代码块。"

#: src/glossary.md
msgid ""
"garbage collector:  \n"
"A mechanism that automatically frees up memory occupied by objects that are "
"no longer in use."
msgstr ""
"垃圾回收器：\n"
"一种自动释放不再使用的对象所占内存的机制。"

#: src/glossary.md
msgid ""
"generics:  \n"
"A feature that allows writing code with placeholders for types, enabling "
"code reuse with different data types."
msgstr ""
"泛型：\n"
"这项功能支持使用类型占位符编写代码，支持对不同数据类型的代码进行重复使用。"

#: src/glossary.md
msgid ""
"immutable:  \n"
"Unable to be changed after creation."
msgstr ""
"不可变：\n"
"创建后无法再进行更改。"

#: src/glossary.md
msgid ""
"integration test:  \n"
"A type of test that verifies the interactions between different parts or "
"components of a system."
msgstr ""
"集成测试：\n"
"一种测试，用于验证系统的不同部分或组件之间是否能够交互。"

#: src/glossary.md
msgid ""
"keyword:  \n"
"A reserved word in a programming language that has a specific meaning and "
"cannot be used as an identifier."
msgstr ""
"关键字：\n"
"编程语言中的保留字，具有特定含义且不能用作标识符。"

#: src/glossary.md
msgid ""
"library:  \n"
"A collection of precompiled routines or code that can be used by programs."
msgstr ""
"库：\n"
"程序可以使用的一组预编译例程或代码。"

#: src/glossary.md
msgid ""
"macro:  \n"
"Rust macros can be recognized by a `!` in the name. Macros are used when "
"normal functions are not enough. A typical example is `format!`, which takes "
"a variable number of arguments, which isn't supported by Rust functions."
msgstr ""
"宏：\n"
"Rust 宏可通过名称中的 `!` 符号识别。当普通函数无法满足需求时，可以使用宏。一"
"个典型示例是 `format!`，其接受可变数量的参数，但 Rust 函数不支持这种类型。"

#: src/glossary.md
msgid ""
"`main` function:  \n"
"Rust programs start executing with the `main` function."
msgstr ""
"`main` 函数：\n"
"Rust 程序使用 `main` 函数开始执行操作。"

#: src/glossary.md
msgid ""
"match:  \n"
"A control flow construct in Rust that allows for pattern matching on the "
"value of an expression."
msgstr ""
"匹配：\n"
"Rust 中的控制流结构，允许对表达式的值进行模式匹配。"

#: src/glossary.md
msgid ""
"memory leak:  \n"
"A situation where a program fails to release memory that is no longer "
"needed, leading to a gradual increase in memory usage."
msgstr ""
"内存泄漏：\n"
"指程序无法释放不再不要的内存的情况，导致内存用量不断增加。"

#: src/glossary.md
msgid ""
"method:  \n"
"A function associated with an object or a type in Rust."
msgstr ""
"方法：\n"
"与 Rust 中的某个对象或类型相关联的函数。"

#: src/glossary.md
msgid ""
"module:  \n"
"A namespace that contains definitions, such as functions, types, or traits, "
"to organize code in Rust."
msgstr ""
"模块：\n"
"Rust 中用于归纳整理代码的命名空间，其中包含函数、类型或特性等定义。"

#: src/glossary.md
msgid ""
"move:  \n"
"The transfer of ownership of a value from one variable to another in Rust."
msgstr ""
"移动：\n"
"在 Rust 中，将值的所有权从一个变量转移到另一个变量。"

#: src/glossary.md
msgid ""
"mutable:  \n"
"A property in Rust that allows variables to be modified after they have been "
"declared."
msgstr ""
"可变：\n"
"Rust 中的一个属性，支持在声明变量后对其进行修改。"

#: src/glossary.md
msgid ""
"ownership:  \n"
"The concept in Rust that defines which part of the code is responsible for "
"managing the memory associated with a value."
msgstr ""
"所有权：\n"
"Rust 中的概念，用于定义代码中的哪一部分负责管理与值关联的内存。"

#: src/glossary.md
msgid ""
"panic:  \n"
"An unrecoverable error condition in Rust that results in the termination of "
"the program."
msgstr ""
"panic：\n"
"Rust 中导致程序终止且不可恢复的错误情况。"

#: src/glossary.md
msgid ""
"parameter:  \n"
"A value that is passed into a function or method when it is called."
msgstr ""
"参数：\n"
"在调用函数或方法时传入函数或方法的值。"

#: src/glossary.md
msgid ""
"pattern:  \n"
"A combination of values, literals, or structures that can be matched against "
"an expression in Rust."
msgstr ""
"模式：\n"
"Rust 中可与表达式匹配的值、字面量或结构的组合。"

#: src/glossary.md
msgid ""
"payload:  \n"
"The data or information carried by a message, event, or data structure."
msgstr ""
"载荷：\n"
"消息、事件或数据结构所携带的数据或信息。"

#: src/glossary.md
msgid ""
"program:  \n"
"A set of instructions that a computer can execute to perform a specific task "
"or solve a particular problem."
msgstr ""
"程序：\n"
"计算机为执行特定任务或解决特定问题而执行的一组指令。"

#: src/glossary.md
msgid ""
"programming language:  \n"
"A formal system used to communicate instructions to a computer, such as Rust."
msgstr ""
"编程语言：\n"
"用于向计算机传递指令的正式系统，例如 Rust。"

#: src/glossary.md
msgid ""
"receiver:  \n"
"The first parameter in a Rust method that represents the instance on which "
"the method is called."
msgstr ""
"接收器：\n"
"Rust 方法中的首个参数，表示正在调用该方法的实例。"

#: src/glossary.md
msgid ""
"reference counting:  \n"
"A memory management technique in which the number of references to an object "
"is tracked, and the object is deallocated when the count reaches zero."
msgstr ""
"引用计数：\n"
"一种内存管理方法，可以跟踪某个对象的引用数量，并在计数为零时释放该对象。"

#: src/glossary.md
msgid ""
"return:  \n"
"A keyword in Rust used to indicate the value to be returned from a function."
msgstr ""
"返回：\n"
"Rust 中的一个关键字，用于表示从函数返回的值。"

#: src/glossary.md
msgid ""
"Rust:  \n"
"A systems programming language that focuses on safety, performance, and "
"concurrency."
msgstr ""
"Rust：\n"
"一种系统编程语言，专注于安全性、性能和并发性。"

#: src/glossary.md
msgid ""
"Rust Fundamentals:  \n"
"Days 1 to 3 of this course."
msgstr ""
"Rust 基础知识：\n"
" 本课程第 1 天到第 3 天的授课内容。"

#: src/glossary.md
#, fuzzy
msgid ""
"Rust in Android:  \n"
"See [Rust in Android](android.md)."
msgstr "欢迎来到Android 中的Rust"

#: src/glossary.md
#, fuzzy
msgid ""
"Rust in Chromium:  \n"
"See [Rust in Chromium](chromium.md)."
msgstr "欢迎来到Android 中的Rust"

#: src/glossary.md
msgid ""
"safe:  \n"
"Refers to code that adheres to Rust's ownership and borrowing rules, "
"preventing memory-related errors."
msgstr ""
"安全：\n"
"指代码遵循 Rust 的所有权和借用规则，以防止出现与内存相关的错误。"

#: src/glossary.md
msgid ""
"scope:  \n"
"The region of a program where a variable is valid and can be used."
msgstr ""
"作用域：\n"
"程序中变量有效且可使用的区域。"

#: src/glossary.md
msgid ""
"standard library:  \n"
"A collection of modules providing essential functionality in Rust."
msgstr ""
"标准库：\n"
"Rust 中提供基本功能的一系列模块。"

#: src/glossary.md
msgid ""
"static:  \n"
"A keyword in Rust used to define static variables or items with a `'static` "
"lifetime."
msgstr ""
"静态：\n"
"Rust 中的关键字，用于定义具有 `'static` 生命周期的静态变量或项。"

#: src/glossary.md
msgid ""
"string:  \n"
"A data type storing textual data. See [`String` vs `str`](basic-syntax/"
"string-slices.html) for more."
msgstr ""
"字符串：\n"
"一种存储文本数据的数据类型。如需了解详情，请参阅 [`String` 与 `str`](basic-"
"syntax/string-slices.html)。"

#: src/glossary.md
msgid ""
"struct:  \n"
"A composite data type in Rust that groups together variables of different "
"types under a single name."
msgstr ""
"结构体：\n"
"Rust 中的复合数据类型，可将不同类型的变量归到同一名称下。"

#: src/glossary.md
msgid ""
"test:  \n"
"A Rust module containing functions that test the correctness of other "
"functions."
msgstr ""
"test：\n"
"Rust 中的模块，其中包含用于测试其他函数是否正确的函数。"

#: src/glossary.md
msgid ""
"thread:  \n"
"A separate sequence of execution in a program, allowing concurrent execution."
msgstr ""
"线程：\n"
"程序中的单独执行顺序，支持并发执行。"

#: src/glossary.md
msgid ""
"thread safety:  \n"
"The property of a program that ensures correct behavior in a multithreaded "
"environment."
msgstr ""
"线程安全：\n"
"一种程序属性，用于确保多线程环境中的行为正确无误。"

#: src/glossary.md
msgid ""
"trait:  \n"
"A collection of methods defined for an unknown type, providing a way to "
"achieve polymorphism in Rust."
msgstr ""
"trait：\n"
"用于定义未知类型的一系列方法，为在 Rust 中实现多态性提供了方法。"

#: src/glossary.md
msgid ""
"trait bound:  \n"
"An abstraction where you can require types to implement some traits of your "
"interest."
msgstr ""

#: src/glossary.md
#, fuzzy
msgid ""
"tuple:  \n"
"A composite data type that contains variables of different types. Tuple "
"fields have no names, and are accessed by their ordinal numbers."
msgstr ""
"结构体：\n"
"Rust 中的复合数据类型，可将不同类型的变量归到同一名称下。"

#: src/glossary.md
msgid ""
"type:  \n"
"A classification that specifies which operations can be performed on values "
"of a particular kind in Rust."
msgstr ""
"类型：\n"
"一种分类方式，用于指定可以对 Rust 中特定类型的值执行哪些操作。"

#: src/glossary.md
msgid ""
"type inference:  \n"
"The ability of the Rust compiler to deduce the type of a variable or "
"expression."
msgstr ""
"类型推理：\n"
"Rust 编译器能够推断变量或表达式的类型。"

#: src/glossary.md
msgid ""
"undefined behavior:  \n"
"Actions or conditions in Rust that have no specified result, often leading "
"to unpredictable program behavior."
msgstr ""
"未定义的行为：\n"
"Rust 中未指定结果的操作或条件，通常会导致不可预测的程序行为。"

#: src/glossary.md
msgid ""
"union:  \n"
"A data type that can hold values of different types but only one at a time."
msgstr ""
"并集：\n"
"一种数据类型，可以存储不同类型的值，但一次只能保存一个值。"

#: src/glossary.md
msgid ""
"unit test:  \n"
"Rust comes with built-in support for running small unit tests and larger "
"integration tests. See [Unit Tests](testing/unit-tests.html)."
msgstr ""
"单元测试：\n"
"Rust 内置了运行小型单元测试和大型集成测试的支持功能。请参阅 [单元测试]"
"(testing/unit-tests.html)。"

#: src/glossary.md
msgid ""
"unit type:  \n"
"Type that holds no data, written as a tuple with no members."
msgstr ""

#: src/glossary.md
msgid ""
"unsafe:  \n"
"The subset of Rust which allows you to trigger _undefined behavior_. See "
"[Unsafe Rust](unsafe.html)."
msgstr ""
"不安全：\n"
"Rust 的子集，允许您触发 _未定义_ 的行为。请参阅 [不安全 Rust](unsafe.html)。"

#: src/glossary.md
#, fuzzy
msgid ""
"variable:  \n"
"A memory location storing data. Variables are valid in a _scope_."
msgstr ""
"变量：\n"
"用于存储数据的内存位置。变量在 _作用域_ 内有效。"

#: src/other-resources.md
msgid "Other Rust Resources"
msgstr "其他 Rust 资源"

#: src/other-resources.md
msgid ""
"The Rust community has created a wealth of high-quality and free resources "
"online."
msgstr "Rust 社区已经创造了丰富的高质量免费资源在线提供。"

#: src/other-resources.md
msgid "Official Documentation"
msgstr "官方文档"

#: src/other-resources.md
msgid "The Rust project hosts many resources. These cover Rust in general:"
msgstr "Rust 项目提供了许多资源。这些资源涵盖了 Rust 的一般内容："

#: src/other-resources.md
msgid ""
"[The Rust Programming Language](https://doc.rust-lang.org/book/): the "
"canonical free book about Rust. Covers the language in detail and includes a "
"few projects for people to build."
msgstr ""
"[Rust 程序设计语言](https://doc.rust-lang.org/book/)：一部有关 Rust 的免费权"
"威图书。书中详细介绍了该语言，并包含一些可供读者构建的项目。"

#: src/other-resources.md
msgid ""
"[Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the "
"Rust syntax via a series of examples which showcase different constructs. "
"Sometimes includes small exercises where you are asked to expand on the code "
"in the examples."
msgstr ""
"[通过例子学 Rust](https://doc.rust-lang.org/rust-by-example/)：通过一系列展示"
"不同结构的示例介绍 Rust 语法。有时会包括一些小练习，会要求您充分地阐述示例中"
"的代码。"

#: src/other-resources.md
msgid ""
"[Rust Standard Library](https://doc.rust-lang.org/std/): full documentation "
"of the standard library for Rust."
msgstr "[Rust 标准库](https://doc.rust-lang.org/std/)：Rust 标准库的完整文档。"

#: src/other-resources.md
msgid ""
"[The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete "
"book which describes the Rust grammar and memory model."
msgstr ""
"[Rust 参考手册](https://doc.rust-lang.org/reference/)：一本未完成的书，介绍"
"了 Rust 语法和内存模型。"

#: src/other-resources.md
msgid "More specialized guides hosted on the official Rust site:"
msgstr "Rust 官方网站上有更多专业指南："

#: src/other-resources.md
msgid ""
"[The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust, "
"including working with raw pointers and interfacing with other languages "
"(FFI)."
msgstr ""
"[Rust 秘典](https://doc.rust-lang.org/nomicon/)：介绍了不安全 Rust，包括使用"
"原始指针以及与其他语言 (FFI) 交互。"

#: src/other-resources.md
msgid ""
"[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/): "
"covers the new asynchronous programming model which was introduced after the "
"Rust Book was written."
msgstr ""
"[Rust 中的异步编程](https://rust-lang.github.io/async-book/)：介绍了在《Rust "
"程序设计语言》成书后引入的新异步编程模型。"

#: src/other-resources.md
msgid ""
"[The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): "
"an introduction to using Rust on embedded devices without an operating "
"system."
msgstr ""
"[嵌入式 Rust 之书](https://doc.rust-lang.org/stable/embedded-book/)：介绍如何"
"在没有操作系统的嵌入式设备上使用 Rust。"

#: src/other-resources.md
msgid "Unofficial Learning Material"
msgstr "非官方学习资料"

#: src/other-resources.md
msgid "A small selection of other guides and tutorial for Rust:"
msgstr "其他 Rust 指南和教程的小选集："

#: src/other-resources.md
msgid ""
"[Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust "
"from the perspective of low-level C programmers."
msgstr ""
"[Learn Rust the Dangerous Way（以危险的方式学 Rust）](http://cliffle.com/p/"
"dangerust/)：从低级 C 语言程序员的角度介绍 Rust。"

#: src/other-resources.md
msgid ""
"[Rust for Embedded C Programmers](https://docs.opentitan.org/doc/ug/"
"rust_for_c/): covers Rust from the perspective of developers who write "
"firmware in C."
msgstr ""
"[面向嵌入式 C 程序员的 Rust](https://docs.opentitan.org/doc/ug/rust_for_c/)："
"从使用 C 语言编写固件的开发者的角度介绍 Rust。"

#: src/other-resources.md
msgid ""
"[Rust for professionals](https://overexact.com/rust-for-professionals/): "
"covers the syntax of Rust using side-by-side comparisons with other "
"languages such as C, C++, Java, JavaScript, and Python."
msgstr ""
"[Rust for professionals（面向专业人士的 Rust）](https://overexact.com/rust-"
"for-professionals/)：通过与其他语言（例如 C、C++、Java、JavaScript 和 "
"Python）进行并排比较，介绍 Rust 的语法。"

#: src/other-resources.md
msgid ""
"[Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help "
"you learn Rust."
msgstr ""
"[Rust on Exercism（在 Exercism 上学 Rust）](https://exercism.org/tracks/"
"rust)：100 多项练习助您学习 Rust。"

#: src/other-resources.md
msgid ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html): a series of small presentations covering both basic "
"and advanced part of the Rust language. Other topics such as WebAssembly, "
"and async/await are also covered."
msgstr ""
"[Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-"
"material/index.html)：一系列小演示文稿，涵盖 Rust 语言的基础知识和高级部分。"
"还涵盖了 WebAssembly 和 async/await 等其他主题。"

#: src/other-resources.md
msgid ""
"[Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-"
"series-to-rust/) and [Take your first steps with Rust](https://docs."
"microsoft.com/en-us/learn/paths/rust-first-steps/): two Rust guides aimed at "
"new developers. The first is a set of 35 videos and the second is a set of "
"11 modules which covers Rust syntax and basic constructs."
msgstr ""
"[面向 Rust 的初学者系列](https://docs.microsoft.com/zh-cn/shows/beginners-"
"series-to-rust/)和[使用 Rust 迈出第一步](https://docs.microsoft.com/zh-cn/"
"learn/paths/rust-first-steps/)：两个面向新手开发者的 Rust 指南。第一个指南包"
"含 35 个视频，第二个指南包含 11 个模块，内容涵盖 Rust 语法和基本结构。"

#: src/other-resources.md
msgid ""
"[Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial."
"github.io/too-many-lists/): in-depth exploration of Rust's memory management "
"rules, through implementing a few different types of list structures."
msgstr ""
"[通过大量的链表学习Rust](https://rust-unofficial.github.io/too-many-lists/)："
"通过实现几种不同类型的列表结构，深入探索 Rust 的内存管理规则。"

#: src/other-resources.md
msgid ""
"Please see the [Little Book of Rust Books](https://lborb.github.io/book/) "
"for even more Rust books."
msgstr ""
"如需更多 Rust 图书，请查看 [Rust 小册](https://lborb.github.io/book/)。"

#: src/credits.md
msgid ""
"The material here builds on top of the many great sources of Rust "
"documentation. See the page on [other resources](other-resources.md) for a "
"full list of useful resources."
msgstr ""
"本课中的资料以众多优秀的 Rust 文档资源为基础。 如需查看实用资源的完整列表， "
"请参阅关于[其他资源](other-resources.md)的页面。"

#: src/credits.md
#, fuzzy
msgid ""
"The material of Comprehensive Rust is licensed under the terms of the Apache "
"2.0 license, please see [`LICENSE`](https://github.com/google/comprehensive-"
"rust/blob/main/LICENSE) for details."
msgstr ""
"我们根据 Apache 2.0 许可条款 授权你使用“全面了解 Rust”（Comprehensive Rust）"
"的资料。如需了解详情，请参阅[`许可`](../LICENSE)。"

#: src/credits.md
msgid "Rust by Example"
msgstr "Rust 示例"

#: src/credits.md
msgid ""
"Some examples and exercises have been copied and adapted from [Rust by "
"Example](https://doc.rust-lang.org/rust-by-example/). Please see the "
"`third_party/rust-by-example/` directory for details, including the license "
"terms."
msgstr ""
"部分示例和练习复制并 改编自[Rust by Example](https://doc.rust-lang.org/rust-"
"by-example/)。如需了解详情（包括许可 条款），请参阅 `third_party/rust-by-"
"example/` 目录。"

#: src/credits.md
msgid "Rust on Exercism"
msgstr "Rust on Exercism"

#: src/credits.md
msgid ""
"Some exercises have been copied and adapted from [Rust on Exercism](https://"
"exercism.org/tracks/rust). Please see the `third_party/rust-on-exercism/` "
"directory for details, including the license terms."
msgstr ""
"部分练习复制并 改编自 [Rust on Exercism](https://exercism.org/tracks/rust)。"
"如需了解详情（包括许可 条款），请参阅 `third_party/rust-on-exercism/` 目录。"

#: src/credits.md
msgid "CXX"
msgstr "CXX"

#: src/credits.md
msgid ""
"The [Interoperability with C++](android/interoperability/cpp.md) section "
"uses an image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` "
"directory for details, including the license terms."
msgstr ""
"“[与 C++ 的互操作性](android/interoperability/cpp.md)”部分引用了一张 来自 "
"[CXX](https://cxx.rs/) 的图片。如需了解详情（包括许可条款）， 请参阅 "
"`third_party/cxx/` 目录。"

#, fuzzy
#~ msgid "Exercise: GUI Library"
#~ msgstr "练习：面向 GUI 库的模块"

#, fuzzy
#~ msgid "With C++)"
#~ msgstr "与 C++ 交互"

#, fuzzy
#~ msgid "{{%course outline Fundamentals}}"
#~ msgstr "Rust 基础知识"

#~ msgid "{{%session outline}}"
#~ msgstr "{{%s课程大纲}}"

#~ msgid "{{%segment outline}}"
#~ msgstr "{{%s小节大纲}}"

#~ msgid ""
#~ "Let us design a classical GUI library using our new knowledge of traits "
#~ "and trait objects. We'll only implement the drawing of it (as text) for "
#~ "simplicity."
#~ msgstr ""
#~ "让我们利用关于 trait 和 trait 对象的新知识，设计一个经典的 GUI 库。为简单"
#~ "起见，我们仅以文本形式实现绘制。"

#~ msgid "We will have a number of widgets in our library:"
#~ msgstr "我们的库中有许多 widget："

#~ msgid "`Window`: has a `title` and contains other widgets."
#~ msgstr "“Window”：具有“title”且包含其他 widget。"

#~ msgid ""
#~ "`Button`: has a `label`. In reality, it would also take a callback "
#~ "function to allow the program to do something when the button is clicked "
#~ "but we won't include that since we're only drawing the GUI."
#~ msgstr ""
#~ "`Button`：上面有一个 `Label`。实际上，它还需要一个回调函数，以便程序在用户"
#~ "点击按钮时执行某些操作，但由于我们仅绘制 GUI，所以不会添加该函数。"

#~ msgid "`Label`: has a `label`."
#~ msgstr "“Label”：具有“label”。"

#~ msgid "The widgets will implement a `Widget` trait, see below."
#~ msgstr "这些 widget 将实现“Widget”trait，如下所示。"

#~ msgid ""
#~ "Copy the code below to <https://play.rust-lang.org/>, fill in the missing "
#~ "`draw_into` methods so that you implement the `Widget` trait:"
#~ msgstr ""
#~ "将以下代码复制到 <https://play.rust-lang.org/>，然后填入缺少"
#~ "的“draw_into”方法，以便实现“Widget”trait："

#~ msgid "// TODO: Implement `Widget` for `Label`.\n"
#~ msgstr "// TODO: Implement `Widget` for `Label`.\n"

#~ msgid "// TODO: Implement `Widget` for `Button`.\n"
#~ msgstr "// TODO: Implement `Widget` for `Button`.\n"

#~ msgid "// TODO: Implement `Widget` for `Window`.\n"
#~ msgstr "// TODO: Implement `Widget` for `Window`.\n"

#~ msgid "The output of the above program can be something simple like this:"
#~ msgstr "上述程序的输出可能非常简单，例如："

#~ msgid ""
#~ "If you want to draw aligned text, you can use the [fill/alignment]"
#~ "(https://doc.rust-lang.org/std/fmt/index.html#fillalignment) formatting "
#~ "operators. In particular, notice how you can pad with different "
#~ "characters (here a `'/'`) and how you can control alignment:"
#~ msgstr ""
#~ "如果要绘制对齐的文本，可以使用[填充/对齐](https://doc.rust-lang.org/std/"
#~ "fmt/index.html#fillalignment)格式设置运算符。需要特别注意的是您填充不同字"
#~ "符（此处是“/”）的方式以及控制对齐的方式："

#~ msgid "\"left aligned:  |{:/<width$}|\""
#~ msgstr "\"left aligned:  |{:/<width$}|\""

#~ msgid "\"centered:      |{:/^width$}|\""
#~ msgstr "\"centered:      |{:/^width$}|\""

#~ msgid "\"right aligned: |{:/>width$}|\""
#~ msgstr "\"right aligned: |{:/>width$}|\""

#~ msgid ""
#~ "Using such alignment tricks, you can for example produce output like this:"
#~ msgstr "使用这些对齐技巧，您可以生成如下的输出内容："

#, fuzzy
#~ msgid ""
#~ "Rust provides a few safe means of modifying a value given only a shared "
#~ "reference to that value. All of these replace compile-time checks with "
#~ "runtime checks."
#~ msgstr ""
#~ "Rust 提供了一些安全的方法，只需对指定值拥有共享引用，即可修改该值。所有这"
#~ "些方法都用运行时检查取代了编译时检查。"

#~ msgid "`Cell` and `RefCell`"
#~ msgstr "“Cell”和“RefCell”"

#, fuzzy
#~ msgid ""
#~ "[`Cell`](https://doc.rust-lang.org/std/cell/struct.Cell.html) and "
#~ "[`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) "
#~ "implement what Rust calls _interior mutability:_ mutation of values in an "
#~ "immutable context."
#~ msgstr ""
#~ "您可以使用 [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) 和 "
#~ "[`BufRead`](https://doc.rust-lang.org/std/io/trait.BufRead.html) 对 `u8` "
#~ "来源进行抽象化处理："

#~ msgid ""
#~ "`Cell` is typically used for simple types, as it requires copying or "
#~ "moving values. More complex interior types typically use `RefCell`, which "
#~ "tracks shared and exclusive references at runtime and panics if they are "
#~ "misused."
#~ msgstr ""
#~ "“Cell”通常用于简单类型，因为它需要复制或移动值。更复杂的内部类型通常使"
#~ "用“RefCell”，它会在运行时跟踪已共享和专有的引用，并在这些引用被滥用时 "
#~ "panic。"

#~ msgid ""
#~ "If we were using `Cell` instead of `RefCell` in this example, we would "
#~ "have to move the `Node` out of the `Rc` to push children, then move it "
#~ "back in. This is safe because there's always one, un-referenced value in "
#~ "the cell, but it's not ergonomic."
#~ msgstr ""
#~ "在此示例中，如果我们使用的是“Cell”而非“RefCell”，则必须将“Node”从“Rc”中移"
#~ "出以推送子项，然后再将其移回原位。这是安全的做法，因为单元格中总是有一个未"
#~ "引用的值，但这不符合人体工程学。"

#~ msgid ""
#~ "To do anything with a Node, you must call a `RefCell` method, usually "
#~ "`borrow` or `borrow_mut`."
#~ msgstr ""
#~ "如需使用 Node 执行任何操作，您必须调用“RefCell”方法，通常"
#~ "为“borrow”或“borrow_mut”。"

#~ msgid ""
#~ "If you no longer have your version, that's fine - refer back to the "
#~ "[provided solution](../methods-and-traits/solution.html)."
#~ msgstr ""
#~ "如果您的版本已不存在，也没关系，请参阅 [提供的解决方案](../methods-and-"
#~ "traits/solution.html)。"

#~ msgid ""
#~ "When you await a future, all local variables (that would ordinarily be "
#~ "stored on a stack frame) are instead stored in the Future for the current "
#~ "async block. If your future has pointers to data on the stack, those "
#~ "pointers might get invalidated. This is unsafe."
#~ msgstr ""
#~ "在等待 Future 就绪时，所有局部变量（通常存储在堆栈帧上）将改为存储在当前异"
#~ "步代码块的 Future 中。如果您的 Future 中有指向堆栈上数据的指针，这些指针可"
#~ "能会失效。这很不安全。"

#~ msgid ""
#~ "Therefore, you must guarantee that the addresses your future points to "
#~ "don't change. That is why we need to \"pin\" futures. Using the same "
#~ "future repeatedly in a `select!` often leads to issues with pinned values."
#~ msgstr ""
#~ "因此，必须保证 Future 指向的地址不会发生更改。这就是为何需要对 Future 执"
#~ "行 “固定”操作。在 `select!` 中反复使用相同的 Future 通常会导致已固定的值出"
#~ "现问题。"

#~ msgid "Small Example"
#~ msgstr "简短示例"

#~ msgid "An Example in C"
#~ msgstr "C语言示例"

#~ msgid "Compile Time Guarantees"
#~ msgstr "编译期保障"

#~ msgid "Runtime Guarantees"
#~ msgstr "运行时保障"

#~ msgid "Modern Features"
#~ msgstr "现代特性"

#~ msgid "Basic Syntax"
#~ msgstr "基本语法"

#~ msgid "String vs str"
#~ msgstr "String vs str"

#~ msgid "Rustdoc"
#~ msgstr "Rustdoc"

#~ msgid "Overloading"
#~ msgstr "重载"

#~ msgid "Arrays and for Loops"
#~ msgstr "数组与 for 循环"

#~ msgid "if expressions"
#~ msgstr "if 表达式"

#~ msgid "for expressions"
#~ msgstr "for 表达式"

#~ msgid "while expressions"
#~ msgstr "while 表达式"

#~ msgid "break & continue"
#~ msgstr "break & continue"

#~ msgid "loop expressions"
#~ msgstr "loop 表达式"

#~ msgid "Variant Payloads"
#~ msgstr "变体载荷"

#~ msgid "Enum Sizes"
#~ msgstr "枚举大小"

#~ msgid "if let expressions"
#~ msgstr "if let 表达式"

#~ msgid "while let expressions"
#~ msgstr "while let 表达式"

#~ msgid "match expressions"
#~ msgstr "match 表达式"

#~ msgid "Destructuring Structs"
#~ msgstr "解构结构体"

#~ msgid "Destructuring Arrays"
#~ msgstr "解构数组"

#~ msgid "Match Guards"
#~ msgstr "匹配守卫"

#~ msgid "Stack vs Heap"
#~ msgstr "栈 vs 堆"

#~ msgid "Stack Memory"
#~ msgstr "栈内存"

#~ msgid "Manual Memory Management"
#~ msgstr "手动内存管理"

#~ msgid "Scope-Based Memory Management"
#~ msgstr "基于作用域的内存管理"

#~ msgid "Garbage Collection"
#~ msgstr "垃圾回收"

#~ msgid "Rust Memory Management"
#~ msgstr "Rust 内存管理"

#~ msgid "Moved Strings in Rust"
#~ msgstr "Rust 中移动的字符串"

#~ msgid "Double Frees in Modern C++"
#~ msgstr "现代 C++ 中的双重释放"

#~ msgid "Moves in Function Calls"
#~ msgstr "函数调用中的移动"

#~ msgid "Copying and Cloning"
#~ msgstr "复制和克隆"

#~ msgid "Shared and Unique Borrows"
#~ msgstr "共享和唯一的借用"

#~ msgid "Field Shorthand Syntax"
#~ msgstr "字段简写语法"

#~ msgid "Method Receiver"
#~ msgstr "方法接收者"

#~ msgid "Storing Books"
#~ msgstr "书籍存储"

#~ msgid "Option and Result"
#~ msgstr "Option 和 Result"

#~ msgid "Vec"
#~ msgstr "Vec"

#~ msgid "HashMap"
#~ msgstr "哈希表"

#~ msgid "Box"
#~ msgstr "Box"

#~ msgid "Recursive Data Types"
#~ msgstr "递归数据类型"

#~ msgid "Rc"
#~ msgstr "Rc"

#~ msgid "Cell/RefCell"
#~ msgstr "Cell/RefCell"

#~ msgid "Iterators and Ownership"
#~ msgstr "迭代器和所有权"

#~ msgid "Strings and Iterators"
#~ msgstr "字符串和迭代器"

#~ msgid "Generic Methods"
#~ msgstr "泛型方法"

#~ msgid "Monomorphization"
#~ msgstr "单态化"

#~ msgid "Default Methods"
#~ msgstr "默认方法"

#~ msgid "impl Trait"
#~ msgstr "impl Trait"

#~ msgid "Important Traits"
#~ msgstr "重要特征"

#~ msgid "From and Into"
#~ msgstr "From 和 Into"

#~ msgid "Default"
#~ msgstr "Default"

#~ msgid "Operators: Add, Mul, ..."
#~ msgstr "运算符：Add、Mul..."

#~ msgid "Closures: Fn, FnMut, FnOnce"
#~ msgstr "闭包：Fn、FnMut、FnOnce"

#~ msgid "Points and Polygons"
#~ msgstr "点和多边形"

#~ msgid "Catching Stack Unwinding"
#~ msgstr "捕获堆栈展开"

#~ msgid "Structured Error Handling"
#~ msgstr "结构化错误处理"

#~ msgid "Propagating Errors with ?"
#~ msgstr "使用 ? 传播错误"

#~ msgid "Converting Error Types"
#~ msgstr "转换错误类型"

#~ msgid "Deriving Error Enums"
#~ msgstr "派生错误枚举"

#~ msgid "Adding Context to Errors"
#~ msgstr "为错误添加背景信息"

#~ msgid "no_std"
#~ msgstr "no_std"

#~ msgid "alloc"
#~ msgstr "alloc"

#, fuzzy
#~ msgid "embedded-hal"
#~ msgstr "embedded-hal"

#~ msgid "zerocopy"
#~ msgstr "zerocopy"

#~ msgid "buddy_system_allocator"
#~ msgstr "buddy_system_allocator"

#~ msgid "tinyvec"
#~ msgstr "tinyvec"

#~ msgid "spin"
#~ msgstr "转动"

#~ msgid "Send and Sync"
#~ msgstr "Send 和 Sync"

#~ msgid "Send"
#~ msgstr "Send"

#~ msgid "Sync"
#~ msgstr "Sync"

#~ msgid "Arc"
#~ msgstr "Arc"

#~ msgid "Mutex"
#~ msgstr "Mutex"

#~ msgid "Pin"
#~ msgstr "固定"

#~ msgid "Day 1 Morning"
#~ msgstr "第一天上午"

#~ msgid "Day 1 Afternoon"
#~ msgstr "第一天下午"

#~ msgid "Day 2 Morning"
#~ msgstr "第二天上午"

#~ msgid "Day 2 Afternoon"
#~ msgstr "第二天下午"

#~ msgid "Day 3 Morning"
#~ msgstr "第三天上午"

#~ msgid "Day 3 Afternoon"
#~ msgstr "第三天下午"

#~ msgid "Bare Metal Rust Morning"
#~ msgstr "嵌入式 Rust：入门篇"

#~ msgid "Concurrency Morning"
#~ msgstr "并发编程：入门篇"

#~ msgid "Concurrency Afternoon"
#~ msgstr "并发编程：进阶篇"

#~ msgid ""
#~ "Day 1: Basic Rust, syntax, control flow, creating and consuming values."
#~ msgstr "第 1 天：Rust 基础知识、语法、控制流、创建及使用值。"

#~ msgid ""
#~ "Day 2: Memory management, ownership, compound data types, and the "
#~ "standard library."
#~ msgstr "第 2 天：内存管理、所有权、复合数据类类型及标准库。"

#~ msgid "Day 3: Generics, traits, error handling, testing, and unsafe Rust."
#~ msgstr "第 3 天：泛型、trait、错误处理、测试和不安全 Rust。"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    println!(\"Edit me!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Control flow constructs: `if`, `if let`, `while`, `while let`, `break`, "
#~ "and `continue`."
#~ msgstr ""
#~ "控制流的构造：`if`、`if let`、`while`、`while let`、`break` 和 "
#~ "`continue`。"

#~ msgid ""
#~ "The idea for the first day is to show _just enough_ of Rust to be able to "
#~ "speak about the famous borrow checker. The way Rust handles memory is a "
#~ "major feature and we should show students this right away."
#~ msgstr ""
#~ "第一天的主要目标是要谈到著名的 borrow checker，其他方面点到为止。Rust 处理"
#~ "内存的方式是其主要特点，这点我们应该尽早展示给学生。"

#~ msgid ""
#~ "If you're teaching this in a classroom, this is a good place to go over "
#~ "the schedule. We suggest splitting the day into two parts (following the "
#~ "slides):"
#~ msgstr ""
#~ "如果你是在教室里教授此课程，不妨在这里介绍一下时间安排。 这边建议是把每天"
#~ "分成两部分（跟着幻灯片来）："

#~ msgid "Morning: 9:00 to 12:00,"
#~ msgstr "早上：9:00 到 12:00，"

#~ msgid "Afternoon: 13:00 to 16:00."
#~ msgstr "下午：13:00 到 16:00。"

#~ msgid ""
#~ "You can of course adjust this as necessary. Please make sure to include "
#~ "breaks, we recommend a break every hour!"
#~ msgstr ""
#~ "当然你也可以看情况调整时间。但是请务必记得提供休息时间。我们建议每个小时休"
#~ "息一次！"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello 🌍!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello 🌍!\");\n"
#~ "}\n"
#~ "```"

#~ msgid "Here is a small example program in Rust:"
#~ msgstr "以下是一个简短的 Rust 示例程序："

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {              // Program entry point\n"
#~ "    let mut x: i32 = 6;  // Mutable variable binding\n"
#~ "    print!(\"{x}\");       // Macro for printing, like printf\n"
#~ "    while x != 1 {       // No parenthesis around expression\n"
#~ "        if x % 2 == 0 {  // Math like in other languages\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {              // 程序入口\n"
#~ "    let mut x: i32 = 6;  // 可变变量绑定\n"
#~ "    print!(\"{x}\");       // 与 printf 类似的输出宏\n"
#~ "    while x != 1 {       // 表达式周围没有括号\n"
#~ "        if x % 2 == 0 {  // 与其他语言类似的数值计算\n"
#~ "            x = x / 2;\n"
#~ "        } else {\n"
#~ "            x = 3 * x + 1;\n"
#~ "        }\n"
#~ "        print!(\" -> {x}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The code implements the Collatz conjecture: it is believed that the loop "
#~ "will always end, but this is not yet proved. Edit the code and play with "
#~ "different inputs."
#~ msgstr ""
#~ "这段代码实现了 Collatz 猜想：猜想认为该循环总是会结束，但该猜想还没有被证"
#~ "明。可以编辑代码来尝试不同的输入。"

#~ msgid ""
#~ "Explain that all variables are statically typed. Try removing `i32` to "
#~ "trigger type inference. Try with `i8` instead and trigger a runtime "
#~ "integer overflow."
#~ msgstr ""
#~ "说明所有变量的类型都是静态的。尝试删除 `i32` 来触发类型推断。尝试使用 "
#~ "`i8` 来触发运行时整数溢出。"

#~ msgid "Change `let mut x` to `let x`, discuss the compiler error."
#~ msgstr "将 `let mut x` 改为 `let x`，讨论出现的编译错误。"

#~ msgid ""
#~ "Show how `print!` gives a compilation error if the arguments don't match "
#~ "the format string."
#~ msgstr "展示 `print!` 在参数与格式字符串不匹配时产生的编译错误。"

#~ msgid ""
#~ "Show how you need to use `{}` as a placeholder if you want to print an "
#~ "expression which is more complex than just a single variable."
#~ msgstr "展示如何使用 `{}` 作为占位符，来输出比单个变量更复杂的表达式。"

#~ msgid ""
#~ "Show the students the standard library, show them how to search for `std::"
#~ "fmt` which has the rules of the formatting mini-language. It's important "
#~ "that the students become familiar with searching in the standard library."
#~ msgstr ""
#~ "向学生展示标准库，展示如何搜索 `std::fmt`，其中包含用于格式化字符串的微型"
#~ "语言规则。要点是让学生熟悉在标准库中搜索的过程。"

#~ msgid ""
#~ "In a shell `rustup doc std::fmt` will open a browser on the local std::"
#~ "fmt documentation"
#~ msgstr ""
#~ "在 shell 中，运行 `rustup doc std::fmt` 会在浏览器中打开本地 std::fmt 文档"

#~ msgid "Compile time memory safety."
#~ msgstr "编译期内存安全。"

#~ msgid "Lack of undefined runtime behavior."
#~ msgstr "没有运行时未定义行为。"

#~ msgid "Modern language features."
#~ msgstr "现代的编程语言特性。"

#~ msgid "Let's consider the following \"minimum wrong example\" program in C:"
#~ msgstr "让我们查看以下 C 语言的“最小错误示例”程序："

#~ msgid "How many bugs do you spot?"
#~ msgstr "你发现了多少 bug？"

#~ msgid ""
#~ "Despite just 29 lines of code, this C example contains serious bugs in at "
#~ "least 11:"
#~ msgstr "尽管该 C 语言示例仅有29行代码，但它却包含了至少11个严重 bug："

#~ msgid "Assignment `=` instead of equality comparison `==` (line 28)"
#~ msgstr "使用赋值 `=` 而非判断相等 `==`（第28行）"

#~ msgid "Excess argument to `printf` (line 23)"
#~ msgstr "`printf` 有多余参数（第23行）"

#~ msgid "File descriptor leak (after line 26)"
#~ msgstr "文件描述符泄露（第26行之后）"

#~ msgid "Forgotten braces in multi-line `if` (line 22)"
#~ msgstr "多行 `if` 语句缺少花括号（第22行）"

#~ msgid "Forgotten `break` in a `switch` statement (line 32)"
#~ msgstr "`switch` 语句忘记添加 `break`（第32行）"

#~ msgid ""
#~ "Forgotten NUL-termination of the `buf` string, leading to a buffer "
#~ "overflow (line 29)"
#~ msgstr "`buf` 字符串忘记NUL终止符，从而导致缓冲区溢出（第29行）"

#~ msgid "Memory leak by not freeing the `malloc`\\-allocated buffer (line 21)"
#~ msgstr "未释放由 `malloc` 分配的缓冲区，从而导致内存泄漏（第21行）"

#~ msgid "Out-of-bounds access (line 17)"
#~ msgstr "越界访问（第17行）"

#~ msgid "Unchecked cases in the `switch` statement (line 11)"
#~ msgstr "`switch` 语句存在未检查的情况（第11行）"

#~ msgid "Unchecked return values of `stat` and `fopen` (lines 18 and 26)"
#~ msgstr "`stat` 和 `fopen` 存在未检查的返回值（第18行及第26行）"

#~ msgid ""
#~ "_Shouldn't these bugs be obvious even for a C compiler?_  \n"
#~ "No, surprisingly this code compiles warning-free at the default warning "
#~ "level, even in the latest GCC version (13.2 as of writing)."
#~ msgstr ""
#~ "_即使对于 C 语言编译器，这些bug难道不应该是显而易见的吗？_  \n"
#~ "惊人的是，即便使用最新版本的GCC（截至撰文时为13.2），在默认警告等级下编译"
#~ "代码时也不出现任何警告。"

#~ msgid ""
#~ "_Isn't this a highly unrealistic example?_  \n"
#~ "Absolutely not, these kind of bugs have lead to serious security "
#~ "vulnerabilities in the past. Some examples:"
#~ msgstr ""
#~ "_这是非常极端的示例吗？_  \n"
#~ "当然不是。这些类型的bug在过去曾引发一系列的安全漏洞，比如以下案例："

#~ msgid ""
#~ "Assignment `=` instead of equality comparison `==`: [The Linux Backdoor "
#~ "Attempt of 2003](https://freedom-to-tinker.com/2013/10/09/the-linux-"
#~ "backdoor-attempt-of-2003)"
#~ msgstr ""
#~ "使用赋值 `=` 而非判断相等 `==`：[2003年Linux后门尝试](https://freedom-to-"
#~ "tinker.com/2013/10/09/the-linux-backdoor-attempt-of-2003)"

#~ msgid ""
#~ "Forgotten braces in multi-line `if`: [The Apple goto fail vulnerability]"
#~ "(https://dwheeler.com/essays/apple-goto-fail.html)"
#~ msgstr ""
#~ "多行 `if` 语句缺少花括号：[Apple goto失败漏洞](https://dwheeler.com/"
#~ "essays/apple-goto-fail.html)"

#~ msgid ""
#~ "Forgotten `break` in a `switch` statement: [The break that broke sudo]"
#~ "(https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-hole-"
#~ "the-break-that-broke-sudo)"
#~ msgstr ""
#~ "`switch` 语句忘记添加 `break`：[破坏sudo的break](https://nakedsecurity."
#~ "sophos.com/2012/05/21/anatomy-of-a-security-hole-the-break-that-broke-"
#~ "sudo)"

#~ msgid ""
#~ "_How is Rust any better here?_  \n"
#~ "Safe Rust makes all of these bugs impossible:"
#~ msgstr ""
#~ "_Rust在这些方面表现得怎么样？_  \n"
#~ "安全Rust使这些bug的出现变得不可能："

#~ msgid "Assignments inside an `if` clause are not supported."
#~ msgstr "不支持 `if` 语句内赋值。"

#~ msgid "Format strings are checked at compile-time."
#~ msgstr "编译时检查格式化字符串。"

#~ msgid "Resources are freed at the end of scope via the `Drop` trait."
#~ msgstr "在作用域末尾，Rust通过 `Drop` trait 来释放资源。"

#~ msgid "All `if` clauses require braces."
#~ msgstr "所有 `if` 语句必须有花括号。"

#~ msgid ""
#~ "`match` (as the Rust equivalent to `switch`) does not fall-through, hence "
#~ "you can't accidentally forget a `break`."
#~ msgstr ""
#~ "`match` 语句（在 Rust 中相当于 `switch`）并不会落空，因此你不会意外忘记一"
#~ "个 `break`。"

#~ msgid "Buffer slices carry their size and don't rely on a NUL terminator."
#~ msgstr "缓冲区切片自带它们的大小，且不依赖NUL终止符。"

#~ msgid ""
#~ "Heap-allocated memory is freed via the `Drop` trait when the "
#~ "corresponding `Box` leaves the scope."
#~ msgstr "当相关 `Box` 离开作用域时，Rust 通过 `Drop` trait 释放堆分配内存。"

#~ msgid ""
#~ "Out-of-bounds accesses cause a panic or can be checked via the `get` "
#~ "method of a slice."
#~ msgstr ""
#~ "越界访问会导致程序发生 panic 而终止，也可以用 `get` 方法来检查一个序列是否"
#~ "越界。"

#~ msgid "`match` mandates that all cases are handled."
#~ msgstr "`match` 语句规定要处理所有情况。"

#~ msgid ""
#~ "Fallible Rust functions return `Result` values that need to be unwrapped "
#~ "and thereby checked for success. Additionally, the compiler emits a "
#~ "warning if you miss to check the return value of a function marked with "
#~ "`#[must_use]`."
#~ msgstr ""
#~ "可出错的 Rust 函数返回的 `Result` 值需要拆箱并检查是否成功。此外，如果你忽"
#~ "略检查标注为 `#[must_use]` 的函数的返回值，编译器会发出警告。"

#~ msgid "Static memory management at compile time:"
#~ msgstr "编译期静态内存管理："

#~ msgid "No memory leaks (_mostly_, see notes)."
#~ msgstr "不存在内存泄漏（_通常情况下_，见注释）。"

#~ msgid ""
#~ "It is possible to produce memory leaks in (safe) Rust. Some examples are:"
#~ msgstr "在（安全的）Rust 中也有可能产生内存泄漏。例如："

#~ msgid ""
#~ "You can use [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
#~ "html#method.leak) to leak a pointer. A use of this could be to get "
#~ "runtime-initialized and runtime-sized static variables"
#~ msgstr ""
#~ "可以使用 [`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box."
#~ "html#method.leak) 来泄漏一个指针。该方法可以用于得到在运行时决定大小和初始"
#~ "化的静态变量"

#~ msgid ""
#~ "You can use [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn."
#~ "forget.html) to make the compiler \"forget\" about a value (meaning the "
#~ "destructor is never run)."
#~ msgstr ""
#~ "可以使用 [`std::mem::forget`](https://doc.rust-lang.org/std/mem/fn.forget."
#~ "html) 来让编译器“忘记”一个值（即其析构函数不会被执行）。"

#~ msgid ""
#~ "You can also accidentally create a [reference cycle](https://doc.rust-"
#~ "lang.org/book/ch15-06-reference-cycles.html) with `Rc` or `Arc`."
#~ msgstr ""
#~ "可以使用 `Rc` 或 `Arc` 意外创建一个循环引用（[reference cycle](https://"
#~ "doc.rust-lang.org/book/ch15-06-reference-cycles.html)）。"

#~ msgid ""
#~ "In fact, some will consider infinitely populating a collection a memory "
#~ "leak and Rust does not protect from those."
#~ msgstr ""
#~ "实际上，有人认为无限填充一个集合也是一种内存泄漏，而 Rust 对此没有保护。"

#~ msgid ""
#~ "For the purpose of this course, \"No memory leaks\" should be understood "
#~ "as \"Pretty much no _accidental_ memory leaks\"."
#~ msgstr "就本课程而言，“不存在内存泄漏”应理解为“几乎没有 _意外_ 内存泄漏”。"

#~ msgid ""
#~ "Integer overflow is defined via the [`overflow-checks`](https://doc.rust-"
#~ "lang.org/rustc/codegen-options/index.html#overflow-checks) compile-time "
#~ "flag. If enabled, the program will panic (a controlled crash of the "
#~ "program), otherwise you get wrap-around semantics. By default, you get "
#~ "panics in debug mode (`cargo build`) and wrap-around in release mode "
#~ "(`cargo build --release`)."
#~ msgstr ""
#~ "整数溢出的行为由编译时的标志指定。可以选择 panic（一种受控的程序崩溃）或使"
#~ "用“回绕（wrap-around）”语义。默认情况下，使用调试模式编译（`cargo build`）"
#~ "的行为为 panic，使用发布模式编译（`cargo build --release`）的行为为“回"
#~ "绕”。"

#~ msgid ""
#~ "Bounds checking cannot be disabled with a compiler flag. It can also not "
#~ "be disabled directly with the `unsafe` keyword. However, `unsafe` allows "
#~ "you to call functions such as `slice::get_unchecked` which does not do "
#~ "bounds checking."
#~ msgstr ""
#~ "边界检查不能使用编译标志禁用，也不能直接通过 `unsafe` 关键字禁用。然而， "
#~ "`unsafe` 允许你调用 `slice::get_unchecked` 等不做边界检查的函数。"

#~ msgid "Rust is built with all the experience gained in the last decades."
#~ msgstr "Rust 建立于过去几十年来所获得的经验之上。"

#~ msgid "Language Features"
#~ msgstr "语言特性"

#~ msgid "Tooling"
#~ msgstr "工具"

#~ msgid ""
#~ "Zero-cost abstractions, similar to C++, means that you don't have to "
#~ "'pay' for higher-level programming constructs with memory or CPU. For "
#~ "example, writing a loop using `for` should result in roughly the same low "
#~ "level instructions as using the `.iter().fold()` construct."
#~ msgstr ""
#~ "与 C++ 类似的零成本抽象，意味着你不需要为高级程序语言的结构“付出”更多的内"
#~ "存和 CPU。例如使用 `for` 循环与使用 `.iter().fold()` 结构应该会生成大致相"
#~ "同的底层指令。"

#~ msgid ""
#~ "It may be worth mentioning that Rust enums are 'Algebraic Data Types', "
#~ "also known as 'sum types', which allow the type system to express things "
#~ "like `Option<T>` and `Result<T, E>`."
#~ msgstr ""
#~ "值得一提的是，Rust 的枚举是“代数数据类型”（也叫“和类型”）。它使得类型系统"
#~ "可以表示 `Option<T>` 和 `Result<T, E>` 等结构。"

#~ msgid ""
#~ "Remind people to read the errors --- many developers have gotten used to "
#~ "ignore lengthy compiler output. The Rust compiler is significantly more "
#~ "talkative than other compilers. It will often provide you with "
#~ "_actionable_ feedback, ready to copy-paste into your code."
#~ msgstr ""
#~ "提醒学生去阅读编译错误 --- 许多开发者已经习惯去忽略冗长的编译器输出。Rust "
#~ "编译器会比其它编译器更健谈。它通常会提供 _可操作的_ 反馈，可以直接复制粘贴"
#~ "到代码中。"

#~ msgid ""
#~ "The Rust standard library is small compared to languages like Java, "
#~ "Python, and Go. Rust does not come with several things you might consider "
#~ "standard and essential:"
#~ msgstr ""
#~ "相比 Java、Python 和 Go 等语言，Rust 标准库较为精简。Rust 并没有内置一些你"
#~ "可能认为标准和必要的功能："

#~ msgid "a random number generator, but see [rand](https://docs.rs/rand/)."
#~ msgstr "随机数生成器，可以使用 [rand](https://docs.rs/rand/) 替代。"

#~ msgid "support for SSL or TLS, but see [rusttls](https://docs.rs/rustls/)."
#~ msgstr "SSL 和 TLS 支持，可以使用 [rusttls](https://docs.rs/rustls/) 替代。"

#~ msgid "support for JSON, but see [serde_json](https://docs.rs/serde_json/)."
#~ msgstr ""
#~ "JSON 支持，可以使用 [serde_json](https://docs.rs/serde_json/) 替代。"

#~ msgid ""
#~ "The reasoning behind this is that functionality in the standard library "
#~ "cannot go away, so it has to be very stable. For the examples above, the "
#~ "Rust community is still working on finding the best solution --- and "
#~ "perhaps there isn't a single \"best solution\" for some of these things."
#~ msgstr ""
#~ "Rust 这么做的原因是标准库中的功能是无法去除的，因此该功能必须非常稳定。对"
#~ "于以上例子，Rust 社区仍在寻找最佳解决方案 --- 甚至对一些情况可能没有单一"
#~ "的“最佳解决方案”。"

#~ msgid ""
#~ "Rust comes with a built-in package manager in the form of Cargo and this "
#~ "makes it trivial to download and compile third-party crates. A "
#~ "consequence of this is that the standard library can be smaller."
#~ msgstr ""
#~ "Rust 内置了一个包管理器 Cargo，使得下载和编译第三方 crate 变得简单。这也导"
#~ "致标准库可以更加精简。"

#~ msgid ""
#~ "Discovering good third-party crates can be a problem. Sites like <https://"
#~ "lib.rs/> help with this by letting you compare health metrics for crates "
#~ "to find a good and trusted one."
#~ msgstr ""
#~ "发现高质量的第三方 crate 也许是一个问题。 <https://lib.rs/> 等网站对此问题"
#~ "有所帮助。它能帮你比较 crate 的健康指标，以找到一个高质量并受信任的 "
#~ "crate。"

#~ msgid ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/) is a well supported LSP "
#~ "implementation used in major IDEs and text editors."
#~ msgstr ""
#~ "[rust-analyzer](https://rust-analyzer.github.io/) 是一个受到广泛支持的 "
#~ "LSP 实现，被主流的 IDE 和文本编辑器所使用。"

#~ msgid "`\"foo\"`, `\"two\\nlines\"`"
#~ msgstr "`\"foo\"`、`“两\\n行”`"

#~ msgid "Like C++, Rust has references:"
#~ msgstr "如同 C++ 一样，Rust 也提供了引用类型。"

#~ msgid ""
#~ "We must dereference `ref_x` when assigning to it, similar to C and C++ "
#~ "pointers."
#~ msgstr ""
#~ "就像 C 与 C++ 中的指针一样，对引用 `ref_x` 进行赋值时，我们必须对其解引"
#~ "用。"

#~ msgid ""
#~ "References that are declared as `mut` can be bound to different values "
#~ "over their lifetime."
#~ msgstr ""
#~ "如果引用值被声明为 `mut`（可变引用），那么这个引用值可以在它的生命周期内被"
#~ "绑定为不同的值。"

#~ msgid "A reference is said to \"borrow\" the value it refers to."
#~ msgstr "一个引用被认为是“借用（borrow）”了它指向的值。"

#~ msgid ""
#~ "Rust is tracking the lifetimes of all references to ensure they live long "
#~ "enough."
#~ msgstr "Rust 会跟踪所有引用的生命周期，以确保这些值的存活时间足够长。"

#~ msgid "`String` vs `str`"
#~ msgstr "“String”与“str”的区别"

#~ msgid "We can now understand the two string types in Rust:"
#~ msgstr "现在我们就可以理解 Rust 中的两种字符串类型："

#~ msgid ""
#~ "You can borrow `&str` slices from `String` via `&` and optionally range "
#~ "selection."
#~ msgstr "你可以通过 `&` 和可选的范围选择从 `String` 中借用 `&str` 切片。"

#~ msgid ""
#~ "A Rust version of the famous [FizzBuzz](https://en.wikipedia.org/wiki/"
#~ "Fizz_buzz) interview question:"
#~ msgstr ""
#~ "一个 Rust 版本的著名 [FizzBuzz](https://en.wikipedia.org/wiki/Fizz_buzz) "
#~ "面试题："

#~ msgid ""
#~ "We refer in `main` to a function written below. Neither forward "
#~ "declarations nor headers are necessary. "
#~ msgstr ""
#~ "我们在 `main` 中引用了下面编写的一个函数。不需要提前声明或添加头文件。 "

#~ msgid ""
#~ "The range expression in the `for` loop in `print_fizzbuzz_to()` contains "
#~ "`=n`, which causes it to include the upper bound."
#~ msgstr ""
#~ "`print_fizzbuzz_to()`函数中`for`循环的范围表达式（range expression）包含"
#~ "`=n`，这会导致它包括上限。"

#~ msgid ""
#~ "All language items in Rust can be documented using special `///` syntax."
#~ msgstr "Rust 中的所有语言元素都可以通过特殊的 `///` 语法进行文档化。"

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "/// Determine whether the first argument is divisible by the second "
#~ "argument.\n"
#~ "///\n"
#~ "/// If the second argument is zero, the result is false.\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "/// ```\n"
#~ "/// assert!(is_divisible_by(42, 2));\n"
#~ "/// ```\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // Corner case, early return\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // The last expression in a block is the return "
#~ "value\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "/// 判断第一个参数是否可以被第二个参数整除。\n"
#~ "///\n"
#~ "/// 如果第二个参数是 0，则返回结果为 false。\n"
#~ "fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n"
#~ "    if rhs == 0 {\n"
#~ "        return false;  // 边界条件，直接返回\n"
#~ "    }\n"
#~ "    lhs % rhs == 0     // 代码块中的最后一个表达式就是它的返回值\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "This course does not include rustdoc on slides, just to save space, but "
#~ "in real code they should be present."
#~ msgstr ""
#~ "本课程的幻灯片中不包含 rustdoc，这是为了节省空间，但是在实际的代码中，应当"
#~ "编写相关的程序文档。"

#~ msgid ""
#~ "Inner doc comments are discussed later (in the page on modules) and need "
#~ "not be addressed here."
#~ msgstr "内部文档注释将在稍后（在讲解模块的页面）讨论，这里无需进行说明。"

#~ msgid ""
#~ "Rustdoc comments can contain code snippets that we can run and test using "
#~ "`cargo test`. We will discuss these tests in the [Testing section](../"
#~ "testing/doc-tests.html)."
#~ msgstr ""
#~ "Rustdoc 注释可以包含我们可使用“cargo test”运行和测试的代码段。我们将在[“测"
#~ "试”部分](../testing/doc-tests.html)中讨论这些测试。"

#~ msgid ""
#~ "Methods are functions associated with a type. The `self` argument of a "
#~ "method is an instance of the type it is associated with:"
#~ msgstr ""
#~ "方法是与某种类型关联的函数。方法的 `self` 参数是与其关联类型的一个实例："

#~ msgid ""
#~ "We will look much more at methods in today's exercise and in tomorrow's "
#~ "class."
#~ msgstr "我们将在今天的练习和明天的课程中更深入地学习方法相关的概念。"

#, fuzzy
#~ msgid ""
#~ "Add a static method called `Rectangle::new` and call this from `main`:"
#~ msgstr "新增一个 `Rectangle::new` 构造函数并在 `main` 函数中调用它:"

#~ msgid ""
#~ "While _technically_, Rust does not have custom constructors, static "
#~ "methods are commonly used to initialize structs (but don't have to). The "
#~ "actual constructor, `Rectangle { width, height }`, could be called "
#~ "directly. See the [Rustnomicon](https://doc.rust-lang.org/nomicon/"
#~ "constructors.html)."
#~ msgstr ""
#~ "虽然从技术层面来讲，Rust 没有自定义构造函数，但静态方法通常用于初始化结构"
#~ "体（但并非必须这样做）。您可以直接调用实际构造函数“Rectangle { width, "
#~ "height }”。请参阅 [Rust 秘典](https://doc.rust-lang.org/nomicon/"
#~ "constructors.html)。"

#, fuzzy
#~ msgid ""
#~ "Add a `Rectangle::square(width: u32)` constructor to illustrate that such "
#~ "static methods can take arbitrary parameters."
#~ msgstr ""
#~ "新增一个 `Rectangle::new_square(width: u32)` 构造函数来说明构造函数可以接"
#~ "受任意参数。"

#~ msgid "Function Overloading"
#~ msgstr "函数重载"

#~ msgid "Overloading is not supported:"
#~ msgstr "不支持重载："

#~ msgid "Always takes a fixed number of parameters."
#~ msgstr "始终接受固定个数的形参。"

#~ msgid "Default values are not supported:"
#~ msgstr "不支持提供默认值："

#~ msgid "All call sites have the same number of arguments."
#~ msgstr "实参的数量在所有调用的地方都是一样的。"

#~ msgid "Macros are sometimes used as an alternative."
#~ msgstr "有时可以用宏（Macro）作为替代。"

#~ msgid "However, function parameters can be generic:"
#~ msgstr "然而，函数形参可以是泛型（generics）："

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
#~ "    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn pick_one<T>(a: T, b: T) -> T {\n"
#~ "    if std::process::id() % 2 == 0 { a } else { b }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"coin toss: {}\", pick_one(\"heads\", \"tails\"));\n"
#~ "    println!(\"cash prize: {}\", pick_one(500, 1000));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "When using generics, the standard library's `Into<T>` can provide a kind "
#~ "of limited polymorphism on argument types. We will see more details in a "
#~ "later section."
#~ msgstr ""
#~ "标准库中的 `Into<T>` 通过泛型参数提供了一种具有有限多态性的参数类型。详见"
#~ "之后的章节。"

#~ msgid "Day 1: Morning Exercises"
#~ msgstr "第一天上午习题"

#~ msgid "In these exercises, we will explore two parts of Rust:"
#~ msgstr "在这些习题中，我们将探索 Rust 的两个部分："

#~ msgid "Implicit conversions between types."
#~ msgstr "类型之间的隐式转换。"

#~ msgid "Arrays and `for` loops."
#~ msgstr "数组和 `for` 循环。"

#~ msgid "A few things to consider while solving the exercises:"
#~ msgstr "在解题时要考虑几件事："

#~ msgid ""
#~ "Use a local Rust installation, if possible. This way you can get auto-"
#~ "completion in your editor. See the page about [Using Cargo](../../cargo."
#~ "md) for details on installing Rust."
#~ msgstr ""
#~ "最好使用本地安装的 Rust，以实现在编辑器中自动补全。关于安装 Rust 的细节，"
#~ "请参见 \\[使用 Cargo\\] 页面。"

#~ msgid "Alternatively, use the Rust Playground."
#~ msgstr "也可以使用 Rust Playground 作为替代。"

#~ msgid ""
#~ "The code snippets are not editable on purpose: the inline code snippets "
#~ "lose their state if you navigate away from the page."
#~ msgstr ""
#~ "页面内嵌的代码片段是不可编辑的：因为离开页面后内嵌代码片段中的修改会丢失。"

#~ msgid ""
#~ "Rust will not automatically apply _implicit conversions_ between types "
#~ "([unlike C++](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion)). You can see this in a program like this:"
#~ msgstr ""
#~ "[与 C++ 不同](https://en.cppreference.com/w/cpp/language/"
#~ "implicit_conversion)，Rust 不会自动进行 _隐式类型转换_。例如，下面的程序中"
#~ "不存在隐式类型转换："

#~ msgid ""
#~ "The Rust integer types all implement the [`From<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.From.html) and [`Into<T>`](https://doc.rust-"
#~ "lang.org/std/convert/trait.Into.html) traits to let us convert between "
#~ "them. The `From<T>` trait has a single `from()` method and similarly, the "
#~ "`Into<T>` trait has a single `into()` method. Implementing these traits "
#~ "is how a type expresses that it can be converted into another type."
#~ msgstr ""
#~ "Rust 的整数类型都实现了 [`From<T>`](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html) 和 [`Into<T>`](https://doc.rust-lang.org/std/convert/"
#~ "trait.Into.html) trait，使得我们可以在它们之间进行转换。`From<T>` trait 包"
#~ "含 `from()` 方法，`Into<T>` trait 包含 `into()` 方法。类型通过实现这些 "
#~ "trait 来表达它将被如何转换为另一个类型。"

#~ msgid ""
#~ "The standard library has an implementation of `From<i8> for i16`, which "
#~ "means that we can convert a variable `x` of type `i8` to an `i16` by "
#~ "calling  `i16::from(x)`. Or, simpler, with `x.into()`, because `From<i8> "
#~ "for i16` implementation automatically create an implementation of "
#~ "`Into<i16> for i8`."
#~ msgstr ""
#~ "标准库中包含 `From<i8> for i16` 的实现，即我们可以通过调用 `i16::from(x)` "
#~ "来将 `i8` 类型的变量 `x` 转换为 `i16`。或者也可以简单地使用 `x.into()`，因"
#~ "为 `From<i8> for i16` 的实现会自动创建 `Into<i16> for i8` 的实现。"

#~ msgid ""
#~ "The same applies for your own `From` implementations for your own types, "
#~ "so it is sufficient to only implement `From` to get a respective `Into` "
#~ "implementation automatically."
#~ msgstr ""
#~ "这同样也适用于自定义类型的 `From` 实现，只需实现 `From` 就可以自动得到对应"
#~ "的 `Into` 实现。"

#~ msgid "Execute the above program and look at the compiler error."
#~ msgstr "执行上述程序，并查看对应的编译错误。"

#~ msgid "Update the code above to use `into()` to do the conversion."
#~ msgstr "修改代码，使用 `into()` 进行类型转换。"

#~ msgid ""
#~ "Change the types of `x` and `y` to other things (such as `f32`, `bool`, "
#~ "`i128`) to see which types you can convert to which other types. Try "
#~ "converting small types to big types and the other way around. Check the "
#~ "[standard library documentation](https://doc.rust-lang.org/std/convert/"
#~ "trait.From.html) to see if `From<T>` is implemented for the pairs you "
#~ "check."
#~ msgstr ""
#~ "修改 `x` 和 `y` 的类型（例如 `f32`, `bool`, `i128` 等）来了解哪些类型之间"
#~ "可以相互转换。尝试将较小的类型转换为较大的类型和将较大的类型转换为较小的类"
#~ "型。阅读 [标准库文档](https://doc.rust-lang.org/std/convert/trait.From."
#~ "html) 来了解对于你所尝试的两个类型 `From<T>` 是否已被实现。"

#~ msgid "Arrays and `for` Loops"
#~ msgstr "数组与 `for` 循环"

#~ msgid "We saw that an array can be declared like this:"
#~ msgstr "我们可以这样声明一个数组："

#~ msgid ""
#~ "You can print such an array by asking for its debug representation with "
#~ "`{:?}`:"
#~ msgstr "你可以使用 `{:?}` 来打印这种数组的调试格式："

#~ msgid ""
#~ "Rust lets you iterate over things like arrays and ranges using the `for` "
#~ "keyword:"
#~ msgstr "在 Rust 中，可以使用 `for` 关键词遍历数组和区间等元素："

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    print!(\"Iterating over array:\");\n"
#~ "    for n in &array {\n"
#~ "        print!(\" {n}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "\n"
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let array = [10, 20, 30];\n"
#~ "    print!(\"Iterating over array:\");\n"
#~ "    for n in array {\n"
#~ "        print!(\" {n}\");\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "\n"
#~ "    print!(\"Iterating over range:\");\n"
#~ "    for i in 0..3 {\n"
#~ "        print!(\" {}\", array[i]);\n"
#~ "    }\n"
#~ "    println!();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,should_panic\n"
#~ "// TODO: remove this when you're done with your implementation.\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- the comment makes rustfmt add a newline\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "\n"
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);\n"
#~ "\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,should_panic\n"
#~ "// TODO: 完成你的实现后移除此行。\n"
#~ "#![allow(unused_variables, dead_code)]\n"
#~ "\n"
#~ "fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn pretty_print(matrix: &[[i32; 3]; 3]) {\n"
#~ "    unimplemented!()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let matrix = [\n"
#~ "        [101, 102, 103], // <-- 这个注释会让 rustfmt 添加一个新行\n"
#~ "        [201, 202, 203],\n"
#~ "        [301, 302, 303],\n"
#~ "    ];\n"
#~ "\n"
#~ "    println!(\"matrix:\");\n"
#~ "    pretty_print(&matrix);\n"
#~ "\n"
#~ "    let transposed = transpose(matrix);\n"
#~ "    println!(\"transposed:\");\n"
#~ "    pretty_print(&transposed);\n"
#~ "}\n"
#~ "```"

#~ msgid "Bonus Question"
#~ msgstr "附加题"

#~ msgid ""
#~ "Could you use `&[i32]` slices instead of hard-coded 3 × 3 matrices for "
#~ "your argument and return types? Something like `&[&[i32]]` for a two-"
#~ "dimensional slice-of-slices. Why or why not?"
#~ msgstr ""
#~ "是否可以使用 `&[i32]` 切片而不是硬编码的 3 × 3 矩阵作为函数的参数和返回类"
#~ "型？例如使用 `&[&[i32]]` 表示一个二维的切片的切片。为什么这样做是可行或不"
#~ "可行的？"

#~ msgid ""
#~ "See the [`ndarray` crate](https://docs.rs/ndarray/) for a production "
#~ "quality implementation."
#~ msgstr ""
#~ "参考 [`ndarray` crate](https://docs.rs/ndarray/) 以了解该功能满足生产环境"
#~ "质量的实现。"

#~ msgid ""
#~ "The solution and the answer to the bonus section are available in the  "
#~ "[Solution](solutions-morning.md#arrays-and-for-loops) section."
#~ msgstr ""
#~ "题目解答和附加题的答案在 [题解](solutions-morning.md#arrays-and-for-"
#~ "loops) 章节中。"

#~ msgid ""
#~ "The use of the reference `&array` within `for n in &array` is a subtle "
#~ "preview of issues of ownership that will come later in the afternoon."
#~ msgstr ""
#~ "在“for n in &array”中使用引用“&array”这一做法巧妙地预先展示了下午将谈到的"
#~ "所有权问题。"

#~ msgid "Without the `&`..."
#~ msgstr "如果不使用“&”…"

#~ msgid ""
#~ "The loop would have been one that consumes the array.  This is a change "
#~ "[introduced in the 2021 Edition](https://doc.rust-lang.org/edition-guide/"
#~ "rust-2021/IntoIterator-for-arrays.html)."
#~ msgstr ""
#~ "循环将会是一个使用数组的循环。这是一项[在 2021 年版中引入](https://doc."
#~ "rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html)的变"
#~ "更。"

#~ msgid ""
#~ "An implicit array copy would have occurred.  Since `i32` is a copy type, "
#~ "then `[i32; 3]` is also a copy type."
#~ msgstr ""
#~ "会发生隐式数组复制。由于“i32”是复制类型，因此“\\[i32; 3\\]”也是复制类型。"

#~ msgid ""
#~ "As we have seen, `if` is an expression in Rust. It is used to "
#~ "conditionally evaluate one of two blocks, but the blocks can have a value "
#~ "which then becomes the value of the `if` expression. Other control flow "
#~ "expressions work similarly in Rust."
#~ msgstr ""
#~ "正如我们所知，`if` 是 Rust 中的一个表达式。它用于有条件地 评估两个块中的一"
#~ "个，但这些块可以有一个值， 然后成为 `if` 表达式的值。其他控制流表达式在 "
#~ "Rust 中也有类似 的运作方式。"

#~ msgid ""
#~ "The same rule is used for functions: the value of the function body is "
#~ "the return value:"
#~ msgstr "同样的规则也适用于函数：函数主体的值 是返回值："

#~ msgid ""
#~ "The point of this slide is to show that blocks have a type and value in "
#~ "Rust. "
#~ msgstr "这张幻灯片的重点是说明在 Rust 中，块有类型和值。"

#, fuzzy
#~ msgid ""
#~ "The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) is "
#~ "closely related to the [`while let` loop](while-let-expressions.md). It "
#~ "will automatically call `into_iter()` on the expression and then iterate "
#~ "over it:"
#~ msgstr ""
#~ "[`for` 循环](https://doc.rust-lang.org/std/keyword.for.html) 与 [`when "
#~ "let` 循环](when-let-expression.md)密切相关。它会 自动对表达式调用 "
#~ "`into_iter()`，然后对其进行迭代："

#~ msgid "You can use `break` and `continue` here as usual."
#~ msgstr "你可以在此照常使用 `break` 和 `continue`。"

#~ msgid "Index iteration is not a special syntax in Rust for just that case."
#~ msgstr "在这种情况下，索引迭代在 Rust 中并不是一个特殊的语法。"

#~ msgid "`(0..10)` is a range that implements an `Iterator` trait. "
#~ msgstr "`(0..10)` 是实现 `Iterator` trait 的区间。"

#~ msgid ""
#~ "`step_by` is a method that returns another `Iterator` that skips every "
#~ "other element. "
#~ msgstr ""
#~ "`step_by` 是返回另一个 `Iterator` 的方法，用于逐一跳过所有其他元素。"

#~ msgid ""
#~ "Modify the elements in the vector and explain the compiler errors. Change "
#~ "vector `v` to be mutable and the for loop to `for x in v.iter_mut()`."
#~ msgstr ""
#~ "修改矢量中的元素并说明编译器错误。将矢量 `v` 改为可变，并将 for 循环改为 "
#~ "`for x in v.iter_mut()`。"

#~ msgid "`loop` expressions"
#~ msgstr "`loop` 表达式"

#~ msgid ""
#~ "Finally, there is a [`loop` keyword](https://doc.rust-lang.org/reference/"
#~ "expressions/loop-expr.html#infinite-loops) which creates an endless loop."
#~ msgstr ""
#~ "最后是用于创建无限循环的 [`loop` 关键字](https://doc.rust-lang.org/"
#~ "reference/expressions/loop-expr.html#infinite-loops) 。"

#~ msgid "Here you must either `break` or `return` to stop the loop:"
#~ msgstr "在下例中，你必须 `break` 或 `return` 才能停止循环："

#~ msgid "Break the `loop` with a value (e.g. `break 8`) and print it out."
#~ msgstr "用一个值（例如 `break 8`）来中断 `loop` 并将其输出。"

#~ msgid ""
#~ "Due to type inference the `i32` is optional. We will gradually show the "
#~ "types less and less as the course progresses."
#~ msgstr ""
#~ "由于类型推导，`i32` 可以省略。随着课程推进，我们会越来越少地看到类型声明。"

#, fuzzy
#~ msgid ""
#~ "The following code tells the compiler to copy into a certain generic "
#~ "container without the code ever explicitly specifying the contained type, "
#~ "using `_` as a placeholder:"
#~ msgstr ""
#~ "下面的代码通过使用 `_` 占位符来告诉编译器无需明确指定其类型就可以将对应数"
#~ "据拷贝到该容器： "

#, fuzzy
#~ msgid ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect) relies on [`FromIterator`](https://doc.rust-lang.org/"
#~ "std/iter/trait.FromIterator.html), which [`HashSet`](https://doc.rust-"
#~ "lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-"
#~ "HashSet%3CT,+S%3E) implements."
#~ msgstr ""
#~ "[`collect`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator."
#~ "html#method.collect) 依赖 [`HashSet`](https://doc.rust-lang.org/std/iter/"
#~ "trait.FromIterator.html) 实现的 `FromIterator`。"

#~ msgid "Static and Constant Variables"
#~ msgstr "静态变量和常量"

#~ msgid ""
#~ "```rust,editable\n"
#~ "static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"{BANNER}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "static BANNER: &str = \"Welcome to RustOS 3.14\";\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    println!(\"{BANNER}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");\n"
#~ "\n"
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");\n"
#~ "\n"
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let a = 10;\n"
#~ "    println!(\"before: {a}\");\n"
#~ "\n"
#~ "    {\n"
#~ "        let a = \"hello\";\n"
#~ "        println!(\"inner scope: {a}\");\n"
#~ "\n"
#~ "        let a = true;\n"
#~ "        println!(\"shadowed in inner scope: {a}\");\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"after: {a}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The following code demonstrates why the compiler can't simply reuse "
#~ "memory locations when shadowing an immutable variable in a scope, even if "
#~ "the type does not change."
#~ msgstr ""
#~ "以下代码说明了为什么在作用域内隐藏一个不可变的变量时，即使是在变量类型没有"
#~ "改变的情况下，编译器也不能简单地重复利用之前的内存位置。"

#, fuzzy
#~ msgid ""
#~ "This page offers an enum type `CoinFlip` with two variants `Heads` and "
#~ "`Tails`. You might note the namespace when using variants."
#~ msgstr ""
#~ "本页提供了一个枚举类型 `CoinFlip`，其中包含 `Heads` 和`Tail`两个变体。在使"
#~ "用变体时，你可能会注意到命名空间。"

#~ msgid "In both, associated functions are defined within an `impl` block."
#~ msgstr "在这两者中，关联的函数都在 `impl` 块中定义。"

#~ msgid ""
#~ "You can define richer enums where the variants carry data. You can then "
#~ "use the `match` statement to extract the data from each variant:"
#~ msgstr ""
#~ "你可以定义更丰富的枚举，其中变体会携带数据。然后，你可以使用 `match` 语句"
#~ "从每个变体中提取数据："

#~ msgid ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // Variant without payload\n"
#~ "    KeyPress(char),           // Tuple struct variant\n"
#~ "    Click { x: i64, y: i64 }, // Full struct variant\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, "
#~ "y={y}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };\n"
#~ "\n"
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "enum WebEvent {\n"
#~ "    PageLoad,                 // Variant without payload\n"
#~ "    KeyPress(char),           // Tuple struct variant\n"
#~ "    Click { x: i64, y: i64 }, // Full struct variant\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(event: WebEvent) {\n"
#~ "    match event {\n"
#~ "        WebEvent::PageLoad       => println!(\"page loaded\"),\n"
#~ "        WebEvent::KeyPress(c)    => println!(\"pressed '{c}'\"),\n"
#~ "        WebEvent::Click { x, y } => println!(\"clicked at x={x}, "
#~ "y={y}\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let load = WebEvent::PageLoad;\n"
#~ "    let press = WebEvent::KeyPress('x');\n"
#~ "    let click = WebEvent::Click { x: 20, y: 80 };\n"
#~ "\n"
#~ "    inspect(load);\n"
#~ "    inspect(press);\n"
#~ "    inspect(click);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The expression is matched against the patterns from top to bottom. There "
#~ "is no fall-through like in C or C++."
#~ msgstr "表达式会从上到下与模式匹配。没有像 C 或 C++ 中那样的跳转。"

#~ msgid ""
#~ "The match expression has a value. The value is the last expression in the "
#~ "match arm which was executed."
#~ msgstr "匹配表达式拥有一个值。值是 match 分支中被执行的最后一个表达式。"

#~ msgid ""
#~ "Starting from the top we look for what pattern matches the value then run "
#~ "the code following the arrow. Once we find a match, we stop. "
#~ msgstr ""
#~ "从顶部开始，查找与该值匹配的模式，然后沿箭头运行代码。一旦找到匹配，我们便"
#~ "会停止。"

#~ msgid "`match` inspects a hidden discriminant field in the `enum`."
#~ msgstr "`match` 会检查 `enum` 中的隐藏的判别字段。"

#~ msgid ""
#~ "It is possible to retrieve the discriminant by calling `std::mem::"
#~ "discriminant()`"
#~ msgstr "可以通过调用 `std::mem::discriminant()` 来检索判别"

#~ msgid ""
#~ "This is useful, for example, if implementing `PartialEq` for structs "
#~ "where comparing field values doesn't affect equality."
#~ msgstr ""
#~ "这很有用，例如如果为结构体实现 `PartialEq`，比较字段值不会影响等式。"

#~ msgid ""
#~ "`WebEvent::Click { ... }` is not exactly the same as `WebEvent::"
#~ "Click(Click)` with a top level `struct Click { ... }`. The inlined "
#~ "version cannot implement traits, for example."
#~ msgstr ""
#~ "`WebEvent::Click { ... }` 与含顶层 `struct Click { ... }` 的 `WebEvent::"
#~ "Click(Click)` 不完全相同。例如，内嵌版本无法实现 trait。"

#~ msgid ""
#~ "Rust enums are packed tightly, taking constraints due to alignment into "
#~ "account:"
#~ msgstr "Rust 枚举被紧密地打包，考虑到了对齐的影响，因此存在一些限制："

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::any::type_name;\n"
#~ "use std::mem::{align_of, size_of};\n"
#~ "\n"
#~ "fn dbg_size<T>() {\n"
#~ "    println!(\"{}: size {} bytes, align: {} bytes\",\n"
#~ "        type_name::<T>(), size_of::<T>(), align_of::<T>());\n"
#~ "}\n"
#~ "\n"
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    dbg_size::<Foo>();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::mem::{align_of, size_of};\n"
#~ "\n"
#~ "macro_rules! dbg_size {\n"
#~ "    ($t:ty) => {\n"
#~ "        println!(\"{}: size {} bytes, align: {} bytes\",\n"
#~ "                 stringify!($t), size_of::<$t>(), align_of::<$t>());\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "enum Foo {\n"
#~ "    A,\n"
#~ "    B,\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    dbg_size!(Foo);\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "Internally Rust is using a field (discriminant) to keep track of the enum "
#~ "variant."
#~ msgstr "在内部，Rust 使用字段（判别）来跟踪枚举变体。"

#, fuzzy
#~ msgid "Try out other types such as"
#~ msgstr "试试其他类型，例如："

#, fuzzy
#~ msgid "`dbg_size!(bool)`: size 1 bytes, align: 1 bytes,"
#~ msgstr "`dbg_size!(bool)`：大小占用 1 个字节，对齐占用 1 个字节；"

#, fuzzy
#~ msgid ""
#~ "`dbg_size!(Option<bool>)`: size 1 bytes, align: 1 bytes (niche "
#~ "optimization, see below),"
#~ msgstr ""
#~ "`dbg_size!(Option<bool>)`：大小占用 1 个字节，对齐占用 1 个字节（小众优"
#~ "化，请参阅下文）；"

#, fuzzy
#~ msgid ""
#~ "`dbg_size!(&i32)`: size 8 bytes, align: 8 bytes (on a 64-bit machine),"
#~ msgstr ""
#~ "`dbg_size!(&i32)`：大小占用 8 个字节，对齐占用 8 个字节（在 64 位设备"
#~ "上）；"

#, fuzzy
#~ msgid ""
#~ "`dbg_size!(Option<&i32>)`: size 8 bytes, align: 8 bytes (null pointer "
#~ "optimization, see below)."
#~ msgstr ""
#~ "`dbg_size!(Option<&i32>)`：大小占用 8 个字节，对齐占用 8 个字节（Null 指针"
#~ "优化，请参阅下文）。"

#, fuzzy
#~ msgid ""
#~ "Niche optimization: Rust will merge unused bit patterns for the enum "
#~ "discriminant."
#~ msgstr "小众优化：Rust 将对枚举判别合并使用 未使用的位模式。"

#~ msgid ""
#~ "More complex example if you want to discuss what happens when we chain "
#~ "more than 256 `Option`s together."
#~ msgstr ""
#~ "如果您想讨论将 256 多个“Option”链在一起时会发生什么情况，可以使用下方这个"
#~ "更复杂的示例。"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let arg = std::env::args().next();\n"
#~ "    if let Some(value) = arg {\n"
#~ "        println!(\"Program name: {value}\");\n"
#~ "    } else {\n"
#~ "        println!(\"Missing name?\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let arg = std::env::args().next();\n"
#~ "    if let Some(value) = arg {\n"
#~ "        println!(\"Program name: {value}\");\n"
#~ "    } else {\n"
#~ "        println!(\"Missing name?\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "Since 1.65, a similar [let-else](https://doc.rust-lang.org/rust-by-"
#~ "example/flow_control/let_else.html) construct allows to do a "
#~ "destructuring assignment, or if it fails, execute a block which is "
#~ "required to abort normal control flow (with `panic`/`return`/`break`/"
#~ "`continue`):"
#~ msgstr ""
#~ "自 1.65 版以来，类似的 [let-else](https://doc.rust-lang.org/rust-by-"
#~ "example/flow_control/let_else.html) 结构允许执行解构赋值，或者如果不满足条"
#~ "件，则有一个非返回块分支 (panic/return/break/continue)："

#~ msgid ""
#~ "The [`match` keyword](https://doc.rust-lang.org/reference/expressions/"
#~ "match-expr.html) is used to match a value against one or more patterns. "
#~ "In that sense, it works like a series of `if let` expressions:"
#~ msgstr ""
#~ "[`match` 关键字](https://doc.rust-lang.org/reference/expressions/match-"
#~ "expr.html) 用于将一个值与一个或多个模式进行匹配。从这个意义上讲，它的工作"
#~ "方式 类似于一系列的 `if let` 表达式："

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    match std::env::args().next().as_deref() {\n"
#~ "        Some(\"cat\") => println!(\"Will do cat things\"),\n"
#~ "        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
#~ "        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
#~ "        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
#~ "        None        => println!(\"Hmm, no program name?\"),\n"
#~ "        _           => println!(\"Unknown program name!\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    match std::env::args().next().as_deref() {\n"
#~ "        Some(\"cat\") => println!(\"Will do cat things\"),\n"
#~ "        Some(\"ls\")  => println!(\"Will ls some files\"),\n"
#~ "        Some(\"mv\")  => println!(\"Let's move some files\"),\n"
#~ "        Some(\"rm\")  => println!(\"Uh, dangerous!\"),\n"
#~ "        None        => println!(\"Hmm, no program name?\"),\n"
#~ "        _           => println!(\"Unknown program name!\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Save the match expression to a variable and print it out."
#~ msgstr "将 match 表达式保存到一个变量中并输出结果。"

#~ msgid "Remove `.as_deref()` and explain the error."
#~ msgstr "移除 `.as_deref()` 并说明错误。"

#~ msgid ""
#~ "`std::env::args().next()` returns an `Option<String>`, but we cannot "
#~ "match against `String`."
#~ msgstr ""
#~ "`std::env::args().next()` 会返回  `Option<String>`，但无法与 `String` 进行"
#~ "匹配。"

#~ msgid ""
#~ "`as_deref()` transforms an `Option<T>` to `Option<&T::Target>`. In our "
#~ "case, this turns `Option<String>` into `Option<&str>`."
#~ msgstr ""
#~ "`as_deref()` 会将 `Option<T>` 转换为 `Option<&T::Target>`。在我们的示例"
#~ "中，这会将 `Option<String>` 转换为 `Option<&str>`。"

#~ msgid ""
#~ "We can now use pattern matching to match against the `&str` inside "
#~ "`Option`."
#~ msgstr "现在，我们可以使用模式匹配来匹配 `Option` 中的 `&str`。"

#~ msgid "The `_` pattern is a wildcard pattern which matches any value."
#~ msgstr "模式 `_` 是外卡 (wildcard) 模式。它可以匹配任何值。"

#~ msgid ""
#~ "It can be useful to show how binding works, by for instance replacing a "
#~ "wildcard character with a variable, or removing the quotes around `q`."
#~ msgstr ""
#~ "展示绑定的运作方式可能会很有帮助，例如通过用变量替换通配符或移除“q”周围的"
#~ "引号来展示。"

#~ msgid "You can demonstrate matching on a reference."
#~ msgstr "您可以在参照项上演示如何匹配。"

#~ msgid ""
#~ "This might be a good time to bring up the concept of irrefutable "
#~ "patterns, as the term can show up in error messages."
#~ msgstr ""
#~ "这时可能很适合提到“不可反驳的模式”这个概念，因为这个术语可能会出现在错误消"
#~ "息中。"

#~ msgid "You can also destructure `structs`:"
#~ msgstr "您还可以解构“structs”："

#~ msgid ""
#~ "Destructuring of slices of unknown length also works with patterns of "
#~ "fixed length."
#~ msgstr "对未知长度的切片进行解构也可以使用固定长度的模式。"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    inspect(&[0, -2, 3]);\n"
#~ "    inspect(&[0, -2, 3, 4]);\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(slice: &[i32]) {\n"
#~ "    println!(\"Tell me about {slice:?}\");\n"
#~ "    match slice {\n"
#~ "        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        &[1, ..]   => println!(\"First is 1 and the rest were "
#~ "ignored\"),\n"
#~ "        _          => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    inspect(&[0, -2, 3]);\n"
#~ "    inspect(&[0, -2, 3, 4]);\n"
#~ "}\n"
#~ "\n"
#~ "#[rustfmt::skip]\n"
#~ "fn inspect(slice: &[i32]) {\n"
#~ "    println!(\"Tell me about {slice:?}\");\n"
#~ "    match slice {\n"
#~ "        &[0, y, z] => println!(\"First is 0, y = {y}, and z = {z}\"),\n"
#~ "        &[1, ..]   => println!(\"First is 1 and the rest were "
#~ "ignored\"),\n"
#~ "        _          => println!(\"All elements were ignored\"),\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "When matching, you can add a _guard_ to a pattern. This is an arbitrary "
#~ "Boolean expression which will be executed if the pattern matches:"
#~ msgstr ""
#~ "匹配时，您可以向模式中添加“守卫”。这是一个任意布尔表达式，如果模式匹配，就"
#~ "会执行该表达式："

#~ msgid ""
#~ "You can use the variables defined in the pattern in your if expression."
#~ msgstr "您可以在 if 表达式中使用模式中定义的变量。"

#~ msgid "Day 1: Afternoon Exercises"
#~ msgstr "第 1 天：下午练习"

#~ msgid "We will look at two things:"
#~ msgstr "我们将关注以下两方面："

#, fuzzy
#~ msgid "The Luhn algorithm,"
#~ msgstr "Luhn 算法"

#, fuzzy
#~ msgid "An exercise on pattern matching."
#~ msgstr "枚举和模式匹配。"

#, fuzzy
#~ msgid ""
#~ "Copy the code below to <https://play.rust-lang.org/> and implement the "
#~ "function."
#~ msgstr "将下面的代码复制到 <https://play.rust-lang.org/> 并实现上述函数："

#~ msgid ""
#~ "Try to solve the problem the \"simple\" way first, using `for` loops and "
#~ "integers. Then, revisit the solution and try to implement it with "
#~ "iterators."
#~ msgstr ""
#~ "使用“for”循环和整数，先尝试以简单的方式解决问题。然后，再次查看该解决方"
#~ "案，并尝试使用迭代器来实现它。"

#~ msgid ""
#~ "Memory management: stack vs heap, manual memory management, scope-based "
#~ "memory management, and garbage collection."
#~ msgstr ""
#~ "内存管理：栈与堆，手动内存管理，基于作用域的内存管理，以及垃圾回收。"

#~ msgid ""
#~ "Ownership: move semantics, copying and cloning, borrowing, and lifetimes."
#~ msgstr ""
#~ "所有权：移动（move）的语义，复制（copy）和克隆（clone），借用（borrow），"
#~ "以及生命周期。"

#, fuzzy
#~ msgid "Structs and methods."
#~ msgstr "结构体（struct）, 枚举（enum）, 方法（method）。"

#~ msgid ""
#~ "The Standard Library: `String`, `Option` and `Result`, `Vec`, `HashMap`, "
#~ "`Rc` and `Arc`."
#~ msgstr ""
#~ "标准库: `字符串（String）`, `选项（Option）` 和 `结果（Result）`, `动态数"
#~ "组（Vec）`, `散列表（HashMap）`, `引用计数（Rc）` 和 `共享引用计数（Arc）"
#~ "`。"

#~ msgid "Modules: visibility, paths, and filesystem hierarchy."
#~ msgstr "模块: 可见性, 路径和文件系统的层次结构。"

#~ msgid "First, let's refresh how memory management works."
#~ msgstr "首先，我们回顾一下内存管理的工作原理。"

#~ msgid "The Stack vs The Heap"
#~ msgstr "栈与堆"

#, fuzzy
#~ msgid "Stack and Heap Example"
#~ msgstr "栈 vs 堆"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1 = String::from(\"Hello\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1 = String::from(\"Hello\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::from(\"Hello\");\n"
#~ "    s1.push(' ');\n"
#~ "    s1.push_str(\"world\");\n"
#~ "    // DON'T DO THIS AT HOME! For educational purposes only.\n"
#~ "    // String provides no guarantees about its layout, so this could lead "
#~ "to\n"
#~ "    // undefined behavior.\n"
#~ "    unsafe {\n"
#~ "        let (ptr, capacity, len): (usize, usize, usize) = std::mem::"
#~ "transmute(s1);\n"
#~ "        println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
#~ "{capacity}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let mut s1 = String::from(\"Hello\");\n"
#~ "    s1.push(' ');\n"
#~ "    s1.push_str(\"world\");\n"
#~ "    // DON'T DO THIS AT HOME! For educational purposes only.\n"
#~ "    // String provides no guarantees about its layout, so this could lead "
#~ "to\n"
#~ "    // undefined behavior.\n"
#~ "    unsafe {\n"
#~ "        let (capacity, ptr, len): (usize, usize, usize) = std::mem::"
#~ "transmute(s1);\n"
#~ "        println!(\"ptr = {ptr:#x}, len = {len}, capacity = "
#~ "{capacity}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "You allocate and deallocate heap memory yourself."
#~ msgstr "你自己实现堆内存分配和释放。"

#~ msgid ""
#~ "If not done with care, this can lead to crashes, bugs, security "
#~ "vulnerabilities, and memory leaks."
#~ msgstr "稍有不慎，这可能会导致崩溃、bug、安全漏洞和内存泄漏。"

#~ msgid "C Example"
#~ msgstr "C++ 示例"

#~ msgid "You must call `free` on every pointer you allocate with `malloc`:"
#~ msgstr "你必须对使用 `malloc` 分配的每个指针调用 `free`："

#, fuzzy
#~ msgid ""
#~ "```c\n"
#~ "void foo(size_t n) {\n"
#~ "    int* int_array = malloc(n * sizeof(int));\n"
#~ "    //\n"
#~ "    // ... lots of code\n"
#~ "    //\n"
#~ "    free(int_array);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c\n"
#~ "void foo(size_t n) {\n"
#~ "    int* int_array = (int*)malloc(n * sizeof(int));\n"
#~ "    //\n"
#~ "    // ... lots of code\n"
#~ "    //\n"
#~ "    free(int_array);\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "Memory is leaked if the function returns early between `malloc` and "
#~ "`free`: the pointer is lost and we cannot deallocate the memory. Worse, "
#~ "freeing the pointer twice, or accessing a freed pointer can lead to "
#~ "exploitable security vulnerabilities."
#~ msgstr ""
#~ "如果函数在 `malloc` 和 `free` 之间提前返回，则会导致内存泄漏： 指针丢失，"
#~ "而我们无法释放对应的内存。"

#~ msgid ""
#~ "Constructors and destructors let you hook into the lifetime of an object."
#~ msgstr "构造函数和析构函数让你可以钩入对象的生命周期。"

#~ msgid ""
#~ "By wrapping a pointer in an object, you can free memory when the object "
#~ "is destroyed. The compiler guarantees that this happens, even if an "
#~ "exception is raised."
#~ msgstr ""
#~ "通过将指针封装在对象中，你可以在该对象 被销毁时释放内存。编译器可保证这一"
#~ "点的实现，即使引发了异常也不例外。"

#~ msgid ""
#~ "This is often called _resource acquisition is initialization_ (RAII) and "
#~ "gives you smart pointers."
#~ msgstr ""
#~ "这通常称为“资源获取即初始化 (resource acquisition is initialization, "
#~ "RAII)”， 并为你提供智能指针。"

#~ msgid ""
#~ "```c++\n"
#~ "void say_hello(std::unique_ptr<Person> person) {\n"
#~ "  std::cout << \"Hello \" << person->name << std::endl;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "void say_hello(std::unique_ptr<Person> person) {\n"
#~ "  std::cout << \"Hello \" << person->name << std::endl;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The `std::unique_ptr` object is allocated on the stack, and points to "
#~ "memory allocated on the heap."
#~ msgstr "`std::unique_ptr` 对象在栈上分配内存，并指向在堆上分配的内存。"

#~ msgid ""
#~ "At the end of `say_hello`, the `std::unique_ptr` destructor will run."
#~ msgstr "在 `say_hello` 结束时，`std::unique_ptr` 析构函数将运行。"

#~ msgid "The destructor frees the `Person` object it points to."
#~ msgstr "析构函数释放它所指向的 `Person` 对象。"

#~ msgid ""
#~ "Special move constructors are used when passing ownership to a function:"
#~ msgstr "将所有权传递给函数时，使用特殊的 move 构造函数："

#~ msgid ""
#~ "An alternative to manual and scope-based memory management is automatic "
#~ "memory management:"
#~ msgstr "自动内存管理是手动和基于作用域的内存管理 的替代方案："

#~ msgid "The programmer never allocates or deallocates memory explicitly."
#~ msgstr "程序员从不显式分配或取消分配内存。"

#~ msgid ""
#~ "A garbage collector finds unused memory and deallocates it for the "
#~ "programmer."
#~ msgstr "垃圾回收器找到未使用的内存，并为程序员将其取消分配。"

#~ msgid "Java Example"
#~ msgstr "Java 示例"

#~ msgid "The `person` object is not deallocated after `sayHello` returns:"
#~ msgstr "`sayHello` 返回后，`person` 对象未被取消分配："

#~ msgid ""
#~ "```java\n"
#~ "void sayHello(Person person) {\n"
#~ "  System.out.println(\"Hello \" + person.getName());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "void sayHello(Person person) {\n"
#~ "  System.out.println(\"Hello \" + person.getName());\n"
#~ "}\n"
#~ "```"

#~ msgid "Memory Management in Rust"
#~ msgstr "Rust 中的内存管理"

#~ msgid "Memory management in Rust is a mix:"
#~ msgstr "Rust 中的内存管理是一种混合模式："

#~ msgid "Safe and correct like Java, but without a garbage collector."
#~ msgstr "像 Java 一样安全又正确，但没有垃圾回收器。"

#~ msgid "Scope-based like C++, but the compiler enforces full adherence."
#~ msgstr "像 C++ 一样基于作用域，但编译器会强制完全遵循规则。"

#~ msgid ""
#~ "A Rust user can choose the right abstraction for the situation, some even "
#~ "have no cost at runtime like C."
#~ msgstr ""
#~ "Rust 用户可以根据具体情况选择合适的抽象，有些甚至没有像 C 那样的运行时开"
#~ "销。"

#, fuzzy
#~ msgid "Rust achieves this by modeling _ownership_ explicitly."
#~ msgstr "它通过对“所有权”进行显式建模来实现这一点。"

#~ msgid ""
#~ "If asked how at this point, you can mention that in Rust this is usually "
#~ "handled by RAII wrapper types such as [Box](https://doc.rust-lang.org/std/"
#~ "boxed/struct.Box.html), [Vec](https://doc.rust-lang.org/std/vec/struct."
#~ "Vec.html), [Rc](https://doc.rust-lang.org/std/rc/struct.Rc.html), or [Arc]"
#~ "(https://doc.rust-lang.org/std/sync/struct.Arc.html). These encapsulate "
#~ "ownership and memory allocation via various means, and prevent the "
#~ "potential errors in C."
#~ msgstr ""
#~ "如果此时被问及如何操作，你可以提及在 Rust 中，这通常由 RAII 封装容器类型"
#~ "（例如 [Box](https://doc.rust-lang.org/std/boxed/struct.Box.html)、[Vec]"
#~ "(https://doc.rust-lang.org/std/vec/struct.Vec.html)、[Rc](https://doc."
#~ "rust-lang.org/std/rc/struct.Rc.html) 或 [Arc](https://doc.rust-lang.org/"
#~ "std/sync/struct.Arc.html)）处理。这些类型通过各种方式封装了所有权和内存分"
#~ "配，并防止了 C 中潜在错误的发生。"

#~ msgid ""
#~ "You may be asked about destructors here, the [Drop](https://doc.rust-lang."
#~ "org/std/ops/trait.Drop.html) trait is the Rust equivalent."
#~ msgstr ""
#~ "你可能会被问及析构函数，此处 [Drop](https://doc.rust-lang.org/std/ops/"
#~ "trait.Drop.html) trait 是 Rust 等效项。"

#~ msgid "A destructor can run here to free up resources."
#~ msgstr "析构函数可在此运行以释放资源。"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Hello!\");\n"
#~ "    let s2: String = s1;\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    // println!(\"s1: {s1}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let s1: String = String::from(\"Hello!\");\n"
#~ "    let s2: String = s1;\n"
#~ "    println!(\"s2: {s2}\");\n"
#~ "    // println!(\"s1: {s1}\");\n"
#~ "}\n"
#~ "```"

#~ msgid "There is always _exactly_ one variable binding which owns a value."
#~ msgstr "变量绑定在任一时刻有且“只有”一个值。"

#~ msgid "The heap data from `s1` is reused for `s2`."
#~ msgstr "`s1` 中的堆数据会被 `s2` 重复使用。"

#~ msgid ""
#~ "When `s1` goes out of scope, nothing happens (it has been moved from)."
#~ msgstr "当 `s1` 离开作用域时，什么都不会发生（它已被移出）。"

#~ msgid ""
#~ "```c++\n"
#~ "std::string s1 = \"Cpp\";\n"
#~ "std::string s2 = s1;  // Duplicate the data in s1.\n"
#~ "```"
#~ msgstr ""
#~ "```c++\n"
#~ "std::string s1 = \"Cpp\";\n"
#~ "std::string s2 = s1;  // 复制 s1 中的数据。\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = String::from(\"Alice\");\n"
#~ "    say_hello(name);\n"
#~ "    // say_hello(name);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn say_hello(name: String) {\n"
#~ "    println!(\"Hello {name}\")\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = String::from(\"Alice\");\n"
#~ "    say_hello(name);\n"
#~ "    // say_hello(name);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "If students ask about `derive`, it is sufficient to say that this is a "
#~ "way to generate code in Rust at compile time. In this case the default "
#~ "implementations of `Copy` and `Clone` traits are generated."
#~ msgstr ""
#~ "如果学员问起 `derive`，只需说这是一种 在编译时生成 Rust 代码的方法。在这种"
#~ "情况下，系统会生成 `Copy` 和 `Clone` trait 的默认实现。"

#~ msgid "A borrowed value has a _lifetime_:"
#~ msgstr "借用的值是有“生命周期”的："

#~ msgid ""
#~ "The lifetime can be implicit: `add(p1: &Point, p2: &Point) -> Point`."
#~ msgstr "生命周期可以是隐式的：add(p1: &Point, p2: &Point) -> Point\\`。"

#~ msgid "Lifetimes can also be explicit: `&'a Point`, `&'document str`."
#~ msgstr "生命周期也可以是显式的：`&'a Point`、`&'document str`。"

#~ msgid ""
#~ "Read `&'a Point` as \"a borrowed `Point` which is valid for at least the "
#~ "lifetime `a`\"."
#~ msgstr "将 `&'a Point` 读取为“借用的 `Point，至少 在 `a\\` 生命周期内有效。"

#~ msgid ""
#~ "Lifetimes are always inferred by the compiler: you cannot assign a "
#~ "lifetime yourself."
#~ msgstr "生命周期始终由编译器推断出来：你不能自行 分配生命周期。"

#~ msgid ""
#~ "In addition to borrowing its arguments, a function can return a borrowed "
#~ "value:"
#~ msgstr "除了借用其参数之外，函数还可以返回借用的值："

#~ msgid "`'a` is a generic parameter, it is inferred by the compiler."
#~ msgstr "`'a` 是一个泛型形参，由编译器推断出来。"

#~ msgid "Lifetimes start with `'` and `'a` is a typical default name."
#~ msgstr "以 `'` 和 `'a` 开头的生命周期是典型的默认名称。"

#~ msgid ""
#~ "The _at least_ part is important when parameters are in different scopes."
#~ msgstr "当参数在不同的作用域时，“至少”部分至关重要。"

#~ msgid ""
#~ "Move the declaration of `p2` and `p3` into a new scope (`{ ... }`), "
#~ "resulting in the following code:"
#~ msgstr "将 `p2` 和 `p3` 的声明移至新作用域 (`{ ... }`)，以产生以下代码："

#~ msgid "Note how this does not compile since `p3` outlives `p2`."
#~ msgstr "请注意：由于 `p3` 的生命周期比 `p2` 长，因此无法编译。"

#~ msgid ""
#~ "Reset the workspace and change the function signature to `fn "
#~ "left_most<'a, 'b>(p1: &'a Point, p2: &'a Point) -> &'b Point`. This will "
#~ "not compile because the relationship between the lifetimes `'a` and `'b` "
#~ "is unclear."
#~ msgstr ""
#~ "重置工作区，然后将函数签名更改为 `fn left_most<'a, 'b>(p1: &'a Point, p2: "
#~ "&'a Point) -> &'b Point`。这不会被编译，因为 `'a` 和 `'b` 生命周期之间的关"
#~ "系不明确。"

#~ msgid "Another way to explain it:"
#~ msgstr "另一种解释方式："

#~ msgid ""
#~ "Two references to two values are borrowed by a function and the function "
#~ "returns another reference."
#~ msgstr "对两个值的两个引用被一个函数借用，该函数返回 另一个引用。"

#~ msgid ""
#~ "It must have come from one of those two inputs (or from a global "
#~ "variable)."
#~ msgstr "它必须是来自这两个输入中的一个（或来自一个全局变量）。"

#~ msgid ""
#~ "Which one is it? The compiler needs to know, so at the call site the "
#~ "returned reference is not used for longer than a variable from where the "
#~ "reference came from."
#~ msgstr ""
#~ "是哪一个呢？编译器需要知道这一点，因此在调用点，返回的引用 的使用时间不会"
#~ "超过引用的来源中的变量。"

#~ msgid ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);\n"
#~ "\n"
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let text = String::from(\"The quick brown fox jumps over the lazy dog."
#~ "\");\n"
#~ "    let fox = Highlight(&text[4..19]);\n"
#~ "    let dog = Highlight(&text[35..43]);\n"
#~ "    // erase(text);\n"
#~ "    println!(\"{fox:?}\");\n"
#~ "    println!(\"{dog:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "#[derive(Debug)]\n"
#~ "struct Highlight<'doc>(&'doc str);\n"
#~ "\n"
#~ "fn erase(text: String) {\n"
#~ "    println!(\"Bye {text}!\");\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let text = String::from(\"The quick brown fox jumps over the lazy dog."
#~ "\");\n"
#~ "    let fox = Highlight(&text[4..19]);\n"
#~ "    let dog = Highlight(&text[35..43]);\n"
#~ "    // erase(text);\n"
#~ "    println!(\"{fox:?}\");\n"
#~ "    println!(\"{dog:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Methods are defined in an `impl` block, which we will see in following "
#~ "slides."
#~ msgstr "方法是在“impl”块中进行定义的，我们将在后面的幻灯片中看到。"

#~ msgid ""
#~ "The `new` function could be written using `Self` as a type, as it is "
#~ "interchangeable with the struct type name"
#~ msgstr ""
#~ "在编写“new”函数时可以使用“Self”作为类型，因为它可以与结构体类型名称互换"

#~ msgid ""
#~ "Implement the `Default` trait for the struct. Define some fields and use "
#~ "the default values for the other fields."
#~ msgstr "为结构体实现“Default”trait。定义一些字段并对其他字段使用默认值。"

#~ msgid "Methods are defined in the `impl` block."
#~ msgstr "方法是在“impl”块中进行定义的。"

#~ msgid ""
#~ "Use struct update syntax to define a new structure using `peter`. Note "
#~ "that the variable `peter` will no longer be accessible afterwards."
#~ msgstr ""
#~ "使用结构体更新语法以利用“peter”定义一个新结构。请注意，之后将无法再访问变"
#~ "量“peter”。"

#~ msgid ""
#~ "Use `{:#?}` when printing structs to request the `Debug` representation."
#~ msgstr "在输出结构体时，使用“{:#?}”来请求“Debug”表示法。"

#~ msgid "We describe the distinction between method receivers next."
#~ msgstr "下面，我们将介绍方法接收器之间的区别。"

#~ msgid ""
#~ "Consider emphasizing \"shared and immutable\" and \"unique and mutable\". "
#~ "These constraints always come together in Rust due to borrow checker "
#~ "rules, and `self` is no exception. It isn't possible to reference a "
#~ "struct from multiple locations and call a mutating (`&mut self`) method "
#~ "on it."
#~ msgstr ""
#~ "建议强调“共享且不可变”和“唯一且可变”。由于借用检查器规则的原因，这些约束"
#~ "在 Rust 中总是一起出现，而“self”也不例外。您无法从多个位置引用结构体并对其"
#~ "调用一项改变（“&mut self”）方法。"

#~ msgid "All four methods here use a different method receiver."
#~ msgstr "这里的所有四种方法都使用一个不同的方法接收器。"

#~ msgid ""
#~ "You can point out how that changes what the function can do with the "
#~ "variable values and if/how it can be used again in `main`."
#~ msgstr ""
#~ "您可以指出这会如何改变函数可对变量值采取的操作，以及是否/如何能够"
#~ "在“main”中再次使用该函数。"

#~ msgid ""
#~ "You can showcase the error that appears when trying to call `finish` "
#~ "twice."
#~ msgstr "您可以展示在尝试调用“finish”两次时出现的错误。"

#~ msgid ""
#~ "Note that although the method receivers are different, the non-static "
#~ "functions are called the same way in the main body. Rust enables "
#~ "automatic referencing and dereferencing when calling methods. Rust "
#~ "automatically adds in the `&`, `*`, `muts` so that that object matches "
#~ "the method signature."
#~ msgstr ""
#~ "请注意，尽管方法接收器不同，但是非静态函数在 main 函数体中的调用方式相同。"
#~ "Rust 支持在调用方法时自动引用和解引用，并会自动加入“&”“\\*”和“muts”以便该"
#~ "对象与方法签名匹配。"

#~ msgid ""
#~ "You might point out that `print_laps` is using a vector that is iterated "
#~ "over. We describe vectors in more detail in the afternoon. "
#~ msgstr ""
#~ "您或许可以指出 `print_laps` 使用的是不断迭代的vector。我们将在下午详细说明"
#~ "这些vector。"

#~ msgid "Day 2: Morning Exercises"
#~ msgstr "第二天上午习题"

#~ msgid "We will look at implementing methods in two contexts:"
#~ msgstr "我们将考虑以下两种场景："

#~ msgid "Storing books and querying the collection"
#~ msgstr "存储图书和查询馆藏"

#~ msgid "Keeping track of health statistics for patients"
#~ msgstr "跟踪患者的健康统计信息"

#, fuzzy
#~ msgid ""
#~ "We will learn much more about structs and the `Vec<T>` type tomorrow. For "
#~ "now, you just need to know part of its API:"
#~ msgstr ""
#~ "我们明天会更详细地介绍结构体和“Vec\n"
#~ "\n"
#~ "”类型。目前，您只需了解其 API 的一部分："

#, fuzzy
#~ msgid ""
#~ "Use this to model a library's book collection. Copy the code below to "
#~ "<https://play.rust-lang.org/> and update the types to make it compile:"
#~ msgstr "将下面的代码复制到 <https://play.rust-lang.org/> 并实现上述函数："

#~ msgid "The common vocabulary types include:"
#~ msgstr "常见的词汇类型包括："

#~ msgid ""
#~ "[`Option` and `Result`](std/option-result.md) types: used for optional "
#~ "values and [error handling](error-handling.md)."
#~ msgstr ""
#~ "[`Option` 和 `Result`](std/option-result.md) 类型：用于可选值和 [错误处理]"
#~ "(error-handling.md)。"

#~ msgid ""
#~ "[`String`](std/string.md): the default string type used for owned data."
#~ msgstr "[`String`](std/string.md)：用于自有数据的默认字符串类型。"

#~ msgid "[`Vec`](std/vec.md): a standard extensible vector."
#~ msgstr "[`Vec`](std/vec.md)：标准的可扩展矢量。"

#~ msgid ""
#~ "[`HashMap`](std/hashmap.md): a hash map type with a configurable hashing "
#~ "algorithm."
#~ msgstr "[`HashMap`](std/hashmap.md)：采用可配置哈希算法的哈希映射 类型。"

#~ msgid "[`Box`](std/box.md): an owned pointer for heap-allocated data."
#~ msgstr "[`Box`](std/box.md)：适用于堆分配数据的自有指针。"

#~ msgid ""
#~ "[`Rc`](std/rc.md): a shared reference-counted pointer for heap-allocated "
#~ "data."
#~ msgstr "[`Rc`](std/rc.md)：适用于堆分配数据的共享引用计数指针。"

#~ msgid "`Option` and `Result`"
#~ msgstr "`Option` 和 `Result`"

#~ msgid "The types represent optional data:"
#~ msgstr "这些类型表示可选数据："

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let numbers = vec![10, 20, 30];\n"
#~ "    let first: Option<&i8> = numbers.first();\n"
#~ "    println!(\"first: {first:?}\");\n"
#~ "\n"
#~ "    let arr: Result<[i8; 3], Vec<i8>> = numbers.try_into();\n"
#~ "    println!(\"arr: {arr:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "`Option<&T>` has zero space overhead compared to `&T`."
#~ msgstr "相较于 `&T`，`Option<&T>` 的空间开销为零。"

#~ msgid ""
#~ "Show iterating over a vector and mutating the value: `for e in &mut v "
#~ "{ *e += 50; }`"
#~ msgstr "介绍如何迭代矢量并更改它的值：“for e in &mut v { \\*e += 50; }”"

#~ msgid ""
#~ "In the above example, you can even leave out the `*` in the `println!` "
#~ "statement thanks to `Deref`. "
#~ msgstr ""
#~ "在上面的示例中，因为有 `Deref`，您甚至可以在 `println!` 语句中省略 `*`。"

#~ msgid "Box with Recursive Data Structures"
#~ msgstr "包含递归数据结构的 Box"

#~ msgid "Day 2: Afternoon Exercises"
#~ msgstr "第二天下午习题"

#~ msgid ""
#~ "The exercises for this afternoon will focus on strings and iterators."
#~ msgstr "今天下午的习题将重点关注字符串（string）和迭代器（iterator）。"

#~ msgid ""
#~ "The ownership model of Rust affects many APIs. An example of this is the "
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) traits."
#~ msgstr ""
#~ "Rust 的所有权模式会影响许多 API。例如，[“Iterator”](https://doc.rust-lang."
#~ "org/std/iter/trait.Iterator.html)和[“IntoIterator”](https://doc.rust-lang."
#~ "org/std/iter/trait.IntoIterator.html) trait。"

#~ msgid ""
#~ "Traits are like interfaces: they describe behavior (methods) for a type. "
#~ "The `Iterator` trait simply says that you can call `next` until you get "
#~ "`None` back:"
#~ msgstr ""
#~ "trait 类似于接口：它们描述某类型的行为（方法）。`Iterator` trait 只是告知"
#~ "您可以调用 `next`，直到返回 `None`："

#~ msgid "You use this trait like this:"
#~ msgstr "您可以按如下方式使用此 trait："

#~ msgid "What is the type returned by the iterator? Test your answer here:"
#~ msgstr "迭代器返回的类型是什么？请在此测试您的答案："

#~ msgid "Why is this type used?"
#~ msgstr "为什么要使用此类型？"

#~ msgid "Like before, what  is the type returned by the iterator?"
#~ msgstr "和之前一样，迭代器返回的类型是什么？"

#~ msgid ""
#~ "Now that we know both `Iterator` and `IntoIterator`, we can build `for` "
#~ "loops. They call `into_iter()` on an expression and iterates over the "
#~ "resulting iterator:"
#~ msgstr ""
#~ "现在，我们已了解了“Iterator”和“IntoIterator”，接下来可以构建“for”循环了。"
#~ "它们会针对表达式调用“into_iter()”，并对生成的迭代器进行迭代："

#, fuzzy
#~ msgid ""
#~ "Experiment with the code above and then consult the documentation for "
#~ "[`impl IntoIterator for &Vec<T>`](https://doc.rust-lang.org/std/vec/"
#~ "struct.Vec.html#impl-IntoIterator-for-%26'a+Vec%3CT,+A%3E) and [`impl "
#~ "IntoIterator for Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec."
#~ "html#impl-IntoIterator-for-Vec%3CT,+A%3E) to check your answers."
#~ msgstr ""
#~ "使用上方代码进行实验，然后参阅[“impl IntoIterator for &Vec\n"
#~ "\n"
#~ "”](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
#~ "for-%26'a+Vec%3CT,+A%3E)和[“impl IntoIterator for Vec\n"
#~ "\n"
#~ "”](https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-"
#~ "for-Vec%3CT,+A%3E)的相关文档来检查您的答案。"

#~ msgid ""
#~ "In this exercise, you are implementing a routing component of a web "
#~ "server. The server is configured with a number of _path prefixes_ which "
#~ "are matched against _request paths_. The path prefixes can contain a "
#~ "wildcard character which matches a full segment. See the unit tests below."
#~ msgstr ""
#~ "在本练习中，您将实现 Web 服务器的路由组件。服务器配置有多个路径前缀，这些"
#~ "前缀与请求路径匹配。路径前缀可以包含与完整段匹配的通配符。请参阅下面的单元"
#~ "测试。"

#~ msgid ""
#~ "Traits: deriving traits, default methods, and important standard library "
#~ "traits."
#~ msgstr "trait：派生 trait、默认方法和重要的标准库 trait。"

#~ msgid ""
#~ "Generics: generic data types, generic methods, monomorphization, and "
#~ "trait objects."
#~ msgstr "泛型：泛型数据类型、泛型方法、单态化和 trait 对象。"

#~ msgid "Testing: unit tests, documentation tests, and integration tests."
#~ msgstr "测试：单元测试、文档测试和集成测试。"

#~ msgid ""
#~ "Unsafe Rust: raw pointers, static variables, unsafe functions, and extern "
#~ "functions."
#~ msgstr "不安全 Rust：原始指针、静态变量、不安全函数和外部函数。"

#~ msgid "Try declaring a new variable `let p = Point { x: 5, y: 10.0 };`."
#~ msgstr "尝试声明一个新变量“let p = Point { x: 5, y: 10.0 };”。"

#~ msgid "Fix the code to allow points that have elements of different types."
#~ msgstr "修正代码，以允许点具有不同类型的元素。"

#~ msgid "You can declare a generic type on your `impl` block:"
#~ msgstr "您可以在 `impl` 块中声明通用类型："

#~ msgid ""
#~ "Generic code is turned into non-generic code based on the call sites:"
#~ msgstr "泛型代码根据调用位置转换为非泛型代码："

#~ msgid "behaves as if you wrote"
#~ msgstr "具体行为与您所编写的一样"

#~ msgid ""
#~ "Rust derive macros work by automatically generating code that implements "
#~ "the specified traits for a data structure."
#~ msgstr "Rust 派生宏的运作方式是自动生成代码，用于实现数据结构的指定 trait。"

#, fuzzy
#~ msgid "You can let the compiler derive a number of traits as follows:"
#~ msgstr "您可以让编译器派生多个特征："

#~ msgid "Traits can implement behavior in terms of other trait methods:"
#~ msgstr "特征可以依照其他特征方法来实现行为："

#~ msgid "Move method `not_equals` to a new trait `NotEquals`."
#~ msgstr "将方法“not_equals”移至新的 trait“NotEquals”。"

#~ msgid "Make `Equals` a super trait for `NotEquals`."
#~ msgstr "将“Equals”设为“NotEquals”的超 trait。"

#~ msgid "Provide a blanket implementation of `NotEquals` for `Equals`."
#~ msgstr "为“Equals”提供“NotEquals”的通用实现。"

#~ msgid ""
#~ "With the blanket implementation, you no longer need `Equals` as a super "
#~ "trait for `NotEqual`."
#~ msgstr "借助通用实现，您不再需要将“Equals”作为“NotEqual”的超 trait。"

#~ msgid "`impl Trait` allows you to work with types which you cannot name."
#~ msgstr "`impl Trait` 让您可使用无法命名的类型。"

#~ msgid ""
#~ "This example is great, because it uses `impl Display` twice. It helps to "
#~ "explain that nothing here enforces that it is _the same_ `impl Display` "
#~ "type. If we used a single  `T: Display`, it would enforce the constraint "
#~ "that input `T` and return `T` type are the same type. It would not work "
#~ "for this particular function, as the type we expect as input is likely "
#~ "not what `format!` returns. If we wanted to do the same via `: Display` "
#~ "syntax, we'd need two independent generic parameters."
#~ msgstr ""
#~ "这是一个非常棒的示例，因为它使用了两次 `impl Display`。这有助于说明 此处没"
#~ "有任何项目会强制使用相同的 `impl Display` 类型。如果我们使用单个 `T: "
#~ "Display`，它会强制限制输入 `T` 和返回 `T` 均为同一类型。 这并不适用于这个"
#~ "特定函数，因为我们预期作为输入的类型可能 不会是 `format!` 返回的值。如果我"
#~ "们希望通过 `: Display` 语法执行相同的操作，则需要两个 独立的泛型形参。"

#~ msgid ""
#~ "We will now look at some of the most common traits of the Rust standard "
#~ "library:"
#~ msgstr "现在，我们来看看 Rust 标准库的一些最常见的特征："

#~ msgid ""
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) used in `for` loops,"
#~ msgstr ""
#~ "[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) 和 "
#~ "[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator."
#~ "html) 用于 `for` 循环中，"

#~ msgid ""
#~ "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) and "
#~ "[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) used to "
#~ "convert values,"
#~ msgstr ""
#~ "[`From`](https://doc.rust-lang.org/std/convert/trait.From.html) 和 "
#~ "[`Into`](https://doc.rust-lang.org/std/convert/trait.Into.html) 用于转换"
#~ "值，"

#~ msgid ""
#~ "[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) and [`Write`]"
#~ "(https://doc.rust-lang.org/std/io/trait.Write.html) used for IO,"
#~ msgstr ""
#~ "[`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) 和 [`Write`]"
#~ "(https://doc.rust-lang.org/std/io/trait.Write.html) 用于实现 IO。"

#~ msgid ""
#~ "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html), [`Mul`]"
#~ "(https://doc.rust-lang.org/std/ops/trait.Mul.html), ... used for operator "
#~ "overloading, and"
#~ msgstr ""
#~ "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html)、[`Mul`]"
#~ "(https://doc.rust-lang.org/std/ops/trait.Mul.html) 等用于实现运算符重载，"

#~ msgid ""
#~ "[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) "
#~ "used to construct a default instance of a type."
#~ msgstr ""
#~ "[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) 用于"
#~ "构建相应类型的默认实例。"

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let primes = vec![2, 3, 5, 7];\n"
#~ "    let prime_squares = primes\n"
#~ "        .into_iter()\n"
#~ "        .map(|prime| prime * prime)\n"
#~ "        .collect::<Vec<_>>();\n"
#~ "    println!(\"prime_squares: {prime_squares:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let mut iter = v.into_iter();\n"
#~ "\n"
#~ "    while let Some(x) = iter.next() {\n"
#~ "        println!(\"x: {x}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "`Iterator` implements `fn collect<B>(self) -> B where B: "
#~ "FromIterator<Self::Item>, Self: Sized`"
#~ msgstr ""
#~ "`Iterator` 会实现 `fn collect<B>(self) -> B where B: FromIterator<Self::"
#~ "Item>, Self: Sized`"

#~ msgid "`Add`, `Mul`, ..."
#~ msgstr "` Add`Mul \\``…"

#~ msgid "Day 3: Morning Exercises"
#~ msgstr "第 3 天：上午练习"

#~ msgid ""
#~ "We will design a classical GUI library using traits and trait objects."
#~ msgstr "我们将使用 trait 和 trait 对象设计一个经典的 GUI 库。"

#~ msgid ""
#~ "We will also look at enum dispatch with an exercise involving points and "
#~ "polygons."
#~ msgstr "我们还将通过点和多边形的相关练习，探讨枚举调度情况。"

#, fuzzy
#~ msgid "Drawing A Simple GUI"
#~ msgstr "一个简单的 GUI 库"

#~ msgid "Polygon Struct"
#~ msgstr "多边形结构体"

#~ msgid ""
#~ "We will create a `Polygon` struct which contain some points. Copy the "
#~ "code below to <https://play.rust-lang.org/> and fill in the missing "
#~ "methods to make the tests pass:"
#~ msgstr ""
#~ "我们将创建一个包含一些点的“Polygon”结构体。将以下代码复制到 <https://play."
#~ "rust-lang.org/>，然后填入缺少的方法，设法通过测试："

#~ msgid ""
#~ "Since the method signatures are missing from the problem statements, the "
#~ "key part of the exercise is to specify those correctly. You don't have to "
#~ "modify the tests."
#~ msgstr ""
#~ "由于问题语句中缺少方法签名，因此练习的关键部分是正确指定这些内容。您无需修"
#~ "改测试。"

#~ msgid "Other interesting parts of the exercise:"
#~ msgstr "练习的其他有趣部分："

#~ msgid ""
#~ "Derive a `Copy` trait for some structs, as in tests the methods sometimes "
#~ "don't borrow their arguments."
#~ msgstr ""
#~ "为某些结构体派生“Copy”trait，因为在测试中，方法有时不借用它们的参数。"

#~ msgid ""
#~ "Discover that `Add` trait must be implemented for two objects to be "
#~ "addable via \"+\". Note that we do not discuss generics until Day 3."
#~ msgstr ""
#~ "发现必须实现“Add”trait 才能通过“+”添加两个对象。请注意，我们在第 3 天之前"
#~ "不会讨论泛型。"

#~ msgid "Error handling in Rust is done using explicit control flow:"
#~ msgstr "Rust 中的错误处理是使用显式控制流来进行的："

#~ msgid "Functions that can have errors list this in their return type,"
#~ msgstr "包含错误的函数会在返回类型中列出相关信息。"

#~ msgid "There are no exceptions."
#~ msgstr "此规则没有例外。"

#~ msgid "Catching the Stack Unwinding"
#~ msgstr "捕获堆栈展开"

#~ msgid ""
#~ "We have already seen the `Result` enum. This is used pervasively when "
#~ "errors are expected as part of normal operation:"
#~ msgstr ""
#~ "在前面，我们看到了 `Result` 枚举。在遇到正常操作产生的预期错误时， 我们常"
#~ "会用到此方法："

#~ msgid "Propagating Errors with `?`"
#~ msgstr "使用 `?` 传播错误"

#~ msgid ""
#~ "The try-operator `?` is used to return errors to the caller. It lets you "
#~ "turn the common"
#~ msgstr "try 操作符 `?` 用于将错误返回给调用方。它能把常用命令"

#, fuzzy
#~ msgid ""
#~ "The return type of the function has to be compatible with the nested "
#~ "functions it calls. For instance, a function returning a `Result<T, Err>` "
#~ "can only apply the `?` operator on a function returning a  `Result<AnyT, "
#~ "Err>`. It cannot apply the `?` operator on a function returning an "
#~ "`Option<AnyT>` or `Result<T, OtherErr>` unless `OtherErr` implements "
#~ "`From<Err>`. Reciprocally, a function returning an `Option<T>` can only "
#~ "apply the `?` operator  on a function returning an `Option<AnyT>`."
#~ msgstr ""
#~ "函数的返回值类型必须与其调用的嵌套函数兼容。例如，一个返回“Result\\<T, "
#~ "Err>”的函数只能对返回“Result\\<AnyT, Err>”的函数应用“?”运算符。它无法对返"
#~ "回“Option\n"
#~ "\n"
#~ "”或“Result\\<T, OtherErr>”的函数应用“?”运算符，除非“OtherErr”实现“From\n"
#~ "\n"
#~ "”。相反地，返回“Option\n"
#~ "\n"
#~ "”的函数只能对返回“Option\n"
#~ "\n"
#~ "”的函数应用“?”运算符。"

#~ msgid ""
#~ "You can convert incompatible types into one another with the different "
#~ "`Option` and `Result` methods  such as `Option::ok_or`, `Result::ok`, "
#~ "`Result::err`."
#~ msgstr ""
#~ "您可以使用其他“Option”和“Result”方法（例如“Option::ok_or”“Result::"
#~ "ok”“Result::err”）将不兼容的类型转换为另一种类型。"

#~ msgid ""
#~ "It is good practice for all error types that don't need to be `no_std` to "
#~ "implement `std::error::Error`, which requires `Debug` and `Display`. The "
#~ "`Error` crate for `core` is only available in [nightly](https://github."
#~ "com/rust-lang/rust/issues/103765), so not fully `no_std` compatible yet."
#~ msgstr ""
#~ "对所有不需要是“no_std”的错误类型来说，实现“std::error::Error”是一种很好的"
#~ "做法，而这需要“Debug”和“Display”。“core”的“Error”crate 仅在 [nightly]"
#~ "(https://github.com/rust-lang/rust/issues/103765) 提供，因此尚未"
#~ "与“no_std”完全兼容。"

#, fuzzy
#~ msgid ""
#~ "It's generally helpful for them to implement `Clone` and `Eq` too where "
#~ "possible, to make life easier for tests and consumers of your library. In "
#~ "this case we can't easily do so, because `io::Error` doesn't implement "
#~ "them."
#~ msgstr ""
#~ "对所有错误类型实现 `std::error::Error` 是一种很好的做法，而这需要结合使用 "
#~ "`Debug` 和 `Display` 方法。 通常，在可能的情况下实现 `Clone` 和 `Eq` 也十"
#~ "分有益， 可以让库的测试和使用变得更加简单。在本例中，我们无法轻松做到这一"
#~ "点， 因为 `io::Error` 不能实现这些方法。"

#~ msgid ""
#~ "The [thiserror](https://docs.rs/thiserror/) crate is a popular way to "
#~ "create an error enum like we did on the previous page:"
#~ msgstr ""
#~ "[thiserror](https://docs.rs/thiserror/) crate 是创建错误枚举的常用方法， "
#~ "就像前一页中提供的示例一样："

#~ msgid ""
#~ "`thiserror`'s derive macro automatically implements `std::error::Error`, "
#~ "and optionally `Display` (if the `#[error(...)]` attributes are provided) "
#~ "and `From` (if the `#[from]` attribute is added). It also works for "
#~ "structs."
#~ msgstr ""
#~ "`thiserror` 的派生宏会自动实现 `std::error::Error`，并且可以选择性地实现 "
#~ "`Display` （如果提供了 `#[error(...)]` 属性）和 `From`（如果添加了 "
#~ "`#[from]` 属性）。 此规则也适用于结构体。"

#~ msgid ""
#~ "It doesn't affect your public API, which makes it good for libraries."
#~ msgstr "但是，此规则不会影响公共 API，对于库而言，这非常理想。"

#~ msgid ""
#~ "The widely used [anyhow](https://docs.rs/anyhow/) crate can help you add "
#~ "contextual information to your errors and allows you to have fewer custom "
#~ "error types:"
#~ msgstr ""
#~ "广泛使用的 [anyhow](https://docs.rs/anyhow/) crate 可以帮助我们为错误添加 "
#~ "背景信息，并减少自定义错误类型的 数量。"

#~ msgid "Mark unit tests with `#[test]`:"
#~ msgstr "使用 `#[test]` 标记单元测试："

#~ msgid "Use `cargo test` to find and run the unit tests."
#~ msgstr "使用 `cargo test` 查找并运行单元测试。"

#~ msgid ""
#~ "Unit tests are often put in a nested module (run tests on the [Playground]"
#~ "(https://play.rust-lang.org/)):"
#~ msgstr ""
#~ "单元测试通常会放在嵌套模块中（在 [Playground](https://play.rust-lang."
#~ "org/) 上运行测试）："

#~ msgid "Useful crates for writing tests"
#~ msgstr "用于编写测试的实用 crate"

#~ msgid "Calling External Code"
#~ msgstr "调用外部代码"

#~ msgid ""
#~ "Functions from other languages might violate the guarantees of Rust. "
#~ "Calling them is thus unsafe:"
#~ msgstr ""
#~ "基于其他语言的函数可能会违反 Rust 的保证。因此， 调用这类函数是不安全的："

#~ msgid "Day 3: Afternoon Exercises"
#~ msgstr "第 3 天：下午练习"

#~ msgid "Let us build a safe wrapper for reading directory content!"
#~ msgstr "让我们构建一个用于读取目录内容的安全封装容器！"

#~ msgid ""
#~ "For this exercise, we suggest using a local dev environment instead of "
#~ "the Playground. This will allow you to run your binary on your own "
#~ "machine."
#~ msgstr ""
#~ "在本练习中，我们建议您使用本地开发环境，而不是 Playground。这样，您就可以"
#~ "在自己的机器上运行二进制文件。"

#~ msgid ""
#~ "To get started, follow the [running locally](../../cargo/running-locally."
#~ "md) instructions."
#~ msgstr ""
#~ "首先，请按照[在本地运行](../../cargo/running-locally.md)中的说明操作。"

#~ msgid ""
#~ "After looking at the exercise, you can look at the [solution](solutions-"
#~ "afternoon.md) provided."
#~ msgstr "看过练习后，您可以查看所提供的[解题方法](solutions-afternoon.md)。"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust\",\n"
#~ "    crate_name: \"hello_rust\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust\",\n"
#~ "    crate_name: \"hello_rust\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello from Rust!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"Hello from Rust!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_with_dep\",\n"
#~ "    crate_name: \"hello_rust_with_dep\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libgreetings\",\n"
#~ "        \"libtextwrap\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "\n"
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_with_dep\",\n"
#~ "    crate_name: \"hello_rust_with_dep\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"libgreetings\",\n"
#~ "        \"libtextwrap\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "\n"
#~ "rust_library {\n"
#~ "    name: \"libgreetings\",\n"
#~ "    crate_name: \"greetings\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Rust demo.\n"
#~ "\n"
#~ "use greetings::greeting;\n"
#~ "use textwrap::fill;\n"
#~ "\n"
#~ "/// Prints a greeting to standard output.\n"
#~ "fn main() {\n"
#~ "    println!(\"{}\", fill(&greeting(\"Bob\"), 24));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Greeting library.\n"
#~ "\n"
#~ "/// Greet `name`.\n"
#~ "pub fn greeting(name: &str) -> String {\n"
#~ "    format!(\"Hello {name}, it is very nice to meet you!\")\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Greeting library.\n"
#~ "\n"
#~ "/// Greet `name`.\n"
#~ "pub fn greeting(name: &str) -> String {\n"
#~ "    format!(\"Hello {name}, it is very nice to meet you!\")\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "aidl_interface {\n"
#~ "    name: \"com.example.birthdayservice\",\n"
#~ "    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
#~ "    unstable: true,\n"
#~ "    backend: {\n"
#~ "        rust: { // Rust is not enabled by default\n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "aidl_interface {\n"
#~ "    name: \"com.example.birthdayservice\",\n"
#~ "    srcs: [\"com/example/birthdayservice/*.aidl\"],\n"
#~ "    unstable: true,\n"
#~ "    backend: {\n"
#~ "        rust: { // 默认情况下不启用 Rust \n"
#~ "            enabled: true,\n"
#~ "        },\n"
#~ "    },\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Implementation of the `IBirthdayService` AIDL interface.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "/// The `IBirthdayService` implementation.\n"
#~ "pub struct BirthdayService;\n"
#~ "\n"
#~ "impl binder::Interface for BirthdayService {}\n"
#~ "\n"
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
#~ "Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} "
#~ "years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! 实现了 `IBirthdayService` AIDL 接口。\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "/// `IBirthdayService` 接口的具体实现。\n"
#~ "pub struct BirthdayService;\n"
#~ "\n"
#~ "impl binder::Interface for BirthdayService {}\n"
#~ "\n"
#~ "impl IBirthdayService for BirthdayService {\n"
#~ "    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::"
#~ "Result<String> {\n"
#~ "        Ok(format!(\n"
#~ "            \"Happy Birthday {name}, congratulations with the {years} "
#~ "years!\"\n"
#~ "        ))\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_library {\n"
#~ "    name: \"libbirthdayservice\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    crate_name: \"birthdayservice\",\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_library {\n"
#~ "    name: \"libbirthdayservice\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    crate_name: \"birthdayservice\",\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// Entry point for birthday service.\n"
#~ "fn main() {\n"
#~ "    let birthday_service = BirthdayService;\n"
#~ "    let birthday_service_binder = BnBirthdayService::new_binder(\n"
#~ "        birthday_service,\n"
#~ "        binder::BinderFeatures::default(),\n"
#~ "    );\n"
#~ "    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
#~ "as_binder())\n"
#~ "        .expect(\"Failed to register service\");\n"
#~ "    binder::ProcessState::join_thread_pool()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! 生日服务。\n"
#~ "use birthdayservice::BirthdayService;\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::BnBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// 生日服务的入口。\n"
#~ "fn main() {\n"
#~ "    let birthday_service = BirthdayService;\n"
#~ "    let birthday_service_binder = BnBirthdayService::new_binder(\n"
#~ "        birthday_service,\n"
#~ "        binder::BinderFeatures::default(),\n"
#~ "    );\n"
#~ "    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder."
#~ "as_binder())\n"
#~ "        .expect(\"Failed to register service\");\n"
#~ "    binder::ProcessState::join_thread_pool()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_server\",\n"
#~ "    crate_name: \"birthday_server\",\n"
#~ "    srcs: [\"src/server.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "        \"libbirthdayservice\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_server\",\n"
#~ "    crate_name: \"birthday_server\",\n"
#~ "    srcs: [\"src/server.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "        \"libbirthdayservice\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Birthday service.\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// Connect to the BirthdayService.\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
#~ "StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}\n"
#~ "\n"
#~ "/// Call the birthday service.\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);\n"
#~ "\n"
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to "
#~ "BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! 生日服务。\n"
#~ "use com_example_birthdayservice::aidl::com::example::birthdayservice::"
#~ "IBirthdayService::IBirthdayService;\n"
#~ "use com_example_birthdayservice::binder;\n"
#~ "\n"
#~ "const SERVICE_IDENTIFIER: &str = \"birthdayservice\";\n"
#~ "\n"
#~ "/// 连接到 BirthdayService。\n"
#~ "pub fn connect() -> Result<binder::Strong<dyn IBirthdayService>, binder::"
#~ "StatusCode> {\n"
#~ "    binder::get_interface(SERVICE_IDENTIFIER)\n"
#~ "}\n"
#~ "\n"
#~ "/// 调用生日服务。\n"
#~ "fn main() -> Result<(), binder::Status> {\n"
#~ "    let name = std::env::args()\n"
#~ "        .nth(1)\n"
#~ "        .unwrap_or_else(|| String::from(\"Bob\"));\n"
#~ "    let years = std::env::args()\n"
#~ "        .nth(2)\n"
#~ "        .and_then(|arg| arg.parse::<i32>().ok())\n"
#~ "        .unwrap_or(42);\n"
#~ "\n"
#~ "    binder::ProcessState::start_thread_pool();\n"
#~ "    let service = connect().expect(\"Failed to connect to "
#~ "BirthdayService\");\n"
#~ "    let msg = service.wishHappyBirthday(&name, years)?;\n"
#~ "    println!(\"{msg}\");\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_client\",\n"
#~ "    crate_name: \"birthday_client\",\n"
#~ "    srcs: [\"src/client.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"birthday_client\",\n"
#~ "    crate_name: \"birthday_client\",\n"
#~ "    srcs: [\"src/client.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"com.example.birthdayservice-rust\",\n"
#~ "        \"libbinder_rs\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_logs\",\n"
#~ "    crate_name: \"hello_rust_logs\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"liblog_rust\",\n"
#~ "        \"liblogger\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "    host_supported: true,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"hello_rust_logs\",\n"
#~ "    crate_name: \"hello_rust_logs\",\n"
#~ "    srcs: [\"src/main.rs\"],\n"
#~ "    rustlibs: [\n"
#~ "        \"liblog_rust\",\n"
#~ "        \"liblogger\",\n"
#~ "    ],\n"
#~ "    prefer_rlib: true,\n"
#~ "    host_supported: true,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "//! Rust logging demo.\n"
#~ "\n"
#~ "use log::{debug, error, info};\n"
#~ "\n"
#~ "/// Logs a greeting.\n"
#~ "fn main() {\n"
#~ "    logger::init(\n"
#~ "        logger::Config::default()\n"
#~ "            .with_tag_on_device(\"rust\")\n"
#~ "            .with_min_level(log::Level::Trace),\n"
#~ "    );\n"
#~ "    debug!(\"Starting program.\");\n"
#~ "    info!(\"Things are going fine.\");\n"
#~ "    error!(\"Something went wrong!\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "//! Rust logging demo.\n"
#~ "\n"
#~ "use log::{debug, error, info};\n"
#~ "\n"
#~ "/// Logs a greeting.\n"
#~ "fn main() {\n"
#~ "    logger::init(\n"
#~ "        logger::Config::default()\n"
#~ "            .with_tag_on_device(\"rust\")\n"
#~ "            .with_min_level(log::Level::Trace),\n"
#~ "    );\n"
#~ "    debug!(\"Starting program.\");\n"
#~ "    info!(\"Things are going fine.\");\n"
#~ "    error!(\"Something went wrong!\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -42;\n"
#~ "    let abs_x = unsafe { abs(x) };\n"
#~ "    println!(\"{x}, {abs_x}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "extern \"C\" {\n"
#~ "    fn abs(x: i32) -> i32;\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -42;\n"
#~ "    let abs_x = unsafe { abs(x) };\n"
#~ "    println!(\"{x}, {abs_x}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```c\n"
#~ "#include <stdio.h>\n"
#~ "#include \"libbirthday.h\"\n"
#~ "\n"
#~ "void print_card(const card* card) {\n"
#~ "  printf(\"+--------------\\n\");\n"
#~ "  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
#~ "  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
#~ "  printf(\"+--------------\\n\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c\n"
#~ "#include <stdio.h>\n"
#~ "#include \"libbirthday.h\"\n"
#~ "\n"
#~ "void print_card(const card* card) {\n"
#~ "  printf(\"+--------------\\n\");\n"
#~ "  printf(\"| Happy Birthday %s!\\n\", card->name);\n"
#~ "  printf(\"| Congratulations with the %i years!\\n\", card->years);\n"
#~ "  printf(\"+--------------\\n\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "cc_library {\n"
#~ "    name: \"libbirthday\",\n"
#~ "    srcs: [\"libbirthday.c\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "cc_library {\n"
#~ "    name: \"libbirthday\",\n"
#~ "    srcs: [\"libbirthday.c\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_bindgen {\n"
#~ "    name: \"libbirthday_bindgen\",\n"
#~ "    crate_name: \"birthday_bindgen\",\n"
#~ "    wrapper_src: \"libbirthday_wrapper.h\",\n"
#~ "    source_stem: \"bindings\",\n"
#~ "    static_libs: [\"libbirthday\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_bindgen {\n"
#~ "    name: \"libbirthday_bindgen\",\n"
#~ "    crate_name: \"birthday_bindgen\",\n"
#~ "    wrapper_src: \"libbirthday_wrapper.h\",\n"
#~ "    source_stem: \"bindings\",\n"
#~ "    static_libs: [\"libbirthday\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"print_birthday_card\",\n"
#~ "    srcs: [\"main.rs\"],\n"
#~ "    rustlibs: [\"libbirthday_bindgen\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_binary {\n"
#~ "    name: \"print_birthday_card\",\n"
#~ "    srcs: [\"main.rs\"],\n"
#~ "    rustlibs: [\"libbirthday_bindgen\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "//! Bindgen demo.\n"
#~ "\n"
#~ "use birthday_bindgen::{card, print_card};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
#~ "    let card = card {\n"
#~ "        name: name.as_ptr(),\n"
#~ "        years: 42,\n"
#~ "    };\n"
#~ "    unsafe {\n"
#~ "        print_card(&card as *const card);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "//! Bindgen demo.\n"
#~ "\n"
#~ "use birthday_bindgen::{card, print_card};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let name = std::ffi::CString::new(\"Peter\").unwrap();\n"
#~ "    let card = card {\n"
#~ "        name: name.as_ptr(),\n"
#~ "        years: 42,\n"
#~ "    };\n"
#~ "    unsafe {\n"
#~ "        print_card(&card as *const card);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_test {\n"
#~ "    name: \"libbirthday_bindgen_test\",\n"
#~ "    srcs: [\":libbirthday_bindgen\"],\n"
#~ "    crate_name: \"libbirthday_bindgen_test\",\n"
#~ "    test_suites: [\"general-tests\"],\n"
#~ "    auto_gen_config: true,\n"
#~ "    clippy_lints: \"none\", // Generated file, skip linting\n"
#~ "    lints: \"none\",\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_test {\n"
#~ "    name: \"libbirthday_bindgen_test\",\n"
#~ "    srcs: [\":libbirthday_bindgen\"],\n"
#~ "    crate_name: \"libbirthday_bindgen_test\",\n"
#~ "    test_suites: [\"general-tests\"],\n"
#~ "    auto_gen_config: true,\n"
#~ "    clippy_lints: \"none\", // Generated file, skip linting\n"
#~ "    lints: \"none\",\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "//! Rust FFI demo.\n"
#~ "#![deny(improper_ctypes_definitions)]\n"
#~ "\n"
#~ "use std::os::raw::c_int;\n"
#~ "\n"
#~ "/// Analyze the numbers.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
#~ "    if x < y {\n"
#~ "        println!(\"x ({x}) is smallest!\");\n"
#~ "    } else {\n"
#~ "        println!(\"y ({y}) is probably larger than x ({x})\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "//! Rust FFI demo.\n"
#~ "#![deny(improper_ctypes_definitions)]\n"
#~ "\n"
#~ "use std::os::raw::c_int;\n"
#~ "\n"
#~ "/// Analyze the numbers.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn analyze_numbers(x: c_int, y: c_int) {\n"
#~ "    if x < y {\n"
#~ "        println!(\"x ({x}) is smallest!\");\n"
#~ "    } else {\n"
#~ "        println!(\"y ({y}) is probably larger than x ({x})\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```c\n"
#~ "#ifndef ANALYSE_H\n"
#~ "#define ANALYSE_H\n"
#~ "\n"
#~ "extern \"C\" {\n"
#~ "void analyze_numbers(int x, int y);\n"
#~ "}\n"
#~ "\n"
#~ "#endif\n"
#~ "```"
#~ msgstr ""
#~ "```c\n"
#~ "#ifndef ANALYSE_H\n"
#~ "#define ANALYSE_H\n"
#~ "\n"
#~ "extern \"C\" {\n"
#~ "void analyze_numbers(int x, int y);\n"
#~ "}\n"
#~ "\n"
#~ "#endif\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_ffi {\n"
#~ "    name: \"libanalyze_ffi\",\n"
#~ "    crate_name: \"analyze_ffi\",\n"
#~ "    srcs: [\"analyze.rs\"],\n"
#~ "    include_dirs: [\".\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_ffi {\n"
#~ "    name: \"libanalyze_ffi\",\n"
#~ "    crate_name: \"analyze_ffi\",\n"
#~ "    srcs: [\"analyze.rs\"],\n"
#~ "    include_dirs: [\".\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```c\n"
#~ "#include \"analyze.h\"\n"
#~ "\n"
#~ "int main() {\n"
#~ "  analyze_numbers(10, 20);\n"
#~ "  analyze_numbers(123, 123);\n"
#~ "  return 0;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```c\n"
#~ "#include \"analyze.h\"\n"
#~ "\n"
#~ "int main() {\n"
#~ "  analyze_numbers(10, 20);\n"
#~ "  analyze_numbers(123, 123);\n"
#~ "  return 0;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "cc_binary {\n"
#~ "    name: \"analyze_numbers\",\n"
#~ "    srcs: [\"main.c\"],\n"
#~ "    static_libs: [\"libanalyze_ffi\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "cc_binary {\n"
#~ "    name: \"analyze_numbers\",\n"
#~ "    srcs: [\"main.c\"],\n"
#~ "    static_libs: [\"libanalyze_ffi\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "At this point, the instructor should switch to the [CXX tutorial](https://"
#~ "cxx.rs/tutorial.html)."
#~ msgstr ""
#~ "此时，讲师应该该切换到 [CXX tutorial](https://cxx.rs/tutorial.html)。"

#~ msgid "Walk the students through the tutorial step by step."
#~ msgstr "逐步引导学生按照教程一步步操作。"

#~ msgid ""
#~ "Highlight how CXX presents a clean interface without unsafe code in _both "
#~ "languages_."
#~ msgstr "突出展示 CXX 在 _两种语言_ 中都提供了一个没有不安全代码的干净接口。"

#~ msgid ""
#~ "Explain how a Rust `String` cannot map to a C++ `std::string` (the latter "
#~ "does not uphold the UTF-8 invariant). Show that despite being different "
#~ "types, `rust::String` in C++ can be easily constructed from a C++ `std::"
#~ "string`, making it very ergonomic to use."
#~ msgstr ""
#~ "解释 Rust 的 `String` 无法直接映射到 C++ 的 `std::string `（后者不符合"
#~ "UTF-8不变性）。展示尽管类型不同，但在 C++ 中，可以很容易地从 C++ 的 `std::"
#~ "string` 构造 `rust::String` ，使得使用起来非常方便。"

#~ msgid ""
#~ "Explain that a Rust function returning `Result<T, E>` becomes a function "
#~ "which throws a `E` exception in C++ (and vice versa)."
#~ msgstr ""
#~ "解释 Rust 中返回 `Result<T, E> ` 的函数在 C++ 中会变成抛出 `E` 异常的函数"
#~ "（反之亦然）。"

#~ msgid ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI demo.\n"
#~ "\n"
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;\n"
#~ "\n"
#~ "/// HelloWorld::hello method implementation.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"system\" fn Java_HelloWorld_hello(\n"
#~ "    env: JNIEnv,\n"
#~ "    _class: JClass,\n"
#~ "    name: JString,\n"
#~ ") -> jstring {\n"
#~ "    let input: String = env.get_string(name).unwrap().into();\n"
#~ "    let greeting = format!(\"Hello, {input}!\");\n"
#~ "    let output = env.new_string(greeting).unwrap();\n"
#~ "    output.into_inner()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,compile_fail\n"
#~ "//! Rust <-> Java FFI demo.\n"
#~ "\n"
#~ "use jni::objects::{JClass, JString};\n"
#~ "use jni::sys::jstring;\n"
#~ "use jni::JNIEnv;\n"
#~ "\n"
#~ "/// HelloWorld::hello method implementation.\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"system\" fn Java_HelloWorld_hello(\n"
#~ "    env: JNIEnv,\n"
#~ "    _class: JClass,\n"
#~ "    name: JString,\n"
#~ ") -> jstring {\n"
#~ "    let input: String = env.get_string(name).unwrap().into();\n"
#~ "    let greeting = format!(\"Hello, {input}!\");\n"
#~ "    let output = env.new_string(greeting).unwrap();\n"
#~ "    output.into_inner()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "rust_ffi_shared {\n"
#~ "    name: \"libhello_jni\",\n"
#~ "    crate_name: \"hello_jni\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    rustlibs: [\"libjni\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "rust_ffi_shared {\n"
#~ "    name: \"libhello_jni\",\n"
#~ "    crate_name: \"hello_jni\",\n"
#~ "    srcs: [\"src/lib.rs\"],\n"
#~ "    rustlibs: [\"libjni\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);\n"
#~ "\n"
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        String output = HelloWorld.hello(\"Alice\");\n"
#~ "        System.out.println(output);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "class HelloWorld {\n"
#~ "    private static native String hello(String name);\n"
#~ "\n"
#~ "    static {\n"
#~ "        System.loadLibrary(\"hello_jni\");\n"
#~ "    }\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        String output = HelloWorld.hello(\"Alice\");\n"
#~ "        System.out.println(output);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "java_binary {\n"
#~ "    name: \"helloworld_jni\",\n"
#~ "    srcs: [\"HelloWorld.java\"],\n"
#~ "    main_class: \"HelloWorld\",\n"
#~ "    required: [\"libhello_jni\"],\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "java_binary {\n"
#~ "    name: \"helloworld_jni\",\n"
#~ "    srcs: [\"HelloWorld.java\"],\n"
#~ "    main_class: \"HelloWorld\",\n"
#~ "    required: [\"libhello_jni\"],\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    thread::spawn(|| {\n"
#~ "        for i in 1..10 {\n"
#~ "            println!(\"Count in thread: {i}!\");\n"
#~ "            thread::sleep(Duration::from_millis(5));\n"
#~ "        }\n"
#~ "    });\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    thread::spawn(|| {\n"
#~ "        for i in 1..10 {\n"
#~ "            println!(\"Count in thread: {i}!\");\n"
#~ "            thread::sleep(Duration::from_millis(5));\n"
#~ "        }\n"
#~ "    });\n"
#~ "\n"
#~ "    for i in 1..5 {\n"
#~ "        println!(\"Main thread: {i}\");\n"
#~ "        thread::sleep(Duration::from_millis(5));\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn foo() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    foo();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::spawn(|| {\n"
#~ "        println!(\"Length: {}\", s.len());\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::scope(|scope| {\n"
#~ "        scope.spawn(|| {\n"
#~ "            println!(\"Length: {}\", s.len());\n"
#~ "        });\n"
#~ "    });\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let s = String::from(\"Hello\");\n"
#~ "\n"
#~ "    thread::scope(|scope| {\n"
#~ "        scope.spawn(|| {\n"
#~ "            println!(\"Length: {}\", s.len());\n"
#~ "        });\n"
#~ "    });\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    tx.send(10).unwrap();\n"
#~ "    tx.send(20).unwrap();\n"
#~ "\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "\n"
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    tx.send(10).unwrap();\n"
#~ "    tx.send(20).unwrap();\n"
#~ "\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "\n"
#~ "    let tx2 = tx.clone();\n"
#~ "    tx2.send(30).unwrap();\n"
#~ "    println!(\"Received: {:?}\", rx.recv());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::channel();\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::mpsc;\n"
#~ "use std::thread;\n"
#~ "use std::time::Duration;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let (tx, rx) = mpsc::sync_channel(3);\n"
#~ "\n"
#~ "    thread::spawn(move || {\n"
#~ "        let thread_id = thread::current().id();\n"
#~ "        for i in 1..10 {\n"
#~ "            tx.send(format!(\"Message {i}\")).unwrap();\n"
#~ "            println!(\"{thread_id:?}: sent Message {i}\");\n"
#~ "        }\n"
#~ "        println!(\"{thread_id:?}: done\");\n"
#~ "    });\n"
#~ "    thread::sleep(Duration::from_millis(100));\n"
#~ "\n"
#~ "    for msg in rx.iter() {\n"
#~ "        println!(\"Main: got {msg}\");\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(vec![10, 20, 30]);\n"
#~ "    let mut handles = Vec::new();\n"
#~ "    for _ in 1..5 {\n"
#~ "        let v = Arc::clone(&v);\n"
#~ "        handles.push(thread::spawn(move || {\n"
#~ "            let thread_id = thread::current().id();\n"
#~ "            println!(\"{thread_id:?}: {v:?}\");\n"
#~ "        }));\n"
#~ "    }\n"
#~ "\n"
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::thread;\n"
#~ "use std::sync::Arc;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(vec![10, 20, 30]);\n"
#~ "    let mut handles = Vec::new();\n"
#~ "    for _ in 1..5 {\n"
#~ "        let v = Arc::clone(&v);\n"
#~ "        handles.push(thread::spawn(move || {\n"
#~ "            let thread_id = thread::current().id();\n"
#~ "            println!(\"{thread_id:?}: {v:?}\");\n"
#~ "        }));\n"
#~ "    }\n"
#~ "\n"
#~ "    handles.into_iter().for_each(|h| h.join().unwrap());\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::Mutex;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Mutex::new(vec![10, 20, 30]);\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut guard = v.lock().unwrap();\n"
#~ "        guard.push(40);\n"
#~ "    }\n"
#~ "\n"
#~ "    println!(\"v: {:?}\", v.lock().unwrap());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "// use std::sync::{Arc, Mutex};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let handle = thread::spawn(|| {\n"
#~ "        v.push(10);\n"
#~ "    });\n"
#~ "    v.push(1000);\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable,compile_fail\n"
#~ "use std::thread;\n"
#~ "// use std::sync::{Arc, Mutex};\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = vec![10, 20, 30];\n"
#~ "    let handle = thread::spawn(|| {\n"
#~ "        v.push(10);\n"
#~ "    });\n"
#~ "    v.push(1000);\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,editable\n"
#~ "use std::sync::{Arc, Mutex};\n"
#~ "use std::thread;\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let v = Arc::new(Mutex::new(vec![10, 20, 30]));\n"
#~ "\n"
#~ "    let v2 = Arc::clone(&v);\n"
#~ "    let handle = thread::spawn(move || {\n"
#~ "        let mut v2 = v2.lock().unwrap();\n"
#~ "        v2.push(10);\n"
#~ "    });\n"
#~ "\n"
#~ "    {\n"
#~ "        let mut v = v.lock().unwrap();\n"
#~ "        v.push(1000);\n"
#~ "    }\n"
#~ "\n"
#~ "    handle.join().unwrap();\n"
#~ "\n"
#~ "    println!(\"v: {v:?}\");\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "concurrency:"
#~ msgstr "并发"

#, fuzzy
#~ msgid "constant:"
#~ msgstr "`const`"

#, fuzzy
#~ msgid "enumeration:"
#~ msgstr "实现"

#, fuzzy
#~ msgid "error handling:"
#~ msgstr "错误处理"

#, fuzzy
#~ msgid "garbage collector:"
#~ msgstr "垃圾回收"

#, fuzzy
#~ msgid "generics:"
#~ msgstr "泛型"

#, fuzzy
#~ msgid "integration test:"
#~ msgstr "集成测试"

#, fuzzy
#~ msgid "main function:"
#~ msgstr "调用 Unsafe 函数"

#, fuzzy
#~ msgid "memory leak:"
#~ msgstr "内存泄漏。"

#, fuzzy
#~ msgid "method:"
#~ msgstr "方法"

#, fuzzy
#~ msgid "module:"
#~ msgstr "模块"

#~ msgid "mutable:"
#~ msgstr "可变："

#, fuzzy
#~ msgid "ownership:"
#~ msgstr "所有权"

#, fuzzy
#~ msgid "panic:"
#~ msgstr "Panics"

#, fuzzy
#~ msgid "receiver:"
#~ msgstr "驱动程序"

#, fuzzy
#~ msgid "reference counting:"
#~ msgstr "解引用原始指针。"

#, fuzzy
#~ msgid "standard library:"
#~ msgstr "标准库"

#, fuzzy
#~ msgid "static:"
#~ msgstr "`static`"

#, fuzzy
#~ msgid "struct:"
#~ msgstr "结构体"

#, fuzzy
#~ msgid "thread:"
#~ msgstr "线程"

#, fuzzy
#~ msgid "thread safety:"
#~ msgstr "线程"

#, fuzzy
#~ msgid "trait:"
#~ msgstr "特征"

#, fuzzy
#~ msgid "union:"
#~ msgstr "联合体"

#, fuzzy
#~ msgid "unit test:"
#~ msgstr "单元测试"

#, fuzzy
#~ msgid "variable:\\"
#~ msgstr "变量"

#~ msgid "You will find solutions to the exercises on the following pages."
#~ msgstr "您将在下面的页面找到练习的解答。"

#~ msgid ""
#~ "Feel free to ask questions about the solutions [on GitHub](https://github."
#~ "com/google/comprehensive-rust/discussions). Let us know if you have a "
#~ "different or better solution than what is presented here."
#~ msgstr ""
#~ "欢迎您在 [GitHub](https://github.com/google/comprehensive-rust/"
#~ "discussions) 上提问关于解决方案的问题。如果您有与此处呈现的不同或更好的解"
#~ "决方案，请告诉我们。"

#~ msgid "Day 1 Morning Exercises"
#~ msgstr "第一天上午的练习"

#~ msgid "([back to exercise](for-loops.md))"
#~ msgstr "([返回练习](for-loops.md))"

#~ msgid "Bonus question"
#~ msgstr "附加问题"

#~ msgid ""
#~ "It requires more advanced concepts. It might seem that we could use a "
#~ "slice-of-slices (`&[&[i32]]`) as the input type to transpose and thus "
#~ "make our function handle any size of matrix. However, this quickly breaks "
#~ "down: the return type cannot be `&[&[i32]]` since it needs to own the "
#~ "data you return."
#~ msgstr ""
#~ "这需要更高级的概念。看起来，我们可以使用切片的切片（`&[&[i32]]`）作为输入"
#~ "类型来进行转置，从而使我们的函数能够处理任意大小的矩阵。然而，这很快就会崩"
#~ "溃：返回类型不能是 `&[&[i32]]`，因为它需要拥有您返回的数据。"

#~ msgid ""
#~ "You can attempt to use something like `Vec<Vec<i32>>`, but this doesn't "
#~ "work out-of-the-box either: it's hard to convert from `Vec<Vec<i32>>` to "
#~ "`&[&[i32]]` so now you cannot easily use `pretty_print` either."
#~ msgstr ""
#~ "您可以尝试使用类似 `Vec<Vec<i32>>` 的方式，但这也无法直接工作：从 "
#~ "`Vec<Vec<i32>>` 转换为 `&[&[i32]]` 很困难，因此您现在也不能轻松使用 "
#~ "`pretty_print`。"

#~ msgid ""
#~ "Once we get to traits and generics, we'll be able to use the [`std::"
#~ "convert::AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) "
#~ "trait to abstract over anything that can be referenced as a slice."
#~ msgstr ""
#~ "了解 trait 和泛型后，我们就可以使用[“std::convert::AsRef”](https://doc."
#~ "rust-lang.org/std/convert/trait.AsRef.html)trait 来抽象化任何可作为 Slice "
#~ "引用的内容了。"

#~ msgid ""
#~ "In addition, the type itself would not enforce that the child slices are "
#~ "of the same length, so such variable could contain an invalid matrix."
#~ msgstr ""
#~ "此外，类型本身不会强制要求子切片具有相同的长度，因此这样的变量可能包含一个"
#~ "无效的矩阵。"

#~ msgid "Day 1 Afternoon Exercises"
#~ msgstr "第一天下午的练习"

#~ msgid "([back to exercise](luhn.md))"
#~ msgstr "([返回练习](luhn.md))"

#, fuzzy
#~ msgid "Pattern matching"
#~ msgstr "模式匹配"

#~ msgid "Day 2 Morning Exercises"
#~ msgstr "第二天上午的练习"

#~ msgid "Designing a Library"
#~ msgstr "设计一个库"

#~ msgid "([back to exercise](book-library.md))"
#~ msgstr "([返回练习](book-library.md))"

#, fuzzy
#~ msgid "([back to exercise](health-statistics.md))"
#~ msgstr "([返回练习](rtc.md))"

#~ msgid "([back to exercise](strings-iterators.md))"
#~ msgstr "([返回练习](strings-iterators.md))"

#~ msgid "Day 3 Morning Exercise"
#~ msgstr "第三天上午的练习"

#~ msgid "([back to exercise](simple-gui.md))"
#~ msgstr "([返回练习](simple-gui.md))"

#~ msgid "([back to exercise](points-polygons.md))"
#~ msgstr "([返回练习](points-polygons.md))"

#~ msgid "Day 3 Afternoon Exercises"
#~ msgstr "第三天下午的练习"

#~ msgid "([back to exercise](safe-ffi-wrapper.md))"
#~ msgstr "([返回练习](safe-ffi-wrapper.md))"

#, fuzzy
#~ msgid "Why Rust?"
#~ msgstr "异步 Rust"

#, fuzzy
#~ msgid "Novel Control Flow"
#~ msgstr "Furture 控制流"

#, fuzzy
#~ msgid "async/await"
#~ msgstr "关于 async/await 的误区"

#, fuzzy
#~ msgid "control flow:"
#~ msgstr "Furture 控制流"

#~ msgid "\"127.0.0.1:6142\""
#~ msgstr "\"127.0.0.1:6142\""
